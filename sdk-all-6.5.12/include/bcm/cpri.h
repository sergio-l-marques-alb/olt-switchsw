/*
 * $Id: $
 * 
 * $Copyright: (c) 2017 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_CPRI_H__
#define __BCM_CPRI_H__

#include <bcm/types.h>
#include <shared/cpri.h>

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize the CPRI subsystem. */
extern int bcm_cpri_init(
    int unit);

/* De-initialize the CPRI subsystem. */
extern int bcm_cpri_detach(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Port types */
typedef enum bcm_cpri_port_type_e {
    bcmCpriPortTypeCpri = 0,    /*  */
    bcmCpriPortTypeRsvd4 = 1    /*  */
} bcm_cpri_port_type_t;

/* CPRI Port speeds */
typedef enum bcm_cpri_port_speed_e {
    bcmCpriPortSpeed1228p8 = 0,     /*  */
    bcmCpriPortSpeed2457p6 = 1,     /*  */
    bcmCpriPortSpeed3072p0 = 2,     /*  */
    bcmCpriPortSpeed4915p2 = 3,     /*  */
    bcmCpriPortSpeed6144p0 = 4,     /*  */
    bcmCpriPortSpeed9830p4 = 5,     /*  */
    bcmCpriPortSpeed10137p6 = 6,    /*  */
    bcmCpriPortSpeed12165p12 = 7,   /*  */
    bcmCpriPortSpeed24330p24 = 8    /*  */
} bcm_cpri_port_speed_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configures the Rx speed of the specified CPRI port. */
extern int bcm_cpri_port_rx_speed_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_port_type_t port_type, 
    bcm_cpri_port_speed_t speed);

/* Retrieves the Rx speed of the specified CPRI port. */
extern int bcm_cpri_port_rx_speed_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_port_type_t *port_type, 
    bcm_cpri_port_speed_t *speed);

/* Configures the Tx speed of the specified CPRI port. */
extern int bcm_cpri_port_tx_speed_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_port_type_t port_type, 
    bcm_cpri_port_speed_t speed);

/* Retrieves the Tx speed of the specified CPRI port. */
extern int bcm_cpri_port_tx_speed_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_port_type_t *port_type, 
    bcm_cpri_port_speed_t *speed);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Frame synchroniation modes */
typedef enum bcm_cpri_frame_sync_mode_e {
    bcmCpriFrameSyncModeHyper = 0,  /*  */
    bcmCpriFrameSyncModeRadio = 1,  /*  */
    bcmCpriFrameSyncModeBasic = 2   /*  */
} bcm_cpri_frame_sync_mode_t;

/* CPRI Frame truncation modes */
typedef enum bcm_cpri_frame_trunc_mode_e {
    bcmCpriFrameTruncMode15_to_16 = 0,  /*  */
    bcmCpriFrameTruncModeAdd_0 = 1,     /*  */
    bcmCpriFrameTruncMode16_to_15 = 2,  /*  */
    bcmCpriFrameTruncModeAdd_1 = 3      /*  */
} bcm_cpri_frame_trunc_mode_t;

/* CPRI Frame compression modes */
typedef enum bcm_cpri_frame_compress_mode_e {
    bcmCpriFrameCompressModeCompress = 0, /*  */
    bcmCpriFrameCompressModeDecompress = 1, /*  */
    bcmCpriFrameCompressModeNone = 2    /*  */
} bcm_cpri_frame_compress_mode_t;

/* CPRI Agnostic mode configuration */
typedef struct bcm_cpri_agnostic_config_s {
    int start_bit;                      /* Start bit position of basic frame */
    int num_bits;                       /* Number of bits in AxC */
    int map_method;                     /* Mapping method */
    int stuffing_count;                 /* Nst for method#1 bits */
    int container_blk_count;            /* Container block count */
    int sample_size_M;                  /* Sample size */
    int Nv;                             /* Nv value for method 3 */
    int Na;                             /* Na value for method 3 */
    int Nc;                             /* Numnber of containers in a basic
                                           frame - method 3 only */
    bcm_cpri_frame_sync_mode_t frame_sync_mode; /* CPRI Frame synchronization modes */
    int basic_frame_offset;             /* Frame number offset of basic frame */
    int radio_frame_offset;             /* Frame number offset of radio frame */
    int hyper_frame_offset;             /* Frame number offset of hyper frame */
    int num_samples_per_roe_pkt;        /* Number of samples in RoE payload */
    bcm_cpri_frame_trunc_mode_t truncation_mode; /*  */
    bcm_cpri_frame_compress_mode_t compress_mode; /*  */
    uint8 priority;                     /* Priority 0-3 */
    uint8 rx_queue_size;                /* Queue size in bytes */
    uint16 cycle_size;                  /* Tx cycle size */
    uint8 queue_number;                 /* Tx queue number */
    uint16 packet_size;                 /* Tx Packet size */
} bcm_cpri_agnostic_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure the CPRI port in agnostic mode. */
extern int bcm_cpri_port_axc_agnostic_mode_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_agnostic_config_t *config);

/* Enables agnostic mode in both Tx and Rx direction. */
extern int bcm_cpri_port_axc_agnostic_mode_enable_set(
    int unit, 
    bcm_gport_t port, 
    int enable);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Framer stages */
typedef enum bcm_cpri_stage_e {
    bcmCpriStageRxParser = 0,   /*  */
    bcmCpriStageTxAssembler = 1 /*  */
} bcm_cpri_stage_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Activates the shadow basic frame table. */
extern int bcm_cpri_port_stage_activate(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_stage_t stage);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Axc Framer Configuration */
typedef struct bcm_cpri_axc_frame_info_s {
    int start_bit;                      /* Start bit position of basic frame */
    int num_bits;                       /* Number of bits in AxC */
    int map_method;                     /* Mapping method */
    int stuffing_count;                 /* Nst for method#1 bits */
    int K;                              /* Container block count */
    int sample_size_M;                  /* Sample size */
    int Nv;                             /* Nv value for method 3 */
    int Na;                             /* Na value for method 3 */
    int Nc;                             /* Numnber of containers in a basic
                                           frame - method 3 only */
    bcm_cpri_frame_sync_mode_t frame_sync_mode; /* CPRI Frame synchronization modes */
    int basic_frame_offset;             /* Frame number offset of basic frame */
    int radio_frame_offset;             /* Frame number offset of radio frame */
    int hyper_frame_offset;             /* Frame number offset of hyper frame */
    int num_samples_per_roe_pkt;        /* Number of samples in RoE payload */
    int truncation_enable;              /* True/False */
    bcm_cpri_frame_trunc_mode_t truncation_mode; /*  */
    bcm_cpri_frame_compress_mode_t compress_mode; /*  */
    uint8 priority;                     /* Priority 0-3 */
    uint16 rx_queue_size;               /* Queue size in bytes */
    uint16 cycle_size;                  /* Tx cycle size */
} bcm_cpri_axc_frame_info_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Sets up the AxC (method 1) or AxC group (method 3) on a CPRI port in
 * the Rx datapath.
 */
extern int bcm_cpri_port_rx_axc_frame_add(
    int unit, 
    bcm_gport_t port, 
    int axc_id, 
    bcm_cpri_axc_frame_info_t *axc_info);

/* 
 * Retrieves the AxC (method 1) or AxC group (method 3) in the Rx datapth
 * on a CPRI port.
 */
extern int bcm_cpri_port_rx_axc_frame_get(
    int unit, 
    bcm_gport_t port, 
    int axc_id, 
    bcm_cpri_axc_frame_info_t *axc_info);

/* 
 * Retrieves the configured list of AxC (method 1) or AxC group (method
 * 3) on a CPRI port.
 */
extern int bcm_cpri_port_rx_axc_frame_get_all(
    int unit, 
    bcm_gport_t port, 
    int max_count, 
    int *axc_id_list, 
    bcm_cpri_axc_frame_info_t *axc_info_list, 
    int *axc_count);

/* 
 * Remove the specified AxC (method 1) or AxC group (method 3) on a CPRI
 * port.
 */
extern int bcm_cpri_port_rx_axc_frame_delete(
    int unit, 
    bcm_gport_t port, 
    int axc_id);

/* 
 * Sets up the AxC (method 1) or AxC group (method 3) in the Tx datapath
 * on a CPRI port.
 */
extern int bcm_cpri_port_tx_axc_frame_add(
    int unit, 
    bcm_gport_t port, 
    int axc_id, 
    bcm_cpri_axc_frame_info_t *axc_info);

/* 
 * Retrieves the AxC (method 1) or AxC group (method 3) in the Tx datapth
 * on a CPRI port.
 */
extern int bcm_cpri_port_tx_axc_frame_get(
    int unit, 
    bcm_gport_t port, 
    int axc_id, 
    bcm_cpri_axc_frame_info_t *axc_info);

/* 
 * Retrieves the configured list of AxC (method 1) or AxC group (method
 * 3) in the Tx datapath on a CPRI port.
 */
extern int bcm_cpri_port_tx_axc_frame_get_all(
    int unit, 
    bcm_gport_t port, 
    int axc_id, 
    int max_count, 
    bcm_cpri_axc_frame_info_t *axc_info_list, 
    int *axc_count);

/* 
 * Remove the specified AxC (method 1) or AxC group (method 3) on a CPRI
 * port.
 */
extern int bcm_cpri_port_tx_axc_frame_delete(
    int unit, 
    bcm_gport_t port, 
    int axc_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Encap flags */
#define BCM_CPRI_ENCAP_USE_TAG_ID_FOR_VLAN  0x1        
#define BCM_CPRI_ENCAP_USE_TAG_ID_FOR_FLOWID 0x2        
#define BCM_CPRI_ENCAP_USE_OPCODE           0x4        

/* CPRI VLAN Types */
typedef enum bcm_cpri_vlan_type_e {
    bcmCpriVlanTypeNone = 0,        /*  */
    bcmCpriVlanTypeSingle = 1,      /*  */
    bcmCpriVlanTypeQinQ = 2,        /*  */
    bcmCpriVlanTypeSingleTable1 = 3 /*  */
} bcm_cpri_vlan_type_t;

/* CPRI RoE Subtypes */
typedef enum bcm_cpri_roe_subtype_e {
    bcmCpriRoESubtypeControl = 0,   /*  */
    bcmCpriRoESubtypeResv = 1,      /*  */
    bcmCpriRoESubtypeAgnostic = 2,  /*  */
    bcmCpriRoESubtypeCpriData = 3,  /*  */
    bcmCpriRoESubtypeNative = 4,    /*  */
    bcmCpriRoESubtypeSlowCM = 0     /*  */
} bcm_cpri_roe_subtype_t;

/* CPRI RoE Opcodes */
typedef enum bcm_cpri_roe_opcode_e {
    bcmCpriRoEOpcodeOamTlv = 0,     /*  */
    bcmCpriRoEOpcodeCtrlAxC = 1,    /*  */
    bcmCpriRoEOpcodeVSD = 2,        /*  */
    bcmCpriRoEOpcodeTiming = 3      /*  */
} bcm_cpri_roe_opcode_t;

/* CPRI Header Encapsulation types */
typedef enum bcm_cpri_hdr_encap_type_e {
    bcmCpriHdrEncapTypeRoe = 0,     /* ROE encapsulation type */
    bcmCpriHdrEncapTypeNone = 1,    /* no ROE encapsulation */
    bcmCpriHdrEncapTypeCount = 2    /* should be last */
} bcm_cpri_hdr_encap_type_t;

/* CPRI Encap Information */
typedef struct bcm_cpri_encap_info_s {
    uint32 flags;                       /* CPRI Encap Info flags */
    uint8 roe_flow_id;                  /*  */
    bcm_cpri_roe_subtype_t subtype;     /* RoE subtype */
    bcm_cpri_hdr_encap_type_t hdr_type; /* CPRI header encapsulation type */
    int roe_ordering_info_index;        /* RoE ordering Info index */
    int macda_index;                    /* Index to MAC DA address */
    int macsa_index;                    /* Index to MAC SA address */
    bcm_cpri_vlan_type_t vlan_type;     /* CPRI Vlan type */
    int vlan0_idx;                      /*  */
    int vlan1_idx;                      /*  */
    int vlan0_priority;                 /*  */
    int vlan1_priority;                 /*  */
    uint8 vlan_ethertype_idx;           /*  */
    bcm_cpri_roe_opcode_t opcode;       /* RoE opcode */
} bcm_cpri_encap_info_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Program the specified entry into Encapsulation header table. */
extern int bcm_cpri_port_encap_set(
    int unit, 
    bcm_gport_t port, 
    int queue_num, 
    bcm_cpri_encap_info_t *encap_config);

/* Retrieve the encapsulation header info for a given axc ID. */
extern int bcm_cpri_port_encap_get(
    int unit, 
    bcm_gport_t port, 
    int queue_num, 
    bcm_cpri_encap_info_t *encap_config);

/* Remove the encapsulation header info for a given axc ID. */
extern int bcm_cpri_port_encap_clear(
    int unit, 
    bcm_gport_t port, 
    int queue_num);

/* Clears the encapsulation header info for all axc. */
extern int bcm_cpri_port_encap_clear_all(
    int unit, 
    bcm_gport_t port);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Encapsulation VLAN configuration */
typedef struct bcm_cpri_encap_vlan_config_s {
    uint32 ethertype_vlan_tagged;   /*  */
    uint32 ethertype_vlan_qinq;     /*  */
    uint8 qinq_select_outer;        /*  */
    uint32 roe_ethertype_0;         /*  */
    uint32 roe_ethertype_1;         /*  */
} bcm_cpri_encap_vlan_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set the VLAN ethertype config for encapsulation header . */
extern int bcm_cpri_port_encap_vlan_config_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_encap_vlan_config_t *vlan_config);

/* Retrieve the VLAN ethertype config for encapsulation header . */
extern int bcm_cpri_port_encap_vlan_config_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_encap_vlan_config_t *vlan_config);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Encap RoE Ordering Info Info types */
typedef enum bcm_cpri_roe_info_type_e {
    bcmCpriRoEInfoTypeUseSeq = 0,       /*  */
    bcmCpriRoEInfoTypeBfnForQcnt = 1,   /*  */
    bcmCpriRoEInfoTypePInfo = 2         /*  */
} bcm_cpri_roe_info_type_t;

/* CPRI Encap RoE Ordering Info Increment types */
typedef enum bcm_cpri_roe_incr_type_e {
    bcmCpriRoEIncrTypeNone = 0,         /*  */
    bcmCpriRoEIncrTypeConstant = 1,     /*  */
    bcmCpriRoEIncrTypePayloadSize = 2   /*  */
} bcm_cpri_roe_incr_type_t;

/* CPRI Encap RoE Ordering Information */
typedef struct bcm_cpri_encap_roe_oi_s {
    bcm_cpri_roe_info_type_t info_type; /*  */
    bcm_cpri_roe_incr_type_t p_seq_incr; /* seqNumPIncProp */
    bcm_cpri_roe_incr_type_t q_seq_incr; /* seqNumQIncProp */
    uint32 pcnt_size;                   /* Number in the range 1 to 32 */
    uint32 pcnt_increment;              /* seqNumPInc */
    uint32 pcnt_max;                    /* seqNumPMax */
    uint32 qcnt_size;                   /* Number in the range 0 to (32-pcnt) */
    uint32 qcnt_increment;              /* seqNumQInc */
    uint32 qcnt_max;                    /* seqNumQMax */
    uint32 seq_rsvd;                    /* seqNumRsvd Value */
} bcm_cpri_encap_roe_oi_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set the ordering info for encapsulation header. */
extern int bcm_cpri_port_encap_roe_ordering_info_set(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_cpri_encap_roe_oi_t *ordering_info);

/* Get the ordering info for encapsulation header. */
extern int bcm_cpri_port_encap_roe_ordering_info_get(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_cpri_encap_roe_oi_t *ordering_info);

/* Get the ordering info for encapsulation header. */
extern int bcm_cpri_port_encap_roe_ordering_info_clear(
    int unit, 
    bcm_gport_t port, 
    int index);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Encap RoE Ordering Info Sequence Offset configuration */
typedef struct bcm_cpri_roe_oi_seq_offset_s {
    uint32 pcnt_size;   /*  */
    uint32 pcnt_offset; /*  */
    uint32 qcnt_size;   /*  */
    uint32 qcnt_offset; /*  */
} bcm_cpri_roe_oi_seq_offset_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure sequence offset info associated with the ordering info. */
extern int bcm_cpri_port_encap_roe_ordering_sequence_offset_set(
    int unit, 
    bcm_gport_t port, 
    int queue, 
    int control, 
    bcm_cpri_roe_oi_seq_offset_t *seq_offset);

/* Get sequence offset info associated with the ordering info. */
extern int bcm_cpri_port_encap_roe_ordering_sequence_offset_get(
    int unit, 
    bcm_gport_t port, 
    int queue, 
    int control, 
    bcm_cpri_roe_oi_seq_offset_t *seq_offset);

/* Set the encap entry MAC DA. */
extern int bcm_cpri_port_encap_roe_entry_macda_set(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_mac_t macaddr);

/* Set the encap entry MAC SA. */
extern int bcm_cpri_port_encap_roe_entry_macsa_set(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_mac_t macaddr);

/* Get the encap entry MAC DA. */
extern int bcm_cpri_port_encap_roe_entry_macda_get(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_mac_t macaddr);

/* Get the encap entry MAC SA. */
extern int bcm_cpri_port_encap_roe_entry_macsa_get(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_mac_t macaddr);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Vlan flags */
#define BCM_CPRI_VLAN_FLAG_VLAN_0   0x0        
#define BCM_CPRI_VLAN_FLAG_VLAN_1   0x1        

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure VLAN ID for the given the encap entry. */
extern int bcm_cpri_port_encap_roe_entry_vlan_set(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    uint32 index, 
    bcm_vlan_t vlan_id);

/* Get the VLAN ID for the given encap entry. */
extern int bcm_cpri_port_encap_roe_entry_vlan_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    uint32 index, 
    bcm_vlan_t *vlan_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Packet Ethertypes */
typedef enum bcm_cpri_ethertype_e {
    bcmCpriEthertypeRoe = 0,    /*  */
    bcmCpriEthertypeFast = 1,   /*  */
    bcmCpriEthertypeVlan = 2,   /*  */
    bcmCpriEthertypeQinQ = 3    /*  */
} bcm_cpri_ethertype_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set the ethertype for CPRI decap. */
extern int bcm_cpri_port_decap_ethertype_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_ethertype_t type, 
    uint16 tpid);

/* Set the ethertype for CPRI decap. */
extern int bcm_cpri_port_decap_ethertype_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_ethertype_t type, 
    uint16 *tpid);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Decap Flow types */
typedef enum bcm_cpri_decap_flow_type_e {
    bcmCpriDecapFlowTypeIQData = 0,     /*  */
    bcmCpriDecapFlowTypeIQDataWithTimestamp = 1, /*  */
    bcmCpriDecapFlowTypeIQDataWithOpcode = 2, /*  */
    bcmCpriDecapFlowTypeControl = 3     /*  */
} bcm_cpri_decap_flow_type_t;

/* CPRI Decap Flow lookup options */
typedef enum bcm_cpri_decap_flow_lookup_e {
    bcmCpriDecapFlowLookupQueueNum = 0, /*  */
    bcmCpriDecapFlowLookupFlowID = 1,   /*  */
    bcmCpriDecapFlowLookupOpcode = 2    /*  */
} bcm_cpri_decap_flow_lookup_t;

/* CPRI Decap Flow classification information */
typedef struct bcm_cpri_decap_flow_config_s {
    bcm_cpri_decap_flow_type_t flow_type; /*  */
    bcm_cpri_decap_flow_lookup_t lookup_option; /*  */
    int queue_num;                      /*  */
} bcm_cpri_decap_flow_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure flow classification table in CPRI decap. */
extern int bcm_cpri_port_decap_flow_config_set(
    int unit, 
    bcm_gport_t port, 
    uint8 roe_subtype, 
    bcm_cpri_decap_flow_config_t *config);

/* Retrieve flow classification table in CPRI decap. */
extern int bcm_cpri_port_decap_flow_config_get(
    int unit, 
    bcm_gport_t port, 
    uint8 roe_subtype, 
    bcm_cpri_decap_flow_config_t *config);

/* Clear the flow classification table in CPRI decap. */
extern int bcm_cpri_port_decap_flow_config_clear(
    int unit, 
    bcm_gport_t port, 
    uint8 roe_subtype);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Decapsulation RoE Ordering Information */
typedef struct bcm_cpri_decap_roe_oi_s {
    bcm_cpri_roe_info_type_t info_type; /*  */
    uint32 pcnt_size;                   /* Number in the range 1 to 32 */
    uint32 pcnt_increment;              /* seqNumPInc */
    uint32 pcnt_max;                    /* seqNumPMax */
    uint32 p_inc_p2;                    /* seqNumPInc to be power of 2 */
    uint32 p_bias;                      /* Bias for P count */
    uint32 qcnt_size;                   /* Number in the range 0 to (32-pcnt) */
    uint32 qcnt_increment;              /* seqNumQInc */
    uint32 qcnt_max;                    /* seqNumQMax */
    uint32 q_inc_p2;                    /* seqNumQInc to be power of 2 */
    uint32 q_bias;                      /* Bias for Q count */
    uint8 p_ext;                        /* Extended P Counter */
    uint8 gsm_tsn_bitmap;               /* TSN bitmap */
    uint32 pcnt_pkt_count;              /* Maximum pkt count described by P
                                           counter */
    uint32 modulo_2;                    /* Queue Cycle Size is modulo 2 */
    uint32 seq_rsvd;                    /* seqNumRsvd Value */
} bcm_cpri_decap_roe_oi_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set the ordering info for Decapsulation. */
extern int bcm_cpri_port_decap_roe_ordering_info_set(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_cpri_decap_roe_oi_t *ordering_info);

/* Get the ordering info for Decapsulation. */
extern int bcm_cpri_port_decap_roe_ordering_info_get(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_cpri_decap_roe_oi_t *ordering_info);

/* Configure sequence offset info associated with the ordering info. */
extern int bcm_cpri_port_decap_roe_ordering_sequence_offset_set(
    int unit, 
    bcm_gport_t port, 
    int queue, 
    bcm_cpri_roe_oi_seq_offset_t *seq_offset);

/* Get sequence offset info associated with the ordering info. */
extern int bcm_cpri_port_decap_roe_ordering_sequence_offset_get(
    int unit, 
    bcm_gport_t port, 
    int queue, 
    bcm_cpri_roe_oi_seq_offset_t *seq_offset);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Tx TGEN configuration */
typedef struct bcm_cpri_tx_frame_tgen_config_s {
    uint32 tx_tgen_hfn;         /* new hyperframe hfn number on next hyperframe */
    uint32 tx_tgen_bfn;         /* new radio frame bfn number on next radio
                                   frame */
    uint32 tx_tgen_bfn_sel;     /* use cfg_tgen_bfn on next hyperframe or radio
                                   frame */
    uint64 tx_tgen_ts_offset;   /* start frame event after matching this offset */
} bcm_cpri_tx_frame_tgen_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure tgen for port */
extern int bcm_cpri_port_tx_frame_tgen_config_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cpri_tx_frame_tgen_config_t *tgen_config);

/* Enable or disable Tx tgen for port */
extern int bcm_cpri_port_tx_frame_tgen_enable(
    int unit, 
    bcm_gport_t port, 
    int enable);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Rx frame configuration */
typedef struct bcm_rsvd4_rx_frame_config_s {
    int speed_multiple; /* Only values 4 and 8 are supported */
} bcm_rsvd4_rx_frame_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set RSVD4 frame configuration */
extern int bcm_cpri_port_rsvd4_rx_frame_config_set(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_rx_frame_config_t *config);

/* Get RSVD4 frame configuration */
extern int bcm_cpri_port_rsvd4_rx_frame_config_get(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_rx_frame_config_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Rx Config fields */
typedef enum bcm_rsvd4_rx_config_e {
    bcmRsvd4RxConfigDescrambleEnable = 0, /*  */
    bcmRsvd4RxConfigSyncThreshold = 1,  /*  */
    bcmRsvd4RxConfigUnsyncThreshold = 2, /*  */
    bcmRsvd4RxConfigFrameSyncThreshold = 3, /*  */
    bcmRsvd4RxConfigFrameUnsyncThreshold = 4, /*  */
    bcmRsvd4RxConfigBlockSize = 5       /*  */
} bcm_rsvd4_rx_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set RSVD4 frame configuration for debug purpose */
extern int bcm_cpri_port_rsvd4_rx_frame_config_debug_set(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_rx_config_t config_type, 
    uint32 value);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Rx FSM States */
typedef enum bcm_rsvd4_rx_fsm_state_e {
    bcmRsvd4RxFsmStateUnsync = 0,       /*  */
    bcmRsvd4RxFsmStateWaitForSeed = 1,  /*  */
    bcmRsvd4RxFsmStateWaitForK28p7Idles = 2, /*  */
    bcmRsvd4RxFsmStateWaitForFrameSync = 3, /*  */
    bcmRsvd4RxFsmStateFrameSync = 4     /*  */
} bcm_rsvd4_rx_fsm_state_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* To set the RSVD4 state machine to a particular state for debug purpose */
extern int bcm_cpri_port_rsvd4_rx_fsm_state_set(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_rx_fsm_state_t state);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Rx FSM Override parameters */
typedef enum bcm_rsvd4_rx_params_e {
    bcmRsvd4RxParams_Frame_Unsync_T_Invalid_MG_Rcvd = 0, /*  */
    bcmRsvd4RxParams_Frame_Sync_T_Valid_MG_Rcvd = 1, /*  */
    bcmRsvd4RxParams_K_MG_Idles_Rcvd = 2, /*  */
    bcmRsvd4RxParams_Idle_Req_Rcvd = 3, /*  */
    bcmRsvd4RxParams_Idle_Ack_Rcvd = 4, /*  */
    bcmRsvd4RxParams_SeedCapAndVerifyDone = 5 /*  */
} bcm_rsvd4_rx_params_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* To set the RSVD4 state machine to a particular state for debug purpose */
extern int bcm_cpri_port_rsvd4_rx_override_set(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_rx_params_t parameter, 
    int enable, 
    int value);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 TS MSG modes */
typedef enum bcm_rsvd4_msg_ts_mode_e {
    bcmRsvd4MsgTsModeWCDMA = 0, /*  */
    bcmRsvd4MsgTsModeLTE = 1,   /*  */
    bcmRsvd4MsgTsModeGSMDL = 2, /*  */
    bcmRsvd4MsgTsModeGSMUL = 3  /*  */
} bcm_rsvd4_msg_ts_mode_t;

/* RSVD4 Sync modes */
typedef enum bcm_rsvd4_sync_mode_e {
    bcmRsvd4SyncModeNoSync = 0,         /*  */
    bcmRsvd4SyncModeRadioFrame = 1,     /*  */
    bcmRsvd4SyncModeMasterFrame = 2,    /*  */
    bcmRsvd4SyncModeTsNoSync = 3,       /*  */
    bcmRsvd4SyncModeTsRadioFrame = 4,   /*  */
    bcmRsvd4SyncModeTsMasterFrame = 5   /*  */
} bcm_rsvd4_sync_mode_t;

/* RSVD4 Rx Flow configuration */
typedef struct bcm_rsvd4_rx_flow_info_s {
    uint32 mask;                        /*  */
    uint32 match_data;                  /* header data to match */
    uint16 payload_size; 
    uint16 last_payload_index; 
    bcm_rsvd4_msg_ts_mode_t msg_ts_mode; 
    bcm_rsvd4_sync_mode_t sync_mode; 
    uint16 stuffing_count; 
    uint32 message_number_offset; 
    uint16 master_frame_offset; 
    uint16 msg_ts_count; 
    uint16 container_blk_count; 
    uint8 priority; 
    uint32 queue_size; 
    uint8 gsm_pad_size; 
    uint8 gsm_extra_pad_size; 
    uint8 gsm_pad_en; 
    uint8 gsm_ctrl_loc; 
    uint32 axc_id; 
    uint32 last_payload_size; 
    uint8 gsm_tsn_bitmap; 
} bcm_rsvd4_rx_flow_info_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Add RSVD4 Rx Flow data AxC */
extern int bcm_cpri_port_rsvd4_rx_flow_add(
    int unit, 
    bcm_gport_t port, 
    int flow_id, 
    bcm_rsvd4_rx_flow_info_t *flow_info);

/* Delete RSVD4 Rx Flow data AxC */
extern int bcm_cpri_port_rsvd4_rx_flow_delete(
    int unit, 
    bcm_gport_t port, 
    int flow_id);

/* Set RSVD4 Rx master frame sync info */
extern int bcm_cpri_port_rsvd4_rx_bfn_sync_config_set(
    int unit, 
    bcm_gport_t port, 
    uint16 master_frame_count, 
    uint64 master_frame_start);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Tx frame configuration */
typedef struct bcm_rsvd4_tx_frame_config_s {
    uint8 los_enable; 
    uint8 rsvd4_scrambler_seed; 
    int speed_multiple;         /* Only values 4 and 8 are supported */
} bcm_rsvd4_tx_frame_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* RSVD4 Tx frame configuration */
extern int bcm_cpri_port_rsvd4_tx_frame_config_set(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_tx_frame_config_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Tx Config fields */
typedef enum bcm_rsvd4_tx_config_e {
    bcmRsvd4TxConfigForceOffState = 0,  /*  */
    bcmRsvd4TxConfigAckT = 1,           /*  */
    bcmRsvd4TxConfigForceIdleAck = 2,   /*  */
    bcmRsvd4TxConfigLosEnable = 3,      /*  */
    bcmRsvd4TxConfigScrambleEnable = 4, /*  */
    bcmRsvd4TxConfigTransmitterEnable = 5 /*  */
} bcm_rsvd4_tx_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set RSVD4 Tx frame configuration for debug purpose */
extern int bcm_cpri_port_rsvd4_tx_frame_config_debug_set(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_tx_config_t config_type, 
    uint32 value);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Tx FSM States */
typedef enum bcm_rsvd4_tx_fsm_state_e {
    bcmRsvd4TxFsmStateOff = 0,      /*  */
    bcmRsvd4TxFsmStateIdle = 1,     /*  */
    bcmRsvd4TxFsmStateIdleReq = 2,  /*  */
    bcmRsvd4TxFsmStateIdleAck = 3,  /*  */
    bcmRsvd4TxFsmStateFrameTx = 4   /*  */
} bcm_rsvd4_tx_fsm_state_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* To set the RSVD4 state machine to a particular state for debug purpose */
extern int bcm_cpri_port_rsvd4_tx_fsm_state_set(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_tx_fsm_state_t state);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Tx override parameteres for debug purpose */
typedef enum bcm_rsvd4_tx_params_e {
    bcmRsvd4TxParams_StartTx = 0,       /*  */
    bcmRsvd4TxParams_PCS_Ack_CAP = 1,   /*  */
    bcmRsvd4TxParams_PCS_Idle_REQ = 2,  /*  */
    bcmRsvd4TxParams_PCS_SCR_Lock = 3,  /*  */
    bcmRsvd4TxParams_LOS_Status = 4     /*  */
} bcm_rsvd4_tx_params_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* To set the RSVD4 state machine to a particular state for debug purpose */
extern int bcm_cpri_port_rsvd4_tx_override_set(
    int unit, 
    bcm_gport_t port, 
    bcm_rsvd4_tx_params_t parameter, 
    int enable, 
    int value);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Tx Flow configuration */
typedef struct bcm_rsvd4_tx_flow_info_s {
    int axc_id; 
    uint16 stuffing_count; 
    uint32 message_number_offset; 
    uint16 master_frame_offset; 
    uint32 container_blk_count; 
    uint16 message_addr; 
    uint32 msg_ts_offset; 
    bcm_rsvd4_msg_ts_mode_t msg_ts_mode; 
    uint8 message_type; 
    bcm_rsvd4_sync_mode_t sync_mode; 
    uint16 msg_ts_count; 
    uint8 index_to_secondary_dbm; 
    uint8 secondary_dbm_enable; 
    uint8 num_active_slot; 
    uint16 payload_size; 
    uint16 last_payload_size; 
    uint8 last_index; 
    uint8 pad_enable; 
    uint8 pad_size; 
    uint8 extra_pad_size; 
    uint8 cycle_size; 
    uint32 buffer_size; 
    uint8 gsm_ctrl_loc; 
    uint8 gsm_tsn_bitmap; 
} bcm_rsvd4_tx_flow_info_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Add RSVD4 Tx Flow data AxC */
extern int bcm_cpri_port_rsvd4_tx_flow_add(
    int unit, 
    bcm_gport_t port, 
    int flow_id, 
    bcm_rsvd4_tx_flow_info_t *flow_info);

/* Delete a RSVD4 Tx Flow data AxC */
extern int bcm_cpri_port_rsvd4_tx_flow_delete(
    int unit, 
    bcm_gport_t port, 
    int flow_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 dual bitmap entry */
typedef struct bcm_rsvd4_dbm_entry_s {
    uint8 bm1_multiple; 
    uint32 bm1[3]; 
    uint8 bm1_size; 
    uint32 bm2[2]; 
    uint8 bm2_size; 
    uint8 num_slots; 
    uint8 pos_index; 
    uint8 pos_entries; 
} bcm_rsvd4_dbm_entry_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set up a DBM entry */
extern int bcm_cpri_port_rsvd4_dbm_entry_set(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_rsvd4_dbm_entry_t *entry);

/* Retrieve a DBM entry */
extern int bcm_cpri_port_rsvd4_dbm_entry_get(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_rsvd4_dbm_entry_t *entry);

/* Clear a DBM entry */
extern int bcm_cpri_port_rsvd4_dbm_entry_clear(
    int unit, 
    bcm_gport_t port, 
    int index);

#endif /* BCM_HIDE_DISPATCHABLE */

/* RSVD4 Secondary dual bitmap entry */
typedef struct bcm_rsvd4_secondary_dbm_entry_s {
    uint8 bm1_multiple; 
    uint8 bm1; 
    uint8 bm1_size; 
    uint8 bm2; 
    uint8 bm2_size; 
    uint8 num_slots; 
} bcm_rsvd4_secondary_dbm_entry_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set up a secondary DBM entry */
extern int bcm_cpri_port_rsvd4_secondary_dbm_entry_set(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_rsvd4_secondary_dbm_entry_t *entry);

/* Retrieve a secondary DBM entry */
extern int bcm_cpri_port_rsvd4_secondary_dbm_entry_get(
    int unit, 
    bcm_gport_t port, 
    int index, 
    bcm_rsvd4_secondary_dbm_entry_t *entry);

/* Clear a Secondary DBM entry */
extern int bcm_cpri_port_rsvd4_secondary_dbm_entry_clear(
    int unit, 
    bcm_gport_t port, 
    int index);

#endif /* BCM_HIDE_DISPATCHABLE */

/* CPRI Flow types */
typedef enum bcm_cpri_flow_type_e {
    bcmCpriFlowTypeData = 0,    /*  */
    bcmCpriFlowTypeCtrl = 1,    /*  */
    bcmCpriFlowTypeCount = 2    /* Should be last */
} bcm_cpri_flow_type_t;

/* CPRI dbm position table entry */
typedef struct bcm_cpri_dbm_position_entry_s {
    uint8 valid;                    /* Valid */
    uint8 flow_id;                  /* Flow id */
    bcm_cpri_flow_type_t flow_type; /* Flow type - Data or Ctrl */
    uint8 index;                    /* X slot position , 0 to (Num_slot-1) */
} bcm_cpri_dbm_position_entry_t;

/* CPRI transmission rule types */
typedef enum bcm_cpri_tx_rule_type_e {
    bcmCpriTxRuleTypeData = 0,  /*  */
    bcmCpriTxRuleTypeCtrl = 1,  /*  */
    bcmCpriTxRuleTypeCount = 2  /* Should be last */
} bcm_cpri_tx_rule_type_t;

/* CPRI modulo rule types */
typedef enum bcm_cpri_modulo_rule_mod_e {
    bcmCpriModuloRuleMod1 = 0,      /*  */
    bcmCpriModuloRuleMod2 = 1,      /*  */
    bcmCpriModuloRuleMod4 = 2,      /*  */
    bcmCpriModuloRuleMod8 = 3,      /*  */
    bcmCpriModuloRuleMod16 = 4,     /*  */
    bcmCpriModuloRuleMod32 = 5,     /*  */
    bcmCpriModuloRuleMod64 = 6,     /*  */
    bcmCpriModuloRuleModCount = 7   /* Should be last */
} bcm_cpri_modulo_rule_mod_t;

/* RSVD4 Tx Flow rule entry */
typedef struct bcm_rsvd4_tx_flow_rule_s {
    uint8 modulo_table_index; 
    uint8 modulo; 
    uint8 index; 
    uint8 dbm_en; 
    uint8 dbm_profile_num; 
    uint8 ctrl_flow; 
    uint8 position_table_index; /* Only needed if DBM is enabled */
    uint8 dbm_slot_index;       /* Only needed if DBM is enabled */
} bcm_rsvd4_tx_flow_rule_t;

/* CPRI modulo rule entry */
typedef struct bcm_cpri_modulo_rule_entry_s {
    uint8 active;                       /* Entry is active */
    bcm_cpri_modulo_rule_mod_t modulo_value; /* Modulo value */
    uint8 modulo_index;                 /* Modulo index */
    uint8 dbm_enable;                   /* Dual bitmap rule is enabled */
    uint8 dbm_dbm_id;                   /* Flow Id or DBM profile ID if dbm is
                                           enabled */
    bcm_cpri_flow_type_t flow_type;     /* Flow type - Data or Ctrl */
} bcm_cpri_modulo_rule_entry_t;

#ifndef BCM_HIDE_DISPATCHABLE

extern int bcm_cpri_port_rsvd4_tx_modulo_rule_entry_set(
    int unit, 
    bcm_gport_t port, 
    uint32 modulo_rule_num, 
    bcm_cpri_tx_rule_type_t modulo_rule_type, 
    bcm_cpri_modulo_rule_entry_t *modulo_rule);

extern int bcm_cpri_port_rsvd4_tx_modulo_rule_entry_get(
    int unit, 
    bcm_gport_t port, 
    uint32 modulo_rule_num, 
    bcm_cpri_tx_rule_type_t modulo_rule_type, 
    bcm_cpri_modulo_rule_entry_t *modulo_rule);

extern int bcm_cpri_port_rsvd4_tx_position_entry_set(
    int unit, 
    bcm_gport_t port, 
    uint32 pos_index, 
    bcm_cpri_dbm_position_entry_t *pos_entry);

extern int bcm_cpri_port_rsvd4_tx_position_entry_get(
    int unit, 
    bcm_gport_t port, 
    uint32 pos_index, 
    bcm_cpri_dbm_position_entry_t *pos_entry);

/* Configure decap flow to queue mapping. */
extern int bcm_cpri_port_decap_flow_to_queue_mapping_set(
    int unit, 
    bcm_gport_t port, 
    uint32 flow_id, 
    uint32 queue_num);

/* Retrieve decap flow to queue mapping. */
extern int bcm_cpri_port_decap_flow_to_queue_mapping_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flow_id, 
    uint32 *queue_num);

/* Configure decap queue to ordering info index. */
extern int bcm_cpri_port_decap_queue_to_ordering_info_index_set(
    int unit, 
    bcm_gport_t port, 
    uint32 queue_num, 
    uint32 ordering_info_index);

/* Retrieve decap queue to ordering info index. */
extern int bcm_cpri_port_decap_queue_to_ordering_info_index_get(
    int unit, 
    bcm_gport_t port, 
    uint32 queue_num, 
    uint32 *ordering_info_index);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef struct bcm_rsvd4_control_config_s {
    uint8 single_msg_queue; /* Queue# for single message */
    uint8 default_tag_id;   /*  */
    uint8 no_match_tag_id;  /*  */
} bcm_rsvd4_control_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure control message handling. */
extern int bcm_cpri_port_rsvd4_rx_control_config_set(
    int unit, 
    int port, 
    bcm_rsvd4_control_config_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef enum bcm_rsvd4_tag_option_e {
    bcmRsvd4TagDefault = 0, /*  */
    bcmRsvd4TagLookup = 1   /*  */
} bcm_rsvd4_tag_option_t;

/*  */
typedef enum bcm_rsvd4_cm_process_type_e {
    bcmRsvd4CmProcEth = 0,          /*  */
    bcmRsvd4CmProcFcb = 1,          /*  */
    bcmRsvd4CmProcPayload = 2,      /*  */
    bcmRsvd4CmProcFull = 3,         /*  */
    bcmRsvd4CmProcFullWithTag = 4   /*  */
} bcm_rsvd4_cm_process_type_t;

/*  */
typedef struct bcm_rsvd4_control_flow_config_s {
    uint32 match_mask;                  /* Header */
    uint32 match_data;                  /* Header */
    uint8 queue_num;                    /*  */
    bcm_rsvd4_cm_process_type_t type;   /*  */
    int sync_en;                        /*  */
    uint8 sync_profile;                 /*  */
    uint8 priority;                     /* 0-3 */
    uint8 queue_size;                   /* in bytes */
} bcm_rsvd4_control_flow_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Add control message flow. */
extern int bcm_cpri_port_rsvd4_rx_control_flow_add(
    int unit, 
    int port, 
    int control_flow_id, 
    bcm_rsvd4_control_flow_config_t *config);

/* Delete control message flow. */
extern int bcm_cpri_port_rsvd4_rx_control_flow_delete(
    int unit, 
    int port, 
    int control_flow_id, 
    bcm_rsvd4_control_flow_config_t *control_flow_cfg);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_rsvd4_fast_eth_config_info_t */
typedef _shr_fast_eth_config_t bcm_rsvd4_fast_eth_config_info_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Setup the fast ethernet control flow. */
extern int bcm_cpri_port_rsvd4_cm_fast_eth_config_set(
    int unit, 
    int port, 
    int control_flow_id, 
    bcm_rsvd4_fast_eth_config_info_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef enum bcm_rsvd4_sync_count_cycle_e {
    bcmRsvd4SyncCountEveryMf = 0,   /*  */
    bcmRsvd4SyncCountUptoSixMf = 1  /*  */
} bcm_rsvd4_sync_count_cycle_t;

/*  */
typedef struct bcm_rsvd4_sync_profile_entry_s {
    uint32 master_frame_offset;         /*  */
    uint32 message_offset;              /*  */
    bcm_rsvd4_sync_count_cycle_t count_cycle; /*  */
} bcm_rsvd4_sync_profile_entry_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure sync profile entry. */
extern int bcm_cpri_port_rsvd4_sync_profile_entry_set(
    int unit, 
    int port, 
    int index, 
    bcm_rsvd4_sync_profile_entry_t *config);

/* Retrieve sync profile entry. */
extern int bcm_cpri_port_rsvd4_sync_profile_entry_get(
    int unit, 
    int port, 
    int index, 
    bcm_rsvd4_sync_profile_entry_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef struct bcm_rsvd4_control_message_flow_config_s {
    uint8 tag_id;       /*  */
    uint16 mask;        /*  */
    uint16 header;      /*  */
    uint8 word_count;   /* only for RTWP 0-3 mean 1-4 */
} bcm_rsvd4_control_message_flow_config_t;

/* Tag Generation Entry information. */
typedef _shr_tag_gen_entry_t bcm_cpri_tag_gen_entry_t;

#ifndef BCM_HIDE_DISPATCHABLE

/*  */
extern int bcm_cpri_port_rsvd4_rx_tag_gen_entry_add(
    int unit, 
    int port, 
    int index, 
    bcm_cpri_tag_gen_entry_t *config);

/*  */
extern int bcm_cpri_port_rsvd4_rx_tag_gen_entry_delete(
    int unit, 
    int port, 
    int index, 
    bcm_cpri_tag_gen_entry_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef enum bcm_rsvd4_control_group_id_e {
    bcmRsvd4ControlGroupId0 = 0,    /*  */
    bcmRsvd4ControlGroupId1 = 1     /*  */
} bcm_rsvd4_control_group_id_t;

/*  */
typedef enum bcm_rsvd4_slot_type_e {
    bcmRsvd4SlotData = 0,   /*  */
    bcmRsvd4SlotControl = 1 /*  */
} bcm_rsvd4_slot_type_t;

/*  */
typedef enum bcm_rsvd4_priority_e {
    bcmRsvd4Priority0 = 0,  /*  */
    bcmRsvd4Priority1 = 1,  /*  */
    bcmRsvd4Priority2 = 2,  /*  */
    bcmRsvd4Priority3 = 3   /*  */
} bcm_rsvd4_priority_t;

/* bcm_cpri_control_msg_proc_type_t */
typedef _shr_control_msg_proc_type_t bcm_cpri_control_msg_proc_type_t;

/*  */
typedef struct bcm_rsvd4_tx_control_flow_group_config_s {
    uint8 queue_num;                    /*  */
    bcm_cpri_control_msg_proc_type_t type; /*  */
    bcm_rsvd4_priority_t priority;      /*  */
} bcm_rsvd4_tx_control_flow_group_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/*  */
extern int bcm_cpri_port_rsvd4_tx_control_flow_group_member_add(
    int unit, 
    int port, 
    bcm_rsvd4_control_group_id_t group_num, 
    bcm_rsvd4_tx_control_flow_group_config_t *config);

/*  */
extern int bcm_cpri_port_rsvd4_tx_control_flow_group_member_delete(
    int unit, 
    int port, 
    bcm_rsvd4_control_group_id_t group_num, 
    bcm_rsvd4_priority_t priority);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef struct bcm_rsvd4_tx_cm_eth_config_s {
    uint8 msg_node;     /*  */
    uint8 msg_subnode;  /*  */
    uint8 msg_type;     /*  */
    uint8 msg_padding;  /*  */
    uint8 crc_mode;     /*  */
} bcm_rsvd4_tx_cm_eth_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/*  */
extern int bcm_cpri_port_rsvd4_tx_cm_eth_config_set(
    int unit, 
    int port, 
    bcm_rsvd4_tx_cm_eth_config_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef struct bcm_rsvd4_tx_cm_raw_config_s {
    uint8 msg_id;   /*  */
    uint8 msg_type; /*  */
} bcm_rsvd4_tx_cm_raw_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/*  */
extern int bcm_cpri_port_rsvd4_tx_cm_raw_config_set(
    int unit, 
    int port, 
    bcm_rsvd4_tx_cm_raw_config_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef struct bcm_rsvd4_tx_control_flow_config_s {
    uint8 queue_num;                    /*  */
    bcm_cpri_control_msg_proc_type_t type; /*  */
} bcm_rsvd4_tx_control_flow_config_t;

#ifndef BCM_HIDE_DISPATCHABLE

/*  */
extern int bcm_cpri_port_rsvd4_tx_control_flow_add(
    int unit, 
    int port, 
    int control_flow_id, 
    bcm_rsvd4_tx_control_flow_config_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef enum bcm_rsvd4_cm_tunnel_crc_option_e {
    bcmRsvd4CmTunnelCrcUseRoe = 0,      /* Old CRC */
    bcmRsvd4CmTunnelCrcRegenerate = 1   /*  */
} bcm_rsvd4_cm_tunnel_crc_option_t;

#ifndef BCM_HIDE_DISPATCHABLE

/*  */
extern int bcm_cpri_port_rsvd4_tx_cm_tunnel_crc_config_set(
    int unit, 
    int port, 
    bcm_rsvd4_cm_tunnel_crc_option_t crc_option);

#endif /* BCM_HIDE_DISPATCHABLE */

/*  */
typedef struct bcm_rsvd4_tx_cm_hdr_entry_s {
    uint8 rsvd4_header_node;            /*  */
    uint8 rsvd4_header_subnode;         /*  */
    uint8 rsvd4_control_payload_node;   /*  */
} bcm_rsvd4_tx_cm_hdr_entry_t;

#ifndef BCM_HIDE_DISPATCHABLE

/*  */
extern int bcm_cpri_port_rsvd4_tx_cm_hdr_config_entry_set(
    int unit, 
    int port, 
    int index, 
    bcm_rsvd4_tx_cm_hdr_entry_t *entry);

/*  */
extern int bcm_cpri_port_rsvd4_tx_cm_hdr_lkup_entry_set(
    int unit, 
    int port, 
    int flow_id, 
    int header_index);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_cpri_crc_mode_t */
typedef _shr_hdlc_crc_mode_t bcm_cpri_crc_mode_t;

/* bcm_cpri_hdlc_flag_size_t */
typedef _shr_hdlc_flag_size_t bcm_cpri_hdlc_flag_size_t;

/* cpri_hdlc_fcs_size_t */
typedef _shr_hdlc_fcs_size_t bcm_cpri_hdlc_fcs_size_t;

/* cpri_cw_filter_mode_t */
typedef _shr_cpri_cw_filter_mode_t bcm_cpri_cw_filter_mode_t;

/* bcm_cpri_hdlc_filling_pattern_t */
typedef _shr_hdlc_filling_flag_pattern_t bcm_cpri_hdlc_filling_pattern_t;

/* bcm_cpri_gcw_mask_t */
typedef _shr_cpri_gcw_mask_t bcm_cpri_gcw_mask_t;

#define BCM_CPRI_CW_L1_SIGNAL_LOF           0x01       
#define BCM_CPRI_CW_L1_SIGNAL_LOS           0x02       
#define BCM_CPRI_CW_L1_SIGNAL_SDI           0x04       
#define BCM_CPRI_CW_L1_SIGNAL_RAI           0x08       
#define BCM_CPRI_CW_L1_SIGNAL_RESET         0x10       
#define BCM_CPRI_CW_L1_SIGNAL_HDLC_RATE     0x20       
#define BCM_CPRI_CW_L1_SIGNAL_ETH_POINTER   0x40       
#define BCM_CPRI_CW_L1_SIGNAL_PROTOCOL_VERSION 0x80       

#define BCM_CPRI_CRC_APPEND     _shrHdlcCrcAppend 
#define BCM_CPRI_CRC_REPLACE    _shrHdlcCrcReplace 
#define BCM_CPRI_CRC_NO_UPDATE  _shrHdlcCrcNoUpdate 

#define BCM_CPRI_HDLC_FLAG_SIZE_1_BYTE  _shrHdlcNumFlagSizeOneByte 
#define BCM_CPRI_HDLC_FLAG_SIZE_2_BYTE  _shrHdlcNumFlagSizeTwoByte 

#define BCM_CPRI_HDLC_FILLING_PATTERN_7E    _shrHdlcFillingFlagPattern7E 
#define BCM_CPRI_HDLC_FILLING_PATTERN_7F    _shrHdlcFillingFlagPattern7F 
#define BCM_CPRI_HDLC_FILLING_PATTERN_FF    _shrHdlcFillingFlagPatternFF 

#define BCM_CPRI_HDLC_FCS_SIZE_8_BITS   _shrHdlcFcsSize8Bits 
#define BCM_CPRI_HDLC_FCS_SIZE_16_BITS  _shrHdlcFcsSize16Bits 
#define BCM_CPRI_HDLC_FCS_SIZE_32_BITS  _shrHdlcFcsSize32Bits 

#define BCM_CPRI_FILTER_DISABLE     _shrCpriFilterDisable 
#define BCM_CPRI_FILTER_NON_ZERO    _shrCpriFilterNonZero 
#define BCM_CPRI_FILTER_PERIODIC    _shrCpriFilterPeriodic 
#define BCM_CPRI_FILTER_CHANGE      _shrCpriFilterChange 
#define BCM_CPRI_FILTER_PATTERN     _shrCpriFilterPatternMatch 

#define BCM_CRPI_GCW_MASK_NO_BYTE   _shrCpriGcwMaskNone 
#define BCM_CRPI_GCW_MASK_LSB_BYTE  _shrCpriGcwMaskLSB 
#define BCM_CRPI_GCW_MASK_MSB_BYTE  _shrCpriGcwMaskMSB 
#define BCM_CRPI_GCW_MASK_BOT_BYTE  _shrCpriGcwMaskBOTH 

/* Layer 1 protocol information. */
typedef _shr_cpri_cw_l1_protocol_info_t bcm_cpri_cw_l1_protocol_info_t;

/*  */
typedef struct bcm_cpri_slow_hdlc_config_info_s {
    bcm_cpri_crc_mode_t hdlc_crc_mode;  /*  */
    bcm_cpri_hdlc_flag_size_t tx_flag_size; /*  */
    bcm_cpri_hdlc_filling_pattern_t tx_filling_pattern; /*  */
    bcm_cpri_hdlc_filling_pattern_t crc_init_val; /* all 0's or all 1's */
    int use_fe_mac;                     /*  */
    int crc_byte_swap;                  /*  */
    int no_fcs_err_check;               /*  */
    uint32 hdlc_cw_sel;                 /*  */
    uint32 hdlc_cw_size;                /*  */
    bcm_cpri_hdlc_flag_size_t hdlc_fcs_size; /*  */
    int hdlc_run_drop;                  /*  */
    int hdlc_max_drop;                  /*  */
    uint32 hdlc_min_size;               /*  */
    uint32 hdlc_max_size;               /*  */
    uint32 hdlc_queue_num;              /*  */
    uint32 priority;                    /*  0-3 */
    uint32 queue_size;                  /*  in bytes */
    uint32 cycle_size;                  /*  */
    uint32 buffer_size;                 /* pkt size */
} bcm_cpri_slow_hdlc_config_info_t;

/*  */
typedef struct bcm_cpri_fast_eth_config_info_s {
    uint32 sub_channel_start;       /*  The first sub-channel allocated for fast
                                       c&m */
    uint32 sub_channel_size;        /*  sub channel size */
    uint32 cw_sel;                  /*  Select sub-channel words */
    uint32 cw_size;                 /*  Number of bytes per word to use. Valid
                                       values are 0 to 16. */
    uint32 queue_num;               /*  queue number */
    int ignore_fcs_err;             /*   True or False */
    uint32 min_pkt_size;            /*  */
    uint32 max_pkt_size;            /*  */
    uint32 drop_min_pkt_size;       /*  */
    uint32 drop_max_pkt_size;       /*  */
    int strip_crc;                  /*   True or False */
    uint32 min_ipg;                 /*  */
    bcm_cpri_crc_mode_t crc_mode;   /*  0-append 1-replace 2-No update */
    uint32 priority;                /*  0-3 */
    uint32 queue_size;              /*  in bytes */
    uint32 cycle_size;              /*  */
    uint32 buffer_size;             /*  pkt size */
} bcm_cpri_fast_eth_config_info_t;

/*  */
typedef struct bcm_cpri_rx_vsd_config_info_s {
    uint32 schan_start;                 /*  starting control subchannel number */
    uint32 schan_size;                  /*  CPRIMOD_CTRL_2CHS, CPRIMOD_CTRL_4CHS */
    uint32 schan_bytes;                 /*  CPRIMOD_1BYTES, CPRIMOD_2BYTES,
                                           CPRIMOD_4BYTES */
    uint32 schan_step;                  /* CPRIMOD_SKIP_0, CPRIMOD_SKIP_1 */
    uint32 queue_num;                   /*  */
    uint32 vsd_valid_sector_mask[4];    /*  total of 128 possible sectors */
    uint32 priority;                    /* 0-3 */
    uint32 queue_size;                  /* in bytes */
    uint32 flow_bytes;                  /* number of bytes per flow */
} bcm_cpri_rx_vsd_config_info_t;

/* VSD Flow information. */
typedef _shr_cpri_rx_vsd_flow_info_t bcm_cpri_rx_vsd_flow_info_t;

/*  */
typedef struct bcm_cpri_rx_vsd_raw_config_info_s {
    uint32 schan_start;                 /* starting control subchannel number */
    uint32 schan_size;                  /*  Number of sub channels */
    uint32 cw_sel;                      /*  4 bits bit map. which Xs bytes to
                                           use */
    uint32 cw_size;                     /*  number of bytes per word to extract
                                           0 to Tcw/8. Max 16 bytes */
    uint32 queue_num;                   /* The queue number to be used for the
                                           payload data in the encapsulation
                                           memory. */
    uint32 match_mask;                  /* Mask to apply to the data before
                                           comparing to the match_value. */
    uint32 match_value;                 /* Value to match. */
    uint32 match_offset;                /* The offset of the first byte in the
                                           flow to match. */
    uint32 hfn_modulo;                  /* Modulo value. Valid values are 1 to
                                           150. */
    uint32 hfn_offset;                  /* Programmable offset. Valid values are
                                           0 to 149. */
    bcm_cpri_cw_filter_mode_t filter_mode; /*  */
    uint32 priority;                    /*  0-3 */
    uint32 queue_size;                  /*  in_bytes */
} bcm_cpri_rx_vsd_raw_config_info_t;

/*  */
typedef struct bcm_cpri_rx_rsvd5_config_info_s {
    uint32 schan_start;         /* The first sub-channel allocated for the RSVD5
                                   parser. Valid values are 16 to 63 */
    uint32 schan_size;          /*  Number of sub channels 1, 2 or 4 for CPRI
                                   4x, 8x and 16x.2 or 4 for CPRI 2x and
                                   10x.Setting the field to 0 disables the
                                   engine. Values other than 1, 2, 4 not
                                   supported. */
    int disable_parity_check;   /*  */
    uint32 queue_num;           /*  user configurable */
    uint32 priority;            /*  0-3 */
    uint32 queue_size;          /*  in_bytes */
} bcm_cpri_rx_rsvd5_config_info_t;

/*  */
typedef struct bcm_cpri_control_tag_config_s {
    uint32 default_tag;     /*  */
    uint32 no_match_tag;    /*  */
} bcm_cpri_control_tag_config_t;

/*  */
typedef struct bcm_cpri_fec_tick_config_s {
    uint16 gbox_tick_denominator;   /*  */
    uint32 gbox_tick_numerator;     /*  */
} bcm_cpri_fec_tick_config_t;

/*  */
typedef struct bcm_cpri_fec_timestamp_config_s {
    uint8 enable;                       /*  */
    uint8 send_cl91_257b_ts_to_tsfifo;  /*  */
    uint8 send_cl91_66b_ts_to_cmic;     /*  */
    uint8 control_bit_offset_0;         /*  */
    uint8 control_bit_offset_1;         /*  */
    uint8 control_bit_offset_2;         /*  */
    uint8 control_bit_offset_3;         /*  */
} bcm_cpri_fec_timestamp_config_t;

/*  */
typedef struct bcm_cpri_rx_gcw_config_info_s {
    uint32 Ns;                          /*  sub channel # */
    uint32 Xs;                          /*  word number */
    uint32 Y;                           /*  first byte number valid value 0-7
                                           for 0,2,4,..14) */
    bcm_cpri_gcw_mask_t mask;           /*  */
    bcm_cpri_cw_filter_mode_t filter_mode; /*  */
    uint32 hfn_index;                   /*  Programmable offset. Valid values
                                           are 0 to 149. */
    uint32 hfn_modulo;                  /*  Modulo value. Valid values are 1 to
                                           150. */
    uint32 match_value;                 /*  */
    uint32 match_mask;                  /*  Mask to apply to the data before
                                           comparing to the match_value. */
} bcm_cpri_rx_gcw_config_info_t;

/*  */
typedef struct bcm_cpri_cw_sync_info_s {
    uint32 hfn; /*  current hyperframe number Z.64.0 */
    uint32 bfn; /*  cpri radio frame number Z.192.0 Z.128.0 */
} bcm_cpri_cw_sync_info_t;

/* Tx L1 Config information. */
typedef _shr_cpri_cw_l1_config_info_t bcm_cpri_cw_l1_config_info_t;

/*  */
typedef struct bcm_cpri_tx_vsd_config_info_s {
    uint32 schan_start;                 /*  starting control subchannel number */
    uint32 schan_size;                  /*  CPRIMOD_CTRL_2CHS, CPRIMOD_CTRL_4CHS */
    uint32 schan_bytes;                 /*  CPRIMOD_1BYTES, CPRIMOD_2BYTES ,
                                           CPRIMOD_4BYTES */
    uint32 schan_step;                  /*  CPRIMOD_SKIP_0, CPRIMOD_SKIP_1 */
    uint32 queue;                       /*  0x44 (68) default */
    uint32 vsd_valid_sector_mask[4];    /*  total of 128 possible sectors */
    uint32 cycle_size;                  /*  hdlc rate */
    uint32 buffer_size;                 /*  pkt size */
    uint32 flow_bytes;                  /* number of bytes per flow */
} bcm_cpri_tx_vsd_config_info_t;

/* VSD Tx Flow information. */
typedef _shr_cpri_tx_vsd_flow_info_t bcm_cpri_tx_vsd_flow_info_t;

/*  */
typedef struct bcm_cpri_tx_vsd_raw_config_info_s {
    uint32 schan_start;     /* starting control subchannel number */
    uint32 schan_size;      /*  Number of sub channels */
    uint32 cw_sel;          /*  4 bits bit map. which Xs bytes to use */
    uint32 cw_size;         /*  number of bytes per word to extract 0 to Tcw/8.
                               Max 16 bytes */
    uint32 queue_num;       /* The decap queue number to be used for VSD raw
                               data. Valid values are 64-79. Should be different
                               than other control queue numbers.. */
    uint32 map_mode;        /*  */
    int repeat_mode;        /*  */
    int bfn0_filter_enable; /*  */
    int bfn1_filter_enable; /*  */
    uint32 hfn_index;       /*  */
    uint32 hfn_modulo;      /*  */
    uint32 idle_value;      /*  */
    uint32 cycle_size;      /*  */
    uint32 buffer_size;     /*  pkt size */
} bcm_cpri_tx_vsd_raw_config_info_t;

/*  */
typedef struct bcm_cpri_tx_cw_vsd_raw_filter_info_s {
    uint32 bfn0_value;  /*  */
    uint32 bfn0_mask;   /*  */
    uint32 bfn1_value;  /*  */
    uint32 bfn1_mask;   /*  */
} bcm_cpri_tx_cw_vsd_raw_filter_info_t;

/*  */
typedef struct bcm_cpri_tx_cw_rsvd5_config_info_s {
    uint32 schan_start;     /* The first sub-channel allocated for the RSVD5
                               parser. Valid values are 16 to 63 */
    uint32 schan_size;      /*  Number of sub channels 1, 2 or 4 for CPRI 4x, 8x
                               and 16x.2 or 4 for CPRI 2x and 10x.Setting the
                               field to 0 disables the engine. Values other than
                               1, 2, 4 not supported. */
    int crc_check_enable;   /*  */
    uint32 queue_num;       /*  */
    uint32 cycle_size;      /*  */
    uint32 buffer_size;     /*  pkt size */
} bcm_cpri_tx_cw_rsvd5_config_info_t;

/*  */
typedef struct bcm_cpri_tx_gcw_config_info_s {
    uint32 Ns;                  /*  sub channel # */
    uint32 Xs;                  /*  word number */
    uint32 Y;                   /*  first byte number valid value 0-7 for
                                   0,2,4,..14) */
    bcm_cpri_gcw_mask_t mask;   /*  */
    int repeat_mode;            /*  */
    int bfn0_filter_enable;     /*  Insert only when BFN matches values
                                   specified by the BFN configuration register. */
    int bfn1_filter_enable;     /*  Insert only when BFN matches values
                                   specified by the BFN configuration register. */
    uint32 hfn_index;           /*  Programmable offset. Valid values are 0 to
                                   149. */
    uint32 hfn_modulo;          /*  Modulo value. Valid values are 1 to 150. */
} bcm_cpri_tx_gcw_config_info_t;

/*  */
typedef struct bcm_cpri_tx_gcw_tx_filter_info_s {
    uint32 bfn0_value;  /*  */
    uint32 bfn0_mask;   /*  */
    uint32 bfn1_value;  /*  */
    uint32 bfn1_mask;   /*  */
} bcm_cpri_tx_gcw_tx_filter_info_t;

#ifndef BCM_HIDE_DISPATCHABLE

/*  */
extern int bcm_cpri_port_rx_cw_sync_info_get(
    int unit, 
    int port, 
    uint32 *hyper_frame_num, 
    uint32 *radio_frame_num);

/*  */
extern int bcm_cpri_port_rx_cw_l1_signal_info_get(
    int unit, 
    int port, 
    bcm_cpri_cw_l1_protocol_info_t *l1_info);

/*  */
extern int bcm_cpri_port_rx_cw_l1_signal_protection_set(
    int unit, 
    int port, 
    uint32 signal_map, 
    uint32 enable);

/*  */
extern int bcm_cpri_port_rx_cw_l1_signal_protection_get(
    int unit, 
    int port, 
    uint32 signal_map, 
    uint32 *enable);

/*  */
extern int bcm_cpri_port_cw_slow_hdlc_config_set(
    int unit, 
    int port, 
    bcm_cpri_slow_hdlc_config_info_t *config);

/*  */
extern int bcm_cpri_port_cw_slow_hdlc_config_get(
    int unit, 
    int port, 
    bcm_cpri_slow_hdlc_config_info_t *config);

/*  */
extern int bcm_cpri_port_cw_fast_eth_config_set(
    int unit, 
    int port, 
    bcm_cpri_fast_eth_config_info_t *config);

/*  */
extern int bcm_cpri_port_cw_fast_eth_config_get(
    int unit, 
    int port, 
    bcm_cpri_fast_eth_config_info_t *config);

/*  */
extern int bcm_cpri_port_rx_cw_vsd_config_set(
    int unit, 
    int port, 
    bcm_cpri_rx_vsd_config_info_t *config);

/*  */
extern int bcm_cpri_port_rx_cw_vsd_config_get(
    int unit, 
    int port, 
    bcm_cpri_rx_vsd_config_info_t *config);

/*  */
extern int bcm_cpri_port_rx_cw_vsd_ctrl_flow_config_set(
    int unit, 
    int port, 
    uint16 group_id, 
    bcm_cpri_rx_vsd_flow_info_t *config);

/*  */
extern int bcm_cpri_port_rx_cw_vsd_ctrl_flow_config_get(
    int unit, 
    int port, 
    uint16 group_id, 
    bcm_cpri_rx_vsd_flow_info_t *config);

/*  */
extern int bcm_cpri_encap_control_queue_tag_to_flow_id_map_set(
    int unit, 
    int port, 
    uint32 tag_id, 
    uint32 flow_id);

/*  */
extern int bcm_cpri_port_rx_cw_vsd_raw_config_set(
    int unit, 
    int port, 
    uint8 vsd_raw_id, 
    bcm_cpri_rx_vsd_raw_config_info_t *config);

/*  */
extern int bcm_cpri_port_rx_cw_vsd_raw_config_get(
    int unit, 
    int port, 
    uint8 vsd_raw_id, 
    bcm_cpri_rx_vsd_raw_config_info_t *config);

/*  */
extern int bcm_cpri_port_rx_cw_rsvd5_config_set(
    int unit, 
    int port, 
    bcm_cpri_rx_rsvd5_config_info_t *config);

/*  */
extern int bcm_cpri_port_rx_cw_rsvd5_config_get(
    int unit, 
    int port, 
    bcm_cpri_rx_rsvd5_config_info_t *config);

/*  */
extern int bcm_cpri_rx_tag_config_set(
    int unit, 
    int port, 
    uint32 default_tag, 
    uint32 no_match_tag);

/*  */
extern int bcm_cpri_port_rx_tag_config_set(
    int unit, 
    int port, 
    bcm_cpri_control_tag_config_t *config);

/*  */
extern int bcm_cpri_port_rx_tag_entry_add(
    int unit, 
    int port, 
    bcm_cpri_tag_gen_entry_t *config);

/*  */
extern int bcm_cpri_port_rx_tag_entry_delete(
    int unit, 
    int port, 
    bcm_cpri_tag_gen_entry_t *config);

/*  */
extern int bcm_cpri_port_rx_fec_enable_set(
    int unit, 
    int port, 
    uint8 enable);

/*  */
extern int bcm_cpri_port_rx_fec_tick_set(
    int unit, 
    int port, 
    bcm_cpri_fec_tick_config_t *config);

/*  */
extern int bcm_cpri_port_rx_fec_timestamp_config_set(
    int unit, 
    int port, 
    bcm_cpri_fec_timestamp_config_t *config);

/*  */
extern int bcm_cpri_port_rx_fec_soft_reset_set(
    int unit, 
    int port, 
    uint8 enable);

/*  */
extern int bcm_cpri_port_rx_fec_descramble_bypass_set(
    int unit, 
    int port, 
    uint8 enable);

/*  */
extern int bcm_cpri_port_rx_cw_gcw_config_set(
    int unit, 
    int port, 
    uint8 index, 
    bcm_cpri_rx_gcw_config_info_t *config);

/*  */
extern int bcm_cpri_port_rx_cw_gcw_config_get(
    int unit, 
    int port, 
    uint8 index, 
    bcm_cpri_rx_gcw_config_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_sync_info_set(
    int unit, 
    int port, 
    bcm_cpri_cw_sync_info_t *entry);

/*  */
extern int bcm_cpri_port_tx_cw_sync_info_get(
    int unit, 
    int port, 
    bcm_cpri_cw_sync_info_t *entry);

/*  */
extern int bcm_cpri_port_tx_cw_l1_config_set(
    int unit, 
    int port, 
    bcm_cpri_cw_l1_config_info_t *entry);

/*  */
extern int bcm_cpri_port_tx_cw_vsd_config_set(
    int unit, 
    int port, 
    bcm_cpri_tx_vsd_config_info_t *entry);

/*  */
extern int bcm_cpri_port_tx_cw_vsd_config_get(
    int unit, 
    int port, 
    bcm_cpri_tx_vsd_config_info_t *entry);

/*  */
extern int bcm_cpri_port_tx_cw_vsd_ctrl_flow_config_set(
    int unit, 
    int port, 
    uint16 group_id, 
    bcm_cpri_tx_vsd_flow_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_vsd_raw_flow_config_set(
    int unit, 
    int port, 
    uint8 index, 
    bcm_cpri_tx_vsd_raw_config_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_vsd_raw_flow_config_get(
    int unit, 
    int port, 
    uint8 index, 
    bcm_cpri_tx_vsd_raw_config_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_vsd_raw_filter_set(
    int unit, 
    int port, 
    bcm_cpri_tx_cw_vsd_raw_filter_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_vsd_raw_filter_get(
    int unit, 
    int port, 
    bcm_cpri_tx_cw_vsd_raw_filter_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_rsvd5_config_set(
    int unit, 
    int port, 
    bcm_cpri_tx_cw_rsvd5_config_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_rsvd5_config_get(
    int unit, 
    int port, 
    bcm_cpri_tx_cw_rsvd5_config_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_gcw_config_set(
    int unit, 
    int port, 
    uint8 index, 
    bcm_cpri_tx_gcw_config_info_t *config);

/*  */
extern int bcm_cpri_port_tx_cw_gcw_filter_set(
    int unit, 
    int port, 
    uint8 index, 
    bcm_cpri_tx_gcw_tx_filter_info_t *config);

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_CPRI_H__ */
