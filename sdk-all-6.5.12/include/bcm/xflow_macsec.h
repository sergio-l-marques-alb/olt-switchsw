/*
 * $Id: $
 * 
 * $Copyright: (c) 2017 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_XFLOW_MACSEC_H__
#define __BCM_XFLOW_MACSEC_H__

#if defined(INCLUDE_XFLOW_MACSEC)

#include <bcm/types.h>
#include <xflow_macsec_defs.h>

#define BCM_XFLOW_MACSEC_SECURE_CHAN_ID_CREATE(flag, chan_id)                  \
                XFLOW_MACSEC_SECURE_CHAN_ID_CREATE(flag, chan_id) 
#define BCM_XFLOW_MACSEC_ENCRYPT_DECRYPT_NONE XFLOW_MACSEC_ENCRYPT_DECRYPT_NONE /* Indicates the
                                                          parameters are not
                                                          specific to encrypt or
                                                          decrypt flow or
                                                          applies to both. */
#define BCM_XFLOW_MACSEC_ENCRYPT            XFLOW_MACSEC_ENCRYPT /* Indicates the
                                                          parameters are for
                                                          encryption. */
#define BCM_XFLOW_MACSEC_DECRYPT            XFLOW_MACSEC_DECRYPT /* Indicates the
                                                          parameters are for
                                                          decryption. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_WITH_ID XFLOW_MACSEC_SECURE_CHAN_WITH_ID /* To be used when secure
                                                          channel needs to be
                                                          created with a
                                                          particular id. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_INFO_INCLUDE_SCI XFLOW_MACSEC_SECURE_CHAN_INFO_INCLUDE_SCI /* Indicates the 64-bit
                                                          SCI should be included
                                                          in the SecTAG during
                                                          encryption. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_INFO_CONTROLLED_PORT XFLOW_MACSEC_SECURE_CHAN_INFO_CONTROLLED_PORT /* Allow all data packets
                                                          and management
                                                          packets. The default
                                                          is uncontrolled port
                                                          which is to discard
                                                          all data packets and
                                                          allow only management
                                                          packets. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_INFO_ENCRYPT_DISABLE XFLOW_MACSEC_SECURE_CHAN_INFO_ENCRYPT_DISABLE /* Do not encrypt the
                                                          packet using the
                                                          Cipher suite. The
                                                          default behavior is to
                                                          encrypt. */
#define BCM_XFLOW_MACSEC_SECURE_CHAN_INFO_REPLAY_PROTECT_ENABLE XFLOW_MACSEC_SECURE_CHAN_INFO_REPLAY_PROTECT_ENABLE /* Enable replay protect. */

typedef enum bcm_xflow_macsec_crypto_e {
    BCM_XFLOW_MACSEC_CRYPTO_AES_128_GCM_INTEGRITY_ONLY = XFLOW_MACSEC_CRYPTO_AES_128_GCM_INTEGRITY_ONLY, 
    BCM_XFLOW_MACSEC_CRYPTO_AES_128_GCM = XFLOW_MACSEC_CRYPTO_AES_128_GCM, 
    BCM_XFLOW_MACSEC_CRYPTO_AES_128_GCM_XPN_INTEGRITY_ONLY = XFLOW_MACSEC_CRYPTO_AES_128_GCM_XPN_INTEGRITY_ONLY, 
    BCM_XFLOW_MACSEC_CRYPTO_AES_128_GCM_XPN = XFLOW_MACSEC_CRYPTO_AES_128_GCM_XPN, 
    BCM_XFLOW_MACSEC_CRYPTO__COUNT = XFLOW_MACSEC_CRYPTO__COUNT 
} bcm_xflow_macsec_crypto_t;

typedef enum bcm_xflow_macsec_mtu_e {
    BCM_XFLOW_MACSEC_MTU_0 = XFLOW_MACSEC_MTU_0, 
    BCM_XFLOW_MACSEC_MTU_1 = XFLOW_MACSEC_MTU_1, 
    BCM_XFLOW_MACSEC_MTU_2 = XFLOW_MACSEC_MTU_2, 
    BCM_XFLOW_MACSEC_MTU_3 = XFLOW_MACSEC_MTU_3 
} bcm_xflow_macsec_mtu_t;

typedef enum bcm_xflow_macsec_sectag_ethertype_e {
    BCM_XFLOW_MACSEC_SECTAG_ETYPE_0 = XFLOW_MACSEC_SECTAG_ETYPE_0, 
    BCM_XFLOW_MACSEC_SECTAG_ETYPE_1 = XFLOW_MACSEC_SECTAG_ETYPE_1, 
    BCM_XFLOW_MACSEC_SECTAG_ETYPE_2 = XFLOW_MACSEC_SECTAG_ETYPE_2, 
    BCM_XFLOW_MACSEC_SECTAG_ETYPE_3 = XFLOW_MACSEC_SECTAG_ETYPE_3 
} bcm_xflow_macsec_sectag_ethertype_t;

typedef xflow_macsec_secure_chan_info_t bcm_xflow_macsec_secure_chan_info_t;

typedef xflow_macsec_secure_chan_id_t bcm_xflow_macsec_secure_chan_id_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Installs a new security channel entry. Returns the channel Id. */
extern int bcm_xflow_macsec_secure_chan_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int priority, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id);

/* 
 * Sets/Resets the value of one of the parameters of a given security
 * channel.
 */
extern int bcm_xflow_macsec_secure_chan_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int priority);

/* Get the security channel configuration for a given SC index. */
extern int bcm_xflow_macsec_secure_chan_get(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int *priority);

/* 
 * Delete the given security channel. The corresponding SA must be
 * destroyed first.
 */
extern int bcm_xflow_macsec_secure_chan_destroy(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize the data structure. */
extern void bcm_xflow_macsec_secure_chan_info_t_init(
    bcm_xflow_macsec_secure_chan_info_t *chan_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable the Security Channel. */
extern int bcm_xflow_macsec_secure_chan_enable_set(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    int enable);

/* Check if the Security Channel is enabled. */
extern int bcm_xflow_macsec_secure_chan_enable_get(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    int *enable);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_xflow_macsec_chan_traverse_cb */
typedef int (*bcm_xflow_macsec_chan_traverse_cb)(
    int unit, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse secure channels */
extern int bcm_xflow_macsec_secure_chan_info_traverse(
    int unit, 
    bcm_xflow_macsec_chan_traverse_cb callback, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_SECURE_ASSOC_ID_CREATE(flag, assoc_id)                  \
                XFLOW_MACSEC_SECURE_ASSOC_ID_CREATE(flag, assoc_id) 
#define BCM_XFLOW_MACSEC_SECURE_ASSOC_INFO_SET_NEXT_PKT_NUM XFLOW_MACSEC_SECURE_ASSOC_INFO_SET_NEXT_PKT_NUM /* Set the next PN of the
                                                          security association
                                                          to the value given. */

typedef xflow_macsec_secure_assoc_info_t bcm_xflow_macsec_secure_assoc_info_t;

typedef xflow_macsec_crypto_aes128_gcm_t bcm_xflow_macsec_crypto_aes128_gcm_t;

typedef uint32 bcm_xflow_macsec_secure_assoc_id_t;

typedef enum bcm_xflow_macsec_secure_assoc_an_control_e {
    BCM_XFLOW_MACSEC_SECURE_ASSOC_AN_NORMAL = XFLOW_MACSEC_SECURE_ASSOC_AN_NORMAL, 
    BCM_XFLOW_MACSEC_SECURE_ASSOC_AN_ROLLOVER = XFLOW_MACSEC_SECURE_ASSOC_AN_ROLLOVER, 
    BCM_XFLOW_MACSEC_SECURE_ASSOC_AN_AUTO = XFLOW_MACSEC_SECURE_ASSOC_AN_AUTO 
} bcm_xflow_macsec_secure_assoc_an_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Create the Security Association for the given Security Channel. */
extern int bcm_xflow_macsec_secure_assoc_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info, 
    bcm_xflow_macsec_secure_assoc_id_t *assoc_id);

/* 
 * Sets/Resets the value of any of the parameters of a given security
 * association.
 */
extern int bcm_xflow_macsec_secure_assoc_set(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info);

/* 
 * Retrieve the Security Association configuration and the SC index from
 * the SA index.
 */
extern int bcm_xflow_macsec_secure_assoc_get(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id);

/* Deletes the SA entry corresponding to the Security Association. */
extern int bcm_xflow_macsec_secure_assoc_destroy(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize the Security Association data structure. */
extern void bcm_xflow_macsec_secure_assoc_info_t_init(
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info);

/* bcm_xflow_macsec_secure_assoc_traverse_cb */
typedef int (*bcm_xflow_macsec_secure_assoc_traverse_cb)(
    int unit, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse Secure Associations */
extern int bcm_xflow_macsec_secure_assoc_traverse(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_assoc_traverse_cb callback, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_ID_CREATE(id)                  \
                XFLOW_MACSEC_POLICY_ID_CREATE(BCM_XFLOW_MACSEC_DECRYPT, id) 
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_WITH_ID XFLOW_MACSEC_POLICY_WITH_ID /* Provide the policy_id
                                                          as input to the API. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_UNTAGGED_FRAME_DENY XFLOW_MACSEC_DECRYPT_POLICY_UNTAGGED_FRAME_DENY /* Deny and account all
                                                          data packet which
                                                          doesn't have a sectag. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_CHECK_ICV XFLOW_MACSEC_DECRYPT_POLICY_CHECK_ICV /* Allow all data and
                                                          control packets to be
                                                          permitted and
                                                          accounted regardless
                                                          of policy violation,
                                                          but do check and
                                                          account (but not drop)
                                                          for ICV violations. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_CHECK_NONE XFLOW_MACSEC_DECRYPT_POLICY_CHECK_NONE /* Allow all data and
                                                          control packets to be
                                                          permitted and
                                                          accounted regardless
                                                          of policy violation
                                                          and do not perform an
                                                          ICV check. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_UNTAGGED_CONTROL_PORT_ENABLE XFLOW_MACSEC_DECRYPT_POLICY_UNTAGGED_CONTROL_PORT_ENABLE /* Allow data packets
                                                          which are untagged
                                                          (i.e., they don't have
                                                          a SecTAG) to be
                                                          processed by the
                                                          MACsec logic. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_TAGGED_CONTROL_PORT_ENABLE XFLOW_MACSEC_DECRYPT_POLICY_TAGGED_CONTROL_PORT_ENABLE /* Allow data
                                                          (non-management)
                                                          packets which are
                                                          tagged (i.e., they
                                                          have a SecTAG) to be
                                                          processed by the
                                                          MACsec logic. */
#define BCM_XFLOW_MACSEC_DECRYPT_POLICY_POINT_TO_POINT_ENABLE XFLOW_MACSEC_DECRYPT_POLICY_POINT_TO_POINT_ENABLE /* Enable the point to
                                                          point mode in the
                                                          Policy table. This
                                                          mode is disabled by
                                                          default. The SCI value
                                                          is only programmed
                                                          when point to point
                                                          mode is enabled. */

typedef xflow_macsec_policy_id_t bcm_xflow_macsec_policy_id_t;

typedef xflow_macsec_policy_info_t bcm_xflow_macsec_decrypt_policy_info_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Create a Macsec decrypt policy. Returns the policy_id. */
extern int bcm_xflow_macsec_decrypt_policy_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info, 
    bcm_xflow_macsec_policy_id_t *policy_id);

/* 
 * Set/Replace one of the parameters of an existing decrypt policy
 * configuration.
 */
extern int bcm_xflow_macsec_decrypt_policy_set(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info);

/* Get the decrypt policy configuration given the policy_id. */
extern int bcm_xflow_macsec_decrypt_policy_get(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info);

/* Get the decrypt policy configuration given the policy_id. */
extern int bcm_xflow_macsec_decrypt_policy_destroy(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize the data structure. */
extern void bcm_xflow_macsec_decrypt_policy_info_t_init(
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info);

#define BCM_XFLOW_MACSEC_DECRYPT_FLOW_ID_CREATE(id)                  \
                XFLOW_MACSEC_FLOW_ID_CREATE(XFLOW_MACSEC_DECRYPT, assoc_id) 
#define BCM_XFLOW_MACSEC_FLOW_WITH_ID       XFLOW_MACSEC_FLOW_WITH_ID /* To be used when flows
                                                          need to be created
                                                          with a particular id */
#define BCM_XFLOW_MACSEC_FLOW_TPID_SEL_0    XFLOW_MACSEC_FLOW_TPID_SEL_0 /* Select the first TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_FLOW_TPID_SEL_1    XFLOW_MACSEC_FLOW_TPID_SEL_1 /* Select the second TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_FLOW_TPID_SEL_2    XFLOW_MACSEC_FLOW_TPID_SEL_2 /* Select the third TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_FLOW_TPID_SEL_3    XFLOW_MACSEC_FLOW_TPID_SEL_3 /* Select the fourth TPID
                                                          to be matched. */

typedef xflow_macsec_flow_id_t bcm_xflow_macsec_flow_id_t;

typedef xflow_macsec_flow_info_t bcm_xflow_macsec_decrypt_flow_info_t;

typedef enum bcm_xflow_macsec_decrypt_flow_pkt_type_e {
    BCM_XFLOW_MACSEC_DECRYPT_FLOW_NON_MACSEC_PKT = XFLOW_MACSEC_DECRYPT_FLOW_NON_MACSEC_PKT, 
    BCM_XFLOW_MACSEC_DECRYPT_FLOW_MACSEC = XFLOW_MACSEC_DECRYPT_FLOW_MACSEC, 
    BCM_XFLOW_MACSEC_DECRYPT_FLOW_MANAGEMENT = XFLOW_MACSEC_DECRYPT_FLOW_MANAGEMENT, 
    BCM_XFLOW_MACSEC_DECRYPT_FLOW_KAY = XFLOW_MACSEC_DECRYPT_FLOW_KAY 
} bcm_xflow_macsec_decrypt_flow_pkt_type_t;

typedef enum bcm_xflow_macsec_decrypt_flow_etype_e {
    BCM_XFLOW_MACSEC_FLOW_ETYPE_EII = XFLOW_MACSEC_FLOW_ETYPE_EII, 
    BCM_XFLOW_MACSEC_FLOW_ETYPE_SNAP = XFLOW_MACSEC_FLOW_ETYPE_SNAP, 
    BCM_XFLOW_MACSEC_FLOW_ETYPE_LLC = XFLOW_MACSEC_FLOW_ETYPE_LLC, 
    BCM_XFLOW_MACSEC_FLOW_ETYPE_MPLS = XFLOW_MACSEC_FLOW_ETYPE_MPLS 
} bcm_xflow_macsec_decrypt_flow_etype_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Creates a flow entry in the decrypt TCAM which is used to match
 * packets that need decryption. Matched entry results in an index to the
 * policy table.
 */
extern int bcm_xflow_macsec_decrypt_flow_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int priority, 
    bcm_xflow_macsec_flow_id_t *flow_id);

/* Set/Replace one of the parameters in the flow criteria. */
extern int bcm_xflow_macsec_decrypt_flow_set(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int priority);

/* Get the flow configuration given a flow index. */
extern int bcm_xflow_macsec_decrypt_flow_get(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int *priority);

/* 
 * Delete a flow configuration given a flow index. This does not delete
 * the policy configuration.
 */
extern int bcm_xflow_macsec_decrypt_flow_destroy(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize the data structure. */
extern void bcm_xflow_macsec_decrypt_flow_info_t_init(
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable a flow given the flow index. */
extern int bcm_xflow_macsec_decrypt_flow_enable_set(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    int enable);

/* Disable a flow given the flow index. */
extern int bcm_xflow_macsec_decrypt_flow_enable_get(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    int *enable);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef xflow_macsec_id_t bcm_xflow_macsec_id_t;

typedef xflow_macsec_subport_num_t bcm_xflow_macsec_subport_num_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Gives the subport number corresponding to an encrypt or decrypt
 * channel.
 */
extern int bcm_xflow_macsec_subport_num_get(
    int unit, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_subport_num_t *macsec_subport_num);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef enum bcm_xflow_macsec_control_e {
    BCM_XFLOW_MACSEC_CONTROL_DECRYPT_PAD_THRESHOLD = XFLOW_MACSEC_CONTROL_DECRYPT_PAD_THRESHOLD, 
    BCM_XFLOW_MACSEC_CONTROL_DECRYPT_SECTAG_C1_E0_ERROR = XFLOW_MACSEC_CONTROL_DECRYPT_SECTAG_C1_E0_ERROR, 
    BCM_XFLOW_MACSEC_CONTROL_DECRYPT_FAIL_SWITCH_TO_CPU = XFLOW_MACSEC_CONTROL_DECRYPT_FAIL_SWITCH_TO_CPU, 
    BCM_XFLOW_MACSEC_CONTROL_ENCRYPT_FAIL_SWITCH_TO_CPU = XFLOW_MACSEC_CONTROL_ENCRYPT_FAIL_SWITCH_TO_CPU 
} bcm_xflow_macsec_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Sets the value in HW for the macsec control type provided. */
extern int bcm_xflow_macsec_control_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_control_t type, 
    int value);

/* Gets the value from HW for the macsec control type provided. */
extern int bcm_xflow_macsec_control_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_control_t type, 
    int *value);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef enum bcm_xflow_macsec_stat_type_e {
    bcmXflowMacsecStatTypeInvalid = xflowMacsecStatTypeInvalid , 
    bcmXflowMacsecUnctrlPortInOctets = xflowMacsecUnctrlPortInOctets, 
    bcmXflowMacsecUnctrlPortInUcastPkts = xflowMacsecUnctrlPortInUcastPkts, 
    bcmXflowMacsecUnctrlPortInMulticastPkts = xflowMacsecUnctrlPortInMulticastPkts, 
    bcmXflowMacsecUnctrlPortInBroadcastPkts = xflowMacsecUnctrlPortInBroadcastPkts, 
    bcmXflowMacsecUnctrlPortInDiscards = xflowMacsecUnctrlPortInDiscards, 
    bcmXflowMacsecUnctrlPortOutOctets = xflowMacsecUnctrlPortOutOctets, 
    bcmXflowMacsecUnctrlPortOutUcastPkts = xflowMacsecUnctrlPortOutUcastPkts, 
    bcmXflowMacsecUnctrlPortOutMulticastPkts = xflowMacsecUnctrlPortOutMulticastPkts, 
    bcmXflowMacsecUnctrlPortOutBroadcastPkts = xflowMacsecUnctrlPortOutBroadcastPkts, 
    bcmXflowMacsecUnctrlPortOutErrors = xflowMacsecUnctrlPortOutErrors, 
    bcmXflowMacsecCtrlPortInOctets = xflowMacsecCtrlPortInOctets, 
    bcmXflowMacsecCtrlPortInUcastPkts = xflowMacsecCtrlPortInUcastPkts, 
    bcmXflowMacsecCtrlPortInMulticastPkts = xflowMacsecCtrlPortInMulticastPkts, 
    bcmXflowMacsecCtrlPortInBroadcastPkts = xflowMacsecCtrlPortInBroadcastPkts, 
    bcmXflowMacsecCtrlPortInDiscards = xflowMacsecCtrlPortInDiscards, 
    bcmXflowMacsecCtrlPortInErrors = xflowMacsecCtrlPortInErrors, 
    bcmXflowMacsecCtrlPortOutOctets = xflowMacsecCtrlPortOutOctets, 
    bcmXflowMacsecCtrlPortOutUcastPkts = xflowMacsecCtrlPortOutUcastPkts, 
    bcmXflowMacsecCtrlPortOutMulticastPkts = xflowMacsecCtrlPortOutMulticastPkts, 
    bcmXflowMacsecCtrlPortOutBroadcastPkts = xflowMacsecCtrlPortOutBroadcastPkts, 
    bcmXflowMacsecCtrlPortOutErrors = xflowMacsecCtrlPortOutErrors, 
    bcmXflowMacsecSecyStatsTxUntaggedPkts = xflowMacsecSecyStatsTxUntaggedPkts, 
    bcmXflowMacsecSecyStatsTxTooLongPkts = xflowMacsecSecyStatsTxTooLongPkts, 
    bcmXflowMacsecSecyStatsRxUntaggedPkts = xflowMacsecSecyStatsRxUntaggedPkts, 
    bcmXflowMacsecSecyStatsRxNoTagPkts = xflowMacsecSecyStatsRxNoTagPkts, 
    bcmXflowMacsecSecyStatsRxBadTagPkts = xflowMacsecSecyStatsRxBadTagPkts, 
    bcmXflowMacsecSecyStatsRxUnknownSCIPkts = xflowMacsecSecyStatsRxUnknownSCIPkts, 
    bcmXflowMacsecSecyStatsRxNoSCIPkts = xflowMacsecSecyStatsRxNoSCIPkts, 
    bcmXflowMacsecSecyStatsRxOverrunPkts = xflowMacsecSecyStatsRxOverrunPkts, 
    bcmXflowMacsecSecyTxSCStatsProtectedPkts = xflowMacsecSecyTxSCStatsProtectedPkts, 
    bcmXflowMacsecSecyTxSCStatsEncryptedPkts = xflowMacsecSecyTxSCStatsEncryptedPkts, 
    bcmXflowMacsecSecyTxSCStatsOctetsProtected = xflowMacsecSecyTxSCStatsOctetsProtected, 
    bcmXflowMacsecSecyTxSCStatsOctetsEncrypted = xflowMacsecSecyTxSCStatsOctetsEncrypted, 
    bcmXflowMacsecSecyRxSCStatsUnusedSAPkts = xflowMacsecSecyRxSCStatsUnusedSAPkts, 
    bcmXflowMacsecSecyRxSCStatsNotUsingSAPkts = xflowMacsecSecyRxSCStatsNotUsingSAPkts, 
    bcmXflowMacsecSecyRxSCStatsLatePkts = xflowMacsecSecyRxSCStatsLatePkts, 
    bcmXflowMacsecSecyRxSCStatsNotValidPkts = xflowMacsecSecyRxSCStatsNotValidPkts, 
    bcmXflowMacsecSecyRxSCStatsInvalidPkts = xflowMacsecSecyRxSCStatsInvalidPkts, 
    bcmXflowMacsecSecyRxSCStatsDelayedPkts = xflowMacsecSecyRxSCStatsDelayedPkts, 
    bcmXflowMacsecSecyRxSCStatsUncheckedPkts = xflowMacsecSecyRxSCStatsUncheckedPkts, 
    bcmXflowMacsecSecyRxSCStatsOKPkts = xflowMacsecSecyRxSCStatsOKPkts, 
    bcmXflowMacsecSecyRxSCStatsOctetsValidated = xflowMacsecSecyRxSCStatsOctetsValidated, 
    bcmXflowMacsecSecyRxSCStatsOctetsDecrypted = xflowMacsecSecyRxSCStatsOctetsDecrypted, 
    bcmXflowMacsecSecyTxSAStatsProtectedPkts = xflowMacsecSecyTxSAStatsProtectedPkts, 
    bcmXflowMacsecSecyTxSAStatsEncryptedPkts = xflowMacsecSecyTxSAStatsEncryptedPkts, 
    bcmXflowMacsecSecyRxSAStatsUnusedSAPkts = xflowMacsecSecyRxSAStatsUnusedSAPkts, 
    bcmXflowMacsecSecyRxSAStatsNotUsingSAPkts = xflowMacsecSecyRxSAStatsNotUsingSAPkts, 
    bcmXflowMacsecSecyRxSAStatsNotValidPkts = xflowMacsecSecyRxSAStatsNotValidPkts, 
    bcmXflowMacsecSecyRxSAStatsInvalidPkts = xflowMacsecSecyRxSAStatsInvalidPkts, 
    bcmXflowMacsecSecyRxSAStatsOKPkts = xflowMacsecSecyRxSAStatsOKPkts, 
    bcmXflowMacsecInMgmtPkts = xflowMacsecInMgmtPkts, 
    bcmXflowMacsecFlowTcamHitCntr = xflowMacsecFlowTcamHitCntr, 
    bcmXflowMacsecFlowTcamMissCntr = xflowMacsecFlowTcamMissCntr, 
    bcmXflowMacsecScTcamHitCntr = xflowMacsecScTcamHitCntr, 
    bcmXflowMacsecScTcamMissCntr = xflowMacsecScTcamMissCntr, 
    bcmXflowMacsecOutMgmtPkts = xflowMacsecOutMgmtPkts, 
    bcmXflowMacsecInPacketDropCntr = xflowMacsecInPacketDropCntr, 
    bcmXflowMacsecOutPacketDropCntr = xflowMacsecOutPacketDropCntr, 
    bcmXflowMacsecBadOlpHdrCntr = xflowMacsecBadOlpHdrCntr, 
    bcmXflowMacsecStatTypeCount = xflowMacsecStatTypeCount 
} bcm_xflow_macsec_stat_type_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Gets the counter value corresponding to the macsec_id and stat_type
 * provided.
 */
extern int bcm_xflow_macsec_stat_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_stat_type_t  stat_type, 
    uint64 *value);

/* 
 * Sets the counter value corresponding to the macsec_id and stat_type
 * provided.
 */
extern int bcm_xflow_macsec_stat_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_stat_type_t  stat_type, 
    uint64 value);

/* 
 * Gets an array of counter values corresponding to macsec_id and the
 * array of stat_type provided. The output ?stats_array? should be
 * allocated to hold ?array_count? number of values.
 */
extern int bcm_xflow_macsec_stat_multi_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    uint32 num_stats, 
    bcm_xflow_macsec_stat_type_t  *stat_type_array, 
    uint64 *value_array);

/* 
 * Sets an array of counter values corresponding to macsec_id and the
 * array of stat_type provided. The output ?stats_array? should be
 * allocated to hold ?array_count? number of values.
 */
extern int bcm_xflow_macsec_stat_multi_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    uint32 num_stats, 
    bcm_xflow_macsec_stat_type_t  *stat_type_array, 
    uint64 *value_array);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_MATCH_TPID_SEL_0   XFLOW_MACSEC_MATCH_TPID_SEL_0 /* Select the first TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_MATCH_TPID_SEL_1   XFLOW_MACSEC_MATCH_TPID_SEL_1 /* Select the second TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_MATCH_TPID_SEL_2   XFLOW_MACSEC_MATCH_TPID_SEL_2 /* Select the third TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_MATCH_TPID_SEL_3   XFLOW_MACSEC_MATCH_TPID_SEL_3 /* Select the fourth TPID
                                                          to be matched. */
#define BCM_XFLOW_MACSEC_VLAN_TPID_MAX      XFLOW_MACSEC_VLAN_TPID_MAX /* Total TPIDs
                                                          configurable */

typedef xflow_macsec_vlan_tpid_t bcm_xflow_macsec_vlan_tpid_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Set the four VLAN TPID for decrypt flow. */
extern int bcm_xflow_macsec_vlan_tpid_array_set(
    int unit, 
    bcm_xflow_macsec_vlan_tpid_t *vlan_tpid);

/* Retrieve the four vlan tpid configured. */
extern int bcm_xflow_macsec_vlan_tpid_array_get(
    int unit, 
    bcm_xflow_macsec_vlan_tpid_t *vlan_tpid);

/* 
 * Get the index corresponding to a TPID value. This is to be used in the
 * decrypt policy.
 */
extern int bcm_xflow_macsec_vlan_tpid_array_index_get(
    int unit, 
    uint32 vlan_tpid, 
    uint8 *tpid_index_sel);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_MTU_WITH_ID    XFLOW_MACSEC_MTU_WITH_ID /* The mtu_index is provided
                                                      as an input. */

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Set the MTU for encrypt or decrypt flow and get the corresponding MTU
 * index. The index can be used with SC config. To clear the value, set
 * mtu as 0 for the corresponding mtu_index (IN).
 */
extern int bcm_xflow_macsec_mtu_set(
    int unit, 
    int flags, 
    uint32 mtu, 
    uint32 *mtu_index);

/* Get the value corresponding to a MTU index. */
extern int bcm_xflow_macsec_mtu_get(
    int unit, 
    int flags, 
    uint32 mtu_index, 
    uint32 *mtu);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_XFLOW_MACSEC_ETHERTYPE_WITH_ID  XFLOW_MACSEC_ETHERTYPE_WITH_ID /* The sectag_etype_index
                                                          is provided as input. */

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Set the sectag Ethertype and get the corresponding ethertype index. To
 * clear this value, set the sectag_etype to 0 for the given
 * sectag_etype_index(IN) along with the appropriate flag. This API is
 * applicable to both encrypt and decrypt.
 */
extern int bcm_xflow_macsec_sectag_etype_set(
    int unit, 
    int flags, 
    uint32 sectag_etype, 
    uint32 *sectag_etype_index);

/* Get the value corresponding to a Sectag Ethertype index. */
extern int bcm_xflow_macsec_sectag_etype_get(
    int unit, 
    uint32 sectag_etype_index, 
    uint32 *sectag_etype);

#endif /* defined(INCLUDE_XFLOW_MACSEC) */

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_XFLOW_MACSEC_H__ */
