/** \file dnxc_sw_state_plain.c
 * This is the main dnxc sw state module.
 * Module is implementing the access itself. Plain implementation.
 */
/*
 * $Id: $
 * $Copyright: (c) 2017 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */

/* 
 * Note! 
 * This include statement must be at the top of every sw state .c file 
 * It points to a set of in-code compilation flags that must be taken into 
 * account for every sw state componnent compilation 
 */
#include <soc/dnxc/swstate/sw_state_features.h>
/* ---------- */

/*
 * Include files
 * {
 */
#include <assert.h>
#include <shared/bsl.h>
#include <shared/mem_measure_tool.h>
#include <soc/dnxc/swstate/sw_state_defs.h>
#include <soc/dnxc/swstate/dnxc_sw_state.h>
#include <soc/dnxc/swstate/dnxc_sw_state_plain.h>
#include <soc/dnxc/swstate/dnxc_sw_state_journal.h>
#include <shared/shrextend/shrextend_debug.h>
/*
 * }
 */

#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif

#define BSL_LOG_MODULE BSL_LS_SWSTATEDNX_GENERAL

/*
 * Defines
 * {
 */

dnxc_sw_state_allocation_dll_t dnxc_sw_state_allocation_dll[SOC_MAX_NUM_DEVICES];

#if 1
#define DNX_SW_STATE_MEMORY_MEASUREMENT_INCREASE(_size)
#endif

/**
 * \brief - allocate memory, record allocated memory
 */
#define DNX_SW_STATE_ALLOC_PLAIN_INTERNAL(_ptr, _ptr_type, _size, _dbg_string)                                              \
do {                                                                                                                        \
    (_ptr) = (_ptr_type *)sal_alloc(_size, _dbg_string);                                                                    \
    if(NULL == (_ptr)) {                                                                                                    \
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_MEMORY, "sw state ERROR: failed to allocate data\n%s%s%s", EMPTY, EMPTY, EMPTY);     \
    }                                                                                                                       \
    sal_memset((void *)(_ptr), 0x0, _size);                                                                                 \
    DNX_SW_STATE_MEMORY_MEASUREMENT_INCREASE(_size);                                                                        \
    sal_set_alloc_counters_offset(_size, 0);                                                                                \
} while(0)

#define DNX_SW_STATE_FREE_PLAIN_INTERNAL(_ptr, _size)   \
do {                                                    \
    sal_free((void *)(_ptr));                           \
    (_ptr) = NULL;                                      \
    sal_set_alloc_counters_offset(0, _size);            \
} while(0)

/**
 * \brief - validate ptr integrity, start santinel
 */
#define DNXC_SW_STATE_VALIDATE_PTR_START_SANTINEL(_ptr) \
    assert(((dnxc_sw_state_allocation_data_prefix_t *)(((uint8 *)_ptr) - sizeof(dnxc_sw_state_allocation_data_prefix_t)))->start_santinel == DNX_SWSTATE_MEMORY_ALLOCATION_START_SANTINEL)

/**
 * \brief - validate ptr integrity, end santinel
 */
#define DNXC_SW_STATE_VALIDATE_PTR_END_SANTINEL(_ptr, _size) \
    assert(((dnxc_sw_state_allocation_data_suffix_t *)(((uint8 *)_ptr) + _size))->end_santinel == DNX_SWSTATE_MEMORY_ALLOCATION_END_SANTINEL)

/**
 * \brief - validate ptr integrity
 */
#define DNXC_SW_STATE_VALIDATE_PTR(_ptr,_size)              \
do {                                                        \
    DNXC_SW_STATE_VALIDATE_PTR_START_SANTINEL(_ptr);        \
    DNXC_SW_STATE_VALIDATE_PTR_END_SANTINEL(_ptr, _size);   \
} while(0)
/*
 * }
 */

/**
 * \brief - check if sw state allocation size is valid and permitted
 */
STATIC int dnxc_sw_state_size_verify_plain(int unit, uint32 alloc_size, uint32 flags)
{
    DNX_SW_STATE_INIT_FUNC_DEFS;

    /*
     * check if we are attempting to allocate bigger size than permitted
     * allow big allocations for non-autogenerated sw state allocations
     */
    if(!(sw_state_is_flag_on(flags, DNX_SW_STATE_DNX_DATA_ALLOC)) && 
       !(sw_state_is_flag_on(flags, DNX_SW_STATE_DNX_DATA_ALLOC_EXCEPTION)) &&
       !(sw_state_is_flag_on(flags, DNX_SW_STATE_JOURNAL_ROLLING_BACK)) &&
        (sw_state_is_flag_on(flags, DNX_SW_STATE_AUTO_GENERATED_ALLOCATION)) &&
        (alloc_size > DNX_SW_STATE_ALLOC_MAX_BYTES)) { 
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: size allocated is bigger than permitted by DNX_SW_STATE_ALLOC_MAX_BYTES \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    DNX_SW_STATE_FUNC_RETURN;
}

/**
 * \brief - create a new doubled linked list entry and add it to the list
 */
STATIC int dnxc_sw_state_dll_entry_add(int unit, uint8 **ptr_location, dnxc_sw_state_allocation_data_prefix_t *ptr_prefix)
{
    dnxc_sw_state_allocation_dll_entry_t *entry = NULL;
    dnxc_sw_state_allocation_dll_entry_t *prev = NULL;

    DNX_SW_STATE_INIT_FUNC_DEFS;

    DNX_SW_STATE_ALLOC_PLAIN_INTERNAL(entry, dnxc_sw_state_allocation_dll_entry_t, sizeof(dnxc_sw_state_allocation_dll_entry_t), "sw state dll entry");

    entry->prev = NULL;
    entry->next = NULL;
    entry->ptr = *ptr_location;
    entry->ptr_location = ptr_location;

    /*
     * add entry to double linked list
     * don't store ptr_location for swstate structure allocations
     */
    if(NULL == dnxc_sw_state_allocation_dll[unit].head) {
        dnxc_sw_state_allocation_dll[unit].head = entry;
        dnxc_sw_state_allocation_dll[unit].tail = entry;
    } else {
        prev = dnxc_sw_state_allocation_dll[unit].tail;
        entry->prev = prev;
        prev->next = entry;
        dnxc_sw_state_allocation_dll[unit].tail = entry;
    }

    /*
     * add a reference to the dll
     */
    ptr_prefix->dll_entry = entry;

    dnxc_sw_state_allocation_dll[unit].entry_counter++;

    DNX_SW_STATE_FUNC_RETURN;
}

/**
 * \brief - disconnects a double linked list entry from the list,
 */
STATIC int dnxc_sw_state_dll_entry_free(int unit, dnxc_sw_state_allocation_dll_entry_t *dll_entry)
{
    DNX_SW_STATE_INIT_FUNC_DEFS;

    if(NULL == dll_entry) {
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: cannot free NULL dll_entry \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    /*
     * disconnect entry from linked list
     */
    if((NULL == dll_entry->next) && (NULL == dll_entry->prev )) {
        /*
         * only entry in the linked list scenario, no need to disconnect
         */
        dnxc_sw_state_allocation_dll[unit].head = NULL;
        dnxc_sw_state_allocation_dll[unit].tail = NULL;
    } else {
        /*
         * disconnect previous, if needed
         */
        if(NULL == dll_entry->prev){
            dnxc_sw_state_allocation_dll[unit].head = dll_entry->next;
            dnxc_sw_state_allocation_dll[unit].head->prev = NULL;
        } else {
            dll_entry->prev->next = dll_entry->next;
        }

        /*
         * disconnect next, if needed
         */
        if(NULL == dll_entry->next){
            dnxc_sw_state_allocation_dll[unit].tail = dll_entry->prev;
            dnxc_sw_state_allocation_dll[unit].tail->next = NULL;
        } else {
            dll_entry->next->prev = dll_entry->prev;
        }
    }

    /*
     * free entry, decrease counter
     */
    DNX_SW_STATE_FREE_PLAIN_INTERNAL(dll_entry, sizeof(dnxc_sw_state_allocation_dll_entry_t));

    dnxc_sw_state_allocation_dll[unit].entry_counter--;

    DNX_SW_STATE_FUNC_RETURN;
}

/**
 * \brief - Calculates the location of the real pointer and frees the allocated data.
 */
STATIC int dnxc_sw_state_free_sw_state_pointer(int unit, uint32 module_id, uint8 *ptr)
{
    uint32 size = 0;
    uint32 nof_elements = 0;
    uint32 element_size = 0;
    uint8 *real_ptr = NULL;

    DNX_SW_STATE_INIT_FUNC_DEFS;

    /* 
     * get the full allocation size, pointer integration test is performed internally
     */
    SHR_IF_ERR_EXIT(dnxc_sw_state_alloc_size_plain(unit, module_id, ptr, &nof_elements, &element_size));
    size = nof_elements * element_size;
    DNXC_SW_STATE_ALIGN_SIZE(size);
    size += (sizeof(dnxc_sw_state_allocation_data_prefix_t) + sizeof(dnxc_sw_state_allocation_data_suffix_t));

    /*
     * calculate the location of the real pointer and free memory
     */
    real_ptr = (ptr - sizeof(dnxc_sw_state_allocation_data_prefix_t));

    DNX_SW_STATE_FREE_PLAIN_INTERNAL(real_ptr, size);

    DNX_SW_STATE_FUNC_RETURN;
}


/*
 * see .h file for description
 */
int dnxc_sw_state_init_plain(
    int unit,
    uint32 flags)
{
    dnxc_sw_state_allocation_dll[unit].entry_counter = 0;
    dnxc_sw_state_allocation_dll[unit].head = NULL;
    dnxc_sw_state_allocation_dll[unit].tail = NULL;

    sw_state_roots_array[unit] = sal_alloc(sizeof(void*) * NOF_MODULE_ID, "alloc sw state roots array (plain implementation)");
    sal_memset(sw_state_roots_array[unit], 0, sizeof(void*) * NOF_MODULE_ID);
    
    return SOC_E_NONE;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_deinit_plain(
    int unit,
    uint32 flags)
{
    /*
     * use a default module_id in freeing all sw state memory
     */
    uint32 module_id = 0;

    dnxc_sw_state_allocation_dll_entry_t *entry = dnxc_sw_state_allocation_dll[unit].tail;
    dnxc_sw_state_allocation_dll_entry_t *prev = NULL;

    DNX_SW_STATE_INIT_FUNC_DEFS;

    /*
     * traverse double linked list, tail --> head
     * free double linked list entry, free associated sw state memory
     */
    while(entry != NULL) {

        /*
         * free sw state pointer, put null in sw state location
         */
        SHR_IF_ERR_EXIT(dnxc_sw_state_free_sw_state_pointer(unit, module_id, entry->ptr));

        
        /*
         * set null in sw state only if the pointer kept in the dynamic linked list entry
         * is the same as the one pointed to by ptr_location
         */
        if(entry->ptr == *(entry->ptr_location))
        {
            *(entry->ptr_location) = NULL;
        }

        /*
         * free associated double linked list entry
         */
        prev = entry->prev;
        SHR_IF_ERR_EXIT(dnxc_sw_state_dll_entry_free(unit, entry));

        entry = prev;
    }

    dnxc_sw_state_allocation_dll[unit].entry_counter = 0;
    dnxc_sw_state_allocation_dll[unit].head = NULL;
    dnxc_sw_state_allocation_dll[unit].tail = NULL;

    sal_free(sw_state_roots_array[unit]);
    DNX_SW_STATE_FUNC_RETURN;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_module_init_plain(int unit, uint32 module_id, uint32 size, uint32 flags, char *dbg_string)
{
    DNX_SW_STATE_INIT_FUNC_DEFS;

    SHR_IF_ERR_EXIT(dnxc_sw_state_alloc_plain(unit, module_id, (uint8**)&sw_state_roots_array[unit][module_id], 1, size, flags, dbg_string));

    DNX_SW_STATE_FUNC_RETURN;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_module_deinit_plain(int unit, uint32 module_id, uint32 flags, char *dbg_string)
{
    DNX_SW_STATE_INIT_FUNC_DEFS;

    SHR_IF_ERR_EXIT(dnxc_sw_state_free_plain(unit, module_id, (uint8**)&sw_state_roots_array[unit][module_id], flags, dbg_string));

    DNX_SW_STATE_FUNC_RETURN;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_alloc_plain(int unit, uint32 module_id, uint8 **ptr_location, uint32 nof_elements, uint32 element_size, uint32 flags, char* dbg_string)
{

/**
 *                                   STRUCTURE OF SW STATE ALLOCATION
 *  +----------------+----------------+--------------+--------------+-------------------------+--------------+
 *  | start_santinel |     ptr_ll     | nof_elements | element_size |         DATA            | end_santinel |
 *  +----------------+----------------+--------------+--------------+-------------------------+--------------+
 *       4 bytes     sizeof(dll_entry*)    4 bytes        4 bytes     n bytes (4 byte rounded)     4 bytes    
 *
 *                            (total size = size + 16 + sizeof(uint8 *) + alignment padding)
 */

    uint32 size = 0;
    uint32 full_size = 0;

    /*
     * pointers to the prefix and suffix portion of the allocated chunk
     */
    dnxc_sw_state_allocation_data_prefix_t *ptr_prefix = NULL;
    dnxc_sw_state_allocation_data_suffix_t *ptr_suffix = NULL;

    DNX_SW_STATE_INIT_FUNC_DEFS;

    /*
     * calculate allocation size and round it up to next 32 bit
     */
    size = nof_elements * element_size;
    DNXC_SW_STATE_ALIGN_SIZE(size);

    /*
     * check if we are trying to allocate memory after init
     */
    if(!(dnx_sw_state_alloc_during_test_get(unit)
       || !(SOC_IS_DONE_INIT(unit))
       || (sw_state_is_flag_on(flags, DNX_SW_STATE_ALLOC_AFTER_INIT_EXCEPTION))
       || (sw_state_is_flag_on(flags,  DNX_SW_STATE_JOURNAL_ROLLING_BACK)))) {
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: trying to allocate data after init \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    /*
     * check if we are attempting to allocate bigger size than permitted 
     */
    SHR_IF_ERR_EXIT(dnxc_sw_state_size_verify_plain(unit, size, flags));

    /*
     * double allocation attempted
     */
    if(NULL != *ptr_location) {
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: double allocation attempted. Allocation can be performed on NULL pointers only. \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    /*
     * calculate the full size as size of data + prefix + suffix.
     * allocate memory for the entire chunk, clear memory
     */
    full_size = sizeof(dnxc_sw_state_allocation_data_prefix_t) + size + sizeof(dnxc_sw_state_allocation_data_suffix_t);

    DNX_SW_STATE_ALLOC_PLAIN_INTERNAL(*ptr_location, uint8, full_size, dbg_string);

    /*
     * calculate the location of the prefix segment, set prefix fields
     */
    ptr_prefix = (dnxc_sw_state_allocation_data_prefix_t *)(*ptr_location);
    ptr_prefix->start_santinel = DNX_SWSTATE_MEMORY_ALLOCATION_START_SANTINEL;
    ptr_prefix->nof_elements = nof_elements;
    ptr_prefix->element_size = element_size;

    /*
     * adjust ptr_location to point to the data segment 
     */
    *ptr_location += sizeof(dnxc_sw_state_allocation_data_prefix_t);

    /*
     * calculate the location of the suffix segment, set suffix fields
     */
    ptr_suffix = (dnxc_sw_state_allocation_data_suffix_t *)(*ptr_location + size);
    ptr_suffix->end_santinel = DNX_SWSTATE_MEMORY_ALLOCATION_END_SANTINEL;

    /*
     * create a new dynamic linked list entry and add a reference to it in memory
     */
    SHR_IF_ERR_EXIT(dnxc_sw_state_dll_entry_add(unit, ptr_location, ptr_prefix));

    /* journal an alloc entry, if journaling is enabled */
    if(!sw_state_is_flag_on(flags,  DNX_SW_STATE_JOURNAL_ROLLING_BACK)) {
        SHR_IF_ERR_EXIT(dnxc_sw_state_journal_log_alloc(unit, module_id, ptr_location));
    }

    DNX_SW_STATE_FUNC_RETURN;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_alloc_size_plain(int unit, uint32 module, uint8 *location, uint32 *nof_elements, uint32 *element_size)
{

    uint32 size = 0;
    dnxc_sw_state_allocation_data_prefix_t *ptr_prefix = NULL;

    DNX_SW_STATE_INIT_FUNC_DEFS;

    if ((NULL == location) || (NULL == nof_elements) || (NULL == element_size)) {
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: invalid parameter \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    /*
     * adjust location to beginning of allocation
     */
    ptr_prefix = (dnxc_sw_state_allocation_data_prefix_t *)(location - sizeof(dnxc_sw_state_allocation_data_prefix_t));

    *nof_elements = ptr_prefix->nof_elements;
    *element_size = ptr_prefix->element_size;

    size = ptr_prefix->nof_elements * ptr_prefix->element_size;
    DNXC_SW_STATE_ALIGN_SIZE(size);

    DNXC_SW_STATE_VALIDATE_PTR(location, size);

    DNX_SW_STATE_FUNC_RETURN;
}


/*
 * see .h file for description
 */
int dnxc_sw_state_free_plain(int unit, uint32 module_id, uint8 **ptr_location, uint32 flags, char *dbg_string)
{
    int result = SOC_E_NONE;
    uint32 nof_elements = 0;
    uint32 element_size = 0;

    /*
     * points to the prefix portion of the allocated chunk
     */
    dnxc_sw_state_allocation_data_prefix_t *ptr_prefix = NULL;

    /*
     * the double linked list entry associated with the allocation
     */
    dnxc_sw_state_allocation_dll_entry_t *dll_entry = NULL;

    DNX_SW_STATE_INIT_FUNC_DEFS;

    /*
     * validate input
     */
    if (NULL == ptr_location ) {
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: ptr is an invalid pointer \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    if (NULL == (*ptr_location)) {
        return SOC_E_NONE;
    }

    /*
     * journal a free entry, if journaling is enabled
     */ 
    dnxc_sw_state_alloc_size_plain(unit, module_id, *ptr_location, &nof_elements, &element_size);
    if(!sw_state_is_flag_on(flags, DNX_SW_STATE_JOURNAL_ROLLING_BACK)) {
        result = dnxc_sw_state_journal_log_free(unit, module_id, nof_elements, element_size, ptr_location);
    }

    /* 
     * calculate the location of the prefix segment
     */
    ptr_prefix = (dnxc_sw_state_allocation_data_prefix_t *)((uint8 *)(*ptr_location) - sizeof(dnxc_sw_state_allocation_data_prefix_t));

    /*
     * retrieve the associated dynamic linked list entry
     */
    dll_entry = ptr_prefix->dll_entry;

    /*
     * sanity check the double linked list pointer.
     */
    if(((dll_entry->ptr_location != ptr_location) && !sw_state_is_flag_on(flags, DNX_SW_STATE_LINKED_LIST_FREE)) 
        || (dll_entry->ptr != *ptr_location)) {
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: associated linked list entry stores a different sw state pointer value \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    /*
     * free sw state pointer, put null in sw state location
     */
    SHR_IF_ERR_EXIT(dnxc_sw_state_free_sw_state_pointer(unit, module_id, *ptr_location));
    *ptr_location = NULL;

    /*
     * free associated double linked list entry
     */
    SHR_IF_ERR_EXIT(dnxc_sw_state_dll_entry_free(unit, dll_entry));

    if(SOC_E_NONE != result) {
        return result;
    }

    DNX_SW_STATE_FUNC_RETURN;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_memcpy_plain(int unit, uint32 module_id, uint32 size, uint8 *dest, uint8 *src, uint32 flags, char *dbg_string)
{
    DNX_SW_STATE_INIT_FUNC_DEFS;

    if(NULL == dest || NULL == src) {
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: invalid parameter \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    /* journal a memcpy entry, if journaling is enabled */
    if(!sw_state_is_flag_on(flags,  DNX_SW_STATE_JOURNAL_ROLLING_BACK)) {
        SHR_IF_ERR_EXIT(dnxc_sw_state_journal_log_memcpy(unit, module_id, size, dest));
    }

    sal_memcpy(dest, src, size);

    DNX_SW_STATE_FUNC_RETURN;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_memset_plain(int unit, uint32 module_id, uint8 *dest, uint32 value, uint32 size, uint32 flags, char *dbg_string)
{
    DNX_SW_STATE_INIT_FUNC_DEFS;

    if(NULL == dest) {
        SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: invalid parameter \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

	if(!sw_state_is_flag_on(flags,  DNX_SW_STATE_JOURNAL_ROLLING_BACK)) {
        SHR_IF_ERR_EXIT(dnxc_sw_state_journal_log_memcpy(unit, module_id, size, dest));
    }

    sal_memset(dest, value, size);

    DNX_SW_STATE_FUNC_RETURN;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_counter_inc_plain(int unit, uint32 module_id, uint8 *ptr_location, uint32 inc_value, uint32 type_size, uint32 flags, char *dbg_string)
{
    DNX_SW_STATE_INIT_FUNC_DEFS;

    switch(type_size) {
        case 1:
            if(!sw_state_is_flag_on(flags,  DNX_SW_STATE_JOURNAL_ROLLING_BACK)) {
                SHR_IF_ERR_EXIT(dnxc_sw_state_journal_log_memcpy(unit, module_id, 1, ptr_location));
            }
            (*(uint8 *)(ptr_location))+=inc_value;
            break;
        case 4:
            if(!sw_state_is_flag_on(flags,  DNX_SW_STATE_JOURNAL_ROLLING_BACK)) {
                SHR_IF_ERR_EXIT(dnxc_sw_state_journal_log_memcpy(unit, module_id, 4, ptr_location));
            }
            (*(uint32 *)(ptr_location))+=inc_value;
            break;
        default:
            SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: Unsupported counter type \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    DNX_SW_STATE_FUNC_RETURN;
}

/*
 * see .h file for description
 */
int dnxc_sw_state_counter_dec_plain(int unit, uint32 module_id, uint8 *ptr_location, uint32 dec_value, uint32 type_size, uint32 flags, char *dbg_string)
{
    DNX_SW_STATE_INIT_FUNC_DEFS;

    switch(type_size) {
        case 1:
            if(!sw_state_is_flag_on(flags,  DNX_SW_STATE_JOURNAL_ROLLING_BACK)) {
                SHR_IF_ERR_EXIT(dnxc_sw_state_journal_log_memcpy(unit, module_id, 1, ptr_location));
            }
            (*(uint8 *)(ptr_location))-=dec_value;
            break;
        case 4:
            if(!sw_state_is_flag_on(flags,  DNX_SW_STATE_JOURNAL_ROLLING_BACK)) {
                SHR_IF_ERR_EXIT(dnxc_sw_state_journal_log_memcpy(unit, module_id, 4, ptr_location));
            }
            (*(uint32 *)(ptr_location))-=dec_value;
            break;
        default:
            SHR_IF_ERR_EXIT_WITH_LOG(SOC_E_INTERNAL, "sw state ERROR: Unsupported counter type \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

    DNX_SW_STATE_FUNC_RETURN;
}

#undef _ERR_MSG_MODULE_NAME
