/*
 * Product: EmWeb
 * Release: R6_2_0
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION OF VIRATA CORPORATION
 * THE EMWEB SOFTWARE ARCHITECTURE IS PATENTED (US PATENT #5,973,696)
 * AND OTHER US AND INTERNATIONAL PATENTS PENDING.
 * 'EMWEB' AND 'EMSTACK' ARE TRADEMARKS OF VIRATA CORPORATION
 * 
 * Notice to Users of this Software Product:
 * 
 * This software product of Virata Corporation ("Virata"), 5 Clock Tower
 * Place, Suite 400, Maynard, MA  01754 (e-mail: info@virata.com) in 
 * source and object code format embodies valuable intellectual property 
 * including trade secrets, copyrights and patents which are the exclusive
 * proprietary property of Virata. Access, use, reproduction, modification
 * disclsoure and distribution are expressly prohibited unless authorized
 * in writing by Virata.  Under no circumstances may you copy this
 * software or distribute it to anyone else by any means whatsoever except in
 * strict accordance with a license agreement between Virata and your
 * company.  This software is also protected under patent, trademark and 
 * copyright laws of the United States and foreign countries, as well as 
 * under the license agreement, against any unauthorized copying, modification,
 * or distribution.
 * Please see your supervisor or manager regarding any questions that you may
 * have about your right to use this software product.  Thank you for your
 * cooperation.
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Virata Corporation
 * All Rights Reserved
 * 
 * Virata Corporation
 * 5 Clock Tower Place
 * Suite 400
 * Maynard, MA  01754
 * 
 * Voice: +1 (978) 461-0888
 * Fax:   +1 (978) 461-2080
 * 
 * http://www.emweb.com/
 *   support@agranat.com
 *     sales@agranat.com
 *
 * EmWeb/Server HTTP header parsing
 *
 */

#include "ews.h"
#include "ews_pars.h"
#include "ews_serv.h"
#include "ews_send.h"
#include "ews_form.h"
#include "ews_sys.h"
#include "ews_gway.h"

/*
 * ews_request_header_table
 *
 * NOTE: This table is in the same order as EwsRequestHeaderIndex. Changes
 *       here must be reflected in the EwsRequestHeaderIndex defined
 *       in ews_pars.h.
 */
const EwsConstCharP ews_request_header_table[] =
  {
    "", /* Unknown header - not referenced */

    /*
     * The non-dummy elements of this array are generated by including
     * ews_req.h with EW_REQ_TABLE defined.  EwsRequestHeaderIndex is
     * constructed by ews_req.h as well.  This ensures that the two
     * are conditionalized in the same way, which reduces errors.
     */
#define EW_REQ_TABLE
#include "ews_req.h"
#undef EW_REQ_TABLE

    NULL

  };

#ifdef EW_CONFIG_OPTION_FIELDTYPE_FILE
/*
 * ews_form_data_header_table
 *
 * A table that translates the form-data header enums above to
 * their string representation that will appear in the datastream.
 * These strings will be used while parsing a multipart/form-data
 * submission.
 *
 * Rather than using the ews_request_header_table[], we have to
 * create this second table because:
 *
 *  1) some header fields that we are interested in are different.
 *  2) these headers will only exist while processing the applicable
 *      message segment.  Each segment can "overwrite" a header
 *      that was used by the previous segment.
 *
 *  This table is only defined in ews_pars.c - it's here so we
 *  can keep it consistent with the enum definition.
 *
 * NOTE: MUST MATCH ewsFormDataHeaderIndex above!!
 */

const EwsConstCharP ews_form_data_header_table[] =
{
  "",           /* unknown header */
  "Content-type",
  "Content-length",
  "Content-disposition",
  "Content-transfer-encoding"
};
#endif /* EW_CONFIG_OPTION_FIELDTYPE_FILE */


#ifndef EW_CONFIG_OPTION_RELEASE_UNUSED
#define ewsParseReleaseUnusedBuffers(context, flag)
#endif

#ifdef EWA_LOG_HOOK
static void ewsParseError(EwsContext context, EwsLogStatus status);
#define EWS_PARSE_ERROR(context, status) ewsParseError(context, status)
#else
static void ewsParseError(EwsContext context);
#define EWS_PARSE_ERROR(context, status) ewsParseError(context)
#endif

#ifdef EW_CONFIG_OPTION_FIELDTYPE_FILE
static boolean ewsParseFormData( EwsContext context );
static void ewsParseFormDataFieldName( EwsContext context );
#endif /* EW_CONFIG_OPTION_FIELDTYPE_FILE */

#ifdef EW_CONFIG_OPTION_COOKIES
static void ewsParseCookies( EwsContext context );
#endif /* EW_CONFIG_OPTION_COOKIES */

#ifdef EW_CONFIG_OPTION_CONTENT_NEGOTIATION
static void ewsParseNegotiateHdr( EwsContext context);

static void ewsParseAcceptHdr( EwsContext context,
                               EwsString estring,
                               EwsAcceptHdrDataP *first,
                               EwsAcceptHdrDataP *last );
#endif /* EW_CONFIG_OPTION_CONTENT_NEGOTIATION */

#ifdef EMWEB_TRACE_PARSE

/* The number of input chars (more or less) to dump whenever we dump input. */
#define EMWEB_TRACE_PARSE_LEN 60

/* Return a printable representation of a string. */
static const char *
emwebTraceParseQuoteString(EwsString, int, int);

#ifndef EMWEB_TRACE_PARSE_OUT
/* Define EMWEB_TRACE_PARSE output function, if not configured by user.
 * One could also define as #define EMWEB_TRACE_PARSE_OUT(x) EMWEB_TRACE(x)
 * if EMWEB_TRACE is not just printf.  But we do not do that by default,
 * since EMWEB_TRACE is a no-op by default, and we may want to trace
 * the parser without tracing the rest of the server. */
#define EMWEB_TRACE_PARSE_OUT(x)        printf x
#endif /* !defined(EMWEB_TRACE_PARSE_OUT) */

#else /* defined(EMWEB_TRACE_PARSE) */

/* Null out definition of EMWEB_TRACE_PARSE_OUT. */
#define EMWEB_TRACE_PARSE_OUT(x)        /* empty */

#endif /* defined(EMWEB_TRACE_PARSE) */

/*
 * ewsParse
 * Crank HTTP parser state machine on HTTP request data queue attached to
 * request context.
 *
 * context      - Context of request
 *
 * Returns TRUE if there is more parsing to be done (e.g. after a state
 * transition), FALSE if more data is needed before parsing can continue.
 */
boolean
ewsParse ( EwsContext context )
{
  uintf match_c;
  EwsRequestHeaderIndex header;
# if defined EW_CONFIG_OPTION_AUTH_DIGEST
  uintf bytes;
# endif

  EMWEB_TRACE_PARSE_OUT(("ewsParse(context=%p) entered\n", context));

    /*
     * Handle by state
     */
    switch (context->state)
      {
        /*********************************************************************/
        /* Parse HTTP request line:
         *      method SP abs_path { SP protocol } CRNL
         * If protocol field present (e.g. "HTTP/1.0"), then headers follow,
         * followed by blank line, followed by message body. Otherwise, this
         * is an HTTP/0.9 simple request with no body.
         */
        case ewsContextStateParseRequest:
          /* In the ParseRequest state, req_str_begin is the parse pointer,
           * and advances through the request line. */

          /*
           * Handle by substate
           */
          switch(context->substate.request)
            {
              /*=============================================================*/
              /* Parse and save method.  Look up type "GET", "HEAD", "POST"
               */
              case ewsContextSubstateParseMethod:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=ParseMethod)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)" \t\n\r", ewsStringSearchInclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }

                /*
                 * HTTP/1.1 specification suggests that leading CRLF should
                 * be ignored for robustness
                 */
                if (match_c == '\n' || match_c == '\r')
                  {
                    /*
                     * Make sure first character was match, otherwise this
                     * is a bad request
                     */
                    match_c = ewsStringGetChar(&context->req_str_begin);
                    if (match_c != '\n' && match_c != '\r')
                      {
                        EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                        EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                        return FALSE;
                      }

                    /*
                     * Skip leading CRLF and try parsing request line again
                     */
                    ewsStringGetChar(&context->req_str_end);
                    context->req_str_begin = context->req_str_end;
                    ewsStringLengthSet(&context->req_str_begin, 0);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                    return TRUE;
                  }

                ewsParseReleaseUnusedBuffers(context, TRUE);
                context->req_method_str = context->req_str_begin;

                /*** These tests should be reduced to a table look-up. */
                if (ewsStringCompare(&context->req_str_begin, "GET",
                      ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodGet;
                  }
                else if (ewsStringCompare(&context->req_str_begin, "POST",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodPost;
                  }
                else if (ewsStringCompare(&context->req_str_begin, "HEAD",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodHead;
                  }

                /*
                 * HTTP/1.1 methods (which we'll support under 1.0 as well)
                 */
#               ifdef EW_CONFIG_OPTION_METHOD_OPTIONS
                else if (ewsStringCompare(&context->req_str_begin, "OPTIONS",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodOptions;
                  }
#               endif /* EW_CONFIG_OPTION_METHOD_OPTIONS */
#               ifdef EW_CONFIG_OPTION_METHOD_TRACE
                else if (ewsStringCompare(&context->req_str_begin, "TRACE",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodTrace;
                  }
#               endif /* EW_CONFIG_OPTION_METHOD_TRACE */
#               ifdef EW_CONFIG_OPTION_FILE_PUT
                else if (ewsStringCompare(&context->req_str_begin, "PUT",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodPut;
                  }
#               endif /* EW_CONFIG_OPTION_FILE_PUT */
#               ifdef EW_CONFIG_OPTION_FILE_DELETE
                else if (ewsStringCompare(&context->req_str_begin, "DELETE",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodDelete;
                  }
#               endif /* EW_CONFIG_OPTION_FILE_DELETE */

#               ifdef EW_CONFIG_OPTION_UPNP
                /* Handle the special methods for UPnP. */
                else if (ewsStringCompare(&context->req_str_begin, "M-SEARCH",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodMSearch;
                  }
                else if (ewsStringCompare(&context->req_str_begin, "NOTIFY",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodNotify;
                  }
                else if (ewsStringCompare(&context->req_str_begin, "SUBSCRIBE",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodSubscribe;
                  }
                else if (ewsStringCompare(&context->req_str_begin,
                                          "UNSUBSCRIBE",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodUnsubscribe;
                  }
#               ifdef EW_CONFIG_OPTION_SOAP
                else if (ewsStringCompare(&context->req_str_begin, "M-POST",
                           ewsStringCompareCaseInsensitive, NULL))
                  {
                    context->req_method = ewsRequestMethodMPost;
                  }
#               endif /* EW_CONFIG_OPTION_SOAP */
#               endif /* EW_CONFIG_OPTION_UPNP */

                else
                  {
                    context->req_method = ewsRequestMethodUnknown;
                  }
                context->substate.request = ewsContextSubstatePreParseURI;

                /* fall through to next state */

              /*=============================================================*/
              /* Skip LWS between method and absolute path
               */
              case ewsContextSubstatePreParseURI:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=PreParseURI)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)" \t", ewsStringSearchExclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }

#               if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
                if (match_c != '/' && match_c != '*')
                  {
                    /*
                     * If requestURI does not begin with '/' or '*', then
                     * it must be an absoluteURI (HTTP/1.1 conformance
                     * requires that we accept this).  So, parse the scheme.
                     */
#                   ifdef EW_CONFIG_OPTION_UPNP
                    /*
                     * except for UPNP, in which case it has to be '*'
                     */
                    if (context->ssdp_connection)
                      {
                        EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                        EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE - MSEARCH must have * for URI \n"));
                        return FALSE;
                       }
#                   endif /* EW_CONFIG_OPTION_UPNP */
                    context->req_str_begin = context->req_str_end;
                    ewsStringLengthSet(&context->req_str_begin, 0);
                    context->substate.request = ewsContextSubstateParseScheme;
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                    return TRUE;
                  }
#               else /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */
                if (match_c != '/')
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
#               endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

#               ifdef EW_CONFIG_OPTION_UPNP
                /*
                 * for UPNP, in which case it has to be '*'
                 */
                if ((context->ssdp_connection) && (match_c != '*'))
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE - MSEARCH must have * for URI \n"));
                    return FALSE;
                   }
#               endif /* EW_CONFIG_OPTION_UPNP */
                context->req_str_begin = context->req_str_end;
                ewsStringLengthSet(&context->req_str_begin, 0);
                context->substate.request = ewsContextSubstateParseURI;

                /* fall through to next state */

              /*=============================================================*/
              /* Parse absolute path up to '?', if present
               *        '/' abs_path { '?' query }
               * If CRNL sequence found, then this is HTTP/0.9
               */
              case ewsContextSubstateParseURI:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=ParseURI)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)" ?\r\n\t", ewsStringSearchInclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;            /* need more data */
                  }
                ewsParseReleaseUnusedBuffers(context, TRUE);
                context->req_url = context->req_str_begin;
#if             defined EW_CONFIG_OPTION_AUTH_DIGEST
                /*
                 * save original request url so we can check it against
                 * digest_url later on.
                 *
                 * Once digest_url verified, we can free rcvd_url
                 *
                 */
                bytes = ewsStringLength(&context->req_url);
#               ifdef EW_CONFIG_OPTION_UPNP
                /*
                 * except for UPNP, in which case it has to be '*'
                 */
                if ((context->ssdp_connection) && (bytes > 1))
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE - MSEARCH must have * for URI \n"));
                    return FALSE;
                   }
#               endif
                context->rcved_url = (char *) ewaAlloc(bytes + 1);
                if (context->rcved_url == (char *) NULL)
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_NO_RESOURCES);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
                ewsStringCopyOut(context->rcved_url, &context->req_url, bytes);
#               endif
                context->req_str_begin = context->req_str_end;
                ewsStringLengthSet(&context->req_str_begin, 0);
                if (match_c == '?')
                  {
                    (void) ewsStringGetChar(&context->req_str_end);
                    context->req_str_begin = context->req_str_end;
                    ewsStringLengthSet(&context->req_str_begin, 0);
                    context->substate.request = ewsContextSubstateParseQuery;
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                    return TRUE;
                  }
                else if (match_c == '\r' || match_c == '\n')
                  {
                    /* HTTP/0.9 */
                    context->req_protocol_maj = 0;
                    context->req_protocol_min = 9;
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsServeStart\n"));
                    return ewsServeStart(context);
                  }
                context->substate.request = ewsContextSubstatePreParseProtocol;

                /* fall through to next state */

              /*=============================================================*/
              /* Skip LWS between absolute path and protocol.  If CRNL sequence
               * found, then this is HTTP/0.9.
               */
              case ewsContextSubstatePreParseProtocol:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=PreParseProtocol)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)" \t", ewsStringSearchExclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }
                else if (match_c == '\r' || match_c == '\n')
                  {
                    context->req_protocol_maj = 0;
                    context->req_protocol_min = 9;
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsServeStart\n"));
                    return ewsServeStart(context);
                  }
                context->req_str_begin = context->req_str_end;
                ewsStringLengthSet(&context->req_str_begin, 0);
                context->substate.request = ewsContextSubstateParseProtocol;

                /* fall through to next state */

              /*=============================================================*/
              /* Parse protocol, e.g., "HTTP/1.0"
               */
              case ewsContextSubstateParseProtocol:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=ParseProtocol)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)"\r\n", ewsStringSearchInclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;        /* need more data */
                  }
                ewsParseReleaseUnusedBuffers(context, TRUE);
                context->req_protocol = context->req_str_begin;

                /*
                 * Get major.minor
                 */
                if (!ewsStringCompare(&context->req_str_begin
                                     ,"HTTP/"
                                     ,ewsStringCompareCaseInsensitive
                                     ,NULL)
                    || !ewsStringGetInteger(&context->req_str_begin
                                           ,10
                                           ,&context->req_protocol_maj)
                    || ewsStringGetChar(&context->req_str_begin) != '.'
                    || !ewsStringGetInteger(&context->req_str_begin
                                           ,10
                                           ,&context->req_protocol_min))
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }

                /* Suppress chunked encoding on HTTP requests. */
#ifdef NO_CHUNKED_ENCODING
                context->req_protocol_min = 0;
#endif

#               ifdef EW_CONFIG_OPTION_PERSISTENT
                /*
                 * By default, HTTP/1.1 connections are keep-alive
                 */
                if (context->req_protocol_maj > 1 ||
                    (context->req_protocol_maj == 1 &&
                     context->req_protocol_min >= 1))
                  {
                    context->keep_alive = TRUE;
                  }
#               endif /* EW_CONFIG_OPTION_PERSISTENT */

                context->state = ewsContextStateParseHeaders;
                context->substate.header = ewsContextSubstateCRNLPending;
                context->req_header = ewsRequestHeaderUnknown;

                EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                return TRUE;

#             if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1

              /*=============================================================*/
              /* Parse scheme "HTTP:"
               */
              case ewsContextSubstateParseScheme:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=ParseScheme)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)" \r\n\t:", ewsStringSearchInclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }
                else if (match_c != ':'
                       ||!ewsStringCompare(&context->req_str_begin
                                          ,"http"
                                          ,ewsStringCompareCaseInsensitive
                                          ,NULL))
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
                ewsStringGetChar(&context->req_str_end);
                context->substate.request = ewsContextSubstatePreParseHost1;

                /* fall through to next state */

              /*=============================================================*/
              /* Skip "//" between scheme and host: first '/'
               */
              case ewsContextSubstatePreParseHost1:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=PreParseHost1)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringGetChar(&context->req_str_end);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }
                if (match_c != '/')
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
                context->substate.request = ewsContextSubstatePreParseHost2;

                /* fall through to next state */

              /*=============================================================*/
              /* Skip "//" between scheme and host: second '/'
               */
              case ewsContextSubstatePreParseHost2:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=PreParseHost2)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringGetChar(&context->req_str_end);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }
                if (match_c != '/')
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
                context->req_str_begin = context->req_str_end;
                ewsStringLengthSet(&context->req_str_begin, 0);
                context->substate.request = ewsContextSubstateParseHost;

                /* fall through to next state */

              /*=============================================================*/
              /* Parse host in absouluteURI up to '/' in abs_path
               */
              case ewsContextSubstateParseHost:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=ParseHost)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(&context->req_str_begin
                                         ,&context->req_str_end
                                         ,(char *)" \r\n\t/"
                                         ,ewsStringSearchInclude
                                         ,NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }
                if (match_c != '/')
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
                ewsParseReleaseUnusedBuffers(context, TRUE);
                context->req_host = context->req_str_begin;
                context->req_str_begin = context->req_str_end;
                ewsStringLengthSet(&context->req_str_begin, 0);
                context->substate.request = ewsContextSubstateParseURI;
                EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                return TRUE;

#             endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

              /*=============================================================*/
              /* Parse query string. If CRNL sequence found, then this is
               * HTTP/0.9.
               */
              case ewsContextSubstateParseQuery:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=ParseQuery)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)" \r\n\t", ewsStringSearchInclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;        /* need more data */
                  }
                else if (match_c == '\r' || match_c == '\n')

                  {
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsServeStart\n"));
                    return ewsServeStart(context);
                  }
                ewsParseReleaseUnusedBuffers(context, TRUE);
                context->req_query = context->req_str_begin;
                context->substate.request = ewsContextSubstatePreParseProtocol;
                EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                return TRUE;

              /*=============================================================*/
              /* Unknown state! */
#             ifdef EMWEB_SANITY
              default:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseRequest, substate=UNKNOWN)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                EMWEB_ERROR(("ewsParse: bad substate of ParseRequest\n"));
                ewsNetHTTPAbort( context );
                EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                return FALSE;
#             endif /* EMWEB_SANITY */

            }
          break;

        /*********************************************************************/
        /* Parse HTTP/1.0 request headers
         *      header ':' value CRNL
         * An empty header line (i.e. CRNL by itself) terminates headers and
         * begins body.  A CRNL followed by LWS is a continuation of the
         * previous line.
         */
        case ewsContextStateParseHeaders:
          /* In the ParseHeaders state, req_str_end is the parse pointer,
           * and advances through the header line.  req_str_begin points to
           * the beginning of the header line, then is later moved to point
           * to the beginning of the value portion of the header line.
           */

          /*
           * Handle by substate
           */
          switch(context->substate.header)
            {
              /*=============================================================*/
              /* The next character is (i.e., req_str_end points at) a CR or
               * NL.  Process it and go to HaveCR or HaveNL as appropriate.
               */
              case ewsContextSubstateCRNLPending:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseHeaders, substate=CRNLPending)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_end, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringGetChar(&context->req_str_end);
                if (match_c == '\n')
                  {
                    context->substate.header = ewsContextSubstateHaveNL;
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                    return TRUE;
                  }
                /* Only other possible case is CR. */
#               ifdef EMWEB_SANITY
                if (match_c != '\r')
                  {
                    EMWEB_ERROR(("ewsParse: CR or NL should be seen\n"));
                    ewsNetHTTPAbort( context );
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
#               endif /* EMWEB_SANITY */
                context->substate.header = ewsContextSubstateHaveCR;

                /* Fall through to next state. */

              /*=============================================================*/
              /* Have read CR from previous header line.  Next character
               * must be NL.
               */
              case ewsContextSubstateHaveCR:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseHeaders, substate=HaveCR)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_end, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringGetChar(&context->req_str_end);
                if (match_c == EWS_STRING_EOF)
                  {
                    context->schedulingState = ewsContextDataWait;
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
                ewsStringExpand(&context->req_str_begin, 1);
                if (match_c != '\n')
                  {
                    EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                    return FALSE;
                  }
                context->substate.header = ewsContextSubstateHaveNL;

                /* fall through to next state */

              /*=============================================================*/
              /* Have read NL from previous header line.  Another NL terminates
               * headers. LWS indicates continuation of previous header.
               * Otherwise, start new header.  Note that we call
               * ewsParseReleaseUnusedBuffers here, and not in
               * ewsContextSubstateParseValue.  This is because we might
               * discover a continuation in which case it is premature to
               * look for unused buffers.
               */
              case ewsContextSubstateHaveNL:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseHeaders, substate=HaveNL)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_end, FALSE, EMWEB_TRACE_PARSE_LEN)));

#               ifdef EW_CONFIG_OPTION_PRIMARY
                context->hdr_str_end = context->req_str_end;
#               endif /* EW_CONFIG_OPTION_PRIMARY */
                for (;;)
                  {
                    /* We are going to do a look-ahead examination of the next
                     * character, so we have to save req_str_end so we can
                     * restore it later. */
                    EwsString tmp = context->req_str_end;
                    match_c = ewsStringGetChar(&context->req_str_end);
                    if (match_c == EWS_STRING_EOF)
                      {
                        context->schedulingState = ewsContextDataWait;
                        EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                        return FALSE;
                      }
                    ewsStringExpand(&context->req_str_begin, 1);
                    if (match_c == '\n')
                      {
                        ewsParseReleaseUnusedBuffers(context,
                          (boolean)(context->req_header != ewsRequestHeaderUnknown));
                        ewsParseHeader(context);
                        EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsServeStart\n"));
                        return ewsServeStart(context);
                      }
                    else if (match_c == ' ' || match_c == '\t')
                      {
                        context->substate.header =
                          ewsContextSubstateParseValue;
                        EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                        return TRUE;
                      }
                    else if (match_c != '\r')
                      {
                        /* Any character other than \r, \n, SPC, or \t. */
                        context->req_str_end = tmp;
                        ewsParseReleaseUnusedBuffers(context,
                         (boolean)( context->req_header != ewsRequestHeaderUnknown));
                        ewsParseHeader(context);
                        context->req_str_begin = tmp;
                        ewsStringLengthSet(&context->req_str_begin, 0);
                        context->substate.header =
                          ewsContextSubstateParseHeader;
                        break;      /* out of for(;;) */
                      }
                    /* match_c == '\r'.
                     * Loop to look at the next character, which should be
                     * a LF.
                     */
                  }

                /* fall through to next state */

              /*=============================================================*/
              /* Read the header token.  Search request header table for match
               * and remember the header index.  This is where the following
               * header value will be stored.
               */
              case ewsContextSubstateParseHeader:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseHeaders, substate=ParseHeader)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_end, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)": \t\r\n", ewsStringSearchInclude, NULL);
                 if (match_c == EWS_STRING_EOF)
                   {
                     break;     /* need more data */
                   }
                if (match_c == '\r' || match_c == '\n')
                  {
                    context->req_header = ewsRequestHeaderUnknown;
                    context->substate.header = ewsContextSubstateCRNLPending;
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                    return TRUE;
                  }

#               ifdef EW_CONFIG_OPTION_PRIMARY
                /*
                 * Save location of header name so that it may be "clobbered"
                 * if it is a hop-to-hop header.  If this is the first
                 * header, save it as well.
                 */
                context->hdr_str_clobber = context->req_str_begin;
                if (ewsStringBuffer(&context->hdr_str_begin) ==
                    EWA_NET_BUFFER_NULL)
                  {
                    context->hdr_str_begin = context->req_str_begin;
                  }

#               endif /* EW_CONFIG_OPTION_PRIMARY */

                for (header = (EwsRequestHeaderIndex) 1;
                     header < ewsRequestHeaderCount;
                     header = (EwsRequestHeaderIndex) (header + 1))
                  {
                    EwsString _e = context->req_str_begin; /* save */
                    if (ewsStringCompare(&context->req_str_begin,
                          ews_state->req_header_table[header],
                          ewsStringCompareCaseInsensitive, NULL))
                      {
                        /* Make sure exact match [ASI Support #3286] */
                        if (ewsStringLength(&context->req_str_begin) != 0)
                          {
                            context->req_str_begin = _e; /* restore */
                            continue;
                          }
                        break;      /* out of for(;;) */
                      }
                  }
                if (header == ewsRequestHeaderCount)
                  {
                    header = ewsRequestHeaderUnknown;
                  }
                context->req_header = header;
                context->substate.header = ewsContextSubstatePostParseHeader;

                /* fall through to next state */

              /*=============================================================*/
              /* Parse the ':' separator
               */
              case ewsContextSubstatePostParseHeader:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseHeaders, substate=PostParseHeader)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_end, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)":\r\n", ewsStringSearchInclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }
                if (match_c == '\r' || match_c == '\n')
                  {
                    context->req_header = ewsRequestHeaderUnknown;
                    context->substate.header = ewsContextSubstateCRNLPending;
                    EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                    return TRUE;
                  }
                /* match_c == ':' */
                (void) ewsStringGetChar(&context->req_str_end);
                context->substate.header = ewsContextSubstatePreParseValue;

                /* fall through to next state */

              /*=============================================================*/
              /* Skip LWS between ':' and value
               */
              case ewsContextSubstatePreParseValue:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseHeaders, substate=PreParseValue)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_end, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)" \t", ewsStringSearchExclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }
                /* Set req_str_begin to mark the beginning of the value. */
                context->req_str_begin = context->req_str_end;
                ewsStringLengthSet(&context->req_str_begin, 0);
                context->substate.header = ewsContextSubstateParseValue;

                /* fall through to next state */

              /*=============================================================*/
              /* Parse value up to CRNL and save it.  (Value may be continued,
               * which is handled in the ewsContextSubstateHaveCR/NL
               * substates).
               */
              case ewsContextSubstateParseValue:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseHeaders, substate=ParseValue)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_end, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, &context->req_str_end,
                  (char *)"\r\n", ewsStringSearchInclude, NULL);
                if (match_c == EWS_STRING_EOF)
                  {
                    break;      /* need more data */
                  }
                context->req_headerp[context->req_header] =
                  context->req_str_begin;
                EMWEB_TRACE_PARSE_OUT((
                  "ewsParse: req_headerp[%s] set to %s\n",
                  (context->req_header == ewsRequestHeaderUnknown ?
                   "UNKNOWN" :
                   ews_state->req_header_table[context->req_header]),
                  emwebTraceParseQuoteString(context->req_str_begin,
                                             TRUE,
                                             EMWEB_TRACE_PARSE_LEN-30)));
                context->substate.header = ewsContextSubstateCRNLPending;
                EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
                return TRUE;

              /*=============================================================*/
              /* Unknown state! */
#             ifdef EMWEB_SANITY
              default:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParseHeaders, substate=UNKNOWN)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_end, TRUE, EMWEB_TRACE_PARSE_LEN)));

                EMWEB_ERROR(("ewsParse: bad substate of ParseHeaders\n"));
                ewsNetHTTPAbort( context );
                EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                return FALSE;
#             endif /* EMWEB_SANITY */
            }
          break;

#       ifdef EW_CONFIG_OPTION_FORM

        /*********************************************************************/
        /* Parse FORM x-www-urlencoded data
         *   name=value&name=value...
         * The *context->form_expectp indicates how much data is expected.
         * The context->form_parsep indicates the EwsString used for parsing.
         */
        case ewsContextStateParsingForm:
          EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParsingForm)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

#         if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
          /*
           * If chunked encoding, handle chunk state if not parsing data
           */
          if (*context->form_chunkedp &&
              context->chunk_in_state != ewsContextChunkInStateParseData)
            {
              EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseChunk\n"));
              return ewsParseChunk(context);
            }
#         endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

#         ifdef _CONFIG_OPTION_AUTH_DIGEST_AUTH_INT
          /*
           * If checking message digest, update digest.
           */
          if (context->auth_state != ewsAuthStateUninitialized)
            {
              ewsAuthDigestUpdate(context);
            }
#         endif /* _CONFIG_OPTION_AUTH_DIGEST_AUTH_INT */

          /*
           * Handle by substate
           */
          switch(context->substate.form)
            {
              /*=============================================================*/
              /* Parse name up to '=' */
              case ewsContextSubstateParseName:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParsingForm, substate=ParseName)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

                match_c = ewsStringSearch(
                  &context->req_str_begin, context->form_parsep,
                  (char *)"=", ewsStringSearchInclude, context->form_expectp);
                if (match_c == EWS_STRING_EOF)
                  {
                    if (*context->form_expectp != 0)
                      {
                        break;  /* expect more data */
                      }
#                   if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
                    /*
                     * If end of chunk, process next chunk
                     */
                    else if (*context->form_chunkedp)
                      {
                        EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseChunk\n"));
                        return ewsParseChunk(context);
                      }
#                   endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */
                    else
                      {
                        EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_FORM);
                        EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                        return FALSE;      /* aborted */
                      }
                  }

                /*
                 * Skip '='
                 */
                (void) ewsStringGetChar(context->form_parsep);
                (*context->form_expectp)--;

                /*
                 * Save name and continue parsing value
                 */
                context->form_name = context->req_str_begin;
                context->req_str_begin = *context->form_parsep;
                ewsStringLengthSet(&context->req_str_begin, 0);
                context->substate.form = ewsContextSubstateParseFormValue;

                /* fall through to next state */

              /*=============================================================*/
              /* Parse value up to '&', CRNL, LWS, or EOF */
              case ewsContextSubstateParseFormValue:
                EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParsingForm, substate=ParseFormValue)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));
                match_c = ewsStringSearch(
                  &context->req_str_begin, context->form_parsep,
                  (char *)"& \t\r\n", ewsStringSearchInclude, context->form_expectp);

               /*
                * If no more data and the expected length has not been
                * received, then resume parsing as additional buffers
                * are received.
                */
               if (match_c == EWS_STRING_EOF)
                 {
                   if (*context->form_expectp != 0)
                     {
                       break;  /* expect more data */
                     }
                 }

               /*
                * Otherwise, consume matching character
                */
               else
                 {
                   (void) ewsStringGetChar(context->form_parsep);
                   (*context->form_expectp)--;
                 }

               /*
                * If the matching character was not an '&' and we expect
                * more data, then this isn't x-www-urlencoded.
                */
               if (match_c != '&')
                 {
                   if (*context->form_expectp != 0)
                     {
                       EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_FORM);
                       EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                       return FALSE;      /* aborted */
                     }
#                   if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
                   /*
                    * If end-of-chunk, we must process next chunk
                    */
                   else if (*context->form_chunkedp)
                     {
                       EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseChunk\n"));
                       return ewsParseChunk(context);
                     }
#                   endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */
                 }

               /*
                * Decode name/value pair and pass to compiler-generated
                * code for processing.
                */
               ewsStringUnescape
                 (&context->form_name
                 ,ewsStringUnescapePlus2Space);
               ewsStringUnescape
                 (&context->req_str_begin
                 ,ewsStringUnescapePlus2Space);
               ewsFormSubmitSet
                 (context
                 ,&context->form_name
                 ,&context->req_str_begin);

               /*
                * ...SubmitSet could have detected an error
                * and could have set context state to ...Abort...
                * Well, in that case follow the state
                */
               if (context->abort_flags & EWS_CONTEXT_FLAGS_ABORT)
                 {
                   EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                   return FALSE;
                 }

               /*
                * If we are parsing from the message body (POST method),
                * release unused buffers.
                */
               if (&context->req_str_end == context->form_parsep)
                 {
                   ewsParseReleaseUnusedBuffers(context, FALSE);
                 }


               /*
                * If form parsing complete, submit the form and terminate
                * the request.
                */
               if (match_c != '&')
                 {
                   context->state = ewsContextStateSubmittingForm;
                   context->schedulingState = ewsContextScheduled;
                   ewsServeSubmitForm(context);
                   EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                   return FALSE;
                 }

               /*
                * Update state and parse next value
                */
               context->req_str_begin = *context->form_parsep;
               ewsStringLengthSet(&context->req_str_begin, 0);
               context->substate.form = ewsContextSubstateParseName;
               EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
               return TRUE;

             /*=============================================================*/
             /* Unknown state! */
             default:
#             ifdef EMWEB_SANITY
               EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParsingForm, substate=UNKNOWN)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

               EMWEB_ERROR(("ewsParse: bad substate of ParsingForm\n"));
               ewsNetHTTPAbort( context );
               EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
#             endif /* EMWEB_SANITY */
               return FALSE;
           }
         break;

#       endif /* EW_CONFIG_OPTION_FORM */

#       ifdef EW_CONFIG_OPTION_FIELDTYPE_FILE

       /*********************************************************************/
       /* Parse FORM data in mulitpart/form-data format (RFC1867):
        */
       case ewsContextStateParsingMPForm:
         {
           EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseFormData\n"));
           return( ewsParseFormData( context ) );
         }
#       endif /* EW_CONFIG_OPTION_FIELDTYPE_FILE */


#       ifdef EW_CONFIG_OPTION_FILE_PUT
       /*********************************************************************
        * Parse PUT data (de-chunk, check digest, and write to file)
        */
       case ewsContextStateParsingPut:
         {
           sintf putBytes;
           EwaNetBuffer buffer;
           EwaFileHandle file_handle;
           EwaFileStatus file_status;
#          if defined EW_CONFIG_OPTION_AUTH_DIGEST
           EwsStatus status = EWS_STATUS_OK;
#          endif

             EMWEB_TRACE_PARSE_OUT(("ewsParse(state=ParsingPut)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

#            if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
             /*
              * If chunked encoding, handle chunk state if not parsing data
              */
             if (context->chunked_encoding &&
                 context->chunk_in_state != ewsContextChunkInStateParseData)
               {
                 EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseChunk\n"));
                 return ewsParseChunk(context);
               }
#             endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

#            ifdef _CONFIG_OPTION_AUTH_DIGEST_AUTH_INT
             /*
              * If checking message digest, update digest.
              */
             if (context->auth_state != ewsAuthStateUninitialized)
               {
                 ewsAuthDigestUpdate(context);
               }
#            endif /* _CONFIG_OPTION_AUTH_DIGEST_AUTH_INT */

             /*
              * While data to put
              */
             while (context->content_remaining != 0)
               {
                 /*
                  * Determine available bytes in current buffer.  If no
                  * more bytes in this buffer, proceed to next.
                  */
                 putBytes = ewsStringAvailable(&context->req_str_begin);
                 if (putBytes == 0)
                   {
                     buffer = ewaNetBufferNextGet(
                                ewsStringBuffer(&context->req_str_begin));
                     if (buffer == EWA_NET_BUFFER_NULL)
                       {
                         context->schedulingState = ewsContextDataWait;
                         EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                         return FALSE;
                       }
                     ewsStringInit(&context->req_str_begin, buffer);
                     continue;
                   }
                 if ((uintf)putBytes > context->content_remaining)
                   {
                     putBytes = context->content_remaining;
                   }

                 /*
                  * Write contiguous data to file and update state
                  */
#                ifdef EW_CONFIG_OPTION_FILE_SYSTEM_LIST
                 if (context->fileSystem != EWS_FILE_SYSTEM_HANDLE_NULL)
                   {
                    if (context->fileSystem->fs.fileWrite == NULL)
                      {
                        EMWEB_ERROR(("ewsParse: NULL fs fileWrite function\n"));
                        putBytes = 0;
                      }
                     else
                      {
                         putBytes = context->fileSystem->fs.fileWrite(
                                              context
                                             ,context->fileHandle
                                             ,ewsStringData(&context->req_str_begin)
                                             ,putBytes);
                      }
                   }
                 else
                   {
                     putBytes = 0;
                   }
#                else /* EW_CONFIG_OPTION_FILE_SYSTEM_LIST */
                 putBytes = ewaFileWrite(context
                                     ,context->fileHandle
                                     ,ewsStringData(&context->req_str_begin)
                                     ,putBytes);
#                endif /* EW_CONFIG_OPTION_FILE_SYSTEM_LIST */
                 if (putBytes > 0)
                   {
                     context->req_str_begin.offset += putBytes;
                     context->content_remaining -= putBytes;
                     context->req_str_end = context->req_str_begin;
                     ewsParseReleaseUnusedBuffers(context, FALSE);
                   }

                 /*
                  * If ewaFileWrite suspended or aborted, return to
                  * scheduler.
                  */
                 if (context->abort_flags & EWS_CONTEXT_FLAGS_ABORT
#                     ifdef EW_CONFIG_OPTION_SCHED_SUSP_RES
                     || context->schedulingState == ewsContextSuspended
#                     endif /* EW_CONFIG_OPTION_SCHED_SUSP_RES */
                    )
                   {
                     EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                     return FALSE;
                   }
#                 ifdef EW_CONFIG_OPTION_SCHED_SUSP_RES
                 context->schedulingState = ewsContextScheduled;
#                 endif /* EW_CONFIG_OPTION_SCHED_SUSP_RES */

                 /*
                  * If write failed, return internal abort
                  */
                 if (putBytes < 0)
                   {
                     ewaLogHook(context, EWS_LOG_STATUS_INTERNAL_ERROR);
                     ewsSendHeaderAndEnd(context
                                        ,ews_http_status_500
                                        ,ews_http_string_500);
                     EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                     return FALSE;
                   }
               }

#             if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
             /*
              * If end of chunk, parse next chunk
              */
             if (context->chunked_encoding)
               {
                 EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseChunk\n"));
                 return ewsParseChunk(context);
               }
#             endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

             /*
              * Check digest
              */
#            if defined EW_CONFIG_OPTION_AUTH_DIGEST
             if ( ewsAuthStateIntegrity == context->auth_state )
               {
                 status = ewsAuthDigestFinish(context);
                 if (status == EWS_STATUS_AUTH_FAILED)
                   {
                     ewaLogHook(context, EWS_LOG_STATUS_AUTH_FORGERY);
                     ewsSendHeaderAndEnd(context, ews_http_status_401
                                                , ews_http_string_401);
                   }
                 else if ((status == EWS_STATUS_BAD_REQUEST) ||
                          (status == EWS_STATUS_AUTH_CHALLENGE))
                   {
                     /*
                      * This should not happen, by now authorization process is
                      * finishing integrity state, so data provided by client
                      * has been verified long ago
                      */
                     ewsSendHeaderAndEnd(context ,ews_http_status_400
                                                 ,ews_http_string_400);
                     EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                     return FALSE;
                   }
                 else if (status == EWS_STATUS_NO_RESOURCES)
                   {
                     ewaLogHook(context, EWS_LOG_STATUS_NO_RESOURCES);
                     EMWEB_WARN(("ewsParse: unable to authenticate\n"));
                     ewsNetHTTPAbort(context);
                     EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                     return FALSE;
                   }
               }
#            endif

             /*
              * Close file to complete PUT/POST processing.  We allow
              * the application to call ewsContextSendReply() (and possibly
              * ewsContextSetFile() prior) to create a response to the PUT.
              * Otherwise, we send an empty response.
              */
             file_handle = context->fileHandle;
             context->fileHandle = EWA_FILE_HANDLE_NULL;
             context->fileParams = NULL;
             if (context->dummy != NULL)
               {
                 ewaFree(context->dummy);
               }
             context->dummy = NULL;
#            ifdef EW_CONFIG_OPTION_FILE_SYSTEM_LIST
             if (context->fileSystem != EWS_FILE_SYSTEM_HANDLE_NULL)
               {
                 (context->fileSystem->use_cnt)--;
                 context->fs_inuse = FALSE;
                 if (context->fileSystem->fs.fileClose == NULL)
                   {
                     EMWEB_ERROR(("ewsParse: NULL fs fileClose function\n"));
                     file_status = EWA_STATUS_ERROR;
                   }
                 else
                   {
#                    if defined EW_CONFIG_OPTION_AUTH_DIGEST
                     if (status == EWS_STATUS_AUTH_FAILED)
                       {
                         file_status =
                           context->fileSystem->fs.fileClose(file_handle, EWS_STATUS_ABORTED);
                         EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                         return FALSE;
                       }
                     else
                       {
                         file_status = context->fileSystem->fs.fileClose(file_handle, EWS_STATUS_OK);
                       }
#                    else
                     file_status = context->fileSystem->fs.fileClose(file_handle, EWS_STATUS_OK);
#                    endif
                   }
               }
             else
               {
                 file_status = EWA_STATUS_ERROR;
               }
#            else /* EW_CONFIG_OPTION_FILE_SYSTEM_LIST */
#            ifdef EW_CONFIG_OPTION_AUTH_DIGEST
             if (status == EWS_STATUS_AUTH_FAILED)
               {
                 file_status = ewaFileClose(file_handle, EWS_STATUS_ABORTED);
                 EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                 return FALSE;
               }
             else
               {
                 file_status = ewaFileClose(file_handle, EWS_STATUS_OK);
               }
#            else
             file_status = ewaFileClose(file_handle, EWS_STATUS_OK);
#            endif
#            endif /* EW_CONFIG_OPTION_FILE_SYSTEM_LIST */

#            ifdef EW_CONFIG_OPTION_CLIENT
             /*
              * If EmWeb/Client handling inbound data from remote server,
              * pass control back to EmWeb/Client
              */
             if (context->client != NULL)
               {
                 context->state = ewsContextStateClient;
               }
#            endif /* EW_CONFIG_OPTION_CLIENT */

             if (context->state == ewsContextStateParsingPut)
               {
                 switch (file_status)
                   {
                     case EWA_FILE_STATUS_OK:
                       ewaLogHook(context, EWS_LOG_STATUS_OK);
                       ewsSendHeaderAndEnd(context
                                          ,ews_http_status_204
                                          ,ews_no_body);
                       break;
                     case EWA_FILE_STATUS_CREATED:
                       ewaLogHook(context, EWS_LOG_STATUS_OK);
                       ewsSendHeaderAndEnd(context
                                          ,ews_http_status_201
                                          ,ews_http_string_201);
                       break;
                     default:
                       ewaLogHook(context, EWS_LOG_STATUS_INTERNAL_ERROR);
                       ewsSendHeaderAndEnd(context
                                          ,ews_http_status_500
                                          ,ews_http_string_500);
                       break;
                   }
               }
             EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
             return FALSE;
         }
         break;
#       endif /* EW_CONFIG_OPTION_FILE_PUT */


#       ifdef EW_CONFIG_OPTION_PERSISTENT
       /*********************************************************************
        * Skip unparsed message entity body before next HTTP request line
        */
       case ewsContextStateSkipContent:
         {
           uintf len;
           EwaNetBuffer buf, nxt;

             EMWEB_TRACE_PARSE_OUT(("ewsParse(state=SkipContent)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

#            if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
             /*
              * If chunked encoding, handle chunk state if not parsing data
              */
             if (context->chunked_encoding &&
                 context->chunk_in_state != ewsContextChunkInStateParseData)
               {
                 EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseChunk\n"));
                 return ewsParseChunk(context);
               }
#             endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

             /*
              * While content remains
              */
             while (context->content_remaining != 0)
               {
                 /*
                  * If end of current buffer
                  */
                 while ((len = ewsStringAvailable(&context->req_str_end)) == 0)
                   {
                     /*
                      * If no more buffers, then wait for more data
                      */
                     buf = context->req_buf_first;
                     nxt = ewaNetBufferNextGet(buf);
                     if (nxt == EWA_NET_BUFFER_NULL)
                       {
                         context->schedulingState = ewsContextDataWait;
                         EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
                         return FALSE;
                       }

                     /*
                      * Update parser to beginning of next buffer
                      */
                     context->req_buf_first = context->req_str_end.first = nxt;
                     context->req_str_end.offset = 0;

                     /*
                      * Release skipped buffer
                      */
                     ewaNetBufferNextSet(buf, EWA_NET_BUFFER_NULL);
                     ewaNetBufferFree(buf);
                   }

                 /*
                  * Advance up to end of this buffer
                  */
                 if (len > context->content_remaining)
                   {
                     len = context->content_remaining;
                   }
                 context->req_str_end.offset += len;
                 context->content_remaining -= len;
               }

#             if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
             /*
              * If end-of-chunk, we must process next chunk
              */
             if (context->chunked_encoding)
               {
                 EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseChunk\n"));
                 return ewsParseChunk(context);
               }
#             endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

             /*
              * Reset state machine to parse next request line
              */
             context->state = ewsContextStateParseRequest;
             context->substate.request = ewsContextSubstateParseMethod;
             context->req_str_begin = context->req_str_end;
             ewsStringLengthSet(&context->req_str_begin, 0);
             EMWEB_TRACE_PARSE_OUT(("ewsParse() returns TRUE\n"));
             return TRUE;
         }

#       endif /* EW_CONFIG_OPTION_PERSISTENT */

#       ifdef EW_CONFIG_OPTION_SMTP
       case ewsContextStateSmtp:
         EMWEB_TRACE_PARSE_OUT(("ewsParse(state=Smtp)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

         EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsSmtpParse\n"));
         return ewsSmtpParse(context);
#       endif

#       ifdef EW_CONFIG_OPTION_UPNP
       case ewsContextStateSSDPMsearchResponse:
         EMWEB_TRACE_PARSE_OUT(("ewsParse(state=MsearchResponse)\n\t%s\n"
                                ,emwebTraceParseQuoteString(
                                   context->req_str_begin
                                  ,FALSE, EMWEB_TRACE_PARSE_LEN)));
         EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsClientParseStat\n"));
         return ewsClientParseStatus(context
                                    ,&context->clientState
                                    ,&context->clientStatus
                                    ,&context->clientString
                                    );
#       endif /* EW_CONFIG_OPTION_UPNP */

#       ifdef EW_CONFIG_OPTION_TELNET
       case ewsContextStateTelnet:
         EMWEB_TRACE_PARSE_OUT(("ewsParse(state=Telnet)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

         EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsTenetParse\n"));
         return ewsTelnetParse(context);
#       endif

#       ifdef EW_CONFIG_OPTION_CLIENT
       case ewsContextStateClient:
         return ewsClientParse(context);
#       endif

#       ifdef EMWEB_XMLP
       case ewsContextStateXMLP:
         {
           XmlpParseStatus status;

#            if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
             /*
              * If chunked encoding, handle chunk state if not parsing data
              */
             if (   context->chunked_encoding
                 && (   context->chunk_in_state != ewsContextChunkInStateParseData
                     || context->content_remaining == 0
                    )
                )
               {
                 EMWEB_TRACE_PARSE_OUT(("ewsParse() tail-calls ewsParseChunk\n"));
                 return ewsParseChunk(context);
               }
#            endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

             /*
              * If we have data to send to XML parser, parse it
              */
             if (context->content_remaining != 0)
               {
                 /*
                  * Note: ewxmlParse() works somewhat differently than other
                  * EmWeb parsers (so as to also operate conveniently in a
                  * stand-alone form).  It uses req_str_begin to describe the
                  * available input data, and expects its length field to be
                  * set to the available bytes ahead of req_str_begin.  On
                  * return, req_str_begin may be advanced and its length
                  * decremented.  We need to advance req_str_end to the
                  * end of previously available data (end-of-chunk) and update
                  * req_str_begin.length with any newly available data.
                  */

                 int32 len;
                 EwaNetBuffer buf;
                 EwsString tmp;

                 /*
                  * First, determine how much data is available from
                  * req_str_end to end-of-data or chunk.
                  */
                 for (  len = - (int32) context->req_str_end.offset
                      , buf = ewsStringBuffer(&context->req_str_end);
                         buf != EWA_NET_BUFFER_NULL
                      && len < (int32) context->content_remaining;
                        len += ewaNetBufferLengthGet(buf)
                      , buf = ewaNetBufferNextGet(buf)
                     )
                    {
                    }
                  if ((uint32)len > context->content_remaining)
                    {
                      len = context->content_remaining;
                    }

                 /*
                  * Update req_str_begin length with new available data
                  */
                 ewsStringExpand(&context->req_str_begin, len);
                 status = ewxmlParse( context->xmlp_handle );

                 /*
                  * Handle suspend/abort cases
                  */
                 if (context->abort_flags & EWS_CONTEXT_FLAGS_ABORT
#                     ifdef EW_CONFIG_OPTION_SCHED_SUSP_RES
                     || context->schedulingState == ewsContextSuspended
#                     endif /* EW_CONFIG_OPTION_SCHED_SUSP_RES */
                    )
                   {
                     ewsStringExpand(&context->req_str_begin, -len);
                     return FALSE;
                   }
                 /* reset scheduling state, may be resuming */
                 context->schedulingState = ewsContextScheduled;

                 /*
                  * Update req_str_end and content_remaining by advancing
                  * our pointer ahead of data passed to parser (regardless
                  * of how much data parser actually consumed).
                  */
                 (void) ewsStringTrim(&context->req_str_end, len);
                 context->content_remaining -= len;

                 /*
                  * Remove unused buffers
                  */
                 buf = ewxmlFreeBuffersNotIncluding(context->xmlp_handle);
                 if (EWA_NET_BUFFER_NULL != buf)
                   {
                     tmp = context->req_str_end;
                     ewsStringInit(&context->req_str_end, buf);
                     ewsParseReleaseUnusedBuffers(context, FALSE);
                     context->req_str_end = tmp;
                   }

                 /*
                  * If more to parse, advance to end-of-chunk
                  */
                 if (   XmlpParseStatus_More == status
                     || XmlpParseStatus_Yield == status
                    )
                   {
                     /*
                      * If more data is expected from network and parser,
                      * wait for it
                      */
                     if (context->content_remaining != 0)
                       {
                         context->schedulingState = ewsContextDataWait;
                         return FALSE;
                       }

                     /*
                      * Otherwise, we have reached end-of-chunk or end-of-data,
                      * return to parser loop to process appropriately.  (We
                      * honor "Yield" return status by leaving the parser loop
                      * and let EmWeb scheduler run additional requests).
                      */
                     return (XmlpParseStatus_More == status);
                   }

                 /*
                  * On error, notify XML layer.  Default HTTP response will
                  * be "400 Bad Request", or overridden by application action
                  * using ewsContextSendReply...
                  */
                 else
                   {
                     (void) ewxmlEndOrAbort( context->xmlp_handle, TRUE );
                     context->xmlp_handle = NULL;
                     if (context->state == ewsContextStateXMLP)
                       {
                         EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
                       }
                   }
               }
             /*
              * Otherwise, signal end-of-data condition to XML parser.  Default
              * HTTP response will be "204 No Content", or overridden by
              * application action using ewsContextSendReply...
              */
             else
               {
                 status = ewxmlEndOrAbort( context->xmlp_handle, FALSE );

                 /*
                  * Handle suspend/abort case
                  */
                 if (context->abort_flags & EWS_CONTEXT_FLAGS_ABORT
#                     ifdef EW_CONFIG_OPTION_SCHED_SUSP_RES
                     || context->schedulingState == ewsContextSuspended
#                     endif /* EW_CONFIG_OPTION_SCHED_SUSP_RES */
                    )
                   {
                     return FALSE;
                   }
                 context->schedulingState = ewsContextScheduled;
                 context->xmlp_handle = NULL;

#                ifdef EW_CONFIG_OPTION_CLIENT
                 /*
                  * If source is EmWeb/Client response, then we must not send
                  * data on the connection, and instead pass control back to
                  * client.
                  */
                 if (context->client != NULL)
                   {
                     context->state = ewsContextStateClient;
                     return FALSE;
                   }
#                endif /* EW_CONFIG_OPTION_CLIENT */

#                ifdef EW_CONFIG_OPTION_SOAP
                 /*
                  * If we finished parsing SOAP request's XML body,
                  * we have to call action/query function
                  */
                 if (context->soap_flags & EW_SOAP_REQUEST)
                   {
                     /*
                      * If we finished parsing SOAP request's XML body,
                      * we have to call action/query function AFTER
                      * ewuSoapXmlpEnd() called by XMLP
                      */
                     return(FALSE);
                   }
#                endif /* EW_CONFIG_OPTION_SOAP */

                 if (   context->state == ewsContextStateXMLP
                    )
                   {
                     ewsSendHeaderAndEnd(context
                                        ,ews_http_status_204
                                        ,ews_no_body);
                   }
               }
             return FALSE;
         }

#       endif /* EMWEB_XMLP*/

       /*********************************************************************/
       /* Bad state! */
       default:
         EMWEB_TRACE_PARSE_OUT(("ewsParse(state=UNKNOWN)\n\t%s\n", emwebTraceParseQuoteString(context->req_str_begin, FALSE, EMWEB_TRACE_PARSE_LEN)));

#       ifdef EMWEB_SANITY
         EMWEB_ERROR(("ewsParse: bad state\n"));
#       endif /* EMWEB_SANITY */
         ewsNetHTTPAbort( context );
         break;
     }

   /*
    * I'm assuming that, if we get here, we are
    * waiting for more data.
    */
   context->schedulingState = ewsContextDataWait;
   EMWEB_TRACE_PARSE_OUT(("ewsParse() returns FALSE\n"));
   return FALSE;
}

/*
 * ewsParseHeader
 * This function is called from ewsParse when context->req_header has been
 * parsed.  Some headers require special internal handling (e.g. for
 * authentication, content-length, etc.) and are handled here.
 *
 * context      - Context of request
 *
 * No return value
 */
void
ewsParseHeader ( EwsContext context )
{

#if defined (EW_CONFIG_OPTION_CGI) || \
   defined (EW_CONFIG_OPTION_FORM) || \
   defined (EW_CONFIG_OPTION_PERSISTENT) || \
   defined (EW_CONFIG_OPTION_CONTENT_NEGOTIATION) || \
   defined(EW_CONFIG_OPTION_PRIMARY) ||\
   defined(EW_CONFIG_OPTION_RANGE) ||\
   defined(EW_CONFIG_OPTION_CLIENT_COOKIES) ||\
   EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1

 EwsString estring;

   EW_UNUSED(estring); /* unused in some configurations */

   EMWEB_TRACE_PARSE_OUT(("ewsParseHeader(header=%s, value=%s)\n",
                          (context->req_header == ewsRequestHeaderUnknown ?
                           "UNKNOWN" :
                           ews_state->req_header_table[context->req_header]),
                          emwebTraceParseQuoteString(
                            context->req_headerp[context->req_header],
                            TRUE,
                            EMWEB_TRACE_PARSE_LEN)));

   switch(context->req_header)
     {
#if defined (EW_CONFIG_OPTION_CGI) || defined (EW_CONFIG_OPTION_FORM) ||\
   defined (EW_CONFIG_OPTION_PRIMARY) || defined (EW_CONFIG_OPTION_UPNP)
       /*
        * Read Content-Length: decimal value from character string
        */
       case ewsRequestHeaderContentLength:
         context->content_length = 0;
         estring = context->req_headerp[ewsRequestHeaderContentLength];
         ewsStringGetInteger(&estring, 10, &context->content_length);
         context->content_remaining = context->content_length;
         break;
#endif /* CGI | FORM | PRIMARY */

#       ifdef EW_CONFIG_OPTION_PERSISTENT
       /*
        * Read Connection: header and set keep-alive flag if Keep-Alive
        */
       case ewsRequestHeaderConnection:

#        ifdef EW_CONFIG_OPTION_PRIMARY
         /*
          * Clobber end-to-end header in case we forward it
          */
         ewsStringRewriteChar(&context->hdr_str_clobber, '-');
#        endif /* EW_CONFIG_OPTION_PRIMARY */

         context->have_connection_header = TRUE;
         if (ewsParseAttributeFromHeader( &context->req_headerp[ewsRequestHeaderConnection]
                                         ,(char*)"Keep-Alive"
                                         ,&estring
                                         ,ewsParseValue
                                         ,'=' /* not used? */
                                         ,ewsHdrUpdateNo
                                         )
             )
           {
             /* client explicitly requested persistence, so respect it */
             context->keep_alive = TRUE;
           }

         if (ewsParseAttributeFromHeader( &context->req_headerp[ewsRequestHeaderConnection]
                                         ,(char*)"close"
                                         ,&estring
                                         ,ewsParseValue
                                         ,'=' /* not used? */
                                         ,ewsHdrUpdateNo
                                         )
             )
           {
             /* client explicitly wants a close */
             context->keep_alive = FALSE;
           }
         break;
#       endif /* EW_CONFIG_OPTION_PERSISTENT */

#       if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 ||\
          defined(EW_CONFIG_OPTION_CONTEXT_HOST)
       case ewsRequestHeaderHost:
         if (ewsStringLength(&context->req_host) == 0)
           {
             context->req_host = context->req_headerp[ewsRequestHeaderHost];
           }
         break;
#       endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 || HOST */
#       if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 && defined(EW_CONFIG_OPTION_EXPECT)
       case ewsRequestHeaderExpect:
         if (ewsStringCompare(&context->req_headerp[ewsRequestHeaderExpect]
                             ,"100-continue"
                             ,ewsStringCompareCaseInsensitive
                             ,NULL))
            {
              context->expect_100_continue = TRUE;
            }
          else
            {
              context->expect_failed = TRUE;
            }
#       endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 && EXPECT */

#       if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
       case ewsRequestHeaderTransferEncoding:
         if (ewsStringCompare(
                &context->req_headerp[ewsRequestHeaderTransferEncoding]
               ,"chunked"
               ,ewsStringCompareCaseInsensitive
               ,NULL))
           {
             context->chunked_encoding = TRUE;
             context->chunk_in_state = ewsContextChunkInStateInit;
#             ifdef EW_CONFIG_OPTION_PRIMARY
             /*
              * If downgrading, clobber transfer-encoding header
              */
             if (context->is_secondary_context &&
                 context->secondary->context_current->downgrade)
               {
                 ewsStringRewriteChar(&context->hdr_str_clobber, '-');
               }
#             endif /* EW_CONFIG_OPTION_PRIMARY */
           }
         break;
#       endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

#       ifdef EW_CONFIG_OPTION_PRIMARY
       case ewsRequestHeaderMaxForwards:
         estring = context->req_headerp[ewsRequestHeaderMaxForwards];
         ewsStringGetInteger(&estring, 10, &context->max_forwards);
         break;
#       endif /* EW_CONFIG_OPTION_PRIMARY */

#ifdef EW_CONFIG_OPTION_COOKIES
       /* if this is the Cookie header, we need to dig out all the name = value
        * pairs and save them in EwsCookie structures linked together
        * and hooked up to context
        *
        */

       case ewsRequestHeaderCookie:
         ewsParseCookies( context );
         break;
#endif /* EW_CONFIG_OPTION_COOKIES */


#ifdef EW_CONFIG_OPTION_CONTENT_NEGOTIATION

       /* parse the Negotiate: request header */
       case ewsRequestHeaderNegotiate:
         ewsParseNegotiateHdr( context );
         break;

       /* parse the Accept: request header */
       case ewsRequestHeaderAccept:
         estring = context->req_headerp[ewsRequestHeaderAccept];

         ewsParseAcceptHdr( context,
                            estring,
                            &context->accept_hdr_first,
                            &context->accept_hdr_last );
         break;

       /* parse the Accept-Charset: request header */
       case ewsRequestHeaderAcceptCharset:

         estring = context->req_headerp[ewsRequestHeaderAcceptCharset];

         ewsParseAcceptHdr( context,
                            estring,
                            &context->accept_charset_hdr_first,
                            &context->accept_charset_hdr_last );
         break;

       /* parse the Accept-Language: request header */
       case ewsRequestHeaderAcceptLanguage:

         estring = context->req_headerp[ewsRequestHeaderAcceptLanguage];

         ewsParseAcceptHdr( context,
                            estring,
                            &context->accept_language_hdr_first,
                            &context->accept_language_hdr_last );
         break;

       /* parse Accept-Encoding: request header */
       case ewsRequestHeaderAcceptEncoding:

         estring = context->req_headerp[ewsRequestHeaderAcceptEncoding];

         ewsParseAcceptHdr( context,
                            estring,
                            &context->accept_encoding_hdr_first,
                            &context->accept_encoding_hdr_last );
         break;

#endif /* EW_CONFIG_OPTION_CONTENT_NEGOTIATION */

#ifdef EW_CONFIG_OPTION_UPNP
       /*
        *
        * MSEARCH request MUST have the following headers
        *
        */

       case ewsRequestHeaderMAN:
         if (context->ssdp_connection == TRUE)
           {
             /*
              * the value must be "ssdp:discover"
              */
             if (ewsStringCompare(&context->req_headerp[ewsRequestHeaderMAN]
                                 ,"\"ssdp:discover\""
                                 ,ewsStringCompareCaseSensitive, NULL))
               {
                 context->upnp_have_headers |= UPNP_MAN_HEADER;
               }
           }
#ifdef   EW_CONFIG_OPTION_SOAP
         else
           {
             /*
              * assume it is MPOST request
              */
             context->upnp_have_headers |= UPNP_MAN_HEADER;
           }
#endif   /* EW_CONFIG_OPTION_SOAP */
         break;
       case ewsRequestHeaderMX:
         /*
          * delay value, integer
          */
         context->upnp_have_headers |= UPNP_MX_HEADER;
         context->ssdp_mx = 0;
         estring = context->req_headerp[ewsRequestHeaderMX];
         ewsStringGetInteger(&estring, 10, &context->ssdp_mx);
         break;
       case ewsRequestHeaderST:
         /*
          * search target, string
          */
         estring = context->req_headerp[ewsRequestHeaderST];
         if (ewsStringLength(&estring) == 0)
           {
             EMWEB_WARN(("ewsParseHeader: no ST value for MSEARCH request\n"));
             (void) ewsNetHTTPAbort(context);
             return;
           }
         context->upnp_have_headers |= UPNP_ST_HEADER;
         break;
#     ifdef EW_CONFIG_OPTION_UPNP_SSDP_CP
      /*
       * NOTIFY message MUST have following headers:
       */
      case ewsRequestHeaderNT:
        estring = context->req_headerp[ewsRequestHeaderNT];
        if (ewsStringLength(&estring) == 0)
          {
            EMWEB_WARN(("ewsParseHeader: no NT value for NOTIFY request\n"));
            break;
          }
        context->upnp_have_headers |= UPNP_NT_HEADER;
        break;
      case ewsRequestHeaderNTS:
        estring = context->req_headerp[ewsRequestHeaderNTS];
        if (ewsStringLength(&estring) == 0)
          {
            EMWEB_WARN(("ewsParseHeader: no NTS value for NOTIFY request\n"));
            break;
          }
        context->upnp_have_headers |= UPNP_NTS_HEADER;
        break;
      case ewsRequestHeaderUSN:
        estring = context->req_headerp[ewsRequestHeaderUSN];
        if (ewsStringLength(&estring) == 0)
          {
            EMWEB_WARN(("ewsParseHeader: no USN value for NOTIFY request\n"));
            break;
          }
        context->upnp_have_headers |= UPNP_USN_HEADER;
        break;
      case ewsRequestHeaderLocation:
        /*
         * this is URL for UPnP description for root device
         */
        estring = context->req_headerp[ewsRequestHeaderLocation];
        if (ewsStringLength(&estring) == 0)
          {
            EMWEB_WARN(("ewsParseHeader: no LOCATION value for NOTIFY request\n"));
            break;
          }
        context->upnp_have_headers |= UPNP_LOCATION_HEADER;
        break;
      case ewsRequestHeaderCacheControl:
        /*
         * device/service retention time
         */
        estring = context->req_headerp[ewsRequestHeaderCacheControl];
        if (ewsStringLength(&estring) == 0)
          {
            EMWEB_WARN(("ewsParseHeader: no CACHE-CONTROL value for NOTIFY request\n"));
            break;
          }
        context->upnp_have_headers |= UPNP_CACHE_CONTROL_HEADER;
        break;
#     endif /* EW_CONFIG_OPTION_UPNP_SSDP_CP */
#endif /* EW_CONFIG_OPTION_UPNP */

#ifdef EW_CONFIG_OPTION_CLIENT_COOKIES
       case ewsRequestHeaderSetCookie:
         ewsClientParseSetCookie(context);
         break;
#endif /* EW_CONFIG_OPTION_CLIENT_COOKIES */

#ifdef EW_CONFIG_OPTION_BYTE_RANGES
       case ewsRequestHeaderRange:
         estring = context->req_headerp[ewsRequestHeaderRange];
         /*
          * Only pay attention to first range header, ignore any others
          */
         if ( ! context->isRange )
           {
             EwsString _e;
             uint32    _u;

             context->isRange = TRUE; /* We have found a Range: header */

             /*
              * Look for and skip "bytes"+LWS+"="+LWS
              */
             if (!ewsStringCompare(&estring
                                  ,"bytes"
                                  ,ewsStringCompareCaseInsensitive
                                  ,NULL))
               {
                 context->firstBytePos = 1; /* mark unparsable */
                 context->lastBytePos = 0;
                 break;
               }
             _e = estring;
             if (ewsStringSearch(&_e
                                ,&estring
                                ,(char*) " \t\r\n"
                                ,ewsStringSearchExclude
                                ,NULL)
                 != '=')
               {
                 context->firstBytePos = 1; /* mark unparsable */
                 context->lastBytePos = 0;
                 break;
               }
             (void) ewsStringGetChar(&estring); /* skip = */
             _e = estring;
             ewsStringSearch(&_e
                            ,&estring
                            ,(char*) " \t\r\n"
                            ,ewsStringSearchExclude
                            ,NULL);
             _e = estring;

             /*
              * Parse first byte, may be negative.  We don't rely upon
              * ewsGetInteger() because we want to allow LWS after '-'.
              */
             context->firstBytePos = 0;
             context->lastBytePos = EWS_CONTENT_LENGTH_UNKNOWN;

             /*
              * If first character is '-', then this is a suffix
              */
             if (ewsStringGetChar(&_e) == '-')
               {
                 /* skip LWS after '-' */
                 estring = _e;
                 ewsStringSearch(
                    &estring
                   ,&_e
                   ,(char*) " \t\r\n"
                   ,ewsStringSearchExclude
                   ,NULL);
                 if (!ewsStringGetInteger(&_e, 10, &_u))
                   {
                     context->firstBytePos = 1; /* mark unparsable */
                     context->lastBytePos = 0;
                     break;
                   }
                 context->firstBytePos = - _u;
               }

             /*
              * Otherwise, this is a range
              */
             else
               {
                 /*
                  * Get first byte position
                  */
                 if (!ewsStringGetInteger(&estring, 10, &_u))
                   {
                     context->firstBytePos = 1; /* mark unparsable */
                     context->lastBytePos = 0;
                     break;
                   }
                 context->firstBytePos = _u;

                 /*
                  * skip LWS to hyphen
                  */
                 _e = estring;
                 if (ewsStringSearch(&estring
                                    ,&_e
                                    ,(char*) " \t\r\n"
                                    ,ewsStringSearchExclude
                                    ,NULL) != '-')
                   {
                     context->firstBytePos = 1; /* mark unparsable */
                     context->lastBytePos = 0;
                     break;
                   }
                 (void) ewsStringGetChar(&_e); /* skip hyphen */
                 estring = _e;
                 ewsStringSearch(&estring
                                ,&_e
                                ,(char*) " \t\r\n"
                                ,ewsStringSearchExclude
                                ,NULL);
                 /*
                  * Read optional last byte position.  No error case.
                  */
                 if (ewsStringGetInteger(&_e, 10, &_u))
                   {
                     context->lastBytePos = _u;
                   }
               }
           }
         break;
#endif /* EW_CONFIG_OPTION_BYTE_RANGES */

       /*
        * No special action for any other header types
        */
       default:
         break;
     }

#else /* defined (CGI | FORM | PERSISTENT | HTTP_1_1 | PRIMARY | UPNP | RANGE | CLIENT_COOKIES) */
  EW_UNUSED(context);
#endif /* defined (CGI | FORM | PERSISTENT | HTTP_1_1 | PRIMARY | UPNP | RANGE | CLIENT_COOKIES) */

}

#ifdef EW_CONFIG_OPTION_RELEASE_UNUSED
/*
 * ewsParseReleaseUnusedBuffers
 *
 * During HTTP processing, often the server will save strings from
 * the incoming data stream.  This routine flushes any buffers that
 * don't contain any data that has been saved.  This is a simple optimization
 * intended to prevent EmWeb/Server from holding on to large HTTP request or
 * HTTP submit buffers if no useful information is contained in them.
 *
 * If string_saved is TRUE, then this routine assumes context->req_str_begin
 * represents the start of the last saved string, and context->req_str_end
 * the byte just past this last saved string.  Any buffers preceding
 * req_str_begin that do not contain saved data are freed.
 *
 * If string_saved is FALSE, then this routine assumes that all buffers
 * between the end of the last saved string up to the buffer _before_
 * context->req_str_end are to be freed.
 *
 * This function must be called each time the HTTP parser saves a string.
 * The context keeps track of the last saved buffer (context->req_buf_used).
 *
 * context      - context of request
 * string_saved - TRUE if string just saved, otherwise FALSE.  If TRUE, the
 *                req_buf_used state is updated, otherwise it is left alone.
 *
 * No return value
 */
void
ewsParseReleaseUnusedBuffers ( EwsContext context, boolean string_saved )
{
 EwaNetBuffer  first;  /* first buffer in EwsString */
 EwaNetBuffer  buffer; /* used to walk chain of queued buffers */
 EwaNetBuffer  next;   /* next buffer after buffer */

   EMWEB_TRACE(("ewsParseReleaseUnusedBuffers(%p, %d)\n", context,
     string_saved));

#   ifdef EW_CONFIG_OPTION_METHOD_TRACE
   /*
    * If TRACE method, we must not discard any buffers!
    */
   if (context->req_method == ewsRequestMethodTrace)
     {
       return;
     }
#   endif /* EW_CONFIG_OPTION_METHOD_TRACE */

#   ifdef EW_CONFIG_OPTION_PRIMARY
   /*
    * If configured as primary, we must not discard headers.
    */
   if (context->state == ewsContextStateParseHeaders)
     {
       context->req_buf_used = ewsStringBuffer(&context->req_str_end);
       return;
     }
#   endif /* EW_CONFIG_OPTION_PRIMARY */

   /*
    * If this EwsString was just saved, then the first buffer in the string
    * is referenced.  We can only release buffers between the previously
    * used buffer and the first buffer in the string exclusive.
    */
   if (string_saved)
     {
       first = ewsStringBuffer(&context->req_str_begin);
     }

   /*
    * Otherwise, we can release all buffers after the last used up to but
    * not including the last buffer in the current string.  The last buffer
    * in the current string is in use now, but could be released later if
    * no strings are saved from it.
    */
   else
     {
       first = ewsStringBuffer(&context->req_str_end);
     }

   /*
    * If this is not the first time through, and the first buffer to save
    * in the EwsString is not the last used buffer, then determine if
    * intermediate buffers exist which may be released
    */
   buffer = context->req_buf_used;
   if (buffer != EWA_NET_BUFFER_NULL && buffer != first)
     {
       /*
        * Determine buffer immediately before EwsString's first buffer
        */
       while ((next = ewaNetBufferNextGet(buffer)) != first)
         {
           buffer = next;
         }

       /*
        * If the preceding buffer was not the last saved buffer, then there
        * are intermediate buffers to release.
        */
       if (buffer != context->req_buf_used)
         {
           /*
            * Link last used buffer to first buffer in new string, break link
            * between last unused buffer and new string, and release chain of
            * unused buffers.
            */
           next = ewaNetBufferNextGet(context->req_buf_used);
           ewaNetBufferNextSet(context->req_buf_used, first);
           ewaNetBufferNextSet(buffer, EWA_NET_BUFFER_NULL);
           ewaNetBufferFree(next);
         }

     }

   /*
    * If no req_buf_used specified, we can free all buffers up to current
    * buffer.  This will never happen in HTTP server because METHOD
    * is in beginning of first buffer and is saved.  However, other protocols
    * using this engine will benefit.
    */
   if (buffer == EWA_NET_BUFFER_NULL && context->req_buf_first != first)
     {
       buffer = context->req_buf_first;
       for (next = buffer;
            ewaNetBufferNextGet(next) != first;
            next = ewaNetBufferNextGet(next)
           )
         {
         }
       ewaNetBufferNextSet(next, EWA_NET_BUFFER_NULL);
       context->req_buf_first = first;
       ewaNetBufferFree(buffer);
     }

   /*
    * If the caller just saved a string, update the req_buf_used field.
    * Otherwise, simply free buffers up to this point.  The current buffer
    * may or may not end up being saved.
    */
   if (string_saved)
     {
       context->req_buf_used = ewsStringBuffer(&context->req_str_end);
     }
}
#endif /* EW_CONFIG_OPTION_RELEASE_UNUSED */

#ifdef EW_CONFIG_OPTION_UPNP
/*
 * ewsParseAwaitingRequest
 * Test if the parser is awaiting the beginning of a request.
 * Assumes context has returned from ewsPars().
 *
 * context      - Context of request
 *
 * Returns TRUE if the parser is in a state indicating that it expects the
 * beginning of an HTTP request next.
 * Returns FALSE if the parser has seen that an initial part of a request has
 * already been processed, but the request has not been finished.  I.e., a
 * state in which seeing end-of-input would indicate a malformed request.
 */
boolean
ewsParseAwaitingRequest ( EwsContext context )
{
  /* Test the state variables.
   * This test is imperfect, since the parser does not exit the ParseMethod
   * substate until it sees the space at the end of the method, but in
   * practice that will only cause requests with uncompleted method words to
   * be terminated without an error report.
   */
  return ewsContextStateParseRequest == context->state &&
      ewsContextSubstateParseMethod == context->substate.request;
}
#endif /* EW_CONFIG_OPTION_UPNP */

static void
ewsParseError(EwsContext context
#ifdef EWA_LOG_HOOK
            ,EwsLogStatus status
#endif
            )
{
#ifdef EW_CONFIG_OPTION_PRIMARY
  if (!context->is_secondary_context)
    {
      ewaLogHook(context, status);
    }
#else
   ewaLogHook(context, status);
#endif
   context->req_protocol_maj = 1;
#ifdef EW_CONFIG_OPTION_UPNP
   if (context->ssdp_connection)
     {
       ewsInternalFinish(context);
       return;
     }
#endif
   ewsSendHeaderAndEnd(context
                       ,ews_http_status_400
                       ,ews_http_string_400);
}

#if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
boolean
ewsParseChunk(EwsContext context)
{
#ifdef EW_CONFIG_OPTION_CHUNKED_IN
 uintf match_c;
 uintf bytes;
 uint8 *src, *dst;
 EwaNetBuffer buf;

   /*
    * Handle by state
    */
   switch ( context->chunk_in_state )
     {
       case ewsContextChunkInStateParseData:

         /* fall through to next state */

       case ewsContextChunkInStateInit:
         /*
          * Save parse state, move to preparse length
          */
         context->chunk_str_begin = context->req_str_begin;
         context->chunk_str_end = context->req_str_end;
         context->req_str_begin = context->req_str_end;
         context->chunk_in_state = ewsContextChunkInStatePreParseLength;

         /* fall through to next state */

       case ewsContextChunkInStatePreParseLength:
         /*
          * Skip LWS before chunk length value
          */
         match_c = ewsStringSearch(&context->req_str_begin
                                  ,&context->req_str_end
                                  ,(char *)" \t\r\n"
                                  ,ewsStringSearchExclude
                                  ,NULL);
         if (match_c == EWS_STRING_EOF)
           {
             break; /* need more data */
           }

         context->req_str_begin = context->req_str_end;
         ewsStringLengthSet(&context->req_str_begin, 0);
         context->chunk_in_state = ewsContextChunkInStateParseLength;

         /* fall through to next state */

       case ewsContextChunkInStateParseLength:
         /*
          * Parse length up to LWS or chunk extension and read chunk length
          * in hexadecimal
          */
         match_c = ewsStringSearch(&context->req_str_begin
                                  ,&context->req_str_end
                                  ,(char *)" \t\r\n;"
                                  ,ewsStringSearchInclude
                                  ,NULL);
         if (match_c == EWS_STRING_EOF)
           {
             break; /* need more data */
           }
         if (!ewsStringGetInteger(&context->req_str_begin
                                 ,16
                                 ,&context->content_remaining))
           {
             EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_REQUEST);
             return FALSE;
           }

         ewsStringGetChar(&context->req_str_end);
         if (match_c == '\n')
           {
             context->chunk_in_state = ewsContextChunkInStateHaveNL;
             return TRUE;
           }
         context->chunk_in_state = ewsContextChunkInStatePostParseLength;

         /* fall through to next state */

       case ewsContextChunkInStatePostParseLength:
         /*
          * Skip up to NL
          */
         for (;;)
           {
             match_c = ewsStringGetChar(&context->req_str_end);
             if (match_c == EWS_STRING_EOF)
               {
                 context->schedulingState = ewsContextDataWait;
                 return FALSE; /* need more data */
               }
             if (match_c == '\n')
               {
                 break;
               }
           }
         context->chunk_in_state = ewsContextChunkInStateHaveNL;


          /* fall through to next state */

       case ewsContextChunkInStateHaveNL:

         /*
          * If not last chunk,
          */
         if (context->content_remaining != 0)
           {
#             ifdef EW_CONFIG_OPTION_PRIMARY
             /*
              * If forwarding to secondary, we must not strip out chunk
              * headers as they are to be forwarded, unless downgrading
              * to HTTP/1.0 user agent.
              */
             if (context->state == ewsContextStateForwarding)
               {
                 EwsContext pcontext = context->secondary->context_current;

                   if (!context->is_secondary_context ||
                       pcontext->req_protocol_maj > 1 ||
                       (pcontext->req_protocol_maj == 1 &&
                        pcontext->req_protocol_min >= 1))
                     {
                       context->req_str_begin = context->chunk_str_begin;
                       context->chunk_in_state = ewsContextChunkInStateParseData;
                       return TRUE;
                     }
               }
#             endif /* EW_CONFIG_OPTION_PRIMARY */

             /*
              * Strip out chunk header to make data contiguous.
              *
              * If chunk header starts and ends in the same buffer,
              * we can simply reduce the buffer length and copy
              * data down over chunk header.
              */
             if (ewsStringBuffer(&context->chunk_str_end) ==
                 ewsStringBuffer(&context->req_str_end))
               {
                 src = ewsStringData(&context->req_str_end);
                 dst = ewsStringData(&context->chunk_str_end);
                 bytes = ewsStringAvailable(&context->req_str_end);
                 ewaNetBufferLengthSet(
                    ewsStringBuffer(&context->chunk_str_end)
                   ,ewaNetBufferLengthGet(
                      ewsStringBuffer(&context->chunk_str_end)) - (src - dst));
                 while (bytes > 0)
                   {
                     *dst++ = *src++;
                     bytes--;
                   }
               }

             /*
              * Otherwise, chunk header spans buffer boundary.
              */
             else
               {
                 /*
                  * Truncate length of first buffer to start of chunk header
                  */
                 buf = ewsStringBuffer(&context->chunk_str_end);
                 ewaNetBufferLengthSet(buf, context->chunk_str_end.offset);

                 /*
                  * For each intermediate buffer, set length to zero
                  */
                 for (buf = ewaNetBufferNextGet(buf);
                      buf != ewsStringBuffer(&context->req_str_end);
                      buf = ewaNetBufferNextGet(buf))
                   {
                     ewaNetBufferLengthSet(buf, 0);
                   }

                 /*
                  * For last buffer, advance data pointer to end of chunk
                  * and adjust length accordingly.
                  */
                 ewaNetBufferDataSet(buf
                                    ,ewsStringData(&context->req_str_end));
                 ewaNetBufferLengthSet(buf
                                    ,ewaNetBufferLengthGet(buf) -
                                     context->req_str_end.offset);
               }

             /*
              * Restore parser state and continue parsing
              */
             context->req_str_begin = context->chunk_str_begin;
             context->req_str_end = context->chunk_str_end;
             context->chunk_in_state = ewsContextChunkInStateParseData;
#            ifdef EW_CONFIG_OPTION_AUTH_DIGEST
             context->md5_entity_str = context->req_str_end;
             context->md5_remaining = context->content_remaining;
#            endif /* EW_CONFIG_OPTION_AUTH_DIGEST */

             return TRUE;
           }

         context->chunk_in_state = ewsContextChunkInStateParseFooter;

         /* fall through to next state */

       case ewsContextChunkInStateParseFooter:
         /*
          * Skip up to NL
          */
         for (;;)
           {
             match_c = ewsStringGetChar(&context->req_str_end);
             if (match_c == EWS_STRING_EOF)
               {
                 context->schedulingState = ewsContextDataWait;
                 return FALSE; /* need more data */
               }
             if (match_c != '\n' && match_c != '\r')
               {
                 context->chunk_in_state = ewsContextChunkInStatePostParseLength;
                 return TRUE;
               }
             if (match_c == '\n')
               {
                 break;
               }
           }

         /*
          * End of request:  Restore parse state
          */
         context->chunked_encoding = FALSE;
         context->req_str_begin = context->chunk_str_begin;
         return TRUE;

#       ifdef EMWEB_SANITY
       default:
         EMWEB_ERROR(("ewsParseChunk: bad chunk state\n"));
         ewsNetHTTPAbort(context);
         return FALSE;
#       endif /* EMWEB_SANITY */
     }

   /*
    * I'm assuming that, if we get here, we are
    * waiting for more data.
    */
   context->schedulingState = ewsContextDataWait;
   return FALSE;

#else /* EW_CONFIG_OPTION_CHUNKED_IN */

#ifdef EW_CONFIG_OPTION_PRIMARY
   if (!context->is_secondary_context)
     ewaLogHook(context, EWS_LOG_STATUS_LENGTH_REQUIRED);
#else
   ewaLogHook(context, EWS_LOG_STATUS_LENGTH_REQUIRED);
#endif
   ewsSendHeaderAndEnd(context
                      ,ews_http_status_411
                      ,ews_http_string_411);
   return FALSE;

#endif /* EW_CONFIG_OPTION_CHUNKED_IN */

}
#endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */


#ifdef EW_CONFIG_OPTION_FIELDTYPE_FILE

/**********************************************************************
 * ewsParseFormData
 *
 * Parse FORM data in mulitpart/form-data format
 * format (see RFC1867):
 *
 * 1*[<CRLF>--(boundary)<CRLF>(headers)<CRLF>(multipart-data)]
 * <CRLF>--(boundary)--<CRLF>
 *
 * The context->inputFile->formDataBoundary contains the boundary string as a
 * null terminated string in the <CRLF>--boundary format.
 * If context->form_expectp is not NULL, then *context->form_expectp indicates
 * how much data is expected, else no content length is given, and we search
 * until we hit the end-boundary.
 * The context->req_str_begin indicates the start of the search.
 * The context->form_parsep indicates the end of the last search.
 *
 * Moved the logic into it's own function to help isolate the
 * complexity...
 *
 * Returning "TRUE" causes ewsParse to be recalled immediately
 */
static boolean
ewsParseFormData( EwsContext context )
{
 EwsFormInputFileState *file = context->inputFile;  /* cache the file state */
 uintf     match_c;

# ifdef EMWEB_SANITY
 if (context->form_parsep != &context->req_str_end)
   {
     EMWEB_ERROR(("ewsParseFormData: Internal error -"
                  " form_parsep != req_str_end!!\n"));
   }
# endif /* EMWEB_SANITY */


# if EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1
 /*
  * If chunked encoding, handle chunk state if not parsing data
  */
 if (   *context->form_chunkedp
     && context->chunk_in_state != ewsContextChunkInStateParseData)
   {
     return ewsParseChunk(context);
   }

# ifdef EW_CONFIG_OPTION_CHUNKED_IN
 /*
  * If we saved the previous end of data, restore it here
  * (see the end of this function).  We had to do this
  * if we did not absorb a full chunk's worth of data
  * before needing the next chunk (eg. looking for a string
  * match which spans a chunk).
  */
 if (ewsStringBuffer( &file->leftOverChunk ) != EWA_NET_BUFFER_NULL)
   {
     *context->form_parsep = file->leftOverChunk;
     *context->form_expectp += file->leftOverData;
     ewsStringInit( &file->leftOverChunk, EWA_NET_BUFFER_NULL );
   }
# endif /* EW_CONFIG_OPTION_CHUNKED_IN */
# endif /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

# ifdef _CONFIG_OPTION_AUTH_DIGEST_AUTH_INT
  /*
   * If checking message digest, update digest.
   */
  if (context->auth_state != ewsAuthStateUninitialized)
    {
      ewsAuthDigestUpdate(context);
    }
# endif /* _CONFIG_OPTION_AUTH_DIGEST_AUTH_INT */

 /*
  * Handle by substate
  */
 switch(context->substate.form)
   {
     /************************************************
      * First state when parsing form-data.  This is a
      * special case: we could be at a boundary WITHOUT
      * the leading CRLF (the CRLF that terminated the
      * headers is the leading CRLF for this boundary),
      * or we're at the optional preamble.  This
      * preamble must be ignored.
      */
   case ewsContextSubstateMPPreamble:
     {
       /* note we're just looking for the boundary without
        * the leading CRLF...
        */
       file->boundaryMatch =
         ewsStringSubstringSearch(&context->req_str_begin
                                  ,context->form_parsep
                                  ,&file->formDataBoundary[2]
                                  ,ewsStringCompareCaseSensitive
                                  ,context->form_expectp);

       /*
        * only leave this state on a boundary match, there
        * MUST be one!!  Mark form_name is empty for now.
        */
       if (file->boundaryMatch)
         {
           ewsStringLengthSet( &context->form_name, 0 );

           /* We have matched a boundary!  According to the
            * MIME spec, the boundary will NEVER occur in the
            * data.  So, the only valid chars that can follow
            * the boundary are LWS, -'s (indicating last boundary),
            * and good old CRLF.
            *
            * Start by pushing context->form_parsep to the
            * char following the boundary string.
            */
           ewsStringTrim( context->form_parsep
                         ,ewsStringLength( context->form_parsep)
                        );

           context->substate.form = ewsContextSubstateMPBoundaryFound;
           return TRUE;
         }

       /*
        * couple of notes:
        *
        * 1) most of the time, there will not be a preamble.  We'll
        * match the boundary right off, then jump to boundary found
        * 2) If there is a preamble, and the boundary is a prefix
        * of preamble data (false match), then we're safe to jump
        * to boundaryFound, since the false match will be detected,
        * and the next boundary match will be normal (prefixed with
        * CRLF
        * 3) Since we haven't gotten a field name set, any preamble
        * will be tossed away (not associated with a form element -
        * see SubstateMPPostBoundary).
        */
     }
   break;

   /*************************************************
    * Parse to the next boundary string, ignoring any
    * data between the current point and the boundary
    * string.
    *************************************************/

   case ewsContextSubstateMPFindBoundary:
     {
       /*
        * If match, req_str_begin represents the string from the
        * current position to the char before <CRLF>--boundary,
        * and form_parsep represents the <CRLF>--boundary string.
        * If no match, then req_str_begin represents the string
        * from the current position to the last char searched,
        * form_parsep is set to the next char to start searching.
        */
       file->boundaryMatch =
         ewsStringSubstringSearch( &context->req_str_begin
                                   ,context->form_parsep
                                   ,file->formDataBoundary
                                   ,ewsStringCompareCaseSensitive
                                   ,context->form_expectp);
       context->substate.form = ewsContextSubstateMPSearchDone;
     }     /* fall through */


   /********************************************************************
    * The search routine either found a possible match, or it ran out of
    * data.  Either way, write any data that the search may have skipped
    * if we're writing data to a file.
    ********************************************************************/

   case ewsContextSubstateMPSearchDone:
     {
       /*
        * if currently parsing file data, send
        * what we've got to the file write routine
        * and advance req_str_begin beyond this string.
        * After this, req_str_begin = form_parsep and
        * req_str_begin->length = 0
        */
       if (file->fieldIsFile)
         {
           if (file->formFile != EWA_FILE_HANDLE_NULL)
             {
               sintf   status;

               /* write data to file, req_str_begin advances past data
                * written
                */

               if ((status = ewsStringWrite( context
                                             ,file->formFile
#                                         ifdef EW_CONFIG_OPTION_PRIMARY
                                             ,ewsStringWriteFile
#                                         endif /* EW_CONFIG_OPTION_PRIMARY */
                                             ,&context->req_str_begin ))
                   < 0)
                 {
                   /* blow away the file handle to prevent further writes,
                    * set the file error bit in the form field's status,
                    * assume that the form submit code will clean up/close the
                    * file
                    */

                   EMWEB_WARN( ("ewsParseFormData: file write failed"
                                " - error code: 0x%X\n", status));
                   file->formFile = EWA_FILE_HANDLE_NULL;
                   *file->fileStatusp |= EW_FORM_FILE_ERROR;
                 }

               /* check for suspend or abort during write call */

               if (   context->abort_flags & EWS_CONTEXT_FLAGS_ABORT
#               ifdef EW_CONFIG_OPTION_SCHED_SUSP_RES
                      || context->schedulingState == ewsContextSuspended
#               endif  /* EW_CONFIG_OPTION_SCHED_SUSP_RES */
                      )
                 {
                   return FALSE;
                 }
             }     /* end if file handle OK */

           /*
            * free any buffers that we've written, NOTE that form_name
            * string will be freed with this call!!
            * Bugfix #743 - free unused buffers regardless of status of
            *  the file handle (valid or not!).
            */
           ewsParseReleaseUnusedBuffers( context, FALSE );

         } /* end if file input field */

       if (file->boundaryMatch)      /* boundary found!! */
         {
           /* We have matched a boundary!  According to the
            * MIME spec, the boundary will NEVER occur in the
            * data.  So, the only valid chars that can follow
            * the boundary are LWS, -'s (indicating last boundary),
            * and good old CRLF.
            *
            * Start by pushing context->form_parsep to the
            * char following the boundary string.
            */
           ewsStringTrim( context->form_parsep
                         ,ewsStringLength( context->form_parsep)
                        );
           context->substate.form = ewsContextSubstateMPBoundaryFound;
           /* fall to next state */
         }
       else        /* boundary not seen, continue search */
         {
           context->substate.form = ewsContextSubstateMPFindBoundary;
           break;          /* need more data or data truncated */
         }
       /* fall through */
     }

   /*******************************************************
    * At this point, context->req_str_begin bounds the text
    * prior to the boundary line.  context->form_parsep is
    * at the next unread char that is past the boundary, but
    * before the header lines.
    *
    * We should ignore any characters past the boundary
    * string until we hit a CRLF.  However, if this boundary
    * is the "last" boundary (trailed by "--"), then we
    * can submit the form right away, and ignore any chars
    * that follow until the end of data (there may be none).
    *******************************************************/

   case ewsContextSubstateMPBoundaryFound:
     {
       uintf next;

       /* Update the current form field (if there is one).  Note the
        * check fieldIsFile for the case of an input file.  Must do
        * this, since we NEVER want to do a ewsFormSubmitSet on a file
        * field.
        * NOTE WELL:  The order of the following check is important!!
        * we don't save the buffers that contain the
        * form_name string.  If there are lots of form fields, the
        * number of buffers to save would cause an undo burden.  In
        * the case of a file data field, we release buffers every time
        * we "write" a buffer to the file, so in this case the string
        * pointed to by context->form_name is _gone_ (freed with the
        * first batch of freed file data buffers).  So DON'T ever
        * try to reference the context->form_name once you start
        * writing file data (or put in an explicit save for it).
        * You'll see that I'm checking that context->inputFile->
        * fieldIsFile == FALSE before I know it's safe to use
        * context->form_name.
        */
       if (   !file->fieldIsFile
           && ewsStringLength(&context->form_name))
         {
           /* form_name.length would be zero if this was the initial
            * boundary (haven't hit a field yet). At this point, I have a
            * valid non-file form field - set it in the form
            */

           ewsFormSubmitSet( context
                            ,&context->form_name
                            ,&context->req_str_begin );
           /*
            * ...SubmitSet could have detected an error
            * and could have set context state to ...Abort...
            * Well, in that case follow the state
            */
           if (context->abort_flags & EWS_CONTEXT_FLAGS_ABORT)
             {
               return FALSE;
             }

         }

       /* since we're done with the form_name and all the header info,
        * it's safe to do a release of the buffers up to
        * context->form_parsep...
        */

       ewsParseReleaseUnusedBuffers( context, FALSE );

       /* reset the form_name and fieldIsFile for the next
        * form field
        */

       context->inputFile->fieldIsFile = FALSE;
       ewsStringLengthSet( &context->form_name, 0 );


       /* ignore characters that follow the boundary until CRLF,
        * unless -- is seen, which indicates that this boundary is
        * the last boundary of the form-data.  If that is the
        * case, submit the form, then ignore all chars until no
        * more data is seen....
        */

       for (;;)
         {
           if (context->form_expectp && *context->form_expectp == 0)
             {
               break;    /* no more data in form */
             }

           next = ewsStringGetChar( context->form_parsep );

           if (next == EWS_STRING_EOF)
             break;                        /* need more data */

           /* decrement the char count only after
            * char is not EWS_STRING_EOF
            */
           if (context->form_expectp)
             (*context->form_expectp)--;

           switch (next)
             {
             case '-':
               /*
                * must be last boundary in form, stay in this state
                * until we run out of data
                */
               file->formDataEnd = TRUE;
               break;

             case '\n':    /* done with the boundary !! */
               /*
                * if we have see the last boundary (see above), then
                * do nothing (wait out the remaining data before we
                * do the submit), otherwise, move on to check for MIME
                * headers.
                * Move req_str_begin & form_parsep to the next
                * unparsed byte, set length zero
                */

               if (!file->formDataEnd)
                 {
                   /* Move req_str_begin & form_parsep to the next
                    * unparsed byte, set length zero
                    */
                   ewsStringLengthSet( context->form_parsep, 0 );
                   context->req_str_begin = *context->form_parsep;
                   context->substate.form = ewsContextSubstateMPHeaderHaveNL;
                   return TRUE;
                 }

               /*
                * to be totally conformant, any boundary that is
                * followed by anything other than LWS, --, or CRLF
                * is an error.  But, we must be liberal in what we
                * accept, so I'm ignoring any chars (other than -) that
                * come before the CRLF (or end of data if -- seen)
                */
             }
         }         /* end for */
     }
   break;          /* if hit here, ran out of data */


   /**********************************************************************
    * Parse MIME headers for each of the form data segments
    *
    * At this point, form_parsep has reached CR from previous header
    * line or end of boundary string. Wait for NL.
    **********************************************************************/

   case ewsContextSubstateMPHeaderHaveCR:
     for (;;)
       {
         if (   (context->form_expectp && *context->form_expectp == 0)
             || ((match_c = ewsStringGetChar(context->form_parsep))
                 == EWS_STRING_EOF)
             )
           {
             break;          /* out of data, exit for loop */
           }

         if (context->form_expectp)
           (*context->form_expectp)--;

         ewsStringExpand(&context->req_str_begin, 1);

         if (match_c == '\n')
           {
             context->substate.form = ewsContextSubstateMPHeaderHaveNL;
             return TRUE;
           }
       }
     break;        /* we get here if out of data */


   /******************************************************************
    * Reached NL from previous header line or from last boundary.
    * Another NL terminates headers. LWS indicates continuation of
    * previous header (if there was one!).  Otherwise, start new header.
    * req_str_begin represents the value string, form_parsep indicates
    * the next char to parse.
    ******************************************************************/

   case ewsContextSubstateMPHeaderHaveNL:
     {
       EwsString tmp = *context->form_parsep;

       for (;;)
         {
           if (   (context->form_expectp && *context->form_expectp == 0)
               || ((match_c = ewsStringGetChar( &tmp ))
                   == EWS_STRING_EOF)
              )
             {
               break;          /* out of data */
             }


           if (match_c == '\n')      /* that's it, done with headers! */
             {
               /*
                * We'll start parsing from tmp; suck up the
                * \n...
                */
               *context->form_parsep = tmp;
               ewsStringLengthSet( context->form_parsep, 0 );
               context->req_str_begin = *context->form_parsep;
               if (context->form_expectp)
                 (*context->form_expectp)--;

               /*
                * if the field is a file, then attempt to open the
                * file, else it's a regular old field: get its
                * data.
                */

               if (file->fieldIsFile)
                 {
                   context->substate.form = ewsContextSubstateMPOpenFile;
                 }
               else
                 {
                   context->substate.form = ewsContextSubstateMPFindBoundary;
                 }
               return TRUE;
             }
           else if (match_c == ' ' || match_c == '\t')   /* header continue */
             {
               /*
                * keep the current char in the data stream for the next
                * state to read
                */
               context->substate.form = ewsContextSubstateMPParseValue;
               return TRUE;
             }
           else if (match_c != '\r')
             {
               /*
                * Done parsing current header value.  Don't do anything
                * with it yet.  Process headers as a group when done
                * with all headers.  keep the current char in the
                * data stream for the next state to read.
                */

               ewsStringLengthSet(context->form_parsep, 0);
               context->req_str_begin = *context->form_parsep;
               context->substate.form = ewsContextSubstateMPParseHeader;
               return TRUE;
             }
           else        /* \r - just suck it up and continue */
             {
               if (context->form_expectp)
                 (*context->form_expectp)--;
               ewsStringExpand(&context->req_str_begin, 1);
               *context->form_parsep = tmp;
             }
         }
     }
     break;        /* only get here if out of data */


   /***********************************************************************
    * req_str_begin points to the first char that should be the header
    * token. Read the header token.  Search request header table for match
    * and remember the header index.  This is where the following
    * header value will be stored.
    ***********************************************************************/

   case ewsContextSubstateMPParseHeader:
     {
       EwsFormDataHeaderIndex header;

       match_c = ewsStringSearch( &context->req_str_begin,
                                  context->form_parsep,
                                  (char *)": \t\r\n",
                                  ewsStringSearchInclude,
                                  context->form_expectp);
     if (match_c == EWS_STRING_EOF)
       {
         break;     /* need more data */
       }

     /* \r or \n are totally unexpected....
      * skip this partially entered field
      */

     if (match_c == '\r')
       {
         context->req_header = ewsRequestHeaderUnknown;
         context->substate.form = ewsContextSubstateMPHeaderHaveCR;
         return TRUE;
       }
     else if (match_c == '\n')
       {
         context->req_header = ewsRequestHeaderUnknown;
         context->substate.form = ewsContextSubstateMPHeaderHaveNL;
         return TRUE;
       }

     /*
      * check the header value for one that we're trying
      * to find...
      */
     for (header = (EwsFormDataHeaderIndex) 1;
          header < ewsFormDataHeaderCount;
          header = (EwsFormDataHeaderIndex) (header + 1))
       {
         if (ewsStringCompare(&context->req_str_begin,
                              ews_state->form_data_header_table[header],
                              ewsStringCompareCaseInsensitive,
                              NULL /* don't decrement expectp! */))
           {
             break;      /* out of for(;;) */
           }
       }

     if (header == ewsFormDataHeaderCount)
       {
         header = ewsFormDataHeaderUnknown;
       }
     context->req_header = (EwsRequestHeaderIndex) header;
     context->substate.form = ewsContextSubstateMPPostParseHeader;
     }
   /* fall through to next state */


   /*************************************************************
    * req_str_begin represents the header's token string.  It's
    * already been used to find the correct form data header.
    * (It may have been moved past this header, if a string
    * compare was successful).  Search for :
    *************************************************************/

   case ewsContextSubstateMPPostParseHeader:
     {
       match_c = ewsStringSearch(&context->req_str_begin,
                                 context->form_parsep,
                                 (char *)":\r\n",
                                 ewsStringSearchInclude,
                                 context->form_expectp);

       if (match_c == EWS_STRING_EOF)
         {
           break;      /* need more data */
         }

       /*
        * \r || \n totally unexpected, punt this header
        */
       if (match_c == '\r')
         {
           context->req_header = ewsRequestHeaderUnknown;
           context->substate.form = ewsContextSubstateMPHeaderHaveCR;
           return TRUE;
         }
       else if (match_c == '\n')
         {
           context->req_header = ewsRequestHeaderUnknown;
           context->substate.form = ewsContextSubstateMPHeaderHaveNL;
           return TRUE;
         }

       /*
        * otherwise, form_parsep is at ":", suck it up
        */
       ewsStringLengthSet( context->form_parsep, 1 );
       (void) ewsStringGetChar(&context->req_str_end);
       if (context->form_expectp)
         (*context->form_expectp)--;

       context->substate.form = ewsContextSubstateMPPreParseValue;
     }
   /* fall through to next state */


   /***********************************************************************
    * Have passed the "HEARDER : " string.  Skip LWS between ':' and value
    ***********************************************************************/

   case ewsContextSubstateMPPreParseValue:
     {
       match_c = ewsStringSearch(
                                 &context->req_str_begin,
                                 context->form_parsep,
                                 (char *)" \t",
                                 ewsStringSearchExclude,
                                 context->form_expectp);

       if (match_c == EWS_STRING_EOF)
         {
           break;      /* need more data */
         }

       /*
        * At this point, form_parsep is at the first
        * non-LWS character past the ":".  Start parsing
        * the header value here, so setup req_str_begin
        * to start here
        */
       context->req_str_begin = *context->form_parsep;
       ewsStringLengthSet(&context->req_str_begin, 0);
       context->substate.form = ewsContextSubstateMPParseValue;
     }
   /* fall through to next state */


   /***********************************************************************
    * Parse the value at req_str_begin up to CRNL and save it away.  (Value
    * may be continued, which is handled in the ewsContextSubstateMPHaveCR/NL
    * substates).
    ***********************************************************************/

   case ewsContextSubstateMPParseValue:
     {
       match_c = ewsStringSearch(
                                 &context->req_str_begin,
                                 context->form_parsep,
                                 (char *)"\r\n",
                                 ewsStringSearchInclude,
                                 context->form_expectp);

       if (match_c == EWS_STRING_EOF)
         {
           break;      /* need more data */
         }

       /* save the string seen so far */

       file->formDataHeaders[context->req_header] = context->req_str_begin;

       /* the Content-Disposition header contains the form field name.
        * If this header is Content-Disposition, we'll need to save
        * the buffer that contains the form field name only if the
        * form field name is that of a TYPE=FILE field - this is because
        * we'll be freeing buffers that contain file info when we're done
        * writing them and don't want to free the buffer that contains
        * the field name
        */
       if (context->req_header == (EwsRequestHeaderIndex)ewsFormDataHeaderContentDisposition)
         {
           ewsParseFormDataFieldName( context );
         }

       /* only leave this state on \r || \n */

       if (match_c == '\r')
         {
           context->substate.form = ewsContextSubstateMPHeaderHaveCR;
         }
       else if (match_c == '\n')
         {
           context->substate.form = ewsContextSubstateMPHeaderHaveNL;
         }
       return TRUE;
     }


   /******************************************************************
    * We've just parsed the header for a file input field.  At this
    * point, we open the file and set the field in the form structure
    * Note that this routine can suspend!!
    ******************************************************************/

   case ewsContextSubstateMPOpenFile:
     {
       ewsFormSubmitSet( context, &context->form_name, NULL);

       /* return now if aborting or suspended */

       if (   context->abort_flags & EWS_CONTEXT_FLAGS_ABORT
#           ifdef EW_CONFIG_OPTION_SCHED_SUSP_RES
           || context->schedulingState == ewsContextSuspended
#           endif  /* EW_CONFIG_OPTION_SCHED_SUSP_RES */
          )
         {
           return FALSE;
         }

       /* ensure not resuming */

#       ifdef EW_CONFIG_OPTION_SCHED_SUSP_RES
       context->schedulingState = ewsContextScheduled;
#       endif  /* EW_CONFIG_OPTION_SCHED_SUSP_RES */

       /*
        * on sucessful set of field, start sending data to file
        * on the way to finding the boundary.
        */

       context->substate.form = ewsContextSubstateMPFindBoundary;
       return TRUE;
     }

   /***********************************************************************
    * UNKNOWN STATE!
    ***********************************************************************/

   default:
#   ifdef EMWEB_SANITY
     EMWEB_ERROR(("ewsParseFormData: bad state\n"));
     ewsNetHTTPAbort( context );
#   endif/* EMWEB_SANITY */
     return FALSE;

   }       /* end switch( substate ) */


 /*
  * The only reason that we would fall out of the switch statement
  * would be that we've run out of data to parse.  If we are done
  * parsing the form (formDataEnd == TRUE), then we're done and can
  * submit the form.  Otherwise, this is a bad submission and will
  * be ignored.
  */

# if (EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1) \
 && defined( EW_CONFIG_OPTION_CHUNKED_IN)
 /*
  * form_expectp may be zero if at the end of a chunk.  Attempt
  * to process the next chunk.  If form_expectp is NOT zero,
  * which it will be if we are looking for a boundary string, and that
  * boundary string spans a chunk, then we have to squirrel away the point
  * in the data stream where we stopped searching, and set the req_str_end
  * to be the end of the current chunk (because ewsParseChunk expects the
  * req_str_end to point to the end of the current chunk in order to work).
  * We restore this "left over" data when we are re-called, so we'll restart
  * parsing where we left off!
  */
 if (*context->form_chunkedp)      /* if chunks remain */
   {
     if (context->form_expectp && *context->form_expectp != 0)
       {
         /* store the current position of form_parsep
          * and the # of bytes unparsed.  Then fast-forward
          * form_parsep to the end of the chunk
          */
         file->leftOverChunk = *context->form_parsep;
         file->leftOverData = *context->form_expectp;
         *context->form_expectp = 0;
         ewsStringLengthSet( context->form_parsep, file->leftOverData );
         ewsStringTrim( context->form_parsep, file->leftOverData );
       }
     return ewsParseChunk(context);
   }
 else
# endif  /* EW_CONFIG_HTTP_PROTOCOL >= HTTP_1_1 */

   if (file->formDataEnd)      /* end of data boundary seen */
     {
       /*
        * only leave this parsing state if we are totally out of
        * data.  If there is outstanding data (*form_expectp != 0)
        * then wait for more...
        */
       if (   context->form_expectp == NULL
           || *context->form_expectp == 0
          )
         {
           context->state = ewsContextStateSubmittingForm;
           context->schedulingState = ewsContextScheduled;
           ewsServeSubmitForm(context);
           return FALSE;
         }
       else
         {
           /* fall through to ewsContextDataWait setup */
         }
     }
   else if (context->form_expectp)
     {
       /* note: we run out of data under three conditions:
        * 1) remaining bytes of data is zero
        * 2) searching for boundary with less than boundary length
        * 3) searching for trailing '--' with less than 2 bytes
        *    this third case added for [ASI Support #3083].
        */
       uintf len;
       if (file->boundaryMatch)
         {
           len = 2;
         }
       else
         {
           EMWEB_STRLEN(len, file->formDataBoundary);
         }
       if (*context->form_expectp < len)
         {
           EWS_PARSE_ERROR(context, EWS_LOG_STATUS_BAD_FORM);
           return FALSE;     /* aborted */
         }
     }

 context->schedulingState = ewsContextDataWait;
 return FALSE;
}


/**********************************************************************
 * ewsParseFormDataFieldName
 *
 * Do any processing associated with the Content-Disposition header,
 * which is represented by the context->req_str_begin string.
 * We look in the Content-Disposition: header to find the name
 * of the field.  For INPUT fields of type TYPE=FILE, we must save the
 * the buffer that contains the field name, because we'll be freeing
 * all buffers after each file write and we don't want to free the buffer
 * that contains the field name.
 *
 * This function will set the inputFile->form_name, formFile, fieldIsFile
 * fields in the context block.
 */
static void
ewsParseFormDataFieldName( EwsContext context )
{
 ewsParseAttributeFromHeader( &(context->
                                inputFile->
                                formDataHeaders[ewsFormDataHeaderContentDisposition])
                             ,(char *)"name"
                             ,&context->form_name
                             ,ewsParseValue
                             ,';'
                             ,ewsHdrUpdateNo);

 if (ewsStringLength( &context->form_name ) != 0)
   {
     /* attribute found, and value is not null */

     EwsString tmp = context->form_name;

     /* context->form_name now holds value for name= attribute
      * if the first char of the name is ".", then
      * it's a file field, otherwise,
      * it's a regular old input field.
      */
     if (ewsStringGetChar(&tmp) == '.')
       {
         context->inputFile->fieldIsFile = TRUE;
         context->form_name = tmp;
       }
   }
}

#endif /* EW_CONFIG_OPTION_FIELDTYPE_FILE */


#ifdef EW_CONFIG_OPTION_COOKIES

/*
 *    ewsParseCookies
 *
 *      This functions parses further the Cookie header. It looks for
 *      all name=value instances and copies cookie's name and its value
 *      to EwsCookie structure. context for the request points to the list
 *      of all cookie structures parsed so far (NOTE: if there should be
 *      multiple Cookie header with the request, thats OK, this function
 *      will just keep appending structures).
 *      EwsCookies are link in order they appeared in the header, so
 *      the first one is first and the last one is last.
 *      EwsCookie structures are dynamically allocated and of various sizes
 *      depending on the name and value length.
 *
 */

void ewsParseCookies (EwsContext context)
{
 EwsString name_str, value_str;
 EwsString hdr_str;
 EwsCookieP cookieP;

 if (&context->req_headerp[ewsRequestHeaderCookie] == NULL)
   return;
 hdr_str = context->req_headerp[ewsRequestHeaderCookie];

 while (hdr_str.length)
   {
                               /* get name = value pairs               */
     if (ewsParseAttributeFromHeader( &hdr_str
                                     ,&name_str
                                     ,&value_str
                                     ,ewsParsePair
                                     ,';'
                                     ,ewsHdrUpdateYes))
       {
                               /* allocate memory for cookie           */
         cookieP = (EwsCookieP)ewaAlloc(sizeof(EwsCookie) +
                                        name_str.length + 1 +
                                        value_str.length + 1);
         if (cookieP == (EwsCookieP)NULL)
           {
             EMWEB_WARN(("ewsParseCookies: no resources for new cookie\n"));
             (void) ewsNetHTTPAbort(context);
             return;
           }
                               /* copy name and value                  */
        cookieP->nameP = (char *)cookieP + sizeof(EwsCookie);
        ewsStringCopyOut(cookieP->nameP, &name_str, name_str.length + 1);
        cookieP->valueP = (char *)cookieP + sizeof(EwsCookie) + name_str.length + 1;
        ewsStringCopyOut(cookieP->valueP, &value_str, value_str.length + 1);
                               /* and link cookie in                   */
        if (context->cookie_list_first == (EwsCookieP)NULL)
          context->cookie_list_first = cookieP;
        if (context->cookie_list_last == (EwsCookieP)NULL)
          context->cookie_list_last = cookieP;
        else
          context->cookie_list_last->next = cookieP;
        cookieP->next = (EwsCookieP)NULL;
        context->cookie_list_last = cookieP;
       }
     else
       break;
   }
}

#endif /* EW_CONFIG_OPTION_COOKIES */

#if defined (EW_CONFIG_OPTION_COOKIES) \
   || defined (EW_CONFIG_OPTION_FIELDTYPE_FILE) \
   || defined (EW_CONFIG_OPTION_AUTH_DIGEST) \
   || defined (EW_CONFIG_OPTION_CLIENT) \
   || defined (EW_CONFIG_OPTION_PERSISTENT)
/**********************************************************************
 *
 *  ewsParseAttributeFromHeader
 *
 *  Purpose: Search a header for a first attribute=value pair
 *           or for matching attribute
 *
 *  Inputs: header - address of emweb string containing the header that
 *              will be searched.
 *          attribute - address of emweb string to contain attribute found
 *              or pointer to the attribute name to match
 *          value - address of emweb string to contain the value of the
 *              attribute found.
 *          function - this defines the function to be performed:
 *              ewsParseValue - for specified attribute, find and return value
 *              ewsParsePair - find first name=value pair in the header and
 *                      return both
 *          c - character separating name=value pairs
 *          hdrUpdate - this specifies what is to be done with the header
 *              uppon completion:
 *              ewsHdrUpdateYes - advance header to the next character
 *                      after 'value;'
 *              ewsHdrUpdateNo - leave header unchanged
 *
 *
 *
 *  Outputs:    header(conditional) - if to be changed:
 *                      advanced to the next attribute in the header,
 *                      If no pair found, header is unchaged.
 *                      If end of header reached, length of header
 *                      is 0;
 *              attribute(conditional) - if not a match function:
 *                      set to attribute
 *              value - set to value
 *
 *  Returns: TRUE if attribute found (param may be zero len!), FALSE if
 *              attribute not found.
 *
 */
boolean
ewsParseAttributeFromHeader( EwsString *header
                    ,void *attribute
                    ,EwsString *value
                    ,EwsParseAttHdr function
                    ,char c
                    ,EwsHdrUpdate hdrUpdate )
{
 uintf     match_c;
 uint32    len;
 EwsString tmp1,tmp2;
 EwsString att_tmp;
 char term_c[6];
 char eqterm_c[7];
 char separator[2];

 EMWEB_STRCPY(term_c, "? \t\r\n");
 EMWEB_STRCPY(eqterm_c, "? \t\r\n=");
 term_c[0] = c;
 eqterm_c[0] = c;
 /* bugfix: 910 - make c a STRING */
 separator[0] = c;
 separator[1] = '\0';


 len = ewsStringLength( header );
 tmp1 = tmp2 = *header;

 while (len)
   {
     /* Initialize value to empty string in case no match found */
     *value = tmp1;
     ewsStringLengthSet(value, 0);

     /* first, skip any whitespace or ; to the first token */

     if (ewsStringSearch( &tmp1
                         ,&tmp2
                         ,term_c
                         ,ewsStringSearchExclude        /* skip ws + ; */
                         ,&len) == EWS_STRING_EOF)
       break;

     /* bound the current token in tmp1 */

     tmp1 = tmp2;
     ewsStringLengthSet( &tmp1, 0 );

     ewsStringSearch( &tmp1
                     ,&tmp2
                     ,eqterm_c               /* first token */
                     ,ewsStringSearchInclude
                     ,&len );
     if (ewsStringLength(&tmp1) == 0)
       {
         break;
       }

     /* now save token as attribute name */

     att_tmp = tmp1;

     /* verify that the next nonspace is an = */

     match_c = ewsStringSearch( &tmp1
                               ,&tmp2
                               ,(char *)" \t\r\n"
                               ,ewsStringSearchExclude
                               ,&len);

     switch (function) {
       case ewsParseValue:
         if (!ewsStringCompare( &tmp1
                               ,(char *)attribute
                               ,ewsStringCompareCaseInsensitive
                               ,NULL))
           break;
                               /* fall through if match                */
       case ewsParsePair:
         if (match_c == '=')
           {
             /* good, now skip the = and any trailing ws */

             if ((match_c = ewsStringSearch( &tmp1
                                            ,&tmp2
                                            ,(char *)" \t\r\n="
                                            ,ewsStringSearchExclude
                                            ,&len))
                 == EWS_STRING_EOF)
               break;


             /* if next char is quote, parse to close quote */
             if (match_c == '"')
               {
                 (void) ewsStringGetChar( &tmp2 ); /* skip quote */
                 len--;
                 *value = tmp2;
                 ewsStringLengthSet( value, 0 );
                 if (ewsStringSearch( value
                                     ,&tmp2
                                     ,(char *)"\""
                                     ,ewsStringSearchInclude
                                     ,&len) == EWS_STRING_EOF)
                   {
                     break;
                   }
               }
             else
               {
                 *value = tmp2;
                 ewsStringLengthSet( value, 0 );
                 ewsStringSearch( value
                                 ,&tmp2
                                 ,term_c
                                 ,ewsStringSearchInclude
                                 ,&len);

               }

           }
         if (function == ewsParsePair)
           {
             *(EwsString *)attribute = att_tmp;
           }
         if (hdrUpdate == ewsHdrUpdateYes)
           {
             if (len)
               {
                 (void)ewsStringGetChar(&tmp2); /* skip token unless end */
               }
             *header = tmp2;
           }
         return TRUE;

       default:
         return(FALSE);              /* unrecognized function asked for */
       }

     /*
      * attribute not matched, skip tmp2 to the next separator
      */

     ewsStringSearch( &tmp1, &tmp2, separator, ewsStringSearchInclude, &len );
   }
 return FALSE;
}
#endif /* EW_CONFIG_OPTION_COOKIES || EW_CONFIG_OPTION_FIELDTYPE_FILE
         || EW_CONFIG_OPTION_AUTH_DIGEST || EW_CONFIG_OPTION_CLIENT
         || EW_CONFIG_OPTION_PERSISTENT */


#ifdef EW_CONFIG_OPTION_CONTENT_NEGOTIATION
/*
 * ewsParseNegotiateHdr
 *
 * Builds a list of negotiate directives from the Negotiate: request header
 * and attaches list to request context at context->negotiate_hdr_first. Any
 * negotiate extensions are saved whole (as token=token) and are marked
 * as extensions in the boolean 'extn' field.
 *
 * Input: request context
 *
 * Output: linked list of negotiate directives attached to context
 *
 * Return: no return value
 *
 * from the HTTP/1.1 spec:
 *
 * Negotiate = "Negotiate" ":" 1#negotiate-directive
 *
 * negotiate-directive = "trans"
 *                     | "vlist"
 *                     | "guess-small"
 *                     | rvsa-version
 *                     | "*"
 *                     | negotiate-extension
 *
 * negotiate-extension = token [ "=" token ]
 *
 * examples: Negotiate: 1.0, 2.5
 *           Negotiate: *
 *           Negotiate: trans, foo=bar
 *
 */
void
ewsParseNegotiateHdr( EwsContext context)
{
 EwsNegotiateHdrDataP  neg_hdr;
 uintf                 match_c;
 EwsString             estring, tmp_estring;
# ifdef EMWEB_SANITY
 EwsNegotiateHdrDataP  p;
# endif /* EMWEB_SANITY */

 EMWEB_TRACE(("ewsParseNegotiateHdr(%p)\n", context));

 estring = tmp_estring = context->req_headerp[ewsRequestHeaderNegotiate];

 for (;;)
   {
     neg_hdr = NULL;

     /*
      * Skip LWS
      */
     match_c = ewsStringSearch(&estring
                              ,&tmp_estring
                              ,(char *)" \t\r\n"
                              ,ewsStringSearchExclude
                              ,NULL);
     if (match_c == EWS_STRING_EOF)
       {
         break;
       }

     /*
      * Look for a directive
      */
     estring = tmp_estring;
     ewsStringLengthSet(&estring, 0);
     match_c = ewsStringSearch(&estring
                              ,&tmp_estring
                              ,(char *)",\r\n"
                              ,ewsStringSearchInclude
                              ,NULL);

     if (match_c == EWS_STRING_EOF)
       {
         break;
       }

     if (estring.length > 0)
       {
         neg_hdr = (EwsNegotiateHdrData *)
                                         ewaAlloc(sizeof(EwsNegotiateHdrData));
         neg_hdr->extn = FALSE;

         if (neg_hdr == NULL)
           {
             EMWEB_WARN(("ewsParseNegotiateHdr: no resources for Negotiate:"
                         " header\n"));
             (void) ewsNetHTTPAbort(context);
             return;
           }

         neg_hdr->directive = (char *)ewaAlloc(estring.length + 1);
         if (neg_hdr->directive == NULL)
           {
             EMWEB_WARN(("ewsParseNegotiateHdr: no resources for Negotiate:"
                         " header directive\n"));
             (void) ewsNetHTTPAbort(context);
             return;
           }
         ewsStringCopyOut(neg_hdr->directive, &estring, estring.length);

         if (EMWEB_STRCHR(neg_hdr->directive, '='))
           neg_hdr->extn = TRUE;
         else
           neg_hdr->extn = FALSE;

         neg_hdr->next = NULL;

         /* save directive */
         if (!context->negotiate_hdr_first)
           {
             context->negotiate_hdr_first = neg_hdr;
             context->negotiate_hdr_last = neg_hdr;
           }
         else
           {
             context->negotiate_hdr_last->next = neg_hdr;
             context->negotiate_hdr_last = neg_hdr;
           }
         ewsStringGetChar( &tmp_estring);
       }
     if ( (match_c == '\r') || (match_c == '\n') )
       break;
   }
#ifdef EMWEB_SANITY

   p = context->negotiate_hdr_first;
   while (p)
     {
       EMWEB_TRACE(("ews_tcn: Found negotiate directive [%s] extension [%d]\n",
              p->directive, p->extn));
       p = p->next;
     }
#endif /* EMWEB_SANITY */
}
#endif /* EW_CONFIG_OPTION_CONTENT_NEGOTIATION */

#ifdef EW_CONFIG_OPTION_CONTENT_NEGOTIATION

/*
 * ewsParseAcceptHdr
 *
 * This is a generic routine that can parse any of the Accept headers
 * (Accept, Accept-Charset, Accept-Language, Accept-Encoding).
 * It builds a list of accept directives from the Accept* request header
 * passed in as 'estring' and attaches the list to the list pointer passed
 * in as 'first'. Any accept extensions are discarded but the boolean 'extn'
 * field is marked TRUE to flag an extension was received.
 *
 * Input: request context
 *        estring containing accept header contents
 *        first and last linked list pointers
 *
 * Output: linked list of accept directives attached to 'first'
 *
 * Return: no return value
 *
 */
void
ewsParseAcceptHdr( EwsContext context,
                  EwsString estring,
                  EwsAcceptHdrData **first,
                  EwsAcceptHdrData **last )
{
 EwsAcceptHdrDataP    acc_hdr;
 uintf                match_c;
 EwsString            tmp_estring;
 boolean              HAVE_DATA = FALSE;
 char                 *tmp_str;
# ifdef EMWEB_SANITY
 EwsAcceptHdrDataP    p;
# endif /* EMWEB_SANITY */

 EMWEB_TRACE(("ewsParseAcceptHdr(%p)\n", context));

 acc_hdr = NULL;
 tmp_estring = estring;

 for (;;)
   {
     /*
      * Skip LWS
      */
     match_c = ewsStringSearch(&estring
                              ,&tmp_estring
                              ,(char *)" \t\r\n"
                              ,ewsStringSearchExclude
                              ,NULL);
     if (match_c == EWS_STRING_EOF)
       {
         break;
       }

     /*
      *
      */
     estring = tmp_estring;
     ewsStringLengthSet(&estring, 0);
     match_c = ewsStringSearch(&estring
                              ,&tmp_estring
                              ,(char *)",;\r\n"
                              ,ewsStringSearchInclude
                              ,NULL);

     if (match_c == EWS_STRING_EOF)
       {
         break;
       }

     if (estring.length > 0)
       {
         if (!HAVE_DATA)   /* save it */
           {
             acc_hdr = (EwsAcceptHdrData *) ewaAlloc(sizeof(EwsAcceptHdrData));
             acc_hdr->extn = FALSE;
             acc_hdr->qual = NULL;
             acc_hdr->next = NULL;

             if (acc_hdr == NULL)
               {
                 EMWEB_WARN(("ewsParseAcceptHdr: no resources for Accept:"
                             " header\n"));
                 (void) ewsNetHTTPAbort(context);
                 return;
               }

             acc_hdr->data = (char *)ewaAlloc(estring.length + 1);
             if (acc_hdr->data == NULL)
               {
                 EMWEB_WARN(("ewsParseAcceptHdr: no resources for Accept:"
                             " header data\n"));
                 (void) ewsNetHTTPAbort(context);
                 return;
               }
             ewsStringCopyOut(acc_hdr->data, &estring, estring.length);

             if (EMWEB_STRCHR(acc_hdr->data, '=') )
               {
                 /* received an accept-extension without a preceding media-range.
                  * ie: Accept: foo=bar
                  */
                 ewaFree(acc_hdr->data);
                 ewaFree(acc_hdr);
                 break;
               }

             ewsStringGetChar( &tmp_estring);
             HAVE_DATA = TRUE;
           }
         else
           {
             tmp_str = (char *)ewaAlloc(estring.length + 1);
             ewsStringCopyOut(tmp_str, &estring, estring.length);
             ewsStringGetChar( &tmp_estring); /* eat match_c */

             /* if it's the quality value, save it */
             if ((tmp_str[0] == 'q') && (!acc_hdr->qual))
               {                            /* save the first quality value */
                 acc_hdr->qual = tmp_str;   /* if rcv multiples, dump extras */
               }
             else   /* mark that we received an extension but don't save it */
               {
                 acc_hdr->extn = TRUE;
                 ewaFree (tmp_str);
               }
            }
       }
     else
       {
         ewsStringGetChar( &tmp_estring);
       }

     if ( (estring.length > 0) && ( (match_c == ',')  ||
                                    (match_c == '\r') ||
                                    (match_c == '\n') ) )
       {
         /* hook this on to the list */
         if (!*first)
           {
             *first = *last = acc_hdr;
           }
         else
           {
             (**last).next = acc_hdr;
             *last = acc_hdr;
           }
         HAVE_DATA = FALSE;
       }
     if ( (match_c == '\r') ||
          (match_c == '\n') ||
          (match_c == '\n') )
       break;
   }

#ifdef EMWEB_SANITY

   p = *first;
   while (p)
     {
       EMWEB_TRACE(("ews_tcn: Found Accept data [%s], quality [%s],"
                    " extension [%d]\n", p->data, p->qual, p->extn));
       p = p->next;
     }
#endif /* EMWEB_SANITY */

}

#endif /* EW_CONFIG_OPTION_CONTENT_NEGOTIATION */


#ifdef EW_CONFIG_OPTION_FORM_REPEAT
/*
 * ewCheckPrefix
 *
 * This functions parses string of format:
 *
 *   #.#.#.name
 *
 * into the EwsRptName structure.
 *
 * input:    name - EwsString ptr to the name to be parsed
 *           rpt  - ponter to the repeat name structure where
 *                  the parsed values are placed
 * return:   TRUE - if this is prefixed name
 *           FALSE - other name
 *
 * Note: if TRUE returned, the original name string is advanced to the 'name'
 */

boolean ewCheckPrefix(EwsStringP name, EwsRptName *rpt)
{
 EwsString save = *name;

 if (ewsStringGetInteger(name, 10, &rpt->number) == TRUE)
   {
     if (ewsStringGetChar(name) == '.')
       {
         if (ewsStringGetInteger(name, 10, &rpt->iteration) == TRUE)
           {
             if (ewsStringGetChar(name) == '.')
               {
                 if (ewsStringGetInteger(name, 10, &rpt->total_cnt) == TRUE)
                   {
                     if (ewsStringGetChar(name) == '.')
                       {
                         return(TRUE);
                       }
                   }
               }
           }
       }
   }
 *name = save;
 return(FALSE);
}
#endif /* EW_CONFIG_OPTION_FORM_REPEAT */

#ifdef EMWEB_TRACE_PARSE

/* Pointer to output buffer */
static char *emwebTraceParseOutputBuffer = NULL;
/* Length of output buffer */
static int emwebTraceParseOutputBufferLength = 0;
/* Characters currently in output buffer */
static int emwebTraceParseOutputBufferUsed;

/* Append some characters to emwebTraceParseOutputBuffer. */
static void emwebTraceParseAppendToString(char *);

/* Return a printable representation of a string.
 *
 * string - points to the beginning of the string
 * respect_length - TRUE if dumping is to be limited to the substring
 *      specified by the .length field
 * chars - approximate maximum total number of characters to put in the output
 *      representation
 *
 * Returns a pointer to a static buffer in which a printable string-literal
 * representation of the string is written.  If we run out of space (via
 * 'chars' argument), close the string-literal and append '...'.
 */
static const char *
emwebTraceParseQuoteString( EwsString string
                           ,int respect_length
                           ,int chars
                           )
{
  int reached_end;

  /* Clear the output buffer. */
  if (emwebTraceParseOutputBuffer != NULL)
    {
      emwebTraceParseOutputBuffer[0] = '\0';
      emwebTraceParseOutputBufferUsed = 0;
    }

  /* Insert initial ". */
  emwebTraceParseAppendToString("\"");
  /* Decrement 'chars' to account for the boilerplate (" "...). */
  chars -= 5;
  reached_end = 0;
  /* Use 'chars' to count down the number of characters requested but not yet
   * printed. */
  while (chars > 0 && (!respect_length || string.length > 0))
    {
      uintf c;
      char b[10];

      /* Since the argument 'string' is an EwsString, and not a pointer to one,
       * calling ewsStringGetChar modifies our copy of it, not our caller's. */
      c = ewsStringGetChar(&string);
      /* Exit the loop if we've reached the end of the string. */
      if (EWS_STRING_EOF == c)
        {
          reached_end = 1;
          break;
        }
      /* Represent the character correctly. */
      if (c == '"')
        {
          emwebTraceParseAppendToString("\\\"");
          chars -= 2;
        }
      else if (c >= ' ' && c <= '~')
        {
          b[0] = c;
          b[1] = '\0';
          emwebTraceParseAppendToString(b);
          chars -= 1;
        }
      else if (c >= 7 && c <= 13)
        {
          b[0] = '\\';
          b[1] = "abtnvfr"[c-7];
          b[2] = '\0';
          emwebTraceParseAppendToString(b);
          chars -= 2;
        }
      else
        {
          b[0] = '\\';
          b[1] = 'x';
          b[2] = "0123456789abcdef"[(c >> 4) & 15];
          b[3] = "0123456789abcdef"[c & 15];
          b[4] = '\0';
          emwebTraceParseAppendToString(b);
          chars -= 4;
        }
    }
  emwebTraceParseAppendToString(reached_end ||
                                (respect_length && string.length <= 0) ?
                                "\"" :
                                "\"...");

  /* Return the output buffer. */
  return emwebTraceParseOutputBuffer;
}

/* Append some characters to emwebTraceParseOutputBuffer. */
static
void emwebTraceParseAppendToString( const char *s )
{
  int l;

  EMWEB_STRLEN(l, s);

  /* Enlarge the buffer if the text won't fit. */
  while (emwebTraceParseOutputBufferUsed + l + 1 >
         emwebTraceParseOutputBufferLength)
  {
    int new_length = (emwebTraceParseOutputBufferLength + 1) * 2;
    if (emwebTraceParseOutputBuffer == NULL) {
      emwebTraceParseOutputBuffer = ewaAlloc(new_length);
    } else {
      char *tmp = (char *) ewaAlloc(new_length);
      EMWEB_STRCPY(tmp, emwebTraceParseOutputBuffer);
      ewaFree(emwebTraceParseOutputBuffer);
      emwebTraceParseOutputBuffer = tmp;
    }
    if (emwebTraceParseOutputBuffer == NULL) {
      EMWEB_ERROR(("emwebTraceParseQuoteString: realloc() returned NULL while attempting to allocate %d bytes for emwebTraceParseOutputBuffer\n", new_length));
    }
    if (emwebTraceParseOutputBufferLength == 0) {
      emwebTraceParseOutputBuffer[0] = '\0';
    }
  }

  /* Concatenate the string to the buffer. */
  EMWEB_STRCPY(emwebTraceParseOutputBuffer+emwebTraceParseOutputBufferUsed, s);
  emwebTraceParseOutputBufferUsed += l;
}
#endif /* EMWEB_TRACE_PARSE */
