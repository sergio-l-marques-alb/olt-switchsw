/*
 *
 * Product: EmWeb
 * Release: R6_2_0
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION OF VIRATA CORPORATION
 * THE EMWEB SOFTWARE ARCHITECTURE IS PATENTED (US PATENT #5,973,696)
 * AND OTHER US AND INTERNATIONAL PATENTS PENDING.
 * 'EMWEB' AND 'EMSTACK' ARE TRADEMARKS OF VIRATA CORPORATION
 * 
 * Notice to Users of this Software Product:
 * 
 * This software product of Virata Corporation ("Virata"), 5 Clock Tower
 * Place, Suite 400, Maynard, MA  01754 (e-mail: info@virata.com) in 
 * source and object code format embodies valuable intellectual property 
 * including trade secrets, copyrights and patents which are the exclusive
 * proprietary property of Virata. Access, use, reproduction, modification
 * disclsoure and distribution are expressly prohibited unless authorized
 * in writing by Virata.  Under no circumstances may you copy this
 * software or distribute it to anyone else by any means whatsoever except in
 * strict accordance with a license agreement between Virata and your
 * company.  This software is also protected under patent, trademark and 
 * copyright laws of the United States and foreign countries, as well as 
 * under the license agreement, against any unauthorized copying, modification,
 * or distribution.
 * Please see your supervisor or manager regarding any questions that you may
 * have about your right to use this software product.  Thank you for your
 * cooperation.
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Virata Corporation
 * All Rights Reserved
 * 
 * Virata Corporation
 * 5 Clock Tower Place
 * Suite 400
 * Maynard, MA  01754
 * 
 * Voice: +1 (978) 461-0888
 * Fax:   +1 (978) 461-2080
 * 
 * http://www.emweb.com/
 *   support@agranat.com
 *     sales@agranat.com
 *
 * EmWeb/Server document management internals
 *
 */

#include "ews.h"
#include "ews_sys.h"
#include "ews_serv.h"
#include "ew_lib.h"
#include "ews_xml.h"

/******************************************************************************
 * ARCHIVE MAINTENANCE
 *
 * The EmWeb/Compiler generates an archive of one or more documents.  Documents
 * can be HTML files, JAVA programs, graphical images, or any other information
 * resource addressable by a URL.  Archives may be independently loaded or
 * unloaded into the EmWeb/Server.
 *
 * In most applications, the entire set of available documents would be
 * compiled into a single archive and loaded at boot time.  However, some
 * applications may desire to dynamically load archives at run-time as needed
 * in order to reduce memory requirements.  In fact, some applications may
 * want to implement a scheme similar to page swapping under some operating
 * systems to cache an active set of documents in memory while storing other
 * documents in a secondary storage area.  Such a secondary storage area
 * could be in FLASH memory, or on a remote server using TFTP or other
 * protocols to load documents at run-time.
 *
 * An EmWeb archive consists of two components.  First, there is the archive
 * data component containing the database of compressed documents, information
 * about how to construct dynamic documents at run-time, access controls,
 * etc.  Second, there is the archive object component containing the run-time
 * object code used for the construction of dynamic documents, etc.
 *
 * Operating systems supporting the run-time loading and linking of object
 * code may offload both the data and object archive components to a secondary
 * storage area.  Otherwise, only the data components would be offloaded
 * while the object components would be statically linked into the run-time
 * executable image.
 *
 * Each archive contains an archive descriptor in the object component.  The
 * archive descriptor is referenced by a public symbol generated by the
 * EmWeb/Compiler.  In order to activate an archive at run-time, the
 * application must invoke ewsDocumentInstallArchive() with parameters
 * indicating the address of the data component and the archive descriptor of
 * the object component.  The archive may be deactivated by invoking
 * ewsDocumentRemoveArchive().
 *
 *****************************************************************************/

/* ================================================================
 * Static Function Declarations
 * ================================================================ */

/* ================================================================
 * External Interfaces
 * ================================================================ */


/*
 * ewsDocumentInstallArchive
 *
 * Install a document archive generated by EmWeb/Compiler into EmWeb/Server
 * run-time database.
 *
 * descriptor   - public symbol of archive object component descriptor
 * datap        - pointer to archive data component
 *
 * Returns EWS_STATUS_OK on success, else error code (TBD)
 */
EwsStatus
ewsDocumentInstallArchive ( EwsArchive descriptor, EwsArchiveData datap )
{
  const EwsArchiveHeader *ahp = (const EwsArchiveHeader *) datap;
  const EwsDocumentHeader *dhp;
  EwsDocument document;
  const char *url;
  uint32 offset;
  uintf hash;
# ifdef EW_CONFIG_OPTION_LOAD
  boolean derivedLoad = FALSE;
# endif
# ifdef EW_CONFIG_OPTION_DEMAND_LOADING
  EwsContext context;
# endif /* EW_CONFIG_OPTION_DEMAND_LOADING */
#ifdef EMWEB_SANITY
  boolean bvalue;
  const uint8 *code_offset;
# endif /* EMWEB_SANITY */

# if defined( EW_CONFIG_SCHEMA_ARCHIVE )
  const EwsDocumentHeader  *schema_document = NULL;
  const EwsDocumentNode    *schema_nodes = NULL;
# endif /* schema processing */

    EMWEB_TRACE(("ewsDocumentInstallArchive(%p, %p)\n", descriptor, datap));

#   ifdef EMWEB_SANITY
    /*
     * Verify magic numbers
     */
    if (descriptor->magic != EW_ARCHIVE_OBJECT_MAGIC)
      {
        EMWEB_WARN(("ewsDocumentInstallArchive: bad archive object magic\n"));
        return EWS_STATUS_BAD_MAGIC;
      }

    if (EW_BYTES_TO_UINT32(ahp->magic) != EW_ARCHIVE_DATA_MAGIC)
      {
        EMWEB_WARN(("ewsDocumentInstallArchive: bad archive data magic\n"));
        return EWS_STATUS_BAD_MAGIC;
      }

    /*
     * Verify versions.  Certainly, the version number in the object part
     * should match the version number in the data part.  The major numbers
     * should match with the EmWeb/Server.  We assume that if the major number
     * changed, we don't know how to read it.
     */
    if (descriptor->version_maj != EW_ARCHIVE_VERSION_MAJ ||
        ahp->version_maj != EW_ARCHIVE_VERSION_MAJ ||
        descriptor->version_min != ahp->version_min)
      {
        EMWEB_WARN(("ewsDocumentInstallArchive: bad version\n"));
        return EWS_STATUS_BAD_VERSION;
      }

    /* Verify backward compatibility. If Server is not configured
     * to support old archive, and  we have old archive, we also
     * have a problem
     */

#   ifndef EW_CONFIG_OPTION_SUPPORT_ARCH1_0
    if ((ahp->version_maj == 1) && (ahp->version_min == 0))
      {
        EMWEB_WARN(("ewsDocumentInstallArchive: no support for old archives\n"));
        return EWS_STATUS_BAD_VERSION;
      }
#   endif /* EW_CONFIG_OPTION_SUPPORT_ARCH1.0 */

    /*
     * Verify object and data components have the same code creation date.
     * Just warn the application, but install anyway as the data part
     * might be dynamically loaded from a source while object components
     * may have been linked in. Note that the code creation date of the
     * archive is no longer necessarily the same as the last modified.
     *
     * 1.0 and 1.1 archives use date_1123_offset to verify code/data match.
     * 1.2 archives use new code_date_1123_offset
     */
    if ((ahp->version_maj == 1) && (ahp->version_min < 2))
      {
        code_offset = ahp->date_1123_offset;
      }
    else
      {
        code_offset = ahp->code_date_1123_offset;
      }
    EMWEB_STRCMP ( bvalue
                  ,descriptor->date_1123
                  ,&datap[EW_BYTES_TO_UINT32(code_offset)]
                 );
    if (bvalue)
      {
        EMWEB_WARN(("Warning: date mismatch in archive components\n"));
      }
#   endif /* EMWEB_SANITY */

    /*
     * Verify that the document list is empty.  Otherwise, the archive is
     * already loaded.
     */
    if (descriptor->document_list != EWS_DOCUMENT_NULL)
      {
#       ifdef EW_CONFIG_OPTION_LOAD
        derivedLoad = TRUE;
#       endif

#       ifdef EMWEB_SANITY
        EMWEB_WARN(("ewsDocumentInstallArchive: adding to installed archive\n"
                    "  (this may be ok if this is a derived archive)\n"));
#       endif /* EMWEB_SANITY */
      }

    EMWEB_TRACE((" loading %s - %s\n",
      (const char *) &datap[EW_BYTES_TO_UINT32(ahp->name_offset)],
      (const char *) &datap[EW_BYTES_TO_UINT32(ahp->date_1123_offset)]));

#   if defined( EW_CONFIG_SCHEMA_ARCHIVE )
    /*
     * Spin through all docs once looking for the namespace schema.  Need
     * to cache this before we load other documents
     */
    offset = EW_BYTES_TO_UINT32(ahp->doc_offset);

    EWA_TASK_LOCK();
    while (offset != 0)
      {
        /*
         * Get document's URL
         */
        dhp = (const EwsDocumentHeader *) &datap[offset];

        if ((dhp->document_type & EW_ARCHIVE_DOC_TYPE_MASK)
            == EW_ARCHIVE_DOC_TYPE_SCHEMA
           )
          {
#           ifdef EMWEB_SANITY
            if (schema_nodes != NULL)
              {
                EMWEB_ERROR(("ewsDocumentInstallArchive: INTERNAL ERROR - mulitple schema docs!\n"));
                return EWS_STATUS_FATAL_ERROR;
              }
#           endif   /* EMWEB_SANITY */
            schema_document = dhp;
            schema_nodes = (const EwsDocumentNode *)
              &datap[EW_BYTES_TO_UINT32(dhp->node_offset)];

#           ifdef EW_CONFIG_OPTION_NS_LOOKUP
            /*
             * Initialize schema lookup table
             */
            {
              EwsStatus status = ewsSchemaInit( descriptor
                                               ,datap
                                               ,schema_document
                                               ,schema_nodes
                                              );
              if (status != EWS_STATUS_OK)
                  {
                    return status;
                  }
            }
#           endif /* EW_CONFIG_OPTION_NS_LOOKUP */

            break;  /* note: only one allowed!! */
          }

        offset = EW_BYTES_TO_UINT32(dhp->next_offset);
      }
    EWA_TASK_UNLOCK();

#   endif  /* schema data */

    /*
     * Follow linked list of document headers to insert individual documents
     * into filesystem hash database.
     */
    offset = EW_BYTES_TO_UINT32(ahp->doc_offset);

    EWA_TASK_LOCK();

    while (offset != 0)
      {

        /*
         * Get document's URL and look-up in filesystem
         */
        dhp = (const EwsDocumentHeader *) &datap[offset];

        /*
         * Only install documents that are not schemas
         * This will have to be changed when we want direct access to
         * schemas through a lookup, but they will need unique URLs for
         * that - right now if you have a schema in each of two archives
         * you would get a collision here when you install them.
         */
        if ((dhp->document_type & EW_ARCHIVE_DOC_TYPE_MASK)
            != EW_ARCHIVE_DOC_TYPE_SCHEMA
            )
          {
            url = (const char *) &datap[EW_BYTES_TO_UINT32(dhp->url_offset)];
            hash = ewsFileHash(url);
            document = ewsFileHashLookup(hash, url);

        /*
         * If document is already in the filesystem, it must be a registered
         * and unloaded document.  In this case, we simply mark the document
         * as loaded.
         */
            if (document != EWS_DOCUMENT_NULL)
              {

#           ifdef EMWEB_SANITY
                if (((document->flags & EWS_FILE_FLAG_REGISTERED) == 0) ||
                    ((document->flags & EWS_FILE_FLAG_LOADED) != 0))
                  {
                    EWA_TASK_UNLOCK();
                    EMWEB_ERROR(("ewsDocumentInstallArchive: collision (%s)\n", url));

#               ifdef EW_CONFIG_OPTION_CLEANUP
                    ewsDocumentRemoveArchive(descriptor);
#               endif /* EW_CONFIG_OPTION_CLEANUP */

                    return EWS_STATUS_IN_USE;
                  }
#           endif /* EMWEB_SANITY */

                document->flags |= EWS_FILE_FLAG_LOADED;
              }

            /*
         * Otherwise, create a new document node in the filesystem
         * representing the archive document
         */
            else
              {
                document = ewsFileHashInsert(hash);
                if (document == EWS_DOCUMENT_NULL)
                  {
                    EWA_TASK_UNLOCK();
                    EMWEB_ERROR(("ewsDocumentInstallArchive: no resources\n"));

#               ifdef EW_CONFIG_OPTION_CLEANUP
                    ewsDocumentRemoveArchive(descriptor);
#               endif /* EW_CONFIG_OPTION_CLEANUP */

                    return EWS_STATUS_NO_RESOURCES;
                  }
                document->flags = EWS_FILE_FLAG_LOADED;
                document->url = url;
                document->doc_handle = EWA_DOCUMENT_HANDLE_NULL;

#           ifdef EW_CONFIG_OPTION_DEMAND_LOADING
                EWS_LINK_INIT(&document->fault_list);
#           endif /*EW_CONFIG_OPTION_DEMAND_LOADING */

#           ifdef EW_CONFIG_OPTION_CLONING
                document->clone_count = 0;
#           endif /* EW_CONFIG_OPTION_CLONING */

              }

            /*
         * Initialize the document
         */
            document->next_archive = descriptor->document_list;
            descriptor->document_list = document;
            document->archive = descriptor;
            document->archive_data = datap;
            document->doc_header = dhp;
#           if defined( EW_CONFIG_SCHEMA_ARCHIVE )
            document->schema_document = schema_document;
            document->schema_nodes = schema_nodes;
#           endif /* schema */

#       ifdef EW_CONFIG_OPTION_AUTH
            /*
         * Register document's realm
         */
            offset = EW_BYTES_TO_UINT32(dhp->realm_offset);
            if (offset != 0)
              {
                document->realmp = ewsAuthRealmGet((const char *)&datap[offset]);
                if (document->realmp == (EwsRealmP) NULL)
                  {
                    EMWEB_ERROR(("ewsDocumentInstallArchive: no resources\n"));
#               ifdef EW_CONFIG_OPTION_CLEANUP
                    ewsDocumentRemoveArchive(descriptor);
#               endif /* EW_CONFIG_OPTION_CLEANUP */
                    return EWS_STATUS_NO_RESOURCES;
                  }
              }
            else
              {
                document->realmp = (EwsRealmP) NULL;
              }
#       endif /* EW_CONFIG_OPTION_AUTH */

#       ifdef EW_CONFIG_OPTION_DEMAND_LOADING
            /*
         * Schedule any requests waiting for document load
         */
            while (&document->fault_list != document->fault_list.next)
              {
                context = (EwsContext) document->fault_list.next;
                context->state = ewsContextStateServeSetup;
                context->substate.setup = ewsContextServeSetupBegin;
                EWS_LINK_DELETE(&context->link);
                /*
                 * If scheduling is being used, link context into
                 * serv_list and process it during ewsRun().
                 * If no scheduling, then process it now, just like
                 * in ewsNetHTTPReceive()
                 */
#           ifdef EW_CONFIG_OPTION_SCHED
                context->document = document;
                EWS_LINK_INSERT(&ews_state->context_serve_list, &context->link);
#           else  /* not EW_CONFIG_OPTION_SCHED */
                context->current = TRUE;
                EWA_TASK_UNLOCK();
                ewsServeSetup(context, document);
                EWA_TASK_LOCK();
                context->current = FALSE;
                if (context->abort_flags & EWS_CONTEXT_FLAGS_ABORT)
                  {
                    EWA_TASK_UNLOCK();
                    ewsInternalAbort(context);
                    EWA_TASK_LOCK();
                  }
#           endif /* not EW_CONFIG_OPTION_SCHED */
              }
#       endif /* EW_CONFIG_OPTION_DEMAND_LOADING */
          }
        /*
         * Next document in archive
         */
        offset = EW_BYTES_TO_UINT32(dhp->next_offset);
          }

    EWA_TASK_UNLOCK();

#   ifdef EW_CONFIG_OPTION_LOAD
    {
      if (   ! derivedLoad
          && ( NULL != descriptor->emweb_load )
          )
        {
          boolean done = FALSE;

          descriptor->emweb_load(&done);

#         ifdef EMWEB_SANITY
          if (done != TRUE)
            {
              EMWEB_ERROR(("ewsDocumentInstallArchive: invalid return in <emweb_load> code block\n"));
              return EWS_STATUS_FATAL_ERROR;
            }
#         endif /* EMWEB_SANITY */
        }
    }
#   endif /* EW_CONFIG_OPTION_LOAD */

#   ifdef EW_CONFIG_OPTION_XMLP
    /*
     * Register XMLP consumers
     */
    {
      uintf i;
      EmWebXmlpTableP tp = &descriptor->emweb_xmlp_table[1];

      for (i = 1; i <= descriptor->emweb_xmlp_table_size; i++, tp++)
        {
          tp->consumer
            = xmlpRegisterConsumer(*tp->events
                                  ,*tp->defaultWhitespaceHandlingPolicy
                                  ,*tp->attributeWhitespaceHandlingPolicy
                                  ,*tp->namespaceHandlingPolicy
                                  ,(const char **) tp->namespaces
                                  ,*tp->implicitNamespace
                                  ,tp->pfXmlpConsumerStart
                                  ,tp->pfXmlpConsumerEvent
                                  ,tp->pfXmlpConsumerEnd
                                  ,tp->pfXmlpConsumerAbort
                                  );
        }
    }
#   endif /* EW_CONFIG_OPTION_XMLP */

    return EWS_STATUS_OK;
}

#ifdef EW_CONFIG_OPTION_CLEANUP

/*
 * ewsDocumentRemoveArchive
 *
 * Removes previously installed document archive from run-time database.
 *
 * descriptor   - public symbol of archive object component descriptor
 *
 * Returns EWS_STATUS_OK on success, else error code (TBD)
 */
EwsStatus
ewsDocumentRemoveArchive ( EwsArchive descriptor )
{
  EwsDocument document;

    EMWEB_TRACE(("ewsDocumentRemoveArchive(%p)\n", descriptor));

    EWA_TASK_LOCK();

    /*
     * Check reference count to make sure no documents in the archive are
     * presently in use.
     */
    if (descriptor->reference_count != 0)
      {
        EWA_TASK_UNLOCK();
        EMWEB_TRACE((" in use\n"));
        return EWS_STATUS_IN_USE;
      }

#   ifdef EW_CONFIG_OPTION_UNLOAD
    {
      if (descriptor->emweb_unload != NULL)
        {
          boolean done = FALSE;

          descriptor->reference_count++;
          EWA_TASK_UNLOCK();
          (*descriptor->emweb_unload) (&done);
          EWA_TASK_LOCK();
          descriptor->reference_count--;

#         ifdef EMWEB_SANITY
          if (done != TRUE)
            {
              EMWEB_ERROR(("ewsDocumentRemoveArchive: invalid return in <emweb_unload> code block\n"));
              return EWS_STATUS_FATAL_ERROR;
            }
#         endif /* EMWEB_SANITY */
        }
    }
#   endif /* EW_CONFIG_OPTION_UNLOAD */

#   ifdef EW_CONFIG_OPTION_XMLP
    /*
     * Unregister XMLP consumers
     */
    {
      uintf i;
      EmWebXmlpTableP tp = &descriptor->emweb_xmlp_table[1];

      for (i = 1; i <= descriptor->emweb_xmlp_table_size; i++, tp++)
        {
          xmlpUnregisterConsumer((XmlpConsumer) tp->consumer);
        }
    }
#   endif /* EW_CONFIG_OPTION_XMLP */

    /*
     * Follow the list of document nodes
     */
    while (descriptor->document_list != EWS_DOCUMENT_NULL)
      {
        document = descriptor->document_list;
        descriptor->document_list = document->next_archive;

        /*
         * If the node was a registered document, then simply clear loaded
         * flag.
         */
        if ((document->flags & EWS_FILE_FLAG_REGISTERED) != 0)
          {
            document->flags &= ~EWS_FILE_FLAG_LOADED;
          }

        /*
         * Otherwise, delete the document node
         */
        else
          {
            ewsFileHashDelete(document);
          }
      }

#   ifdef EW_CONFIG_OPTION_NS_LOOKUP
    /*
     * Cleanup schema lookup table
     */
    ewsSchemaShutdown( descriptor );
#   endif /* EW_CONFIG_OPTION_NS_LOOKUP */

    EWA_TASK_UNLOCK();

    return EWS_STATUS_OK;
}

/*
 * ewsDocumentRemoveDataArchive
 *
 * Removes previously installed data (derived) archive from run-time database.
 *
 * datap   - address of data archive component
 *
 * Returns EWS_STATUS_OK on success, else error code (TBD)
 */
EwsStatus
ewsDocumentRemoveDataArchive ( const uint8 *datap )
{
  const EwsArchiveHeader *ahp = (const EwsArchiveHeader *) datap;
  const EwsDocumentHeader *dhp;
  EwsDocument document;
  const char *url;
  uint32 offset;
  uintf hash;

    offset = EW_BYTES_TO_UINT32(ahp->doc_offset);

    EWA_TASK_LOCK();

    while (offset != 0)
      {
        /*
         * Get document's URL and look-up in filesystem
         */
        dhp = (const EwsDocumentHeader *) &datap[offset];
        url = (const char *) &datap[EW_BYTES_TO_UINT32(dhp->url_offset)];
        hash = ewsFileHash(url);
        document = ewsFileHashLookup(hash, url);

        /*
         * If the node was a registered document, then simply clear loaded
         * flag.
         */
        if ((document->flags & EWS_FILE_FLAG_REGISTERED) != 0)
          {
            document->flags &= ~EWS_FILE_FLAG_LOADED;
          }

        /*
         * Otherwise, delete the document node
         */
        else
          {
            /*
             * If document to be deleted is at head of master archive document
             * list, delete from list.
             */
            if (document->archive->document_list == document)
              {
                document->archive->document_list = document->next_archive;
              }
            document->archive->reference_count--;
            ewsFileHashDelete(document);
          }

        /*
         * Next document in archive
         */
        offset = EW_BYTES_TO_UINT32(dhp->next_offset);
      }

    EWA_TASK_UNLOCK();

    return EWS_STATUS_OK;
}

#endif /* EW_CONFIG_OPTION_CLEANUP */

/*
 * ewsDocumentArchiveName
 *
 * Returns the archive name as stored in the archive by the EmWeb/Compiler,
 * or NULL on error.
 */
const char *
ewsDocumentArchiveName ( const uint8 *datap )
{
  const EwsArchiveHeader *ahp = (const EwsArchiveHeader *) datap;
  uint32 offset;
  const char * name;

    offset = EW_BYTES_TO_UINT32(ahp->name_offset);
    if (offset == 0)
      {
        name = NULL;
      }
    else
      {
        name = (const char *) &datap[offset];
      }
    return name;
}

/*
 * ewsDocumentArchiveDate
 *
 * Returns the RFC1123 date string stroed in the archive header generated
 * by the EmWeb/Compiler when the archive was created, or NULL on error.
 */
const char *
ewsDocumentArchiveDate ( const uint8 *datap )
{
  const EwsArchiveHeader *ahp = (const EwsArchiveHeader *) datap;
  uint32 offset;
  const char *date;

    offset = EW_BYTES_TO_UINT32(ahp->date_1123_offset);
    if (offset == 0)
      {
        date = NULL;
      }
    else
      {
        date = (const char *) &datap[offset];
      }
    return date;
}

/*
 * ewsDocumentArchiveDate1036
 *
 * Returns the RFC1036 date string stroed in the archive header generated
 * by the EmWeb/Compiler when the archive was created, or NULL on error.
 * (This is not the preferred representation - RFC1123 is.  However, many
 *  browsers still expect this, so we implement both).
 */
const char *
ewsDocumentArchiveDate1036 ( const uint8 *datap )
{
  const EwsArchiveHeader *ahp = (const EwsArchiveHeader *) datap;
  uint32 offset;
  const char *date;

    offset = EW_BYTES_TO_UINT32(ahp->date_1036_offset);
    if (offset == 0)
      {
        date = NULL;
      }
    else
      {
        date = (const char *) &datap[offset];
      }
    return date;
}

#ifdef EW_CONFIG_OPTION_DEMAND_LOADING

/******************************************************************************
 *
 * DEMAND LOADING
 *
 * In order to implement on-demand archive loading, the application may
 * register document URLs with the EmWeb/Server which are valid but not
 * loaded.  This is done by invoking ewsDocumentRegister().  If a registered
 * document is requested, the EmWeb/Server will notify the application by
 * invoking ewaDocumentFault().  At this point, the application may load
 * a new archive (possibly removing a previously installed archive to make
 * room).  When the archive containing the page is installed, the EmWeb/Server
 * will automatically complete processing the request.  The request can be
 * aborted either immediately by returning EWA_STATUS_ERROR from the
 * ewaDocumentFault() function, or by invoking ewsNetHTTPAbort().
 *
 * Once a document is registered, there is no need to re-register it in the
 * event that the corresponding archive is removed.  EmWeb/Server remembers
 * that the document has been registered as dynamically loadable.  However,
 * the application may deregister a document by invoking
 * ewsDocumentDeregister().
 *
 *****************************************************************************/

/*
 * ewsDocumentRegister
 * Registers the URL of a document with the run-time database indicating that
 * the given document is valid but not currently loaded into memory.
 *
 * url          - local URL of document to be registered
 * handle       - application-specific handle passed to ewaDocumentFault()
 *
 * Returns document descriptor, or EWS_DOCUMENT_NULL on failure.
 */
EwsDocument
ewsDocumentRegister ( const char * url, EwaDocumentHandle handle )
{
  uintf hash;
  EwsDocument document;
  uintf len;

    EMWEB_TRACE(("ewsDocumentRegister(%s, %p)\n", url, handle));

    /*
     * Create a new document node in the hashed file system
     */
    hash = ewsFileHash(url);

    EWA_TASK_LOCK();

#   ifdef EMWEB_SANITY
    if (ewsFileHashLookup(hash, url) != EWS_DOCUMENT_NULL)
      {
        EMWEB_WARN(("ewsDocumentRegister: exists\n"));
        return EWS_DOCUMENT_NULL;
      }
#   endif /* EMWEB_SANITY */

    document = ewsFileHashInsert(hash);
    if (document == EWS_DOCUMENT_NULL)
      {
        EMWEB_WARN(("ewsDocumentRegister: no resources\n"));
        return EWS_DOCUMENT_NULL;
      }

    /*
     * Allocate string space for the new URL name
     */
    EMWEB_STRLEN(len, url);
    document->url = (char *) ewaAlloc(len + 1);
    if (document->url == NULL)
      {
        EMWEB_WARN(("ewsDocumentRegister: no resources\n"));
        ewsFileHashDelete(document);
        return EWS_DOCUMENT_NULL;
      }

    /*
     * Initialize registered document node
     */
    EMWEB_STRCPY(document->url, url);
    document->flags = EWS_FILE_FLAG_REGISTERED;
    document->doc_handle = handle;
    EWS_LINK_INIT(&document->fault_list);

#   ifdef EW_CONFIG_OPTION_CLONING
    document->clone_count = 0;
#   endif /* EW_CONFIG_OPTION_CLONING */

    EWA_TASK_UNLOCK();

    return document;
}

/*
 * ewsDocumentDeregister
 * Unregisters a previously registered document from the run-time database
 * indicating that the given dynamically-loadable document is no longer valid.
 *
 * document     - descriptor of document to be deregistered
 *
 * Returns EWS_STATUS_OK on success, else error code (TBD).
 */
EwsStatus
ewsDocumentDeregister ( EwsDocument document )
{
    EMWEB_TRACE(("ewsDocumentDeregister(%p)\n", document));

    EWA_TASK_LOCK();

    /*
     * Document must have been previously registered and not presently
     * loaded.
     */
    if ((document->flags & EWS_FILE_FLAG_REGISTERED) == 0
        || (document->flags & EWS_FILE_FLAG_LOADED) != 0

#       ifdef EW_CONFIG_OPTION_CLONING
        || document->clone_count != 0
#       endif /* EW_CONFIG_OPTION_CLONING */

       )
      {
        EWA_TASK_UNLOCK();
        EMWEB_WARN(("ewsDocumentDeregister: in use or bad state\n"));
        return EWS_STATUS_IN_USE;
      }

    /*
     * Remove the document from the filesystem
     */
    ewaFree((void *)document->url);
    ewsFileHashDelete(document);

    EWA_TASK_UNLOCK();

    return EWS_STATUS_OK;
}

#endif /* EW_CONFIG_OPTION_DEMAND_LOADING */

#ifdef EW_CONFIG_OPTION_CLONING

/******************************************************************************
 *
 * DOCUMENT CLONING
 *
 * Documents may be cloned and assigned to a new URL.  This allows multiple
 * instances of a document to exist.  An application-specific handle can be
 * used to identify an instance of a document from the request context.
 *
 * The application clones a document by invoking ewsDocumentClone().  The
 * cloned document may be removed by invoking ewsDocumentRemove().  All
 * clones created from documents in an archive must be removed before the
 * archive can be removed.
 *
 *****************************************************************************/

/*
 * ewsDocumentClone
 * Clone an existing document under a new URL in the database.
 *
 * baseurl      - URL of existing document
 * newurl       - URL of new cloned document
 * handle       - application-specific handle available in request context
 *
 * Returns document descriptor or EWS_DOCUMENT_NULL on error.
 */
EwsDocument
ewsDocumentClone ( const char * baseurl, const char * newurl, EwaDocumentHandle handle )
{
  EwsDocument basedoc;
  EwsDocument newdoc;
  uintf hash;
  uintf len;

    EMWEB_TRACE(("ewsDocumentClone(%s, %s, %p)\n", baseurl, newurl, handle));

    EWA_TASK_LOCK();

    /*
     * Lookup base document
     */
    hash = ewsFileHash(baseurl);
    basedoc = ewsFileHashLookup(hash, baseurl);

#   ifdef EMWEB_SANITY
    if (basedoc == EWS_DOCUMENT_NULL)
      {
        EWA_TASK_UNLOCK();
        EMWEB_WARN(("ewsDocumentClone: not found\n"));
        return EWS_DOCUMENT_NULL;
      }
#   endif /* EMWEB_SANITY */

#   ifdef EMWEB_SANITY
    /*
     * Can't clone clones
     */
    if ((basedoc->flags & EWS_FILE_FLAG_CLONE) != 0)
      {
        EWA_TASK_UNLOCK();
        EMWEB_WARN(("ewsDocumentClone: can't clone a clone\n"));
        return EWS_DOCUMENT_NULL;
      }
#   endif /* EMWEB_SANITY */

    /*
     * Verify that new URL isn't already present
     */
    hash = ewsFileHash(newurl);

#   ifdef EMWEB_SANITY
    newdoc = ewsFileHashLookup(hash, newurl);
    if (newdoc != EWS_DOCUMENT_NULL)
      {
        EWA_TASK_UNLOCK();
        EMWEB_WARN(("ewsDocumentClone: exists\n"));
        return EWS_DOCUMENT_NULL;
      }
#   endif /* EMWEB_SANITY */

    /*
     * Create clone
     */
    newdoc = ewsFileHashInsert(hash);
    if (newdoc == EWS_DOCUMENT_NULL)
      {
        EWA_TASK_UNLOCK();
        EMWEB_WARN(("ewsDocumentClone: resources\n"));
        return EWS_DOCUMENT_NULL;
      }
    EMWEB_STRLEN(len, newurl);
    newdoc->url = (char *) ewaAlloc(len + 1);
    if (newdoc->url == NULL)
      {
        ewsFileHashDelete(newdoc);
        EWA_TASK_UNLOCK();
        EMWEB_WARN(("ewsDocumentClone: resources\n"));
        return EWS_DOCUMENT_NULL;
      }

    /*
     * Initialize clone state
     */
    EMWEB_STRCPY(newdoc->url, newurl);
    newdoc->clone_base = basedoc;
    newdoc->clone_count = 0;
    newdoc->flags = EWS_FILE_FLAG_CLONE;
    newdoc->doc_handle = handle;
    newdoc->archive = basedoc->archive;
    newdoc->archive_data = basedoc->archive_data;
    newdoc->doc_header = basedoc->doc_header;

#   ifdef EW_CONFIG_OPTION_AUTH
    newdoc->realmp = basedoc->realmp;
#   endif /* EW_CONFIG_OPTION_AUTH */

#   ifdef EW_CONFIG_OPTION_DEMAND_LOADING
    EWS_LINK_INIT(&newdoc->fault_list);
#   endif

#   ifdef EW_CONFIG_SCHEMA_ARCHIVE
    newdoc->schema_nodes = basedoc->schema_nodes;
    newdoc->schema_document = basedoc->schema_document;
#   endif /* EW_CONFIG_SCHEMA_ARCHIVE */

    /*
     * Increment the base document reference count.  If the document is loaded
     * and not registered, increment the archive use count as well.  (We don't
     * do this for registered documents because the registered documents will
     * not be deleted when the archive is removed).
     */
    basedoc->clone_count++;
    if (((basedoc->flags & EWS_FILE_FLAG_LOADED) != 0)
        && ((basedoc->flags & EWS_FILE_FLAG_REGISTERED) == 0))
      {
        basedoc->archive->reference_count++;
      }

    EWA_TASK_UNLOCK();

    return newdoc;
}

/*
 * ewsDocumentRemove
 * Remove a previously cloned document from the database.
 *
 * document     - document descriptor of previously cloned document.
 *
 * Returns EWS_STATUS_OK on success, else error code (TBD).
 */
EwsStatus
ewsDocumentRemove ( EwsDocument document )
{
    EMWEB_TRACE(("ewsDocumentRemove(%p)\n", document));

#   ifdef EMWEB_SANITY
    /*
     * If this isn't a clone document, then we can't remove it.
     */
    if ((document->flags & EWS_FILE_FLAG_CLONE) == 0)
      {
        EMWEB_WARN(("ewsDocumentRemove: not clone\n"));
        return EWS_STATUS_NOT_CLONED;
      }
#   endif /* EMWEB_SANITY */

    EWA_TASK_LOCK();

    /*
     * If this document is cloned itself, then we can't remove it
     */
    if (document->clone_count != 0)
      {
        EMWEB_WARN(("ewsDocumentRemove: busy\n"));
        return EWS_STATUS_IN_USE;
      }

    /*
     * Decrement the base document clone count.  If the base document is
     * loaded and not registered, then decrement the archive reference count
     * as well.
     */
    document->clone_base->clone_count--;
    if (((document->clone_base->flags & EWS_FILE_FLAG_LOADED) != 0) &&
        ((document->clone_base->flags & EWS_FILE_FLAG_REGISTERED) == 0))
      {
        document->clone_base->archive->reference_count--;
      }

    ewaFree((void *)document->url);
    ewsFileHashDelete(document);

    EWA_TASK_UNLOCK();

    return EWS_STATUS_OK;
}
#endif /* EW_CONFIG_OPTION_CLONING */

#ifdef EW_CONFIG_OPTION_DOCUMENT_DATA
/*
 * ewsDocumentData
 * Retrieve pointer to raw data and data size from URL in archive
 *
 * url          - url of document
 * bytesp       - output: size of document (as-is in archive) in bytes
 * datapp       - output: pointer to start of document
 *
 * Returns EWS_STATUS_OK on success, else error code (TBD).
 */
EwsStatus
ewsDocumentData ( const char * url, uint32 *bytesp, const uint8 **datapp )
{
  EwsDocument document;
  uintf hash;

    /*
     * Lookup document
     */
    hash = ewsFileHash(url);
    document = ewsFileHashLookup(hash, url);

#   ifdef EMWEB_SANITY
    if (document == EWS_DOCUMENT_NULL ||
        (document->flags & EWS_FILE_FLAG_LOADED) == 0)
      {
        EMWEB_TRACE(("ewsDocumentData: not found or not loaded\n"));
        return EWS_STATUS_NOT_FOUND;
      }
#   endif /* EMWEB_SANITY */

    *bytesp = EW_BYTES_TO_UINT32(document->doc_header->data_length);
    *datapp = &document->archive_data
      [ EW_BYTES_TO_UINT32(document->doc_header->data_offset) ];
    return EWS_STATUS_OK;
}
#endif /* EW_CONFIG_OPTION_DOCUMENT_DATA */

#ifdef EW_CONFIG_OPTION_AUTH
#ifdef EW_CONFIG_OPTION_DOCUMENT_SET_REALM
/*
 * ewsDocumentSetRealm
 * Set or change authentication realm of document at run-time.
 *
 * url          - url of document
 * realm        - name of authentication realm, or NULL (or "") to disable.
 *
 * Returns EWS_STATUS_OK on success, else error code.
 */
EwsStatus
ewsDocumentSetRealm ( const char * url, const char *realm )
{
  EwsDocument document;
  uintf hash;
  EwsRealmP realmp;

    /*
     * Lookup document
     */
    hash = ewsFileHash(url);
    document = ewsFileHashLookup(hash, url);

#   ifdef EMWEB_SANITY
    if (document == EWS_DOCUMENT_NULL)
      {
        EMWEB_TRACE(("ewsDocumentSetRealm: not found or not loaded\n"));
        return EWS_STATUS_NOT_FOUND;
      }
#   endif /* EMWEB_SANITY */

    /*
     * If realm is specified, attempt to override existing realm
     */
    if (realm != NULL && *realm != '\0')
      {
        realmp = ewsAuthRealmGet(realm);
        if (realmp == NULL)
          {
            return EWS_STATUS_NO_RESOURCES;
          }
        document->realmp = realmp;
      }

    /*
     * Otherwise, remove protection from URL
     */
    else
      {
        document->realmp = (EwsRealmP) NULL;
      }

    return EWS_STATUS_OK;
}
#endif /* EW_CONFIG_OPTION_DOCUMENT_SET_REALM */
#endif /* EW_CONFIG_OPTION_AUTH */


/* ================================================================
 * Static Functions
 * ================================================================ */
