/********************************************************************
 *
 * (C) Copyright Broadcom Corporation 2003-2007
 *
 * *********************************************************************
 *
 * @filename           ospfmib.ext
 *
 * @purpose            external interface for OSPF MIB tables support
 *                     (according to RFC 1850)
 *
 * @component          Routing OSPF Component
 *
 * @comments
 *
 * @create             03/01/2000
 *
 * @author             Elena Korchemny
 *
 * @end
 *
 * ********************************************************************/


#ifndef _ospfmib_support_ext_
#define _ospfmib_support_ext_


/* "$Header: /home/cvs/PR1003/PR1003/FASTPATH/RELEASE_610_FP_6.1.0.5-FastPath-Ent-esw-xgs3-bmw-LR-CSxw-IQH/src/application/routing/protocol/ospf/ospfmib.ext,v 1.1 2011/04/18 18:52:05 mruas Exp $"; */

#include "std.h"
#include "l3_comm_structs.h"
#include "rfc1443.h"

#include "ospfmib.h"

/******************************
* OSPF MIB CallBack procedures
*******************************/
typedef struct t_ospfMibIfLowParams
{
   ulng           ifSpeed; 
   e_OspfPhyType  ifPhyType;
   word           ifMTUsize;

} t_ospfMibIfLowParams;


typedef struct t_ospfMibCallbacks
{
   /* The callback returns the low layer object     */
   /* handle for the interface specified by ifIndex */
   t_Handle (*f_Get_IfLowLayerId)(ulng ifIndex);

   /* The callback returns low layer parameters of the interface:  */
   /* speed (bandwidth in bits per second), type (Ethernet (1),    */
   /* frame relay(1) or ATM(2)), maximal MTU size                  */
   e_Err (*f_Get_IfParams)(ulng ifIndex, 
                          t_ospfMibIfLowParams *ifLowParams);

   /* The callback returns the interface mask                      */
   ulng (*f_Get_IfMask)(ulng ifIndex, ulng ifIpAddres);

   /* The callback returns ifIndex of an interface connecting  */
   /* to the specified host                                    */
   e_Err (*f_Get_HostRoute)(ulng HostIpAddres, t_LIH *ifIndex);

   /* The callback procedure used for indication of IFO object creation  */
   /* or deleting IFO object                                             */
   /* if0CreatDel is TRUE - interface has been  activated and IFO object */
   /* was created successfully, ifoCreatDel - FALSE, IFO object has been */
   /* deleted                                                            */
   e_Err (*f_ifoCreateDelInd)(t_Handle rtrMng, t_Handle rtrObj,
                             ulng ifIpAddr, ulng ifIndex,
                             Bool ifoCreatDel, t_Handle IfObj);

} t_ospfMibCallbacks;


/*****************************************************
 *  MACROs and procedures for OSPF MIB tables access
 *****************************************************/

/*--- Macros and access procedures for ospfAreaTable ----*/
#define OSPFAREA_AUTHTYPE(p)          ((ospfAreaEntry*)(p))->info.authType
#define OSPFAREA_IMPORTASEXT(p)       ((ospfAreaEntry*)(p))->info.importASExt
#define OSPFAREA_SUMMARY(p)           ((ospfAreaEntry*)(p))->info.areaSummary
#define OSPFAREA_ROWSTATUS(p)         ((ospfAreaEntry*)(p))->info.rowStatus
#define OSPFAREA_INTERNALLCREATED(p)  ((ospfAreaEntry*)(p))->info.internalCreated 

ulng OSPFAREA_AUTHSPFRUNS(t_Handle p); 
ulng OSPFAREA_BDRRTRCOUNT(t_Handle p);         
ulng OSPFAREA_LSACOUNT(t_Handle p);            
ulng OSPFAREA_LSACHKSUM(t_Handle p);           

/*--- Macros and access procedures for ospfStubAreaTable ----*/
#define OSPFSTUBAREA_TOS(p)             ((ospfStubAreaEntry*)(p))->ospfStubAreaTOS
#define OSPFSTUBAREA_METRIC(p)          ((ospfStubAreaEntry*)(p))->info.metric
#define OSPFSTUBAREA_ROWSTATUS(p)       ((ospfStubAreaEntry*)(p))->info.rowStatus
#define OSPFSTUBAREA_METRICTYPE(p)      ((ospfStubAreaEntry*)(p))->info.metricType

e_Err OSPFSTUBAREA_SETMETRIC(t_Handle ospfMibObj, t_Handle p, ulng metric);
e_Err OSPFSTUBAREA_SETMETRICTYPE(t_Handle ospfMibObj, t_Handle p,
                                 e_StubMetricType  metricType);


/*---- Macros and access procedures for ospfLsdbTable ----*/
/*ulng OSPFLSDB_SEQUENCE(t_Handle p); */
/*ulng OSPFLSDB_AGE(t_Handle p);      */
/*ulng OSPFLSDB_CHKSUM(t_Handle p);   */
/*byte *OSPFLSDB_ADVERTISEMENT(t_Handle p);*/

#define OSPFLSDB_SEQUENCE(p)      ((L7_ospfLsdbEntry_t *)(p))->LsdbSequence
#define OSPFLSDB_AGE(p)           ((L7_ospfLsdbEntry_t *)(p))->LsdbAge
#define OSPFLSDB_CHKSUM(p)        ((L7_ospfLsdbEntry_t *)(p))->LsdbChecksum
#define OSPFLSDB_ADVERT_LEN(p)    ((L7_ospfLsdbEntry_t *)(p))->LsdbAdvertLength
 
/*---- Macros and access procedures for ospfHostTable ----*/
#define OSPFHOST_METRIC(p)               ((ospfHostEntry*)(p))->info.metric
#define OSPFHOST_ROWSTATUS(p)            ((ospfHostEntry*)(p))->info.rowStatus
#define OSPFHOST_AREAID(p)               ((ospfHostEntry*)(p))->info.areaId

/*---- Macros and access procedures for ospfIfTable ----*/
#define OSPFIF_AREAID(p)                 ((ospfIfEntry*)(p))->info.areaId
#define OSPFIF_IFTYPE(p)                 ((ospfIfEntry*)(p))->info.ifType
#define OSPFIF_ADMINSTATUS(p)            ((ospfIfEntry*)(p))->info.adminStatus
#define OSPFIF_RTRPRIORITY(p)            ((ospfIfEntry*)(p))->info.rtrPriority
#define OSPFIF_TRANSITDELAY(p)           ((ospfIfEntry*)(p))->info.transitDelay
#define OSPFIF_RETRANSINTERVAL(p)        ((ospfIfEntry*)(p))->info.retransInterval
#define OSPFIF_HELLOINTERVAL(p)          ((ospfIfEntry*)(p))->info.helloInterval
#define OSPFIF_RTRDEADINTERVAL(p)        ((ospfIfEntry*)(p))->info.deadInterval
#define OSPFIF_POLLINTERVAL(p)           ((ospfIfEntry*)(p))->info.pollInterval
#define OSPFIF_AUTHTYPE(p)               ((ospfIfEntry*)(p))->info.authType
#define OSPFIF_AUTHKEY(p)                ((ospfIfEntry*)(p))->info.authKey
#define OSPFIF_ROWSTATUS(p)              ((ospfIfEntry*)(p))->info.rowStatus
#define OSPFIF_MTCASTFORWARDING(p)       ((ospfIfEntry*)(p))->info.mtCastForwarding
#define OSPFIF_DEMAND(p)                 ((ospfIfEntry*)(p))->info.demand

word OSPFIF_STATE(t_Handle p);
ulng OSPFIF_DESRTR(t_Handle p);
ulng OSPFIF_BACKUPDESRTR(t_Handle p);
ulng OSPFIF_EVENTS(t_Handle p);
e_Err OSPFIF_SETAUTHKEY(t_Handle p, byte *authKey, int keyLen);

/*---- Macros and access procedures for ospfIfMetricTable ----*/
#define OSPFIFMETRIC_VALUE(p)             ((ospfIfMetricEntry*)(p))->info.metricValue
#define OSPFIFMETRIC_ROWSTATUS(p)         ((ospfIfMetricEntry*)(p))->info.rowStatus

e_Err OSPFIFMETRIC_SETMETRIC(t_Handle ospfMibObj, t_Handle p, word metric);

/*---- Macros and access procedures for ospfVirtIfTable ----*/
#define OSPFVIRTIF_AREAID(p)                 ((ospfVirtIfEntry*)(p))->info.areaId
#define OSPFVIRTIF_NEIGHBOR(p)               ((ospfVirtIfEntry*)(p))->info.neighbor
#define OSPFVIRTIF_TRANSITDELAY(p)           ((ospfVirtIfEntry*)(p))->info.transitDelay
#define OSPFVIRTIF_RETRANSINTERVAL(p)        ((ospfVirtIfEntry*)(p))->info.retransInterval
#define OSPFVIRTIF_HELLOINTERVAL(p)          ((ospfVirtIfEntry*)(p))->info.helloInterval
#define OSPFVIRTIF_RTRDEADINTERVAL(p)        ((ospfVirtIfEntry*)(p))->info.deadInterval
#define OSPFVIRTIF_AUTHTYPE(p)               ((ospfVirtIfEntry*)(p))->info.authType
#define OSPFVIRTIF_AUTHKEY(p)                NULLP
#define OSPFVIRTIF_ROWSTATUS(p)              ((ospfVirtIfEntry*)(p))->info.rowStatus

word OSPFVIRTIF_STATE(t_Handle p);
ulng OSPFVIRTIF_EVENTS(t_Handle p);
e_Err OSPFVIRTIF_SETAUTHKEY(t_Handle p, byte *authKey, int keyLen);

/*---- Macros and access procedures for ospfNbrTable ----  
 *(macro OSPFNBR_PRIORITY is used for read/set operation for SNMP created
 * neighbor(i.e. permanent nbr); procedure OSPFNBR_GETPRIORITY is used 
 * only for get operation on any neighbor (both dynamic and permanent) */
#define OSPFNBR_RTRID(p)               ((ospfNbrEntry*)(p))->info.rtrId
#define OSPFNBR_PRIORITY(p)            ((ospfNbrEntry*)(p))->info.priority
#define OSPFNBR_ROWSTATUS(p)           ((ospfNbrEntry*)(p))->info.rowStatus
#define OSPFNBR_PERMANENCE(p)          ((ospfNbrEntry*)(p))->info.permanence
#define OSPFNBR_INTERNALLCREATED(p)    ((ospfNbrEntry*)(p))->info.internalCreated
#define OSPFNBR_OWNER(p)               ((ospfNbrEntry*)(p))->owner

word OSPFNBR_GETPRIORITY (t_Handle p);
word OSPFNBR_GETIFINDEX (t_Handle p);
ulng OSPFNBR_GETDEADTIMERREMAINING (t_Handle p);
ulng OSPFNBR_GETUPTIME(t_Handle p);
word OSPFNBR_GETAREA (t_Handle p);
ulng OSPFNBR_OPTIONS (t_Handle p);
word OSPFNBR_STATE(t_Handle p);
ulng OSPFNBR_EVENTS(t_Handle p);
ulng OSPFNBR_LSRETRANSQLEN(t_Handle p);
e_TruthValue OSPFNBR_HELLOSUPPRESSED(t_Handle p);

/*---- Macros and access procedures for ospfVirtNbrTable ----*/
ulng OSPFVIRTNBR_IPADDR(t_Handle p);
ulng OSPFVIRTNBR_OPTIONS(t_Handle p);
word OSPFVIRTNBR_STATE(t_Handle p);
ulng OSPFVIRTNBR_EVENTS(t_Handle p);
ulng OSPFVIRTNBR_LSRETRANSQLEN(t_Handle p);
e_TruthValue OSPFVIRTNBR_HELLOSUPPRESSED(t_Handle p);

/*---- Macros and access procedures for ospfExtLsdbTable ----*/
/* ulng OSPFEXTLSDB_SEQNO(t_Handle p);          */
/* ulng OSPFEXTLSDB_AGE(t_Handle p);            */
/* ulng OSPFEXTLSDB_CHKSUM(t_Handle p);         */
/* byte *OSPFEXTLSDB_ADVERTISEMENT(t_Handle p); */

#define OSPFEXTLSDB_SEQNO(p)         ((ospfExtLsdbEntry*)(p))->info.seqNo
#define OSPFEXTLSDB_AGE(p)           ((ospfExtLsdbEntry*)(p))->info.lsaAge
#define OSPFEXTLSDB_CHKSUM(p)        ((ospfExtLsdbEntry*)(p))->info.chkSum
#define OSPFEXTLSDB_ADVERTISEMENT(p) ((ospfExtLsdbEntry*)(p))->info.advertisement
#define OSPFEXTLSDB_ADVERT_LEN(p)    ((ospfExtLsdbEntry*)(p))->info.advertLength

/*---- Macros and access procedures for ospfAreaAggrTable ----*/
#define OSPFAREAAGGR_ROWSTATUS(p)       ((ospfAreaAggrEntry*)(p))->info.rowStatus
#define OSPFAREAAGGR_EFFECT(p)          ((ospfAreaAggrEntry*)(p))->info.effect

e_Err OSPFAREAAGGR_SETEFFECT(t_Handle ospfMibObj, t_Handle p,
                             e_ospfAreaAggrEffect effect);


/***************************************************
 * The ospfMIB object creation, deletion and set up routines.
 * Handle of the router and the router manager have
 * to be set by stack manager during start up 
 ***************************************************/

 /*********************************************************************
 * @purpose             Create new OSPF MIB object.
 *
 *
 * @param RTO_Obj       @b{(input)}  parent RTO object handler
 * @param rtrMng        @b{(input)}  router manager handler
 * @param p_ospfMibObj  @b{(input)}  t_Handle of the created OSPF
 *                                    MIB object
 *
 * @returns             E_OK       - success
 * @returns             E_BADPARM  - invalid parameter
 * @returns             E_NOMEMORY - can't allocate memory
 *
 * @notes
 *                    Create new OSPF MIB object.
 *   This object stores handles of all MIB tables defined in
 *   OSPF MIB. It has to be created before any ospfMib procedure
 *   is called to create/delete/read OSPF MIB information.
 *
 *   Store t_Handle of the the router object to ospfRouterObj
 *   and t_Handle of the router manager to ospfRouterMng .
 *   This procedure has to be called by stack manager during
 *   start up, when the RTO object is created.
 *
 * @end
 * ********************************************************************/
e_Err ospfCreateMibObj (t_Handle RTO_Obj, t_Handle rtrMng,
                               t_Handle  *p_ospfMibObj);


 /*********************************************************************
 * @purpose               Deletes OSPF MIB object.
 *
 *
 * @param  ospfMibObj     @b{(input)} t_Handle of the OSPF MIB object
 *
 * @returns               E_OK - success
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfDestroyMibObj (t_Handle ospfMibObj);


 /*********************************************************************
 * @purpose     Get the handle of the router object associated with the
 *              current MIB table, and a handle of its router manager.
 *
 *
 * @param ospfMibObj   @b{(input)}  t_Handle of the OSPF MIB object
 * @param rtrObj       @b{(output)}  the returned parent RTO object handler
 * @param rtrMng       @b{(output)}  the returned router manager handler
 *
 * @returns            E_OK      - success
 * @returns            E_BADPARM - invalid parameter
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetRouterObj(t_Handle ospfMibObj, t_Handle *rtrObj,
                       t_Handle *rtrMng);


 /*********************************************************************
 * @purpose     Binds user supplied procedures to ospfMibCallbacks
 *              structure. All these procedures are used in OSPF MIB
 *              support code.
 *
 *
 * @param       @b{(input)}  t_Handle of the OSPF MIB object
 * @param       @b{(input)}  structure that contains user-supplied
 *                           callback routines
 *
 * @returns     E_OK      - success
 * @returns     E_BADPARM - invalid parameter
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfSetMibCallbacks (t_Handle ospfMibObj,
                           t_ospfMibCallbacks *mibCallbacks);


/*******************************************************
 *  Procedures for access to the OSPF global variables
 *******************************************************/


 /*********************************************************************
 * @purpose               Sets the OSPF Router ID.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param rtrId           @b{(input)}  The OSPF router id (IP address)
 *
 * @returns               E_OK     - success
 * @returns               not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfSetRouterId(t_Handle ospfMibObj, ulng rtrId);


 /*********************************************************************
 * @purpose             Returns the OSPF Router IP address.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param rtrId         @b{(output)}  a handle to the returned OSPF router IP
 *                                   Address
 *
 * @returns             E_OK      - success
 * @returns             E_BADPARM - invalid parameter(s)
 * @returns             E_FAILED  - acion failed
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetRouterId(t_Handle ospfMibObj, ulng *rtrId);


 /*********************************************************************
 * @purpose     Sets the administrative status of OSPF process in the
 *              router.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param admStatus      @b{(input)}  the new value of admin. status
 *
 * @returns              E_OK     - success
 * @returns              not E_OK - failure
 *
 * @notes        The value "enabled" denotes that the OSPF Process
 *              is active on at least one interface; "disabled" disables
 *              it on all interfaces.
 *
 * @end
 * ********************************************************************/
e_Err ospfSetAdminStatus(t_Handle ospfMibObj, e_ospfAdminStatus admStatus);


 /*********************************************************************
 * @purpose             Returns the administrative status of the OSPF
 *                      router.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param admStatus      @b{(output)}  the returned admin. status
 *
 * @returns              E_OK     - success
 * @returns              not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetAdminStatus(t_Handle ospfMibObj, e_ospfAdminStatus *admStatus);


 /*********************************************************************
 * @purpose     Returns the current version number of the OSPF protocol.
 *
 *
 * @param       @b{(input)} n/a
 *
 * @returns     The OSPF protocol version number
 *
 * @notes
 *
 * @end
 * ********************************************************************/
int ospfGetVersionNumber(void);


 /*********************************************************************
 * @purpose     Returns value of the flag indicating whether this router
 *              is an area border router.
 *
 *
 * @param ospfMibObj   @b{(input)} t_Handle of the OSPF MIB object
 * @param flag         @b{(input)} the OSPF area border router flag value
 *
 * @returns            E_OK     - success
 * @returns            not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetAreaBrdRouterFlag(t_Handle ospfMibObj, e_TruthValue *flag);


 /*********************************************************************
 * @purpose          Sets value of the flag indicating whether this router
 *                   is configured as an Autonomous System border router.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param flag        @b{(input)}  the new flag value to be set (true
 *                                                           or false)
 *
 * @returns           E_OK     - success
 * @returns           not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfSetASBrdRouterFlag(t_Handle ospfMibObj, e_TruthValue flag);


 /*********************************************************************
 * @purpose     Returns value of the flag indicating whether this router
 *              is configured as an Autonomous System border router.
 *
 *
 * @param ospfMibObj   @b{(input)}  t_Handle of the OSPF MIB object
 * @param flag         @b{(input)}  the OSPF AS border router flag value
 *
 * @returns            E_OK     - success
 * @returns            not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetASBrdRouterFlag(t_Handle ospfMibObj, e_TruthValue *flag);


 /*********************************************************************
 * @purpose     Returns the number of external link-state advertisements
 *              in the link-state database.
 *
 *
 * @param ospfMibObj   @b{(input)}  t_Handle of the OSPF MIB object
 * @param count        @b{(input)}  the returned external LSA counter value
 *
 * @returns            E_OK     - success
 * @returns            not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetExternLsaCount(t_Handle ospfMibObj, ulng *count);


 /*********************************************************************
 * @purpose        Returns the sum of the LS checksums of the external
 *                 link-state advertisements contained in the link-state
 *                 database.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param cksumSum      @b{(output)}  returned value of external LSA
 *                                   checksums sum
 *
 * @returns             E_OK     - success
 * @returns             not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetExternLsaCksumSum(t_Handle ospfMibObj, ulng *cksumSum);


 /*********************************************************************
 * @purpose               Returns the router's support for type_of_service
 *                        routing.
 *
 *
 * @param ospfMibObj      @b{(input)} t_Handle of the OSPF MIB object
 * @param tosSupport      @b{(input)} TRUE when TOS routing is supported;
 *                                    FALSE when TOS routing is not supported.
 *
 * @returns               E_OK     - success
 * @returns               not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetTOSSupport(t_Handle ospfMibObj, e_TruthValue *tosSupport);


 /*********************************************************************
 * @purpose               Sets the router's support for type_of_service
 *                        routing.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param tosSupport      @b{(input)}  the new value of TOS support to
 *                                     be set
 *
 * @returns               E_OK     - success
 * @returns               not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfSetTOSSupport(t_Handle ospfMibObj, e_TruthValue tosSupport);


 /*********************************************************************
 * @purpose     Returns the number of the new link-state advertisements
 *              that have been originated.
 *
 *
 * @param ospfMibObj   @b{(input)}  t_Handle of the OSPF MIB object
 * @param count        @b{(output)}  the returned number of the new originated
 *                                  LSAs
 *
 * @returns            E_OK     - success
 * @returns            not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetOriginateNewLsas(t_Handle ospfMibObj, ulng *count);


 /*********************************************************************
 * @purpose     Returns the number of link-state advertisements received
 *              determined to be new instantiations.
 *
 *
 * @param ospfMibObj   @b{(input)}  t_Handle of the OSPF MIB object
 * @param count        @b{(output)}  the returned number of received LSAs
 *
 * @returns            E_OK     - success
 * @returns            not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetRxNewLsas(t_Handle ospfMibObj, ulng *count);


 /*********************************************************************
 * @purpose            Sets value of ospfExtLsdbLimit.
 *
 *
 * @param ospfMibObj   @b{(input)}  t_Handle of the OSPF MIB object
 * @param limit        @b{(input)}  the new value of the ospfExtLsdbLimit
 *
 * @returns            E_OK     - success
 * @returns            not E_OK - failure
 *
 * @notes
 *       "ospfExtLsdbLimit" is the maximum number of non_default
 * AS-external-LSAs entries that can be stored in the link_state
 * database. If the value is -1, then there is no limit.
 *
 * When the number of non_default AS-external-LSAs in the
 * router's link_state database reaches ospfExtLsdbLimit, the
 * router enters OverflowState.
 *
 * The router never holds more than ospfExtLsdbLimit non-default
 * AS-external-LSAs in its database.
 *
 * OspfExtLsdbLimit must be set identically in all routers attached
 * to the OSPF backbone and/or any regular OSPF area (i.e. OSPF stub
 * area and NSSAs are excluded).
 *
 * @end
 * ********************************************************************/
e_Err ospfSetExtLsdbLimit(t_Handle ospfMibObj, ulng limit);



 /*********************************************************************
 * @purpose        Returns the maximum number of non_default AS-external
 *                 -LSAs entries that can be stored in the link_state
 *                 database.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param limit          @b{(output)}  the returned limit
 *
 * @returns              E_OK     - success
 * @returns              not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetExtLsdbLimit(t_Handle ospfMibObj, ulng *limit);


 /*********************************************************************
 * @purpose                       Sets value of ospfExitOverflowInterval.
 *
 *
 * @param ospfMibObj              @b{(input)}  t_Handle of the OSPF MIB
 *                                             object
 * @param exitOverflowInterval    @b{(input)}  interval value to set
 *
 * @returns                       E_OK     - success
 * @returns                       not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfSetExitOverflowInterval(t_Handle ospfMibObj,
                                  ulng exitOverflowInterval);



 /*********************************************************************
 * @purpose                 Returns the ospfExitOverflowInterval value.
 *
 *
 * @param ospfMibObj        @b{(input)}  t_Handle of the OSPF MIB object
 * @param oflowInterval     @b{(output)}  the returned value of the
 *                                       ospfExitOverflowInterval
 *
 * @returns                 E_OK     - success
 * @returns                 not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetExitOverflowInterval(t_Handle ospfMibObj, ulng *oflowInterval);



 /*********************************************************************
 * @purpose              Sets value of ospfMulticastExtensions.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param multicastExt    @b{(input)}  multicast flag bitmap
 *
 * @returns  TRUE  - new multicast extension bits/flags have been set
 *                   successfully
 * @returns  FALSE - incorrect value were requested to set, value of
 *                   multicast extension bits/flags have't been reset.
 *
 * @notes
 *             "ospfMulticastExtensions" is a bitmask indicating whether the
 *  router is forwarding IP multicast datagrams based on the
 * algorithms defined in the Multicast Extensions to OSPF.
 *
 * Bit 0, if set, indicates that the router can forward IP multicast
 * datagrams in the router's directly attached areas (called
 * intra-area multicast routing).
 * Bit 1, if set, indicates that the router can forward IP multicast
 * datagrams between OSPF areas (called inter-area multicast routing).
 * Bit 2, if set, indicates that the router can forward IP multicast
 * datagrams between Autonomous Systems (called inter-AS multicast
 * routing).
 * Only certain combinations of bit  settings  are allowed,  namely:
 *      0  - no multicast forwarding is enabled,
 *      1  - intra-area multicasting  only,
 *      3  - intra-area  and  inter-area  multicasting,
 *      5  - intra-area and inter-AS  multicasting
 *      7  - multicasting  everywhere.
 *
 * By default, no multicast forwarding is enabled.
 *
 * @end
 * ********************************************************************/
Bool ospfSetMulticastExtensions(t_Handle ospfMibObj, ulng multicastExt);



 /*********************************************************************
 * @purpose               Returns the ospfMulticastExtensions value.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param multicastExt    @b{(input)}  multicast flag bitmap
 *
 * @returns               E_OK     - success
 * @returns               not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetMulticastExtensions (t_Handle ospfMibObj, ulng *multicastExt);



 /*********************************************************************
 * @purpose        Sets value of ospfDemandExtensions.
 *                 "ospfDemandExtensions" value indicates that the router
 *                 supports demand routing.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param demandExt      @b{(input)}  value of tag_TruthValue type (_true(1),
 *                                    _false(2))
 *
 * @returns              E_OK     - success
 * @returns              not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfSetDemandExtensions(t_Handle ospfMibObj, e_TruthValue demandExt);


 /*********************************************************************
 * @purpose               Returns value of ospfDemandExtensions.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param demandExt:      @b{(input)}  _true   - if the router supports
 *                                               demand routing
 *                                     _false  - if the router does not
 *                                               support demand routing
 *
 * @returns                E_OK     - success
 * @returns                not E_OK - failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfGetDemandExtensions(t_Handle ospfMibObj, e_TruthValue *demandExt);


/********************************************************
 *  MIB support procedures
 ********************************************************/

/********************************************************
 *   OSPF Area Table 
 ********************************************************/

 /*********************************************************************
 * @purpose           Create a new row in the ospf Area Table.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  The area identifier - IP address
 *
 * @returns           E_OK       - success
 * @returns           E_IN_MATCH - entry already exists
 * @returns           E_BADPARM  - invalid parameter
 * @returns           E_NOMEMORY - can't allocate memory
 *
 * @notes
 *          The procedure is called when the row is created by SNMP
 *          request (i.e. requested row status is CreateAndGo or
 *          CreateAndWait).
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaTable_New(t_Handle ospfMibObj, ulng areaId);


 /*********************************************************************
 * @purpose             Create a new row in the ospf Area Table and
 *                      activate it.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId        @b{(input)}  The area identifier - IP address
 * @param areaObj       @b{(input)}  Pointer to the area object
 *
 * @returns             E_OK       - success
 * @returns             E_IN_MATCH - entry already exists
 * @returns             E_BADPARM  - invalid parameter
 * @returns             E_NOMEMORY - can't allocate memory
 *
 * @notes
 *       The procedure is called from OSPF protocol code after
 *       a new area object is created.
 *       The new row parameters are set according to the area object
 *       parameters.
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaTable_InternalNewActive(t_Handle ospfMibObj, ulng areaId,
                                      t_Handle p_areaObj);


 /*********************************************************************
 * @purpose           Delete a row from the OSPF Area MIB Table
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  The area identifier - IP address
 *
 * @returns           E_OK     - Success
 * @returns           Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaTable_Delete(t_Handle ospfMibObj, ulng areaId);


 /*********************************************************************
 * @purpose     Delete a row from the OSPF Area MIB Table, and delete all
 *              host.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  The area identifier - IP address
 *
 * @returns           E_OK     - Success
 * @returns           Not E_OK - Failure
 *
 * @notes      area ranges and stub area metrics associalted with this area.
 *             This routine is to be called from OSPF protocol code only.
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaTable_DeleteInternal(t_Handle ospfMibObj, ulng areaId);



 /*********************************************************************
 * @purpose          Set OSPF area object handle into the entry of the
 *                   ospfAreaTable.
 *
 *
 * @param ospfMibObj  @b{(input)} t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)} The area identifier (index in ospf
 *                                                         AreaTable)
 * @param areObjId    @b{(input)} OSPF area handle
 *
 * @returns           E_OK     - Success
 * @returns           Not E_OK - Failure, look at std.h for details
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaTable_SetOwner (t_Handle ospfMibObj, ulng areaId,
                              t_Handle areaObj);


 /*********************************************************************
 * @purpose            Get OSPF area object handle from the entry in the
 *                     ospfAreaTable.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  The OSPF area identifier (IP address)
 *
 * @returns           OSPF area handle - Success
 * @returns           NULLP            - Otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfAreaTable_GetOwner(t_Handle ospfMibObj, ulng areaId);


 /*********************************************************************
 * @purpose             Get an entry in the ospfAreaTable.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId        @b{(input)}  the OSPF area identifier (IP address)
 *
 * @returns             pointer to the appropriate entry of ospfAreaTable on
 *                      success
 * @returns             NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfAreaTable_Lookup(t_Handle ospfMibObj, ulng areaId);


 /*********************************************************************
 * @purpose     Test the parameters in a row of the ospfAreaTable before
 *              setting them by SNMP agent.
 *
 *
 * @param lastOid    @b{(input)}  parameter offset in the row
 * @param newValue   @b{(input)}  value to set
 * @param p          @b{(input)}  pointer to ospfAreaEntry
 *
 * @returns          E_OK     - success, value can be set
 * @returns          E_FAILED - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaTable_SetTest(word lastOid, ulng newValue, t_Handle p);



 /*********************************************************************
 * @purpose               Get the next entry in the ospfAreaTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param prevAreaId      @b{(input)}  the OSPF area identifier (IP address)
 *
 * @returns               pointer to the next (after prevAreaId) entry in the
 *                        ospfAreaTable and the next area id on success
 *
 * @returns               NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfAreaTable_GetNext(t_Handle ospfMibObj, ulng prevAreaId,
                               ulng *p_AreaId);


 /*********************************************************************
 * @purpose               Get the first entry in the ospfAreaTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @returns               pointer to the first entry in the ospfAreaTable
 *                        and the first areaId on success
 * @returns               NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfAreaTable_GetFirst(t_Handle ospfMibObj, ulng *p_AreaId);


 /*********************************************************************
 * @purpose           Set new value for row status of the ospfAreaTable
 *                    and check consistency of this value.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  The area identifier (index of the table)
 * @param value       @b{(input)}  Value to be set into row status
 *
 * @returns           E_OK      - success, value can be set
 * @returns           E_BADPARM - bad parameter(s)
 * @returns           E_FAILED  - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaTable_SetRowStatus(t_Handle ospfMibObj, ulng areaId,
                                 ulng value);


 /*********************************************************************
 * @purpose            Update the Area Table entry according to the are
 *                     configuration:
 *
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param p_Cfg       @b{(input)}  a handle of the area parameters structure,
 *                                 including the 'command' parameter
 *
 * @returns           E_OK       - success
 * @returns           E_BADPARM  - invalid parameter
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaTable_Update(t_Handle ospfMibObj, t_S_AreaCfg *p_Cfg);


/***************************************
 *  OSPF Stub Area Table
 ***************************************/

 /*********************************************************************
 * @purpose     Create a new row in the ospf Area Default Metric Table
 *              (ospfStubAreaTable).
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param stubAreaId      @b{(input)}  The area identifier - IP address
 * @param stubTOS         @b{(input)}  Stub area type of service
 *
 * @returns               E_OK       - success
 * @returns               E_IN_MATCH - entry already exists
 * @returns               E_BADPARM  - invalid parameter
 * @returns               E_NOMEMORY - can't allocate memory
 *
 * @notes                 This procedure is to be used only
 *                        from the SNMP code
 *
 * @end
 * ********************************************************************/
e_Err ospfStubAreaTable_New(t_Handle ospfMibObj, ulng stubAreaId,
                            ulng stubAreaTOS);


 /*********************************************************************
 * @purpose     Delete a row from the OSPF Stub Area MIB Table. This routine
 *              is to be called from SNMP only.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param stubAreaId      @b{(input)}  The area identifier - IP address
 * @param stubTOS         @b{(input)}  The stub area type of service
 *
 * @returns               E_OK     - Success
 * @returns               Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfStubAreaTable_Delete(t_Handle ospfMibObj, ulng stubAreaId,
                               ulng stubTOS);


 /*********************************************************************
 * @purpose               Get an entry in the ospfStubAreaTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param stubAreaId      @b{(input)}  The OSPF Stub area identifier
 *                                     (IP address)
 * @param stubTOS         @b{(input)}  The stub area type of service
 *
 * @returns       pointer to the appropriate entry of ospfStubAreaTable
 *                on success
 * @returns       NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfStubAreaTable_Lookup(t_Handle ospfMibObj, ulng stubAreaId,
                                  ulng stubTOS);


 /*********************************************************************
 * @purpose               Get the next entry in the ospfStubAreaTable.
 *
 *
 * @param ospfMibObj        @b{(input)}  t_Handle of the OSPF MIB object
 * @param prevStubAreaId    @b{(input)}  the stub OSPF area identifier
 *                                     (IP address)
 * @param prevStubAreaTOS   @b{(input)}  the stub area type of service
 * @param p_StubAreaId      @b{(input)}  the next stub area identifier
 * @param p_StubAreaTOS     @b{(input)}  the next stub areatype of service
 *
 * @returns          pointer to the next (after the previous) entry in the
 *                   ospfStubAreaTable and the next area id on success
 * @returns          NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfStubAreaTable_GetNext(t_Handle ospfMibObj, ulng prevStubAreaId,
                                   ulng prevStubAreaTOS, ulng  *p_StubAreaId,
                                   ulng *p_StubAreaTOS);


 /*********************************************************************
 * @purpose               Get the first entry in the ospfStubAreaTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param p_StubAreaId    @b{(input)}  the next stub area identifier
 * @param p_StubAreaTOS   @b{(input)}  the next stub areatype of
 *                                        service
 *
 * @returns               pointer to the first entry in the
 *                        ospfStubAreaTable and the indexes of the first
 *                        entry on success
 * @returns               NULLP otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfStubAreaTable_GetFirst(t_Handle ospfMibObj, ulng  *p_StubAreaId,
                                    ulng *p_StubAreaTOS);


 /*********************************************************************
 * @purpose     Test the parameters in a row of the ospfStubAreaTable
 *              before setting them by SNMP agent.
 *
 *
 * @param  lastOid      @b{(input)}  parameter offset in the row
 * @param  newValue     @b{(input)}  value to set
 * @param  p            @b{(input)}  pointer to ospfAreaEntry
 *
 * @returns             E_OK      - success, value can be set
 * @returns             E_FAILED  - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfStubAreaTable_SetTest(word lastOid, ulng newValue, t_Handle p);


 /*********************************************************************
 * @purpose     Set new value for row status of the ospfStubAreaTable
 *              and check consistency of this value.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param stubAreaId      @b{(input)}  The area identifier (index of
 *                                                        the table)
 * @param stubTOS         @b{(input)}  The stub area type of service
 * @param value           @b{(input)}  Value to be set into row status
 *
 * @returns               E_OK      - success, value can be set
 * @returns               E_BADPARM - bad parameter(s)
 * @returns               E_FAILED  - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfStubAreaTable_SetRowStatus(t_Handle ospfMibObj, ulng stubAreaId,
                                     ulng stubTOS, ulng value);


 /*********************************************************************
 * @purpose      Update the Stub Area (Metric) Table according to the
 *               'command' parameter.
 *
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param stubAreaId      @b{(input)}  The area identifier - IP address
 * @param p_Metric        @b{(input)}  a handle of the metric parameters ,
 *                                     structure including the 'command'
 *                                     parameter
 *
 * @returns               E_OK       - success
 * @returns               E_IN_MATCH - entry already exists
 * @returns               E_BADPARM  - invalid parameter
 * @returns               E_NOMEMORY - can't allocate memory
 *
 * @notes       either create new row, or update/destroy an existing one.
 *              This procedure is to be called only from the OSPF code
 *              (not from the SNMP code).
 *
 * @end
 * ********************************************************************/
e_Err ospfStubAreaTable_Update(t_Handle ospfMibObj, ulng stubAreaId,
                               t_S_StubAreaEntry *p_Metric);


/***********************************
 *  OSPF Link State Database Table
 ***********************************/

 /*********************************************************************
 * @purpose             Create a new row in the ospf Link State database
 *                      table.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param LsdbAreaId    @b{(input)}  the area identifier (IP address)
 * @param LsdbType      @b{(input)}  the type of the link state advertisement
 * @param LsdbId        @b{(input)}  identifies the piece of the routing domain
 *                                   that is being describes by the advertisement
 *                                   (IP adrress)
 * @param LsdbRouterId  @b{(input)}  originating router in the Autonomous System
 *                                       (IP address)
 *
 * @returns             E_OK       - success
 * @returns             E_IN_MATCH - entry already exists
 * @returns             E_BADPARM  - invalid parameter
 * @returns             E_NOMEMORY - can't allocate memory
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfLsdbTable_New(t_Handle ospfMibObj, ulng LsdbAreaId, ulng LsdbType,
                        ulng LsdbId, ulng LsdbRouterId);


 /*********************************************************************
 * @purpose            Delete a row from the OSPF Link State database
 *                     table.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param LsdbAreaId    @b{(input)}  the area identifier (IP address)
 * @param LsdbType      @b{(input)}  the type of the link state advertis
 *                                   ement
 * @param LsdbId        @b{(input)}  identifies the piece of the routing
 *                                   domain that is being describes by the
 *                                   advertisement(IP adrress)
 * @param LsdbRouterId  @b{(input)}  originating router in the Autonomous
 *                                   System (IP address)
 *
 * @returns              E_OK     - Success
 * @returns              Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfLsdbTable_Delete(t_Handle ospfMibObj, ulng LsdbAreaId,
                           ulng LsdbType, ulng LsdbId, ulng LsdbRouterId);


 /*********************************************************************
 * @purpose               Get the first entry in the ospfLsdbTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @returns               pointer to the first entry in the
 *                        ospfAreaTable and the first entry indexes on
 *                        success
 * @returns               NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfLsdbTable_GetFirst(t_Handle ospfMibObj, ulng *p_LsdbAreaId,
                                ulng *p_LsdbType, ulng *p_LsdbId,
                                ulng *p_LsdbRouterId);


/****************************
 *  OSPF Host Table
 ****************************/

 /*********************************************************************
 * @purpose     Create a new row in the ospf Host Table. This routine is
 *              to be called from the SNMP code only.
 *
 *
 * @param ospfMibObj   @b{(input)}  t_Handle of the OSPF MIB object
 * @param hostIpAddr   @b{(input)}  the host IP address
 * @param hostTOS      @b{(input)}  the host type of service
 *
 * @returns            E_OK       - success
 * @returns            E_IN_MATCH - entry already exists
 * @returns            E_BADPARM  - invalid parameter
 * @returns            E_NOMEMORY - can't allocate memory
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfHostTable_New(t_Handle ospfMibObj, ulng hostIpAddr, ulng hostTOS);


 /*********************************************************************
 * @purpose     Delete a row from the OSPF Host MIB Table. This routine
 *              is to be called from the SNMP code only.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param hostIpAddr      @b{(input)}  the host IP address
 * @param hostTOS         @b{(input)}  the host type of service
 *
 * @returns               E_OK     - Success
 * @returns               Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfHostTable_Delete(t_Handle ospfMibObj, ulng hostIpAddr,
                           ulng hostTOS);


 /*********************************************************************
 * @purpose               Get an entry in the ospfHostTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param hostIpAddr      @b{(input)}  the host IP address
 * @param hostTOS         @b{(input)}  the host type of service
 *
 * @returns               pointer to the appropriate entry of ospfHostTable
 *                        on success
 * @returns               NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfHostTable_Lookup(t_Handle ospfMibObj, ulng hostIpAddr,
                              ulng hostTOS);


 /*********************************************************************
 * @purpose                 Get the next entry in the ospfHostTable.
 *
 *
 * @param prevHostIpAddr    @b{(input)}  the IP address of the host
 * @param prevHostTOS       @b{(input)}  the type of service of the route
 *                                        being configured
 * @param ospfMibObj        @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @param p_HostIpAddr      @b{(output)}  the IP address of the host
 * @param p_HostTOS         @b{(output)}  the type of service of the route
 *                                         being configured
 *
 * @returns           pointer to the next (after the previous) entry in the
 *                    ospfHostTable and the next entry indexes on success
 * @returns           NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfHostTable_GetNext(t_Handle ospfMibObj, ulng prevHostIpAddr,
                               ulng prevHostTOS, ulng *p_HostIpAddr,
                               ulng *p_HostTOS);


 /*********************************************************************
 * @purpose               Get the first entry in the ospfHostTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @param p_HostIpAddr    @b{(output)}  the IP address of the host
 * @param p_HostTOS       @b{(output)}  the type of service of the route
 *                                      being configured
 *
 * @returns               pointer to the first entry in the
 *                        ospfHostTable and indexes of the first entry
 * @returns               NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfHostTable_GetFirst(t_Handle ospfMibObj, ulng *p_HostIpAddr,
                                ulng *p_HostTOS);


 /*********************************************************************
 * @purpose     Test the parameters in a row of the ospfHostTable before
 *              setting them by SNMP agent.
 *
 *
 * @param lastOid       @b{(input)}  parameter offset in the row
 * @param newValue      @b{(input)}  value to set
 * @param p             @b{(input)}  pointer to ospfAreaRangeEntry
 *
 * @returns             E_OK     - success, value can be set
 * @returns             E_FAILED - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfHostTable_SetTest(word lastOid, ulng newValue, t_Handle p);


 /*********************************************************************
 * @purpose     Set new value for row status of the ospfHostTable and check
 *              consistency of this value.
 *
 *
 * @param ospfMibObj     @b{(input)} t_Handle of the OSPF MIB object
 * @param hostIpAddr     @b{(input)} the host IP address
 * @param hostTOS        @b{(input)} the host type of service
 * @param value          @b{(input)} Value to be set into row status
 *
 * @returns              E_OK      - success, value can be set
 * @returns              E_BADPARM - bad parameter(s)
 * @returns              E_FAILED  - inconsistent value
 *
 * @notes                This procedure is designed to be
 *                       called from SNMP agent code.(row status can
 *                       be changed only for SNMP created hosts.)
 *
 * @end
 * ********************************************************************/
e_Err ospfHostTable_SetRowStatus(t_Handle ospfMibObj, ulng hostIpAddr,
                                 ulng hostTOS, ulng value);


 /*********************************************************************
 * @purpose     Update the Host Table according to the 'command' parameter.
 *
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param p_Hosts       @b{(input)}  a handle of the host parameters structure,
 *                                   including the 'command' parameter
 *
 * @returns     E_OK       - success
 * @returns     E_IN_MATCH - entry already exists
 * @returns     E_BADPARM  - invalid parameter
 * @returns     E_NOMEMORY - can't allocate memory
 *
 * @notes       either create new row, or update/destroy an existing one.
 *              This procedure is to be called only from the OSPF code
 *              (not from the SNMP code).
 *
 * @end
 * ********************************************************************/
e_Err ospfHostTable_Update(t_Handle ospfMibObj, t_S_HostRouteCfg *p_Hosts);


/***********************************
 *  OSPF Interface Table
 ***********************************/

 /*********************************************************************
 * @purpose             Create a new row in the OSPF Interface MIB Table.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param ifIpAddr      @b{(input)}  the interface IP address
 * @param ifAddrLessIf  @b{(input)}  ifIndex (for interfaces having no IP addr)
 *
 * @returns             E_OK       - success
 * @returns             E_IN_MATCH - entry already exists
 * @returns             E_BADPARM  - invalid parameter
 * @returns             E_NOMEMORY - can't allocate memory
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfTable_New(t_Handle ospfMibObj, ulng ifIpAddr,
                      ulng ifAddrLessIf);


 /*********************************************************************
 * @purpose          Create a new row in the OSPF Interface MIB Table and
 *                   activate it.
 *
 *
 * @param ospfMibObj   @b{(input)}  t_Handle of the OSPF MIB object
 * @param ifIpAddr     @b{(input)}  the interface IP address
 * @param ifAddrLessIf @b{(input)}  ifIndex
 * @param ifObj        @b{(input)}  t_Handle of the corresponding IFO object
 *                                  (the owner)
 *
 * @returns            E_OK       - success
 * @returns            E_IN_MATCH - entry already exists
 * @returns            E_BADPARM  - invalid parameter
 * @returns            E_NOMEMORY - can't allocate memory
 *
 * @notes
 *              This procedure can be called from OSPF protocol code only.
 *       It is called from OSPF protocol code after a new interface object
 *       is created.
 *       The new row parameters are set according to the interface object
 *       parameters.
 *
 * @end
 * ********************************************************************/
e_Err ospfIfTable_InternalNewAndActive(t_Handle ospfMibObj, ulng ifIpAddr,
                                       ulng ifAddrLessIf, t_Handle ifObj);


 /*********************************************************************
 * @purpose     Delete a row from the OSPF Interface MIB Table. Called
 *              when interface is deleted by SNMP request.
 *
 *
 * @param  ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param  ifIpAddr      @b{(input)}  the interface IP address
 * @param  ifAddrLessIf  @b{(input)}  ifIndex (for interfaces having
 *                                                        no IP addr)
 *
 * @returns              E_OK     - Success
 * @returns              Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfTable_Delete(t_Handle ospfMibObj, ulng ifIpAddr,
                         ulng ifAddrLessIf);


 /*********************************************************************
 * @purpose     Delete a row from the OSPF Interface MIB Table. This
 *              routine is called only from the protocol code, not from
 *              the SNMP.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param ifIpAddr      @b{(input)}  the interface IP address
 * @param ifAddrLessIf  @b{(input)}  ifIndex
 *
 * @returns             E_OK     - Success
 * @returns             Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfTable_DeleteInternal(t_Handle ospfMibObj, ulng ifIpAddr,
                                 ulng ifAddrLessIf);


 /*********************************************************************
 * @purpose             Get an entry in the ospfIfTable.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param ifIpAddr      @b{(input)}  the interface IP address
 * @param ifAddrLessIf  @b{(input)}  ifIndex (for interfaces having
 *                                                       no IP addr)
 *
 * @returns     pointer to the appropriate entry of ospfIfTable on success
 * @returns     NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfIfTable_Lookup(t_Handle ospfMibObj, ulng ifIpAddr,
                            ulng ifAddrLessIf);


 /*********************************************************************
 * @purpose                 Get the next entry in the ospfIfTable.
 *
 *
 * @param ospfMibObj        @b{(input)}  t_Handle of the OSPF MIB object
 * @param prevIfIpAddr      @b{(input)}  the interface IP address
 * @param prevIfAddrLessIf  @b{(input)}  ifIndex (for interfaces
 *                                                    having no IP addr)
 *
 * @param p_IfIpAddr        @b{(output)}  the interface IP address
 * @param p_IfAddrLessIf    @b{(output)}  ifIndex (for interfaces having
 *                                                            no IP addr)
 *
 *
 * @returns      pointer to the next (after the previous) entry in the
 *               ospfIfTable and indexes of the next element
 * @returns      NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfIfTable_GetNext(t_Handle ospfMibObj, ulng prevIfIpAddr,
                             ulng prevIfAddrLessIf, ulng *p_IfIpAddr,
                             ulng *p_IfAddrLessIf);


 /*********************************************************************
 * @purpose               Get the first entry in the ospfIfTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @param p_IfIpAddr      @b{(output)}  the interface IP address
 * @param p_IfAddrLessIf  @b{(output)}  ifIndex
 *
 * @returns        pointer to the first entry in the
 *                 ospfIfTable and indexes of the first element
 * @returns        NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfIfTable_GetFirst(t_Handle ospfMibObj, ulng *p_IfIpAddr,
                              ulng *p_IfAddrLessIf);


 /*********************************************************************
 * @purpose     Test the parameters in a row of the ospfIfTable before
 *              setting them by SNMP agent.
 *
 *
 * @param lastOid      @b{(input)}  parameter offset in the row
 * @param newValue     @b{(input)}  value to set
 * @param p            @b{(input)}  pointer to ospfIfEntry
 *
 * @returns            E_OK     - success, value can be set
 * @returns            E_FAILED - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/

e_Err ospfIfTable_SetTest(word lastOid, ulng newValue, t_Handle p);


 /*********************************************************************
 * @purpose          Set new value for row status of the ospfIfTable
 *                   and check consistency of this value.
 *
 *
 * @param  ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param  ifIpAddr       @b{(input)}  the interface IP address
 * @param  ifAddrLessIf   @b{(input)}  ifIndex (for interfaces having
 *                                                          no IP addr)
 * @param  value          @b{(input)}  Value to be set into row status
 *
 * @returns               E_OK      - success, value can be set
 * @returns               E_BADPARM - bad parameter(s)
 * @returns               E_FAILED  - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfTable_SetRowStatus(t_Handle ospfMibObj, ulng ifIpAddr,
                               ulng ifAddrLessIf, ulng value);


 /*********************************************************************
 * @purpose           Set new value for admin status of the ospfIfTable
 *                    and check consistency of this value.
 *
 *
 * @param  ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param  ifIpAddr       @b{(input)}  the interface IP address
 * @param  ifAddrLessIf   @b{(input)}  ifIndex (for interfaces having
 *                                                         no IP addr)
 * @param  value          @b{(input)}  Value to be set into row status
 *
 * @returns               E_OK      - success, value can be set
 * @returns               E_BADPARM - bad parameter(s)
 * @returns               E_FAILED  - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfTable_SetAdminStatus(t_Handle ospfMibObj, ulng ifIpAddr,
                                 ulng ifAddrLessIf, e_ospfAdminStatus value);




 /*********************************************************************
 * @purpose     Update the If Table entry according to the interface
 *              configuration.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param *p_Cfg      @b{(input)}  a handle of the interface parameters
 *                                 structure,including the 'command'
 *                                 parameter
 *
 * @returns           E_OK       - success
 * @returns           E_BADPARM  - invalid parameter
 *
 * @notes             This procedure is to be called only from
 *                    the OSPF code(not from the SNMP code).
 *
 * @end
 * ********************************************************************/
e_Err ospfIfTable_Update(t_Handle ospfMibObj, t_IFO_Cfg *p_Cfg);



/******************************
 * OSPF Interface Metric Table
 ******************************/

 /*********************************************************************
 * @purpose            Create a new row in the OSPF Interface Metric Table.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param ifIpAddr      @b{(input)}  the interface IP address
 * @param ifAddrLessIf  @b{(input)}  ifIndex (for interfaces having no
 *                                                             IP addr)
 *
 * @param ifTOS         @b{(input)}  the interface type of service
 *                                   (OSPF version 2 supports only TOS 0)
 *
 * @returns             E_OK       - success
 * @returns             E_IN_MATCH - entry already exists
 * @returns             E_BADPARM  - invalid parameter
 * @returns             E_NOMEMORY - can't allocate memory
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfMetricTable_New(t_Handle ospfMibObj, ulng ifIpAddr,
                            ulng ifAddrLessIf, ulng ifTOS);


 /*********************************************************************
 * @purpose             Delete a row from the OSPF Interface Metric MIB
 *                      Table.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param ifIpAddr      @b{(input)}  the interface IP address
 * @param ifAddrLessIf  @b{(input)}  ifIndex (for interfaces having
 *                                                        no IP addr)
 * @param ifTOS         @b{(input)}  type of service of the i/f
 *
 * @returns             E_OK     - Success
 * @returns             Not E_OK - The row cannot be deleted
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfMetricTable_Delete(t_Handle ospfMibObj, ulng ifIpAddr,
                               ulng ifAddrLessIf, ulng ifTOS);


 /*********************************************************************
 * @purpose             Get an entry in the ospfIfMetricTable.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param ifIpAddr      @b{(input)}  the interface IP address
 * @param ifAddrLessIf  @b{(input)}  ifIndex (for interfaces having
 *                                                           no IP addr)
 * @param ifTOS         @b{(input)}  the interface type of service
 *
 * @returns             pointer to the appropriate entry of ospfIfMetricTable
 *                      on success
 * @returns             NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfIfMetricTable_Lookup(t_Handle ospfMibObj, ulng ifIpAddr,
                                  ulng ifAddrLessIf, ulng ifTOS);


 /*********************************************************************
 * @purpose                Get the next entry in the ospfIfMetricTable.
 *
 *
 * @param ospfMibObj       @b{(input)}  t_Handle of the OSPF MIB object
 * @param prevIfIpAddr     @b{(input)}  the interface IP address
 * @param prevIfAddrLessIf @b{(input)}  ifIndex (for interfaces having
 *                                                        no IP addr)
 * @param prevTOS          @b{(input)}  type of service of the i/f
 *
 * @param p_IfIpAddr       @b{(output)}  the interface IP address
 * @param p_IfAddrLessIf   @b{(output)}  ifIndex (for interfaces
 *                                               having no IP addr)
 * @param p_IfTOS          @b{(output)}  type of service of the i/f
 *
 *
 *
 * @returns      pointer to the next (after the previous) entry in the
 *               ospfIfMetricTable and the next entry indexes on success
 * @returns      NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfIfMetricTable_GetNext(t_Handle ospfMibObj, ulng prevIfIpAddr,
                                   ulng prevIfAddrLessIf, ulng prevTOS,
                                   ulng *p_IfIpAddr, ulng *p_IfAddrLessIf,
                                   ulng *p_IfTOS);


 /*********************************************************************
 * @purpose                Get the first entry in the ospfIfMetricTable.
 *
 *
 * @param p_IfIpAddr       @b{(input)}  the interface IP address
 * @param p_IfAddrLessIf   @b{(input)}  ifIndex (for interfaces having
 *                                                             no IP addr)
 * @param p_IfTOS          @b{(input)}  type of service of the i/f
 *
 * @returns       pointer to the first  entry in the ospfIfMetricTable
 *                and the indexes of the first entry on success
 * @returns       NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfIfMetricTable_GetFirst(t_Handle ospfMibObj, ulng *p_IfIpAddr,
                                    ulng *p_IfAddrLessIf, ulng *p_IfTOS);


 /*********************************************************************
 * @purpose     Test the parameters in a row of the ospfIfMetricTable
 *              before setting them by SNMP agent.
 *
 *
 * @param  lastOid      @b{(input)}  parameter offset in the row
 * @param  newValue     @b{(input)}  value to set
 * @param  p            @b{(input)}  pointer to ospfAreaRangeEntry
 *
 * @returns             E_OK     - success, value can be set
 * @returns             E_FAILED - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfMetricTable_SetTest(word lastOid, ulng newValue, t_Handle p);


 /*********************************************************************
 * @purpose    Set new value for row status of the ospfIfMetricTable
 *             and check consistency of this value.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param ifIpAddr      @b{(input)}  the interface IP address
 * @param ifAddrLessIf  @b{(input)}  ifIndex (for interfaces having
 *                                                           no IP addr)
 * @param ifTOS         @b{(input)}  the TOS metric being referenced
 * @param value         @b{(input)}  Value to be set into row status
 *
 * @returns             E_OK      - success, value can be set
 * @returns             E_BADPARM - bad parameter(s)
 * @returns             E_FAILED  - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfMetricTable_SetRowStatus(t_Handle ospfMibObj, ulng ifIpAddr,
                                     ulng ifAddrLessIf, ulng ifTOS,
                                     ulng value);


 /*********************************************************************
 * @purpose     Update the Interface Metric Table according to the 'command'
 *              parameter: either create a new row, or update/destroy an
 *              existing one. This routine is to be called from OSPF
 *              protocol code only.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param p_Metric      @b{(input)}  i/f metric parameters structure,
 *                                   including the 'command' parameter
 *
 * @returns             E_OK      - success
 * @returns             E_BADPARM - invalid parameter
 * @returns             E_FAILED  - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfIfMetricTable_Update(t_Handle ospfMibObj, t_S_IfMetric *p_Metric);


/*************************************
 *  OSPF Virtual Interface Table
 *************************************/

 /*********************************************************************
 * @purpose           Create a new row in the ospf Virtual Interface Table.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  IP Address of the Transit Area that
 *                                 the virtual interface traverses
 * @param ifNbr       @b{(input)}  IP Address of the virtual neighbor
 *                                  router
 *
 * @returns           E_OK       - success
 * @returns           E_IN_MATCH - entry already exists
 * @returns           E_BADPARM  - invalid parameter
 * @returns           E_NOMEMORY - can't allocate memory
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtIfTable_New(t_Handle ospfMibObj, ulng areaId, ulng ifNbr);


 /*********************************************************************
 * @purpose     Create a new row in the OSPF Virtual Interface MIB Table
 *              and configure it according to its "owner" IFO.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  IP Address of the Transit Area that the
 *                                  virtualinterface traverses
 * @param ifNbr       @b{(input)}  IP Address of the virtual neighbor router
 * @param ifObj       @b{(input)}  t_Handle of the corresponding IFO object
 *
 * @returns           E_OK       - success
 * @returns           E_IN_MATCH - entry already exists
 * @returns           E_BADPARM  - invalid parameter
 * @returns           E_NOMEMORY - can't allocate memory
 *
 * @notes
 *             This procedure can be called from OSPF protocol code only.
 *      It is called from OSPF protocol code after a new virtual
 *      interface object is created.
 *      The new row parameters are set according to the "owner" interface
 *      object parameters.
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtIfTable_InternalNewAndActive(t_Handle ospfMibObj, ulng areaId,
                                           ulng ifNbr, t_Handle ifObj);


 /*********************************************************************
 * @purpose     Delete a row from the OSPF Virtual Interface MIB Table.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  IP Address of the Transit Area that the
 *                                 virtual interface traverses
 * @param ifNbr       @b{(input)}  IP Address of the virtual neighbor router
 *
 * @returns           E_OK     - Success
 * @returns           Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtIfTable_Delete(t_Handle ospfMibObj, ulng areaId, ulng ifNbr);


 /*********************************************************************
 * @purpose            Delete a row from the OSPF Virtual Interface MIB
 *                     Table.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  IP Address of the Transit Area that
 *                                 the virtual interface traverses
 * @param ifNbr       @b{(input)}  IP Address of the virtual neighbor
 *                                 router
 *
 * @returns           E_OK     - Success
 * @returns           Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtIfTable_DeleteInternal(t_Handle ospfMibObj, ulng areaId,
                                     ulng ifNbr);


 /*********************************************************************
 * @purpose           Get an entry in the ospfVirtIfTable.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  IP Address of the Transit Area that
 *                                 the virtual interface traverses
 * @param ifNbr       @b{(input)}  IP Address of the virtual neighbor router
 *
 * @returns           pointer to the appropriate entry of ospfVirtIfTable
 *                    on success
 * @returns           NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfVirtIfTable_Lookup(t_Handle ospfMibObj, ulng areaId, ulng ifNbr);


 /*********************************************************************
 * @purpose             Get the next entry in the ospfVirtIfTable.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param prevAreaId    @b{(input)}  the interface IP address
 * @param prevIfNbr     @b{(input)}  ifIndex (for interfaces having no
 *                                                             IP addr)
 *
 * @param p_AreaId      @b{(output)}  the interface IP address
 * @param p_IfNbr       @b{(output)}  ifIndex (for interfaces having no
 *                                                             IP addr)
 *
 * @returns        pointer to the next (after the previous) entry in the
 *                 ospfIfTable and the next entry indexes on success
 * @returns        NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfVirtIfTable_GetNext(t_Handle ospfMibObj, ulng prevAreaId,
                                 ulng prevIfNbr, ulng *p_AreaId,
                                 ulng *p_IfNbr);


 /*********************************************************************
 * @purpose            Get the first entry in the ospfVirtIfTable.
 *
 *
 * @param  ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @param  p_AreaId    @b{(output)}  the interface IP address
 * @param  p_IfNbr     @b{(output)}  ifIndex (for interfaces having no
 *                                                             IP addr)
 *
 * @returns       pointer to the first entry in the
 *                ospfVirtIfTable and the first entry indexes on success
 * @returns       NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfVirtIfTable_GetFirst(t_Handle ospfMibObj, ulng *p_AreaId,
                                  ulng *p_IfNbr);


 /*********************************************************************
 * @purpose     Test the parameters in a row of the ospfVirtIfTable before
 *              setting them by SNMP agent
 *
 *
 * @param lastOid       @b{(input)}  parameter offset in the row
 * @param newValue      @b{(input)}  value to set
 * @param p             @b{(input)}  pointer to ospfVirtIfEntry
 *
 * @returns             E_OK     - success, value can be set
 * @returns             E_FAILED - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtIfTable_SetTest(word lastOid, ulng newValue, t_Handle p);


 /*********************************************************************
 * @purpose          Set new value for row status of the ospfVirtIfTable
 *                   and check consistency of this value.
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param areaId      @b{(input)}  IP Address of the Transit Area that the
 *                                 virtual interface traverses
 * @param ifNbr       @b{(input)}  IP Address of the virtual neighbor router
 *
 * @returns           E_OK     - success, value can be set
 * @returns           E_FAILED - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtIfTable_SetRowStatus(t_Handle ospfMibObj, ulng areaId,
                                   ulng ifNbr, ulng value);




 /*********************************************************************
 * @purpose     Update the Virtual If Table entry according to the
 *              interface configuration.
 *
 *
 *
 * @param ospfMibObj  @b{(input)}  t_Handle of the OSPF MIB object
 * @param p_Cfg       @b{(input)}  a handle of the virtual interface parameters
 *                                 structure,including the 'command' parameter
 *
 * @returns           E_OK       - success
 * @returns           E_BADPARM  - invalid parameter
 *
 * @notes             This procedure is to be called only from the OSPF code
 *                    (not from the SNMP code).
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtIfTable_Update(t_Handle ospfMibObj, t_IFO_Cfg *p_Cfg);


/*******************************
 * OSPF Neighbor Table
 *******************************/

 /*********************************************************************
 * @purpose              Create a new row in the OSPF Neighbor Table
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrIpAddr      @b{(input)}  the neighbor IP address
 * @param nbrAddrLessId  @b{(input)}  ifIndex (for interfaces having
 *                                                        no IP addr)
 *
 * @returns              E_OK       - success
 * @returns              E_IN_MATCH - entry already exists
 * @returns              E_BADPARM  - invalid parameter
 * @returns              E_NOMEMORY - can't allocate memory
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfNbrTable_New(t_Handle ospfMibObj, ulng nbrIpAddr,
                       ulng nbrAddrLessId);


 /*********************************************************************
 * @purpose             Create and activate a new row in the OSPF Neighbor
 *                      Table.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrIpAddr      @b{(input)}  the neighbor IP address
 * @param nbrAddrLessId  @b{(input)}  ifIndex
 * @param owner          @b{(input)}  t_Handle of the neighbor object
 *
 * @returns              E_OK       - success
 * @returns              E_IN_MATCH - entry already exists
 * @returns              E_BADPARM  - invalid parameter
 * @returns              E_NOMEMORY - can't allocate memory
 *
 * @notes
 *               This procedure is called by OSPF protocol code ONLY.
 *        It is called from NBO_Init procedure after the new neighbor
 *        was discovered and new NBO object has been created.
 *        (SNMP agent has to call ospfNbrTable_New and ospfNbrTable_Active
 *        procedures to create new NBMA neighbor row.)
 *
 * @end
 * ********************************************************************/
e_Err ospfNbrTable_InternalNewAndActive(t_Handle ospfMibObj, ulng nbrIpAddr,
                                        ulng nbrAddrLessId, t_Handle owner);


 /*********************************************************************
 * @purpose     Deletes a row from the OSPF Neighbor Table. This routine
 *              is to be called from the SNMP code only.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrIpAddr      @b{(input)}  the neighbor IP address
 * @param nbrAddrLessId  @b{(input)}  ifIndex for i/f w/o and IP address
 *
 * @returns              E_OK      - deleted
 * @returns              E_BADPARM - bad parameter(s)
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfNbrTable_Delete(t_Handle ospfMibObj, ulng nbrIpAddr,
                          ulng nbrAddrLessId);


 /*********************************************************************
 * @purpose     Deletes a row from the OSPF Neighbor Table. This routine
 *              is to be called from the OSPF protocol code only.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrIpAddr      @b{(input)}  the neighbor IP address
 * @param nbrAddrLessId  @b{(input)}  ifIndex for i/f w/o and IP address
 *
 * @returns              E_OK      - deleted
 * @returns              E_BADPARM - bad parameter(s)
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfNbrTable_DeleteInternal(t_Handle ospfMibObj, ulng nbrIpAddr,
                                  ulng nbrAddrLessId);


 /*********************************************************************
 * @purpose              Get an entry in the ospfNbrTable.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrIpAddr      @b{(input)}  the neighbor IP address
 * @param nbrAddrLessId  @b{(input)}  ifIndex (for interfaces having
 *                                                            no IP addr)
 *
 * @returns          pointer to the appropriate entry of ospfNbrTable on
 *                   success
 * @returns          NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfNbrTable_Lookup(t_Handle ospfMibObj, ulng nbrIpAddr,
                             ulng nbrAddrLessId);


 /*********************************************************************
 * @purpose                  Get the next entry in the ospfNbrTable.
 *
 *
 * @param ospfMibObj         @b{(input)}  t_Handle of the OSPF MIB object
 * @param prevNbrIpAddr      @b{(input)}  the interface IP address
 * @param prevNbrAddrLessId  @b{(input)}  ifIndex (for interfaces
 *                                                  having no IP addr)
 *
 * @params p_NbrIpAddr       @b{(output)} the interface IP address
 * @params p_NbrAddrLessId   @b{(output)} ifIndex
 *
 * @returns       pointer to the next (after the previous) entry in the
 *                ospfNbrTable and the next entry indexes on success
 * @returns       NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfNbrTable_GetNext(t_Handle ospfMibObj, ulng prevNbrIpAddr,
                              ulng prevNbrAddrLessId, ulng *p_NbrIpAddr,
                              ulng *p_NbrAddrLessId);


 /*********************************************************************
 * @purpose                 Get the first entry in the ospfNbrTable.
 *
 *
 * @param  ospfMibObj        @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @param  p_NbrIpAddr      @b{(output)}  the interface IP address
 * @param  p_NbrAddrLessId  @b{(output)}  ifIndex
 *
 * @returns    pointer to the first (after the previous) entry in the
 *             ospfNbrTable and the first entry indexes on success
 * @returns    NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfNbrTable_GetFirst(t_Handle ospfMibObj, ulng *p_NbrIpAddr,
                               ulng *p_NbrAddrLessId);


 /*********************************************************************
 * @purpose     Test the parameters in a row of the ospfNbrTable before
 *              setting them by SNMP agent.
 *
 *
 * @param lastOid      @b{(input)}  parameter offset in the row
 * @param newValue     @b{(input)}  value to set
 * @param p            @b{(input)}  pointer to ospfAreaRangeEntry
 *
 * @returns            E_OK     - success, value can be set
 * @returns            E_FAILED - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfNbrTable_SetTest(word lastOid, ulng newValue, t_Handle p);



 /*********************************************************************
 * @purpose     Set new value for row status of the ospfNbrTable
 *              and check consistency of this value.
 *
 *
 * @param ospfMibObj        @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrIpAddr         @b{(input)}  the neighbor IP address
 * @param nbrAddrLessId     @b{(input)}  ifIndex (for interfaces having
 *                                                           no IP addr)
 * @param value             @b{(input)}  new value of the rowStatus
 *
 * @returns                 E_OK      - success, value can be set
 * @returns                 E_BADPARM - bad parameter(s)
 * @returns                 E_FAILED  - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfNbrTable_SetRowStatus(t_Handle ospfMibObj, ulng nbrIpAddr,
                                ulng nbrAddrLessId, ulng value);


/*******************************
 * OSPF Virtual Neighbor Table
 *******************************/

 /*********************************************************************
 * @purpose               Create a new row in the OSPF Virtual Neighbor
 *                        Table.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrAreaIpAddr   @b{(input)}  the transit area identifier (IP address)
 * @param nbrRtrIpAddr    @b{(input)}  neighboring router in the autonomous system
 *                                    (IP router)
 *
 * @returns                E_OK       - success
 * @returns                E_IN_MATCH - entry already exists
 * @returns                E_BADPARM  - invalid parameter
 * @returns                E_NOMEMORY - can't allocate memory
 *
 * @notes
 *      A new row can be created only by OSPF protocol code (not by
 *      SNMP request). A new row is created after the new NBO object
 *      has been successfully created for a neighbor connecting to
 *      the router by virtual interface.
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtNbrTable_NewInternal(t_Handle ospfMibObj, ulng nbrAreaIpAddr,
                                   ulng nbrRtrIpAddr, t_Handle owner);


 /*********************************************************************
 * @purpose                 Delete a row from the OSPF Virtual Neighbor
 *                          MIB Table.
 *
 *
 * @param ospfMibObj        @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrAreaIpAddr     @b{(input)}  the transit area identifier (IP address)
 * @param nbrRtrIpAddr      @b{(input)}  neighboring router in the autonomous system
 *                                       (IP router)
 *
 * @returns                 E_OK     - Success
 * @returns                 Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfVirtNbrTable_Delete(t_Handle ospfMibObj, ulng nbrAreaIpAddr,
                              ulng nbrRtrIpAddr);


 /*********************************************************************
 * @purpose               Get an entry in the ospfVirtNbrTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param nbrAreaIpAddr   @b{(input)}  the transit area identifier (IP address)
 * @param nbrRtrIpAddr    @b{(input)}  neighboring router in the autonomous system
 *                                     (IP router)
 *
 * @returns     pointer to the appropriate entry of ospfVirtNbrTable on
 *              success
 * @returns     NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfVirtNbrTable_Lookup(t_Handle ospfMibObj, ulng nbrAreaIpAddr,
                                 ulng nbrRtrIpAddr);


 /*********************************************************************
 * @purpose                    Get the next entry in the ospfVirtNbrTable.
 *
 *
 * @param ospfMibObj           @b{(input)}  t_Handle of the OSPF MIB object
 * @param prevVirtNbrAreaId    @b{(input)}  the interface IP address
 * @param prevVirtNbrRtrId     @b{(input)}  ifIndex (for interfaces
 *                                                      having no IP addr)
 *
 * @param p_VirtNbrAreaId      @b{(output)}  the i/f IP address
 * @param p_VirtNbrRtrId       @b{(output)}  ifIndex
 *
 * @returns       pointer to the next (after the previous) entry in the
 *                ospfVirtNbrTable on success
 * @returns       NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfVirtNbrTable_GetNext(t_Handle ospfMibObj, ulng prevVirtNbrAreaId,
                                  ulng prevVirtNbrRtrId, ulng *p_VirtNbrAreaId,
                                  ulng *p_VirtNbrRtrId);


 /*********************************************************************
 * @purpose                  Get the first entry in the ospfVirtNbrTable.
 *
 *
 * @param ospfMibObj         @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @param p_VirtNbrAreaId    @b{(output)}  the i/f IP address
 * @param p_VirtNbrRtrId     @b{(output)}  ifIndex
 *
 * @returns     pointer to the firs entry in the ospfVirtNbrTable on
 *              success
 * @returns     NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfVirtNbrTable_GetFirst(t_Handle ospfMibObj, ulng *p_VirtNbrAreaId,
                                   ulng *p_VirtNbrRtrId);


/******************************************
 * OSPF External Link State Database Table 
 ******************************************/

 /*********************************************************************
 * @purpose     Create a new row in the OSPF External Link State Database
 *              Table
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param extLsdbType     @b{(input)}  the type of link state advertisement
 * @param extLsdbLsid     @b{(input)}  IP address or Router ID that specifies
 *                                     the piece of the routing domain describing
 *                                     in the advertisement
 * @param extlsdbRtrId    @b{(input)}  IP address of the originating router
 *
 * @returns               E_OK       - success
 * @returns               E_IN_MATCH - entry already exists
 * @returns               E_BADPARM  - invalid parameter
 * @returns               E_NOMEMORY - can't allocate memory
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfExtLsdbTable_New(t_Handle ospfMibObj, ulng extLsdbType,
                           ulng extLsdbId, ulng extLsdbRtrId);


 /*********************************************************************
 * @purpose     Delete a row from the OSPF external Link State Database
 *              Table.
 *
 *
 * @param ospfMibObj     @b{(input)}  t_Handle of the OSPF MIB object
 * @param extLsdbType    @b{(input)}  the type of link state advertisement
 * @param extLsdbLsid    @b{(input)}  IP address or Router ID that specifies the
 *                                     piece of the routing domain describing in
 *                                     the advertisement
 * @param extlsdbRtrId   @b{(input)}  IP address of the originating router
 *
 * @returns              E_OK     - Success
 * @returns              Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfExtLsdbTable_Delete(t_Handle ospfMibObj, ulng extLsdbType,
                              ulng extLsdbId, ulng extLsdbRtrId);


 /*********************************************************************
 * @purpose                  Get the first entry in the ospfExtLsdbTable.
 *
 *
 * @param ospfMibObj         @b{(input)}  t_Handle of the OSPF MIB object
 *
 * @param p_ExtLsdbType      @b{output)}  the type of the external-LSA
 * @param p_ExtLsdbLsid      @b{(output)} ID of the described piece of
 *                                        routing domain
 * @param p_ExtlsdbRtrId     @b{(output)} the originating router ID
 *
 * @returns      pointer to the first entry in the ospfExtLsdbTable on
 *               success
 * @returns      NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfExtLsdbTable_GetFirst(t_Handle ospfMibObj, ulng *p_ExtLsdbType,
                                   ulng *p_ExtLsdbLsid, ulng *p_ExtlsdbRtrId);


/****************************
 * OSPF Area Aggregate Table
 ****************************/


 /*********************************************************************
 * @purpose               Create a new row in the OSPF Area Aggregate Table.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param aggrAreaId      @b{(input)}  the area the address aggregate is
 *                                     to be found within
 * @param aggrLsdbType    @b{(input)}  the type of address aggregate; could be:
 *                                     summaryLink (3) or nssaExternalLink (7)
 *
 * @param aggrNet         @b{(input)}  IP address of the Net or Subnet indicated by
 *                                     the range
 * @param aggrMask        @b{(input)}  Subnet mask
 *
 * @returns               E_OK       - success
 * @returns               E_IN_MATCH - entry already exists
 * @returns               E_BADPARM  - invalid parameter
 * @returns               E_NOMEMORY - can't allocate memory
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaAggrTable_New(t_Handle ospfMibObj, ulng aggrAreaId,
                            ulng aggrLsdbType, ulng aggrNet, ulng aggrMask);


 /*********************************************************************
 * @purpose             Delete a row from the OSPF Area Aggregate MIB Table.
 *
 *
 * @param ospfMibObj    @b{(input)}  t_Handle of the OSPF MIB object
 * @param aggrAreaId    @b{(input)}  the area the address aggregate is to be
 *                                   found within
 * @param aggrLsdbType  @b{(input)}  the type of address aggregate
 * @param aggrNet       @b{(input)}  IP address of the Net or Subnet indicated by
 *                                   the range
 * @param aggrMask      @b{(input)}  Subnet mask
 *
 * @returns             E_OK     - Success
 * @returns             Not E_OK - Failure
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaAggrTable_Delete(t_Handle ospfMibObj, ulng aggrAreaId,
                               ulng aggrLsdbType, ulng aggrNet,
                               ulng aggrMask);


 /*********************************************************************
 * @purpose               Get an entry in the ospfAreaAggrTable.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param aggrAreaId      @b{(input)}  the area the address aggregate is
 *                                     to be found within
 * @param aggrLsdbType    @b{(input)}  the type of address aggregate
 * @param aggrNet         @b{(input)}  IP address of the Net or Subnet
 *                                     indicated by the range
 * @param aggrMask        @b{(input)}    Subnet mask
 *
 * @returns        pointer to the appropriate entry of ospfAreaAggrTable
 *                 on success
 * @returns        NULLP - otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfAreaAggrTable_Lookup(t_Handle ospfMibObj, ulng aggrAreaId,
                                  ulng aggrLsdbType, ulng aggrNet,
                                  ulng aggrMask);


 /*********************************************************************
 * @purpose                Get the next entry in the ospfAreaAggrTable.
 *
 *
 * @param ospfMibObj       @b{(input)}  t_Handle of the OSPF MIB object
 * @param prevAggrAreaId   @b{(input)}  the area the address aggregate
 *                                      is to be found within
 * @param prevAggrLsdbType @b{(input)}  the type of address aggregate
 * @param prevAggrNet      @b{(input)}  IP address of the Net or Subnet
 *                                      indicated by the range
 * @param prevAggrMask     @b{(input)} Subnet mask
 *
 * @param p_AggrAreaId     @b{(output)}  the area the address aggregate
 *                                        is to befound within
 * @param p_AggrLsdbType   @b{(output)}  the type of address aggregate
 * @param p_AggrNet        @b{(output)}  IP address of the Net or Subnet indicated
 *                                        by the range
 * @param p_AggrMask       @b{(output)}  Subnet mask
 *
 * @returns    pointer to the next (after the previous) entry in the
 *             ospfAreaAggrTable on success
 * @returns    NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfAreaAggrTable_GetNext(t_Handle ospfMibObj, ulng prevAggrAreaId,
                                   ulng prevAggrLsdbType, ulng prevAggrNet,
                                   ulng prevAggrMask, ulng *p_AggrAreaId,
                                   ulng *p_AggrLsdbType, ulng *p_AggrNet,
                                   ulng *p_AggrMask);


 /*********************************************************************
 * @purpose               Get the first entry in the ospfAreaAggrTable.
 *
 *
 * @param ospfMibObj      @b{(input)}   t_Handle of the OSPF MIB object
 *
 * @param p_AggrAreaId    @b{(output)}  the area the address aggregate is to be
 *                                      found within
 * @param p_AggrLsdbType  @b{(output)}  the type of address aggregate
 * @param p_AggrNet       @b{(output)}  IP address of the Net or Subnet
 *                                      indicated by the range
 * @param p_AggrMask      @b{(output)}  Subnet mask
 *
 * @returns           pointer to the first entry in the
 *                    ospfAreaAggrTable on success
 * @returns           NULL otherwise
 *
 * @notes
 *
 * @end
 * ********************************************************************/
t_Handle ospfAreaAggrTable_GetFirst(t_Handle ospfMibObj, ulng  *p_AggrAreaId,
                                    ulng *p_AggrLsdbType, ulng *p_AggrNet,
                                    ulng *p_AggrMask);


 /*********************************************************************
 * @purpose       Test the parameters in a row of the ospfAreaAggrTable
 *                before setting them by SNMP agent.
 *
 *
 * @param lastOid      @b{(input)}  parameter offset in the row
 * @param newValue     @b{(input)}  value to set
 * @param p            @b{(input)}  pointer to ospfAreaAggrEntry
 *
 * @returns            E_OK     - success, value can be set
 * @returns            E_FAILED - inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaAggrTable_SetTest(word lastOid, ulng newValue, t_Handle p);


 /*********************************************************************
 * @purpose        Set new value for row status of the ospfAreaAggrTable
 *                 and check consistency of this value.
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param aggrAreaId      @b{(input)}  the area the address aggregate is
 *                                     to be found within
 * @param aggrLsdbType    @b{(input)}  the type of address aggregate
 * @param aggrNet         @b{(input)}  IP address of the Net or Subnet
 *                                     indicated by the range
 * @param aggrMask        @b{(input)}  Subnet mask
 * @param value           @b{(input)}  new value of the rowStatus
 *
 * @returns               E_OK      -  success, value can be set
 * @returns               E_BADPARM -  bad parameter(s)
 * @returns               E_FAILED  -  inconsistent value
 *
 * @notes
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaAggrTable_SetRowStatus(t_Handle ospfMibObj, ulng aggrAreaId,
                                     ulng aggrLsdbType, ulng aggrNet,
                                     ulng aggrMask, ulng value);


 /*********************************************************************
 * @purpose     Update the Area Aggregate Table according to the 'command'
 *              parameter.
 *
 *
 *
 * @param ospfMibObj      @b{(input)}  t_Handle of the OSPF MIB object
 * @param aggrAreaId      @b{(input)}  the area the address aggregate is
 *                                     to be found within
 * @param p_AdrRange      @b{(input)}  area range parameters structure,
 *                                     including the 'command' parameter
 *
 * @returns               E_OK       - success
 * @returns               E_IN_MATCH - entry already exists
 * @returns               E_BADPARM  - invalid parameter
 * @returns               E_NOMEMORY - can't allocate memory
 *
 * @notes                 either create new row, or update/destroy an
 *                        existing one. This routine is to be called from
 *                        OSPF protocol code only
 *
 * @end
 * ********************************************************************/
e_Err ospfAreaAggrTable_Update(t_Handle ospfMibObj, ulng aggrAreaId,
                               t_S_AreaAggregateEntry *p_AdrRange);

#endif /* _ospfmib_support_ext_ */

