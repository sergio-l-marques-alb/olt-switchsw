
/*********************************************************************
*
* (C) Copyright Broadcom Corporation 2000-2007
*
**********************************************************************
*
* @filename   ip_util.h
*
* @purpose    Ip Mapping layer internal function prototypes
*
* @component  Ip Mapping Layer
*
* @comments   none
*
* @create     03/18/2001
*
* @author     asuthan
* @end
*
**********************************************************************/

/*************************************************************

*************************************************************/



#ifndef INCLUDE_IP_UTIL_H
#define INCLUDE_IP_UTIL_H


#include "l7_cnfgr_api.h"
#include "ip_config.h"
#include "component_mask.h"
#include "async_event_api.h"
#include "rto_api.h"
#include "nimapi.h"



/*--------------------------------------*/
/*  IP MAP CONFIGURATOR PARMS           */
/*--------------------------------------*/


typedef enum {
  IPMAP_PHASE_INIT_0 = 0,
  IPMAP_PHASE_INIT_1,
  IPMAP_PHASE_INIT_2,
  IPMAP_PHASE_WMU,
  IPMAP_PHASE_INIT_3,
  IPMAP_PHASE_EXECUTE,
  IPMAP_PHASE_UNCONFIG_1,
  IPMAP_PHASE_UNCONFIG_2,
} ipMapCnfgrState_t;

/* Enum with power of 2 values to identify bits in a trace flag.
 * Used to turn on tracing for specific things of interest. */
typedef enum {

    /* Trace router events generated by IP MAP */
    IPMAP_TRACE_ROUTER_EVENTS = 0x1,

    /* Trace NIM events processed by IP MAP */
    IPMAP_TRACE_NIM_EVENTS = 0x2,

    /* Trace messages received by the IP MAP processing task */
    IPMAP_TRACE_PROC_TASK = 0x4,

    /* Trace route add, changes, and deletes to DTL. */
    IPMAP_TRACE_ROUTES = 0x8,

    /* Trace secondary interface commands. */
    IPMAP_TRACE_SECONDARY = 0x10,

    /* Trace changes to ARP GW table */
    IPMAP_TRACE_ARP_GW = 0x20,

    /* Trace software forwarding path */
    IPMAP_TRACE_FORWARDING = 0x40,

    /* Trace IP MAP read write lock */
    IPMAP_TRACE_LOCK = 0x80,

    /* Trace ARP events */
    IPMAP_TRACE_ARP = 0x100

} ipMapTraceFlag_t;

typedef enum 
{
  IPMAP_READ_LOCK = 0,
  IPMAP_WRITE_LOCK
} e_ipMapLockType;


#define IPMAP_IS_READY (((ipMapCnfgrState == IPMAP_PHASE_INIT_3) || \
                                           (ipMapCnfgrState == IPMAP_PHASE_EXECUTE) || \
                                           (ipMapCnfgrState == IPMAP_PHASE_UNCONFIG_1)) ? (L7_TRUE) : (L7_FALSE))

/* Max number of characters in an IP MAP trace message */
#define IPMAP_TRACE_LEN_MAX 255

/* max characters of function name stored in ipMapLockInfo. */
#define IPMAP_LOCK_HOLDER_NAME_MAX 64

/* max number of read locks recorded for debug purposes in ipMapLockInfo. */
#define IPMAP_READLOCK_REC_MAX 5

/* Time to wait for IP MAP lock. Milliseconds. */
#define IPMAP_LOCK_WAIT 30000

/*  IP Map Async Notify Types */
typedef enum {
    IPMAP_ASYNC_NOTIFY_TYPE_RTR = 1,
    IPMAP_ASYNC_NOTIFY_TYPE_NIM_INTF
}IPMAP_ASYNC_NOTIFY_TYPE_t;


typedef struct ipRoutingEventNotifyData_s
{

    L7_uint32    intIfNum;
    L7_uint32    event;
    void         *pData;
} ipRoutingEventNotifyData_t;

typedef struct ipIntfEventNotifyData_s
{

    L7_uint32    intIfNum;
    L7_uint32    event;
    NIM_CORRELATOR_t correlator;
} ipIntfEventNotifyData_t;



typedef struct ipAsyncNotificationData_t
{

    IPMAP_ASYNC_NOTIFY_TYPE_t                   eventType;          /* one of IPMAP_ASYNC_CHANGE_TYPE_t. */
    union
    {
        ipRoutingEventNotifyData_t   rtrInfo;
        ipIntfEventNotifyData_t      intfInfo;      /* Would really love for these to have the same type of data - Would simply IP as well as IGMP */
    } type;

} ipAsyncNotifyData_t;



/*--------------------------------------*/
/*  IP MAP MESSAGE PARMS                */
/*--------------------------------------*/



/*  IP Map Message IDs */
/* When modifying this list, also change ipMapProcMessageNames[]. */
typedef enum {
    IPMAP_NO_MSG = 0,
    IPMAP_PDU,
    IPMAP_ROUTER_ID_EVENT,
    IPMAP_RESTORE_EVENT,
    IPMAP_IP_ADDR_EVENT,
    IPMAP_CNFGR,
    IPMAP_INTF_CHANGE,
    IPMAP_ASYNC_EVENT_COMPLETE,
    IPMAP_RTO_EVENT,
    IPMAP_ARPGW_EVENT,
    IPMAP_LAST_MSG
 }IPMAP_MSG_ID_t;



typedef struct ipMapPduMsg_s
{
    L7_uint32       intf;             /* interface that received the packet  */
    L7_uint32       dtlIntf;          /* original DTL intf where pkt was rcvd*/
    L7_uint32       vlanId;
    L7_netBufHandle bufHandle;        /* buffer hanle                        */
} ipMapPduMsg_t;


typedef enum
{
  IPMAP_IP_ADDR_MSG_ADD = 1,
  IPMAP_IP_ADDR_MSG_DELETE

} IPMAP_IPADDR_MSG_TYPE_t;

typedef struct ipMapIPAddrEvent_s
{
    IPMAP_IPADDR_MSG_TYPE_t type;          /* one of IPMAP_IPADDR_MSG_TYPE_t */
    L7_uint32               intIfNum;      /* interface for which the change applied */
    L7_IP_ADDR_t            newIpAddress;  /* previous IP address - The new one is stored in the config structure */
    L7_IP_MASK_t            newSubnetMask; /* previous IP mask, - The new one is stored in the config structure */
    L7_IP_ADDR_t            oldIpAddress;  /* previous IP address - The new one is stored in the config structure */
    L7_IP_MASK_t            oldSubnetMask; /* previous IP mask, - The new one is stored in the config structure */
    L7_uint32               index;         /* index value to store the Secondary IP Address configuration */
} ipMapIPAddrEvent_t;



typedef struct ipMapRtrIntfModeEvent_s
{
    L7_uint32       intIfNum;        /* interface for which the change applied */
    L7_uint32       mode;            /* L7_ENABLE or L7_DISABLE */
} ipMapRtrIntfModeEvent_t;



typedef struct ipMapRtrIdEvent_s
{
    L7_uint32       routerId;
} ipMapRtrIdEvent_t;


typedef struct ipMapIntfChangeParms_s
{
  L7_uint32 intIfNum;
  L7_uint32 event;
  NIM_CORRELATOR_t correlator;
} ipMapIntfChangeParms_t;

typedef struct ipMapRtoEventMsg_s
{
    L7_routeEntry_t *routeEntry;

    /* Only RTO_ADD_ROUTE, RTO_DELETE_ROUTE, or RTO_CHANGE_ROUTE */
    RTO_ROUTE_EVENT_t route_status;

} ipMapRtoEventMsg_t;

typedef struct ipMapMsg_s
{
    L7_uint32       msgId;
    union
    {
      ipMapPduMsg_t             pdu;
      ipMapIPAddrEvent_t        addrEvent;
      ipMapRtrIntfModeEvent_t   modeEvent;
      ipMapRtrIdEvent_t         routerIdEvent;
      ipMapIntfChangeParms_t    intfChangeEvent;  
      ipMapRtoEventMsg_t        rtoEvent;
      ipAsyncNotifyData_t       asyncEvent;
      L7_CNFGR_CMD_DATA_t       CmdData;
    } type;
} ipMapMsg_t;

/* This structure is used by ip to receive callbacks regarding arp resolution of
   a requested next hop */
typedef struct ipMapArpCallback_s
{
  struct ipMapArpCallback_s  *next;     /* linked list chain ptr */
  L7_routeEntry_t routeEntry;           /* Used by the ip layer to store route information
                                           until all next hops have been resolved and
                                           the information can be propated to dtl */
  L7_uint32       numEntriesToResolve;  /* Number of entries that still need to be resolved
                                           before dtl may be called */
  L7_uint32       routeEvent;           /* Specifies the route change event that generated
                                           this arp resolution */
  L7_BOOL         deletePending;        /* Route was deleted while next hop gateway address
                                           was still being resolved */
} ipMapArpCallback_t;


/*--------------------------------------*/
/*  IP MAP QUEUES                       */
/*--------------------------------------*/

typedef enum 
{
  L7_L3_ARP_QUEUE = 0, 
  L7_L3_FWD_QUEUE = 1,
  L7_L3_FWDPRI_QUEUE = 2,
  L7_L3_FWDHIGHPRI_QUEUE = 3,
  L7_L3_FORWARD_QUEUE_COUNT = 4
} e_ForwardQueue;

#define IPMAP_ARP_QUEUE "ipMap_ARP_Queue"
#define IPMAP_ARP_MSG_COUNT  L7_MAX_NETWORK_BUFF_PER_BOX

#define IPMAP_FORWARD_QUEUE "ipMap_Fwd_Queue"
#define IPMAP_FWD_MSG_COUNT  L7_MAX_NETWORK_BUFF_PER_BOX

#define IPMAP_FWD_PRIORITY_QUEUE "ipMap_Fwd_Priority_Queue"
#define IPMAP_FWD_PRIORITY_MSG_COUNT  L7_MAX_NETWORK_BUFF_PER_BOX

#define IPMAP_FWD_HIGHPRIORITY_QUEUE "ipMap_Fwd_HighPriority_Queue"
#define IPMAP_FWD_HIGHPRIORITY_MSG_COUNT  L7_MAX_NETWORK_BUFF_PER_BOX

/* IP MAP processing thread receives messages for configurator events,
 * configuration events, router event completion, NIM events, and
 * notification of best route changes. Make queue proportional to 
 * number of interfaces. */
#define IPMAP_PROCESS_QUEUE "ipMap_Process_Queue"
#define IPMAP_PROC_MSG_COUNT (3 * platIntfTotalMaxCountGet())

#define IPMAP_MSG_SIZE   sizeof(ipMapMsg_t)

#define IPMAP_MAX_ARP_CALLBACK_BUFFERS   200



/*--------------------------------------*/
/*  IP MAP TIMERS                       */
/*--------------------------------------*/

#define IPMAP_TASK_TIMER    1000   /*ms*/
#define IPMAP_IP_CFG_TIMER    50   /*ms*/


/*---------------------------*/
/* IP INFORMATION STRUCTURES */
/*---------------------------*/

typedef struct L7_rtrInterface_s
{
  L7_BOOL             present;
  L7_uint32           intIfNum;

} L7_rtrIntfMap_t;

typedef struct ipMapOper_s     
{
  /* The last global router event sent by IP MAP. */
  L7_RTR_EVENT_CHANGE_t lastNotify;

  /* Whether a global asynchronous event is in progress. That is, whether
   * IP MAP is still waiting for a response from one or more router event
   * clients. */
  L7_BOOL asyncPending;

} ipMapOper_t;

typedef struct ipMapOperRtrIntf_s
{
  /* The last router event IP MAP sent for an interface. */
  L7_RTR_EVENT_CHANGE_t lastNotify;       

  /* L7_TRUE if an asynchronous router event is pending on an interface. */
  L7_BOOL asyncPending;

  /* Whether IP MAP has told the IP stack to enable this interface. This is
   * true after IP MAP sends a L7_RTR_INTF_ENABLE for the interface, and remains
   * true until IP MAP sends a L7_RTR_INTF_DISABLE. */
  L7_BOOL stackEnabled;

  /* ROBRICE - keep? */
  L7_uint32 operLastChanged;  /* sysUpTime at change */

  /* When IP MAP defers its response to NIM for an interface event, response
   * information is stored here. */
  ipMapIntfChangeParms_t nimParms;         

} ipMapOperRtrIntf_t;

typedef struct ipMapInfo_s
{
    /* Timer that tells IP MAP to request best route changes from RTO. */
    osapiTimerDescr_t *bestRouteTimer;

    /* Global router event state information. */
    ipMapOper_t             operRtr;

    /* Interface specific router event state information. Indexed by 
     * internal interface number. */
    ipMapOperRtrIntf_t      operIntf[L7_IPMAP_INTF_MAX_COUNT];

    ASYNC_EVENT_HANDLER_t   eventHandlerId;
    asyncEventHandler_t     eventHandler;
    COMPONENT_MASK_t        registeredComponents;
    /* Timer to fill the token bucket with the configured number of tokens.
     for ex: for every 1 sec send_count will be initialized to 100.*/
    osapiTimerDescr_t *icmpRateLimitTimer;
    L7_uint32 send_count; /* Number of ICMP error packets can be send */

} ipMapInfo_t;

typedef struct ipMapLockHolderName_s
{
  /* function name of lock holder */
  L7_uchar8 fName[IPMAP_LOCK_HOLDER_NAME_MAX];
} ipMapLockHolderName_t;

/* Status of ipRwLock. Assumes lock taken and given in same function.
 * Used for debugging. */
typedef struct ipMapLockInfo_s
{
  /* Function name where write lock currently held. When no write 
   * lock is taken, name is the empty string. */
  ipMapLockHolderName_t writeLockHolder;

  /* Function name where read locks currently held. Can be multiple outstanding
   * read locks. We'll record up to 5 readers. */
  ipMapLockHolderName_t readLockHolder[IPMAP_READLOCK_REC_MAX];

  L7_uint32 writeTakeAttempts;
  L7_uint32 writeTakeFailures;
  L7_uint32 writeGiveAttempts;
  L7_uint32 writeGiveFailures;
  L7_uint32 readTakeAttempts;
  L7_uint32 readTakeFailures;
  L7_uint32 readGiveAttempts;
  L7_uint32 readGiveFailures;

} ipMapLockInfo_t;


typedef struct ipMapIntfInfo_s
{
    L7_BOOL         intfAcquired;   /* Interface has been "acquired" by another component -
                                       It is not available for routing */
    AcquiredMask    acquiredList;   /* Mask of components "acquiring" an interface */
} ipMapIntfInfo_t;


/* VLAN Interfaces */


typedef struct vlanIntfData_s
{
  L7_uint32 vlanId;
  L7_uint32 intIfNum;
  L7_uint32 intfState;
  L7_BOOL   vlanExists;
}vlanIntfData_t;


/****************************************
*
*  DEBUGGING MACROS, FUNCTION PROTOTYPES
*
*****************************************/

/* Usage Note:
   To toggle between logging and printf modes,
   comment or uncomment the following #define.

*/
#define IPMAP_DEBUG_LOG



#ifdef IPMAP_DEBUG_LOG


#define IPMAP_TRACE(format,args...)                         \
{                                                           \
   if ( ipMapTraceModeGet() == L7_ENABLE)                   \
   {                                                        \
      LOG_COMPONENT_MSG(L7_IP_MAP_COMPONENT_ID,format,##args);  \
   }                                                        \
}

#define IPMAP_ERROR_SEVERE(format,args...)                  \
{                                                           \
      LOG_COMPONENT_MSG(L7_IP_MAP_COMPONENT_ID,format,##args);  \
}


#define IPMAP_ERROR(format,args...)                         \
{                                                           \
   if ( ipMapCfg->rtr.rtrAdminMode == L7_ENABLE)                \
   {                                                        \
      LOG_COMPONENT_MSG(L7_IP_MAP_COMPONENT_ID,format,##args);  \
   }                                                        \
}

#else

#define IPMAP_TRACE(format,args...)                         \
{                                                           \
   if ( ipMapTraceModeGet() == L7_ENABLE)                   \
   {                                                        \
      SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_IPMAP,format,##args);    \
   }                                                        \
}

#define IPMAP_ERROR_SEVERE(format,args...)                      \
{                                                               \
      SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_IPMAP_ERROR,format,##args);  \
}



#define IPMAP_ERROR(format,args...)                         \
{                                                           \
   if ( ipMapTraceModeGet() == L7_ENABLE)                   \
   {                                                        \
      SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_IPMAP,format,##args);    \
   }                                                        \
}
#endif

 
#define IPMAP_USER_TRACE(__fmt__, __args__... )                              \
  if (1)                          \
{                                                                 \
  LOG_USER_TRACE(L7_IP_MAP_COMPONENT_ID, __fmt__,##__args__);        \
}

/* Debugging prototypes */
void ipMapTraceLinkerAssist(void);


/****************************************
*
*  IP Internal function defines
*
*****************************************/

/*-------------------------------------------------------------*/
/*                           ipmap.c                           */
/*-------------------------------------------------------------*/
L7_RC_t ipStartTasks(void);
L7_RC_t ipSave(void);

/*********************************************************************
* @purpose  Build default ip config data
*
* @param    ver   @b{(input)} Software version of Config Data
*
* @returns  void
*
* @notes    none
*
* @end
*********************************************************************/
void    ipBuildDefaultConfigData(L7_uint32 ver);

/*********************************************************************
* @purpose  Migrate old config to new
*
* @param    oldVer      @b{(input)} version of old config definition
* @param    ver         @b{(input)} version of current config definition
* @param    pCfgBuffer  @b{(input)} ptr to location of read configuration
*
* @returns  void
*
* @notes    This is the callback function provided to the sysapiCfgFileGet
*           routine to handle cases where the config file is of an older
*           version.
*
* @notes
*
* @end
*********************************************************************/
void ipStaticRtsMigrateConfigData (L7_uint32 oldVer, L7_uint32 ver, L7_char8 * pCfgBuffer);

/*********************************************************************
* @purpose  Migrate old config to new
*
* @param    oldVer      @b{(input)} version of old config definition
* @param    ver         @b{(input)} version of current config definition
* @param    pCfgBuffer  @b{(input)} ptr to location of read configuration
*
* @returns  void
*
* @notes    This is the callback function provided to the sysapiCfgFileGet
*           routine to handle cases where the config file is of an older
*           version.
*
* @notes
*
* @end
*********************************************************************/
void ipStaticArpMigrateConfigData (L7_uint32 oldVer, L7_uint32 ver, L7_char8 * pCfgBuffer);

/*********************************************************************
* @purpose  Migrate old config to new
*
* @param    oldVer      @b{(input)} version of old config definition
* @param    ver         @b{(input)} version of current config definition
* @param    pCfgBuffer  @b{(input)} ptr to location of read configuration
*
* @returns  void
*
* @notes    This is the callback function provided to the sysapiCfgFileGet
*           routine to handle cases where the config file is of an older
*           version.
*
* @notes
*
* @end
*********************************************************************/
void ipmapMigrateConfigData (L7_uint32 oldVer, L7_uint32 ver, L7_char8 * pCfgBuffer);

void ipIntfBuildDefaultConfigData(nimConfigID_t *configId, L7_rtrCfgCkt_t *pCfg);
void ipStaticRtsBuildDefaultConfigData(L7_uint32 ver);
void ipStaticArpBuildDefaultConfigData(L7_uint32 ver);
L7_RC_t ipMapApplyConfigData(void);
L7_RC_t ipMapIntfCreate(L7_uint32 intIfNum, L7_uint32 *eventCompleted);
L7_RC_t ipMapIntfDelete(L7_uint32 intIfNum, L7_uint32 *eventCompleted);
L7_RC_t ipMapIntfChangeCallback (L7_uint32 intIfNum, L7_uint32 event,NIM_CORRELATOR_t correlator);
L7_RC_t ipMapIntfChangeProcess (L7_uint32 intIfNum, L7_uint32 event,NIM_CORRELATOR_t correlator);
L7_RC_t ipMapRouteEntryAdd(L7_routeEntry_t *pRouteEntry);
L7_RC_t ipMapRouteEntryModify(L7_routeEntry_t *pRouteEntry);
L7_RC_t ipMapRouteEntryDelete(L7_routeEntry_t *pRouteEntry);
L7_RC_t ipMapArpEntryAdd(L7_arpEntry_t *pArpEntry);
L7_RC_t ipMapArpEntryModify(L7_arpEntry_t *pArpEntry);
L7_RC_t ipMapArpEntryDelete(L7_arpEntry_t *pArpEntry);
void ipMapForwardingTask(void);
void ipMapProcessingTask(void);
L7_RC_t ipMapPduRcv(ipMapMsg_t *msg);
void ipMapAdminModeProcess(L7_uint32 mode);
L7_RC_t ipMapRtrIntfIpAddressAddProcess(L7_uint32 intIfNum,
                                        L7_uint32 newIpAddr,L7_uint32 newIpMask);
L7_RC_t ipMapRtrIntfIpAddressRemoveProcess(L7_uint32 intIfNum);
L7_RC_t ipMapRtrIntfSecondaryIpAddrAddProcess(L7_uint32 intIfNum, L7_uint32 ipAddr,
                                           L7_uint32 ipMask, L7_uint32 index);
L7_RC_t ipMapRtrIntfSecondaryIpAddrRemoveProcess(L7_uint32 intIfNum, L7_uint32 ipAddr,
                                              L7_uint32 ipMask, L7_uint32 index);
void ipMapRestoreProcess(void);
void ipMapAsyncEventCompleteProcess(ipAsyncNotifyData_t *pAsyncEvent);
void ipMapStaticTosRouteSubsystemCreate(L7_uint32 ifNum,
                        L7_uint32 network,
                        L7_uint32 netmask,
                        L7_uint32 gateway,
                        L7_uint32 type_of_service);
void ipMapStaticTosRouteSubsystemDelete(L7_uint32 ifNum,
                        L7_uint32 network,
                        L7_uint32 netmask,
                        L7_uint32 gateway,
                        L7_uint32 type_of_service);
L7_RC_t ipMapRtoRouteChangeProcess(L7_routeEntry_t *routeEntry,
                                   RTO_ROUTE_EVENT_t route_status);
void ipMapRouteCallback();
void ipMapIcmpRatelimitTimerStop(void);
void ipMapIcmpRatelimitTimerStart(void);
void ipMapIcmpRatelimitTimerCb(void);
L7_BOOL isRateLimitTimerNull(void);
L7_uint32 ipMapIcmpRatelimitSendCountGet(void);
void ipMapIcmpRatelimitSendCountDec(void);
void ipMapDebugIcmpRatelimitSendCount(void);
L7_RC_t ipMapBestRoutesGet(void);
void ipMapBestRouteTimerCb(void);
L7_RC_t ipMapBufferPoolCreate();
L7_uint32 ipMapAsyncNotifyPoolIdGet (void);
void ipMapBufferPoolDelete();
L7_BOOL ipMapMapIntfIsConfigurable(L7_uint32 intIfNum, L7_rtrCfgCkt_t **pCfg);
L7_BOOL ipMapMapIntfConfigEntryGet(L7_uint32 intIfNum, L7_rtrCfgCkt_t **pCfg);

#ifdef L7_QOS_FLEX_PACKAGE_ACL
/*********************************************************************
 * @purpose  Saves IPMAP debug configuration
 *
 * @param    void
 *
 * @returns  L7_SUCCESS
 * @returns  L7_FAILURE
 *
 * @notes    ipMapDebugCfg is the overlay
 *
 * @end
 *********************************************************************/
L7_RC_t ipMapDebugSave(void);

/*********************************************************************
 * @purpose  Restores ip debug configuration
 *
 * @param    void
 *
 * @returns  L7_SUCCESS
 * @returns  L7_FAILURE
 *
 * @notes    ipMapDebugCfg is the overlay
 *
 * @end
 *********************************************************************/
L7_RC_t ipMapDebugRestore(void);

/*********************************************************************
 * @purpose  Checks if ip debug config data has changed
 *
 * @param    void
 *
 * @returns  L7_TRUE or L7_FALSE
 *
 * @notes    none
 *
 * @end
 *********************************************************************/
L7_BOOL ipMapDebugHasDataChanged(void);

/*********************************************************************
 * @purpose  Build default ipMap debug config data
 *
 * @param    ver   Software version of Config Data
 *
 * @returns  void
 *
 * @notes
 *
 * @end
 *********************************************************************/
void ipMapDebugBuildDefaultConfigData(L7_uint32 ver);

/*********************************************************************
 * @purpose  Apply ip debug config data
 *
 * @param    void
 *
 * @returns  L7_SUCCESS/L7_FAILURE
 *
 * @notes    Called after a default config is built
 *
 * @end
 *********************************************************************/
L7_RC_t ipMapApplyDebugConfigData(void);
/*********************************************************************
 * @purpose  Restore and Apply ip debug config data
 *
 * @param    void
 *
 * @returns  L7_SUCCESS/L7_FAILURE
 *
 * @notes    Called after a default config is built
 *
 * @end
 *********************************************************************/
L7_RC_t ipMapRestoreDebugConfigData(void);
#endif

/*-------------------------------------------------------------*/
/*                           iputil.c                          */
/*-------------------------------------------------------------*/
/* Apply routines associated with Set routines */
L7_RC_t ipMapIpSpoofingModeApply(L7_uint32 mode);
L7_RC_t ipMapIpArpAgeTimeApply(L7_uint32 arpAgeTime);
L7_RC_t ipMapIpArpRespTimeApply(L7_uint32 arpRespTime);
L7_RC_t ipMapIpArpRetriesApply(L7_uint32 arpRetries);
L7_RC_t ipMapIpArpCacheSizeApply(L7_uint32 arpCacheSize);
L7_RC_t ipMapIpArpDynamicRenewApply(L7_uint32 arpDynamicRenew);
L7_RC_t ipMapIpSourceCheckingApply(L7_uint32 mode);
L7_RC_t ipMapIntfMaxIpMtu(L7_uint32 intIfNum, L7_uint32 *maxIpMtu);
L7_RC_t ipMapRtrAdminModeEnable(void);
L7_RC_t ipMapRtrAdminModeDisable(void);
L7_RC_t ipMapRtrForwardingModeApply(L7_uint32 mode);
L7_RC_t ipMapRtrTosForwardingModeApply(L7_uint32 mode);
L7_RC_t ipMapRtrEcmpModeApply(L7_uint32 mode);
L7_RC_t ipMapRtrICMPRedirectModeApply(L7_uint32 mode);
L7_RC_t ipMapRtrICMPRatelimitApply (L7_uint32 burstSize, L7_uint32 rateInterval);
L7_RC_t ipMapRtrICMPEchoReplyModeApply (L7_uint32 mode);
L7_RC_t ipMapRtrBootpDhcpRelayModeApply(L7_uint32 mode, L7_IP_ADDR_t ipAddr);
L7_RC_t ipMapRtrBootpDhcpRelayServerApply(L7_uint32 mode,
                                               L7_IP_ADDR_t ipAddress);

L7_RC_t ipMapIntfUpdate(L7_uint32 intIfNum, L7_uint32 *eventCompleted);
L7_BOOL ipMapMayEnableInterface(L7_uint32 intIfNum);
L7_RC_t ipMapDtlIpIntfSet(L7_uint32 intIfNum);
L7_RC_t ipMapRtrIntfIpAddressRemoveApply(L7_uint32 intIfNum);
L7_RC_t ipMapIntfIpMtuApply(L7_uint32 intIfNum, L7_uint32 ipMtu);
L7_RC_t ipMapIntfIpUnreachablesModeApply(L7_uint32 intIfNum, L7_uint32 mode);
L7_RC_t ipMapIntfIpRedirectsModeApply (L7_uint32 intIfNum, L7_uint32 mode);
L7_RC_t ipMapIntfBandwidthApply(L7_uint32 intIfNum, L7_uint32 bandwidth);
L7_RC_t ipMapv6IntfBandwidthApply(L7_uint32 intIfNum, L7_uint32 bandwidth);
L7_RC_t ipMapRtrIntfNetDirectBcastsApply( L7_uint32 intIfNum, L7_uint32 mode);
L7_RC_t ipMapRtrIntfMcastFwdModeApply(L7_uint32 intIfNum, L7_uint32 mode);
L7_RC_t ipMapStaticArpAddApply(L7_IP_ADDR_t ipAddress, L7_uint32 intIfNum, L7_linkLayerAddr_t *pLLAddr );
L7_RC_t ipMapStaticArpDeleteApply(L7_IP_ADDR_t ipAddress, L7_uint32 intIfNum);
L7_RC_t ipMapIpDefaultTTLApply(L7_uint32 ttl);
void ipMapMartianAddrsInstall(void);
void ipMapMartianAddrsRemove(void);

L7_RC_t _ipMapIntIfNumToRtrIntf(L7_uint32 intIfNum, L7_uint32 *rtrIfNum);

/* Others */
L7_BOOL ipMapHasDataChanged(void);
void ipMapResetDataChanged(void);
L7_RC_t ipMapRoutingEventChangeNotify(L7_uint32 intIfNum, L7_uint32 event,
                                      L7_BOOL isAsync, void *pData);
void ipMapAsyncEventCompleteNotify(ASYNC_EVENT_COMPLETE_INFO_t *pComplete,
                                   COMPONENT_MASK_t *pRemainingMask,
                                   COMPONENT_MASK_t *pFailingMask);
void ipMapAsyncEventCompleteQueue( ipAsyncNotifyData_t *pEventData);
L7_RC_t ipMapIpForwardingStackInit();

void ipResetTables(void);
e_ForwardQueue ipMapQueuePriority(L7_uchar8 protocol, 
                                  L7_ushort16 sourcePort, L7_ushort16 destPort);
void ipMapIntfStaticArpDelete(L7_uint32 intIfNum);
L7_BOOL ipMapIntfIsAttached(L7_uint32 intIfNum);
L7_RC_t ipMapIntfChangeNimNotify(L7_uint32 intIfNum, L7_uint32 event,
                                 NIM_NOTIFY_CB_FUNC_t callback,
                                 NIM_HANDLE_t *handle);
void ipMapTraceWrite(L7_uchar8 *traceMsg);
L7_RC_t ipMapRtrIntfSecondaryIpAddressApply(L7_uint32 intIfNum, L7_uint32 ipAddr,
                                            L7_uint32 ipMask, L7_uint32 index);
void ipMapRtrIntfStaticConfigApply(L7_IP_ADDR_t ipAddr, L7_IP_MASK_t ipMask, L7_uint32 intIfNum);
L7_RC_t ipMapRtrIntfSecondaryIpAddressRemoveApply(L7_uint32 intIfNum, L7_uint32 ipAddr,
                                                  L7_uint32 ipMask, L7_uint32 index);
void ipMapRtrIntfStaticConfigRemoveApply(L7_IP_ADDR_t ipAddr, L7_IP_MASK_t ipMask, L7_uint32 intIfNum);
L7_uint32 ipMapNumberedIfc(L7_uint32 intIfNum);
L7_BOOL _ipMapIntfIsUnnumbered(L7_uint32 intIfNum);
L7_RC_t ipMapNumberedIfcBind(L7_uint32 intIfNum, L7_uint32 numberedIfc);
L7_uint32 _ipMapBorrowedAddr(L7_uint32 intIfNum);
L7_RC_t ipMapRtrIntfIpAddressValidityCheck(L7_IP_ADDR_t ipAddress,
                                           L7_IP_MASK_t subnetMask);
L7_BOOL ipMapMgmtPortConflict(L7_uint32 intIfNum, L7_IP_ADDR_t ipAddress,
                              L7_IP_MASK_t subnetMask);
L7_BOOL ipMapRtrIntfAddressConflictFind(L7_uint32 intIfNum, 
                                        L7_IP_ADDR_t ipAddress,
                                        L7_IP_MASK_t subnetMask);
L7_RC_t ipMapStaticArpIpAddressConflictCheck(L7_IP_ADDR_t ipAddress);
L7_BOOL ipMapIntfIsUp(L7_uint32 intIfNum);
L7_BOOL ipMapIntfAddrInSubnet(L7_uint32 intIfNum, L7_uint32 ipAddr, L7_uint32 ipMask);
L7_RC_t _ipMapRouterIfResolve(L7_IP_ADDR_t ipAddr, L7_uint32 *intIfNum);
L7_BOOL _ipMapRtrIntfConfigured(L7_uint32 intIfNum);
L7_RC_t _ipMapIpAddressToIntf(L7_IP_ADDR_t ipAddr, L7_uint32 *intIfNum);
L7_RC_t ipMapRtrIntfDataGet( L7_uint32 intIfNum, dtlRtrIntfDesc_t *ipCircuitDesc);
L7_RC_t ipMapCheckIfNumber(L7_uint32 rtrIfNum);
L7_RC_t ipMapLockTake(e_ipMapLockType lockType, const L7_int32 wait, 
                      const L7_uchar8 *lockHolder);
L7_RC_t ipMapLockGive(e_ipMapLockType lockType, const L7_uchar8 *lockHolder);
L7_RC_t ipMapStaticRejectRoutesAdd(void);
L7_RC_t ipMapStaticRejectRoutesRemove(void);
L7_RC_t ipMapSubnetStaticRoutesRemove(L7_uint32 intIfNum, L7_IP_ADDR_t ipAddr, L7_IP_MASK_t ipMask);
L7_RC_t ipMapSubnetLocalRouteRemove(L7_uint32 ipAddr, L7_uint32 ipMask);

/*-------------------------------------------------------------*/
/*                   ipmap_cnfgr.c                             */
/*-------------------------------------------------------------*/
L7_RC_t ipMapInit(L7_CNFGR_CMD_DATA_t *pCmdData);
void ipMapInitUndo();
L7_RC_t ipMapCnfgrInitPhase1Process( L7_CNFGR_RESPONSE_t *pResponse,
                                     L7_CNFGR_ERR_RC_t   *pReason );
L7_RC_t ipMapCnfgrInitPhase2Process( L7_CNFGR_RESPONSE_t *pResponse,
                                     L7_CNFGR_ERR_RC_t   *pReason );

L7_RC_t ipMapCnfgrInitPhase3Process( L7_CNFGR_RESPONSE_t *pResponse,
                                     L7_CNFGR_ERR_RC_t   *pReason );
void ipMapCnfgrFiniPhase1Process();
void ipMapCnfgrFiniPhase2Process();
void ipMapCnfgrFiniPhase3Process();
L7_RC_t ipMapCnfgrNoopProccess( L7_CNFGR_RESPONSE_t *pResponse,
                                L7_CNFGR_ERR_RC_t   *pReason );
L7_RC_t ipMapCnfgrUconfigPhase2( L7_CNFGR_RESPONSE_t *pResponse,
                                 L7_CNFGR_ERR_RC_t   *pReason );
void ipMapCnfgrParse(L7_CNFGR_CMD_DATA_t *pCmdData);

/*-------------------------------------------------------------*/
/*                   ipmap_static.c                            */
/*-------------------------------------------------------------*/
L7_BOOL ipMapSrMultipleNextHops(L7_rtrStaticRouteCfgData_t *staticRoute);
L7_BOOL ipMapDefaultRouteConfigured(void);
L7_RC_t ipMapSrNextHopPrefSet(L7_rtrStaticRouteCfgData_t *staticRoute,
    L7_uint32 nextHop, nimConfigID_t *intfConfigId, L7_uint32 pref);
L7_RC_t ipMapSrPrefSet(L7_rtrStaticRouteCfgData_t *staticRoute, L7_uint32 pref);
L7_RC_t ipMapSrNextHopAdd(L7_rtrStaticRouteCfgData_t *staticRoute,
                          L7_uint32 nextHop, nimConfigID_t *intfConfigId);
L7_RC_t ipMapSrNextHopRemove(L7_rtrStaticRouteCfgData_t *staticRoute,
                             L7_uint32 nextHop, nimConfigID_t *intfConfigId);
L7_rtrStaticRouteCfgData_t* ipMapSrFind(L7_uint32 ipAddr, L7_uint32 subnetMask);
L7_rtrStaticRouteCfgData_t*ipMapSrNextHopFind(L7_uint32 ipAddr, 
    L7_uint32 subnetMask, L7_uint32 nextHop, nimConfigID_t *intfConfigId);
L7_rtrStaticRouteCfgData_t* ipMapSrPrefFind(L7_uint32 ipAddr,
    L7_uint32 subnetMask, L7_uint32 pref);
L7_rtrStaticRouteCfgData_t* ipMapSrRejectFind(L7_uint32 ipAddr,
                                              L7_uint32 subnetMask);
L7_RC_t ipMapSrAdd(L7_uint32 ipAddr, L7_uint32 subnetMask,
    L7_uint32 nextHop, nimConfigID_t *intfConfigId, L7_uint32 pref);
L7_RC_t ipMapSrDelete(L7_uint32 ipAddr, L7_uint32 subnetMask);
L7_RC_t ipMapSrRejectDelete(L7_uint32 ipAddr, L7_uint32 subnetMask);
L7_RC_t ipMapSrEntryCreate(L7_rtrStaticRouteCfgData_t *staticRoute,
                           L7_routeEntry_t *routeEntry);
L7_RC_t ipMapSrInterfaceEnable(L7_uint32 intIfNum);
L7_RC_t ipMapSrNextHopsMerge(L7_rtrStaticRouteCfgData_t *sourceStaticRoute,
                             L7_rtrStaticRouteCfgData_t *targetStaticRoute);
L7_BOOL ipMapSrNextHopIpAddressConflictCheck(L7_uint32 ipAddr);

#endif /* INCLUDE_IP_UTIL_H */

