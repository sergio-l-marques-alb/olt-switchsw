/*********************************************************************
*
* (C) Copyright Broadcom Corporation 2002-2007
*
**********************************************************************
* @filename dot1s_ih.c
*
* @purpose Multiple Spanning tree Interface Handler
*
* @component dot1s
*
* @comments none
*
* @create 10/14/2002
*
* @author skalyanam
*
* @end
*             
**********************************************************************/

#include "dot1s_include.h"

static L7_ushort16 VIDList[L7_MAX_VLANS + 1];
extern dot1sDeregister_t dot1sDeregister;
extern dot1sCnfgrState_t dot1sCnfgrState;
extern L7_uint32 *dot1sMapTbl;
extern dot1sCfg_t *dot1sCfg;
/* dot1s/driver async task parameters */
extern dot1sStateCirBuf_t *dot1sCB;
extern void * dot1sStateSetSema;
extern osapiTimerDescr_t        *dot1sStateSetTimer;
static L7_uint32 dot1sCBHead = 0;
static L7_uint32 dot1sCBTail = 0;
static L7_ushort16 dot1sMPC = 0;
static L7_ushort16 dot1sNEC = 1;
static L7_uint32 dot1sNECRollover = 0;
static L7_uint32 dot1sMPCRollover = 0;

static L7_uint32  dot1s_num_port_events_pending = 0;
static void * port_event_mutex = 0;
extern void *dot1sTaskSyncSema;

/*********************************************************************
* @purpose  Return the number of port events issued by dot1s 
*           that are pending in the system.
*
* @param    none
*
* @returns  none
* 
* @comments none
*       
* @end
*********************************************************************/
L7_uint32 dot1sIhNimEventPendingGet (void)
{
  return dot1s_num_port_events_pending;
}

/*********************************************************************
* @purpose  Callback from NIM indicating that port event processing 
*           is done.
*
* @param    none
*
* @returns  none
* 
* @comments none
*       
* @end
*********************************************************************/
static void dot1sIhNimCallback (NIM_NOTIFY_CB_INFO_t retVal)
{
  osapiSemaTake (port_event_mutex, L7_WAIT_FOREVER);
  dot1s_num_port_events_pending--;
  osapiSemaGive (port_event_mutex);
}

/*********************************************************************
* @purpose  Notifies the system of a particular event regarding an 
* @purpose  interface
*
* @param    intIfNum @b{(input)} internal interface number
* @param    intIfEvent @b{(input)} one of L7_PORT_EVENTS_t
* @param    @b{(output)}
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
* 
* @comments this notification is sent to NIM which in turn passes it 
*           to all the registered routines
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhNotifySystem(L7_uint32 intIfNum, L7_uint32 intIfEvent)
{
  L7_RC_t rc = L7_FAILURE;
  NIM_HANDLE_t           handle;
  NIM_EVENT_NOTIFY_INFO_t eventInfo;

  if (port_event_mutex == 0)
  {
    port_event_mutex = osapiSemaMCreate (OSAPI_SEM_Q_FIFO);
  }

  osapiSemaTake (port_event_mutex, L7_WAIT_FOREVER);
  dot1s_num_port_events_pending++;
  osapiSemaGive (port_event_mutex);

  eventInfo.component     = L7_DOT1S_COMPONENT_ID;
  eventInfo.pCbFunc       = dot1sIhNimCallback;
  eventInfo.event         = intIfEvent;
  eventInfo.intIfNum      = intIfNum;

  rc = nimEventIntfNotify(eventInfo,&handle);

  return rc;
}

/*********************************************************************
* @purpose  Handles events generated by NIM
*
* @param    intIfNum @b{(input)} interface number
* @param    intIfEvent @b{(input)} interface event 
* @param    @b{(output)}
*
* @returns  
*
* @comments    
*       
* @end
*********************************************************************/
L7_RC_t dot1sIntfChangeCallBack(L7_uint32 intIfNum, L7_uint32 intIfEvent,NIM_CORRELATOR_t correlator)
{
  L7_RC_t rc = L7_FAILURE;
  NIM_EVENT_COMPLETE_INFO_t status;    

  status.intIfNum     = intIfNum;
  status.component    = L7_DOT1S_COMPONENT_ID;
  status.response.rc  = L7_SUCCESS;
  status.response.reason = NIM_ERR_RC_UNUSED;
  status.event        = intIfEvent;
  status.correlator   = correlator;

  if (dot1sDeregister.dot1sIntfChangeCallback == L7_TRUE)
  {
	LOG_MSG("dot1sIntfCallback is deregistered\n");
	nimEventStatusCallback(status);
	return L7_FAILURE;
  }
  if (!(DOT1S_IS_READY))
  {
	LOG_MSG("Received a interface callback while outside the EXECUTE state");
	nimEventStatusCallback(status);
    return L7_FAILURE;
  }
/* If this is an event that we are not interested in, perform early return*/
  if (intIfEvent != L7_CREATE &&
      intIfEvent != L7_DELETE &&
      intIfEvent != L7_UP &&
      intIfEvent != L7_PORT_ENABLE &&
      intIfEvent != L7_DETACH &&
      intIfEvent != L7_DOWN &&
      intIfEvent != L7_PORT_DISABLE &&
      intIfEvent != L7_LAG_ACQUIRE &&
      intIfEvent != L7_LAG_RELEASE &&
      intIfEvent != L7_PORT_ROUTING_ENABLED &&
      intIfEvent != L7_PORT_ROUTING_DISABLED &&
      intIfEvent != L7_PROBE_SETUP &&
      intIfEvent != L7_PROBE_TEARDOWN &&
      intIfEvent != L7_SPEED_CHANGE &&
      intIfEvent != L7_FORWARDING &&
      intIfEvent != L7_NOT_FORWARDING
      )
  {
    nimEventStatusCallback(status);
    return L7_SUCCESS;
  }
  rc = dot1sIssueCmd(dot1sIntfChange, intIfNum, L7_NULL, /*&intIfEvent*/&status);

  return rc;
}

/*********************************************************************
* @purpose  Process Link state changes   
*
* @param    intIfnum @b{(input)} interface number
* @param    intIfEvent @b{(input)} interface event
* @param    @b{(output)}
*
* @returns  L7_SUCCESS
* @returns  L7_FALIURE
*
* @comments    
*       
* @end
*********************************************************************/
L7_uint32 dot1sIhProcessIntfChange(L7_uint32 intIfNum, NIM_EVENT_COMPLETE_INFO_t status)
{
  L7_uint32 currAcquired, prevAcquired;
  L7_uint32 adminState, instIndex;
  L7_uint32 linkState;
  L7_RC_t rc;
#ifdef OBSELETE
  L7_INTF_TYPES_t type;
#endif
  L7_uint32 intIfEvent;
  L7_uint32 prevLagAcquired, prevIpMapAcquired;
  DOT1S_PORT_COMMON_t *p;

  if (dot1sIsValidIntf(intIfNum) == L7_FALSE)
  {
    rc = L7_SUCCESS;
    status.response.rc = rc;
    nimEventStatusCallback(status);
    return rc;
  }

  intIfEvent = status.event;

  if (nimCheckIfNumber(intIfNum) == L7_SUCCESS)
  {
    rc = nimGetIntfAdminState(intIfNum, &adminState);
  }
  else
  {
    LOG_MSG("Invalid intIfNum");
    status.response.rc = L7_SUCCESS;
    nimEventStatusCallback(status);
    return L7_SUCCESS;
  }

  switch (intIfEvent)
  {
	case L7_CREATE:
	  #ifdef OBSELETE
      /* We need to look out for L7CREATES of LAG interfaces.
	   * This is neccessary as dot3ad creates these interface
	   * and it inits after dot1s. Hence when dot1s builds defaults
	   * and queries nim, nim returns only with 
	   * phy interfaces as at that time LAG interfaces have not 
	   * yet been created. So when these interfaces are created 
	   * we must rebuild the the config file (unless there is saved config)
	   * and update the dot1s port structure for these 'lagging' 
	   * LAG interfaces
	   */
	  rc = nimGetIntfType(intIfNum,&type);
      if (type == L7_LAG_INTF)
      {
        rc = dot1sLagIntfInit(intIfNum);
      }
	  #endif
	  rc = dot1sIntfCreate(intIfNum);
      if (rc != L7_SUCCESS)
      {
          dot1sPort[intIfNum].notParticipating = L7_TRUE;
      }
      break;

	case (L7_DELETE):
	  rc = dot1sIntfDelete(intIfNum);
	  break;

	case (L7_ATTACH):
      /* dot1s is not interested in attach
	   * It achives this by looking at L7_UP
	   * the protocol is enabled or disabled under these 
	   * port events based on adminModes etc.
	   */
      break;

    case (L7_UP):
      /* if port already known as up then nothing to do */
      if (dot1sPort[intIfNum].portLinkState != L7_UP)
      {
        dot1sPort[intIfNum].portLinkState = L7_UP;
        if (dot1sPort[intIfNum].portEnabled == L7_TRUE)
        {
          dot1sPort[intIfNum].portUpEnabledNum = dot1sPort[intIfNum].portNum;
        }

        if (adminState == L7_ENABLE)
        {
          /* are link transition being ignored */
          if (dot1sPort[intIfNum].ignoreLinkStateChanges == L7_FALSE)
          { 
            /* is MSTP Enabled */
            if (dot1sBridge->Mode == L7_ENABLE)
            {
              if (dot1sPort[intIfNum].notParticipating == L7_TRUE)
              {
                /* notParticipating */
                /* set port state to manual forwarding */
                dot1sIhSetPortState(L7_DOT1S_MSTID_ALL, intIfNum, L7_DOT1S_MANUAL_FWD);
              }
              else                                                            
              {
			    /* port is Participating (ie; not notParticipating) */
                /* set port state to discarding */
                rc = dot1sSwitchPortEnableSet(intIfNum);
              }
            }
            else /* MSTP is Disabled */
            {
              /* For USMDB purposes, indicate the port is in forwarding for all 
               * instances
               */
              for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
              {
                dot1sPort[intIfNum].portInstInfo[instIndex].portState = L7_DOT1S_MANUAL_FWD;
              }
            }                                                                 
          }/*end if (dot1sPort[intIfNum].....*/
        }/*end if (adminState == L7_ENABLE)*/
      }/*end if (dot1sPort[intIfNum].portLinkState != L7_UP)*/
      break;

  case(L7_PORT_ENABLE):
	  dot1sPort[intIfNum].diagnosticDisable = L7_FALSE;
      /* If the port is already enabled do not do anything */
      if (dot1sPort[intIfNum].portEnabled != L7_TRUE)
      {
        if (dot1sPort[intIfNum].portLinkState == L7_UP)
        {
          /* are link transition being ignored */
          if (dot1sPort[intIfNum].ignoreLinkStateChanges == L7_FALSE)
          { 
            /* is MSTP Enabled */
            if (dot1sBridge->Mode == L7_ENABLE)
            {
              if (dot1sPort[intIfNum].notParticipating == L7_TRUE)
              {
                /* notParticipating */
                /* set port state to manual forwarding */
                dot1sIhSetPortState(L7_DOT1S_MSTID_ALL, intIfNum, L7_DOT1S_MANUAL_FWD);
              }
              else                                                            
              {
                /* port is Participating (ie; not notParticipating) */
                /* set port state to discarding */
                rc = dot1sSwitchPortEnableSet(intIfNum);
              }
            }
            else /* MSTP is Disabled */
            {
              /* For USMDB purposes, indicate the port is in forwarding for all 
               * instances
               */
              for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
              {
                dot1sPort[intIfNum].portInstInfo[instIndex].portState = L7_DOT1S_MANUAL_FWD;
              }
            }                                                                 
          }/*end if (dot1sPort[intIfNum]....*/
        }/*end if (dot1sPort[intIfNum].portLinkState == L7_UP)*/
      }/*end if (dot1sPort[intIfNum].portEnabled != L7_TRUE) */
      break;
	
	case (L7_DETACH):
	  /* A detach event can theoritically precede a L7_DOWN
	   * hence to handle that case we need to perform the 
	   * actions of L7_DOWN provided this link had been 
	   * linked up. Therefore do exactly what a Link down event 
	   * would entail.
	   */
    case (L7_DOWN):
      /* if port already known as down then nothing to do */
      if (dot1sPort[intIfNum].portLinkState == L7_UP)
      {
        dot1sPort[intIfNum].portLinkState = L7_DOWN;
        dot1sPort[intIfNum].portUpEnabledNum = 0;

        if (adminState == L7_ENABLE || dot1sPort[intIfNum].portEnabled == L7_TRUE)
        {
          /* are link transition being ignored */
          if (dot1sPort[intIfNum].ignoreLinkStateChanges == L7_FALSE)
          { 
            /* is MSTP Enabled */
            if (dot1sBridge->Mode == L7_ENABLE)
            {
              if (dot1sPort[intIfNum].notParticipating == L7_TRUE)
              {
                /* notParticipating */
                /* set port state to disabled */
                for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
                { 
                   dot1sFlush(intIfNum, instIndex);
                }
                dot1sIhSetPortState(L7_DOT1S_MSTID_ALL, intIfNum, L7_DOT1S_DISABLED);                      
              }
              else                                                            
              {
                /* port is Participating (ie; not notParticipating) */
                if (adminState == L7_ENABLE)
                {
                rc = dot1sSwitchPortDisableSet(intIfNum);
              }
            }
            }
            else /* MSTP is Disabled */
            {
              /* For USMDB purposes, indicate the port is disabled for all 
               * instances
               */
              for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
              {
                dot1sPort[intIfNum].portInstInfo[instIndex].portState = L7_DOT1S_DISABLED;
              }
              dot1sPort[intIfNum].lastNotificationSent = L7_LAST_PORT_EVENT;
            }                                                                 
          }/*end if (dot1sPort[intIfNum]....*/
        }/*end if (adminState == L7_ENABLE)*/
      }/*end if (dot1sPort[intIfNum].portLinkState == L7_UP)*/
      break; 

    case(L7_PORT_DISABLE):
      /* if port already known as down then nothing to do */
      if (dot1sPort[intIfNum].portLinkState == L7_UP)
      {
        /* is MSTP Enabled */
        if (dot1sBridge->Mode == L7_ENABLE)
        {
          if (dot1sPort[intIfNum].notParticipating == L7_TRUE)
          {
            /* notParticipating */
            /* set port state to disabled */
            for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
            { 
               dot1sFlush(intIfNum,instIndex);
            }
            dot1sIhSetPortState(L7_DOT1S_MSTID_ALL, intIfNum, L7_DOT1S_DISABLED);                      
          }
          else                                                            
          {
            /* port is Participating (ie; not notParticipating) */
            rc = dot1sSwitchPortDisableSet(intIfNum);
          }
        }
        else /* MSTP is Disabled */
        {
          /* For USMDB purposes, indicate the port is disabled for all 
           * instances
           */
          for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
          {
            dot1sPort[intIfNum].portInstInfo[instIndex].portState = L7_DOT1S_DISABLED;
          }
        }
      }/*end if (dot1sPort[intIfNum].portLinkState == L7_UP)*/
      break;

    case(L7_LAG_ACQUIRE):
      
	  /* Acquired ports need to be ignored when the link state changes. */
	  dot1sPort[intIfNum].ignoreLinkStateChanges = L7_TRUE;

      /* check if previously acquired */
      COMPONENT_ACQ_NONZEROMASK(dot1sPort[intIfNum].acquiredList, prevAcquired);

      /* update aquired list */
      COMPONENT_ACQ_SETMASKBIT(dot1sPort[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID);

      /* If the interface was not previously acquired by some component, cause
       * the acquisition to be reflected in the state of the spanning tree 
       */
      if (prevAcquired == L7_FALSE)
      {
        dot1sIhAcquire(intIfNum);
      }
      break;
    
    case(L7_LAG_RELEASE):
	/* Was the bit set in the first place. Proceed with the IhRelease only
	   * if it was previously acquired and now is getting released
	   */
	prevLagAcquired = COMPONENT_ACQ_ISMASKBITSET(dot1sPort[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID);

	if (prevLagAcquired != L7_FALSE)
	{
	
      /* update aquired list */
      COMPONENT_ACQ_CLRMASKBIT(dot1sPort[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID);

      /* check if currently acquired */
      COMPONENT_ACQ_NONZEROMASK(dot1sPort[intIfNum].acquiredList, currAcquired);

    
	  /* Do not ignore the link state changes of the port now that it 
	   * is no longer acquired.
	   */
	  dot1sPort[intIfNum].ignoreLinkStateChanges = L7_FALSE;
 
      /* If the interface is not currently acquired by some component, cause
       * the acquisition to be reflected in the state of the spanning tree 
       */
    
	  if (currAcquired == L7_FALSE)
      {
        dot1sIhRelease(intIfNum);
      }
	}

      break;

    case(L7_PORT_ROUTING_ENABLED):
      /* check if previously acquired */
      COMPONENT_ACQ_NONZEROMASK(dot1sPort[intIfNum].acquiredList, prevAcquired);
	  /* check if this interface has been previously acquired by ip map component*/
	  prevIpMapAcquired =  COMPONENT_ACQ_ISMASKBITSET(dot1sPort[intIfNum].acquiredList, L7_IP_MAP_COMPONENT_ID);
      /* if prevIpMapAcquired is true then do not do anything thus preventing 
	   * unneccessary events to be generated
	   */
	  if (prevIpMapAcquired == 0)
	  {
        /* update aquired list */
        COMPONENT_ACQ_SETMASKBIT(dot1sPort[intIfNum].acquiredList, L7_IP_MAP_COMPONENT_ID);

        /* If the interface was not previously acquired by some component, cause
         * the acquisition to be reflected in the state of the spanning tree 
         */
        if (prevAcquired == L7_FALSE)
        {
          dot1sIhAcquire(intIfNum);
        }

        /*If link is up, move the state to forwarding*/
        rc = nimGetIntfLinkState(intIfNum, &linkState);
        if (linkState == L7_UP)
        {
		  (void)dtlDot1sFlush(intIfNum);
          /* is MSTP Enabled */
          if (dot1sBridge->Mode == L7_ENABLE)
          {
            if (dot1sPort[intIfNum].notParticipating == L7_TRUE)
            {
              /* notParticipating */
              /* set port state to manual forwarding */
              dot1sIhSetPortState(L7_DOT1S_MSTID_ALL, intIfNum, L7_DOT1S_MANUAL_FWD);
            }
          }
        }
      }
      break;

    case(L7_PORT_ROUTING_DISABLED):
      /* make sure that ip map had this interface previously acquired */
	  prevIpMapAcquired = 1;
	  prevIpMapAcquired =  COMPONENT_ACQ_ISMASKBITSET(dot1sPort[intIfNum].acquiredList, L7_IP_MAP_COMPONENT_ID);

	  if (prevIpMapAcquired != 0)
	  {
	  
      /* update aquired list */
      COMPONENT_ACQ_CLRMASKBIT(dot1sPort[intIfNum].acquiredList, L7_IP_MAP_COMPONENT_ID);

      /* check if currently acquired */
      COMPONENT_ACQ_NONZEROMASK(dot1sPort[intIfNum].acquiredList, currAcquired);

      /* If the interface is not currently acquired by some component, cause
       * the acquisition to be reflected in the state of the spanning tree 
       */
      if (currAcquired == L7_FALSE)
      {
        dot1sIhRelease(intIfNum);
      }
	  }
      break;

    case(L7_PROBE_SETUP):
      /* check if previously acquired */
      COMPONENT_ACQ_NONZEROMASK(dot1sPort[intIfNum].acquiredList, prevAcquired);

      /* update aquired list */
      COMPONENT_ACQ_SETMASKBIT(dot1sPort[intIfNum].acquiredList, L7_PORT_MIRROR_COMPONENT_ID);

      /* If the interface is not previously acquired by some component, cause
       * the acquisition to be reflected in the state of the spanning tree.
       */
      if (prevAcquired == L7_FALSE)
      {
        dot1sIhAcquire(intIfNum);
      }

      /*If link is up, move the state to forwarding*/
      rc = nimGetIntfLinkState(intIfNum, &linkState);
      if (linkState == L7_UP)
      {
        /* is MSTP Enabled */
        if (dot1sBridge->Mode == L7_ENABLE)
        {
          if (dot1sPort[intIfNum].notParticipating == L7_TRUE)
          {
            /* notParticipating */
            /* set port state to manual forwarding */
            dot1sIhSetPortState(L7_DOT1S_MSTID_ALL, intIfNum, L7_DOT1S_MANUAL_FWD);
          }
        }
      }
      break;

    case(L7_PROBE_TEARDOWN):
      /* update aquired list */
      COMPONENT_ACQ_CLRMASKBIT(dot1sPort[intIfNum].acquiredList, L7_PORT_MIRROR_COMPONENT_ID);

      /* check if currently acquired */
      COMPONENT_ACQ_NONZEROMASK(dot1sPort[intIfNum].acquiredList, currAcquired);

      /* If the interface is not currently acquired by some component, cause
       * the acquisition to be reflected in the state of the spanning tree.
       */
      if (currAcquired == L7_FALSE)
      {
        dot1sIhRelease(intIfNum);
      }
      break;

    case(L7_SPEED_CHANGE):

      /* Port Path Cost by default is linked to the link speed */
      rc = dot1sCalcPortPathCost(intIfNum);

      p = dot1sIntfFind(intIfNum);
      if (p != L7_NULLPTR)
      {
        for (instIndex = DOT1S_CIST_INDEX; instIndex <= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
        {
          if (dot1sInstanceMap[instIndex].inUse == L7_TRUE)
          {
            p->portInstInfo[instIndex].reselect = L7_TRUE;
            p->portInstInfo[instIndex].selected = L7_FALSE;
            /* generate reselect event */
            rc = dot1sStateMachineClassifier(prsReselect, p, instIndex , L7_NULL, L7_NULLPTR);
          }
        }
      }

      break;

    case L7_FORWARDING:
    case L7_NOT_FORWARDING:
      if (intIfEvent != dot1sPort[intIfNum].lastNotificationSent)
      {
        dot1sPort[intIfNum].lastNotificationSent = intIfEvent;
      } 
      break;

    default:
      break;
  }/*end switch (intIfEvent)*/                      

  status.response.rc = L7_SUCCESS;
  nimEventStatusCallback(status);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  The specified interface has been "acquired" by another 
* @purpose  component.  
*       
* @param    intIfnum @b{(input)} port changing state
* @param    @b{(output)}
*
* @returns  
*
* @comments This routine should be called only if the interface is 
*           not already acquired by a component.
*           Calling this routine will cause the internal port mode 
*           to be reflected as Disabled. This internal port mode
*           has no reflection on the operational state of the port. 
*           Users wishing to read the operational state of the port 
*           must obtain this information from NIM, not Spanning Tree.
*
* @end
*********************************************************************/
void dot1sIhAcquire(L7_uint32 intIfNum)
{
  L7_uint32 instIndex;
  L7_RC_t rc;

    /* is MSTP Enabled */
  if (dot1sBridge->Mode == L7_ENABLE)
  {                                                                       
    /* Tell MSTP */
    rc = dot1sSwitchPortDisableSet(intIfNum);
  }
  else /* MSTP is disabled */
  {
    /* For USMDB purposes, indicate the port is disabled for all 
     * instances
     */
    for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
    {
      dot1sPort[intIfNum].portInstInfo[instIndex].portState = L7_DOT1S_DISABLED;
    }
  }

  dot1sPort[intIfNum].notParticipating = L7_TRUE;
  /* disable flooding on the port */
  dot1sCommonPortBpduFloodModeSet(intIfNum,L7_NULL,L7_FALSE);
}

/*********************************************************************
* @purpose  The specified interface has been "released" by another component.  
*           Its acquisition means that it should no longer participate in Spanning 
*           Tree.
*       
* @param    intIfnum @b{(input)} port changing state
*
* @returns  
*
* @comments This routine should be called only if the the last acquiring 
*           component has released this interface.
*
* @end
*********************************************************************/
void dot1sIhRelease(L7_uint32 intIfNum)
{
  L7_RC_t rc;
  L7_uint32 instIndex;
  DOT1S_PORT_COMMON_CFG_t *pCfg;
  L7_uint32 adminState;
  
  /* This interface has been "released" by another component.  Its 
   * release means that it **may** be eligible to participate in 
   * Spanning Tree. It is eligible as long as no other component is 
   * also holding a "lock" on the interface. It is the responsibility 
   * of the calling routine to ensure that no other component holds a
   * lock on the interface.
   */

  if (dot1sPort[intIfNum].portAdminMode == L7_ENABLE)
  {
    dot1sPort[intIfNum].notParticipating = L7_FALSE;
  }
  else
  {
    dot1sPort[intIfNum].notParticipating = L7_TRUE;
  }

  /* Reflect the port state */
  if (dot1sPort[intIfNum].portLinkState == L7_UP)
  {
    /* is MSTP Enabled */
    if (dot1sBridge->Mode == L7_ENABLE)
    {
      if (dot1sPort[intIfNum].notParticipating == L7_TRUE)
      {
        /* notParticipating */
        /* set port state to manual forwarding */
        dot1sIhSetPortState(L7_DOT1S_MSTID_ALL, intIfNum, L7_DOT1S_MANUAL_FWD);
      }
      else                                                            
      {
        /* port is Participating (ie; not notParticipating) */
        /* set port state to discarding */
        rc = nimGetIntfAdminState(intIfNum, &adminState);
        if (rc == L7_SUCCESS && adminState == L7_ENABLE)
        {
        rc = dot1sSwitchPortEnableSet(intIfNum);
      }
    }
    }
    else /* MSTP is Disabled */
    {
      /* For USMDB purposes, indicate the port is in forwarding for all 
       * instances
       */
      for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
      {
        dot1sPort[intIfNum].portInstInfo[instIndex].portState = L7_DOT1S_MANUAL_FWD;
      }
    }                                                                 
  }/*end if (dot1sPort[intIfNum].portLinkState == L7_UP)*/
  else
  {
    if (dot1sPort[intIfNum].portLinkState == L7_DOWN)
    {
      /* is MSTP Enabled */
      if (dot1sBridge->Mode == L7_ENABLE)
      {
        if (dot1sPort[intIfNum].notParticipating == L7_TRUE)
        {
          /* notParticipating */
          /* set port state to disabled */
          dot1sIhSetPortState(L7_DOT1S_MSTID_ALL, intIfNum, L7_DOT1S_DISABLED);
        }
        else                                                            
        {
          /* port is Participating (ie; not notParticipating) */
          rc = dot1sSwitchPortDisableSet(intIfNum);
        }
      }
      else /* MSTP is Disabled */
      {
        /* For USMDB purposes, indicate the port is disabled for all 
         * instances
         */
        for (instIndex=0; instIndex<= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
        {
          dot1sPort[intIfNum].portInstInfo[instIndex].portState = L7_DOT1S_DISABLED;
        }
      }                                                                 
    }/*end if (dot1sPort[intIfNum].portLinkState == L7_DOWN)*/
  }/*end else if (dot1sPort[intIfNum].portLinkState == L7_UP)*/

  if (dot1sMapIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
  dot1sCommonPortBpduFloodModeSet(intIfNum,L7_NULL,pCfg->bpduFloodMode);
}

/*********************************************************************
* @purpose  Go through registered Dot1s users and notify them of 
*           interface changes in a specific instance.
*
* @param    mstID @b{(input)} MSTP instance
* @param    intIfNum @b{(input)} interface number
* @param    intIfEvent @b{(input)} interface event
* @param    @b{(output)}
*
* @returns  
*
* @comments    
*       
* @end
*********************************************************************/
void dot1sIhDoNotify(L7_uint32 mstID, L7_uint32 intIfNum, L7_uint32 intIfEvent)
{
  L7_RC_t rc;
  L7_uint32 i;

  for (i = 0; i < L7_LAST_COMPONENT_ID; i++)
  {
    if (dot1sNotifyList[i].registrar_ID)
    {
      rc = (*dot1sNotifyList[i].notify_intf_change)(mstID, intIfNum, intIfEvent);
    }
  }
}

/*********************************************************************
* @purpose  Go through registered Dot1s users and notify them of an 
*           interface change in every valid instance.
*
* @param    intIfNum @b{(input)} interface number
* @param    intIfEvent @b{(input)} interface event
* @param    @b{(output)}
*
* @returns  
*
* @comments    
*       
* @end
*********************************************************************/
void dot1sIhDoNotifyAllInstances(L7_uint32 intIfNum, L7_uint32 intIfEvent)
{
  L7_uint32 inst, instNumber;
  L7_RC_t rc;

  for (inst = 0; inst <= L7_MAX_MULTIPLE_STP_INSTANCES; inst++)
  {
    if ((rc = dot1sInstNumFind(inst, &instNumber)) == L7_SUCCESS)
    {
      dot1sIhDoNotify(instNumber, intIfNum, intIfEvent);
    }
  }
}

/*********************************************************************
* @purpose  Gets the dataRate for a particular interface
*           
* @param    intIfNum @b{(input)} internal interface number
* @param    dataRate @b{(output)} pointer to the dataRate
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments    
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhIntfSpeedDataRateGet(L7_uint32 intIfNum, L7_uint32 *dataRate)
{
  L7_RC_t rc = L7_FAILURE;

  rc = nimGetIntfSpeedDataRate(intIfNum, dataRate);

  return rc;
}

/*********************************************************************
* @purpose  Checks if an interface is full duplex
*           
* @param    intIfNum @b{(input)} internal interface number
* @param    @b{(output)}
*
* @returns  L7_TRUE 
* @returns  L7_FALSE
*
* @comments    
*       
* @end
*********************************************************************/
L7_BOOL dot1sIhIsIntfSpeedFullDuplex(L7_uint32 intIfNum)
{
  L7_BOOL rc = L7_FALSE;
  
  rc = nimIsIntfSpeedFullDuplex(intIfNum);

  return rc;
}

/*********************************************************************
* @purpose  Gets the link speed of the interface 
*           
* @param    intIfNum @b{(input)} internal interface number
* @param    speed @b{(output)} pointer to speed as in L7_PORT_SPEEDS_t
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments    
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhIntfSpeedGet(L7_uint32 intIfNum, L7_uint32 *speed)
{
  L7_RC_t rc = L7_FAILURE;

  rc = nimGetIntfSpeed(intIfNum, speed);

  return rc;
}

/*********************************************************************
* @purpose  Gets the link state of the interface
*           
* @param    intIfNum @b{(input)} internal interface number
* @param    state @b{(output)} L7_UP or L7_DOWN
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments    
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhIntfLinkStateGet(L7_uint32 intIfNum, L7_uint32 *state)
{
  L7_RC_t rc = L7_FAILURE;

  rc = nimGetIntfLinkState(intIfNum, state);

  return rc;
}

/*********************************************************************
* @purpose  Gets the MAC Address associated with an interface
*           
* @param    intIfNum @b{(input)} internal interface number
* @param    addrType @b{(input)} address type requested (L7_SYSMAC_BIA, L7_SYSMAC_LAA,
*                       or L7_NULL) L7_NULL will return currently configured 
*                       MAC Address
* @param    macAddr @b{(output)} pointer to mac address
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments    
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhIntfAddrGet(L7_uint32 intIfNum, L7_uint32 addrType, L7_uchar8 *macAddr)
{
  L7_RC_t rc = L7_FAILURE;

  rc = nimGetIntfAddress(intIfNum, addrType, macAddr);

  return rc;
}

/*********************************************************************
* @purpose  Retrieves the unit slot and port of a given interface
*           
* @param    intIfNum @b{(input)} internal interface number
* @param    usp @b{(output)} pointer to the usp
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments    
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhIntfUspGet(L7_uint32 intIfNum, DOT1S_USP_t *usp)
{
  L7_RC_t rc = L7_FAILURE;
  nimUSP_t nimUsp;

  rc = nimGetUnitSlotPort(intIfNum, &nimUsp);
  if (rc != L7_SUCCESS)
  {
    return L7_FAILURE;
  }
  usp->unit = nimUsp.unit;
  usp->slot = nimUsp.slot;
  usp->port = nimUsp.port;

  return rc;
}

/*********************************************************************
* @purpose  Retrieves auto negotiation status of a given interface
*           
* @param    intIfNum @b{(input)} internal interface number
* @param    autoNegoStatus @b{(output)} pointer to the status
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments    
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhIntfAutoNegStatusGet(L7_uint32 intIfNum, L7_uint32 *autoNegoStatus)
{
  L7_RC_t rc = L7_FAILURE;

  rc = nimGetIntfAutoNegAdminStatus(intIfNum, autoNegoStatus);

  return rc;
}

/*********************************************************************
* @purpose  return the highest assigned interface number 
*          
* @param    @b{(input)}
* @param    highestIntfNumber @b{(output)} pointer to return value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments
*
* @end
*********************************************************************/
L7_RC_t dot1sIhHighestIntfNumGet(L7_uint32 *highestIntfNumber)
{
  L7_RC_t rc = L7_FAILURE;

  rc = nimGetHighestIntfNumber(highestIntfNumber);

  return rc;
}

/*********************************************************************
* @purpose  Set the dot1s forwarding state of an interface in all
*           instances.
*
* @param    intIfNum @b{(input)} the interface number
* @param    state @b{(input)} the dot1s State
* @param    @b{(output)}
*
* @returns  
*
* @comments    
*       
* @end
*********************************************************************/
void dot1sIhPortStateAllSet(L7_uint32 intIfNum, L7_uint32 state)
{
  L7_uint32 inst, instNumber;
  L7_RC_t rc;
  L7_NIM_QUERY_DATA_t nimQueryData;

  nimQueryData.intIfNum = intIfNum;
  nimQueryData.request = L7_NIM_QRY_RQST_STATE;

  if (nimIntfQuery(&nimQueryData) != L7_SUCCESS)
  {
	return;/* should never get here*/
  }


  for (inst = 0; inst <= L7_MAX_MULTIPLE_STP_INSTANCES; inst++)
  {
    if ((rc = dot1sInstNumFind(inst, &instNumber)) == L7_SUCCESS)
    {
      /* only talk to the hardware when the hardware is valid */
	  if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
          (nimQueryData.data.state == L7_INTF_DETACHING) ||
          (nimQueryData.data.state == L7_INTF_ATTACHED))
	  {
        if (state == L7_DOT1S_BPDU_GUARD)
        {
           dot1sIhStateSet(instNumber, intIfNum, L7_DOT1S_DISCARDING);
        }
        else
        {
           dot1sIhStateSet(instNumber, intIfNum, state);
		}
	  }
    }
  }
}

/*********************************************************************
* @purpose  Causes the switch to change state
*
* @param    mstID    @b((input)) user assigned instance number  
* @param    intIfNum @b{(input)} interface to change the state of
* @param    state    @b{(input)} state to change to
*
* @returns  
*
* @comments     
*       
* @end
*********************************************************************/
void dot1sIhSetPortState(L7_uint32 mstID, L7_uint32 intIfNum, L7_uint32 state)
{
  L7_NIM_QUERY_DATA_t nimQueryData;
  L7_uint32 instIndex = 0;

  nimQueryData.intIfNum = intIfNum;
  nimQueryData.request = L7_NIM_QRY_RQST_STATE;

  if (nimIntfQuery(&nimQueryData) != L7_SUCCESS)
  {
	return;/* should never get here*/
  }

  (void )dot1sInstIndexFind(mstID,&instIndex); 
  if (DOT1S_DEBUG(DOT1S_DEBUG_STATE_CHANGE, instIndex))
  {
      DOT1S_DEBUG_MSG("%s:Setting Port(%d) instance(%d) State (%d) at %d \n", 
					  __FUNCTION__,intIfNum, instIndex,state,osapiTimeMillisecondsGet()); 
  }

  switch (state)
  {
  case L7_DOT1S_DISABLED:

    if (mstID == L7_DOT1S_MSTID_ALL)
    {
      /* This state change is applicable to all instances.
       */
      dot1sIhPortStateAllSet(intIfNum, state);
    }
    else
    {
      /* This state change is only applicable to one instance.
       */
      /* only talk to the hardware when the hardware is valid */
	  if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
          (nimQueryData.data.state == L7_INTF_DETACHING) ||
          (nimQueryData.data.state == L7_INTF_ATTACHED))
	  {
		dot1sIhStateSet(mstID, intIfNum, state);
	  }
    }

    break;

  case L7_DOT1S_LEARNING:
    /* Set to Learning for this instance only.
     */
    /* only talk to the hardware when the hardware is valid */
	  if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
          (nimQueryData.data.state == L7_INTF_DETACHING) ||
          (nimQueryData.data.state == L7_INTF_ATTACHED))
	  {
		dot1sIhStateSet(mstID, intIfNum, state);
	  }
    break;

  case L7_DOT1S_FORWARDING:
    /* Set to Forwarding for this instance only.
     */
    /* only talk to the hardware when the hardware is valid */
	  if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
          (nimQueryData.data.state == L7_INTF_DETACHING) ||
          (nimQueryData.data.state == L7_INTF_ATTACHED))
	  {
	  dot1sIhStateSet(mstID, intIfNum, state);
	  }
    break;

  case L7_DOT1S_DISCARDING:

    if (mstID == L7_DOT1S_MSTID_ALL)
    {
      /* This state change is applicable to all instances.
       */
      dot1sIhPortStateAllSet(intIfNum, state);
    }
    else
    {
      /* This state change is only applicable to one instance.
       */
      /* only talk to the hardware when the hardware is valid */
	  if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
          (nimQueryData.data.state == L7_INTF_DETACHING) ||
          (nimQueryData.data.state == L7_INTF_ATTACHED))
	  {
		dot1sIhStateSet(mstID, intIfNum, state);
	  }
    }
    break;

  case L7_DOT1S_MANUAL_FWD:
    /* forwarding when spanning tree is off for the port */
    /* This state change is applicable to all instances.
     */
	if (mstID == L7_DOT1S_MSTID_ALL)
	{
	  dot1sIhPortStateAllSet(intIfNum, state);
	}
	else
	{
	  /* This state change is only applicable to one instance.
       */
      /* only talk to the hardware when the hardware is valid */
	  if ((nimQueryData.data.state == L7_INTF_ATTACHING) ||
          (nimQueryData.data.state == L7_INTF_DETACHING) ||
          (nimQueryData.data.state == L7_INTF_ATTACHED))
	  {
		dot1sIhStateSet(mstID, intIfNum, state);
	  }
    }
    break;

  default:
    LOG_MSG("\r\ndot1sIhSetPortState: Invalid MSTP state!\n");
    break;
  }
}
/*********************************************************************
* @purpose  Causes the switch to change state by telling DTL 
*
* @param    mstID    @b((input)) user assigned instance number  
* @param    intIfNum @b{(input)} interface to change the state of
* @param    state    @b{(input)} state to change to
*
* @returns  
*
* @comments     
*       
* @end
*********************************************************************/
void dot1sIhStateSet(L7_uint32 mstID, L7_uint32 intIfNum, L7_uint32 state)
{
  L7_uint32 localMPC;
  L7_RC_t rc;
  L7_uint32 instIndex;
  nimUSP_t usp;

  (void)osapiSemaTake(dot1sStateSetSema,  L7_WAIT_FOREVER);
  if (dot1sStateSetTimer == L7_NULLPTR)
  {
   /* Start a new osapi timer */
   osapiTimerAdd(dot1sStateSetTimerExpired, intIfNum, state, DOT1S_STATE_SET_TIMEOUT, &dot1sStateSetTimer);
  }
  else
  {
   /*Timer is already running so no need to to do anything*/
  }

  if (((dot1sCBTail +1) % DOT1S_STATE_SET_CB_SIZE) == dot1sCBHead)
  {
	/* Too many messages in ther circular buffer 
	 * disabling this port and logging a message
	 */
	L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
        "dot1sCB is full intIfNum %d, instance ID %d state %d", intIfNum, mstID, state);

	if (dot1sPort[intIfNum].diagnosticDisable == L7_FALSE)
	{
	  (void)nimSetIntfAdminState(intIfNum, L7_DIAG_DISABLE);
	  dot1sPort[intIfNum].diagnosticDisable = L7_TRUE;
	  (void)nimGetUnitSlotPort(intIfNum, &usp);
	  L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
              "Diagnostically disabling interface %d/%d/%d", usp.unit, usp.slot,usp.port);
	}
	
	(void)osapiSemaGive(dot1sStateSetSema);
	return;
  }


  dot1sMPC++;
  if (dot1sMPC == 0)
  {
	/* Rollover has occured */
	dot1sMPCRollover++;
  }
  localMPC = dot1sMPC;
  dot1sCB[dot1sCBTail].intIfNum = (L7_ushort16)intIfNum;
  dot1sCBTail = ((dot1sCBTail + 1) % DOT1S_STATE_SET_CB_SIZE);

  (void)osapiSemaGive(dot1sStateSetSema);
  rc = dot1sInstIndexFind(mstID,  &instIndex);
  if (rc != L7_SUCCESS)
  {
	LOG_MSG("Unknown instance %d\n",  mstID);
	return;
  }
  dot1sPort[intIfNum].portInstInfo[instIndex].stateChangeInProgress++;

  rc = dtlDot1sStateSet(mstID, intIfNum, state, dot1sMPC);

  if (rc != L7_SUCCESS)
  {
	
	/* We will not attempt to clean up dot1sCBTail as this will involve taking the sema
	 * which could lead to curruption of the variable as another task (nim or dot1s 
	 * depending on which one has invoked the current call)  hence we will allow the 
	 * timer to expire and take the clean up action on the expiry of the timer.
	 * we will ofcource diagnostically disable this port as soon as we receive a 
	 * failure. Typically this involves an inability to put htis msg on the dapi/hapi Q
	 * In the sync case (no Q in the driver) the clean up has already happened as the 
	 * callback is invoked before returning from the hapi function
	 */

	L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
            "dtlDot1sStateSet failed intIfNum %d, instance ID %d state %d", 
            intIfNum, mstID, state);
    if (dot1sPort[intIfNum].diagnosticDisable == L7_FALSE)
	{
	  (void)nimSetIntfAdminState(intIfNum, L7_DIAG_DISABLE);
	  dot1sPort[intIfNum].diagnosticDisable = L7_TRUE;
	  (void)nimGetUnitSlotPort(intIfNum, &usp);
	  L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
              "Diagnostically disabling interface %d/%d/%d", usp.unit, 
              usp.slot,usp.port);
	}
  }
  
  return;
}
/*********************************************************************
* @purpose  Notify of a dot1s instance create
*
* @param    instNumber @b{(input)} instance number
* @param    @b{(output)}
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments     
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhDoNotifyInstanceCreate(L7_uint32 instNumber)
{
  L7_RC_t rc;

  /* Notify Dot1s Registered users */
  dot1sIhDoNotify(instNumber, L7_NULL, L7_DOT1S_EVENT_INSTANCE_CREATE);

  /* Notify DTL */
  rc = dtlDot1sInstanceCreate(instNumber);

  return rc;
}

/*********************************************************************
* @purpose  Notify of a dot1s instance delete
*
* @param    instNumber @b{(input)} instance number
* @param    @b{(output)}
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments     
*       
* @end
*********************************************************************/
L7_RC_t dot1sIhDoNotifyInstanceDelete(L7_uint32 instNumber)
{
  L7_RC_t rc;
  L7_uint32 numVlan;
  L7_uint32 i;

  /* Notify Dot1s Registered users */
  dot1sIhDoNotify(instNumber, L7_NULL, L7_DOT1S_EVENT_INSTANCE_DELETE);

  /* Notify DTL */
  rc = dtlDot1sInstanceDelete(instNumber);

  /* notify DTL of the Vlan list changes for the CIST */
  bzero((char *)&VIDList, (L7_int32)sizeof(VIDList));
  rc = dot1sMstiVIDList(DOT1S_CIST_ID, VIDList, &numVlan);

  for (i = 0; i < numVlan; i++)
  {
    rc = dtlDot1sInstVlanIdAdd(DOT1S_CIST_ID, VIDList[i]);
  }

  return rc;
}



/*********************************************************************
* @purpose  Obtain a pointer to the specified interface configuration data
*           for this interface
*
* @param    intIfNum @b{(input)} Internal Interface Number
* @param    **pCfg   @b{(output)}  Ptr  to snoop interface config structure
*                           or L7_NULL if not needed
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
*
* @notes    Facilitates pre-configuration, as it checks if the NIM
*           interface exists and whether the component is in a state to
*           be configured (regardless of whether the component is enabled
*           or not).
*
* @notes    The caller can set the pCfg parm to L7_NULL if it does not
*           want the value output from this function.
*
* @end
*********************************************************************/
L7_BOOL dot1sMapIntfIsConfigurable(L7_uint32 intIfNum, DOT1S_PORT_COMMON_CFG_t **pCfg)
{
  L7_uint32 index;
  nimConfigID_t configId;
  
  if (!(DOT1S_IS_READY))
    return L7_FALSE;

  /* Check boundary conditions */
  if (intIfNum <= 0 || intIfNum >= L7_DOT1S_MAX_INTERFACE_COUNT)
    return L7_FALSE;

  index = dot1sMapTbl[intIfNum];

  if (index == 0)
    return L7_FALSE;

  /* verify that the configId in the config data table entry matches the configId that NIM maps to
   ** the intIfNum we are considering
   */
  if (nimConfigIdGet(intIfNum, &configId) == L7_SUCCESS)
  {
    if (NIM_CONFIG_ID_IS_EQUAL(&configId, &(dot1sCfg->cfg.dot1sCfgPort[index].configId)) == L7_FALSE)
    {
      /* if we get here, either we have a table management error between dot1sCfg and dot1sMapTbl or
      ** there is synchronization issue between NIM and components w.r.t. interface creation/deletion
      */
      LOG_MSG("Error accessing DOT1S config data for interface %d in dot1sMapIntfIsConfigurable.\n", intIfNum);
      return L7_FALSE;
    }
  }

  *pCfg = &dot1sCfg->cfg.dot1sCfgPort[index];

  return L7_TRUE;
}

/*********************************************************************
* @purpose  Obtain a pointer to the first free interface config struct
*
* @param    intIfNum @b{(input)} Internal Interface Number
* @param    **pCfg   @b{(output)}  Ptr  to snoop nterface config structure
*                           or L7_NULL if not needed
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
*
* @notes    Facilitates pre-configuration, as it checks if the NIM
*           interface exists and whether the component is in a state to
*           be configured (regardless of whether the component is enabled
*           or not).
*
* @notes    
*
* @end
*********************************************************************/
L7_BOOL dot1sMapIntfConfigEntryGet(L7_uint32 intIfNum, DOT1S_PORT_COMMON_CFG_t **pCfg)
{
  L7_uint32 i;
  nimConfigID_t configId;
  nimConfigID_t configIdNull;
  L7_RC_t rc;

  memset(&configIdNull, 0, sizeof(nimConfigID_t));

  if (!(DOT1S_IS_READY))
    return L7_FALSE;

  if ((rc = nimConfigIdGet(intIfNum, &configId)) == L7_SUCCESS)
  {
    for (i = 1; i < L7_DOT1S_MAX_INTERFACE_COUNT; i++)
    {
      if (NIM_CONFIG_ID_IS_EQUAL(&dot1sCfg->cfg.dot1sCfgPort[i].configId, &configIdNull))
      {
        dot1sMapTbl[intIfNum] = i;
        *pCfg = &dot1sCfg->cfg.dot1sCfgPort[i];
        return L7_TRUE;
      }
    }
  }

  return L7_FALSE;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_CREATE
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1sIntfCreate(L7_uint32 intIfNum)
{
  nimConfigID_t configId;
  DOT1S_PORT_COMMON_CFG_t *pCfg;
  L7_uint32 i;

  if (dot1sIsValidIntf(intIfNum) != L7_TRUE)
    return L7_FAILURE;

  if (nimConfigIdGet(intIfNum, &configId) != L7_SUCCESS)
    return L7_FAILURE;
  
  for (i = 1; i < L7_DOT1S_MAX_INTERFACE_COUNT; i++)
  {
    if (NIM_CONFIG_ID_IS_EQUAL(&dot1sCfg->cfg.dot1sCfgPort[i].configId, &configId))
    {
      dot1sMapTbl[intIfNum] = i;
      break;
    }
  }

  pCfg = L7_NULL;

  if (dot1sMapIntfIsConfigurable(intIfNum, &pCfg) != L7_TRUE)
  {
    if(dot1sMapIntfConfigEntryGet(intIfNum, &pCfg) != L7_TRUE)
      return L7_FAILURE;
  	if (pCfg != L7_NULL)
    {
      NIM_CONFIG_ID_COPY(&pCfg->configId, &configId);
      dot1sPortDefaultConfigDataBuild (pCfg);
    }


  }

  if (pCfg != L7_NULL)
  {
    dot1sIntfCfgToPortCopy(pCfg);
  /* apply the configuration */
  dot1sCommonPortBpduFilterModeSet(intIfNum,L7_NULL,pCfg->bpduFilterMode);
  dot1sCommonPortBpduFloodModeSet(intIfNum,L7_NULL,pCfg->bpduFloodMode);
  }


  /* Register with stats manager*/
  (void)dot1sStatsCreate(intIfNum);

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_ATTACH
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1sApplyIntfConfigData(L7_uint32 intIfNum)
{
  L7_RC_t brc;
  L7_RC_t rc = L7_SUCCESS;
  DOT1S_PORT_COMMON_CFG_t *pCfg;

  if ((brc = dot1sMapIntfIsConfigurable(intIfNum, &pCfg)) == L7_TRUE)
  {
    /*snoopIntfModeSet(intIfNum, L7_ENABLE);*/
  }
  return rc;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_DELETE
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1sIntfDelete(L7_uint32 intIfNum)
{
  L7_RC_t rc = L7_FAILURE;
  L7_RC_t brc;
  DOT1S_PORT_COMMON_CFG_t *pCfg;

  if ((brc = dot1sMapIntfIsConfigurable(intIfNum, &pCfg)) == L7_TRUE)
  {
   (void)dot1sSwitchPortAdminModeDisableSet(intIfNum);
  }

  if (brc == L7_TRUE)
  {
    memset((void *)&pCfg->configId, 0x00, (L7_uint32)sizeof(nimConfigID_t));
	  memset((void *)pCfg, 0x00, (L7_uint32)sizeof(DOT1S_PORT_COMMON_CFG_t));
    dot1sMapTbl[intIfNum] = 0;
	  rc = L7_SUCCESS;
  }

  return rc;
}
/*********************************************************************
*
* @purpose  To process the Callback for L7_DETACH
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1sIntfDetach(L7_uint32 intIfNum)
{
  DOT1S_PORT_COMMON_CFG_t *pCfg;

  if (dot1sMapIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
  {
    /*
	if (snoopIntfModeApply(intIfNum, FD_IGMP_SNOOPING_INTF_MODE) != L7_SUCCESS)
      return L7_FAILURE;
	  */
  }

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Determine if the interface is valid in dot1s
*
* @param    intIfNum  @b{(input)} internal interface number
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
* @comments none
*       
* @end
*********************************************************************/
L7_RC_t dot1sIntfCfgToPortCopy(DOT1S_PORT_COMMON_CFG_t *pPortCfg)
{
  DOT1S_PORT_COMMON_t *pPort;
  L7_uint32           intIfNum, instIndex, priInstId;
  L7_RC_t rc;

  if (nimIntIfFromConfigIDGet(&(pPortCfg->configId), &intIfNum) != L7_SUCCESS)
	return L7_FAILURE;

  pPort = dot1sIntfFind(intIfNum);

  if (pPort == L7_NULLPTR)
	return L7_FAILURE;

  /* Initialize with the defaults then replace the configured fields
   * with their configured values.
   */
  rc = dot1sPortDefaultPopulate(pPort, intIfNum);

  pPort->portAdminMode = pPortCfg->portAdminMode;

  /* notParticipating must be kept in sync with Admin Mode
   * up until the time of an IhAcquire or IhRelease
   */
  if (pPort->portAdminMode == L7_ENABLE)
  {
    pPort->notParticipating = L7_FALSE;
  }
  else
  {
    pPort->notParticipating = L7_TRUE;
  }

  pPort->portNum = intIfNum;
  pPort->adminEdge = pPortCfg->adminEdge;
  pPort->autoEdge = pPortCfg->autoEdge;
  pPort->restrictedRole = pPortCfg->restrictedRole;
  pPort->loopGuard = pPortCfg->loopGuard;  
  pPort->restrictedTcn = pPortCfg->restrictedTcn;



  for (instIndex = DOT1S_CIST_INDEX; instIndex <= L7_MAX_MULTIPLE_STP_INSTANCES; instIndex++)
  {
    pPort->portInstInfo[instIndex].ExternalPortPathCost = pPortCfg->portInstInfo[instIndex].ExternalPortPathCost;
    pPort->portInstInfo[instIndex].InternalPortPathCost = pPortCfg->portInstInfo[instIndex].InternalPortPathCost;
    pPort->portInstInfo[instIndex].autoInternalPortPathCost = pPortCfg->portInstInfo[instIndex].autoInternalPortPathCost;
    pPort->portInstInfo[instIndex].autoExternalPortPathCost = pPortCfg->portInstInfo[instIndex].autoExternalPortPathCost;
    pPort->portInstInfo[instIndex].portId = ((pPortCfg->portInstInfo[instIndex].portPriority << 8) | intIfNum);
    /* msti */
    if (instIndex != DOT1S_CIST_INDEX)
    {
      priInstId = dot1sCfg->cfg.dot1sInstance.msti[instIndex].BridgeIdentifier.priInstId;
      pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.msti.mstiDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.msti.mstiMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.msti.mstiPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
    }
    else /* cist */
    {
      priInstId = dot1sCfg->cfg.dot1sInstance.cist.BridgeIdentifier.priInstId;

      pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.rootId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.cist.cistDesignatedPriority.regRootId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.rootId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.cist.cistMsgPriority.regRootId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.rootId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.dsgBridgeId.priInstId = (L7_ushort16)priInstId;
      pPort->portInstInfo[instIndex].inst.cist.cistPortPriority.regRootId.priInstId = (L7_ushort16)priInstId;
    }
  }/*endfor instIndex*/

  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Check if this port is Forwarding in any MSTP instance other than the one supplied
*           
*          
* @param    intIfNum @b{(input)} interface number
*           instIndex @b{(input)} instance Index
*
* @returns  L7_SUCCESS if forwarding in any instance or Nim Manual Forwarding
* @returns  L7_FAILURE if not forwarding in all instances
*
* @comments Use dot1sMstiPortStateGet if the state of a port in a specific 
*           instance is required. 
*
* @end
*********************************************************************/
L7_BOOL dot1sIsPortForwarding(L7_uint32 intIfNum, L7_uint32 instIndex)
{
  L7_uint32 index, state;
  DOT1S_PORT_COMMON_t *pPort;

  /* Only return port forwarding state information if MSTP is enabled.
   */
  if (dot1sModeGet() == L7_ENABLE)
  {
    pPort = dot1sIntfFind(intIfNum);
    if (pPort != L7_NULLPTR)
    {
      for (index = 0; index <= L7_MAX_MULTIPLE_STP_INSTANCES; index++)
      {
        if (index == instIndex)
        {
              continue;
        }

        if (dot1sInstanceMap[index].inUse == L7_TRUE)
	    {
          if(pPort->portInstInfo[index].portState == L7_DOT1S_FORWARDING ||
             pPort->portInstInfo[index].portState == L7_DOT1S_MANUAL_FWD)
          {
            return(L7_TRUE);
          }
        }
      }
    }
  }
  else /* MSTP is disabled, return NIM Manual Forwarding status */
  {
    if (nimGetIntfActiveState(intIfNum, &state) == L7_SUCCESS)
    {
      if (state == L7_ACTIVE)
      {
        return(L7_TRUE);
      }
    }
  }

  return(L7_FALSE);
}

/*********************************************************************
* @purpose  Check if this port is Discarding in any MSTP instance other than the one supplied
*           
*          
* @param    intIfNum @b{(input)} interface number
*           instIndex @b{(input)} instance Index
*
* @returns  L7_SUCCESS if forwarding in any instance or Nim Manual Forwarding
* @returns  L7_FAILURE if not forwarding in all instances
*
* @comments 
*           
*
* @end
*********************************************************************/

L7_BOOL dot1sIsPortDiscarding(L7_uint32 intIfNum, L7_uint32 instIndex)
{
  L7_uint32 index, state;
  DOT1S_PORT_COMMON_t *pPort;

  /* Only return port forwarding state information if MSTP is enabled.
   */

  if (dot1sModeGet() == L7_ENABLE)
  {
    pPort = dot1sIntfFind(intIfNum);
    if (pPort != L7_NULLPTR)
    {
      for (index = 0; index <= L7_MAX_MULTIPLE_STP_INSTANCES; index++)
      {
        if (index == instIndex)
        {
              continue;
        }

        if (dot1sInstanceMap[index].inUse == L7_TRUE)
	    {
          if(pPort->portInstInfo[index].portState != L7_DOT1S_DISCARDING)
          {
            return(L7_FALSE);
          }
        }
      }
    }
  }
  else /* MSTP is disabled, return NIM Manual Forwarding status */
  {
    if (nimGetIntfActiveState(intIfNum, &state) == L7_SUCCESS)
    {
      if (state == L7_ACTIVE)
      {
  return(L7_FALSE);
      }
    }
  }

  return(L7_TRUE);
}
/*********************************************************************
* @purpose  The dot1s state set timer has expired disable the affected interface
*           
*          
* @param    intIfNum @b{(input)} interface number
*           state    @b{(input)} MSTP state
*
* @returns  
* @returns  
*
* @comments We are in the osapi Timer context keep processing to a minimum
*			The critical section with in the semaphore protection must be
*			short
*           
*
* @end
*********************************************************************/
void dot1sStateSetTimerExpired(L7_uint32 intIfNum, L7_uint32 state)
{
  L7_uint32 CBIntIfNum;
  nimUSP_t usp;
  L7_BOOL makeDisableCall = L7_FALSE;


  (void)osapiSemaTake(dot1sStateSetSema, L7_WAIT_FOREVER);

  dot1sStateSetTimer = L7_NULLPTR;

  CBIntIfNum = (L7_uint32)dot1sCB[dot1sCBHead].intIfNum;
  dot1sNEC++;
  if (dot1sNEC == 0)
  {
	/*Rollover action*/
	dot1sNECRollover++;
  }

  /*Clean up dot1sCB */
  dot1sCB[dot1sCBHead].intIfNum = L7_NULL;

  dot1sCBHead = ((dot1sCBHead+1)%DOT1S_STATE_SET_CB_SIZE);

  dot1sStateSetTimerStart();

  if (dot1sPort[CBIntIfNum].diagnosticDisable == L7_FALSE)
  {
	dot1sPort[CBIntIfNum].diagnosticDisable = L7_TRUE;
    makeDisableCall = L7_TRUE;
  }


  (void)osapiSemaGive(dot1sStateSetSema);

  L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
          "Dot1s State Set timer (%d msec) expired for interface %d\n",
          DOT1S_STATE_SET_TIMEOUT, CBIntIfNum);  
  if (makeDisableCall == L7_TRUE)
  {
	(void)nimSetIntfAdminState(CBIntIfNum, L7_DIAG_DISABLE);
	(void)nimGetUnitSlotPort(CBIntIfNum, &usp);
	L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
            "Diagnostically disabling interface %d/%d/%d\n", 
            usp.unit, usp.slot,usp.port);
  }

  return;
}
/*********************************************************************
* @purpose  
*           
*          
* @param    intIfNum 	@b{(input)} interface number
*			instance 	@b{(input)} interface number
*           state    	@b{(input)} MSTP state
*			stateStatus @b{(input)} interface number
*
* @returns  
* @returns  
*
* @comments 
*			
*			
*           
*
* @end
*********************************************************************/
L7_RC_t dot1sStateSetCallback(L7_uint32 intIfNum, 
							  L7_uint32 instance, 
							  L7_uint32 state, 
							  dot1s_stateCB_t stateStatus)
{
  L7_uint32 errIntIfNum = L7_NULL;
  L7_BOOL mstpDeviceMode;
  L7_uint32 instIndex;
  L7_RC_t rc;
  
  if (dot1sDeregister.dot1sStateSetResponseCallback == L7_TRUE)
  {
	LOG_MSG("dot1sStateSetCallback is deregistered\n");
	return L7_FAILURE;
  }

  mstpDeviceMode = dot1sModeGet();

  /* If we are returning from a async task we must take the dot1TaskSyncSema
   * to protect the integrity of the dot1s database and structures.
   * If the set is sync then we would already have taken the semaphore and 
   * taking it again would result in a deadlock, since this sema is binary in nature.
   */
  if (L7_DOT1S_ASYNC_STATE_SET == L7_TRUE)
  {
	(void) osapiSemaTake(dot1sTaskSyncSema, L7_WAIT_FOREVER);
  }

  errIntIfNum = dot1sStateSetBookkeeping(intIfNum, stateStatus);
  /* We have now taken care of the bookkeeping if all was good i.e. the final errIntfNum 
   * was L7_NULL, i.e. the content of stateStatus was alright we can now advertize this
   * and call the relevant routine based on whether mstp is enabled on system and port.
   */
  if (errIntIfNum == L7_NULL)
  {
	if (mstpDeviceMode == L7_ENABLE)
	{
	  dot1sStateSetProtocolAction(intIfNum, instance, state);
	}
	else
	{
	  /* If mstpDeviceMode is false then it does not matter if the port has mstp enabled
	   * NIM has made this set call so do the neccessary actions that NIM would do
	   */
	  dot1sStateSetNimAction(intIfNum, state);
	}
	rc = dot1sInstIndexFind(instance,  &instIndex);
	if (rc != L7_SUCCESS)
	{
	  LOG_MSG("Unknown instance %d\n",  instance);
	  if (L7_DOT1S_ASYNC_STATE_SET == L7_TRUE)
	  {
		(void) osapiSemaGive(dot1sTaskSyncSema);
	  }
	  return L7_FAILURE;
	}
	dot1sPort[intIfNum].portInstInfo[instIndex].stateChangeInProgress--;
     
  }
  if (L7_DOT1S_ASYNC_STATE_SET == L7_TRUE)
  {
   (void) osapiSemaGive(dot1sTaskSyncSema);
  }
  return L7_SUCCESS;
}
/*********************************************************************
* @purpose  Perform neccessary calculations for the circular buffer and diag
*			disable a interface(s) if need be           
*          
* @param    intIfNum 	@b{(input)} interface number
*			stateStatus @b{(input)} interface number
*
* @returns  errIntfNum @{(output)} internal interface number
* @returns  
*
* @comments if errIntIfNum is L7_NULL then the contents of stateStatus
*			is valid and additional action can be performed, ie.
*			either dot1s or nim can take further action on the interface			
*			listed in the stateStatus           
*
* @end
*********************************************************************/
L7_uint32 dot1sStateSetBookkeeping(L7_uint32 intIfNum, 
								   dot1s_stateCB_t stateStatus)
{
  L7_uint32 errIntIfNum = L7_NULL;
  nimUSP_t usp;
  
  /* Bookkeeping */
  (void)osapiSemaTake(dot1sStateSetSema,  L7_WAIT_FOREVER);
  if (dot1sStateSetTimer != L7_NULLPTR)
  {
	(void)osapiTimerFree(dot1sStateSetTimer);
	dot1sStateSetTimer = L7_NULLPTR;
  }
  if (stateStatus.mpc == dot1sNEC && stateStatus.rc == L7_SUCCESS)
  {
	dot1sNEC++;
	if (dot1sNEC == 0)
	{
	  /*Rollover action*/
	  dot1sNECRollover++;
	}

    /*Clean up dot1sCB */
	dot1sCB[dot1sCBHead].intIfNum = L7_NULL;

	dot1sCBHead = ((dot1sCBHead + 1)%DOT1S_STATE_SET_CB_SIZE);

  }
  else if (stateStatus.mpc == dot1sNEC && stateStatus.rc != L7_SUCCESS)
  {
	/*correct expected interface but unsuccessful state set*/
	dot1sNEC++;
	if (dot1sNEC == 0)
	{
	  /*Rollover action*/
	  dot1sNECRollover++;
	}
	
	errIntIfNum = (L7_uint32)dot1sCB[dot1sCBHead].intIfNum;

	/*Clean up dot1sCB */
	dot1sCB[dot1sCBHead].intIfNum = L7_NULL;

	dot1sCBHead = ((dot1sCBHead + 1)%DOT1S_STATE_SET_CB_SIZE);

  }
  else /*misordered interface*/
  {
	/* Is this an old interface set ?, i.e. the timer has already expired on this
	 * and we have already set this port to diag disable? Since we have already accounted 
	 * for this interface in the dot1sNEC and dot1sCBHead and already diagnostically
	 * disabled this it is safe to just ignore this return.
	 */
	if (dot1sPort[intIfNum].diagnosticDisable == L7_TRUE)
	{
	  /* No need to check for the return status as this port is already 
	   * diag disabled
	   */
	  errIntIfNum = L7_NULL;
	}
	else
	{
	  /* Must disable all the interfaces which are inbetween */
	  do
	  {
		dot1sNEC++;
		if (dot1sNEC == 0)
		{
		  /*Rollover action*/
		  dot1sNECRollover++;
		}
		errIntIfNum = (L7_uint32)dot1sCB[dot1sCBHead].intIfNum;
  
		/*Clean up dot1sCB */
		dot1sCB[dot1sCBHead].intIfNum = L7_NULL;
  
		dot1sCBHead = ((dot1sCBHead + 1)%DOT1S_STATE_SET_CB_SIZE);
  

        L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
                "%s misordered set err intf %d received intf %d ",
                 __FUNCTION__, errIntIfNum, intIfNum);

		if (dot1sPort[errIntIfNum].diagnosticDisable == L7_FALSE)
		{
		  (void)nimSetIntfAdminState(errIntIfNum, L7_DIAG_DISABLE);
		  dot1sPort[errIntIfNum].diagnosticDisable = L7_TRUE;
		  (void)nimGetUnitSlotPort(errIntIfNum, &usp);
		  L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
                  "Diagnostically disabling interface %d/%d/%d\n", 
                  usp.unit, usp.slot,usp.port);
		}
  
	  } while (dot1sNEC != stateStatus.mpc);
	  /* Now check if the current interface had a good return code */
	  if (stateStatus.rc != L7_SUCCESS)
	  {
		errIntIfNum = (L7_uint32)dot1sCB[dot1sCBHead].intIfNum;
	  }
	  else
	  {
		errIntIfNum = L7_NULL;
	  }
	  dot1sNEC++;
	  if (dot1sNEC == 0)
	  {
		/*Rollover action*/
		dot1sNECRollover++;
	  }
  
	  /*Clean up dot1sCB */
	  dot1sCB[dot1sCBHead].intIfNum = L7_NULL;
  
	  dot1sCBHead = ((dot1sCBHead + 1)%DOT1S_STATE_SET_CB_SIZE);
	  
	}
  }
  /* Check if we need to restart the timer */
  dot1sStateSetTimerStart();

  (void)osapiSemaGive(dot1sStateSetSema);

  if (errIntIfNum != L7_NULL)
  {
	if (stateStatus.rc != L7_SUCCESS && stateStatus.mpc == (dot1sNEC -1))
	{
	  L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID,
              "dot1sStateSetCallback failed intIfNum %d\n", errIntIfNum);
	}
	if (dot1sPort[errIntIfNum].diagnosticDisable == L7_FALSE)
	{
	  (void)nimSetIntfAdminState(errIntIfNum, L7_DIAG_DISABLE);
	  dot1sPort[errIntIfNum].diagnosticDisable = L7_TRUE;
	  (void)nimGetUnitSlotPort(errIntIfNum, &usp);

      L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_DOT1S_COMPONENT_ID, 
              "Diagnostically disabling interface %d/%d/%d\n", usp.unit, usp.slot,usp.port);
	}
  }
  return errIntIfNum;
}
/*********************************************************************
* @purpose  
*           
*          
* @param    intIfNum 	@b{(input)} interface number
*			instance 	@b{(input)} interface number
*           state    	@b{(input)} MSTP state
*			stateStatus @b{(input)} interface number
*
* @returns  
* @returns  
*
* @comments 
*			
*			
*           
*
* @end
*********************************************************************/
void dot1sStateSetProtocolAction(L7_uint32 intIfNum, L7_uint32 instance, L7_uint32 state)
{
  DOT1S_PORT_COMMON_t *p;
  L7_BOOL allDiscard = L7_FALSE;
  L7_BOOL anyForward = L7_TRUE;
  L7_uint32 instIndex;
  L7_RC_t rc;

  p = dot1sIntfFind(intIfNum);
  if (p == L7_NULLPTR)
  {
	return;
  }
  rc = dot1sInstIndexFind(instance,&instIndex);
  if (rc != L7_SUCCESS)
  {
	return;
  }
  if ((p->loopInconsistent == L7_TRUE) && (state != L7_DOT1S_DISCARDING))
  {
    /*We should not get here . The state machine should handle loop inconsistent*/
    LOG_MSG("Cannot set state(%d) for port (%d) in instance(%d) to anything other than discarding as it is loop inconsistent \n", 
            state, intIfNum, instance);
    return;
  }  
  if (p->bpduGuardEffect == L7_TRUE)
  {
	/* For usmdb purposes and protocol refelect the state as DISABLED*/
	p->portInstInfo[instIndex].portState = L7_DOT1S_DISABLED;
  }
  else
  {
    if (!COMPONENT_ACQ_ISMASKBITSET(dot1sPort[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID))
    {
      /* For usmdb purposes and protocol refelect the state */
      p->portInstInfo[instIndex].portState = state;
    }
  }
  

  switch (state)
  {
	case L7_DOT1S_DISCARDING:
	  p->portInstInfo[instIndex].learning = L7_FALSE;
	  p->portInstInfo[instIndex].forwarding = L7_FALSE;

	  /* Tell dot1s registered users for this instance */
	  dot1sIhDoNotify(instance, intIfNum, L7_DOT1S_EVENT_NOT_FORWARDING);
	  /* Tell NIM to tell every other interested party */
	  
	  allDiscard = dot1sIsPortDiscarding(intIfNum,instIndex);

	  if (allDiscard == L7_TRUE && (p->lastNotificationSent == L7_FORWARDING || p->lastNotificationSent == L7_LAST_PORT_EVENT))
	  {
		rc = dot1sIhNotifySystem(intIfNum, L7_NOT_FORWARDING);
		p->lastNotificationSent = L7_NOT_FORWARDING;
	  }
	  /* Call the pst state machines generate event routine */
	  rc = dot1sPstGenerateEvents(p, instIndex);
      break;

	case L7_DOT1S_LEARNING:
	  p->portInstInfo[instIndex].learning = L7_TRUE;
	  /* Call the pst state machines generate event routine */
	  rc = dot1sPstGenerateEvents(p, instIndex);
	  break;

	case L7_DOT1S_FORWARDING:
	  p->portInstInfo[instIndex].forwarding = L7_TRUE;

      anyForward = dot1sIsPortForwarding(intIfNum,instIndex);
	  if (anyForward != L7_TRUE && (p->lastNotificationSent == L7_NOT_FORWARDING|| p->lastNotificationSent == L7_LAST_PORT_EVENT))
	  {
		rc = dot1sIhNotifySystem(intIfNum, L7_FORWARDING);
		p->lastNotificationSent = L7_FORWARDING;
	  }
	  dot1sIhDoNotify(instance, intIfNum, L7_DOT1S_EVENT_FORWARDING);

	  /* Call the pst state machines generate event routine */
	  rc = dot1sPstGenerateEvents(p, instIndex);
	  break;

	case L7_DOT1S_DISABLED:
	  dot1sIhDoNotify(instance, intIfNum, L7_DOT1S_EVENT_NOT_FORWARDING);
	  if (p->lastNotificationSent == L7_FORWARDING|| p->lastNotificationSent == L7_LAST_PORT_EVENT)
	  {
		rc = dot1sIhNotifySystem(intIfNum, L7_NOT_FORWARDING);
		p->lastNotificationSent = L7_NOT_FORWARDING;
	  }
	  break;

	case L7_DOT1S_MANUAL_FWD: 
	  if (p->lastNotificationSent == L7_NOT_FORWARDING|| p->lastNotificationSent == L7_LAST_PORT_EVENT)
	  { 
		rc = dot1sIhNotifySystem(intIfNum, L7_FORWARDING);
		p->lastNotificationSent = L7_FORWARDING;
	  }
	  break;

	case L7_DOT1S_NOT_PARTICIPATE:
	default:
	  /*There is no protocol action to be performed*/
	  break;
  }

  return;
}

/*********************************************************************
* @purpose  
*           
*          
* @param    intIfNum 	@b{(input)} interface number
*			instance 	@b{(input)} interface number
*           state    	@b{(input)} MSTP state
*			stateStatus @b{(input)} interface number
*
* @returns  
* @returns  
*
* @comments 
*			
*			
*           
*
* @end
*********************************************************************/
void dot1sStateSetNimAction(L7_uint32 intIfNum, L7_uint32 state)
{
  DOT1S_PORT_COMMON_t *p;
  L7_RC_t rc;

  p = dot1sIntfFind(intIfNum);
  if (p == L7_NULLPTR)
  {
	return;
  }

  switch (state)
  {
	case L7_DOT1S_DISABLED:
	  if (p->lastNotificationSent == L7_FORWARDING || p->lastNotificationSent == L7_LAST_PORT_EVENT)
	  {
		rc = dot1sIhNotifySystem(intIfNum, L7_NOT_FORWARDING);
		p->lastNotificationSent = L7_NOT_FORWARDING;
	  }
	  break;

	case L7_DOT1S_MANUAL_FWD: 
	  if (p->lastNotificationSent == L7_NOT_FORWARDING || p->lastNotificationSent == L7_LAST_PORT_EVENT)
	  {
		rc = dot1sIhNotifySystem(intIfNum, L7_FORWARDING);
		p->lastNotificationSent = L7_FORWARDING;
	  }
	  break;

	default:
	  /*With MSTP disbaled we should not get any other notifications*/
	  break;
  }


  return;
}
/*********************************************************************
* @purpose  This routine deterimines whether the stateset timer needs 
* 			to restart or not and adds the timer in osapiTimer
*           
*          
* @param    none
*
* @returns  none
*
* @comments Examines the MPC and NEC to determine whether there are any pending events
*  			that need to be acknoledged. Assumes that NEC has already been incremented by 1
* 			Assumes that NEC and MPC are unit32s.
*			Does not protect from more that 0xffffffff pending events. i.e. assumes that 
*           such a rollover has not occured. If such is the case then the system is in 
* 			a un recoverable state. 
*			
*			
* @end
*********************************************************************/
void dot1sStateSetTimerStart()
{
  /* We will not start the timer if NEC is greater than MPC by exactly 1 */
  if (((dot1sNEC > dot1sMPC) && (dot1sNEC - dot1sMPC == 1)) ||
	  ((dot1sNEC == 0) && (dot1sMPC == 0xFFFF)))
  {
	return;
  }
  else
  {
	/* Another set is pending*/
	if (dot1sStateSetTimer == L7_NULLPTR)
	{
	  /* Start a new osapi timer */
	  osapiTimerAdd(dot1sStateSetTimerExpired, (L7_uint32)dot1sCB[dot1sCBHead].intIfNum, L7_NULL, DOT1S_STATE_SET_TIMEOUT, &dot1sStateSetTimer);
	}
	return;
  }
  return;
}

void dot1sDebugCB(L7_uint32 printCB)
{
  L7_uint32 head, tail;
  /* Explicitly not taking the dot1sStateSetSema semaphore so that 
   * we do not affect the actual processing when we are printing out the 
   * entire CB buffer
   */ 

  SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
				"dot1sNEC: %d\n",dot1sNEC);
  SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
				"dot1sNECRollover: %d\n", dot1sNECRollover);
  SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
				"dot1sMPC: %d\n", dot1sMPC);
  SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
				"dot1sMPCRollover: %d\n", dot1sMPCRollover);
  SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
				"dot1sCBHead: %d\n", dot1sCBHead);
  SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
				"dot1sCBTail: %d\n", dot1sCBTail);
  if (printCB != 0)
  {
    head = dot1sCBHead;
	tail = dot1sCBTail;
	while (head != tail)
	{
	  SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
					"CB index %d contains intIfNum %d\n", head, dot1sCB[head].intIfNum);
	  head = ((head + 1)%DOT1S_STATE_SET_CB_SIZE);
	}
  }
  return;							
}

void dot1sTestCBTimer(L7_uint32 nec, L7_uint32 mpc)
{
  /* We will not start the timer if NEC is greater than MPC by exactly 1 */
  if (((nec > mpc) && (nec - mpc == 1)) ||
	  ((nec == 0) && (mpc == 0xFFFFFFFF)))
  {
	SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
				  "Will not start timer\n");
	return;
  }
  else
  {
	SYSAPI_PRINTF(SYSAPI_APPLICATION_LOGGING_ALWAYS,
				  "Will start timer\n");
	return;
  }
  return;


}

