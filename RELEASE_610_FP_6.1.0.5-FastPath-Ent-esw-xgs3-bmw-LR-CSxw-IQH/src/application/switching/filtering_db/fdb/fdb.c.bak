/*********************************************************************
*
* (C) Copyright Broadcom Corporation 2001-2007
*
**********************************************************************
* @filename fdb.c
*
* @purpose Forwarding Data Base Manager Main File
*
* @component fdb
*
* @comments none
*
* @create 09/14/2000
*
* @author bmutz
*
* @end
*
**********************************************************************/

#include <string.h>

#include "l7_common.h"
#include "osapi.h"
#include "osapi_support.h"
#include "sysapi.h"
#include "log.h"
#include "fdb.h"
#include "fdb_api.h"
#include "nvstoreapi.h"
#include "dot1q_api.h"
#include "nimapi.h"
#include "dtlapi.h"
#include "simapi.h"
#include "default_cnfgr.h"
#include "dtlapi.h"
#include "avl_api.h"
#include "fdb_sid.h"

#ifdef L7_METRO_FLEX_PACKAGE
#ifdef L7_DOT1AD_PACKAGE
  #include "dot1ad_api.h"
#endif
#endif

/* local prototypes */
L7_RC_t fdbIntfChangeCallback(L7_uint32 intIfNum, L7_uint32 event,NIM_CORRELATOR_t correlator);

static avlTreeTables_t   *fdbTreeHeap;
static dot1dTpFdbData_t  *fdbDataHeap;
static avlTree_t         fdbTreeData;
static fdb_stats_t       fdb_stats;
static void       *fdbQueue;
static fdbCfgData_t fdbCfgData;
static L7_int32          fdb_task_id;
static L7_FDB_TYPE_t        fdbType;

static fdbIdTable_s      *fdbIdTable;
static L7_uint32         *fdbIdUsed;
static L7_uint32         numberOfFDBIdUsed;

/*********************************************************************
* @purpose  get the next available fdbID.
*
* @param    vlanId      VLAN ID
* @param    *fdbId      next available FDB ID
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    Currently all this routine does is return the VLAN ID.  The
* @notes    fdbIdUsed array can be used to support a "next available"
* @notes    behavior where the FDB ID does not have to be equal to the
* @notes    VLAN ID.
*
* @end
*********************************************************************/
static L7_BOOL getFDBId(L7_uint32 vlanId, L7_uint32 *fdbId)
{
  L7_uint32 index;

  for (index = 0; index < L7_MAX_VLAN_PER_BRIDGE; index++)
  {
    if(fdbIdUsed[index] == vlanId)
    {
      *fdbId = index;
      return(L7_TRUE);
    }
  }

  return(L7_FALSE);
}

static L7_BOOL getNextFDBId(L7_uint32 vlanId, L7_uint32 *fdbId)
{
  L7_uint32 index;

  if(getFDBId(vlanId, fdbId) == L7_TRUE)
    return L7_TRUE;

  for (index = 0; index < L7_MAX_VLAN_PER_BRIDGE; index++)
  {
    if(fdbIdUsed[index] == L7_NULL)
    {
      *fdbId = index;
      return(L7_TRUE);
    }
  }

  return(L7_FALSE);
}

/*********************************************************************
* @purpose  Maximum number of entries in FDB
*
* @param    void
*
* @returns  count    current nnumber of FDB enties
*
* @notes    none
*
* @end
*********************************************************************/
L7_uint32 fdbMaxEntries(void)   /* Need to add fid when multiple database
                               are supported */
{
  return(fdb_stats.most_entries);
}

/*********************************************************************
*
* @purpose  To get the maximum number of entries that the FDB table
*           can hold.
*
* @param    L7_uint32  *maxEntries  total number of entries
*
* @returns  L7_SUCCESS
*
* @comments None.
*       
* @end
*
*********************************************************************/
L7_RC_t fdbMaxTableEntriesGet(L7_uint32 *maxEntries)
{
  *maxEntries = L7_MAX_FDB_MAC_ENTRIES;
  return L7_SUCCESS;
}
/*********************************************************************
* @purpose  Reset maximum number of entries in FDB
*
* @param    void
*
* @returns  void
*
* @notes    none
*
* @end
*********************************************************************/
void fdbMaxEntriesReset(void)   /* Need to add fid when multiple database
                                are supported */
{
  fdb_stats.most_entries = fdb_stats.cur_entries;
}

/*********************************************************************
* @purpose  Current number of entries in FDB
*
* @param    void
*
* @returns  count    current nnumber of FDB enties
*
* @notes    none
*
* @end
*********************************************************************/
L7_uint32 fdbActiveEntries(void)
{
  return(fdb_stats.cur_entries);
}

/*********************************************************************
* @purpose  Keep track of FDB counters global, per interface and vlan.    
*
* @param    L7_uint32   intIfNum  @((input))  internal interface number
* @param    L7_uint32   vlanId    @((input))  VLAN id
* @param    L7_ushort16 entryType @((input))  learned, static, etc.
* @param    L7_BOOL     insert    @((input))  insert or delete
*
* @returns  void
*
* @notes    none
*       
* @end
*********************************************************************/
static void fdbStatsUpdate(L7_uint32   intIfNum, 
                           L7_uint32   vlanId, 
                           L7_ushort16 entryType,
                           L7_BOOL     insert)
{
  L7_uint32 fdbId=0;
  if(getFDBId(vlanId, &fdbId) != L7_TRUE)
  {
    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_FDB_COMPONENT_ID,
           "Failure getting the forwarding database ID for vlanId %d",vlanId);
    return;
  }
  vlanId = fdbId;
  
  if (insert)
  {
    fdb_stats.cur_entries++;
    if (fdb_stats.cur_entries > fdb_stats.most_entries)
      fdb_stats.most_entries = fdb_stats.cur_entries;
  }
  else
  {
    fdb_stats.cur_entries--;
  }

  /* keep track of entry count based on type */
  if (entryType == L7_FDB_ADDR_FLAG_LEARNED)
  {
    if (insert == L7_TRUE)
    {
      fdb_stats.dynamic_entries++;
      fdb_stats.intfStats[intIfNum].dynamic_entries++;
      fdb_stats.vlanStats[vlanId].dynamic_entries++;
    } else
    {
      fdb_stats.dynamic_entries--;
      fdb_stats.intfStats[intIfNum].dynamic_entries--;
      fdb_stats.vlanStats[vlanId].dynamic_entries--;
    }
  }
  else if (entryType == L7_FDB_ADDR_FLAG_STATIC)
  {
    if (insert == L7_TRUE)
    {
      fdb_stats.static_entries++;
      fdb_stats.intfStats[intIfNum].static_entries++;
      fdb_stats.vlanStats[vlanId].static_entries++;
    } else
    {
      fdb_stats.static_entries--;
      fdb_stats.intfStats[intIfNum].static_entries--;
      fdb_stats.vlanStats[vlanId].static_entries--;
    }
  }
  else if (entryType == L7_FDB_ADDR_FLAG_MANAGEMENT ||
           entryType == L7_FDB_ADDR_FLAG_SELF)
  {
    if (insert == L7_TRUE)
    {
      fdb_stats.internal_entries++;
      fdb_stats.intfStats[intIfNum].internal_entries++;
      fdb_stats.vlanStats[vlanId].internal_entries++;
    } else
    {
      fdb_stats.internal_entries--;
      fdb_stats.intfStats[intIfNum].internal_entries--;
      fdb_stats.vlanStats[vlanId].internal_entries--;
    }
  }
  return;
}

/*********************************************************************
* @purpose  FDB insert mac to avl tree
*
* @param    mac_addr    pointer to a mac address
* @param    intIfNum    internal interface number
* @param    vlanId      vlan Id
* @param    entryType   entry type
*
* @returns  void
*
* @notes    none
*
* @end
*********************************************************************/
void fdbInsert(char *mac, L7_uint32 intIfNum,
               L7_uint32 vlanId, L7_ushort16 entryType)
{
  dot1dTpFdbData_t data;
  dot1dTpFdbData_t *pData;
  L7_ushort16      vid;
  L7_uint32        ivlLength = 0;
  L7_uint32        state;
  L7_INTF_TYPES_t  type;

  vid = (L7_ushort16)vlanId;

  vid = osapiHtons(vid); /* convert to network byte order for display purposes */

  fdb_stats.total_adds++;

  memset(data.dot1dTpFdbAddress,0x00,L7_FDB_KEY_SIZE);

  /* some of the outdated events for adding fdb entry in the message queue 
     can exists even after interface has gone down. 
     So this check is required to discard those events */
  if(nimGetIntfType(intIfNum,&type) != L7_SUCCESS)
  {
    return;
  }
  else if(type != L7_CPU_INTF)
  {
    if(nimGetIntfLinkState(intIfNum,&state) != L7_SUCCESS ||
         ( (state != L7_UP)&& (entryType == L7_FDB_ADDR_FLAG_LEARNED)) ) /*Fix for 63128 Issue*/
    {
      return;
    }
  }

  if (fdbType == L7_IVL)
  {
    ivlLength = L7_FDB_IVL_ID_LEN;
    memcpy(data.dot1dTpFdbAddress,&vid,ivlLength);
  }
  memcpy(&data.dot1dTpFdbAddress[ivlLength], mac, L7_FDB_MAC_ADDR_LEN);
  data.dot1dTpFdbPort = intIfNum;
  data.dot1dTpFdbEntryType = entryType;

  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);

  pData = avlInsertEntry(&fdbTreeData, &data);

  if (pData == L7_NULL)
  {
    fdbStatsUpdate(intIfNum, vlanId, entryType, L7_TRUE);
  }
  else if (memcmp(pData, &data, (sizeof(dot1dTpFdbData_t) - 4)) == L7_NULL)
  {
    fdb_stats.bad_adds++;
  }
  else if (pData)
  {
    pData->dot1dTpFdbPort = intIfNum;
    pData->dot1dTpFdbEntryType = entryType;

    fdb_stats.dup_adds++;
  }

  osapiSemaGive(fdbTreeData.semId);

}

/*********************************************************************
* @purpose  FDB del mac from avl tree
*
* @param    mac_addr    pointer to a mac address
* @param    vlanId      vlan Id
*
* @returns  void
*
* @notes    none
*
* @end
*********************************************************************/
void fdbDelete(char *mac,L7_uint32 vlanId)
{
  dot1dTpFdbData_t data;
  dot1dTpFdbData_t *pData;
  L7_ushort16      vid;
  L7_uint32        ivlLength = 0;

  vid = (L7_ushort16)vlanId;

  vid = osapiHtons(vid); /* convert to network byte order for display purposes */

  memset(data.dot1dTpFdbAddress,0x00,L7_FDB_KEY_SIZE);
  if (fdbType == L7_IVL)
  {
    ivlLength = L7_FDB_IVL_ID_LEN;
    memcpy(data.dot1dTpFdbAddress,&vid,ivlLength);
  }
  memcpy(&data.dot1dTpFdbAddress[ivlLength], mac, L7_FDB_MAC_ADDR_LEN);

  fdb_stats.total_dels++;

  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);

  /* get the interface and entry type so we can update our entry type stats */
  if ((pData = (dot1dTpFdbData_t *)avlSearchLVL7(&fdbTreeData, (void *)data.dot1dTpFdbAddress, 
                                                 L7_MATCH_EXACT)) != L7_NULLPTR)
  {
    fdbStatsUpdate(pData->dot1dTpFdbPort, vlanId, pData->dot1dTpFdbEntryType, L7_FALSE);
  } 
  else
  {
    L7_LOGF(L7_LOG_SEVERITY_DEBUG, L7_FDB_COMPONENT_ID,
             "fdbDelete: received delete for unexpected FDB entry:"
             "(%02X:%02X:%02X:%02X:%02X:%02X - %d).\n",
             mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], vlanId);
    fdb_stats.bad_dels++;
    osapiSemaGive(fdbTreeData.semId);
    return;
  }

  avlDeleteEntry(&fdbTreeData, pData);
  osapiSemaGive(fdbTreeData.semId);
  return;
}

/*********************************************************************
* @purpose  FDB find mac in avl tree
*
* @param    mac_addr    pointer to a mac address
* @param    matchType   L7_MATCH_EXACT or L7_MATCH_NEXT
* @parm     pData       pointer to a fdb data struct
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbFind(char *mac, L7_uint32 matchType, dot1dTpFdbData_t *pData)
{
  dot1dTpFdbData_t *pfdbData;

  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);

  pfdbData = avlSearchLVL7(&fdbTreeData, mac, matchType);

  if (pfdbData != L7_NULL)
    memcpy(pData, pfdbData, sizeof(dot1dTpFdbData_t));

  osapiSemaGive(fdbTreeData.semId);

  if (pfdbData == L7_NULL)
  {
    return(L7_FAILURE);
  }
  return(L7_SUCCESS);
}

/*********************************************************************
* @purpose  Del the systems cpu mac address to table
*
* @param    mac_addr    pointer to a mac address
* @param    vlanId      management vlan id
* @param    intIfNum    internal interface number
* @parm     entryType  L7_FDB_ADDR_FLAG_t
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbSysMacDelEntry(L7_uchar8 *macAddr, L7_uint32 vlanId, L7_uint32 intIfNum, L7_uchar8 entryType)
{
  fdbLearnMsg_t fdbMsg;
  L7_FDB_TYPE_t type;

  fdbMsg.entryType = L7_FDB_ADDR_FLAG_MANAGEMENT;
  fdbMsg.intIfNum = intIfNum;

  fdbGetTypeOfVL(&type);
  if (type == L7_SVL)
    fdbMsg.vlanId   = FDB_MEMBER_VLAN_INDEPNDENT;
  else
    fdbMsg.vlanId   = vlanId;

  fdbMsg.msgsType = FDB_DEL;

  memcpy(fdbMsg.mac_addr, macAddr, L7_MAC_ADDR_LEN);

  /*there is no dapi call as this is only done in conjunction with the fdbSysmacAddEntry */
  /*   which takes care of deleting the system mac addr entry in the driver */

  if (osapiMessageSend(fdbQueue, &fdbMsg, sizeof(fdbLearnMsg_t), L7_NO_WAIT, L7_MSG_PRIORITY_NORM) != L7_SUCCESS)
    return(L7_FAILURE);

  return(L7_SUCCESS);
}

/*********************************************************************
* @purpose  Add the systems cpu mac address to table
*
* @param    mac_addr    pointer to a mac address
* @param    intIfNum    internal interface number
* @parm     entryType  L7_FDB_ADDR_FLAG_t
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbSysMacAddEntry(L7_uchar8 *macAddr, L7_uint32 vlanId, L7_uint32 intIfNum, L7_uchar8 entryType)
{
  fdbLearnMsg_t fdbMsg;
  L7_FDB_TYPE_t type;
  L7_ushort16 vlan;

  if (nimPhaseStatusCheck() != L7_TRUE)
  {
    return L7_ERROR;
  }

  fdbMsg.entryType = entryType;
  fdbMsg.intIfNum = intIfNum;

  fdbGetTypeOfVL(&type);
  if (type == L7_SVL)
    fdbMsg.vlanId   = FDB_MEMBER_VLAN_INDEPNDENT;
  else
    fdbMsg.vlanId   = vlanId;

  fdbMsg.msgsType = FDB_ADD;
  memcpy(fdbMsg.mac_addr, macAddr, L7_MAC_ADDR_LEN);

  vlan = vlanId;
  if (osapiMessageSend(fdbQueue, &fdbMsg, sizeof(fdbLearnMsg_t), L7_NO_WAIT, L7_MSG_PRIORITY_NORM) == L7_SUCCESS)
    return (dtlFdbMacAddrSystemSet(macAddr, vlan, entryType));
  else
    return(L7_FAILURE);

  return(L7_SUCCESS);
}

/*********************************************************************
* @purpose  Add an entry into cpu and network processor FDB table
*
* @param    fdbMemberInfo   pointer to a member information
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbAddEntry(fdbMeberInfo_t *fdbMemberInfo)
{
  fdbLearnMsg_t fdbMsg;
  L7_FDB_ADDR_FLAG_t  dtlFlag;
  L7_INTF_TYPES_t sysIntfType;

  fdbMsg.entryType = fdbMemberInfo->entryType;
  fdbMsg.intIfNum  = fdbMemberInfo->intIfNum;
  fdbMsg.vlanId    = fdbMemberInfo->vlanId;
  fdbMsg.msgsType  = FDB_ADD;
  memcpy(fdbMsg.mac_addr, fdbMemberInfo->macAddr, L7_MAC_ADDR_LEN);

  dtlFlag = fdbMemberInfo->entryType;

  fdbMsg.entryType = dtlFlag;

  if ((nimGetIntfType(fdbMemberInfo->intIfNum, &sysIntfType) == L7_SUCCESS) && (sysIntfType != L7_CPU_INTF))
  {
    if (osapiMessageSend(fdbQueue, &fdbMsg, sizeof(fdbLearnMsg_t), L7_NO_WAIT, L7_MSG_PRIORITY_NORM ) == L7_SUCCESS)
    {
//    if (dtlFdbMacAddrAdd(fdbMemberInfo->macAddr,
//                         fdbMemberInfo->intIfNum,
//                         fdbMemberInfo->vlanId,
//                         dtlFlag,
//                         L7_NULL) == L7_SUCCESS)
//    {
        return(L7_SUCCESS);
//    }
    }
  }

  return(L7_FAILURE);
}

/*********************************************************************
* @purpose  Del an entry into cpu and network processor FDB table
*
* @param    fdbMemberInfo   pointer to a member information
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbDelEntry(fdbMeberInfo_t *fdbMemberInfo)
{
  fdbLearnMsg_t fdbMsg;
  L7_FDB_ADDR_FLAG_t  dtlFlag;

  /* Determine the type of mac address entry */
  dtlFlag = fdbMemberInfo->entryType;

  fdbMsg.msgsType = FDB_DEL;
  memcpy(fdbMsg.mac_addr, fdbMemberInfo->macAddr, L7_MAC_ADDR_LEN);
  fdbMsg.intIfNum = fdbMemberInfo->intIfNum;
  fdbMsg.vlanId = fdbMemberInfo->vlanId;
  fdbMsg.entryType = dtlFlag;

  if (osapiMessageSend(fdbQueue, &fdbMsg, sizeof(fdbLearnMsg_t), L7_NO_WAIT, L7_MSG_PRIORITY_NORM) == L7_SUCCESS)
  {
//  dtlFdbMacAddrDelete(fdbMemberInfo->macAddr,
//                      fdbMemberInfo->intIfNum,
//                      fdbMemberInfo->vlanId,
//                      dtlFlag,
//                      L7_NULL);
  }
  else
    return(L7_FAILURE);

  return(L7_SUCCESS);
}



/*********************************************************************
* @purpose  Set the FDB ID in the dot1q VLAN current table
*
* @param    vlanId      VLAN ID
* @param    *fdbId       FDB ID
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbFdbIDGet(L7_uint32 vlanId, L7_uint32 *fdbId)
{


  if ((vlanId <  L7_DOT1Q_MIN_VLAN_ID) || (vlanId >L7_DOT1Q_MAX_VLAN_ID))
  {
      return L7_FAILURE;
  }

  return (getFDBId(vlanId, fdbId) == L7_TRUE) ? L7_SUCCESS : L7_FAILURE;
}

/*********************************************************************
* @purpose  FDB callback for notification of learned entries
*
* @param    mac_addr    pointer to a mac address
* @param    intIfNum    internal interface number
* @parm     msgsType    FDB_ADD or FDB_DEL to add or delete an
* @parm                 address entry
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
void fdbLearnEntryCallBack(L7_uchar8 *macAddr, L7_uint32 intIfNum,
                           L7_uint32 vlanId, L7_uchar8 msgsType)
{
  /* Previously, this function put a message on the fdbQueue so that
     the fdbTask would process the inserts and deletes.  However, this
     can cause a problem, in that the fdbQueue can be full and the
     fdbTask will never see the message.  This is a problem in the case of
     an address aged by the NP because the driver has already told the NP
     to go ahead and delete the address.

     Since fdbInsert() and fdbDelete() make use of a semaphore to
     protect the FDB, it should not be necessary to serialize these actions
     through the fdbTask.  Consequently, we will go ahead and take the
     appropriate action inside of this routine. */

  if (msgsType == FDB_ADD)
  {
    fdbInsert(macAddr, intIfNum, vlanId, L7_FDB_ADDR_FLAG_LEARNED);
  }
  else
  {
    fdbDelete(macAddr, vlanId);
  }
}

/*********************************************************************
* @purpose  Checks if fdb user config data has changed
*
* @param    void
*
* @returns  L7_TRUE or L7_FALSE
*
* @notes    none
*
* @end
*********************************************************************/
L7_BOOL fdbHasDataChanged(void)
{
  return(fdbCfgData.cfgHdr.dataChanged);
}
void fdbResetDataChanged(void)
{
  fdbCfgData.cfgHdr.dataChanged = L7_FALSE;
  return;
}
/*********************************************************************
* @purpose  Saves fdb user config file to NVStore
*
* @param    void
*
* @returns  L7_SUCCESS or L7_FALIURE
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbSave(void)
{

  L7_RC_t rc=L7_SUCCESS;

  if (fdbCfgData.cfgHdr.dataChanged == L7_TRUE)
  {
    fdbCfgData.cfgHdr.dataChanged = L7_FALSE;
    fdbCfgData.checkSum = nvStoreCrc32((L7_char8 *)&fdbCfgData,
                                       sizeof(fdbCfgData) - sizeof(fdbCfgData.checkSum));

    /* call save NVStore routine */
    if (sysapiCfgFileWrite(L7_FDB_COMPONENT_ID, FDB_CFG_FILENAME, (L7_char8 *)&fdbCfgData,
                           sizeof (fdbCfgData)) == L7_ERROR)
    {
      LOG_MSG("Error on call to osapiFsWrite routine on config file %s\n",FDB_CFG_FILENAME);
    }
  }
  return(rc);
}

/*********************************************************************
* @purpose  Build default fdb config data
*
* @param    ver   Software version of Config Data
*
* @returns  void
*
* @notes    none
*
* @end
*********************************************************************/
void fdbBuildDefaultConfigData(L7_uint32 ver)
{
  L7_uint32 i;
  L7_uint32 maxFdb;
  L7_uint32 agingTime;

  maxFdb = fdbSidMaxFdbGet();
  agingTime  = fdbSidDefaultAgingTimeoutGet();

  memset(( void * )&fdbCfgData, 0, sizeof( fdbCfgData_t));
  strcpy(fdbCfgData.cfgHdr.filename, FDB_CFG_FILENAME);
  fdbCfgData.cfgHdr.version = ver;
  fdbCfgData.cfgHdr.componentID = L7_FDB_COMPONENT_ID;
  fdbCfgData.cfgHdr.type = L7_CFG_DATA;
  fdbCfgData.cfgHdr.length = sizeof(fdbCfgData_t);
  fdbCfgData.cfgHdr.dataChanged = L7_FALSE;
  fdbCfgData.cfgHdr.version = ver;

  /* Assuming i directly maps to fid */
  for (i=0; i< maxFdb; i++)
  {
    fdbCfgData.fdbFIDData[i].fid = i;
    fdbCfgData.fdbFIDData[i].vlanId = L7_NULL;
    fdbCfgData.fdbFIDData[i].addressAgingTimeOut = agingTime;
  }

  return;
}

/*********************************************************************
* @purpose  FDB Task
*
* @param    void
*
* @returns  void
*
* @notes    none
*
* @end
*********************************************************************/
void fdbTask( void )
{
  L7_RC_t status = L7_FAILURE;
  fdbLearnMsg_t message;

  if (fdbQueue == NULL)
  {
    LOG_MSG("fdb Task: Failed to create, exiting....\n");
  }
  else
  {
    while (1)
    {
      status = osapiMessageReceive(fdbQueue, (void *)&message, sizeof(fdbLearnMsg_t), L7_WAIT_FOREVER);

      if (status == L7_FAILURE)
        continue;

      switch (message.msgsType)
      {
        case FDB_ADD:
          if (fdbActiveEntries()<L7_MAX_FDB_MAC_ENTRIES)
          {  
            if (dtlFdbMacAddrAdd(message.mac_addr,
                                 message.intIfNum,
                                 message.vlanId,
                                 message.entryType,
                                 L7_NULL)==L7_SUCCESS)
            {
              fdbInsert(message.mac_addr, message.intIfNum,
                        message.vlanId,message.entryType);
            }
          }
          break;

        case FDB_DEL:
          fdbDelete(message.mac_addr,message.vlanId);
          dtlFdbMacAddrDelete(message.mac_addr,
                              message.intIfNum,
                              message.vlanId,
                              message.entryType,
                              L7_NULL);
          break;

        default:
          break;
      }
    }
  }
  return;
}


/*********************************************************************
* @purpose  Returns the Unit's System Address Aging Time Out
*
* @param    fid      Filtering Database Id
*
* @returns  timeOut  System Address Aging Time Out
*
* @notes    none
*
* @end
*********************************************************************/
L7_uint32 fdbGetAddressAgingTimeOut(L7_uint32 fid)
{
  L7_FDB_TYPE_t type;

  fdbGetTypeOfVL(&type);

  if (type == L7_IVL)
  {
    if(getFDBId(fid, &fid) != L7_TRUE)
    {
      L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_FDB_COMPONENT_ID,
           "Failure getting the forwarding database ID for fid %d",fid);
      return L7_FAILURE;
    }
    return(fdbCfgData.fdbFIDData[fdbIdTable[fid].fdbId].addressAgingTimeOut);
  }

  return(fdbCfgData.fdbFIDData[fid].addressAgingTimeOut);
}

/*********************************************************************
* @purpose  Sets the Unit's System Flow Control Mode
*
* @param    timeOut  System Address Aging Time Out
* @param    fid      Filtering Database Id
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbSetAddressAgingTimeOut(L7_uint32 timeOut, L7_uint32 fid)
{
  L7_RC_t rc = L7_FAILURE;
  L7_FDB_TYPE_t type;

  fdbGetTypeOfVL(&type);

  if (type == L7_IVL)
  {
    if(getFDBId(fid, &fid) != L7_TRUE)
    {
      L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_FDB_COMPONENT_ID,
           "Failure getting the forwarding database ID for fid %d",fid);
      return L7_FAILURE;
    } 
    fdbCfgData.fdbFIDData[fdbIdTable[fid].fdbId].addressAgingTimeOut = timeOut;
  }
  else
  {
    fdbCfgData.fdbFIDData[fid].addressAgingTimeOut = timeOut;
  }

  /* Call dtl to set the Address Aging timeout */
  rc = dtlFdbAddressAgingTimeOutSet(fdbCfgData.fdbFIDData[fid].vlanId, timeOut);
  if (rc !=L7_SUCCESS)
  {
    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_FDB_COMPONENT_ID,
        "Failure setting fid %d address aging timeout to %d."
        " Unable to set the age time in the hardware", fid, timeOut);
  }

  fdbCfgData.cfgHdr.dataChanged = L7_TRUE;

  return(rc);
}



/*********************************************************************
* @purpose  wrapper routine to retrive the internal interface number associated
*
* @param    *mac        pointer to the mac address to search for
* @param    *intIfNum   pointer to the interface number to be returned
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    with a MAC address from the arp table maintained in DTL
*
* @end
*********************************************************************/
L7_RC_t fdbMacToIntfGet(L7_uchar8 *mac, L7_uint32 *intIfNum)
{

  return(dtlFdbMacToIntfGet(mac,intIfNum));

}

/*********************************************************************
* @purpose  return the type of supported VL
*
* @param    type       pointer to the type
*
* @returns  L7_SUCCESS or L7_FAILURE
*
* @notes    with a MAC address from the arp table maintained in DTL
*
* @end
*********************************************************************/
L7_RC_t fdbGetTypeOfVL(L7_FDB_TYPE_t *type)
{
  *type = fdbType;
  return(L7_SUCCESS);
}


/*********************************************************************
* @purpose  Callback function to process VLAN changes.
*
* @param    vlanId      VLAN ID
* @param    intIfnum    internal interface whose state has changed
* @param    event       VLAN event (see vlanNotifyEvent_t for list)
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes
*
* @end
*********************************************************************/
L7_RC_t fdbVlanChangeCallback(dot1qNotifyData_t *vlanData, L7_uint32 intIfNum, L7_uint32 event)
{
  fdbMeberInfo_t fdbMemberInfo;
  L7_FDB_TYPE_t     type;
  L7_uint32      fdbId;
  L7_char8       mac[L7_MAC_ADDR_LEN];
  L7_uint32      i = 0, vlanId = 0, numVlans = 0;

  fdbGetTypeOfVL(&type);

  if (type == L7_IVL)
  {
    for (i = 1; i<=L7_VLAN_MAX_MASK_BIT; i++) 
    {
      if (vlanData->numVlans == 1) 
      {
          vlanId = vlanData->data.vlanId;
          /* For any continue, we will break out */
          i = L7_VLAN_MAX_MASK_BIT + 1;
      }
      else
      {
          if (L7_VLAN_ISMASKBITSET(vlanData->data.vlanMask,i)) 
          {
              vlanId = i;
          }
          else
          {
              if (numVlans == vlanData->numVlans) 
              {
                  /* Already taken care of all the bits in the mask so break out of for loop */
                  break;
              }
              else
              {
                  /* Vlan is not set check for the next bit since there are more bits that are set*/
                  continue;
              }
          }
      }

      switch (event)
      {
          case VLAN_ADD_NOTIFY:
            if (getNextFDBId(vlanId, &fdbId) == L7_TRUE)
            {
          fdbIdTable[fdbId].insue = L7_TRUE;
          fdbIdTable[fdbId].fdbId =  fdbId;
              fdbIdUsed[fdbId] = vlanId;
              if (fdbCfgData.fdbFIDData[fdbId].vlanId != vlanId)
              {
                fdbCfgData.fdbFIDData[fdbId].vlanId = vlanId;
                fdbCfgData.fdbFIDData[fdbId].fid    = fdbId;
              }
              if (vlanId == FD_DOT1Q_DEFAULT_VLAN)
              {
                /* Set it only once, as the driver has only one age time that is used for all fdbs */
                dtlFdbAddressAgingTimeOutSet(fdbCfgData.fdbFIDData[fdbId].vlanId,
                                             fdbCfgData.fdbFIDData[fdbId].addressAgingTimeOut);
              }
            }
            break;
    
          case VLAN_DELETE_NOTIFY:
            if(getFDBId(vlanId, &fdbId) == L7_TRUE)
            {
              fdbIdUsed[fdbId] = L7_NULL;
              fdbIdTable[fdbId].insue = L7_FALSE;
              fdbIdTable[fdbId].fdbId = L7_NULL;
            }
            else
            { 
              L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_FDB_COMPONENT_ID,
                        "Failure getting the forwarding database ID for vlanId %d",vlanId);
              return L7_FAILURE;
            }

            if (fdbType == L7_IVL)
            {
              #if defined(FEAT_METRO_CPE_V1_0)
              L7_uchar8          keyNext[L7_FDB_KEY_SIZE] = {0};
              L7_uchar8          vlanStr[L7_FDB_IVL_ID_LEN];
              dot1dTpFdbData_t   fdbEntry;
              L7_enetMacAddr_t   macAddr;
              L7_ushort16        vid;
              
              vid = (L7_ushort16)vlanId;
              vid = osapiHtons(vid);

              /*
               *Mimic SVL for dot1ad service vlans.
               *When a new service is subscribed on an interface,learn the
               *existing mac entries with new service vlan.
               */
              memcpy(vlanStr,&vid,L7_FDB_IVL_ID_LEN);
              while(L7_SUCCESS == fdbFind(keyNext, L7_MATCH_GETNEXT, &fdbEntry))
              {
                memcpy(&keyNext[0], fdbEntry.dot1dTpFdbAddress, L7_FDB_KEY_SIZE);
                if ( 
                     (memcmp((fdbEntry.dot1dTpFdbAddress),vlanStr,L7_FDB_IVL_ID_LEN)==0)&&
                     (fdbEntry.dot1dTpFdbEntryType == L7_FDB_ADDR_FLAG_STATIC)
                   )
                {
                  memcpy(macAddr.addr, &fdbEntry.dot1dTpFdbAddress[2],L7_MAC_ADDR_LEN);
                  memcpy(fdbMemberInfo.macAddr,macAddr.addr,L7_MAC_ADDR_LEN);
                  fdbMemberInfo.intIfNum = intIfNum;
                  fdbMemberInfo.vlanId = vlanId;
                  fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_LEARNED;
                  dtlFdbMacAddrAdd(fdbMemberInfo.macAddr,
                                   fdbMemberInfo.intIfNum,
                                   fdbMemberInfo.vlanId,
                                   L7_FDB_ADDR_FLAG_STATIC,
                                  L7_NULL);
                 fdbDelete(macAddr.addr,vlanId);
                }
              }
             #endif
            }
            break;
    
          case VLAN_ADD_PORT_NOTIFY:
            if (fdbType == L7_IVL)
            {
#if defined(FEAT_METRO_CPE_V1_0)
             dtlDot1sFlush (intIfNum);
#endif
#if 0
#if defined(FEAT_METRO_CPE_V1_0)
              L7_uchar8          keyNext[L7_FDB_KEY_SIZE] = {0};
              L7_uchar8          keyExact[L7_FDB_KEY_SIZE] = {0};
              dot1dTpFdbData_t   fdbEntry;
              L7_enetMacAddr_t   macAddr;
              L7_BOOL            flag = L7_FALSE;     
              /*
               *Mimic SVL for dot1ad service vlans.
               *When a new service is subscribed on an interface,learn the 
               *existing mac entries with new service vlan.
               */   
              while(L7_SUCCESS == fdbFind(keyNext, L7_MATCH_GETNEXT, &fdbEntry))
              {
                memcpy(&keyNext[0], fdbEntry.dot1dTpFdbAddress, L7_FDB_KEY_SIZE);
                if (fdbEntry.dot1dTpFdbPort == intIfNum)
                {
                  memcpy(macAddr.addr, &fdbEntry.dot1dTpFdbAddress[2],L7_MAC_ADDR_LEN);
                  if(L7_SUCCESS == dot1adServiceServiceVidIsConfigured(vlanId,&flag))
                  {
                    if(L7_TRUE == flag)
                    {
                      memcpy(&keyExact[0], &vlanId, sizeof(L7_ushort16));
                      memcpy(&keyExact[2], &macAddr.addr, L7_MAC_ADDR_LEN);
                      if(L7_SUCCESS != fdbFind(keyExact, L7_MATCH_EXACT, &fdbEntry))
                      {
                        memcpy(fdbMemberInfo.macAddr,macAddr.addr,L7_MAC_ADDR_LEN);
                        fdbMemberInfo.intIfNum = intIfNum;
                        fdbMemberInfo.vlanId = vlanId;
                        fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_LEARNED;
                        if (dtlFdbMacAddrAdd(fdbMemberInfo.macAddr,
                                         fdbMemberInfo.intIfNum,
                                         fdbMemberInfo.vlanId,
                                         L7_FDB_ADDR_FLAG_STATIC,
                                         L7_NULL) == L7_SUCCESS)
                        {
                          fdbInsert(fdbMemberInfo.macAddr,
                                    fdbMemberInfo.intIfNum,
                                    vlanId,
                                    L7_FDB_ADDR_FLAG_STATIC);  
                        }
                      }
                    }
                  }
                }
              }
#endif
#endif
              /* Do not store self addresses in an IVL tree if they will consume
                 too many of the FDB entries */
              if (L7_FDB_IVL_STORE_SELF_ADDRESSES == L7_FALSE)
              {
                break;
              }
            }
    
            /* add mac address to FWD DB */
            nimGetIntfAddress(intIfNum, L7_NULL, mac);
            memcpy(fdbMemberInfo.macAddr,mac,L7_MAC_ADDR_LEN);
            fdbMemberInfo.intIfNum = intIfNum;
            fdbMemberInfo.vlanId = vlanId;
            fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_SELF;
            fdbAddEntry(&fdbMemberInfo);
            break;
    
          case VLAN_DELETE_PORT_NOTIFY:
    
            if (fdbType == L7_IVL)
            {
              /* Do not store self addresses in an IVL tree if they will consume
                 too many of the FDB entries */
              if (L7_FDB_IVL_STORE_SELF_ADDRESSES == L7_FALSE)
              {
                break;
              }
            }
            nimGetIntfAddress(intIfNum, L7_NULL, mac);
            memcpy(fdbMemberInfo.macAddr,mac,L7_MAC_ADDR_LEN);
            fdbMemberInfo.intIfNum = intIfNum;
            fdbMemberInfo.vlanId = vlanId;
            fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_SELF;
            fdbDelEntry(&fdbMemberInfo);
            if (fdbType == L7_IVL)
            {
              #if defined(FEAT_METRO_CPE_V1_0)
              L7_uchar8          keyNext[L7_FDB_KEY_SIZE] = {0};
              L7_uchar8          vlanStr[L7_FDB_IVL_ID_LEN];
              dot1dTpFdbData_t   fdbEntry;
              L7_enetMacAddr_t   macAddr;
              L7_ushort16        vid;

              vid = (L7_ushort16)vlanId;
              vid = osapiHtons(vid);

              /*
               *Mimic SVL for dot1ad service vlans.
               *When a new service is subscribed on an interface,learn the
               *existing mac entries with new service vlan.
               */
              memcpy(vlanStr,&vid,L7_FDB_IVL_ID_LEN);
              while(L7_SUCCESS == fdbFind(keyNext, L7_MATCH_GETNEXT, &fdbEntry))
              {
                memcpy(&keyNext[0], fdbEntry.dot1dTpFdbAddress, L7_FDB_KEY_SIZE);
                if ( (fdbEntry.dot1dTpFdbPort == intIfNum) &&
                     (memcmp((fdbEntry.dot1dTpFdbAddress),vlanStr,L7_FDB_IVL_ID_LEN)==0)&&
                     (fdbEntry.dot1dTpFdbEntryType == L7_FDB_ADDR_FLAG_STATIC)
                   )
                {
                  memcpy(macAddr.addr, &fdbEntry.dot1dTpFdbAddress[2],L7_MAC_ADDR_LEN);
                  memcpy(fdbMemberInfo.macAddr,macAddr.addr,L7_MAC_ADDR_LEN);
                  fdbMemberInfo.intIfNum = intIfNum;
                  fdbMemberInfo.vlanId = vlanId;
                  fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_LEARNED;
                  dtlFdbMacAddrAdd(fdbMemberInfo.macAddr,
                                   fdbMemberInfo.intIfNum,
                                   fdbMemberInfo.vlanId,
                                   L7_FDB_ADDR_FLAG_STATIC,
                                  L7_NULL);
                 fdbDelete(macAddr.addr,vlanId);
                }
              }
             #endif
            }

            break;
    
          default:
            break;
        }
      numVlans++;
    }
  }

  return(L7_SUCCESS);
}

/*********************************************************************
* @purpose  get the next fdbID starting from a certain index.
*
* @param    startfrom   index to start search from
* @param    fdbId       pointer to the return value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes
*
* @end
*********************************************************************/
L7_RC_t fdbIdNextGet(L7_uint32 startfrom, L7_uint32 *fdbId)
{
  L7_uint32 index;

  for (index = startfrom; index < L7_MAX_VLAN_PER_BRIDGE; index++)
  {
    if (fdbIdTable[index].insue == L7_TRUE)
    {
      *fdbId = index;
      return(L7_SUCCESS);
    }
  }

  return(L7_FAILURE);
}

/*********************************************************************
* @purpose  check to see if an FDB exists based on an FDB ID.
*
* @param    fdbId       FDB ID to be checked
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes
*
* @end
*********************************************************************/
L7_RC_t fdbIdGet(L7_uint32 fdbId)
{
  if ( (fdbId < L7_MAX_VLAN_PER_BRIDGE) && (fdbIdTable[fdbId].insue == L7_TRUE) )
    return(L7_SUCCESS);

  return(L7_FAILURE);
}

/*********************************************************************
* @purpose  Returns the number of failed FDB insert attempts due to
*           failure to allocate space.
*
* @param    *badAdds     pointer to the number of failed FDB inserts to
*                        be returned
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbBadAddsGet(L7_uint32 *badAdds)
{
  *badAdds = fdb_stats.bad_adds;
  return(L7_SUCCESS);
}

/*********************************************************************
* @purpose  Flush all learned entries from the L2FDB.
*
* @param    none
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbFlush(void)
{
#if 0
  dot1dTpFdbData_t *entry = L7_NULLPTR;
  L7_uchar8         key[L7_FDB_KEY_SIZE];
#endif

  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  if (dtlDot1sFlushAll() != L7_SUCCESS)
  {
    osapiSemaGive(fdbTreeData.semId);
    return L7_FAILURE;
  }
#if 0
  memset(key, 0, L7_FDB_KEY_SIZE);
  while ((entry = avlSearchLVL7(&fdbTreeData, key, L7_MATCH_GETNEXT)) != L7_NULLPTR)
  {
    if (entry->dot1dTpFdbEntryType == L7_FDB_ADDR_FLAG_LEARNED)
    {
      /* delete current entry from tree */
      avlDeleteEntry(&fdbTreeData, entry);
      fdb_stats.total_dels++;
      fdb_stats.cur_entries--;
    } else
    {
      /* copy current key */
      memcpy(key, entry->dot1dTpFdbAddress, L7_FDB_KEY_SIZE);
    }
  }
  fdb_stats.dynamic_entries = 0;
#endif
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of static entries in the L2FDB.
*
* @param    L7_uint32     *entries   @{{output}}  Number of static entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbStaticEntriesGet(L7_uint32 *entries)
{
  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  *entries = fdb_stats.static_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of static entries in the L2FDB for a specific interface
*
* @param    L7_uint32     intIfNum   @((input))   Internal interface number
* @param    L7_uint32     *entries   @{{output}}  Number of static entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbIntfStaticEntriesGet(L7_uint32 intIfNum,
                                L7_uint32 *entries)
{
  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  *entries = fdb_stats.intfStats[intIfNum].static_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of static entries in the L2FDB for a specific VLAN
*
* @param    L7_ushort16    vlanId    @((input))   VLAN identifier
* @param    L7_uint32     *entries   @{{output}}  Number of static entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbVlanStaticEntriesGet(L7_ushort16  vlanId,
                                L7_uint32   *entries)
{
  L7_uint32 fdbId;
  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  if(getFDBId(vlanId, &fdbId) != L7_TRUE)
  {
    L7_LOGF(L7_LOG_SEVERITY_ERROR, L7_FDB_COMPONENT_ID,
           "Failure getting the forwarding database ID for vlanId %d",vlanId);

    osapiSemaGive(fdbTreeData.semId);
    return L7_FAILURE;
  }

  if (fdbIdGet(fdbId) != L7_SUCCESS)
  {
    osapiSemaGive(fdbTreeData.semId);
    return L7_FAILURE;
  }

  vlanId = fdbId;

  *entries = fdb_stats.vlanStats[vlanId].static_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of dynamic entries in the L2FDB.
*
* @param    L7_uint32     *entries   @{{output}}  Number of dynamic entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbDynamicEntriesGet(L7_uint32 *entries)
{
  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  *entries = fdb_stats.dynamic_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of dynamic entries in the L2FDB for a specific interface
*
* @param    L7_uint32     intIfNum   @((input))   Internal interface number
* @param    L7_uint32     *entries   @{{output}}  Number of static entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbIntfDynamicEntriesGet(L7_uint32 intIfNum,
                                 L7_uint32 *entries)
{
  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  *entries = fdb_stats.intfStats[intIfNum].dynamic_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of dynamic entries in the L2FDB for a specific VLAN
*
* @param    L7_ushort16    vlanId    @((input))   VLAN identifier
* @param    L7_uint32     *entries   @{{output}}  Number of static entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbVlanDynamicEntriesGet(L7_ushort16 vlanId,
                                 L7_uint32   *entries)
{
  L7_uint32 fdbId;

  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  if ((getFDBId(vlanId, &fdbId) != L7_TRUE) || (fdbIdGet(fdbId) != L7_SUCCESS))
  {
    osapiSemaGive(fdbTreeData.semId);
    return L7_FAILURE;
  }
  vlanId = fdbId;
  *entries = fdb_stats.vlanStats[vlanId].dynamic_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of internally added entries in the L2FDB.
*
* @param    L7_uint32     *entries   @{{output}}  Number of dynamic entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbInternalEntriesGet(L7_uint32 *entries)
{
  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  *entries = fdb_stats.internal_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of internal entries in the L2FDB for a specific interface
*
* @param    L7_uint32     intIfNum   @((input))   Internal interface number
* @param    L7_uint32     *entries   @{{output}}  Number of static entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbIntfInternalEntriesGet(L7_uint32 intIfNum,
                                  L7_uint32 *entries)
{
  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  *entries = fdb_stats.intfStats[intIfNum].internal_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Get count of internal entries in the L2FDB for a specific VLAN
*
* @param    L7_ushort16    vlanId    @((input))   VLAN identifier
* @param    L7_uint32     *entries   @{{output}}  Number of static entries
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes  
*       
* @end
*********************************************************************/
L7_RC_t fdbVlanInternalEntriesGet(L7_ushort16  vlanId,
                                  L7_uint32   *entries)
{
  L7_uint32 fdbId;

  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);
  if ((getFDBId(vlanId, &fdbId) != L7_TRUE) || (fdbIdGet(fdbId) != L7_SUCCESS))
  {
    osapiSemaGive(fdbTreeData.semId);
    return L7_FAILURE;
  }
  vlanId = fdbId;
  *entries = fdb_stats.vlanStats[vlanId].internal_entries;
  osapiSemaGive(fdbTreeData.semId);
  return L7_SUCCESS;
}


/* test code */
void dumpFdbStats()
{
  printf("cur entries  - %10d\n",fdb_stats.cur_entries);
  printf("max entries  - %10d\n",fdb_stats.most_entries);
  printf("total adds   - %10d\n",fdb_stats.total_adds);
  printf("total dels   - %10d\n",fdb_stats.total_dels);
  printf("dup adds     - %10d\n",fdb_stats.dup_adds);
  printf("bad adds     - %10d\n",fdb_stats.bad_adds);
  printf("bad dels     - %10d\n",fdb_stats.bad_dels);
  printf("static entries - %10d\n", fdb_stats.static_entries);
  printf("dynamic entries - %10d\n", fdb_stats.dynamic_entries);
  printf("internal entries - %10d\n", fdb_stats.internal_entries); 
}

/*
 * Functions added for the configurator to initialize piece to init FDB
 * These functions are here to avoid using global data
 */

/*********************************************************************
* @purpose  Phase 1 initialization
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbPhaseOneInit(void)
{
  L7_RC_t rc = L7_SUCCESS;

  do
  {
    fdbIdTable  = osapiMalloc(L7_FDB_COMPONENT_ID, sizeof( fdbIdTable_s )*fdbSidMaxVlanPerBridgeGet());
    if (fdbIdTable == L7_NULLPTR)
    {
      LOG_MSG("FDB: Unable to allocate resources\n");
      break; /* goto while */
    }
    else
    {
      /* reset the fdbIdTable */
      (void)memset(fdbIdTable,0x00,sizeof(fdbIdTable_s)*fdbSidMaxVlanPerBridgeGet());
    }

    fdbIdUsed   = osapiMalloc(L7_FDB_COMPONENT_ID, sizeof(L7_uint32)*fdbSidMaxVlanPerBridgeGet());
    if (fdbIdUsed == L7_NULLPTR)
    {
      LOG_MSG("FDB: Unable to allocate resources\n");
      break; /* goto while */
    }
    else
    {
      (void)memset(fdbIdUsed,0x00,sizeof(L7_uint32)*fdbSidMaxVlanPerBridgeGet());
    }

    fdbTreeHeap = osapiMalloc(L7_FDB_COMPONENT_ID, sizeof(avlTreeTables_t)*platFdbTotalMacEntriesGet());
    if (fdbTreeHeap == L7_NULLPTR)
    {
      LOG_MSG("FDB: Unable to allocate resources\n");
      break; /* goto while */
    }
    else
    {
      (void)memset(fdbTreeHeap,0x00,sizeof(avlTreeTables_t)*platFdbTotalMacEntriesGet());
    }


    fdbDataHeap = osapiMalloc(L7_FDB_COMPONENT_ID, sizeof(dot1dTpFdbData_t)*platFdbTotalMacEntriesGet());
    if (fdbDataHeap == L7_NULLPTR)
    {
      LOG_MSG("FDB: Unable to allocate resources\n");
      break; /* goto while */
    }
    else
    {
      (void)memset(fdbDataHeap,0x00,sizeof(dot1dTpFdbData_t)*platFdbTotalMacEntriesGet());
    }

    /* set the VL type */
    fdbType = fdbSidVlanLearningTypeGet();

    numberOfFDBIdUsed = 0;

    fdbQueue = (void *)osapiMsgQueueCreate(FDB_QUEUE, fdbSidFdbMsgCountGet(), sizeof(fdbLearnMsg_t));

    if (fdbQueue == L7_NULLPTR)
    {
      rc = L7_FAILURE;
      break; /* goto while */
    }

    avlCreateAvlTree(&fdbTreeData, fdbTreeHeap, fdbDataHeap, platFdbTotalMacEntriesGet(),
                     sizeof(dot1dTpFdbData_t), 0x10, sizeof(L7_uchar8)*L7_FDB_KEY_SIZE);

    fdb_task_id = osapiTaskCreate( "fdbTask", fdbTask, 0, 0,
                                   fdbSidTaskStackSizeGet(),
                                   fdbSidTaskPriorityGet(),
                                   fdbSidTaskSliceGet());

    if (fdb_task_id == L7_ERROR)
    {
      LOG_MSG("Failed to Create fdb Task.\n");
      rc = L7_FAILURE;
      break; /* goto while */
    }

  } while ( 0 );

  return(rc);
}

/*********************************************************************
* @purpose  Phase 1 cleanup
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
void fdbPhaseOneFini(void)
{
  if (fdbQueue != L7_NULLPTR)
  {
    osapiMsgQueueDelete(fdbQueue);
  }

  if (fdb_task_id != L7_ERROR)
  {
    osapiTaskDelete(fdb_task_id);
  }

  if (fdbIdTable != L7_NULLPTR)
  {
    (void)memset(fdbIdTable,0x00,sizeof(fdbIdTable_s)*fdbSidMaxVlanPerBridgeGet());
    osapiFree(L7_FDB_COMPONENT_ID, fdbIdTable);
  }

  if (fdbIdUsed != L7_NULLPTR)
  {
    (void)memset(fdbIdUsed,0x00,sizeof(L7_uint32)*fdbSidMaxVlanPerBridgeGet());
    osapiFree(L7_FDB_COMPONENT_ID, fdbIdUsed);
  }

  if (fdbTreeHeap != L7_NULLPTR)
  {
    (void)memset(fdbTreeHeap,0x00,sizeof(avlTreeTables_t)*platFdbTotalMacEntriesGet());
    osapiFree(L7_FDB_COMPONENT_ID, fdbTreeHeap);
  }


  if (fdbDataHeap != L7_NULLPTR)
  {
    (void)memset(fdbDataHeap,0x00,sizeof(dot1dTpFdbData_t)*platFdbTotalMacEntriesGet());
    osapiFree(L7_FDB_COMPONENT_ID, fdbDataHeap);
  }

  return;
}

/*********************************************************************
* @purpose  Phase 2 initialization
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbPhaseTwoInit(void)
{
  L7_RC_t rc = L7_SUCCESS;
  nvStoreFunctionList_t notifyFunctionList; /* nvstore Functions' Data Structure */
  L7_uint32 eventMask = 0;

  memset((void *) &notifyFunctionList, 0, sizeof(notifyFunctionList));
  notifyFunctionList.registrar_ID   = L7_FDB_COMPONENT_ID;
  notifyFunctionList.notifySave     = fdbSave;
  notifyFunctionList.hasDataChanged = fdbHasDataChanged;
  notifyFunctionList.resetDataChanged = fdbResetDataChanged;

  eventMask = VLAN_ADD_NOTIFY | VLAN_DELETE_NOTIFY | VLAN_ADD_PORT_NOTIFY | VLAN_DELETE_PORT_NOTIFY;

  if ((rc = nvStoreRegister(notifyFunctionList)) != L7_SUCCESS)
  {
    LOG_MSG("FDB: Unable to register to NVRAM routines\n");
    rc = L7_FAILURE;
  }
  else if ((rc = dtlCallbackRegistration(DTL_FAMILY_ADDR_MGMT, dtlFdbReceiveCallback)) != L7_SUCCESS)
  {
    LOG_MSG("FDB: Unable to register to DTL for address changes\n");
    rc = L7_FAILURE;
  }
  /* Give VLAN code a callback hook for receiving VLAN changes */
  else if ((rc = vlanRegisterForChange(fdbVlanChangeCallback, L7_FDB_COMPONENT_ID, eventMask)) != L7_SUCCESS)
  {
    LOG_MSG("FDB: Unable to register for VLAN change callback\n");
    rc = L7_FAILURE;
  }
  else if ((rc = nimRegisterIntfChange(L7_FDB_COMPONENT_ID,fdbIntfChangeCallback)) != L7_SUCCESS)
  {
    LOG_MSG("FDB: Unable to register to NIM for port create\n");
    rc = L7_FAILURE;
  }
  else
  {
    rc = L7_SUCCESS;
  }

  return(rc);
}

/*********************************************************************
* @purpose  Phase 2 cleanup
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
void fdbPhaseTwoFini(void)
{
  nvStoreFunctionList_t notifyFunctionList; /* nvstore Functions' Data Structure */

  (void)memset((void *) &notifyFunctionList, 0, sizeof(notifyFunctionList));

  (void)nvStoreRegister(notifyFunctionList);

  (void)dtlCallbackDeRegistration(DTL_FAMILY_ADDR_MGMT);

  (void)vlanRegisterForChange(L7_NULLPTR, L7_FDB_COMPONENT_ID,0);

  (void)nimDeRegisterIntfChange(L7_FDB_COMPONENT_ID);
}

/*********************************************************************
* @purpose  Phase 3 initialization
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbPhaseThreeInit()
{
  L7_RC_t rc = L7_SUCCESS;

  rc = sysapiCfgFileGet (L7_FDB_COMPONENT_ID, FDB_CFG_FILENAME, (L7_char8 *)&fdbCfgData, sizeof(fdbCfgData),
                         &fdbCfgData.checkSum, FDB_CFG_VER_CURRENT, fdbBuildDefaultConfigData, fdbMigrateConfigData);

  /* starting with fresh config */
  fdbCfgData.cfgHdr.dataChanged = L7_FALSE;

  return(rc);
}

/*********************************************************************
* @purpose  Phase 3 cleanup
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbPhaseThreeFini()
{
  L7_RC_t rc = L7_SUCCESS;

  (void)memset((void*)&fdbCfgData, 0, sizeof(fdbCfgData));

  return(rc);
}

/*********************************************************************
* @purpose  Phase Execute initialization
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbPhaseExecInit()
{
  L7_RC_t rc =  L7_SUCCESS;
  L7_uint32     i;
  L7_FDB_TYPE_t type;
  L7_uint32     maxFdb;

  fdbGetTypeOfVL(&type);

  if (type == L7_SVL)
  {
    maxFdb = fdbSidMaxFdbGet();

    for (i=0; i < maxFdb; i++)
    {
      /* Call dtl to set the Address Aging timeout */
      rc = dtlFdbAddressAgingTimeOutSet(fdbCfgData.fdbFIDData[i].fid,
                                        fdbCfgData.fdbFIDData[i].addressAgingTimeOut);

      if (rc != L7_SUCCESS)
      {
        break;
      }
    }
  }

  return(rc);
}

/*********************************************************************
* @purpose  Reset all the Tables in the FDB
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
L7_RC_t fdbPhaseUnconfig()
{
  L7_RC_t rc = L7_SUCCESS;

  osapiSemaTake(fdbTreeData.semId, L7_WAIT_FOREVER);

  avlPurgeAvlTree(&fdbTreeData,platFdbTotalMacEntriesGet());

  fdb_stats.dynamic_entries = 0;
  fdb_stats.cur_entries     = 0;
  fdb_stats.most_entries    = 0;
  fdb_stats.static_entries  = 0;
  fdb_stats.internal_entries  = 0;


  /* reset the fdbIdTable */
  (void)memset(fdbIdTable,0x00,sizeof(fdbIdTable_s)*fdbSidMaxVlanPerBridgeGet());

  (void)memset(fdbIdUsed,0x00,sizeof(L7_uint32)*fdbSidMaxVlanPerBridgeGet());

  numberOfFDBIdUsed = 0;

  /* Clear out the system MAC address from the hardware.
  */
  dtlFdbMacAddrSystemClear();

  osapiSemaGive(fdbTreeData.semId);

  return rc;
}
/*********************************************************************
* @purpose  Phase Exec cleanup
*
* @param    void
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
void fdbPhaseExecFini(void)
{
  return;
}

/*********************************************************************
* @purpose  Determine if fdb is interested in the given interface
*
* @param    intIfNum              @b{(input)} internal interface number
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
* @comments
*
* @end
*********************************************************************/
L7_BOOL fdbIsValidIntf(L7_uint32 intIfNum)
{
  L7_INTF_TYPES_t sysIntfType;

  if (nimGetIntfType(intIfNum, &sysIntfType) == L7_SUCCESS)
  {
    switch (sysIntfType)
    {
      case L7_PHYSICAL_INTF:
      case L7_LAG_INTF:
      case L7_CPU_INTF:
      case L7_LOGICAL_VLAN_INTF:
        return L7_TRUE;

      default:
        break;
    }
  }

  return L7_FALSE;
}

// PTin added
static L7_RC_t fdbIntfRemove(L7_uint32 intIfNum)
{
  L7_uint16         i;
  L7_INTF_TYPES_t   intfType;
  L7_uchar8         keyNext[L7_FDB_KEY_SIZE];
  dot1dTpFdbData_t  fdbEntry;
  fdbMeberInfo_t    fdbMemberInfo;
  L7_RC_t           rc = L7_SUCCESS;

  if ( ( intIfNum == 0 ) ||
       ( nimGetIntfType(intIfNum,&intfType) != L7_SUCCESS ) ||
       ( intfType != L7_PHYSICAL_INTF && intfType != L7_LAG_INTF ) )
    return L7_SUCCESS;

  // Remove all entries related to this interface
  memset(keyNext,0x00,sizeof(L7_uchar8)*L7_FDB_KEY_SIZE);
  for (i=0; i<PLAT_MAX_FDB_MAC_ENTRIES && fdbFind(keyNext,L7_MATCH_GETNEXT,&fdbEntry)==L7_SUCCESS; i++)
  {
    memcpy(keyNext, fdbEntry.dot1dTpFdbAddress, L7_FDB_KEY_SIZE);
    // Entry must be dynamic and with same interface
    if (fdbEntry.dot1dTpFdbEntryType==L7_FDB_ADDR_FLAG_STATIC || fdbEntry.dot1dTpFdbPort!=intIfNum)
      continue;

    // Prepare entry remotion
    memcpy(fdbMemberInfo.macAddr, &fdbEntry.dot1dTpFdbAddress[2], sizeof(L7_uint8)*L7_MAC_ADDR_LEN);
    fdbMemberInfo.vlanId    = (L7_uint16) *((L7_uint16 *) &fdbEntry.dot1dTpFdbAddress[0]);
    fdbMemberInfo.intIfNum  = fdbEntry.dot1dTpFdbPort;
    fdbMemberInfo.entryType = fdbEntry.dot1dTpFdbEntryType;

    if (fdbDelEntry(&fdbMemberInfo)!=L7_SUCCESS) {
      rc = L7_FAILURE;
    }
  }

  return rc;
}
// PTin end

/*********************************************************************
* @purpose  Callback function to process interface state changes.
*
* @param    intIfnum    @b{(input)} internal interface whose state has changed
* @param    event       @b{(input)} new state (see L7_PORT_EVENTS_t for list)
* @param    correlator  @b{(input)} Correlator for event
*
* @returns  L7_SUCCESS
*
* @notes    This function currently only cares about interface
*           creation on the CPU interface.  When the CPU interface is added,
*           The Mgmt address is added to the forwarding database.
*
* @end
*********************************************************************/
L7_RC_t fdbIntfChangeCallback(L7_uint32 intIfNum, L7_uint32 event,NIM_CORRELATOR_t correlator)
{
  L7_RC_t rc = L7_SUCCESS;
  L7_char8          mac[L7_MAC_ADDR_LEN];
  L7_FDB_TYPE_t     type;
  L7_PORT_EVENTS_t  portEvent;
  NIM_EVENT_COMPLETE_INFO_t status;
  fdbMeberInfo_t    fdbMemberInfo;
  nimMacroPort_t    macroPortIntf;
  L7_INTF_TYPES_t   intfType;
  L7_uint32         vlanId;

  status.intIfNum     = intIfNum;
  status.component    = L7_FDB_COMPONENT_ID;
  status.event        = event;
  status.correlator   = correlator;
  status.response.reason = NIM_ERR_RC_UNUSED;

  if (fdbIsValidIntf(intIfNum) == L7_FALSE)
  {
    rc = L7_SUCCESS;
    status.response.rc = rc;
    nimEventStatusCallback(status);
    return rc;
  }

  vlanId = simMgmtVlanIdGet();

  portEvent = (L7_PORT_EVENTS_t) event;

  switch (portEvent)
  {
    case L7_ATTACH:
      if ((rc = nimGetIntfType(intIfNum, &intfType)) != L7_SUCCESS)
      {
        LOG_MSG("Mirror: failed to get interface type for intIfNum %d on L7_ATTACH\n", intIfNum);
      }
      else if (intfType == L7_CPU_INTF)
      {
        /* we have the cpu interface, add the mac address */
        if (simGetSystemIPMacType() == L7_SYSMAC_BIA)
        {
          simGetSystemIPBurnedInMac(mac);
        }
        else
        {
          simGetSystemIPLocalAdminMac(mac);
        }

                rc = fdbSysMacAddEntry(mac, vlanId, intIfNum, L7_FDB_ADDR_FLAG_MANAGEMENT);

      }
      else if (intfType == L7_LOGICAL_VLAN_INTF)
      {
          if (nimGetIntfAddress(intIfNum,L7_NULL,fdbMemberInfo.macAddr ) == L7_SUCCESS)
          {
            if ( nimGetMacroPortAssignment(intIfNum, &macroPortIntf) == L7_SUCCESS)
            {
                fdbMemberInfo.vlanId    = (L7_uint32)macroPortIntf.macroInfo;
                fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_MANAGEMENT;
                fdbMemberInfo.intIfNum  = intIfNum;
                (void)fdbAddEntry(&fdbMemberInfo);
            }
          }
      }
      else
      {
        rc = L7_SUCCESS;
      }
      break;

    case L7_DETACH:
      if ((rc = nimGetIntfType(intIfNum, &intfType)) != L7_SUCCESS)
      {
        LOG_MSG("Mirror: failed to get interface type for intIfNum %d on L7_ATTACH\n", intIfNum);
      }
      else if (intfType == L7_CPU_INTF)
      {
        /* we have the cpu interface, add the mac address */
        if (simGetSystemIPMacType() == L7_SYSMAC_BIA)
        {
          simGetSystemIPBurnedInMac(mac);
        }
        else
        {
          simGetSystemIPLocalAdminMac(mac);
        }

        rc = fdbSysMacDelEntry(mac, vlanId, intIfNum, L7_FDB_ADDR_FLAG_MANAGEMENT);
      }
      else if (intfType == L7_LOGICAL_VLAN_INTF)
      {
          if (nimGetIntfAddress(intIfNum,L7_NULL,fdbMemberInfo.macAddr ) == L7_SUCCESS)
          {
            if ( nimGetMacroPortAssignment(intIfNum, &macroPortIntf) == L7_SUCCESS)
            {
                fdbMemberInfo.vlanId    = (L7_uint32)macroPortIntf.macroInfo;
                fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_MANAGEMENT;
                fdbMemberInfo.intIfNum  = intIfNum;
                (void)fdbDelEntry(&fdbMemberInfo);
            }
          }
      }
      else
      {
        rc = L7_SUCCESS;
      }

      // PTin added: Update table
      rc = fdbIntfRemove(intIfNum);

      break;

    case L7_UP:

      if ((rc = nimGetIntfAddress(intIfNum, L7_NULL, (L7_uchar8 *)mac)) != L7_SUCCESS)
      {
        LOG_MSG ("FDB:internal interface number %ud has no mac address\n",intIfNum);
      }
      else if (fdbGetTypeOfVL(&type) != L7_SUCCESS)
      {
        LOG_MSG("FDB: Could not get the VL Type\n");
      }
      else
      {
        if (type == L7_SVL)
        {
          if ((nimGetIntfType(intIfNum,&intfType) == L7_SUCCESS) && (intfType != L7_CPU_INTF))
          {
            memcpy(fdbMemberInfo.macAddr,mac,L7_MAC_ADDR_LEN);
            fdbMemberInfo.intIfNum = intIfNum;
            fdbMemberInfo.vlanId = FDB_MEMBER_VLAN_INDEPNDENT;
            fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_SELF;
            if (fdbAddEntry(&fdbMemberInfo) != L7_SUCCESS)
            {
              LOG_MSG("FDB: Could not add fdb entry\n");
            }
          }
        }
      }
      break;

    case L7_DOWN:
      if ((rc = nimGetIntfAddress(intIfNum, L7_NULL, (L7_uchar8 *)mac)) != L7_SUCCESS)
      {
        LOG_MSG ("FDB:internal interface number %ud has no mac address\n",intIfNum);
      }
      else if (fdbGetTypeOfVL(&type) != L7_SUCCESS)
      {
        LOG_MSG("FDB: Could not get the VL Type\n");
      }
      else
      {
        if (type == L7_SVL)
        {
          if ((nimGetIntfType(intIfNum,&intfType) == L7_SUCCESS) && (intfType != L7_CPU_INTF))
          {
            memcpy(fdbMemberInfo.macAddr,mac,L7_MAC_ADDR_LEN);
            fdbMemberInfo.intIfNum = intIfNum;
            fdbMemberInfo.vlanId = FDB_MEMBER_VLAN_INDEPNDENT;
            fdbMemberInfo.entryType = L7_FDB_ADDR_FLAG_SELF;
            if (fdbDelEntry(&fdbMemberInfo) != L7_SUCCESS)
            {
              LOG_MSG("FDB: Failed to delete fdb entry\n");
            }
          }
        }
      }

      // PTin added: Update table
      rc = fdbIntfRemove(intIfNum);

      break;

    default:
      rc = L7_SUCCESS;
      break;
  }

  status.response.rc  = rc;

  nimEventStatusCallback(status);

  return(rc);
}




/*============================================================================*/
/*========================  START OF CONFIG MIGRATION DEBUG CHANGES ==========*/
/*============================================================================*/



/*********************************************************************
* @purpose  Build non-default  config data
*
* @param    void
*
* @returns  void
*
* @notes    This routine is based on xxxBuildDefaultConfigData.
*
* @end
*********************************************************************/
void fdbBuildTestConfigData(void)
{
    L7_uint32 i;
    L7_uint32 maxFdb;

  /*-------------------------------*/
  /* Build Non-Default Config Data */
  /*-------------------------------*/

   /* Save the config IDs */

   maxFdb = fdbSidMaxFdbGet();

   /* Assuming i directly maps to fid */
   for (i=0; i< maxFdb; i++)
   {
     fdbCfgData.fdbFIDData[i].fid = i;
     fdbCfgData.fdbFIDData[i].vlanId = i + 4;
     fdbCfgData.fdbFIDData[i].addressAgingTimeOut = 20 +i;
   }

 /* End of Component's Test Non-default configuration Data */


   /* Force write of config file */
   fdbCfgData.cfgHdr.dataChanged = L7_TRUE;
   sysapiPrintf("Built test config data\n");


}





/*********************************************************************
*
* @purpose  Dump the contents of the config data.
*
* @param    void
*
* @returns  void
*
* @comments
*
* @end
*
*********************************************************************/
void fdbConfigDataTestShow(void)
{

    L7_fileHdr_t  *pFileHdr;
    L7_uint32 i;
    L7_uint32 maxFdb;


    /*-----------------------------*/
    /* Config File Header Contents */
    /*-----------------------------*/
    pFileHdr = &(fdbCfgData.cfgHdr);

    sysapiCfgFileHeaderDump (pFileHdr);

   /*-----------------------------*/
   /* cfgParms                    */
   /*-----------------------------*/

   /* Save the config IDs */

   maxFdb = fdbSidMaxFdbGet();

   sysapiPrintf( "\n");
   for (i=0; i< maxFdb; i++)
   {

       sysapiPrintf( "FID = %d      vlanId =  %d    addressAgingTimeOut = %d\n",
                     fdbCfgData.fdbFIDData[i].fid,
                     fdbCfgData.fdbFIDData[i].vlanId,
                     fdbCfgData.fdbFIDData[i].addressAgingTimeOut);

   }


   /*-------------------------------*/
   /* Scaling Constants             */
   /*-------------------------------*/

    sysapiPrintf( "Scaling Constants\n");
    sysapiPrintf( "-----------------\n");


    sysapiPrintf( "L7_MAX_FILTERING_DATABASES - %d\n",
                  L7_MAX_FILTERING_DATABASES);



    /*-----------------------------*/
    /* Checksum                    */
    /*-----------------------------*/
    sysapiPrintf("fdbCfgData.checkSum : %u\n", fdbCfgData.checkSum);


}



/*============================================================================*/
/*========================  END OF CONFIG MIGRATION DEBUG CHANGES ============*/
/*============================================================================*/


/*********************************************************************
* @purpose  Returns the number of Dynamic entries
*
*
* @returns  L7_SUCCESS
*
* @notes    none
*
* @end
*********************************************************************/
L7_uint32 fdbDynamicAddsGet(void)
{
  return fdb_stats.dynamic_entries;
}

