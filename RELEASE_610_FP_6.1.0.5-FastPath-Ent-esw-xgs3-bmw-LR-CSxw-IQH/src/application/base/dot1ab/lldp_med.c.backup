/*********************************************************************
*
* (C) Copyright Broadcom Corporation 2000-2007
*
**********************************************************************
* @filename lldp_med.c
*
* @purpose LLDP MED Routines
*
* @component 802.1AB
*
* @comments none
*
* @create 12/19/2006
*
* @author skalyanam
*
* @end
*
**********************************************************************/
#include "lldp.h"
#include "lldp_tlv.h"
#include "lldp_med.h"
#include "lldp_util.h"
#include "lldp_api.h"
#include "nimapi.h"
#include "usmdb_sim_api.h"
#include "usmdb_poe_api.h"
#include "poe_api.h"
#include "osapi_support.h"
#include "voice_vlan_api.h"
#include "lldp_exports.h"


lldpXMedNotifyList_t    *lldpXMedNotifyList;
extern void             *lldpSemaphore;
extern lldpIntfOprData_t    *lldpIntfTbl;
extern lldpCfgData_t      *lldpCfgData;
extern lldpStats_t          *lldpStats;
extern void               *lldpQueue;
extern L7_BOOL lldpMedDebugTxFlag;
extern const L7_uchar8 LLDP_MED_TIA_OUI_STRING[LLDP_TIA_OUI_STRING_LEN];
extern const L7_uchar8 LLDP_8023_TIA_OUI_STRING[LLDP_TIA_OUI_STRING_LEN];
extern const L7_uchar8 LLDP_8021_TIA_OUI_STRING[LLDP_TIA_OUI_STRING_LEN];


/*********************************************************************
 *                LLDP-MED APIs
 *********************************************************************/
/*********************************************************************
*
* @purpose  Notification Registration 
*
* @param    L7_uint32                  component_ID @b((input)) componant id
* @param    L7_uint32                  L7_uint32 (*notify)
*                   (L7_uint32 intIfNum, lldpXMedNotify_t *data) 
*                   @b((input))  function to callback
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedNotificationRegister(L7_COMPONENT_IDS_t component_ID,
                   L7_RC_t (*notify)(L7_uint32 intIfNum, lldpXMedNotify_t *data))
{
  if (component_ID >= L7_LAST_COMPONENT_ID)
  {
    LOG_MSG("LLDP-MED registrar ID %u greater than Last Component ID\n", component_ID);
    return(L7_FAILURE);
  }

  if ((L7_uint32)lldpXMedNotifyList[component_ID].notify_med_intf != L7_NULL)
  {
    LOG_MSG("LLDP-MED registrar ID %u already registered\n", component_ID);
    return(L7_FAILURE);
  }
  (void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  lldpXMedNotifyList[component_ID].registrar_ID = component_ID;
  lldpXMedNotifyList[component_ID].notify_med_intf = notify;
  (void)osapiSemaGive(lldpSemaphore);
  return(L7_SUCCESS);
}

/*********************************************************************
*
* @purpose  Notification DeRegistration 
*
* @param    L7_uint32                  component_ID @b((input)) componant id
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedNotificationDeregister(L7_COMPONENT_IDS_t component_ID)
{
  if (component_ID >= L7_LAST_COMPONENT_ID)
  {
    LOG_MSG("LLDP-MED registrar ID %u greater than Last Component ID\n", component_ID);
    return(L7_FAILURE);
  }
  (void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  lldpXMedNotifyList[component_ID].notify_med_intf = L7_NULLPTR;
  lldpXMedNotifyList[component_ID].registrar_ID = L7_NULL;
  (void)osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Call register users with information 
*
* @param    L7_uint32                  intIfNum @b((input)) internal Interface number
* @param    lldpXMedNotify_t           *data @b((output)) media policy data
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
void lldpXMedNotifyRegisteredUsers(L7_uint32 intIfNum, lldpXMedNotify_t *data)
{
  L7_uint32 i;

  for (i = 0; i < L7_LAST_COMPONENT_ID; i++)
  {
    if (lldpXMedNotifyList[i].registrar_ID)
    {
      (void)(*lldpXMedNotifyList[i].notify_med_intf)(intIfNum, data);
    }
  }
  return;
}

/*********************************************************************
*
* @purpose  Send a message to the LLDP Queue for MED to send network policy parameters in its TLV
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    lldpXMedPolicyInfoParms_t  *policyInfo @b((input)) policy information
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPolicyEventCallback(L7_uint32 intIfNum, lldpXMedPolicyInfoParms_t *policyInfo)
{
  lldpMgmtMsg_t msg;

  msg.msgId = lldpMsgMedPolicyInfo;

  msg.u.lldpXMedPolicyInfoParms.dscp = policyInfo->dscp;
  msg.u.lldpXMedPolicyInfoParms.intIfNum = policyInfo->intIfNum;
  msg.u.lldpXMedPolicyInfoParms.priority = policyInfo->priority;
  msg.u.lldpXMedPolicyInfoParms.T = policyInfo->T;
  msg.u.lldpXMedPolicyInfoParms.type = policyInfo->type;
  msg.u.lldpXMedPolicyInfoParms.U = policyInfo->U;
  msg.u.lldpXMedPolicyInfoParms.vlanId = policyInfo->vlanId;

  if (osapiMessageSend(lldpQueue,
                       &msg,
                       LLDP_MSG_SIZE,
                       L7_NO_WAIT,
                       L7_MSG_PRIORITY_NORM) != L7_SUCCESS)
  {
    LOG_MSG("lldpXMedPolicyEventCallback(): message send failed\n");
  }

  return L7_SUCCESS;
}

/*********************************************************************
 *                LLDP-MED Configuration APIs
 *********************************************************************/
/*********************************************************************
*
* @purpose  Sets the MED admin mode for this interface
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  value @b((input))  admin mode (L7_ENABLE/L7_DISABLE)
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPortAdminModeSet(L7_uint32 intIfNum, L7_uint32 value)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpIntfCfgData_t *pCfg  = L7_NULLPTR;
  L7_uint32          index = 0;

  if (value != L7_ENABLE && value != L7_DISABLE)
  {
    return L7_FAILURE;
  }

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
    return L7_FAILURE;
  }

  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if (lldpMapIntfIndexGet(intIfNum, &index) != L7_TRUE)
  {
    (void)osapiSemaGive(lldpSemaphore);
    return L7_FAILURE;
  }

  pCfg = &lldpCfgData->intfCfgData[index];
  if ((value == L7_ENABLE && pCfg->medEnabled == L7_TRUE) ||
      (value == L7_DISABLE && pCfg->medEnabled == L7_FALSE))
  {
    (void)osapiSemaGive(lldpSemaphore);
    return L7_SUCCESS;
  }

  pCfg->medEnabled = (value == L7_ENABLE) ? L7_TRUE : L7_FALSE;
  /* If this port has med enabled then we have to set the tx and rx to enable */
  /* If this port has med disabled then we have to set the tx and rx to disable */

  pCfg->txEnabled = (value == L7_ENABLE) ? L7_TRUE : L7_FALSE;
  pCfg->rxEnabled = (value == L7_ENABLE) ? L7_TRUE : L7_FALSE;

  /* apply the config change */
  lldpIntfTxModeApply(index);
  lldpIntfRxModeApply(index);

  if (value == L7_DISABLE)
  {
  /* Clear the operational tx and rx stats */
  lldpStats->intfStats[index].txFramesTotal = 0;
  lldpStats->intfStats[index].rxFramesDiscarded = 0;
    lldpStats->intfStats[index].rxFramesErrors = 0;
    lldpStats->intfStats[index].rxFramesTotal = 0;
    lldpStats->intfStats[index].rxTLVsDiscarded = 0;
    lldpStats->intfStats[index].rxTLVsUnrecognized = 0;
    lldpStats->intfStats[index].rxAgeouts = 0;
  lldpStats->intfStats[index].rxTLVs8021 = 0;
  lldpStats->intfStats[index].rxTLVs8023 = 0;
  lldpStats->intfStats[index].rxTLVsMED = 0;
  }
  lldpCfgData->cfgHdr.dataChanged = L7_TRUE;

  (void)osapiSemaGive(lldpSemaphore);

  return rc;
}

/*********************************************************************
*
* @purpose  Gets the MED admin mode for this interface
*
* @param    L7_uint32                  intIfNum @b((input)) Internal Interface Number
* @param    L7_uint32                  *value @b((output)) configured admin mode (L7_ENABLE/L7_DISABLE)
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPortAdminModeGet(L7_uint32 intIfNum, L7_uint32 *value)
{
  lldpIntfCfgData_t *pCfg  = L7_NULLPTR;
  L7_uint32          index = 0;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE || value == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  /*(void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);*/
  if (lldpMapIntfIndexGet(intIfNum, &index) != L7_TRUE)
  {
    /*(void)osapiSemaGive(lldpSemaphore);*/
    return L7_FAILURE;
  }

  pCfg = &lldpCfgData->intfCfgData[index];
  *value = (pCfg->medEnabled == L7_TRUE) ? L7_ENABLE : L7_DISABLE;

  /*(void)osapiSemaGive(lldpSemaphore);*/
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets whether we have seen a MED TLV and we are transmitting MED TLVs
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                   *status@b((input))  (L7_ENABLE/L7_DISABLE)
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    The port will transmit only if it has received an MED TLV
*     So even if we are admin mode enabled, we may not neccessarily transmit MED TLVs
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPortTransmitEnabledGet(L7_uint32 intIfNum, L7_uint32 *status)
{
  L7_uint32          index = 0;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE || status == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  /*(void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);*/
  if (lldpMapIntfIndexGet(intIfNum, &index) != L7_TRUE)
  {
    /*(void)osapiSemaGive(lldpSemaphore);*/
    return L7_FAILURE;
  }

  *status = (lldpIntfTbl[index].medTransmitEnabled == L7_TRUE) ? L7_ENABLE : L7_DISABLE;

  /*(void)osapiSemaGive(lldpSemaphore);*/
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the local device's (This device) MED Classification
*
* @param    L7_uint32                *deviceClass @b((output))  endpoint C I, CII, CII or network connectivity
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocDeviceClassGet(L7_uint32 *deviceClass)
{
  if (deviceClass == L7_NULLPTR)
  {
  return L7_FAILURE;
  }
  /*(void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);*/

  *deviceClass = lldpCfgData->localDeviceClass;
  
  /*(void)osapiSemaGive(lldpSemaphore);*/

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the supported capabilities that could be tranamitted in MED TLVs
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    lldpXMedCapabilities_t     *capSup @b((output))  bit mask of the capabilities supported
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPortCapSupportedGet(L7_uint32 intIfNum, lldpXMedCapabilities_t *capSup)
{
  L7_uint32          index = 0;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE || capSup == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  /*(void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);*/
  if (lldpMapIntfIndexGet(intIfNum, &index) != L7_TRUE)
  {
    /*(void)osapiSemaGive(lldpSemaphore);*/
    return L7_FAILURE;
  }
  memcpy(&capSup->bitmap[0], &lldpCfgData->intfCfgData[index].medTLVsSupported.bitmap[0], sizeof(lldpXMedCapabilities_t));
  
  /*(void)osapiSemaGive(lldpSemaphore);*/

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Sets the TLVs that need to be transmitted in the LLDP PDU
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    lldpXMedCapabilities_t     *capSet @b((output))  Bit mask of the TLVs that will be transmitted
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPortConfigTLVsEnabledSet(L7_uint32 intIfNum, lldpXMedCapabilities_t *capSet)
{
  L7_uint32          index = 0;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE || capSet == L7_NULLPTR)
  {
  return L7_FAILURE;
  }

  (void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if (lldpMapIntfIndexGet(intIfNum, &index) != L7_TRUE)
  {
  (void)osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(&lldpCfgData->intfCfgData[index].medTLVsEnabled.bitmap[0], &capSet->bitmap[0],  sizeof(lldpXMedCapabilities_t));

  lldpCfgData->cfgHdr.dataChanged = L7_TRUE;

  (void)osapiSemaGive(lldpSemaphore);

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the TLVs that need to be transmitted in the LLDP PDU
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    lldpXMedCapabilities_t     *capGet@b((input))  Bit mask of TLVs that are set for transmision
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPortConfigTLVsEnabledGet(L7_uint32 intIfNum, lldpXMedCapabilities_t *capGet)
{
  L7_uint32 index = 0;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE || capGet == L7_NULLPTR)
  {
  return L7_FAILURE;
  }
  /*(void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);*/
  if (lldpMapIntfIndexGet(intIfNum, &index) != L7_TRUE)
  {
  /*(void)osapiSemaGive(lldpSemaphore);*/
  return L7_FAILURE;
  }
  memcpy(&capGet->bitmap[0], &lldpCfgData->intfCfgData[index].medTLVsEnabled.bitmap[0], sizeof(lldpXMedCapabilities_t));

  /*(void)osapiSemaGive(lldpSemaphore);*/

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Sets the Topology Change notification for this interface
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_BOOL                   notif @b((output))  Truth value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPortConfigNotifEnableSet(L7_uint32 intIfNum, L7_BOOL notif)
{
  L7_uint32 index = 0;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }

  (void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);

  if (lldpMapIntfIndexGet(intIfNum, &index) != L7_TRUE ||
    (notif != L7_TRUE && notif != L7_FALSE))
  {
  (void)osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }
  if (lldpCfgData->intfCfgData[index].medNotifyEnabled == notif)
  {
    (void)osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
  }

  lldpCfgData->intfCfgData[index].medNotifyEnabled = notif;

  lldpCfgData->cfgHdr.dataChanged = L7_TRUE;
  
  (void)osapiSemaGive(lldpSemaphore);

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the Topology Change notification for this interface
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_BOOL                   *notif @b((input))  Truth value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedPortConfigNotifEnableGet(L7_uint32 intIfNum, L7_BOOL *notif)
{
  L7_uint32 index = 0;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE || notif == L7_NULLPTR)
  {
  return L7_FAILURE;
  }
  /*(void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);*/
  if (lldpMapIntfIndexGet(intIfNum, &index) != L7_TRUE)
  {
  /*(void)osapiSemaGive(lldpSemaphore);*/
  return L7_FAILURE;
  }

  *notif = lldpCfgData->intfCfgData[index].medNotifyEnabled;
  
  /*(void)osapiSemaGive(lldpSemaphore);*/

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Sets the fast start repeat count 
*
* @param    L7_uint32                  count @b((input))  fast start repeat count
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedFastStartRepeatCountSet(L7_uint32 count)
{
  if (count < LLDP_MED_FASTSTART_REPEAT_COUNT_MIN || count > LLDP_MED_FASTSTART_REPEAT_COUNT_MAX)
  {
  return L7_FAILURE;
  }

  (void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if (lldpCfgData->fastStartRepeatCount == count)
  {
  (void)osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
  }

  lldpCfgData->fastStartRepeatCount = count;
  lldpCfgData->cfgHdr.dataChanged = L7_TRUE;

  (void)osapiSemaGive(lldpSemaphore);

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the fast start repeat count 
*
* @param    L7_uint32                   *count @b((output)) fast start repeat count 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedFastStartRepeatCountGet(L7_uint32 *count)
{
  /*(void)osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);*/
  *count = lldpCfgData->fastStartRepeatCount;
  /*(void)osapiSemaGive(lldpSemaphore);*/

  return L7_SUCCESS;
}

/*********************************************************************
 *                LLDP-MED Local Device APIs
 *********************************************************************/
/*********************************************************************
*
* @purpose  Gets whether a particular policy type is supported on this interface
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param  L7_uint32          policyAppType @b((input)) type application policy
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
* @notes    Not taking any sema since we are not accessing lldp data
*
* @end
*********************************************************************/
L7_BOOL lldpXMedLocMediaPolicyAppSupportedGet(L7_uint32 intIfNum, 
                        L7_uint32 policyAppType)
{
  L7_BOOL sup = L7_FALSE;
  lldpXMedPolicyAppTypeValue_t appType;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FALSE;
  }

  appType = (lldpXMedPolicyAppTypeValue_t)policyAppType;
  switch (appType)
  {
  case voice_policyapptype:
    sup = L7_TRUE;
    break;
  case unknown_policyapptype:
  case voiceSignaling_policyapptype:
  case guestVoice_policyapptype:
  case guestVoiceSignaling_policyapptype:
  case softPhoneVoice_policyapptype:
  case videoConferencing_policyapptype:
  case streamingVideo_policyapptype:
  case videoSignaling_policyapptype:
  default:
    /* Currently in FastPath we do not support any of the above applications
     * As and when we support them we shall seperate the case statements and 
     * issue individual APIs to retrieve the vlan id
     */
    sup = L7_FALSE;
    break;
  }
  return sup;
}

/*********************************************************************
*
* @purpose  Gets the vlan id associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_uint32                  *vlanId @b((output))  Vlan ID
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    Not taking any sema since we are not accessing lldp data
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocMediaPolicyVlanIDGet(L7_uint32 intIfNum, 
                       L7_uint32 policyAppType, 
                       L7_uint32 *vlanId)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpXMedPolicyAppTypeValue_t appType;
  L7_uint32 mode;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }

  appType = (lldpXMedPolicyAppTypeValue_t)policyAppType;
  switch (appType)
  {
  case voice_policyapptype:
    /* Call the voice vlan application for the voice vlan associated with this port*/
    /* If voice vlan vlan id is not configured, voice vlan will return a success with the default value */
      if (voiceVlanApiPortStatusGet(intIfNum, &mode) == L7_SUCCESS && mode == L7_ENABLE)
    {
    rc = voiceVlanPortVlanIdGet(intIfNum, vlanId);
    }
    else
    {
    /* voice is disabled on this interface, hence we should not be reporting 
     * this information and not transmitting a network policy tlv with voice app type
     */
    rc = L7_FAILURE;
    }
    break;
  case unknown_policyapptype:
  case voiceSignaling_policyapptype:
  case guestVoice_policyapptype:
  case guestVoiceSignaling_policyapptype:
  case softPhoneVoice_policyapptype:
  case videoConferencing_policyapptype:
  case streamingVideo_policyapptype:
  case videoSignaling_policyapptype:
    /* Currently in FastPath we do not support any of the above applications
     * As and when we support them we shall seperate the case statements and 
     * issue individual APIs to retrieve the vlan id
     */
    rc = L7_FAILURE;
    break;
  }
  
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the priority associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_uint32                  *priority @b((output))  Priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    Not taking any sema since we are not accessing lldp data
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocMediaPolicyPriorityGet(L7_uint32 intIfNum, 
                         L7_uint32 policyAppType, 
                         L7_uint32 *priority )
{
  L7_RC_t rc = L7_SUCCESS;
  lldpXMedPolicyAppTypeValue_t appType;
  L7_uint32 mode;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }

  appType = (lldpXMedPolicyAppTypeValue_t)policyAppType;
  switch (appType)
  {
  case voice_policyapptype:
    /* Call the voice vlan application for the priority associated with this port*/
    /* If voice vlan priority is not configured, voice vlan will return a success with the default value */
      if (voiceVlanApiPortStatusGet(intIfNum, &mode) == L7_SUCCESS && mode == L7_ENABLE)
    {
    rc = voiceVlanPortVlanPriorityGet(intIfNum, priority);
    }
    else
    {
    /* voice is disabled on this interface, hence we should not be reporting 
     * this information and not transmitting a network policy tlv with voice app type
     */
    rc = L7_FAILURE;
    }
    break;
  case unknown_policyapptype:
  case voiceSignaling_policyapptype:
  case guestVoice_policyapptype:
  case guestVoiceSignaling_policyapptype:
  case softPhoneVoice_policyapptype:
  case videoConferencing_policyapptype:
  case streamingVideo_policyapptype:
  case videoSignaling_policyapptype:
    /* Currently in FastPath we do not support any of the above applications
     * As and when we support them we shall seperate the case statements and 
     * issue individual APIs to retrieve the priority
     */
    rc = L7_FAILURE;
    break;
  }
  
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the DSCP associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_uint32                  *dscp @b((output))  dscp
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocMediaPolicyDscpGet(L7_uint32 intIfNum, 
                       L7_uint32 policyAppType, 
                       L7_uint32 *dscp )
{
  L7_RC_t rc = L7_SUCCESS;
  lldpXMedPolicyAppTypeValue_t appType;
  L7_uint32 mode;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }

  appType = (lldpXMedPolicyAppTypeValue_t)policyAppType;
  switch (appType)
  {
  case voice_policyapptype:
    /* Call the voice vlan application for the DSCP associated with this port*/
    /* If voice vlan dscp is not configured, voice vlan will return a success with the default value */
    if (voiceVlanApiPortStatusGet(intIfNum, &mode) == L7_SUCCESS && mode == L7_ENABLE )
    {
    rc = voiceVlanPortDscpGet(intIfNum, dscp);
    }
    else
    {
    /* voice is disabled on this interface, hence we should not be reporting 
     * this information and not transmitting a network policy tlv with voice app type
     */
    rc = L7_FAILURE;
    }
    break;
  case unknown_policyapptype:
  case voiceSignaling_policyapptype:
  case guestVoice_policyapptype:
  case guestVoiceSignaling_policyapptype:
  case softPhoneVoice_policyapptype:
  case videoConferencing_policyapptype:
  case streamingVideo_policyapptype:
  case videoSignaling_policyapptype:
    /* Currently in FastPath we do not support any of the above applications
     * As and when we support them we shall seperate the case statements and 
     * issue individual APIs to retrieve the DSCP
     */
    rc = L7_FAILURE;
    break;
  }
  
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the Unknown bit associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_BOOL                  *unknown @b((output))  unknown bit value (0/1)
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    Not taking any sema since we are not accessing lldp data
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocMediaPolicyUnknownGet(L7_uint32 intIfNum, 
                        L7_uint32 policyAppType, 
                        L7_BOOL *unknown )
{
  L7_RC_t rc = L7_SUCCESS;
  lldpXMedPolicyAppTypeValue_t appType;
  L7_uint32 mode;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }

  appType = (lldpXMedPolicyAppTypeValue_t)policyAppType;
  switch (appType)
  {
  case voice_policyapptype:
    if (voiceVlanApiPortStatusGet(intIfNum, &mode) == L7_SUCCESS && mode == L7_ENABLE )
    {
    *unknown = L7_FALSE; /* Should be transmitted as a zero indicating that the network policy is defined*/ 
    rc = L7_SUCCESS;
    }
    else
    {
    rc = L7_FAILURE;
    }
    
    break;
  case unknown_policyapptype:
  case voiceSignaling_policyapptype:
  case guestVoice_policyapptype:
  case guestVoiceSignaling_policyapptype:
  case softPhoneVoice_policyapptype:
  case videoConferencing_policyapptype:
  case streamingVideo_policyapptype:
  case videoSignaling_policyapptype:
    /* Currently in FastPath we do not support any of the above applications
     * As and when we support them we shall seperate the case statements and 
     * return unknown as false. 
     */
    *unknown = L7_TRUE;
    rc = L7_SUCCESS;
    break;
  }
  
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the tagged bit associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_BOOL                  *tagged @b((output))  tagged bit value (0/1)
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    Not taking any sema since we are not accessing lldp data
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocMediaPolicyTaggedGet(L7_uint32 intIfNum, 
                       L7_uint32 policyAppType, 
                       L7_BOOL *tagged )
{
  L7_RC_t rc = L7_SUCCESS;
  lldpXMedPolicyAppTypeValue_t appType;
  L7_BOOL untagged;
  L7_uint32 mode;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }

  appType = (lldpXMedPolicyAppTypeValue_t)policyAppType;
  switch (appType)
  {
  case voice_policyapptype:
    /* Call the voice vlan application for the tagging associated with this port*/
    /* If voice vlan untag is not configured, voice vlan will return a success with the default value */
    if (voiceVlanApiPortStatusGet(intIfNum, &mode) == L7_SUCCESS && mode == L7_ENABLE )
    {
    rc = voiceVlanPortUntagGet(intIfNum, &untagged);
    }
    else
    {
    /* voice is disabled on this interface, hence we should not be reporting 
     * this information and not transmitting a network policy tlv with voice app type
     */
    rc = L7_FAILURE;
    break;
    }
    *tagged = (untagged == L7_TRUE) ? L7_FALSE: L7_TRUE;
    break;
  case unknown_policyapptype:
  case voiceSignaling_policyapptype:
  case guestVoice_policyapptype:
  case guestVoiceSignaling_policyapptype:
  case softPhoneVoice_policyapptype:
  case videoConferencing_policyapptype:
  case streamingVideo_policyapptype:
  case videoSignaling_policyapptype:
    /* Currently in FastPath we do not support any of the above applications
     * As and when we support them we shall seperate the case statements and 
     * issue individual APIs to retrieve the tagging property
     */
    *tagged = L7_FALSE;
    rc = L7_FAILURE;
    break;
  }
  
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the Hardware revision
*
* @param    L7_uchar8                    *hardwareRev @b((output)) Hardware revision as a string 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocHardwareRevGet(L7_uchar8 *hardwareRev)
{
  L7_RC_t rc = L7_FAILURE;
  /* The entity MIB is not implemented in full in fastpath hence this object will return a NULL */
  strcpy(hardwareRev, "");
  if (lldpMedDebugTxFlag == L7_TRUE)
  {
  strcpy(hardwareRev, "7.7.7.7\0");
  rc = L7_SUCCESS;
  }
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the Firmware revision
*
* @param    L7_uchar8                    *firmwareRev @b((output)) Firmware revision as a string 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocFirmwareRevGet(L7_uchar8 *firmwareRev)
{
  L7_RC_t rc = L7_FAILURE;
  /* The entity MIB is not implemented in full in fastpath hence this object will return a NULL */
  strcpy(firmwareRev, "");
  if (lldpMedDebugTxFlag == L7_TRUE)
  {
  strcpy(firmwareRev, "rrr ttt \0");
  rc = L7_SUCCESS;
  }
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the Software revision
*
* @param    L7_uchar8                    *SoftwareRev @b((output)) Software revision as a string 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocSoftwareRevGet(L7_uchar8 *softwareRev)
{
  L7_RC_t rc = L7_FAILURE;
  /* The entity MIB is not implemented in full in fastpath hence this object will return a NULL */
  strcpy(softwareRev, "");
  if (lldpMedDebugTxFlag == L7_TRUE)
  {
  strcpy(softwareRev, "software revision 4.5\0");
  rc = L7_SUCCESS;
  }
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the Serial Number
*
* @param    L7_uchar8                    *serialNum @b((output)) Serial Number as a string 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocSerialNumGet(L7_uchar8 *serialNum)
{
  L7_RC_t rc = L7_FAILURE;
  strcpy(serialNum, "");
  if (lldpMedDebugTxFlag == L7_TRUE)
  {
  strcpy(serialNum, "serial number 777\0");
  rc = L7_SUCCESS;
  }
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the Manufacturer's Name 
*
* @param    L7_uchar8                    *mfgName @b((output)) Manufacturer's Name as a string 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocMfgNameGet(L7_uchar8 *mfgName)
{
  L7_RC_t rc = L7_FAILURE;
  /* The entity MIB is not implemented in full in fastpath hence this object will return a NULL */
  strcpy(mfgName, "");
  if (lldpMedDebugTxFlag == L7_TRUE)
  {
  strcpy(mfgName, "Broadcom Corp.\0");
  rc = L7_SUCCESS;
  }
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the Model Name
*
* @param    L7_uchar8                    *modelName @b((output)) Model Name as a string 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocModelNameGet(L7_uchar8 *modelName)
{
  L7_RC_t rc = L7_FAILURE;
  /* The entity MIB is not implemented in full in fastpath hence this object will return a NULL */
  strcpy(modelName, "");
  if (lldpMedDebugTxFlag == L7_TRUE)
  {
  strcpy(modelName, "Model XGS3\0");
  rc = L7_SUCCESS;
  }
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the Asset ID
*
* @param    L7_uchar8                    *assetID @b((output)) Asset ID as a string 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocAssetIDGet(L7_uchar8 *assetID)
{
  L7_RC_t rc = L7_FAILURE;
  /* The entity MIB is not implemented in full in fastpath hence this object will return a NULL */
  strcpy(assetID, "");
  if (lldpMedDebugTxFlag == L7_TRUE)
  {
  strcpy(assetID, "asset 1717\0");
  rc = L7_SUCCESS;
  }
  return rc;
}

/*********************************************************************
*
* @purpose  Sets the location information as a string for given type of Location ID
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  subType  @b((input)) Type of location information (unkbown, ELIN, Co-ord, civic address)
* @param    L7_uint32                  *info @b((input)) Actual location information 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocLocationInfoSet(L7_uint32 intIfNum, 
                    L7_uint32 subType, 
                    L7_uchar8 *info)
{
  L7_RC_t rc = L7_FAILURE;
  /* There are currently no Location based application(s) */

  return rc;
}

/*********************************************************************
*
* @purpose  Gets the location information as a string for given type of Location ID
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  subType  @b((input)) Type of location information (unkbown, ELIN, Co-ord, civic address)
* @param    L7_uint32                  *info @b((output)) Actual location information 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocLocationInfoGet(L7_uint32 intIfNum, 
                    L7_uint32 subType, 
                    L7_uchar8 *info)
{
  L7_RC_t rc = L7_SUCCESS;
  switch (subType)
  {
  case unknown_locsubtype:
  case coordinateBased_locsubtype:
  case civicAddress_locsubtype:
  case elin_locsubtype:
  default:
    /* There are currently no Location based application(s) */
    strcpy(info, "");
    break;
  }

  if (lldpMedDebugTxFlag == L7_TRUE)
  {
  L7_uchar8 location[] = "100777100777\0";
  memcpy(info, location, sizeof(location));
  }

  return rc;
}

/*********************************************************************
*
* @purpose  Gets the PoE device type. 
*
* @param    L7_uint32                *deviceType   @b((output))  Type of power device
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    This routine returns the type as per the MIB definitions
*       The actual value to be transmitted in the LLDPPDU is different 
*           and needs to be mapped by the caller.
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocXPoeDeviceTypeGet(L7_uint32 intIfNum, L7_uint32 *deviceType)
{
  L7_RC_t rc = L7_FAILURE;
  lldpXMedPoeDeviceType_t type = none_poedevicetype;

  if (cnfgrIsFeaturePresent(L7_POE_COMPONENT_ID, L7_POE_FEATURE_ID) == L7_TRUE)
  {
    if (lldpPoeIsValidPDIntf(intIfNum) == L7_SUCCESS)
    {
      type = pdDevice;
    }
    else if (lldpPoeIsValidPSEIntf(intIfNum) == L7_SUCCESS)
    {
      type = pseDevice;
    }

    rc = L7_SUCCESS;
  }
  else
  {
    type = none_poedevicetype;
  }

  *deviceType = type;

  return rc;
}

/*********************************************************************
*
* @purpose  Gets the PSE power value in tenths of watts
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  *powerAv @b((output))  Power value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    This is the amount of power available by the power source device.
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocXPoePSEPortPowerAvGet(L7_uint32 intIfNum, L7_uint32 *powerAv)
{
  L7_RC_t rc = L7_FAILURE;
  L7_uint32 unit;

  unit = simGetThisUnit();
#ifdef  L7_POE_PACKAGE
  if(cnfgrIsFeaturePresent(L7_POE_COMPONENT_ID, L7_POE_FEATURE_ID) == L7_TRUE)
  {
    L7_uint32 maxPower;
    rc = poePethPsePortCurPowerLimitGet(intIfNum, &maxPower);
    if (rc == L7_SUCCESS)
    {
      *powerAv = maxPower; /*powerAv is expresed in 0.1 Watts*/
    }
  }
#else
  rc = L7_FAILURE;
#endif
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the PSE port power priority
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  *priority @b((output)) priority 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    This routine returns the type as per the MIB definitions
*       The actual value to be transmitted in the LLDPPDU is different 
*           and needs to be mapped by the caller.
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocXPoePSEPortPriorityGet(L7_uint32 intIfNum, L7_uint32 *priority)
{
  L7_RC_t rc = L7_SUCCESS;
  L7_uint32 val = 0;
  lldpXMedPoePowerPriority_t localPri;
#ifdef L7_POE_PACKAGE
  rc = poePethPsePortPowerPriorityGet(intIfNum, &val);
#else
  rc = L7_FAILURE;
#endif
  if (rc != L7_SUCCESS)
  {
    return rc;
  }
  switch (val)
  {
  case L7_POE_PRIORITY_CRITICAL:
    localPri = critical_pwpri;
  break;
    case L7_POE_PRIORITY_HIGH: 
    localPri = high_pwpri;
  break;
    case L7_POE_PRIORITY_LOW: 
    localPri = low_pwpri;
  break;
    default:
    localPri = unknown_pwpri;
  break;
  }
  *priority = localPri;

  return rc;
}

/*********************************************************************
*
* @purpose  Gets the power source of this port
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  *powerSource @b((output)) type of power source 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    This routine returns the type as per the MIB definitions
*       The actual value to be transmitted in the LLDPPDU is different 
*           and needs to be mapped by the caller.
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocXPoePSEPowerSourceGet(L7_uint32 *powerSource)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpXMedPsePowerSource_t source = primary_psesrc;

  *powerSource = source;

  return rc;
}

/*********************************************************************
*
* @purpose  Gets this devices PD power requirement
*
* @param    L7_uint32                  *pdPowerReq @b((output))  If this device is a PD then its requirement
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocXPoePDPowerReqGet(L7_uint32 intIfNum,L7_uint32 *pdPowerReq)
{
  L7_RC_t rc = L7_FAILURE;
  L7_uint32 unit;

  unit = simGetThisUnit();
#ifdef  L7_POE_PACKAGE
  if(cnfgrIsFeaturePresent(L7_POE_COMPONENT_ID, L7_POE_FEATURE_ID) == L7_TRUE)
  {
    rc = L7_SUCCESS;
  }

  if (rc == L7_SUCCESS)
  {
    L7_uint32 maxPower;
    rc = poePethPsePortCurPowerLimitGet(intIfNum, &maxPower);
    if (rc == L7_SUCCESS)
    {
      *pdPowerReq = maxPower; /*powerAv is expresed in 0.1 Watts*/
    }
  }
#else
  rc = L7_FAILURE;
#endif
  return rc;
}

/*********************************************************************
*
* @purpose   Gets this device's PD source
*
* @param    L7_uint32                  *powerSource @b((output))  Source of the PD
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocXPoePDPowerSouceGet(L7_uint32 intIfNum,L7_uint32 *powerSource)
{
  L7_RC_t rc = L7_FAILURE;
 lldpXMedPdPowerSource_t source;
   source = localAndPSE_pdsrc;
   *powerSource = source;
   rc = L7_SUCCESS;
  /* Local Device can only be a PSE source not a PD*/
  return rc;
}

/*********************************************************************
*
* @purpose  Gets this device's PD priority
*
* @param    L7_uint32                  *priority @b((output))  Priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedLocXPoePDPowerPriorityGet(L7_uint32 intIfNum,L7_uint32 *priority)
{
  L7_RC_t rc = L7_FAILURE;
  lldpXMedPoePowerPriority_t localPri;
  localPri = high_pwpri;
  *priority = localPri;
  rc = L7_SUCCESS;
  /* Local Device can only be a PSE source not a PD*/
  return rc;
}

/*********************************************************************
*
* @purpose  Gets this port's auto nego capabilities
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_BOOL                   *support @b((output))  Truth value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXdot3LocPortAutoNegSupportedGet(L7_uint32 intIfNum, L7_BOOL *support)
{
  L7_RC_t rc = L7_FAILURE;
  L7_RC_t rc1 = L7_FAILURE;
  L7_uint32 phyCapability,intfSpeed;

  rc = nimGetIntfPhyCapability(intIfNum, &phyCapability);
  rc1 = nimGetIntfSpeed(intIfNum, &intfSpeed);
  if (rc != L7_SUCCESS || rc1 != L7_SUCCESS)
  {
  return L7_FAILURE;
  }
  if (phyCapability & L7_PHY_CAP_PORTSPEED_AUTO_NEG &&
    intfSpeed != L7_PORTCTRL_PORTSPEED_FULL_1000SX)
  {
  *support = L7_TRUE;
  }
  else
  {
  *support = L7_FALSE;
  }

  return rc;
}

/*********************************************************************
*
* @purpose   Gets this port's auto nego status
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_BOOL                  *enabled @b((output))  Truth value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXdot3LocPortAutoNegEnabledGet(L7_uint32 intIfNum, L7_BOOL *enabled)
{
  L7_RC_t rc = L7_SUCCESS;
  L7_uint32 status;
  rc = nimGetIntfAutoNegAdminStatus(intIfNum, &status);
  if (rc != L7_SUCCESS)
  {
  return L7_FAILURE;
  }
  *enabled = (status == L7_ENABLE) ? L7_TRUE : L7_FALSE;

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets this port's auto nego advertized capability
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                   *advrtCap @b((output))  String representation of the capability
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXdot3LocPortAutoNegAdvertizedCapGet(L7_uint32 intIfNum, L7_uchar8 *advrtCap)
{
  L7_uchar8 localCap[2];

  /* Since FastPath does not support RFC 3636 and it's associated objects, return 
   * with the least significant bit set, indicating 'other or unknown'
   */
  localCap[0] = (L7_uchar8)0;
  localCap[1] = (L7_uchar8)1;
  memcpy((void *)advrtCap, (void *)localCap, sizeof(L7_ushort16));
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets this port's auto nego operational MAU type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  *type @b((output))  MAU Type
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXdot3LocPortAutoNegOperMauTypeGet(L7_uint32 intIfNum, L7_uint32 *type)
{
  L7_RC_t rc = L7_SUCCESS;
  
  /*Since we do not implement RFC 3636 return 0*/
  *type = 0;
  return rc;
}

/*********************************************************************
 *                LLDP-MED Remote Device APIs
 *********************************************************************/
/*********************************************************************
*
* @purpose  Gets the supported capabilities that was received in MED TLV on this port
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                   *cap@b((output))  Bit mask of the capabilities
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemCapSupportedGet(L7_uint32 intIfNum, 
                    L7_uint32 remIndex, 
                    L7_uint32 timestamp, 
                    lldpXMedCapabilities_t *cap)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedCapTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
    osapiSemaGive(lldpSemaphore);
    return L7_FAILURE;
  }
  memset(&info,  0x00,  sizeof(lldpMedCapTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_CAP, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedCapTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(cap, info.capabilities, sizeof(lldpXMedCapabilities_t));
  
  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the enabled capabilities that was received in MED TLV on this port
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                   *cap@b((output))  Bit mask of capabilities
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemCapCurrentGet(L7_uint32 intIfNum, 
                    L7_uint32 remIndex, 
                    L7_uint32 timestamp, 
                    lldpXMedCapabilities_t *cap)
{
  lldpRemDataEntry_t *remEntry;
  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(cap, remEntry->medCapCurrent,  sizeof(lldpXMedCapabilities_t));

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
} 

/*********************************************************************
*
* @purpose  Gets the remote devices MED class
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                  *deviceClass @b((output))  MED class of the remote device
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemDeviceClassGet(L7_uint32 intIfNum, 
                     L7_uint32 remIndex, 
                     L7_uint32 timestamp, 
                     L7_uint32 *deviceClass)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedCapTLV_t info;
  L7_uint32 dClass;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }
  memset(&info,  0x00,  sizeof(lldpMedCapTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_CAP, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedCapTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  dClass = (L7_uint32)info.deviceType[0];
  *deviceClass = dClass;

  osapiSemaGive(lldpSemaphore);
  return rc;
} 

/*********************************************************************
*
* @purpose  Gets the vlan id associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_uint32                  *vlanId @b((output))  Vlan ID
*
* @returns  L7_SUCCESS
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemMediaPolicyVlanIdGet(L7_uint32 intIfNum, 
                       L7_uint32 remIndex, 
                       L7_uint32 timestamp, 
                       L7_uint32 policyAppType, 
                       L7_uint32 *vlanId)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedNetPolicyTLV_t info;
  L7_ushort16 vid = 0, hostVid = 0;
  L7_uchar8 vidChar[2];
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedNetPolicyTLV_t));

  rc = lldpOrgDefMedXTLVGet(remEntry,
              (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
              LLDP_MED_SUBTYPE_NET_POLICY, 
              policyAppType, 
              (L7_uchar8*)&info, 
              sizeof(lldpMedNetPolicyTLV_t)); 

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  /* The vlan id is stored in the 0th and 1st byte of the policyBits field */
  vidChar[1] = info.policyBits[1];
  vidChar[0] = info.policyBits[0] << 3;
  vidChar[0] = vidChar[0] >> 3;

  /* There is one more bit than we need we will get rid of it after we copy this in to vid */
  memcpy(&vid, vidChar,  sizeof(vidChar));

  hostVid = osapiNtohs(vid);
  /* Get rid of the right most bit */
  hostVid = hostVid >> 1;

  *vlanId = (L7_uint32)hostVid;

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
} 

/*********************************************************************
*
* @purpose  Gets the priority associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_uint32                  *priority @b((output))  Priority
*
* @returns  L7_SUCCESS
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemMediaPolicyPriorityGet(L7_uint32 intIfNum, 
                         L7_uint32 remIndex, 
                         L7_uint32 timestamp, 
                         L7_uint32 policyAppType, 
                         L7_uint32 *priority)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedNetPolicyTLV_t info;
  L7_uchar8 workByte;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedNetPolicyTLV_t));

  rc = lldpOrgDefMedXTLVGet(remEntry,
              (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
              LLDP_MED_SUBTYPE_NET_POLICY, 
              policyAppType, 
              (L7_uchar8*)&info, 
              sizeof(lldpMedNetPolicyTLV_t)); 

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  workByte = info.policyBits[2];
  workByte = workByte >> 6;

  if (info.policyBits[1] & 0x01)
  {
  workByte |= 0x04;
  }

  *priority = (L7_uint32)workByte;

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the DSCP associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_uint32                  *dscp @b((output))  dscp
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemMediaPolicyDscpGet(L7_uint32 intIfNum, 
                       L7_uint32 remIndex, 
                       L7_uint32 timestamp, 
                       L7_uint32 policyAppType, 
                       L7_uint32 *dscp)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedNetPolicyTLV_t info;
  L7_uchar8 workByte;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedNetPolicyTLV_t));

  rc = lldpOrgDefMedXTLVGet(remEntry,
              (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
              LLDP_MED_SUBTYPE_NET_POLICY, 
              policyAppType, 
              (L7_uchar8*)&info, 
              sizeof(lldpMedNetPolicyTLV_t)); 

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  workByte = info.policyBits[2];
  workByte = workByte << 2;
  workByte = workByte >> 2;
  
  *dscp = (L7_uint32)workByte;

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the Unknown bit associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_BOOL                  *unknown @b((output))  unknown bit value (0/1)
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemMediaPolicyUnknownGet(L7_uint32 intIfNum, 
                        L7_uint32 remIndex, 
                        L7_uint32 timestamp, 
                        L7_uint32 policyAppType, 
                        L7_BOOL *unknown)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedNetPolicyTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedNetPolicyTLV_t));

  rc = lldpOrgDefMedXTLVGet(remEntry,
              (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
              LLDP_MED_SUBTYPE_NET_POLICY, 
              policyAppType, 
              (L7_uchar8*)&info, 
              sizeof(lldpMedNetPolicyTLV_t)); 

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  if (info.policyBits[0] & LLDP_MED_NETWORK_POLICY_U)
  {
  *unknown = L7_TRUE;
  }
  else
  {
  *unknown = L7_FALSE;
  }

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
} 

/*********************************************************************
*
* @purpose  Gets the tagged bit associated with a particular policy type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param  L7_uint32          policyAppType @b((input)) type application policy
* @param    L7_BOOL                  *tagged @b((output))  tagged bit value (0/1)
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemMediaPolicyTaggedGet(L7_uint32 intIfNum, 
                       L7_uint32 remIndex, 
                       L7_uint32 timestamp, 
                       L7_uint32 policyAppType, 
                       L7_BOOL *tagged)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedNetPolicyTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }

  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedNetPolicyTLV_t));

  rc = lldpOrgDefMedXTLVGet(remEntry,
              (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
              LLDP_MED_SUBTYPE_NET_POLICY, 
              policyAppType, 
              (L7_uchar8*)&info, 
              sizeof(lldpMedNetPolicyTLV_t)); 

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  if (info.policyBits[0] & LLDP_MED_NETWORK_POLICY_T)
  {
  *tagged = L7_TRUE;
  }
  else
  {
  *tagged = L7_FALSE;
  }

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
} 

/*********************************************************************
*
* @purpose  Gets the remote device's Hardware Revision
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uchar8                  *hardwareRev @b((output))  Hardware revision as a string
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    hardwareRev should be a minimum of 32 bytes
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemHardwareRevGet(L7_uint32 intIfNum, 
                     L7_uint32 remIndex, 
                     L7_uint32 timestamp, 
                     L7_uchar8 *hardwareRev)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedInventoryTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedInventoryTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_INVENTORY_HW, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedInventoryTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(hardwareRev, info.data, sizeof(info));

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the remote device's Firmware Revision
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uchar8                  *firmwareRev @b((output))  Firmware revision as a string
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemFirmwareRevGet(L7_uint32 intIfNum, 
                     L7_uint32 remIndex, 
                     L7_uint32 timestamp, 
                     L7_uchar8 *firmwareRev)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedInventoryTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedInventoryTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_INVENTORY_FW, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedInventoryTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(firmwareRev, info.data, sizeof(info));

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the remote device's Softdware Revision
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uchar8                  *softwareRev @b((output))  Software revision as a string
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemSoftwareRevGet(L7_uint32 intIfNum, 
                     L7_uint32 remIndex, 
                     L7_uint32 timestamp, 
                     L7_uchar8 *softwareRev)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedInventoryTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedInventoryTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_INVENTORY_SW, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedInventoryTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(softwareRev, info.data, sizeof(info));

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the remote device's Hardware Revision
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uchar8                  *serialNum @b((output))  Serial Number as a string
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemSerialNumGet(L7_uint32 intIfNum, 
                   L7_uint32 remIndex, 
                   L7_uint32 timestamp, 
                   L7_uchar8 *serialNum)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedInventoryTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedInventoryTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_INVENTORY_SNO, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedInventoryTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(serialNum, info.data, sizeof(info));

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the remote device's Manufacturer's Name
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                  *mfgName @b((output))  Manufacturer's name as a string
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemMfgNameGet(L7_uint32 intIfNum, 
                   L7_uint32 remIndex, 
                   L7_uint32 timestamp, 
                   L7_uchar8 *mfgName)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedInventoryTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedInventoryTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_INVENTORY_MFG_NAME, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedInventoryTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(mfgName, info.data, sizeof(info));

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the remote device's Model Name
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uchar8                  *modelName @b((output))  Model Name as a string
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemModelNameGet(L7_uint32 intIfNum, 
                   L7_uint32 remIndex, 
                   L7_uint32 timestamp, 
                   L7_uchar8 *modelName)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedInventoryTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedInventoryTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_INVENTORY_MODEL_NAME, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedInventoryTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(modelName, info.data, sizeof(info));

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the remote device's Asset ID
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uchar8                  *assetID @b((output))  Asset ID as a string
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemAssetIdGet(L7_uint32 intIfNum, 
                   L7_uint32 remIndex, 
                   L7_uint32 timestamp, 
                   L7_uchar8 *assetId)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedInventoryTLV_t info;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info,  0x00,  sizeof(lldpMedInventoryTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_INVENTORY_ASSET_ID, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedInventoryTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(assetId, info.data, sizeof(info));

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the location info received on this port for the given location subtype
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                   subType @b((input))  Loaction subtype 
* @param    L7_uchar8                  *info @b((output)) Location information
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemLocationInfoGet(L7_uint32 intIfNum, 
                    L7_uint32 remIndex, 
                    L7_uint32 timestamp, 
                    L7_uint32 subType, 
                    L7_uchar8 *info)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedLocCoOrdTLV_t infoCoord;
  lldpMedLocCivicTLV_t infoCivic;
  lldpMedLocELINTLV_t infoElin;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }
  
  switch (subType)
  {
  case coordinateBased_locsubtype:
    memset(&infoCoord, 0x00, sizeof(lldpMedLocCoOrdTLV_t));
    rc = lldpOrgDefMedXTLVGet(remEntry,
                (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
                LLDP_MED_SUBTYPE_LOCATION, 
                subType, 
                (L7_uchar8*)&infoCoord, 
                sizeof(lldpMedLocCoOrdTLV_t));
    break;
  case civicAddress_locsubtype:
    memset(&infoCivic, 0x00, sizeof(lldpMedLocCivicTLV_t));
    rc = lldpOrgDefMedXTLVGet(remEntry,
                (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
                LLDP_MED_SUBTYPE_LOCATION, 
                subType, 
                (L7_uchar8*)&infoCivic, 
                sizeof(lldpMedLocCivicTLV_t));
    break;
  case elin_locsubtype:
    memset(&infoElin, 0x00, sizeof(lldpMedLocELINTLV_t));
    rc = lldpOrgDefMedXTLVGet(remEntry,
                (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
                LLDP_MED_SUBTYPE_LOCATION, 
                subType, 
                (L7_uchar8*)&infoElin, 
                sizeof(lldpMedLocELINTLV_t));
    break;
  default:
    rc = L7_FAILURE;
    break;

  }
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }
  switch (subType)
  {
  case coordinateBased_locsubtype:
    memcpy(info, &infoCoord.locID[0], (sizeof(lldpMedLocCoOrdTLV_t)-sizeof(L7_uchar8)));
    break;
  case civicAddress_locsubtype:
    memcpy(info, &infoCivic.locID[0], (sizeof(lldpMedLocCivicTLV_t)-sizeof(L7_uchar8)));
      break;
  case elin_locsubtype:
    memcpy(info, &infoElin.locID[0], (sizeof(lldpMedLocELINTLV_t)-sizeof(L7_uchar8)));
    break;
  default:
    rc = L7_FAILURE;
    break;
  }

  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the remote device's PoE device type connected to this port
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                   *deviceType @b((output))  PoE device type
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemXPoeDeviceTypeGet(L7_uint32 intIfNum, 
                      L7_uint32 remIndex, 
                      L7_uint32 timestamp, 
                      L7_uint32 *deviceType)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedExtPwrTLV_t info;
  L7_uchar8 workByte;
  L7_uint32 type;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
    osapiSemaGive(lldpSemaphore);
    return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldpMedExtPwrTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
                (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
                LLDP_MED_SUBTYPE_EXT_POWER, 
                (L7_uchar8*)&info, 
                sizeof(lldpMedExtPwrTLV_t));
  if (rc != L7_SUCCESS)
  {
    osapiSemaGive(lldpSemaphore);
    return L7_FAILURE;
  }

  workByte = info.powerBits[0];
  type = (L7_uint32) workByte & LLDP_MED_EXT_POWER_TYPE;

  if (type == POWER_DEVICE_TYPE_PSE)
  {
    *deviceType =  pseDevice;
  }
  else if (type == POWER_DEVICE_TYPE_PD)
  {
    *deviceType =  pdDevice;
  }
  else
    rc = L7_FAILURE;

  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the remote ports PSE power value in tenths of watts
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                   *powerAv @b((output))  Power Available
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemXPoePSEPowerAvGet(L7_uint32 intIfNum, 
                        L7_uint32 remIndex, 
                        L7_uint32 timestamp, 
                        L7_uint32 *powerAv)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedExtPwrTLV_t info;
  L7_uchar8 workByte;
  L7_uint32 type;
  L7_ushort16 avg;
  L7_ushort16 hostAvg;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
    return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
    osapiSemaGive(lldpSemaphore);
    return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldpMedExtPwrTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
                      (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
                      LLDP_MED_SUBTYPE_EXT_POWER, 
                      (L7_uchar8*)&info, 
                      sizeof(lldpMedExtPwrTLV_t));
  if (rc != L7_SUCCESS)
  {
    osapiSemaGive(lldpSemaphore);
    return L7_FAILURE;
  }

  workByte = info.powerBits[0];
  type = (L7_uint32) workByte & LLDP_MED_EXT_POWER_TYPE;

  memcpy(&avg, info.powerValue, sizeof(avg));
  hostAvg = osapiNtohs(avg);

  if (type == POWER_DEVICE_TYPE_PSE)
  {
    *powerAv = hostAvg;
  }
  else if (type == POWER_DEVICE_TYPE_PD)
  {
  /* This routine is for PSE */ 
    rc = L7_FAILURE;
  }
  else
    rc = L7_FAILURE;

  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the remote ports PSE power source
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                   *powerSrc@b((output)) Power Soruce type 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemXPoePSEPowerSrcGet(L7_uint32 intIfNum, 
                                L7_uint32 remIndex, 
                                L7_uint32 timestamp, 
                                L7_uint32 *powerSrc)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedExtPwrTLV_t info;
  L7_uchar8 workByte;
  L7_uint32 type,src;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
    return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
    osapiSemaGive(lldpSemaphore);
    return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldpMedExtPwrTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
                      (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
                      LLDP_MED_SUBTYPE_EXT_POWER, 
                      (L7_uchar8*)&info, 
                      sizeof(lldpMedExtPwrTLV_t));
  if (rc != L7_SUCCESS)
  {
    osapiSemaGive(lldpSemaphore);
    return L7_FAILURE;
  }

  workByte = info.powerBits[0];
  type = (L7_uint32) workByte & LLDP_MED_EXT_POWER_TYPE;
  src = (L7_uint32)workByte & LLDP_MED_EXT_POWER_SOURCE;

  if (type == POWER_DEVICE_TYPE_PSE)
  {
    switch (src)
    {
      case POWER_SOURCE_UNKNOWN:
      *powerSrc = unknown_psesrc;
      break;
      case POWER_SOURCE_PRIMARY:
      *powerSrc = primary_psesrc;
      break;
      case POWER_SOURCE_BACKUP:
      *powerSrc = backup_psesrc;
      break;
      case POWER_SOURCE_PSE_AND_LOCAL:
      default:
      rc = L7_FAILURE;
      break;
    }
  }
  else if (type == POWER_DEVICE_TYPE_PD)
  {
  /* This routine is for PSE */ 
    rc = L7_FAILURE;
  }
  else
  {
    rc = L7_FAILURE;
  }

  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the remote ports PSE power priority
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                   *powerPri @b((output)) priority  
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemXPoePSEPowerPriGet(L7_uint32 intIfNum, 
                       L7_uint32 remIndex, 
                       L7_uint32 timestamp, 
                       L7_uint32 *powerPri)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedExtPwrTLV_t info;
  L7_uchar8 workByte;
  L7_uint32 type,pri;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldpMedExtPwrTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_EXT_POWER, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedExtPwrTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  workByte = info.powerBits[0];
  type = (L7_uint32) workByte & LLDP_MED_EXT_POWER_TYPE;
  pri = (L7_uint32)workByte & LLDP_MED_EXT_POWER_PRIORITY;

  if (type == POWER_DEVICE_TYPE_PSE)
  {
    switch (pri)
    {
      case POWER_PRIORITY_UNKNOWN:
      *powerPri = unknown_pwpri;
      break;
      case POWER_PRIORITY_CRITICAL:
      *powerPri = critical_pwpri;
      break;
      case POWER_PRIORITY_HIGH:
      *powerPri = high_pwpri;
      break;
      case POWER_PRIORITY_LOW:
      *powerPri = low_pwpri;
      break;
      default:
      rc = L7_FAILURE;
      break;
    }
  }
  else if (type == POWER_DEVICE_TYPE_PD)
  {
  /* This routine is for PSE */ 
    rc = L7_FAILURE;
  }
  else
    rc = L7_FAILURE;

  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the remote port's PD power requirement 
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                   *powerReq @b((output)) Power requirement 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemXPoePDPowerReqGet(L7_uint32 intIfNum, 
                      L7_uint32 remIndex, 
                      L7_uint32 timestamp, 
                      L7_uint32 *powerReq)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedExtPwrTLV_t info;
  L7_uchar8 workByte;
  L7_uint32 type;
  L7_ushort16 req;
  L7_ushort16 hostReq;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldpMedExtPwrTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_EXT_POWER, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedExtPwrTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  workByte = info.powerBits[0];
  type = (L7_uint32) workByte & LLDP_MED_EXT_POWER_TYPE;

  memcpy(&req, info.powerValue, sizeof(req));
  hostReq = osapiNtohs(req);

  if (type == POWER_DEVICE_TYPE_PD)
  {
    *powerReq = hostReq;
  }
  else if (type == POWER_DEVICE_TYPE_PSE)
  {
  /* This routine is for PD*/ 
    rc = L7_FAILURE;
  }
  else
  {
    rc = L7_FAILURE;
  }

  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the remote port's PD power Source
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                  *powerSrc @b((output))  Power source type
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemXPoePDPowerSrcGet(L7_uint32 intIfNum, 
                      L7_uint32 remIndex, 
                      L7_uint32 timestamp, 
                      L7_uint32 *powerSrc)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedExtPwrTLV_t info;
  L7_uchar8 workByte;
  L7_uint32 type,src;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldpMedExtPwrTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_EXT_POWER, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedExtPwrTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  workByte = info.powerBits[0];
  type = (L7_uint32) workByte & LLDP_MED_EXT_POWER_TYPE;
  src = (L7_uint32)workByte & LLDP_MED_EXT_POWER_SOURCE;

  if (type == POWER_DEVICE_TYPE_PD)
  {
  switch (src)
  {
    case POWER_SOURCE_UNKNOWN:
    *powerSrc = unknown_pdsrc;
    break;
    case POWER_SOURCE_PSE:
    *powerSrc = fromPSE_pdsrc;
    break;
    case POWER_SOURCE_LOCAL:
    *powerSrc = local_pdsrc;
    break;
    case POWER_SOURCE_PSE_AND_LOCAL:
    *powerSrc = localAndPSE_pdsrc;
    break;
    default:
    rc = L7_FAILURE;
    break;
    }
  }
  else if (type == POWER_DEVICE_TYPE_PSE)
  {
  /* This routine is for PD */ 
  rc = L7_FAILURE;
  }
  else
  {
    rc = L7_FAILURE;
  }

  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*********************************************************************
*
* @purpose  Gets the remote port's PD power priority
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                  *powerPri @b((output))  power priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXMedRemXPoePDPowerPriGet(L7_uint32 intIfNum, 
                      L7_uint32 remIndex, 
                      L7_uint32 timestamp, 
                      L7_uint32 *powerPri)
{
  L7_RC_t rc = L7_SUCCESS;
  lldpMedExtPwrTLV_t info;
  L7_uchar8 workByte;
  L7_uint32 type,pri;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldpMedExtPwrTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
            LLDP_MED_SUBTYPE_EXT_POWER, 
            (L7_uchar8*)&info, 
            sizeof(lldpMedExtPwrTLV_t));
  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  workByte = info.powerBits[0];
  type = (L7_uint32) workByte & LLDP_MED_EXT_POWER_TYPE;
  pri = (L7_uint32)workByte & LLDP_MED_EXT_POWER_PRIORITY;

  if (type == POWER_DEVICE_TYPE_PD)
  {
  switch (pri)
  {
    case POWER_PRIORITY_UNKNOWN:
    *powerPri = unknown_pwpri;
    break;
    case POWER_PRIORITY_CRITICAL:
    *powerPri = critical_pwpri;
    break;
    case POWER_PRIORITY_HIGH:
    *powerPri = high_pwpri;
    break;
    case POWER_PRIORITY_LOW:
    *powerPri = low_pwpri;
    break;
    default:
    rc = L7_FAILURE;
    break;
    }
  }
  else if (type == POWER_DEVICE_TYPE_PSE)
  {
  /* This routine is for PD */ 
  rc = L7_FAILURE;
  }
  else
  {
    rc = L7_FAILURE;
  }

  osapiSemaGive(lldpSemaphore);
  return rc;
}

/*****************************************************************************
*
* @purpose  Gets the PoE Requested device type.
*
* @param    L7_uint32   *deviceType   @b((output))  Type of power device
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    This routine returns the type as per the MIB definitions
*           The actual value to be transmitted in the LLDPPDU is different
*           and needs to be mapped by the caller.
*
* @end
******************************************************************************/
L7_RC_t lldpXdot3PoePortReqPowerDeviceTypeGet(L7_uint32 intIfNum, L7_uint32 *deviceType)
{
  L7_RC_t rc = L7_FAILURE;
  lldpXMedPoeDeviceType_t type = none_poedevicetype;
  L7_uint32 val = 0;
  L7_uint32 unit;

  unit = simGetThisUnit();
#ifdef L7_POE_PACKAGE
  if(cnfgrIsFeaturePresent(L7_POE_COMPONENT_ID, L7_POE_FEATURE_ID) == L7_TRUE)
  {
    rc = L7_SUCCESS;
  }
  if (rc == L7_SUCCESS)
  {
    rc = poePethPoePortReqPowerDeviceTypeGet(intIfNum, &val);
  }

#else
  rc = L7_FAILURE;
#endif

  if(rc == L7_SUCCESS)
  {
    switch(val)
    {
      case L7_POE_DEVICE_TYPE_PSE:
        type = pseDevice;
        break;
      case L7_POE_DEVICE_TYPE_PD:
        type = pdDevice;
        break;
      default:
        rc = L7_FAILURE;
    }
  }
  *deviceType = type;

  return rc;
}

/*****************************************************************************
*
* @purpose  Gets the POE Port Requested power value in tenths of watts
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  *powerAv @b((output))  Power value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    This is the amount of power requesting by the power device.
*
* @end
******************************************************************************/
L7_RC_t lldpXdot3PoePortReqPowerAvGet(L7_uint32 intIfNum, L7_uint32 *powerAv)
{
  L7_RC_t rc = L7_FAILURE;
  L7_uint32 unit;

  unit = simGetThisUnit();
#ifdef  L7_POE_PACKAGE
  if(cnfgrIsFeaturePresent(L7_POE_COMPONENT_ID, L7_POE_FEATURE_ID) == L7_TRUE)
  {
    rc = L7_SUCCESS;
  }
  if (rc == L7_SUCCESS)
  {
    L7_uint32 maxPower;
    rc = poePethPoePortMaxReqPowerLimitGet(intIfNum, &maxPower);
    if (rc == L7_SUCCESS)
    {
      *powerAv = maxPower;
    }
  }
#else
  rc = L7_FAILURE;
#endif

  return rc;
}

/*****************************************************************************
*
* @purpose  Gets the PSE port requesting power priority
*
* @param    L7_uint32       intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32       *priority @b((output)) priority
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes
*
* @end
******************************************************************************/
L7_RC_t lldpXdot3PoePortReqPowerPriorityGet(L7_uint32 intIfNum, 
                                               L7_uint32 *priority)
{
  L7_RC_t rc = L7_FAILURE;
  L7_uint32 val=0;
  L7_uint32 unit;
  lldpXMedPoePowerPriority_t localPri = unknown_pwpri;

  unit = simGetThisUnit();

#ifdef L7_POE_PACKAGE
  if(cnfgrIsFeaturePresent(L7_POE_COMPONENT_ID, L7_POE_FEATURE_ID) == L7_TRUE)
  {
    rc = L7_SUCCESS;
  }
  if(rc == L7_SUCCESS)
  {
    rc = poePethPoePortReqPowerPriorityGet(intIfNum, &val);
  }
#else
  rc = L7_FAILURE;
#endif

  if(rc == L7_SUCCESS)
  {
    switch (val)
    {
      case L7_POE_PRIORITY_CRITICAL:
        localPri = critical_pwpri;
        break;
      case L7_POE_PRIORITY_HIGH: 
        localPri = high_pwpri;
        break;
      case L7_POE_PRIORITY_LOW: 
        localPri = low_pwpri;
        break;
      default:
        localPri = unknown_pwpri;
        break;
    }
    *priority = localPri;
  }

  return rc;
}

/*****************************************************************************
*
* @purpose  Gets the requesting power source of this port
*
* @param    L7_uint32    intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32    *powerSource @b((output)) type of power source
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes
*
* @end
******************************************************************************/
L7_RC_t lldpXdot3PoePortReqPowerSourceGet(L7_uint32 intIfNum, 
                                             L7_uint32 *source)
{
  L7_RC_t rc = L7_SUCCESS;
  L7_uint32 pwrSrc=0, devType=0;
  L7_uint32 unit;
  lldpXMedPsePowerSource_t localPseSource;
  lldpXMedPdPowerSource_t localPdSource;

  unit = simGetThisUnit();

#ifdef L7_POE_PACKAGE
  if(rc == L7_SUCCESS)
  {
    rc = poePethPoePortReqPowerSourceGet(intIfNum, &pwrSrc);
    if(rc == L7_SUCCESS)
    {
      rc = poePethPoePortReqPowerDeviceTypeGet(intIfNum, &devType);
    }
  }
  else
  {
    rc = L7_FAILURE;
  }
#else
  rc = L7_FAILURE;
#endif
  if (rc == L7_SUCCESS)
  {
    if(devType == L7_POE_DEVICE_TYPE_PSE)
    {
      switch (pwrSrc)
      {
        case L7_POE_PSE_SOURCE_PRIMARY: 
          localPseSource = primary_psesrc;
          break;
        case L7_POE_PSE_SOURCE_BACKUP: 
          localPseSource = backup_psesrc;
          break;
        default:
          localPseSource = unknown_psesrc;
          break;
      }
      *source = localPseSource;
    }
    else if(devType == L7_POE_DEVICE_TYPE_PD)
    {
      switch (pwrSrc)
      {
        case L7_POE_PD_SOURCE_FROM_PSE:
          localPdSource = fromPSE_pdsrc;
          break;
        case L7_POE_PD_SOURCE_LOCAL:
          localPdSource = local_pdsrc;
          break;
        case L7_POE_PD_SOURCE_LOCAL_AND_PSE:
          localPdSource = localAndPSE_pdsrc;
          break;
        default:
          localPdSource = unknown_pdsrc;
          break;
      }
      *source = localPdSource;
    }
    else
    {
      rc = L7_FAILURE;
    }
  }

  return rc;
}

/*****************************************************************************
*
* @purpose  Gets the POE Port Acknowledge status
*
* @param    L7_uint32          intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32          *powerAck @b((output))  Power Acknowledge
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    This is the status power acknowledge
*
* @end
******************************************************************************/
L7_RC_t lldpXdot3PoePortReqPowerAckGet(L7_uint32 intIfNum, L7_uint32 *powerAck)
{
  L7_RC_t rc = L7_FAILURE;
  L7_uint32 val=0;
  L7_uint32 unit;
  lldpX8023PoePowerAck_t localAck = ignore_pwack;

  unit = simGetThisUnit();

#ifdef L7_POE_PACKAGE
  if(cnfgrIsFeaturePresent(L7_POE_COMPONENT_ID, L7_POE_FEATURE_ID) == L7_TRUE)
  {
    rc = L7_SUCCESS;
  }
  if(rc == L7_SUCCESS)
  {
    rc = poePethPoePortLocPowerAckGet(intIfNum, &val);
  }
#else
  rc = L7_FAILURE;
#endif

  if (rc == L7_SUCCESS)
  {
    switch (val)
    {
      case L7_POE_ACK_IGNORE:
        localAck = ignore_pwack;
        break;
      case L7_POE_ACK_YES:
        localAck = ack_pwack;
        break;
      case L7_POE_ACK_NO:
        localAck = nack_pwack;
        break;
      default:
        rc = L7_FAILURE;
        break;
    }
  }
  *powerAck = localAck;

  return rc;
}

/*****************************************************************************
*
* @purpose  Gets the remote port's Power Values
*
* @param    L7_uint32      intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32      *notify   @b((output)) Power Values
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes
*
* @end
******************************************************************************/
L7_RC_t lldpMedProcessPoeDevicePdu(lldpRemDataEntry_t *remEntry,L7_BOOL poeDevice,L7_uchar8 deviceType)
{
  lldpMedExtPwrTLV_t extPwrInfo;
  lldp8023StatefulCntlTLV_t statefulCtrlInfo;
  lldpXMedNotify_t   notifyMsg;
  lldpXMedNotify_t*   notify = &notifyMsg;
  L7_uchar8 workByte;
  L7_ushort16 workShort;

  memset(&extPwrInfo, 0x00, sizeof(lldpMedExtPwrTLV_t));
  memset(&statefulCtrlInfo, 0x00, sizeof(lldp8023StatefulCntlTLV_t));
  memset(&notifyMsg, 0x00, sizeof(lldpXMedNotify_t));

  if ((lldpOrgDefTLVGet(remEntry,
              (L7_uchar8*)LLDP_MED_TIA_OUI_STRING,
              LLDP_MED_SUBTYPE_EXT_POWER,
              (L7_uchar8*)&extPwrInfo,
              sizeof(lldpMedExtPwrTLV_t)) == L7_SUCCESS) &&
     (lldpOrgDefTLVGet(remEntry,
              (L7_uchar8*)LLDP_8023_TIA_OUI_STRING,
              LLDP_8023_SUBTYPE_POE_STATEFUL_CONTROL,
              (L7_uchar8*)&statefulCtrlInfo,
              sizeof(lldp8023StatefulCntlTLV_t)) == L7_SUCCESS))
  {
    /* We see a new POE TLV. send out a ADD notification */
    /* Power Device Type */
    workByte = (L7_uchar8)(extPwrInfo.powerBits[0]);
    switch(workByte & LLDP_MED_EXT_POWER_TYPE)
    {
      case POWER_DEVICE_TYPE_PSE:
        notify->evData.poe.remLocPowerDeviceType = pseDevice;
        break;
      case POWER_DEVICE_TYPE_PD:
        notify->evData.poe.remLocPowerDeviceType = pdDevice;
        break;
      default:
        /* Invalid Device Type reported */
        break;
    }

    /* Power Source Type */
    switch(workByte & LLDP_MED_EXT_POWER_SOURCE)
    {
      case POWER_SOURCE_PSE:
        notify->evData.poe.remLocPowerSource = fromPSE_pdsrc;
        break;
      case POWER_SOURCE_LOCAL:
        notify->evData.poe.remLocPowerSource = local_pdsrc;
        break;
      case POWER_SOURCE_UNKNOWN:
        notify->evData.poe.remLocPowerSource = unknown_pdsrc;
        break;
      default:
        /* Invalid Power Source reported */
        break;
    }

    /* Power Priority */
    switch(workByte & LLDP_MED_EXT_POWER_PRIORITY)
    {
      case POWER_PRIORITY_LOW:
        notify->evData.poe.remLocPowerPriority = low_pwpri;
        break;
      case POWER_PRIORITY_HIGH:
        notify->evData.poe.remLocPowerPriority = high_pwpri;
        break;
      case POWER_PRIORITY_CRITICAL:
        notify->evData.poe.remLocPowerPriority = critical_pwpri;
        break;
      case POWER_PRIORITY_UNKNOWN:
        notify->evData.poe.remLocPowerPriority = unknown_pwpri;
        break;
      default:
        /* Invalid Power Source reported */
        break;
    }
    memcpy(&workShort, extPwrInfo.powerValue, sizeof(workShort));
    workShort = osapiNtohs(workShort);
    notify->evData.poe.remLocPowerValue = workShort;

    workByte = (L7_uchar8)(statefulCtrlInfo.reqPowerBits[0]);
    switch(workByte & LLDP_MED_EXT_POWER_TYPE)
    {
      case POWER_DEVICE_TYPE_PSE:
        notify->evData.poe.remReqPowerDeviceType = pseDevice;
        break;
      case POWER_DEVICE_TYPE_PD:
        notify->evData.poe.remReqPowerDeviceType = pdDevice;
        break;
      default:
        /* Invalid Device Type reported */
        break;
    }

    /* Power Source Type */
    switch(workByte & LLDP_MED_EXT_POWER_SOURCE)
    {
      case POWER_SOURCE_PSE:
        notify->evData.poe.remReqPowerSource = fromPSE_pdsrc;
        break;
      case POWER_SOURCE_LOCAL:
        notify->evData.poe.remReqPowerSource = local_pdsrc;
        break;
      case POWER_SOURCE_UNKNOWN:
        notify->evData.poe.remReqPowerSource = unknown_pdsrc;
        break;
      default:
        /* Invalid Power Source reported */
        break;
    }

    /* Power Priority */
    switch(workByte & LLDP_MED_EXT_POWER_PRIORITY)
    {
      case POWER_PRIORITY_LOW:
        notify->evData.poe.remReqPowerPriority = low_pwpri;
        break;
      case POWER_PRIORITY_HIGH:
        notify->evData.poe.remReqPowerPriority = high_pwpri;
        break;
      case POWER_PRIORITY_CRITICAL:
        notify->evData.poe.remReqPowerPriority = critical_pwpri;
        break;
      case POWER_PRIORITY_UNKNOWN:
        notify->evData.poe.remReqPowerPriority = unknown_pwpri;
        break;
      default:
        /* Invalid Power Source reported */
        break;
    }

    memcpy(&workShort, statefulCtrlInfo.reqPowerValue, sizeof(workShort));
    workShort = osapiNtohs(workShort);
    notify->evData.poe.remReqPowerValue = workShort;
    /* Power Acknowledge */
    workByte = (L7_uchar8)(statefulCtrlInfo.powerAck[0]);

    notify->evData.poe.remLocPowerAck        = workByte&LLDP_8023_STATEFUL_CNTRL_ACKNOWLEDGE;
    notify->event = LLDP_POE_ADD_EVENT;
    lldpXMedNotifyRegisteredUsers(remEntry->intIntfNum, notify);
    return L7_SUCCESS;
  }
  return L7_FAILURE;
}

/*********************************************************************
 *                LLDP 802.3 Extension Configuration APIs
 *********************************************************************/
/*********************************************************************
*
* @purpose  Gets remote port's auto nego capability
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_BOOL                   *support@b((output)) Truth value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXdot3RemPortAutoNegSupportedGet(L7_uint32 intIfNum, 
                         L7_uint32 remIndex, 
                         L7_uint32 timestamp, 
                         L7_BOOL *support)
{
  L7_RC_t rc = L7_SUCCESS;
  lldp8023MacPhyTLV_t info;
  lldpRemDataEntry_t *remEntry;
  
  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldp8023MacPhyTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_8023_TIA_OUI_STRING, 
            LLDP_8023_SUBTYPE_MAC_PHY,
            (L7_uchar8*)&info,
            sizeof(lldp8023MacPhyTLV_t));

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  if (info.autoNegSupStatus[0] & LLDP_8023_MAC_PHY_AUTO_NEG_SUP)
  {
  *support = L7_TRUE;
  }
  else
  {
  *support = L7_FALSE;
  }

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets remote port's auto nego enabled status
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_BOOL                   *enabled@b((output)) Truth value 
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXdot3RemPortAutoNegEnabledGet(L7_uint32 intIfNum, 
                         L7_uint32 remIndex, 
                         L7_uint32 timestamp, 
                         L7_BOOL *enabled)
{
  L7_RC_t rc = L7_SUCCESS;
  lldp8023MacPhyTLV_t info;
  lldpRemDataEntry_t *remEntry;
  
  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldp8023MacPhyTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_8023_TIA_OUI_STRING, 
              LLDP_8023_SUBTYPE_MAC_PHY,
            (L7_uchar8*)&info,
            sizeof(lldp8023MacPhyTLV_t));

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  if (info.autoNegSupStatus[0] & LLDP_8023_MAC_PHY_AUTO_NEG_STATUS)
  {
  *enabled = L7_TRUE;
  }
  else
  {
  *enabled = L7_FALSE;
  }

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets remote ports auto nego advertized capability as a string
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uchar8                  *advrtCap @b((output))  Advertized capability
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXdot3RemPortAutoNegAdvertizedCapGet(L7_uint32 intIfNum, 
                           L7_uint32 remIndex, 
                           L7_uint32 timestamp, 
                           L7_uchar8 *advrtCap)
{
  L7_RC_t rc = L7_SUCCESS;
  lldp8023MacPhyTLV_t info;
  lldpRemDataEntry_t *remEntry;
  
  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldp8023MacPhyTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_8023_TIA_OUI_STRING, 
            LLDP_8023_SUBTYPE_MAC_PHY,
            (L7_uchar8*)&info,
            sizeof(lldp8023MacPhyTLV_t));

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(advrtCap, info.autoNegAdvt, 2);

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the remote port's Operational MAU Type
*
* @param    L7_uint32                  intIfNum  @b((input)) Internal Interface Number
* @param    L7_uint32                  remIndex  @b((input)) Index associated with this remote entry
* @param    L7_uint32                  timestamp @b((input)) Time Stamp associated with this entry
* @param    L7_uint32                  *type @b((output))  MAU Type
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpXdot3RemPortAutoNegOperMauTypeGet(L7_uint32 intIfNum, 
                           L7_uint32 remIndex, 
                           L7_uint32 timestamp, 
                           L7_uint32 *type)
{
  L7_RC_t rc = L7_SUCCESS;
  lldp8023MacPhyTLV_t info;
  L7_ushort16 mtype, hostmtype;
  lldpRemDataEntry_t *remEntry;

  if (lldpIsValidIntf(intIfNum) != L7_TRUE)
  {
  return L7_FAILURE;
  }
  osapiSemaTake(lldpSemaphore, L7_WAIT_FOREVER);
  if ((remEntry = lldpIsRemEntryValid(intIfNum, remIndex, timestamp)) == L7_NULLPTR)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldp8023MacPhyTLV_t));

  rc = lldpOrgDefTLVGet(remEntry,
            (L7_uchar8*)LLDP_8023_TIA_OUI_STRING, 
            LLDP_8023_SUBTYPE_MAC_PHY,
            (L7_uchar8*)&info,
            sizeof(lldp8023MacPhyTLV_t));

  if (rc != L7_SUCCESS)
  {
  osapiSemaGive(lldpSemaphore);
  return L7_FAILURE;
  }

  memcpy(&mtype, info.operMAUType, sizeof(mtype));

  hostmtype = osapiNtohs(mtype);

  *type = (L7_uint32)hostmtype;

  osapiSemaGive(lldpSemaphore);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Gets the org defines tlv string for a given oui and subtype
*
* @param    lldpRemDataEntry_tremEntry @b{(input)} The  remote Info Node
* @param    L7_uchar8 *oui      @b((input)) Org Unique Id
* @param    L7_uint32 subtype   @b((input)) type of tlv
* @param    L7_uchar8 *info     @b((output)) pointer to the information
* @param    L7_uint32 infoLength  @b((input))  length of the information
*
* @returns  L7_SUCCESS  - if the tlv is found
* @returns  L7_FAILURE
*
* @notes    The info should be supplied with sufficient space 
*
* @end
*********************************************************************/
L7_RC_t lldpOrgDefTLVGet(lldpRemDataEntry_t *remEntry, L7_uchar8 *oui, 
                         L7_uint32 subtype, L7_uchar8 *info, L7_uint32 infoLength)
{
  lldpOrgDefInfoEntry_t *entry = L7_NULLPTR;

  if(remEntry == L7_NULLPTR)
  {
    return L7_FAILURE;
  }

  entry = remEntry->orgDefInfoList;
  while (entry != L7_NULLPTR)
  {
    if (memcmp(entry->oui, oui, LLDP_TIA_OUI_STRING_LEN) == 0 && 
    entry->subtype == subtype &&
    entry->length == infoLength) 
    {
      memcpy(info, entry->info, entry->length);
      return L7_SUCCESS;
    }
    entry = entry->next;
  }
  return L7_FAILURE;
}

/*********************************************************************
*
* @purpose  Gets the MED org defines network policy or Location tlv string for a given oui and subtype and app type
*
* @param    lldpRemDataEntry_tremEntry @b{(input)} The  remote Info Node
* @param    L7_uchar8 *oui      @b((input)) Org Unique Id
* @param    L7_uint32 subtype   @b((input)) type of tlv
* @param    L7_uint32 appType   @b((input)) type of application
* @param    L7_uchar8 *info     @b((output)) pointer to the information
* @param    L7_uint32 infoLength  @b((input))  length of the information
*
* @returns  L7_SUCCESS  - if the tlv is found
* @returns  L7_FAILURE
*
* @notes    The info should be supplied with sufficient space 
*
* @end
*********************************************************************/
L7_RC_t lldpOrgDefMedXTLVGet(lldpRemDataEntry_t *remEntry, L7_uchar8 *oui, L7_uint32 subtype, 
                             L7_uint32 appType, L7_uchar8 *info, L7_uint32 infoLength)
{
  lldpOrgDefInfoEntry_t *entry = L7_NULLPTR;

  if(remEntry == L7_NULLPTR)
  {
    return L7_FAILURE;
  }
  entry = remEntry->orgDefInfoList;
  while (entry != L7_NULLPTR)
  {
    if (memcmp(entry->oui, oui, LLDP_TIA_OUI_STRING_LEN) == 0 && 
    entry->subtype == subtype &&
    (L7_uint32)entry->info[0] == appType &&
    entry->length <= infoLength)  /* To accomodate for variable length TLVs the comparison is relaxed to less and equal*/
    {
      memcpy(info, entry->info, entry->length);
      return L7_SUCCESS;
    }
    entry = entry->next;
  }
  return L7_FAILURE;
}

/*********************************************************************
*
* @purpose  Process the PDU packet from MED prespective to send out notifications
*
* @param    lldpRemDataEntry_tremEntry @b{(input)} The  remote Info Node
* @param    L7_BOOL voiceDevice     @b((input)) previously does voice device exists
* @param    L7_uchar8 deviceType      @b((input)) previous device type
*
* @returns  L7_SUCCESS  
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpMedProcessVoiceDevicePdu(lldpRemDataEntry_t *remEntry,L7_BOOL voiceDevice,L7_uchar8 deviceType)
{
  lldpMedCapTLV_t    info;
  lldpXMedNotify_t   medData;
  L7_RC_t            result;

  if(remEntry == L7_NULLPTR)
  {
     return L7_FAILURE;
  }

  memset(&info, 0x00, sizeof(lldpMedCapTLV_t));
  memset(&medData,  0x00,  sizeof(lldpXMedNotify_t));
  memcpy(medData.evData.med.mac,remEntry->srcMac, L7_MAC_ADDR_LEN);
  
  result = lldpOrgDefTLVGet(remEntry,
                            (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
                            LLDP_MED_SUBTYPE_CAP, 
                            (L7_uchar8*)&info, 
                            sizeof(lldpMedCapTLV_t));

  medData.evData.med.deviceType = (L7_uint32)info.deviceType[0];

  if (voiceDevice == L7_FALSE && result == L7_SUCCESS)
  {
    if ((L7_uint32)info.deviceType[0] == endpointClass3)
    {
      /* We see a new voice device endpoint class III 
       * send out a ADD notification*/
      medData.event = LLDP_MED_ADD_EVENT;
      lldpXMedNotifyRegisteredUsers(remEntry->intIntfNum, &medData);
    }
  }
  else if (voiceDevice == L7_TRUE && result == L7_SUCCESS)
  {
    if ((L7_uint32)info.deviceType[0] != endpointClass3)
    {
      /* We do not see a previously detected voice device endpoint class III 
       * send out a REMOVE notification */
      medData.event = LLDP_MED_REMOVE_EVENT;
      lldpXMedNotifyRegisteredUsers(remEntry->intIntfNum, &medData);
    }
  }
  else if (voiceDevice == L7_TRUE && result != L7_SUCCESS)
  {
    /* We do not see a previously detected voice device endpoint class III 
     * send out a REMOVE notification  */
    medData.event = LLDP_MED_REMOVE_EVENT;
    medData.evData.med.deviceType = deviceType;
    lldpXMedNotifyRegisteredUsers(remEntry->intIntfNum, &medData);
  }
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Get voice device info from a remote node
*
* @param    lldpRemDataEntry_tremEntry @b{(input)} The  remote Info Node
* @param    L7_BOOL voiceDevice     @b((output)) previously does voice device exists
* @param    L7_uchar8 deviceType      @b((output)) previous device type
*
* @returns  L7_SUCCESS  
* @returns  L7_FAILURE
*
* @notes    
*
* @end
*********************************************************************/
L7_RC_t lldpMedGetRemEntryVoiceInfo(lldpRemDataEntry_t *remEntry,L7_BOOL *voiceDevice,L7_uchar8 *deviceType)
{
  lldpMedCapTLV_t    info;
  memset(&info, 0x00, sizeof(lldpMedCapTLV_t));
  if (lldpOrgDefTLVGet(remEntry,
                       (L7_uchar8*)LLDP_MED_TIA_OUI_STRING, 
                       LLDP_MED_SUBTYPE_CAP, 
                       (L7_uchar8*)&info, 
                       sizeof(lldpMedCapTLV_t)) == L7_SUCCESS)
  {
    if ((L7_uint32)info.deviceType[0] == endpointClass3)
    {
      *voiceDevice = L7_TRUE;
    }
    *deviceType = info.deviceType[0];
    return L7_SUCCESS;
  }
  return L7_FAILURE;
}

L7_RC_t lldpMedGetRemEntryPoeInfo(lldpRemDataEntry_t *remEntry,L7_BOOL *poeDevice,L7_uchar8 *deviceType)
{
  lldpMedExtPwrTLV_t extPwrInfo;
  lldp8023StatefulCntlTLV_t statefulCtrlInfo;
  memset(&extPwrInfo, 0x00, sizeof(lldpMedExtPwrTLV_t));
  memset(&statefulCtrlInfo, 0x00, sizeof(lldp8023StatefulCntlTLV_t));

  if ((lldpOrgDefTLVGet(remEntry,
              (L7_uchar8*)LLDP_MED_TIA_OUI_STRING,
              LLDP_MED_SUBTYPE_EXT_POWER,
              (L7_uchar8*)&extPwrInfo,
              sizeof(lldpMedExtPwrTLV_t)) == L7_SUCCESS) &&
     (lldpOrgDefTLVGet(remEntry,
              (L7_uchar8*)LLDP_8023_TIA_OUI_STRING,
              LLDP_8023_SUBTYPE_POE_STATEFUL_CONTROL,
              (L7_uchar8*)&statefulCtrlInfo,
              sizeof(lldp8023StatefulCntlTLV_t)) == L7_SUCCESS))
  {
      *poeDevice = L7_TRUE;
      return L7_SUCCESS;
  }
  return L7_FAILURE;
}

/*********************************Debug Routines **************************/
void lldpMedDebugRemIntfDump(L7_uint32 intIfNum)
{
  L7_uint32 index = 0;
  L7_uint32 extIfNum = 0;
  L7_uint32 remIndex, timestamp;
  L7_RC_t rc;
  L7_uchar8 data[512];
  L7_uint32 intData,i;
  L7_BOOL boolData;
  
  printf("\n");
  printf("LLDP-MED Remote Data\n");
  printf("=====================\n\n");

  if (lldpMapIntfIndexGet(intIfNum, &index) == L7_TRUE)
  {
    if (nimGetIntfIfIndex(intIfNum, &extIfNum) == L7_SUCCESS)
    {
      printf("Local Interface: %d\n", extIfNum);
      printf("Remote MED Data\n");
      printf("-------------------------------------------------\n");

    rc = lldpRemEntryGet(intIfNum, &remIndex, &timestamp);
    if (rc != L7_SUCCESS)
    {
    printf("Remote Entry not present\n");
    }
    if (lldpXMedRemDeviceClassGet(intIfNum, remIndex, timestamp, &intData) == L7_SUCCESS)
    {
    printf("MED Cap TLV Device Class: %d\n", intData);
    }
    else
    {
    printf("MED CAP TLV DeviceClass not present\n");
    }
    bzero(data,  512);
    if (lldpXMedRemCapSupportedGet(intIfNum, remIndex, timestamp, (lldpXMedCapabilities_t *)data) == L7_SUCCESS)
    {
    printf("MED CAP TLV cap supported: 0x%x 0x%x\n", data[0],  data[1]);
    }
    else
    {
    printf("MED CAP TLV cap sup not present\n");
    }
    if (lldpXMedRemCapCurrentGet(intIfNum, remIndex, timestamp, (lldpXMedCapabilities_t *)data) == L7_SUCCESS)
    {
        printf("MED CAP TLV cap cur : 0x%x 0x%x\n", data[0],  data[1]);
    }
    else
    {
    printf("MED CAP TLV cap cur not present\n");
    }
    for (i = voice_policyapptype; i <= /*videoSignaling_policyapptype*/voice_policyapptype; i++ )
    {
      if (lldpXMedRemMediaPolicyVlanIdGet(intIfNum, remIndex, timestamp, i, &intData) == L7_SUCCESS)
    {
      printf("MED Net Policy %d vlan id %d\n", i, intData);
    }
    else
    {
      printf("MED Net Policy %d not present\n", i);
    }
    if (lldpXMedRemMediaPolicyUnknownGet(intIfNum, remIndex, timestamp, i, &boolData) == L7_SUCCESS)
    {
      printf("MED Net Policy %d unknown %d\n", i, boolData);
    }
    else
    {
      printf("MED Net Policy %d not present\n", i);
    }
    if (lldpXMedRemMediaPolicyTaggedGet(intIfNum, remIndex, timestamp, i, &boolData) == L7_SUCCESS)
    {
      printf("MED Net Policy %d tagged %d\n", i, boolData);
    }
    else
    {
      printf("MED Net Policy %d not present\n", i);
    }
    if (lldpXMedRemMediaPolicyPriorityGet(intIfNum, remIndex, timestamp, i, &intData) == L7_SUCCESS)
    {
          printf("MED Net Policy %d priority %d\n", i, intData);
    }
    else
    {
      printf("MED Net Policy %d not present\n", i);
    }
    if (lldpXMedRemMediaPolicyDscpGet(intIfNum, remIndex, timestamp, i, &intData) == L7_SUCCESS)
    {
          printf("MED Net Policy %d dscp %d\n", i, intData);
    }
    else
    {
      printf("MED Net Policy %d not present\n", i);
    }
      }
    for (i = coordinateBased_locsubtype; i <= elin_locsubtype; i++)
    {
    bzero(data,  512);
    if (lldpXMedRemLocationInfoGet(intIfNum, remIndex, timestamp, i, &data[0]) == L7_SUCCESS)
    {
      printf("MED location TLV type %d Info %s\n", i, data);
    }
    else
    {
      printf("MED Location TLV type %d not present\n", i);
    }
    }
    if (lldpXMedRemXPoeDeviceTypeGet(intIfNum, remIndex, timestamp, &intData) == L7_SUCCESS)
    {
    printf("MED Ext Power TLV Device type: %d\n", intData);
    if (lldpXMedRemXPoePSEPowerSrcGet(intIfNum, remIndex, timestamp, &intData) == L7_SUCCESS)
    {
      printf("MED PSE TLV Source: %d\n", intData);
    }
    else
    {
      printf("MED PSE TLV Source not present\n");
    }
    if (lldpXMedRemXPoePSEPowerPriGet(intIfNum, remIndex, timestamp, &intData) == L7_SUCCESS)
    {
      printf("MED PSE TLV Priority: %d\n", intData);
    }
    else
    {
      printf("MED PSE TLV Priority not present\n");
    }
    if (lldpXMedRemXPoePSEPowerAvGet(intIfNum, remIndex, timestamp, &intData) == L7_SUCCESS)
    {
      printf("MED PSE TLV Average: %d\n", intData);
    }
    else
    {
      printf("MED PSE TLV Average not present\n");
    }
    if (lldpXMedRemXPoePDPowerSrcGet(intIfNum, remIndex, timestamp, &intData) == L7_SUCCESS)
    {
          printf("MED PD TLV Source: %d\n", intData);
    }
    else
    {
      printf("MED PD TLV Source not present\n");
    }
    if (lldpXMedRemXPoePDPowerPriGet(intIfNum, remIndex, timestamp, &intData) == L7_SUCCESS)
    {
          printf("MED PD TLV Priority: %d\n", intData);
    }
    else
    {
      printf("MED PD TLV Priority not present\n");
    }
    if (lldpXMedRemXPoePDPowerReqGet(intIfNum, remIndex, timestamp, &intData) == L7_SUCCESS)
    {
          printf("MED PD TLV Req: %d\n", intData);
    }
    else
    {
      printf("MED PD TLV Req not present\n");
    }
    }
    else
    {
    printf("MED Ext Power TLV not present\n");
    }
    bzero(data,  512);
    if (lldpXMedRemHardwareRevGet(intIfNum, remIndex, timestamp, data) == L7_SUCCESS)
    {
    printf("MED Inventory TLV HW: %s\n", data);
    }
    bzero(data,  512);
    if (lldpXMedRemFirmwareRevGet(intIfNum, remIndex, timestamp, data) == L7_SUCCESS)
    {
    printf("MED Inventory TLV FW: %s\n", data);
    }
    bzero(data,  512);
    if (lldpXMedRemSoftwareRevGet(intIfNum, remIndex, timestamp, data) == L7_SUCCESS)
    {
    printf("MED Inventory TLV SW: %s\n", data);
    }
    bzero(data,  512);
    if (lldpXMedRemSerialNumGet(intIfNum, remIndex, timestamp, data) == L7_SUCCESS)
    {
    printf("MED Inventory TLV SNO: %s\n", data);
    }
    bzero(data,  512);
    if (lldpXMedRemMfgNameGet(intIfNum, remIndex, timestamp, data) == L7_SUCCESS)
    {
    printf("MED Inventory TLV Mfg Name: %s\n", data);
    }
    bzero(data,  512);
    if (lldpXMedRemModelNameGet(intIfNum, remIndex, timestamp, data) == L7_SUCCESS)
    {
    printf("MED Inventory TLV Model Name: %s\n", data);
    }
      bzero(data,  512);
      if (lldpXMedRemAssetIdGet(intIfNum, remIndex, timestamp, data) == L7_SUCCESS)
    {
    printf("MED Inventory TLV Asset ID: %s\n", data);
    }
      printf("-------------------------------------------------\n\n");
    }
  }
  printf("\n");

  printf("\n=====================\n");

  return;
}
