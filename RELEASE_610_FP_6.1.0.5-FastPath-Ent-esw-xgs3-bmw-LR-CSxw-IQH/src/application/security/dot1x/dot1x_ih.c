/*********************************************************************
*
* (C) Copyright Broadcom Corporation 2003-2007
*
**********************************************************************
* @filename  dot1x_ih.c
*
* @purpose   dot1x Interface Handler
*
* @component dot1x
*
* @comments  none
*
* @create    04/08/2003
*
* @author    mfiorito
*
* @end
*
**********************************************************************/

#include "dot1x_include.h"
#include "dot1q_api.h"
#include "fdb_api.h"
#include "tlv_api.h"
#include "l7_diffserv_api.h"
#include "dtlapi.h"
#include "dot1ad_l2tp_api.h"
#include "voice_vlan_api.h"   /* ddf */
#include "trapapi.h"

extern dot1xCnfgrState_t dot1xCnfgrState;
extern L7_tlvHandle_t    dot1xTlvHandle;
extern L7_RC_t dtlLedBlinkSet(L7_BOOL enable);

/*********************************************************************
* @purpose  Handles events generated by NIM
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    intfEvent  @b{(input)) interface event
* @param    correlator @b{(input)) Correlator for the event
*
* @returns  L7_SUCCESS  on a successful operation
* @returns  L7_FAILURE  for any error
*
* @comments
*
* @end
*********************************************************************/
L7_RC_t dot1xIntfChangeCallback(L7_uint32 intIfNum, L7_uint32 intfEvent, NIM_CORRELATOR_t correlator)
{
  dot1xIntfChangeParms_t parms;
  NIM_EVENT_COMPLETE_INFO_t status;

  if (intfEvent != L7_UP &&
      intfEvent != L7_PORT_ENABLE &&
      intfEvent != L7_LAG_RELEASE &&
      intfEvent != L7_PROBE_TEARDOWN &&
      intfEvent != L7_DOWN &&
      intfEvent != L7_PORT_DISABLE &&
      intfEvent != L7_LAG_ACQUIRE &&
      intfEvent != L7_PROBE_SETUP &&
      intfEvent != L7_CREATE &&
      intfEvent != L7_ATTACH &&
      intfEvent != L7_DETACH &&
      intfEvent != L7_DELETE &&
      intfEvent != L7_DOT1X_ACQUIRE)
  {
    status.intIfNum     = intIfNum;
    status.component    = L7_DOT1X_COMPONENT_ID;
    status.event        = intfEvent;
    status.correlator   = correlator;
    status.response.rc = L7_SUCCESS;
    nimEventStatusCallback(status);
    return L7_SUCCESS;
  }
  parms.intfEvent = intfEvent;
  parms.nimCorrelator = correlator;

  return dot1xIssueCmd(dot1xIntfChange, intIfNum, &parms);
}

/*********************************************************************
* @purpose  Process Link state changes
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    intIfEvent @b{(input)) interface event
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhProcessIntfChange(L7_uint32 intIfNum, L7_uint32 intfEvent, NIM_CORRELATOR_t correlator)
{
  L7_uint32 linkState, adminState;
  L7_RC_t rc = L7_SUCCESS;
  L7_uint32 currAcquired, prevAcquired,lagAcquired;
  NIM_EVENT_COMPLETE_INFO_t status;
  NIM_INTF_MASK_t intfMask;
  dot1xPortCfg_t *pCfg;
  L7_uint32       lIntIfNum;
#if defined L7_DOT1AD_PACKAGE
  L7_uint32       nniIntf;
  L7_uchar8            suppStatus=0x00;
#endif
  dot1xLogicalPortInfo_t *logicalPortInfo;

  status.intIfNum     = intIfNum;
  status.component    = L7_DOT1X_COMPONENT_ID;
  status.event        = intfEvent;
  status.correlator   = correlator;

  if (!(DOT1X_IS_READY))
  {
    LOG_MSG("dot1xIntfChangeCallback: Received an interface change callback while not ready to receive it");
    rc = L7_FAILURE;
    status.response.rc = rc;
    nimEventStatusCallback(status);
    return rc;
  }

  if ((intfEvent != L7_CREATE) && (intfEvent != L7_DELETE) && (intfEvent != L7_ATTACH))
  {
    /* Ensure dot1x is globally enabled */
    if (dot1xCfg->dot1xAdminMode != L7_ENABLE)
    {
      rc = L7_SUCCESS;
      status.response.rc = rc;
      nimEventStatusCallback(status);
      return rc;
    }
  }

  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
  {
    rc = L7_SUCCESS;
    status.response.rc = rc;
    nimEventStatusCallback(status);
    return rc;
  }

  DOT1X_EVENT_TRACE(DOT1X_TRACE_EVENTS,intIfNum,"%s:%d Nim Event %d recieved for %d \n",
                    __FUNCTION__,__LINE__,intfEvent,intIfNum);

  switch (intfEvent)
  {
  case L7_UP:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {
      if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
      {
        #if defined L7_DOT1AD_PACKAGE
        if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                                 L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
        {
          if (dot1adNniInterfaceGet (&nniIntf)!= L7_SUCCESS)
          {
          break;
        }
        if (dot1xSupplicantPortSpmStatusGet (nniIntf,&suppStatus) == L7_SUCCESS)
        {
          if (suppStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
          {
            if (intIfNum != nniIntf)
            {
              break;
            }
          }

        }
        }
       #endif
        if (dot1xPortInfo[intIfNum].portEnabled == L7_FALSE)
        {
           if ( (nimGetIntfAdminState(intIfNum, &adminState) == L7_SUCCESS) &&
             (adminState == L7_ENABLE) )
            {
               dot1xPortInfo[intIfNum].portEnabled = L7_TRUE;
               (void) dot1xPortReset(intIfNum);
               (void) dot1xCtlApplyPortConfigData(intIfNum);
            }
         }
       }
       else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
       {
         /* reApply Supplicant configurations */
         if (dot1xSupplicantPortInfo[intIfNum].portEnabled == L7_FALSE)
         {
           if ( (nimGetIntfAdminState(intIfNum, &adminState) == L7_SUCCESS) &&
             (adminState == L7_ENABLE) )
            {
               dot1xSupplicantPortInfo[intIfNum].portEnabled = L7_TRUE;
               (void) dot1xSupplicantPortReset(intIfNum);
               (void) dot1xCtlApplySupplicantPortConfigData(intIfNum);
            }
         }
       }
    }
    break;

  case L7_PORT_ENABLE:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {

      if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
      {
        #if defined L7_DOT1AD_PACKAGE
        if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                                  L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
        {
          if (dot1adNniInterfaceGet (&nniIntf)!= L7_SUCCESS)
          {
          break;
        }
        if (dot1xSupplicantPortSpmStatusGet (nniIntf,&suppStatus) == L7_SUCCESS)
        {
          if (suppStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
          {
            if (intIfNum != nniIntf)
            break;
          }
         }
        }
       #endif

        if (dot1xPortInfo[intIfNum].portEnabled == L7_FALSE)
        {
           if ( (nimGetIntfAdminState(intIfNum, &adminState) == L7_SUCCESS) &&
             (adminState == L7_ENABLE) )
            {
               dot1xPortInfo[intIfNum].portEnabled = L7_TRUE;
               (void) dot1xPortReset(intIfNum);
               (void) dot1xCtlApplyPortConfigData(intIfNum);
            }
         }
       }
       else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
       {
         /* reApply Supplicant configurations */
         if (dot1xSupplicantPortInfo[intIfNum].portEnabled == L7_FALSE)
         {
           if ( (nimGetIntfAdminState(intIfNum, &adminState) == L7_SUCCESS) &&
             (adminState == L7_ENABLE) )
            {
               dot1xSupplicantPortInfo[intIfNum].portEnabled = L7_TRUE;
               (void) dot1xSupplicantPortReset(intIfNum);
               (void) dot1xCtlApplySupplicantPortConfigData(intIfNum);
            }
         }
       }
    }
    break;

  case L7_LAG_RELEASE:
  case L7_PROBE_TEARDOWN:

     /* Lag component sends a L7_LAG_RELEASE event before a L7_LAG_ACQUIRE as part of the port accquisition process
        It also sends a L7_LAG_RELEASE event when a port is released from a lag. Check that the port has been acctually accquired
        by the Lag before processing the L7_LAG_RELEASE event*/
    lagAcquired=L7_FALSE;
    if (intfEvent == L7_LAG_RELEASE)
    {
        if (COMPONENT_ACQ_ISMASKBITSET(dot1xPortInfo[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID)!=0)
        {
            lagAcquired = L7_TRUE;
        }
    }
    /* update aquired list */
    if ((intfEvent == L7_LAG_RELEASE) && (lagAcquired ==L7_TRUE))
      COMPONENT_ACQ_CLRMASKBIT(dot1xPortInfo[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID);
    else if (intfEvent == L7_PROBE_TEARDOWN)
      COMPONENT_ACQ_CLRMASKBIT(dot1xPortInfo[intIfNum].acquiredList, L7_PORT_MIRROR_COMPONENT_ID);


    /* check if currently acquired */
    COMPONENT_ACQ_NONZEROMASK(dot1xPortInfo[intIfNum].acquiredList, currAcquired);

    /* If the interface is not currently acquired by some component, cause
     * the acquisition to be reflected in the state of the spanning tree
     */

    if (((intfEvent == L7_LAG_RELEASE)&&(lagAcquired == L7_TRUE)&&(currAcquired == L7_FALSE))||
        ((intfEvent == L7_PROBE_TEARDOWN)&&(currAcquired == L7_FALSE)))
    {
    if(nimGetIntfLinkState(intIfNum, &linkState) == L7_SUCCESS)
    {
      if ( (nimGetIntfAdminState(intIfNum, &adminState) == L7_SUCCESS) &&
         (adminState == L7_ENABLE) &&
         (nimGetIntfLinkState(intIfNum, &linkState) == L7_SUCCESS) &&
         (linkState == L7_UP) )
      {
        dot1xPortInfo[intIfNum].portEnabled = L7_TRUE;
        (void) dot1xPortReset(intIfNum);
        (void) dot1xCtlApplyPortConfigData(intIfNum);
      }
    }
    }
    break;

  case L7_DOWN:
  case L7_PORT_DISABLE:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {

      if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
      {
        dot1xPortInfo[intIfNum].portEnabled = L7_FALSE;
        lIntIfNum = DOT1X_LOGICAL_PORT_ITERATE;
        while((logicalPortInfo=dot1xLogicalPortInfoGetNextNode(intIfNum,&lIntIfNum))!= L7_NULLPTR)
        {
           if(logicalPortInfo->inUse != L7_TRUE)
           continue;

          (void) dot1xStateMachineClassifier(apmNotPortEnabled, lIntIfNum, L7_NULL, L7_NULLPTR);
          (void) dot1xStateMachineClassifier(krxNotPortEnabled, lIntIfNum, L7_NULL, L7_NULLPTR);

          if (intfEvent == L7_DOWN)
          {
            if (dot1xRadiusAccountingStop(lIntIfNum, RADIUS_ACCT_TERM_CAUSE_LOST_CARRIER) != L7_SUCCESS)
             LOG_MSG("dot1xIhProcessIntfChange L7_DOWN: failed sending terminate cause, intf %u\n", intIfNum);

          }
          else
          {
            if (intfEvent == L7_PORT_DISABLE)
            {
              if (dot1xRadiusAccountingStop(lIntIfNum, RADIUS_ACCT_TERM_CAUSE_PORT_ADMINISTRATIVELY_DISABLED) != L7_SUCCESS)
               LOG_MSG("dot1xIhProcessIntfChange L7_DISABLE: failed sending terminate cause, intf %u\n", intIfNum);

            }
          }
       }

      /* check if the port is vlan assigned */
      dot1xPortVlanAssignmentDisable(intIfNum);
      /*if(pCfg->guestVlanId !=0)
      {
        dot1xCtlPortGuestVlanRemove(intIfNum,pCfg->guestVlanId);
      }*/

      /* reset operational info on the port*/
      (void)dot1xPortInfoInitialize(intIfNum,L7_TRUE);
      (void)dot1xCtlApplyPortConfigData(intIfNum);
    }
    else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
    {
        dot1xSupplicantPortInfo[intIfNum].portEnabled = L7_FALSE;
        (void)dot1xCtlApplySupplicantPortConfigData(intIfNum);
    }
  }
  break;

  case L7_LAG_ACQUIRE:
  case L7_PROBE_SETUP:
    /* check if previously acquired */
    COMPONENT_ACQ_NONZEROMASK(dot1xPortInfo[intIfNum].acquiredList, prevAcquired);

    /* update aquired list */
    if (intfEvent == L7_LAG_ACQUIRE)
      COMPONENT_ACQ_SETMASKBIT(dot1xPortInfo[intIfNum].acquiredList, L7_DOT3AD_COMPONENT_ID);
    else
      COMPONENT_ACQ_SETMASKBIT(dot1xPortInfo[intIfNum].acquiredList, L7_PORT_MIRROR_COMPONENT_ID);

    /* If the interface was not previously acquired by some component, cause
     * the acquisition to be reflected in the state of the spanning tree
     */
    if (prevAcquired == L7_FALSE)
    {
      if (dot1xPortInfo[intIfNum].portControlMode != L7_DOT1X_PORT_FORCE_AUTHORIZED)
      {
         /* reset all the clients associated with the port if port control mode is Macbased */
          if (dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
          {
              /* remove clients from any associated vlans*/
              dot1xPortVlanAssignmentDisable(intIfNum);
              /* reset all the clients associated with the port */
              (void) dot1xPortReset(intIfNum);
              (void) dot1xCtlApplyPortConfigData(intIfNum);
        }
        else
        {
            dot1xPortVlanAssignmentDisable(intIfNum);
            lIntIfNum = DOT1X_LOGICAL_PORT_ITERATE;
            while((logicalPortInfo=dot1xLogicalPortInfoGetNextNode(intIfNum,&lIntIfNum))!= L7_NULLPTR)
            {
              if(logicalPortInfo->inUse == L7_TRUE)
                (void)dot1xStateMachineClassifier(apmPortControlEqualForceAuthorized, lIntIfNum,
                                                  L7_NULL, L7_NULLPTR);
            }
            /*dot1xPortVlanAssignmentDisable(intIfNum);*/
        }

      }

      /*dot1xPortVlanAssignmentDisable(intIfNum);*/
     /* if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
      {
        if(pCfg->guestVlanId !=0)
        {
          dot1xCtlPortGuestVlanRemove(intIfNum,pCfg->guestVlanId);
        }
      }*/

    }
    break;

  case L7_CREATE:
    rc = dot1xIntfCreate(intIfNum);
    break;

  case L7_ATTACH:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {
      if (pCfg->paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
      {
        (void) dot1xPortReset(intIfNum);
         rc = dot1xCtlApplyPortConfigData(intIfNum);
      }
      else if (pCfg->paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
      {
        dot1xPortInfo[intIfNum].paeCapabilities = L7_DOT1X_PAE_PORT_SUPP_CAPABLE;
        if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
        {
          dot1xSupplicantPortInfoInitialize(intIfNum, L7_TRUE);
          dot1xCtlApplySupplicantPortConfigData(intIfNum);
        }
        else
        {
           /* If dot1x admin mode is disabled, set port to authorized */
           rc = dot1xIhPhyPortStatusSet (intIfNum, L7_DOT1X_PORT_STATUS_AUTHORIZED,L7_TRUE);
        }
      }
    }
    else
    {
      rc = L7_FAILURE;
    }
    break;

  case L7_DETACH:
    rc = dot1xIntfDetach(intIfNum);
    break;

  case L7_DELETE:
    rc = dot1xIntfDelete(intIfNum);
    break;

  case L7_DOT1X_ACQUIRE:
    if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
    {
      if(dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO)
      {
        logicalPortInfo = dot1xPhysicalPortInfoNodeGet(intIfNum);
          if ((logicalPortInfo->vlanAssigned != 0) || (logicalPortInfo->guestVlanId!= 0) || (logicalPortInfo->unauthVlan)!=0)
        {
          /* process for guest vlan */
          /*if(pCfg->guestVlanId !=0)*/
          memset(&intfMask, 0, sizeof(intfMask));
          L7_INTF_SETMASKBIT(intfMask,intIfNum);
          dot1qSwitchPortModeSet(&intfMask, DOT1Q_SWPORT_MODE_GENERAL, 
                                 DOT1Q_DOT1X); 
          if (logicalPortInfo->guestVlanId!=0)
          {
              dot1xPortVlanMembershipSet(intIfNum,logicalPortInfo->guestVlanId,L7_TRUE);
          }
          else
          {
              if (logicalPortInfo->vlanAssigned != 0) {
                  dot1xPortVlanMembershipSet(intIfNum,logicalPortInfo->vlanAssigned,L7_TRUE);
              }
              else if (logicalPortInfo->unauthVlan!=0) {
                   dot1xPortVlanMembershipSet(intIfNum,logicalPortInfo->unauthVlan,L7_TRUE);
              }
          }
         }
      }
    }
    break;
  default:
    break;
  }

  status.response.rc = rc;
  nimEventStatusCallback(status);

  return rc;
}

/*********************************************************************
* @purpose  Make sure this is a valid interface for dot1x
*
* @param    intIfNum   @b{(input)) internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhIntfValidate(L7_uint32 intIfNum)
{
  /* Check for valid interface number */
  if (nimCheckIfNumber(intIfNum) != L7_SUCCESS)
    return L7_FAILURE;

  /* Check for physical interface interface */
  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
      return L7_FAILURE;

  return L7_SUCCESS;
}
#if 0
/*********************************************************************
*
* @purpose  Adds a dynamically locked entry to an interface.
*
* @param    lIntIfNum  @b((input)) Logical interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
static
L7_RC_t dot1xFdbDynamicEntryAdd(L7_uint32 lIntIfNum)
{
  L7_uint32          physPort;
  L7_uchar8          key[L7_FDB_KEY_SIZE];
  dot1dTpFdbData_t   fdbEntry;
  L7_RC_t            rc;
  L7_ushort16        vlanId;
  fdbMeberInfo_t     fdbMember;

  if (dot1xLogicalPortInfo[lIntIfNum].inUse != L7_TRUE)
  {
    DOT1X_ERROR_SEVERE("Failed dot1xFdbDynamicEntryAdd on logical port %d",
                       lIntIfNum);
    return L7_FAILURE;
  }

  physPort = dot1xPhysPortGet(lIntIfNum);

  /* search the FDB to determine if this MAC already exists.
     If it exists as a static entry, return failure. If it
     exists as a dynamic entry, convert it to static */
  vlanId = (L7_ushort16)dot1xLogicalPortInfo[lIntIfNum].vlanId;
  memcpy(&key[0], &vlanId, sizeof(L7_ushort16));
  memcpy(&key[2], &dot1xLogicalPortInfo[lIntIfNum].suppMacAddr.addr, L7_ENET_MAC_ADDR_LEN);

  rc = fdbFind(key, L7_MATCH_EXACT, &fdbEntry);

  if (rc == L7_SUCCESS)
  {
    if (fdbEntry.dot1dTpFdbEntryType != L7_FDB_ADDR_FLAG_LEARNED ||
        fdbEntry.dot1dTpFdbPort != physPort)
      return L7_FAILURE;
    else
      return L7_SUCCESS;
  }

  /* tell FDB component about this address */
  memset(&fdbMember,0,sizeof(fdbMeberInfo_t));
  memcpy(fdbMember.macAddr,dot1xLogicalPortInfo[lIntIfNum].suppMacAddr.addr,L7_MAC_ADDR_LEN);
  fdbMember.vlanId = vlanId;
  fdbMember.intIfNum = physPort;
  fdbMember.entryType =  L7_FDB_ADDR_FLAG_LEARNED;

  fdbAddEntry(&fdbMember);
  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  Removes a dynamically locked entry to an interface.
*
* @param    lIntIfNum  @b((input)) Logical interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @notes    none
*
* @end
*********************************************************************/
static
L7_RC_t dot1xFdbDynamicEntryDelete(L7_uint32 lIntIfNum)
{
  fdbMeberInfo_t     fdbMember;

  memset(&fdbMember,0,sizeof(fdbMeberInfo_t));
  memcpy(fdbMember.macAddr,dot1xLogicalPortInfo[lIntIfNum].suppMacAddr.addr,L7_MAC_ADDR_LEN);
  fdbMember.vlanId = dot1xLogicalPortInfo[lIntIfNum].vlanId;
  fdbMember.intIfNum = dot1xPhysPortGet(lIntIfNum);
  fdbMember.entryType =  L7_FDB_ADDR_FLAG_LEARNED;

  fdbDelEntry(&fdbMember);
  return L7_SUCCESS;;
}
#endif

/*********************************************************************
* @purpose  Set the dot1x port authorization status
*
* @param    lIntIfNum   @b{(input)) internal interface number
* @param    portStatus @b{(input)) port authorization status setting
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
* @returns  L7_ERROR
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhPortStatusSet(L7_uint32 lIntIfNum, L7_DOT1X_PORT_STATUS_t portStatus)
{
  L7_uint32 physPort;
  dot1xLogicalPortInfo_t *logicalPortInfo;
  L7_BOOL client_oper = L7_FALSE;

  logicalPortInfo = dot1xLogicalPortInfoGet(lIntIfNum);
  if(logicalPortInfo == L7_NULLPTR)
  {
    return L7_FAILURE;
  }
  physPort = logicalPortInfo->physPort;

  DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:Setting the Logical port-%d to %s\n",
                    __FUNCTION__,lIntIfNum,
                    (portStatus==L7_DOT1X_PORT_STATUS_AUTHORIZED)?"Authorize":"Unauhtorize");

  /* Verify port status parm value */
  if (portStatus != L7_DOT1X_PORT_STATUS_AUTHORIZED && portStatus != L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
    return L7_FAILURE;

  if (dot1xPortInfo[physPort].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
  {
    /*If setting to the same value, just return success */
    if (portStatus == logicalPortInfo->logicalPortStatus)
    {
      DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d Status already set \n", __FUNCTION__, __LINE__);
      /* if ((portStatus != L7_DOT1X_PORT_STATUS_AUTHORIZED) ||
         ((logicalPortInfo->reAuthenticating != L7_TRUE) && (logicalPortInfo->reauth_auth_apply != L7_TRUE)) ||
         (logicalPortInfo->suppRestarting != L7_TRUE))
         {*/
      return L7_SUCCESS;
      /* } */

    }

    if(dot1xPortInfo[physPort].portControlMode != L7_DOT1X_PORT_AUTO_MAC_BASED)
    {
      if (logicalPortInfo->inUse == L7_TRUE)
      {
        logicalPortInfo->logicalPortStatus = portStatus;
      }
      else
      {
        DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:FAILED to set . Port status is the same as before.\n", __FUNCTION__, __LINE__);
        return L7_SUCCESS;
      }

    }
    else
    {
      client_oper = L7_FALSE;
      if (logicalPortInfo->inUse == L7_TRUE)
      {
        if (portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
        {
          L7_ushort16   vlanId;
#ifdef L7_QOS_FLEX_PACKAGE_DIFFSERV
          L7_uint32     tlvLen = 0;
          L7_uint32     policyIndex;
          L7_uchar8     tempName[DOT1X_FILTER_NAME_LEN];
#endif
          L7_tlv_t      *pTlv = L7_NULL;

          /* Add the entry in the driver */
          if(logicalPortInfo->vlanAssigned != 0)
          {
            vlanId = logicalPortInfo->vlanAssigned;
          }
          else if (logicalPortInfo->unauthVlan != 0)
          {
            vlanId = logicalPortInfo->unauthVlan;
          }
          else if(logicalPortInfo->guestVlanId != 0)
          {
            vlanId = logicalPortInfo->guestVlanId;
          }
          else if(logicalPortInfo->voiceVlanId != 0)
          {
            vlanId = logicalPortInfo->voiceVlanId;
          }
          else
          {
            L7_uint32 pvid;
            /* Check if the dot1q pvid is same as one this client has */
            if (dot1qQportsVIDGet(physPort, L7_DOT1Q_DEFAULT_VID_INDEX, &pvid) == L7_SUCCESS)
            {
              vlanId = pvid;
              logicalPortInfo->vlanId = pvid;
            }
            else
            {
              vlanId = logicalPortInfo->vlanId;
            }
          }

          /* Check for QoS package presence*/
#ifdef L7_QOS_FLEX_PACKAGE_DIFFSERV
          if (cnfgrIsFeaturePresent(L7_FLEX_QOS_DIFFSERV_COMPONENT_ID,L7_DIFFSERV_FEATURE_SUPPORTED)==L7_TRUE)
          {
            pTlv = L7_NULL;
            memset(tempName,0,DOT1X_FILTER_NAME_LEN);
            if(memcmp(logicalPortInfo->filterName,tempName,sizeof(tempName))!=0)
            {
              if(diffServPolicyNameToIndex(logicalPortInfo->filterName,
                                           &policyIndex) == L7_SUCCESS)
              {
                if(diffServPolicyTlvGet(policyIndex,physPort,
                                        L7_USMDB_MIB_DIFFSERV_IF_DIRECTION_IN,
                                        dot1xTlvHandle) == L7_SUCCESS)
                {
                  tlvQuery(dot1xTlvHandle,&pTlv,&tlvLen);
                }
              }
            }
          }
#else
          pTlv=L7_NULL;
#endif
          if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
          {
            DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:adding the client %02x:%02x:%02x:%02x:%02x:%02x, vlan= %d to port %d \n",
                              __FUNCTION__,__LINE__,
                              logicalPortInfo->suppMacAddr.addr[0],
                              logicalPortInfo->suppMacAddr.addr[1],
                              logicalPortInfo->suppMacAddr.addr[2],
                              logicalPortInfo->suppMacAddr.addr[3],
                              logicalPortInfo->suppMacAddr.addr[4],
                              logicalPortInfo->suppMacAddr.addr[5],
                              vlanId,
                              physPort);
            if(dtlDot1xIntfClientAdd(physPort,
                                     logicalPortInfo->suppMacAddr,
                                     vlanId,pTlv) != L7_SUCCESS)
            {
              L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
                      "%s: Error in adding the client details to the driver."
                      " Could not add client (logical port) details to the hardware."
                      ,__FUNCTION__);
              DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,lIntIfNum,"\n%s:%d Error in adding the client details to the driver \n", __FUNCTION__, __LINE__);
              client_oper = L7_FALSE;
            }
            else
            {
              client_oper = L7_TRUE;
            }
          }
          else
          {
            client_oper = L7_TRUE;
          }
          /* free the tlv handle */
          if(pTlv != L7_NULL)
          {
            tlvDelete(dot1xTlvHandle);
          }

        }
        else if (portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED &&
                 logicalPortInfo->logicalPortStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
        {
          dot1xPortCfg_t          *pCfg;

          if (dot1xIntfIsConfigurable(physPort, &pCfg) == L7_TRUE)

          {

            if(pCfg->portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
            {
              if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
              {
                DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:removing the client %d, Mac Addr:%02x:%02x:%02x:%02x:%02x:%02x from port %d \n",
                                  __FUNCTION__,__LINE__,
                                  logicalPortInfo->logicalPortNumber ,
                                  logicalPortInfo->suppMacAddr.addr[0],
                                  logicalPortInfo->suppMacAddr.addr[1],
                                  logicalPortInfo->suppMacAddr.addr[2],
                                  logicalPortInfo->suppMacAddr.addr[3],
                                  logicalPortInfo->suppMacAddr.addr[4],
                                  logicalPortInfo->suppMacAddr.addr[5],
                                  physPort);
                if(dtlDot1xIntfClientRemove(physPort,logicalPortInfo->suppMacAddr) != L7_SUCCESS)
                {
                  L7_LOGF(L7_LOG_SEVERITY_NOTICE, L7_DOT1X_COMPONENT_ID,
                          "%s: Error in removing the client details from the driver."
                          " Could not remove client details from the driver",__FUNCTION__);
                  DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,lIntIfNum,"\n%s:%d Error in removing the client details from the driver\n", __FUNCTION__, __LINE__);
                  client_oper = L7_FALSE;
                }
                else
                  client_oper = L7_TRUE;

              }

            }/*mac based*/
          }
        }

        /* Save new state */
        logicalPortInfo->logicalPortStatus = portStatus;
      }
      else
      {
        DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,physPort,"%s:%d:FAILED to set \n", __FUNCTION__, __LINE__);
        return L7_SUCCESS;
      }
    }

    if(portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
    {
      if (dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
      {
        if (client_oper == L7_TRUE)
        {
          if(dot1xPortInfo[physPort].authCount!=0)
          {
            dot1xPortInfo[physPort].authCount--;
            DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS, lIntIfNum,
                              "%s:%d:Decreased authcount (%d) for physical port:%d because of removal of client:%d  \n",
                              __FUNCTION__, __LINE__, dot1xPortInfo[physPort].authCount,physPort, lIntIfNum);
          }
        }
      }
      else
      {
        if(dot1xPortInfo[physPort].authCount!=0)
          dot1xPortInfo[physPort].authCount--;

      }
    }
    else
    {
      if (dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
      {
        if(client_oper == L7_TRUE)
        {
          if(dot1xPortInfo[physPort].authCount!=DOT1X_MAX_USERS_PER_PORT)
            dot1xPortInfo[physPort].authCount++;
          DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,lIntIfNum,"%s:%d:Increased authcount (%d) for physical port:%d because of adding of client:%d  \n",
                            __FUNCTION__,__LINE__,dot1xPortInfo[physPort].authCount,physPort,lIntIfNum);
        }
      }
      else
      {
        if(dot1xPortInfo[physPort].authCount!=DOT1X_MAX_USERS_PER_PORT)
          dot1xPortInfo[physPort].authCount++;
        DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,lIntIfNum,"%s:%d:Increased authcount (%d) for physical port:%d  \n",
                          __FUNCTION__,__LINE__,dot1xPortInfo[physPort].authCount,physPort);
      }
    }

    /* Generate NIM event and set the driver state */
    if(dot1xPortInfo[physPort].authCount == 1
       && portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
    {
      if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
      {
        trapMgrDot1xPortStatusAuthorizedLogTrap(physPort);
      }

      DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS, lIntIfNum,
                        "%s:%d:Setting physical port:%d to Authorized as authcount = %d \n",
                        __FUNCTION__, __LINE__, physPort, dot1xPortInfo[physPort].authCount);
      dot1xPortInfo[physPort].portStatus =  L7_DOT1X_PORT_STATUS_AUTHORIZED;

      /* During a reauthentication or supplicant restarting, a port remains in
         authorized state. If the reauthentication is successful, but some of the
         client associated parameters viz vlan assigned of filter Id assigned
         have changed, then this change needs to be propgated to the hardware.
         In order to do this, this function is called to set the port to
         unauthorized and then back to authorized. In the process the old
         information for the client is removed and the new one is added.Since
         ultimately the port remains authorized, we want to avoid the costly
         operation of NIM notify for the port. Hence in case of reauthentication
         or supplicant restart with changed parameters for the client we avoid
         NIM Notify. */
      if ((dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED) &&
          ((logicalPortInfo->reAuthenticating == L7_TRUE) || (logicalPortInfo->suppRestarting == L7_TRUE)) &&
          (logicalPortInfo->reauth_auth_apply == L7_TRUE))
      {
        dot1xIhPhyPortStatusSet(physPort,portStatus,L7_FALSE);
      }
      else
      {
        dot1xIhPhyPortStatusSet(physPort,portStatus,L7_TRUE);
      }
    }
    else if(dot1xPortInfo[physPort].authCount == 0 &&
            portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
    {
      if (dot1xCfg->dot1xAdminMode == L7_ENABLE)
      {
        trapMgrDot1xPortStatusUnauthorizedLogTrap(physPort);
      }

      DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS, lIntIfNum,
                        "%s:%d:Setting physical port:%d to Unauthorized as authcount = %d \n",
                        __FUNCTION__, __LINE__, physPort, dot1xPortInfo[physPort].authCount);
      dot1xPortInfo[physPort].portStatus = L7_DOT1X_PORT_STATUS_UNAUTHORIZED;
      if ((dot1xPortInfo[physPort].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED) &&
          ((logicalPortInfo->reAuthenticating == L7_TRUE) || (logicalPortInfo->suppRestarting == L7_TRUE)) &&
          (logicalPortInfo->reauth_auth_apply == L7_TRUE))
      {
        dot1xIhPhyPortStatusSet(physPort,portStatus,L7_FALSE);
      }
      else
      {
        dot1xIhPhyPortStatusSet(physPort,portStatus,L7_TRUE);
      }
    }
  }
  return L7_SUCCESS;
}


/*********************************************************************
* @purpose  Set the dot1x port authorization status
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    portStatus @b{(input)) port authorization status setting
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
* @returns  L7_ERROR
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhPhyPortStatusSet(L7_uint32 intIfNum, L7_DOT1X_PORT_STATUS_t portStatus,L7_BOOL bNotifyNim)
{
  NIM_HANDLE_t           handle;
  NIM_EVENT_NOTIFY_INFO_t eventInfo;
  dot1xPortCfg_t          *pCfg;
  L7_BOOL                 flag=L7_FALSE;

  /* Set the port status in the driver */
  if (dot1xIntfIsConfigurable(intIfNum, &pCfg)== L7_FALSE)
      return L7_FAILURE;

  if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
  {

  if(dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED)
  {
    /* Need to get the violation packets to CPU in mac-based mode */
    flag = L7_TRUE;
  }

  if(!(dot1xPortInfo[intIfNum].portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED &&
      dot1xCfg->dot1xAdminMode == L7_ENABLE && pCfg->portControlMode == L7_DOT1X_PORT_AUTO_MAC_BASED))
    {
       if (dtlDot1xIntfStatusSet(intIfNum, portStatus, flag) != L7_SUCCESS)
       {
         return L7_FAILURE;
       }
         DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,intIfNum,"%s:Setting the port-%d to %s\n",
                      __FUNCTION__,intIfNum,
                  (portStatus==L7_DOT1X_PORT_STATUS_AUTHORIZED)?"Authorize":"Unauhtorize");
    }
  }
  else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
  {

    {
       if (dtlDot1xIntfStatusSet(intIfNum, portStatus, flag) != L7_SUCCESS)
       {
         printf ("\r\n problem in setting the dtlDot1xIntfStatusSet\r\n");
         return L7_FAILURE;
       }
         DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,intIfNum,"%s:Setting the port-%d to %s\n",
                      __FUNCTION__,intIfNum,
                  (portStatus==L7_DOT1X_PORT_STATUS_AUTHORIZED)?"Authorize":"Unauhtorize");
      #if defined L7_DOT1AD_PACKAGE
      if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                              L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
      {
   {
      DOT1AD_INTFERFACE_TYPE_t  intfType;
      dot1adInterfaceTypeGet(intIfNum, &intfType);
      if(intfType == DOT1AD_INTFERFACE_TYPE_NNI)
      {
        if (portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
        {
          dtlLedBlinkSet(L7_FALSE);
        }
        else
        {
          dtlLedBlinkSet(L7_TRUE);
        }
      }
   }
     }
#endif
    }
  }

  if (bNotifyNim == L7_TRUE)
  {
      /* Notify NIM of the port status as NIM is port specific */
      if(portStatus == L7_DOT1X_PORT_STATUS_UNAUTHORIZED)
      {
        eventInfo.event = L7_DOT1X_PORT_UNAUTHORIZED;
      }
      else if(portStatus == L7_DOT1X_PORT_STATUS_AUTHORIZED)
      {
        eventInfo.event = L7_DOT1X_PORT_AUTHORIZED;
      }
      else
      {
        return L7_FAILURE;
      }
      eventInfo.component     = L7_DOT1X_COMPONENT_ID;
      eventInfo.pCbFunc       = L7_NULLPTR;
      eventInfo.intIfNum      = intIfNum;

      if(nimEventIntfNotify(eventInfo,&handle) != L7_SUCCESS)
      {
        return L7_FAILURE;
      }
  }




  return L7_SUCCESS;
}

/*********************************************************************
* @purpose  Obtain a pointer to the specified interface configuration data
*           for this interface
*
* @param    intIfNum @b{(input)} Internal Interface Number
* @param    **pCfg   @b{(output)}  Ptr  to dot1x port config structure
*                           or L7_NULL if not needed
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
*
* @comments Facilitates pre-configuration, as it checks if the NIM
*           interface exists and whether the component is in a state to
*           be configured (regardless of whether the component is enabled
*           or not).
*
* @comments The caller can set the pCfg parm to L7_NULL if it does not
*           want the value output from this function.
*
* @end
*********************************************************************/
L7_BOOL dot1xIntfIsConfigurable(L7_uint32 intIfNum, dot1xPortCfg_t **pCfg)
{
  L7_uint32 index;
  nimConfigID_t configId;

  if (!(DOT1X_IS_READY))
    return L7_FALSE;

  /* Check boundary conditions */
  if (intIfNum <= 0 || intIfNum >= platIntfMaxCountGet())
    return L7_FALSE;

  index = dot1xMapTbl[intIfNum];

  if (index == 0)
    return L7_FALSE;

  /* verify that the configId in the config data table entry matches the configId that NIM maps to
   ** the intIfNum we are considering
   */
  if (nimConfigIdGet(intIfNum, &configId) == L7_SUCCESS)
  {
    if (NIM_CONFIG_ID_IS_EQUAL(&configId, &(dot1xCfg->dot1xPortCfg[index].configId)) == L7_FALSE)
    {
      /* if we get here, either we have a table management error between dot1xCfg and dot1xMapTbl or
      ** there is synchronization issue between NIM and components w.r.t. interface creation/deletion
      */
      LOG_MSG("Error accessing dot1x config data for interface %d in dot1xIntfIsConfigurable.\n", intIfNum);
      return L7_FALSE;
    }
  }

  *pCfg = &dot1xCfg->dot1xPortCfg[index];

  return L7_TRUE;
}

/*********************************************************************
* @purpose  Obtain a pointer to the first free interface config struct
*
* @param    intIfNum @b{(input)} Internal Interface Number
* @param    **pCfg   @b{(output)}  Ptr  to dot1x port config structure
*                           or L7_NULL if not needed
*
* @returns  L7_TRUE
* @returns  L7_FALSE
*
*
* @comments Facilitates pre-configuration, as it checks if the NIM
*           interface exists and whether the component is in a state to
*           be configured (regardless of whether the component is enabled
*           or not).
*
* @end
*********************************************************************/
L7_BOOL dot1xIntfConfigEntryGet(L7_uint32 intIfNum, dot1xPortCfg_t **pCfg)
{
  L7_uint32 i;
  nimConfigID_t configId;
  nimConfigID_t configIdNull;
  L7_RC_t rc;

  memset(&configIdNull, 0, sizeof(nimConfigID_t));

  if (!(DOT1X_IS_READY))
    return L7_FALSE;

  if ((rc = nimConfigIdGet(intIfNum, &configId)) == L7_SUCCESS)
  {
    for (i = 1; i < L7_DOT1X_INTF_MAX_COUNT; i++)
    {
      if (NIM_CONFIG_ID_IS_EQUAL(&dot1xCfg->dot1xPortCfg[i].configId, &configIdNull))
      {
        dot1xMapTbl[intIfNum] = i;
        *pCfg = &dot1xCfg->dot1xPortCfg[i];
        return L7_TRUE;
      }
    }
  }

  return L7_FALSE;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_CREATE
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1xIntfCreate(L7_uint32 intIfNum)
{
  nimConfigID_t configId;
  dot1xPortCfg_t *pCfg;
  L7_uint32 i;

  if (dot1xIsValidIntf(intIfNum) != L7_TRUE)
    return L7_FAILURE;

  if (nimConfigIdGet(intIfNum, &configId) != L7_SUCCESS)
    return L7_FAILURE;

  for (i = 1; i < L7_DOT1X_INTF_MAX_COUNT; i++)
  {
    if (NIM_CONFIG_ID_IS_EQUAL(&dot1xCfg->dot1xPortCfg[i].configId, &configId))
    {
      dot1xMapTbl[intIfNum] = i;
      break;
    }
  }

  pCfg = L7_NULL;

  /* If an interface configuration entry is not already assigned to the interface, assign one */
  if (dot1xIntfIsConfigurable(intIfNum, &pCfg) != L7_TRUE)
  {
    if (dot1xIntfConfigEntryGet(intIfNum, &pCfg) != L7_TRUE)
      return L7_FAILURE;

    /* Update the configuration structure with the config id */
    if (pCfg)
    {
      dot1xBuildDefaultIntfConfigData(&configId, pCfg);
    #if defined L7_DOT1AD_PACKAGE
      if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                              L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
      {
        if (intIfNum == FD_DOT1X_WAN_PORT)
        {
          pCfg->paeCapabilities = L7_DOT1X_PAE_PORT_SUPP_CAPABLE;
        }
      }
   #endif
      dot1xBuildDefaultSupplicantIntfConfigData(&configId, pCfg);
    }
    else
    {
      return L7_FAILURE;
    }
  }

  /* Allocate the Memory for the operational strcuture */
  if(dot1xPhysicalPortInfoNodeGet(intIfNum)==L7_NULLPTR)
  {
    dot1xLogicalPortInfoAlloc(intIfNum);
  }
  /* Initialize the port info and clear the stats for this interface */
  (void)dot1xPortInfoInitialize(intIfNum,L7_TRUE);
    #if defined L7_DOT1AD_PACKAGE
    if (cnfgrIsFeaturePresent(L7_DOT1X_COMPONENT_ID,
                              L7_FEAT_DOT1X_SUPPLICANT_CONTROL_ON_AUTH_PORTS))
      {
        if (intIfNum == FD_DOT1X_WAN_PORT)
        {
          pCfg->paeCapabilities = L7_DOT1X_PAE_PORT_SUPP_CAPABLE;
        }
   }
#endif
  (void)dot1xCtlPortStatsClear(intIfNum);

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_DETACH
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1xIntfDetach(L7_uint32 intIfNum)
{
  dot1xPortCfg_t *pCfg;

  if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
  {
    if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_AUTH_CAPABLE)
    {
      /*dot1xBuildDefaultIntfConfigData(&pCfg->configId, pCfg);*/
      dot1xPortInfoInitialize(intIfNum,L7_TRUE);
      (void)dot1xCtlApplyPortConfigData(intIfNum);
    }
    else if (dot1xPortInfo[intIfNum].paeCapabilities == L7_DOT1X_PAE_PORT_SUPP_CAPABLE)
    {
     /* Disable previous Supplicant functionality */
    (void) dot1xStateMachineClassifier(sbmSuppAbort, intIfNum, L7_NULL, L7_NULLPTR);
    (void) dot1xSupplicantPortInfoInitialize(intIfNum,L7_TRUE);
     dot1xIhPhyPortStatusSet(intIfNum,L7_DOT1X_PORT_STATUS_AUTHORIZED,
                                  L7_TRUE);
    }
  }

  return L7_SUCCESS;
}

/*********************************************************************
*
* @purpose  To process the Callback for L7_DELETE
*
* @param    L7_uint32  intIfNum  internal interface number
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
*
* @comments none
*
* @end
*
*********************************************************************/
L7_RC_t dot1xIntfDelete(L7_uint32 intIfNum)
{
  dot1xPortCfg_t *pCfg;
  L7_uint32      lIndex = 0;
  dot1xLogicalPortInfo_t *logicalPortInfo;

  if (dot1xIntfIsConfigurable(intIfNum, &pCfg) == L7_TRUE)
  {
    memset((void *)&pCfg->configId, 0, sizeof(nimConfigID_t));
    memset((void *)&dot1xMapTbl[intIfNum], 0, sizeof(L7_uint32));
    memset((void *)&dot1xPortInfo[intIfNum], 0, sizeof(dot1xPortInfo_t));
    memset((void *)&dot1xPortStats[intIfNum], 0, sizeof(dot1xPortStats_t));

    lIndex = DOT1X_LOGICAL_PORT_ITERATE;
    while((logicalPortInfo=dot1xLogicalPortInfoGetNextNode(intIfNum,&lIndex))!= L7_NULLPTR)
    {
         /*remove supplicant mac address from Mac address Database*/
        dot1xMacAddrInfoRemove(&(logicalPortInfo->suppMacAddr));
        dot1xLogicalPortInfoDeAlloc(logicalPortInfo);
    }
  }

  return L7_SUCCESS;
}


/*********************************************************************
* @purpose  Set the Violation Callback in the driver
*
* @param    intIfNum   @b{(input)) internal interface number
* @param    flag       @b{(input)) True to set the value
*
* @returns  L7_SUCCESS
* @returns  L7_FAILURE
* @returns  L7_ERROR
*
* @comments none
*
* @end
*********************************************************************/
L7_RC_t dot1xIhPhyPortViolationCallbackSet(L7_uint32 intIfNum, L7_BOOL flag)
{
  DOT1X_EVENT_TRACE(DOT1X_TRACE_PORT_STATUS,intIfNum,"%s:Setting the %d for violation callback \n",
                      __FUNCTION__,intIfNum);
  return dtlDot1xIntfStatusSet(intIfNum,L7_DOT1X_PORT_STATUS_UNAUTHORIZED ,flag);
}
