/*
 * $Id: er_tcam_type1.c,v 1.1 2011/04/18 17:11:04 mruas Exp $
 * $Copyright: Copyright 2009 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * File:      er_tcam_type1.c
 */

#include <soc/error.h>
#include <soc/register.h>
#include <soc/mem.h>
#include <soc/debug.h>
#include <soc/drv.h>

#ifdef BCM_EASYRIDER_SUPPORT
#include <soc/easyrider.h>
#endif /* BCM_EASYRIDER_SUPPORT */
#if defined(BCM_TRIUMPH_SUPPORT)
#include <soc/triumph.h>
#endif /* BCM_TRIUMPH_SUPPORT */
#include <soc/er_cmdmem.h>
#include <soc/er_tcam.h>
#include <soc/tcam/tcamtype1.h>

#include <sal/appl/io.h>

#ifdef BCM_EASYRIDER_SUPPORT
STATIC uint32 type1_subtype1_ucode[] =
{
    0x00000000, 0x00000000, 0x00000042, 0x20000000, /* 0x0000 */
    0x00000000, 0x00000000, 0x00000042, 0x30055000, /* 0x0010 */
    0x00000042, 0x464640c8, 0x00000042, 0x40065081, /* 0x0020 */
    0x00000042, 0x40067083, 0x00000000, 0x00000000, /* 0x0030 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0040 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0050 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0060 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0070 */
    0x00000000, 0x0006d000, 0x00000046, 0x40073081, /* 0x0080 */
    0x00000046, 0x4007b083, 0x00000000, 0x0008f000, /* 0x0090 */
    0x00000000, 0x00000000, 0x00000000, 0x00092000, /* 0x00a0 */
    0x00000000, 0x00099000, 0x00000000, 0x000a4100, /* 0x00b0 */
    0x00000000, 0x000a4100, 0x00000000, 0x000a4100, /* 0x00c0 */
    0x00000002, 0x10000700, 0x00000000, 0x00000000, /* 0x00d0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x00e0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x00f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0100 */
    0x00000000, 0x000a8000, 0x00000000, 0x00000000, /* 0x0110 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0120 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0130 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0140 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0150 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0160 */
    0x00000000, 0x00000000, 0x00000041, 0x000ab040, /* 0x0170 */
    0x00000000, 0x000af000, 0x00000000, 0x00000000, /* 0x0180 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0190 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x01a0 */
    0x00000000, 0x00000000, 0x00000000, 0x000b2000, /* 0x01b0 */
    0x00000041, 0x000b6041, 0x00000000, 0x00000000, /* 0x01c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x01d0 */
    0x00000041, 0x000ba042, 0x00000000, 0x00000000, /* 0x01e0 */
    0x00000000, 0x00000000, 0x00000000, 0x000be000, /* 0x01f0 */
    0x00000000, 0x000c2000, 0x00000000, 0x000c7000, /* 0x0200 */
    0x00000000, 0x000d1000, 0x00000000, 0x000d5000, /* 0x0210 */
    0x00000000, 0x000da000, 0x00000000, 0x000e4000, /* 0x0220 */
    0x00000000, 0x000e7000, 0x00000000, 0x000ec000, /* 0x0230 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0240 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0250 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0260 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0270 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0280 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0290 */
    0x00000000, 0x00000000, 0x00000042, 0x30000200, /* 0x02a0 */
    0x00000042, 0x30000200, 0x00000042, 0x30000200, /* 0x02b0 */
    0x00000042, 0x30000200, 0x00000042, 0x30000200, /* 0x02c0 */
    0x00000042, 0x30000200, 0x00000042, 0x30000200, /* 0x02d0 */
    0x00000042, 0x30000200, 0x00000042, 0x30000200, /* 0x02e0 */
    0x00000042, 0x30000200, 0x00000042, 0x30000200, /* 0x02f0 */
    0x00000042, 0x30000200, 0x00000042, 0x30000200, /* 0x0300 */
    0x00000042, 0x30000200, 0x00000042, 0x30000700, /* 0x0310 */
    0x00000001, 0xc000a700, 0x00000042, 0x464660c8, /* 0x0320 */
    0x00000001, 0x8000a700, 0x00000000, 0x00068000, /* 0x0330 */
    0x00000042, 0x40069082, 0x00000000, 0x0006a000, /* 0x0340 */
    0x00000042, 0x4006b081, 0x00000042, 0x4646c0c8, /* 0x0350 */
    0x00000001, 0x0000a700, 0x00000042, 0x4055a4c8, /* 0x0360 */
    0x00000000, 0x00071300, 0x00000000, 0x164700c8, /* 0x0370 */
    0x00000001, 0xc0154000, 0x00000000, 0x124720c8, /* 0x0380 */
    0x00000001, 0xc0154000, 0x00000046, 0x4055a4c8, /* 0x0390 */
    0x00000000, 0x00078300, 0x00000088, 0x00076081, /* 0x03a0 */
    0x00000088, 0x164770c8, 0x00000001, 0x80154000, /* 0x03b0 */
    0x00000088, 0x00079081, 0x00000088, 0x1247a0c8, /* 0x03c0 */
    0x00000001, 0x80154000, 0x00000000, 0x0007c000, /* 0x03d0 */
    0x00000046, 0x4007d082, 0x00000000, 0x0007e000, /* 0x03e0 */
    0x00000046, 0x4007f081, 0x00000046, 0x4055a4c8, /* 0x03f0 */
    0x00000000, 0x00088300, 0x00000088, 0x00082083, /* 0x0400 */
    0x00000000, 0x00083000, 0x00000088, 0x00084082, /* 0x0410 */
    0x00000000, 0x00085000, 0x00000088, 0x00086081, /* 0x0420 */
    0x00000088, 0x164870c8, 0x00000001, 0x00154000, /* 0x0430 */
    0x00000088, 0x00089083, 0x00000000, 0x0008a000, /* 0x0440 */
    0x00000088, 0x0008b082, 0x00000000, 0x0008c000, /* 0x0450 */
    0x00000088, 0x0008d081, 0x00000088, 0x1248e0c8, /* 0x0460 */
    0x00000001, 0x00154000, 0x00000041, 0x10159493, /* 0x0470 */
    0x00000042, 0x40159400, 0x00000000, 0xc0004700, /* 0x0480 */
    0x00000051, 0x14159490, 0x00000042, 0x40159400, /* 0x0490 */
    0x000000c0, 0x00159492, 0x00000042, 0x40159400, /* 0x04a0 */
    0x000000c0, 0x00159491, 0x00000000, 0x80098000, /* 0x04b0 */
    0x00000000, 0x00154000, 0x00000055, 0x00159490, /* 0x04c0 */
    0x00000072, 0x40159400, 0x000000c0, 0x14159490, /* 0x04d0 */
    0x00000062, 0x40159400, 0x000000c0, 0x00159492, /* 0x04e0 */
    0x00000072, 0x40159400, 0x000000c0, 0x00159492, /* 0x04f0 */
    0x00000042, 0x40159400, 0x000000c8, 0x00159491, /* 0x0500 */
    0x00000000, 0x000a3000, 0x00000000, 0x00154000, /* 0x0510 */
    0x00000000, 0x000a5000, 0x00000041, 0x10159494, /* 0x0520 */
    0x00000000, 0x000a7000, 0x00000001, 0x00000000, /* 0x0530 */
    0x00000002, 0x0000a602, 0x00000000, 0x000aa100, /* 0x0540 */
    0x00000000, 0x10000700, 0x00000000, 0x00004600, /* 0x0550 */
    0x00000000, 0x000ad100, 0x00000001, 0x000ae000, /* 0x0560 */
    0x00000003, 0xc0000700, 0x00000041, 0x10159493, /* 0x0570 */
    0x00000042, 0x00159400, 0x00000001, 0x00004700, /* 0x0580 */
    0x00000042, 0x000b5493, 0x00000042, 0x30159400, /* 0x0590 */
    0x00000000, 0x00004700, 0x00000000, 0x30000500, /* 0x05a0 */
    0x00000000, 0x00005600, 0x00000000, 0x000b8100, /* 0x05b0 */
    0x00000001, 0x000b9000, 0x00000003, 0xc0000700, /* 0x05c0 */
    0x00000000, 0x00005600, 0x00000000, 0x000bc100, /* 0x05d0 */
    0x00000001, 0x000bd000, 0x00000003, 0xc0004700, /* 0x05e0 */
    0x00000041, 0x00159490, 0x00000042, 0x40159400, /* 0x05f0 */
    0x00000000, 0x000c1000, 0x00000000, 0xd0000700, /* 0x0600 */
    0x00000051, 0x00159490, 0x00000072, 0x40159400, /* 0x0610 */
    0x000000c0, 0x00159490, 0x00000042, 0x40159400, /* 0x0620 */
    0x00000000, 0x90000700, 0x00000051, 0x00159490, /* 0x0630 */
    0x00000072, 0x40159400, 0x000000c0, 0x00159490, /* 0x0640 */
    0x00000072, 0x40159400, 0x000000c0, 0x00159490, /* 0x0650 */
    0x00000072, 0x40159400, 0x000000c0, 0x00159490, /* 0x0660 */
    0x00000042, 0x400cf000, 0x00000000, 0x000d0000, /* 0x0670 */
    0x00000000, 0x10000700, 0x00000041, 0x00159492, /* 0x0680 */
    0x00000042, 0x40159400, 0x00000000, 0x000d4000, /* 0x0690 */
    0x00000000, 0xd0004700, 0x00000051, 0x00159492, /* 0x06a0 */
    0x00000072, 0x40159400, 0x000000c0, 0x00159492, /* 0x06b0 */
    0x00000042, 0x40159400, 0x00000000, 0x90000700, /* 0x06c0 */
    0x00000051, 0x00159492, 0x00000072, 0x40159400, /* 0x06d0 */
    0x000000c0, 0x00159492, 0x00000072, 0x40159400, /* 0x06e0 */
    0x000000c0, 0x00159492, 0x00000072, 0x40159400, /* 0x06f0 */
    0x000000c0, 0x00159492, 0x00000042, 0x400e2000, /* 0x0700 */
    0x00000000, 0x000e3000, 0x00000000, 0x10000700, /* 0x0710 */
    0x00000041, 0x00159491, 0x00000000, 0x000e6000, /* 0x0720 */
    0x00000001, 0x10000700, 0x00000051, 0x00159491, /* 0x0730 */
    0x00000030, 0x00159400, 0x000000c0, 0x00159491, /* 0x0740 */
    0x00000000, 0x00159400, 0x00000001, 0x10000700, /* 0x0750 */
    0x00000051, 0x00159491, 0x00000030, 0x00159400, /* 0x0760 */
    0x000000c0, 0x00159491, 0x00000030, 0x00159400, /* 0x0770 */
    0x000000c0, 0x00159491, 0x00000030, 0x00159400, /* 0x0780 */
    0x000000c0, 0x00159491, 0x00000000, 0x000f4000, /* 0x0790 */
    0x00000000, 0x000f5000, 0x00000001, 0x10000700, /* 0x07a0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x07b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x07c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x07d0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x07e0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x07f0 */
    0x00000042, 0x4655d0c8, 0x00000042, 0x4015e081, /* 0x0800 */
    0x00000042, 0x40160083, 0x00000000, 0x00000000, /* 0x0810 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0820 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0830 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0840 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0850 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0860 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0870 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0880 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0890 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x08a0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x08b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x08c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x08d0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x08e0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x08f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0900 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0910 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0920 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0930 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0940 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0950 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0960 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0970 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0980 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0990 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x09a0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x09b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x09c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x09d0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x09e0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x09f0 */
    0x00000046, 0x40166082, 0x00000046, 0x46d6f0d0, /* 0x0a00 */
    0x00000046, 0x40172081, 0x00000046, 0x40177083, /* 0x0a10 */
    0x00000042, 0x40184082, 0x00000000, 0x00000000, /* 0x0a20 */
    0x00000042, 0x4018a081, 0x00000042, 0x4018e083, /* 0x0a30 */
    0x00000046, 0x40196082, 0x00000046, 0x46d9f0d0, /* 0x0a40 */
    0x00000046, 0x401a2081, 0x00000046, 0x401a7083, /* 0x0a50 */
    0x00000042, 0x401b4082, 0x00000000, 0x00000000, /* 0x0a60 */
    0x00000042, 0x401bb081, 0x00000042, 0x401bf083, /* 0x0a70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0a80 */
    0x00000000, 0x00000000, 0x00000042, 0x101c7000, /* 0x0a90 */
    0x00000000, 0x00000200, 0x00000042, 0x14000200, /* 0x0aa0 */
    0x00000042, 0x14000200, 0x00000042, 0x14000200, /* 0x0ab0 */
    0x00000042, 0x14000700, 0x00000000, 0x00000500, /* 0x0ac0 */
    0x00000000, 0x00009600, 0x00000000, 0x0015c100, /* 0x0ad0 */
    0x00000000, 0x00000500, 0x00000001, 0xc0000700, /* 0x0ae0 */
    0x00000042, 0x4655f0c8, 0x00000001, 0x80000700, /* 0x0af0 */
    0x00000000, 0x00161000, 0x00000042, 0x40162082, /* 0x0b00 */
    0x00000000, 0x00163000, 0x00000042, 0x40164081, /* 0x0b10 */
    0x00000042, 0x465650c8, 0x00000001, 0x00000700, /* 0x0b20 */
    0x00000000, 0x00167000, 0x00000046, 0x40168081, /* 0x0b30 */
    0x00000046, 0x46d690d0, 0x00000000, 0x0016a000, /* 0x0b40 */
    0x00000088, 0x0016b082, 0x00000000, 0x0016c000, /* 0x0b50 */
    0x00000088, 0x0016d081, 0x00000088, 0x0656e0d0, /* 0x0b60 */
    0x00000001, 0x40000700, 0x00000000, 0x00170000, /* 0x0b70 */
    0x00000088, 0x065710d0, 0x00000001, 0xc0000700, /* 0x0b80 */
    0x00000046, 0x46d730d0, 0x00000000, 0x00174000, /* 0x0b90 */
    0x00000088, 0x00175081, 0x00000088, 0x065760d0, /* 0x0ba0 */
    0x00000001, 0x80000700, 0x00000000, 0x00178000, /* 0x0bb0 */
    0x00000046, 0x40179082, 0x00000000, 0x0017a000, /* 0x0bc0 */
    0x00000046, 0x4017b081, 0x00000046, 0x46d7c0d0, /* 0x0bd0 */
    0x00000000, 0x0017d000, 0x00000088, 0x0017e083, /* 0x0be0 */
    0x00000000, 0x0017f000, 0x00000088, 0x00180082, /* 0x0bf0 */
    0x00000000, 0x00181000, 0x00000088, 0x00182081, /* 0x0c00 */
    0x00000088, 0x065830d0, 0x00000001, 0x00000700, /* 0x0c10 */
    0x00000000, 0x00185000, 0x00000046, 0x40186081, /* 0x0c20 */
    0x00000046, 0x46d870d0, 0x00000088, 0x00188081, /* 0x0c30 */
    0x00000088, 0x065890d0, 0x00000001, 0x40000700, /* 0x0c40 */
    0x00000046, 0x46d8b0d0, 0x00000000, 0x0018c000, /* 0x0c50 */
    0x00000088, 0x0658d0d0, 0x00000001, 0x80000700, /* 0x0c60 */
    0x00000000, 0x0018f000, 0x00000042, 0x40190082, /* 0x0c70 */
    0x00000000, 0x00191000, 0x00000046, 0x40192081, /* 0x0c80 */
    0x00000046, 0x46d930d0, 0x00000088, 0x00194081, /* 0x0c90 */
    0x00000088, 0x065950d0, 0x00000001, 0x00000700, /* 0x0ca0 */
    0x00000000, 0x00197000, 0x00000046, 0x40198081, /* 0x0cb0 */
    0x00000046, 0x46d990d0, 0x00000000, 0x0019a000, /* 0x0cc0 */
    0x00000088, 0x0019b082, 0x00000000, 0x0019c000, /* 0x0cd0 */
    0x00000088, 0x0019d081, 0x00000088, 0x0659e0d0, /* 0x0ce0 */
    0x00000001, 0x40000700, 0x00000000, 0x001a0000, /* 0x0cf0 */
    0x00000088, 0x065a10d0, 0x00000001, 0xc0000700, /* 0x0d00 */
    0x00000046, 0x46da30d0, 0x00000000, 0x001a4000, /* 0x0d10 */
    0x00000088, 0x001a5081, 0x00000088, 0x065a60d0, /* 0x0d20 */
    0x00000001, 0x80000700, 0x00000000, 0x001a8000, /* 0x0d30 */
    0x00000046, 0x401a9082, 0x00000000, 0x001aa000, /* 0x0d40 */
    0x00000046, 0x401ab081, 0x00000046, 0x46dac0d0, /* 0x0d50 */
    0x00000000, 0x001ad000, 0x00000088, 0x001ae083, /* 0x0d60 */
    0x00000000, 0x001af000, 0x00000088, 0x001b0082, /* 0x0d70 */
    0x00000000, 0x001b1000, 0x00000088, 0x001b2081, /* 0x0d80 */
    0x00000088, 0x065b30d0, 0x00000001, 0x00000700, /* 0x0d90 */
    0x00000000, 0x001b5000, 0x00000046, 0x401b6081, /* 0x0da0 */
    0x00000000, 0x001b7000, 0x00000046, 0x46db80d0, /* 0x0db0 */
    0x00000088, 0x001b9081, 0x00000088, 0x065ba0d0, /* 0x0dc0 */
    0x00000001, 0x40000700, 0x00000046, 0x46dbc0d0, /* 0x0dd0 */
    0x00000000, 0x001bd000, 0x00000088, 0x065be0d0, /* 0x0de0 */
    0x00000001, 0x80000700, 0x00000000, 0x001c0000, /* 0x0df0 */
    0x00000042, 0x401c1082, 0x00000000, 0x001c2000, /* 0x0e00 */
    0x00000046, 0x401c3081, 0x00000046, 0x46dc40d0, /* 0x0e10 */
    0x00000088, 0x001c5081, 0x00000088, 0x065c60d0, /* 0x0e20 */
    0x00000001, 0x00800700, 0x00000042, 0x00000200, /* 0x0e30 */
    0x00000042, 0x00000200, 0x00000042, 0x00000200, /* 0x0e40 */
    0x00000042, 0x00000200, 0x00000042, 0x00000200, /* 0x0e50 */
    0x00000042, 0x00000200, 0x00000042, 0x00000200, /* 0x0e60 */
    0x00000042, 0x00000200, 0x00000042, 0x00000200, /* 0x0e70 */
    0x00000042, 0x00000200, 0x00000042, 0x00000200, /* 0x0e80 */
    0x00000042, 0x00000200, 0x00000042, 0x00000200, /* 0x0e90 */
    0x00000042, 0x00000200, 0x00000042, 0x00000700, /* 0x0ea0 */
};

STATIC uint32 type1_subtype2_ucode[] =
{
    0x00000000, 0x00000000, 0x00000000, 0x00005000, /* 0x0000 */
    0x00000000, 0x00009000, 0x00000000, 0x00000000, /* 0x0010 */
    0x00000002, 0x10000700, 0x00000002, 0x0000a602, /* 0x0020 */
    0x00000000, 0x00007100, 0x00000000, 0x10000700, /* 0x0030 */
    0x00000041, 0x00093040, 0x00000002, 0x0000a001, /* 0x0040 */
    0x00000000, 0x0000b000, 0x00000000, 0x10000700, /* 0x0050 */
    0x00000042, 0x4000d086, 0x00000042, 0x4000e085, /* 0x0060 */
    0x00000042, 0x4000f084, 0x00000042, 0x40010083, /* 0x0070 */
    0x00000042, 0x40011082, 0x00000042, 0x40012081, /* 0x0080 */
    0x00000042, 0x464127c8, 0x00000042, 0x464127c8, /* 0x0090 */
    0x00000042, 0x474127c8, 0x00000042, 0x464127c8, /* 0x00a0 */
    0x00000042, 0x474127c8, 0x00000002, 0x10000700, /* 0x00b0 */
    0x00000000, 0x00078000, 0x00000042, 0x4001a082, /* 0x00c0 */
    0x00000042, 0x4001b081, 0x00000042, 0x464127c8, /* 0x00d0 */
    0x00000000, 0x00078000, 0x00000041, 0x001b5490, /* 0x00e0 */
    0x00000000, 0xd0000700, 0x00000000, 0x000a0000, /* 0x00f0 */
    0x00000042, 0x60000000, 0x00000042, 0x70000200, /* 0x0100 */
    0x00000042, 0x70000200, 0x00000042, 0x70000200, /* 0x0110 */
    0x00000042, 0x70000200, 0x00000042, 0x70000200, /* 0x0120 */
    0x00000042, 0x70000200, 0x00000042, 0x70000200, /* 0x0130 */
    0x00000042, 0x70000200, 0x00000042, 0x70000200, /* 0x0140 */
    0x00000042, 0x70000200, 0x00000042, 0x70000200, /* 0x0150 */
    0x00000042, 0x70000200, 0x00000042, 0x70000200, /* 0x0160 */
    0x00000042, 0x70000200, 0x00000042, 0x70000700, /* 0x0170 */
    0x00000042, 0x70021000, 0x00000042, 0x40032086, /* 0x0180 */
    0x00000042, 0x40033085, 0x00000042, 0x40034084, /* 0x0190 */
    0x00000042, 0x40035083, 0x00000042, 0x40036082, /* 0x01a0 */
    0x00000042, 0x40037081, 0x00000042, 0x474127c8, /* 0x01b0 */
    0x00000000, 0x000a0000, 0x00000042, 0x4003a082, /* 0x01c0 */
    0x00000042, 0x4003b081, 0x00000042, 0x474127c8, /* 0x01d0 */
    0x00000042, 0x405304c8, 0x00000000, 0x00040300, /* 0x01e0 */
    0x00000000, 0x1643f0c8, 0x00000001, 0xc01b0000, /* 0x01f0 */
    0x00000000, 0x124410c8, 0x00000001, 0xc01b0000, /* 0x0200 */
    0x00000041, 0x001b5492, 0x00000000, 0xd0000700, /* 0x0210 */
    0x00000042, 0x21003000, 0x00000042, 0x40046086, /* 0x0220 */
    0x00000042, 0x40047085, 0x00000042, 0x40048084, /* 0x0230 */
    0x00000042, 0x40049083, 0x00000042, 0x4004a082, /* 0x0240 */
    0x00000042, 0x4004b081, 0x00000042, 0x405304c8, /* 0x0250 */
    0x00000000, 0x0004f300, 0x00000000, 0x1644e0c8, /* 0x0260 */
    0x00000000, 0x001b0000, 0x00000000, 0x124500c8, /* 0x0270 */
    0x00000000, 0x001b0000, 0x00000042, 0x405304c8, /* 0x0280 */
    0x00000000, 0x00055300, 0x00000000, 0x164540c8, /* 0x0290 */
    0x00000001, 0x801b0000, 0x00000000, 0x124560c8, /* 0x02a0 */
    0x00000001, 0x801b0000, 0x00000042, 0x40058082, /* 0x02b0 */
    0x00000042, 0x40059081, 0x00000042, 0x405304c8, /* 0x02c0 */
    0x00000000, 0x0005d300, 0x00000000, 0x1645c0c8, /* 0x02d0 */
    0x00000001, 0x001b0000, 0x00000000, 0x1245e0c8, /* 0x02e0 */
    0x00000001, 0x001b0000, 0x00000041, 0x1008c493, /* 0x02f0 */
    0x00000042, 0x4008c400, 0x00000000, 0xc0004700, /* 0x0300 */
    0x00000051, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0310 */
    0x00000000, 0x90000700, 0x00000041, 0x01093041, /* 0x0320 */
    0x00000041, 0x1008c493, 0x00000042, 0x40068000, /* 0x0330 */
    0x00000000, 0xc01ba400, 0x00000000, 0x00004700, /* 0x0340 */
    0x00000051, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0350 */
    0x00000000, 0x900d2000, 0x00000041, 0x00093041, /* 0x0360 */
    0x00000051, 0x1408c490, 0x00000042, 0x4008c400, /* 0x0370 */
    0x00000000, 0x0008c400, 0x000000c0, 0x0008c492, /* 0x0380 */
    0x00000042, 0x4008c400, 0x00000000, 0x801b0000, /* 0x0390 */
    0x00000000, 0x000ad000, 0x00000000, 0x000c0000, /* 0x03a0 */
    0x00000000, 0x000d8000, 0x00000000, 0x000f5000, /* 0x03b0 */
    0x00000041, 0x1008c493, 0x00000042, 0x0008c400, /* 0x03c0 */
    0x00000001, 0x0007b000, 0x00000000, 0x00004700, /* 0x03d0 */
    0x00000000, 0x000a4000, 0x00000000, 0x0001d000, /* 0x03e0 */
    0x00000000, 0x00062000, 0x00000000, 0x000e4000, /* 0x03f0 */
    0x00000055, 0x0008c490, 0x00000072, 0x4008c400, /* 0x0400 */
    0x00000000, 0x0008c400, 0x000000c0, 0x1408c490, /* 0x0410 */
    0x00000062, 0x4008c400, 0x00000000, 0x0008c400, /* 0x0420 */
    0x000000c0, 0x0008c492, 0x00000072, 0x4008c400, /* 0x0430 */
    0x00000000, 0x0008c400, 0x000000c0, 0x0008c492, /* 0x0440 */
    0x00000042, 0x4008c400, 0x00000008, 0x001b0000, /* 0x0450 */
    0x00000000, 0x00000500, 0x00000041, 0x00093042, /* 0x0460 */
    0x00000041, 0x1008c494, 0x00000000, 0x0008c400, /* 0x0470 */
    0x00000000, 0x0008c400, 0x00000000, 0x00092000, /* 0x0480 */
    0x00000001, 0x00000700, 0x00000000, 0x0000e600, /* 0x0490 */
    0x00000000, 0x00095100, 0x00000001, 0x00096000, /* 0x04a0 */
    0x00000000, 0x00097000, 0x00000003, 0xc0098000, /* 0x04b0 */
    0x00000000, 0x00000700, 0x00000041, 0x001b5492, /* 0x04c0 */
    0x00000000, 0xd00d1000, 0x00000000, 0x00000000, /* 0x04d0 */
    0x00000000, 0x00180000, 0x00000000, 0x00042000, /* 0x04e0 */
    0x00000000, 0x000b9000, 0x00000000, 0x000ff000, /* 0x04f0 */
    0x00000041, 0x1008c493, 0x00000042, 0x0008c400, /* 0x0500 */
    0x00000001, 0x001ba400, 0x00000000, 0x00004700, /* 0x0510 */
    0x00000051, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0520 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0530 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0540 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0550 */
    0x00000001, 0x10000700, 0x00000055, 0x001b5490, /* 0x0560 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0570 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0580 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0590 */
    0x000000c0, 0x0008c490, 0x00000042, 0x4008c400, /* 0x05a0 */
    0x00000001, 0x000b7000, 0x00000080, 0x110b8000, /* 0x05b0 */
    0x0000004a, 0x11000700, 0x00000051, 0x001b5492, /* 0x05c0 */
    0x000000c0, 0x001b5492, 0x00000000, 0x90000700, /* 0x05d0 */
    0x00000000, 0x00017000, 0x00000000, 0x00017000, /* 0x05e0 */
    0x00000000, 0x00017000, 0x00000000, 0x00017000, /* 0x05f0 */
    0x00000051, 0x0008c490, 0x00000042, 0x4008c400, /* 0x0600 */
    0x00000000, 0xc00c3000, 0x000000c0, 0x110c4000, /* 0x0610 */
    0x00000042, 0x11000700, 0x00000000, 0x0005f000, /* 0x0620 */
    0x00000000, 0x00000000, 0x00000000, 0x00066000, /* 0x0630 */
    0x00000051, 0x0008c490, 0x00000042, 0x4008c400, /* 0x0640 */
    0x00000000, 0xc00cb000, 0x000000c0, 0x110cc000, /* 0x0650 */
    0x00000042, 0x110d2000, 0x00000000, 0x0006e000, /* 0x0660 */
    0x00000000, 0x00080000, 0x00000041, 0x001b5490, /* 0x0670 */
    0x00000000, 0xd00d1000, 0x00000002, 0x000d2000, /* 0x0680 */
    0x00000002, 0x000d3000, 0x00000002, 0x000d4000, /* 0x0690 */
    0x00000002, 0x000d5000, 0x00000002, 0x000d6000, /* 0x06a0 */
    0x00000002, 0x000d7000, 0x00000002, 0x00000700, /* 0x06b0 */
    0x00000055, 0x001b5490, 0x000000c0, 0x0008c490, /* 0x06c0 */
    0x00000042, 0x4008c400, 0x00000000, 0x800dc000, /* 0x06d0 */
    0x00000080, 0x110dd000, 0x0000004a, 0x11000700, /* 0x06e0 */
    0x00000055, 0x001b5490, 0x000000c0, 0x0008c490, /* 0x06f0 */
    0x00000042, 0x4008c400, 0x00000000, 0x800e2000, /* 0x0700 */
    0x00000080, 0x110e3000, 0x0000004a, 0x110d3000, /* 0x0710 */
    0x00000051, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0720 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0730 */
    0x00000000, 0x10000700, 0x00000051, 0x001b5492, /* 0x0740 */
    0x000000c0, 0x001b5492, 0x00000000, 0x900d2000, /* 0x0750 */
    0x00000000, 0x0008e100, 0x00000000, 0x0008e100, /* 0x0760 */
    0x00000000, 0x0008e100, 0x00000000, 0x0008e100, /* 0x0770 */
    0x00000051, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0780 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x0790 */
    0x00000000, 0x100d4000, 0x00000055, 0x001b5490, /* 0x07a0 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x07b0 */
    0x000000c0, 0x001b5490, 0x0000004a, 0x11000700, /* 0x07c0 */
    0x00000055, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x07d0 */
    0x000000c0, 0x001b5490, 0x000000c0, 0x001b5490, /* 0x07e0 */
    0x0000004a, 0x110d5000, 0x00000051, 0x001b5492, /* 0x07f0 */
    0x000000c0, 0x001b5492, 0x000000c0, 0x001b5492, /* 0x0800 */
    0x000000c0, 0x001b5492, 0x00000000, 0x10000700, /* 0x0810 */
    0x00000042, 0x40045087, 0x00000000, 0x0003c000, /* 0x0820 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0830 */
    0x00000000, 0x00000000, 0x00000000, 0x000cf000, /* 0x0840 */
    0x00000000, 0x0006a000, 0x00000000, 0x000f0000, /* 0x0850 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0860 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0870 */
    0x00000000, 0x00111000, 0x00000000, 0x065120d0, /* 0x0880 */
    0x00000000, 0x00000700, 0x00000000, 0x00000000, /* 0x0890 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x08a0 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x08b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00099000, /* 0x08c0 */
    0x00000000, 0x000e9000, 0x00000000, 0x00189000, /* 0x08d0 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x08e0 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x08f0 */
    0x00000042, 0x46d210d0, 0x00000000, 0x00122000, /* 0x0900 */
    0x00000000, 0x065230d0, 0x00000000, 0x00000700, /* 0x0910 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0920 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0930 */
    0x00000046, 0x46d290d0, 0x00000000, 0x0012a000, /* 0x0940 */
    0x00000088, 0x0652b0d0, 0x00000000, 0x00000700, /* 0x0950 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0960 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0970 */
    0x00000000, 0x00012600, 0x00000000, 0x00132100, /* 0x0980 */
    0x00000000, 0x00000500, 0x00000000, 0x00000000, /* 0x0990 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x09a0 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x09b0 */
    0x00000000, 0x00000000, 0x00000000, 0x000c8000, /* 0x09c0 */
    0x00000000, 0x000de000, 0x00000000, 0x000fa000, /* 0x09d0 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x09e0 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x09f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0a00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0a10 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0a20 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0a30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0a40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0a50 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0a60 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0a70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0a80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0a90 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0aa0 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0ab0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0ac0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0ad0 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0ae0 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0af0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0b00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0b10 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0b20 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0b30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0b40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0b50 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0b60 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0b70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0b80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0b90 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0ba0 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0bb0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0bc0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0bd0 */
    0x00000042, 0x400a0087, 0x00000000, 0x0003c000, /* 0x0be0 */
    0x00000042, 0x40051081, 0x00000042, 0x40057083, /* 0x0bf0 */
    0x00000051, 0x001b5492, 0x000000c0, 0x001b5492, /* 0x0c00 */
    0x000000c0, 0x001b5492, 0x000000c0, 0x001b5492, /* 0x0c10 */
    0x000000c0, 0x001b5492, 0x000000c0, 0x001b5492, /* 0x0c20 */
    0x000000c0, 0x001b5492, 0x000000c0, 0x001b5492, /* 0x0c30 */
    0x00000001, 0x10000700, 0x00000051, 0x001b5492, /* 0x0c40 */
    0x000000c0, 0x001b5492, 0x000000c0, 0x001b5492, /* 0x0c50 */
    0x000000c0, 0x001b5492, 0x00000000, 0x100d4000, /* 0x0c60 */
    0x00000042, 0x4018f086, 0x00000042, 0x40190085, /* 0x0c70 */
    0x00000042, 0x40191084, 0x00000042, 0x40192083, /* 0x0c80 */
    0x00000042, 0x40193082, 0x00000042, 0x40194081, /* 0x0c90 */
    0x00000042, 0x46d950d0, 0x00000000, 0x00196000, /* 0x0ca0 */
    0x00000000, 0x065970d0, 0x00000000, 0x00000700, /* 0x0cb0 */
    0x00000042, 0x40199082, 0x00000042, 0x4019a081, /* 0x0cc0 */
    0x00000042, 0x46d9b0d0, 0x00000000, 0x0019c000, /* 0x0cd0 */
    0x00000000, 0x0659d0d0, 0x00000000, 0x00000700, /* 0x0ce0 */
    0x00000042, 0x4019f086, 0x00000042, 0x401a0085, /* 0x0cf0 */
    0x00000042, 0x401a1084, 0x00000046, 0x401a2083, /* 0x0d00 */
    0x00000046, 0x401a3082, 0x00000046, 0x401a4081, /* 0x0d10 */
    0x00000046, 0x46da50d0, 0x00000088, 0x001a6083, /* 0x0d20 */
    0x00000088, 0x001a7082, 0x00000088, 0x001a8081, /* 0x0d30 */
    0x00000088, 0x065a90d0, 0x00000000, 0x00000700, /* 0x0d40 */
    0x00000042, 0x401ab082, 0x00000046, 0x401ac081, /* 0x0d50 */
    0x00000046, 0x46dad0d0, 0x00000088, 0x001ae081, /* 0x0d60 */
    0x00000088, 0x065af0d0, 0x00000000, 0x00800700, /* 0x0d70 */
    0x00000000, 0x00000200, 0x00000042, 0x14000200, /* 0x0d80 */
    0x00000042, 0x14000200, 0x00000042, 0x14000200, /* 0x0d90 */
    0x00000042, 0x14000700, 0x00000000, 0x001b6000, /* 0x0da0 */
    0x00000072, 0x401b7000, 0x00000000, 0x001b8000, /* 0x0db0 */
    0x00000000, 0x001b9000, 0x00000000, 0x00000500, /* 0x0dc0 */
    0x00000002, 0x001bb000, 0x00000002, 0x001bc000, /* 0x0dd0 */
    0x00000002, 0x001bd000, 0x00000002, 0x001be000, /* 0x0de0 */
    0x00000002, 0x001bf000, 0x00000002, 0x001c0000, /* 0x0df0 */
    0x00000002, 0x00000500, 0x00000000, 0x00000000, /* 0x0e00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e10 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e20 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e50 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e60 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0e90 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0ea0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0eb0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0ec0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0ed0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0ee0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0ef0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f10 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f20 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f50 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f60 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0f90 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0fa0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0fb0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0fc0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0fd0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0fe0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x0ff0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1000 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1010 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x1020 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x1030 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1040 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1050 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x1060 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x1070 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1080 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1090 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x10a0 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x10b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x10c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x10d0 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x10e0 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x10f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1100 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1110 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x1120 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x1130 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1140 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1150 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x1160 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x1170 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1180 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1190 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x11a0 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x11b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x11c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x11d0 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x11e0 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x11f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1200 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1210 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x1220 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x1230 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1240 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1250 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x1260 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x1270 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1280 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1290 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x12a0 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x12b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x12c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x12d0 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x12e0 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x12f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1300 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1310 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x1320 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x1330 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1340 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1350 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x1360 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x1370 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1380 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1390 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x13a0 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x13b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x13c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x13d0 */
    0x00000042, 0x40031087, 0x00000000, 0x00014000, /* 0x13e0 */
    0x00000042, 0x40016081, 0x00000042, 0x40039083, /* 0x13f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1400 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1410 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1420 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1430 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1440 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1450 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1460 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1470 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1480 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1490 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x14a0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x14b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x14c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x14d0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x14e0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x14f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1500 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1510 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1520 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1530 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1540 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1550 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1560 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1570 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1580 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1590 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x15a0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x15b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x15c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x15d0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x15e0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x15f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1600 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1610 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1620 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1630 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1640 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1650 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1660 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1670 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1680 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1690 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x16a0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x16b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x16c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x16d0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x16e0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x16f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1700 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1710 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1720 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1730 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1740 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1750 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1760 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1770 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1780 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1790 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x17a0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x17b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x17c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x17d0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x17e0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x17f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1800 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1810 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1820 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1830 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1840 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1850 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1860 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1870 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1880 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1890 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x18a0 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x18b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x18c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x18d0 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x18e0 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x18f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1900 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1910 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1920 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1930 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1940 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1950 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1960 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1970 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1980 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1990 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x19a0 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x19b0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x19c0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x19d0 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x19e0 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x19f0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1a00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1a10 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1a20 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1a30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1a40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1a50 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1a60 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1a70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1a80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1a90 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1aa0 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1ab0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1ac0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1ad0 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1ae0 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1af0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1b00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1b10 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1b20 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1b30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1b40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1b50 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1b60 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1b70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1b80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1b90 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1ba0 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1bb0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1bc0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1bd0 */
    0x00000042, 0x4000c087, 0x00000000, 0x00013000, /* 0x1be0 */
    0x00000042, 0x40015081, 0x00000042, 0x40019083, /* 0x1bf0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1c00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1c10 */
    0x00000042, 0x4018e087, 0x00000042, 0x46d100d0, /* 0x1c20 */
    0x00000042, 0x40120081, 0x00000042, 0x40198083, /* 0x1c30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1c40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1c50 */
    0x00000042, 0x4019e087, 0x00000000, 0x00000000, /* 0x1c60 */
    0x00000042, 0x40128081, 0x00000042, 0x401aa083, /* 0x1c70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1c80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1c90 */
    0x00000042, 0x4018e087, 0x00000042, 0x46d100d0, /* 0x1ca0 */
    0x00000042, 0x40120081, 0x00000042, 0x40198083, /* 0x1cb0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1cc0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1cd0 */
    0x00000042, 0x4019e087, 0x00000000, 0x00000000, /* 0x1ce0 */
    0x00000042, 0x40128081, 0x00000042, 0x401aa083, /* 0x1cf0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1d00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1d10 */
    0x00000042, 0x4018e087, 0x00000042, 0x46d100d0, /* 0x1d20 */
    0x00000042, 0x40120081, 0x00000042, 0x40198083, /* 0x1d30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1d40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1d50 */
    0x00000042, 0x4019e087, 0x00000000, 0x00000000, /* 0x1d60 */
    0x00000042, 0x40128081, 0x00000042, 0x401aa083, /* 0x1d70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1d80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1d90 */
    0x00000042, 0x4018e087, 0x00000042, 0x46d100d0, /* 0x1da0 */
    0x00000042, 0x40120081, 0x00000042, 0x40198083, /* 0x1db0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1dc0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1dd0 */
    0x00000042, 0x4019e087, 0x00000000, 0x00000000, /* 0x1de0 */
    0x00000042, 0x40128081, 0x00000042, 0x401aa083, /* 0x1df0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1e00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1e10 */
    0x00000042, 0x4018e087, 0x00000042, 0x46d100d0, /* 0x1e20 */
    0x00000042, 0x40120081, 0x00000042, 0x40198083, /* 0x1e30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1e40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1e50 */
    0x00000042, 0x4019e087, 0x00000000, 0x00000000, /* 0x1e60 */
    0x00000042, 0x40128081, 0x00000042, 0x401aa083, /* 0x1e70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1e80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1e90 */
    0x00000042, 0x4018e087, 0x00000042, 0x46d100d0, /* 0x1ea0 */
    0x00000042, 0x40120081, 0x00000042, 0x40198083, /* 0x1eb0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1ec0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1ed0 */
    0x00000042, 0x4019e087, 0x00000000, 0x00000000, /* 0x1ee0 */
    0x00000042, 0x40128081, 0x00000042, 0x401aa083, /* 0x1ef0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1f00 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1f10 */
    0x00000042, 0x4018e087, 0x00000042, 0x46d100d0, /* 0x1f20 */
    0x00000042, 0x40120081, 0x00000042, 0x40198083, /* 0x1f30 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1f40 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1f50 */
    0x00000042, 0x4019e087, 0x00000000, 0x00000000, /* 0x1f60 */
    0x00000042, 0x40128081, 0x00000042, 0x401aa083, /* 0x1f70 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1f80 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1f90 */
    0x00000042, 0x4018e087, 0x00000042, 0x46d100d0, /* 0x1fa0 */
    0x00000042, 0x40120081, 0x00000042, 0x40198083, /* 0x1fb0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1fc0 */
    0x00000000, 0x00000000, 0x00000000, 0x00000000, /* 0x1fd0 */
    0x00000042, 0x4019e087, 0x00000000, 0x00000000, /* 0x1fe0 */
    0x00000042, 0x40128081, 0x00000042, 0x401aa083, /* 0x1ff0 */
};

typedef struct {
    int    ip;            /* instruction buffer index */
    uint32 instruction;   /* instruction buffer content at the above index */
} type1_instruction_t;

/*
 * Instruction format
 * +--------+-----+----------+-----+-----------+
 * |  15:9  | 8:5 |    4     | 3:2 |   1:0     |
 * | OPCODE | DWC | RESERVED | SD  | AD or RSZ |
 * +--------+-----+----------+-----+-----------+
 */
STATIC type1_instruction_t type1_basic_instructions[] = {
    { TYPE1_IP_WRITE_IMA,     0x0c20 },
    { TYPE1_IP_READ_IMA,      0x0800 },
    { -1, 0 }, /* end of table mark */
};

STATIC type1_instruction_t type1_common_instructions[] = {
    { TYPE1_IP_WRITE_DB_D72,  0x1e34 }, /* DWC 1 SD 1 */
    { TYPE1_IP_WRITE_DB_D144, 0x1e58 }, /* DWC 2 SD 2 */
    { TYPE1_IP_WRITE_DB_M72,  0x2634 }, /* DWC 1 SD 1 */
    { TYPE1_IP_WRITE_DB_M144, 0x2658 }, /* DWC 2 SD 2 */
    { TYPE1_IP_READ_DB_D72,   0x1a15 },
    { TYPE1_IP_READ_DB_M72,   0x2215 },
    { TYPE1_IP_WRITE_DB_BMR,  0x3034 },
    { TYPE1_IP_WRITE_DB_REG,  0x0620 },
    { TYPE1_IP_READ_DB_REG,   0x0200 },
    { TYPE1_IP_CLEAR_VALID,   0x3a14 },
    { TYPE1_IP_SEARCH_LPM,    0xc234 }, /* LTR 1 -> LTID 1 BMASK 1 */
    { TYPE1_IP_SEARCH_EPM,    0xc434 }, /* LTR 2 -> LTID 1 BMASK 0 */
    { TYPE1_IP_SEARCH_ACL,    0xc658 }, /* LTR 3 -> LTID 2 BMASK 0 */
    { TYPE1_IP_SEARCH_LPM_H1, 0xca34 }, /* LTR 5 -> LTID 5 BMASK 1 */
    { TYPE1_IP_SEARCH_EPM_H1, 0xcc34 }, /* LTR 6 -> LTID 5 BMASK 0 */
    { TYPE1_IP_SEARCH_ACL_H1, 0xce58 }, /* LTR 7 -> LTID 6 BMASK 0 */
    { TYPE1_IP_NOP,           0x0010 },
    { -1, 0 }, /* end of table mark */
};

STATIC type1_instruction_t type1_subtype1_instructions[] = {
    { TYPE1_IP_SET_VALID,         0x2e14 },
    { -1, 0 }, /* end of table mark */
};

STATIC type1_instruction_t type1_subtype2_instructions[] = {
    { TYPE1_IP_SET_VALID,         0x0010 }, /* use NOP */
    { -1, 0 }, /* end of table mark */
};

STATIC int
type1_er_part_index_to_addr(int cfg, int part, int index, uint32 *addr)
{
    switch (part) {
    case TCAM_PARTITION_RAW:
        *addr = index;
        break;
    case TCAM_PARTITION_LPM:
        if (index > configs[cfg].lpm_entries) {
            return SOC_E_PARAM;
        }
        *addr = configs[cfg].acl_entries * 2 + index;
        break;
    case TCAM_PARTITION_ACL:
        if (index > configs[cfg].acl_entries) {
            return SOC_E_PARAM;
        }
        *addr = index * 2;
        break;
    default:
        return SOC_E_UNAVAIL;
    }
    return SOC_E_NONE;
}

STATIC int
type1_er_tcam_access(int unit, uint32 ipcmd, uint32 ip, uint32 addr,
                     uint32 *data)
{
    int len, i, write;
    uint32 inst_addr[TYPE1_INST_DATA_SIZE_MAX], inst_addr_base;
    uint32 *inst_data, inst_data_buf[TYPE1_INST_DATA_SIZE_MAX];

    write = 1;
    inst_data = inst_data_buf;

    switch (ipcmd) {
    case TYPE1_IPCMD_READ_RESULT:
        write = 0;
        inst_data = data;
        len = 4;
        ip = 0;
        break;
    case TYPE1_IPCMD_WRITE_IB:
        len = 1;
        inst_data[0] = data[0];
        break;
    default:
        switch(ip) {
        case TYPE1_IP_WRITE_IMA:
            if (!data) {
                return SOC_E_PARAM;
            }
            len = 4;
            inst_data[0] = 0;
            inst_data[1] = addr;
            inst_data[2] = data[0];
            inst_data[3] = data[1];
            break;

        case TYPE1_IP_READ_IMA:
            len = 2;
            inst_data[0] = 0;
            inst_data[1] = addr;
            break;

        case TYPE1_IP_WRITE_DB_D72:
        case TYPE1_IP_WRITE_DB_M72:
        case TYPE1_IP_WRITE_DB_BMR:
            if (!data) {
               return SOC_E_PARAM;
            }
            len = 4;
            inst_data[0] = addr;
            inst_data[1] = data[1] << 24 | data[2] >> 8;
            inst_data[2] = data[2] << 24 | data[3] >> 8;
            inst_data[3] = data[3] << 24;
            break;

        case TYPE1_IP_WRITE_DB_D144:
        case TYPE1_IP_WRITE_DB_M144:
            if (!data) {
                return SOC_E_PARAM;
            }
            len = 6;
            inst_data[0] = addr;
            inst_data[1] = data[1] << 24 | data[2] >> 8;
            inst_data[2] = data[2] << 24 | data[3] >> 8;
            inst_data[3] = data[3] << 24 | (data[5] & 0xff) << 16 |
                           data[6] >> 16;
            inst_data[4] = data[6] << 16 | data[7] >> 16;
            inst_data[5] = data[7] << 16;
            break;

        case TYPE1_IP_READ_DB_M72:
        case TYPE1_IP_READ_DB_D72:
        case TYPE1_IP_READ_DB_REG:
        case TYPE1_IP_SET_VALID:
        case TYPE1_IP_CLEAR_VALID:
            len = 2;
            inst_data[0] = addr;
            inst_data[1] = 0;
            break;

        case TYPE1_IP_WRITE_DB_REG:
            len = 4;
            inst_data[0] = addr;
             /* the format is different than in document */
            inst_data[1] = data[0];
            inst_data[2] = data[1];
            inst_data[3] = 0;
            break;

        case TYPE1_IP_SEARCH_EPM:
        case TYPE1_IP_SEARCH_EPM_H1:
        case TYPE1_IP_SEARCH_LPM:
        case TYPE1_IP_SEARCH_LPM_H1:
            len = 4;
            inst_data[0] = data[1] << 24 | data[2] >> 8;
            inst_data[1] = data[2] << 24 | data[3] >> 8;
            inst_data[2] = data[3] << 24;
            inst_data[3] = 0;
            break;

        case TYPE1_IP_SEARCH_ACL:
        case TYPE1_IP_SEARCH_ACL_H1:
            len = 6;
            inst_data[0] = data[1] << 24 | data[2] >> 8;
            inst_data[1] = data[2] << 24 | data[3] >> 8;
            inst_data[2] = data[3] << 24 | (data[5] & 0xff) << 16 |
                           data[6] >> 16;
            inst_data[3] = data[6] << 16 | data[7] >> 16;
            inst_data[4] = data[7] << 16;
            inst_data[5] = 0;
            break;

        case TYPE1_IP_NOP:
        default:
            return SOC_E_PARAM;
        }
    }

    inst_addr_base = MAKE_FIELD(TYPE1_QDR_ADDR_IPCMD, ipcmd) |
                     MAKE_FIELD(TYPE1_QDR_ADDR_IP, ip) |
                     MAKE_FIELD(TYPE1_QDR_ADDR_CNTXT, 0x3f);
    for (i = 0; i < len; i++) {
        inst_addr[i] = inst_addr_base | i;
    }

    if (write) {
        if (SOC_DEBUG_CHECK(SOC_DBG_TCAM)) {
            soc_cm_print("write: ");
            for (i = 0; i < len; i++) {
                if (i && !(i & 3)) {
                    soc_cm_print("\n       ");
                }
                soc_cm_print("%05x: %08x  ", inst_addr[i], inst_data[i]);
            }
            soc_cm_print("\n");
        }
    }

    SOC_IF_ERROR_RETURN(soc_mem_tcam_op(unit, inst_addr, inst_data, len,
                                        write));

    if (!write) {
        if (SOC_DEBUG_CHECK(SOC_DBG_TCAM)) {
            soc_cm_print("read: ");
            for (i = 0; i < 4; i++) {
                soc_cm_print("%05x: %08x  ", inst_addr[i], inst_data[i]);
            }
            soc_cm_print("\n");
        }
    }

    return SOC_E_NONE;
}

STATIC int
type1_er_write_dbreg(int unit, uint32 addr, uint32 d0_msb, uint32 d1_lsb)
{
    uint32 data[2];

    data[0] = d0_msb;
    data[1] = d1_lsb;

    return type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                                TYPE1_IP_WRITE_DB_REG, addr, data);
}

STATIC int
type1_er_write_ima(int unit, uint32 addr, uint32 d0_msb, uint32 d1_lsb)
{
    uint32 data[2];

    data[0] = d0_msb;
    data[1] = d1_lsb;

    return type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                                TYPE1_IP_WRITE_IMA, addr, data);
}

STATIC int
type1_er_read_ima(int unit, uint32 addr, uint32 *d0_msb, uint32 *d1_lsb)
{
    uint32 inst_data[4];

    SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                                             TYPE1_IP_READ_IMA, addr, NULL));
    SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_READ_RESULT,
                                             0, 0, inst_data));

    *d0_msb = inst_data[0];
    *d1_lsb = inst_data[1];

    return SOC_E_NONE;
}

int
soc_er_tcam_type1_write_entry(int unit, int cfg, int part, int index,
                              uint32 *mask, uint32 *data)
{
    soc_tcam_info_t *tcam_info;
    uint32 addr, len, i, ip_mask, ip_data;
    uint32 *ptr0, *ptr1, x[8], y[8];

    if (!mask || !data) {
        return SOC_E_PARAM;
    }

    tcam_info = SOC_CONTROL(unit)->tcam_info;

    SOC_IF_ERROR_RETURN(type1_er_part_index_to_addr(cfg, part, index, &addr));

    switch (part) {
    case TCAM_PARTITION_RAW:
    case TCAM_PARTITION_LPM:
        len = 4;
        ip_mask = TYPE1_IP_WRITE_DB_M72;
        ip_data = TYPE1_IP_WRITE_DB_D72;
        break;
    case TCAM_PARTITION_ACL:
        addr++; /* the last address, not the first address */
        len = 8;
        ip_mask = TYPE1_IP_WRITE_DB_M144;
        ip_data = TYPE1_IP_WRITE_DB_D144;
        break;
    default:
        return SOC_E_UNAVAIL;
    }

    if (tcam_info->subtype == 2) {
        for (i = 0; i < len; i++) {
            x[i] = data[i] & ~mask[i];
            y[i] = ~data[i] & ~mask[i];
        }
        ptr0 = x;
        ptr1 = y;
    } else {
        ptr0 = data;
        ptr1 = mask;
    }

    SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                                             ip_mask, addr, ptr1));
    SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                                             ip_data, addr, ptr0));
    return SOC_E_NONE;
}

int
soc_er_tcam_type1_read_entry(int unit, int cfg, int part, int index,
                             uint32 *mask, uint32 *data, int *valid)
{
    soc_tcam_info_t *tcam_info;
    uint32 addr, dev, len, i;
    uint32 result[4];
    uint32 *ptr0, *ptr1, x[8], y[8];
    static const uint32 valid_bits[4] = {0, 0xff, 0xffffffff, 0xffffffff};

    if (!mask || !data || !valid) {
        return SOC_E_PARAM;
    }

    tcam_info = SOC_CONTROL(unit)->tcam_info;

    SOC_IF_ERROR_RETURN(type1_er_part_index_to_addr(cfg, part, index, &addr));

    switch (part) {
    case TCAM_PARTITION_RAW:
    case TCAM_PARTITION_LPM:
        len = 4;
        break;
    case TCAM_PARTITION_ACL:
        len = 8;
        break;
    default:
        return SOC_E_UNAVAIL;
    }

    if (tcam_info->subtype == 2) {
        ptr0 = x;
        ptr1 = y;
    } else {
        ptr0 = data;
        ptr1 = mask;
    }

    for (i = 0; i < len; i += 4) {
        SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit,
                                                 TYPE1_IPCMD_EXEC_PRIMARY,
                                                 TYPE1_IP_READ_DB_M72,
                                                 addr + (len - 4 - i) / 4,
                                                 NULL));
        SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_READ_RESULT,
                                                 0, 0, &ptr1[i]));
        ptr1[i + 3] = ptr1[i + 2] >> 24 | ptr1[i + 1] << 8;
        ptr1[i + 2] = ptr1[i + 1] >> 24 | ptr1[i] << 8;
        ptr1[i + 1] = ptr1[i] >> 24;
        ptr1[i] = 0;

        SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit,
                                                 TYPE1_IPCMD_EXEC_PRIMARY,
                                                 TYPE1_IP_READ_DB_D72,
                                                 addr + (len - 4 - i) / 4,
                                                 NULL));
        SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_READ_RESULT,
                                                 0, 0, &ptr0[i]));
        ptr0[i + 3] = ptr0[i + 2] >> 24 | ptr0[i + 1] << 8;
        ptr0[i + 2] = ptr0[i + 1] >> 24 | ptr0[i] << 8;
        ptr0[i + 1] = ptr0[i] >> 24;
        ptr0[i] = 0;
    }

    if (tcam_info->subtype == 2) {
        *valid = 0;
        for (i = 1; i < len; i++) {
            if (x[i] != y[i] || x[i] != valid_bits[i & 3]) {
                *valid = 1;
            }
            data[i] = x[i];
            mask[i] = (~x[i] & ~y[i]) & valid_bits[i & 3];
        }
    } else {
        dev = addr / (TYPE1_ST1_BLKS_PER_DEV * TYPE1_ST1_ENTRIES_PER_BLK);
        SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit,
                                                 TYPE1_IPCMD_EXEC_PRIMARY,
                                                 TYPE1_IP_READ_DB_REG,
                                                 TYPE1_DBREG_RESULT_ADDR(dev,
                                                                         0),
                                                 NULL));
        SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_READ_RESULT,
                                                 0, 0, result));
        *valid = ((result[1] >> 14) & 0x01) ^ 0x01;
    }

    return SOC_E_NONE;
}

int
soc_er_tcam_type1_set_valid(int unit, int cfg, int part, int index, int valid)
{
    uint32 addr;

    SOC_IF_ERROR_RETURN(type1_er_part_index_to_addr(cfg, part, index, &addr));

    return type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                                valid ? TYPE1_IP_SET_VALID:
                                        TYPE1_IP_CLEAR_VALID,
                                addr, NULL);
}

int
soc_er_tcam_type1_search_entry(int unit, int cfg, int part, int upper,
                               uint32 *data, int *index)
{
    uint32 ip, result[4];

    if (!data || !index) {
        return SOC_E_PARAM;
    }

    switch (part) {
    case TCAM_PARTITION_LPM:
        ip = upper ? TYPE1_IP_SEARCH_EPM_H1 : TYPE1_IP_SEARCH_EPM;
        break;
    case TCAM_PARTITION_ACL:
        ip = upper ? TYPE1_IP_SEARCH_ACL_H1 : TYPE1_IP_SEARCH_ACL;
        break;
    default:
        return SOC_E_UNAVAIL;
    }

    SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                                             ip, 0, data));
    SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_READ_RESULT,
                                             0, 0, result));

    if ((result[0] & 0xc0000000) != 0x40000000) {
        return SOC_E_NOT_FOUND;
    }

    *index = result[0] & 0xfffff;
    return SOC_E_NONE;
}

int
soc_er_tcam_type1_write_ib(int unit, uint32 ip, uint32 instruction)
{
  return type1_er_tcam_access(unit, TYPE1_IPCMD_WRITE_IB, ip, 0, &instruction);
}

int
soc_er_tcam_type1_write_ima(int unit, uint32 addr, uint32 d0_msb,
                            uint32 d1_lsb)
{
    return type1_er_write_ima(unit, addr, d0_msb, d1_lsb);
}

int
soc_er_tcam_type1_read_ima(int unit, uint32 addr, uint32 *d0_msb,
                           uint32 *d1_lsb)
{
    return type1_er_read_ima(unit, addr, d0_msb, d1_lsb);
}

int
soc_er_tcam_type1_write_dbreg(int unit, uint32 addr, uint32 d0_msb,
                              uint32 d1_lsb)
{
    return type1_er_write_dbreg(unit, addr, d0_msb, d1_lsb);
}

int
soc_er_tcam_type1_read_dbreg(int unit, uint32 addr, uint32 *d0_msb,
                             uint32 *d1_lsb)
{
    uint32 data[4];

    SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                                             TYPE1_IP_READ_DB_REG, addr,
                                             NULL));
    SOC_IF_ERROR_RETURN(type1_er_tcam_access(unit, TYPE1_IPCMD_READ_RESULT,
                                             0, 0, data));

    *d0_msb = (data[0] << 8) | (data[1] >> 24);
    *d1_lsb = (data[1] << 8) | (data[2] >> 24);

    return SOC_E_NONE;
}

STATIC int
type1_er_init_bcm(int unit, int subtype, int slave)
{
    uint32 regv;

    SOC_IF_ERROR_RETURN(READ_TCAM_TYPE1_IP_0r(unit, &regv));
    if (slave) {
        soc_reg_field_set(unit, TCAM_TYPE1_IP_0r, &regv, S72_IPf,
                          TYPE1_IP_SEARCH_LPM_H1);
        soc_reg_field_set(unit, TCAM_TYPE1_IP_0r, &regv, S72_INS_IPf,
                          TYPE1_IP_SEARCH_EPM_H1);
    } else {
        soc_reg_field_set(unit, TCAM_TYPE1_IP_0r, &regv, S72_IPf,
                          TYPE1_IP_SEARCH_LPM);
        soc_reg_field_set(unit, TCAM_TYPE1_IP_0r, &regv, S72_INS_IPf,
                          TYPE1_IP_SEARCH_EPM);
    }
    soc_reg_field_set(unit, TCAM_TYPE1_IP_0r, &regv, WD72_IPf,
                      TYPE1_IP_WRITE_DB_D72);
    soc_reg_field_set(unit, TCAM_TYPE1_IP_0r, &regv, WM72_IPf,
                      TYPE1_IP_WRITE_DB_M72);
    SOC_IF_ERROR_RETURN(WRITE_TCAM_TYPE1_IP_0r(unit, regv));

    SOC_IF_ERROR_RETURN(READ_TCAM_TYPE1_IP_1r(unit, &regv));
    soc_reg_field_set(unit, TCAM_TYPE1_IP_1r, &regv, RD72_IPf,
                      TYPE1_IP_READ_DB_D72);
    soc_reg_field_set(unit, TCAM_TYPE1_IP_1r, &regv, RM72_IPf,
                      TYPE1_IP_READ_DB_M72);
    SOC_IF_ERROR_RETURN(WRITE_TCAM_TYPE1_IP_1r(unit, regv));

    SOC_IF_ERROR_RETURN(READ_TCAM_TYPE1_IP_2r(unit, &regv));
    if (slave) {
        soc_reg_field_set(unit, TCAM_TYPE1_IP_2r, &regv, S144_IPf,
                          TYPE1_IP_SEARCH_ACL_H1);
    } else {
        soc_reg_field_set(unit, TCAM_TYPE1_IP_2r, &regv, S144_IPf,
                          TYPE1_IP_SEARCH_ACL);
    }
    soc_reg_field_set(unit, TCAM_TYPE1_IP_2r, &regv, SET_INVALID_IPf,
                      TYPE1_IP_CLEAR_VALID);
    soc_reg_field_set(unit, TCAM_TYPE1_IP_2r, &regv, SET_VALID_IPf,
                      TYPE1_IP_SET_VALID);
    SOC_IF_ERROR_RETURN(WRITE_TCAM_TYPE1_IP_2r(unit, regv));

    if (subtype == 2) {
        SOC_IF_ERROR_RETURN(READ_EXT_TCAM_CONFIG_0r(unit, &regv));
        soc_reg_field_set(unit, EXT_TCAM_CONFIG_0r, &regv, NETLOGIC_XYf, 1);
        SOC_IF_ERROR_RETURN(WRITE_EXT_TCAM_CONFIG_0r(unit, regv));
    }

    return SOC_E_NONE;
}

STATIC int
type1_er_init_qdr_detect(int unit, int dev, int *subtype)
{
    uint32 data0, data1;
    int i;

    /* load basic instructions (i.e. ima read/wirte) into instruction buffer */
    for (i = 0; type1_basic_instructions[i].ip >= 0; i++) {
        type1_er_tcam_access(unit, TYPE1_IPCMD_WRITE_IB,
                             type1_basic_instructions[i].ip |
                             TYPE1_IMA_BASE(dev),
                             0, &type1_basic_instructions[i].instruction);
    }

    SOC_IF_ERROR_RETURN(type1_er_read_ima(unit,
                                          TYPE1_IMREG_QDR_STATUS_ADDR(dev),
                                          &data0, &data1));
    switch (data1) {
    case TYPE1_IMREG_QDR_STATUS_LSB_5000:
        *subtype = 1;
        break;
    case TYPE1_IMREG_QDR_STATUS_LSB_3280:
        *subtype = 2;
        break;
    default:
        *subtype = 0;
        return SOC_E_UNAVAIL;
    }
    return SOC_E_NONE;
}

STATIC int
type1_er_init_qdr(int unit, int dev, int subtype, int sharing)
{
    volatile uint32 i; /* volatile to avoid NSX vxworks compiler problem */
    uint32 data0, data1;
    type1_instruction_t *inst;
    uint32 *ucode, ucode_len;

    switch (subtype) {
    case 1:
        inst = type1_subtype1_instructions;
        ucode = type1_subtype1_ucode;
        ucode_len = sizeof(type1_subtype1_ucode) / sizeof(uint32);
        break;
    case 2:
        inst = type1_subtype2_instructions;
        ucode = type1_subtype2_ucode;
        ucode_len = sizeof(type1_subtype2_ucode) / sizeof(uint32);
        break;
    default:
        return SOC_E_UNAVAIL;
    }

    /* load common instructions into instruction buffer */
    for (i = 0; type1_common_instructions[i].ip >= 0; i++) {
        type1_er_tcam_access(unit, TYPE1_IPCMD_WRITE_IB,
                             type1_common_instructions[i].ip |
                             TYPE1_IMA_BASE(dev),
                             0, &type1_common_instructions[i].instruction);
    }

    /* load subtype specific instructions into instruction buffer */
    for (; inst->ip >= 0; inst++) {
        type1_er_tcam_access(unit, TYPE1_IPCMD_WRITE_IB,
                             inst->ip | TYPE1_IMA_BASE(dev),
                             0, &inst->instruction);
    }
    SOC_DEBUG(SOC_DBG_TCAM, ("instruction buffer loaded\n"));

    /* clock control register */
    data0 = MAKE_FIELD(TYPE1_IMREG_CLK_CTL_MSB_SRAM_SRC,
                       TYPE1_IMREG_CLK_CTL_SRC_N0_K);
    data1 = MAKE_FIELD(TYPE1_IMREG_CLK_CTL_LSB_SYSTEM_SRC,
                       TYPE1_IMREG_CLK_CTL_SRC_N0_K);
    type1_er_write_ima(unit, TYPE1_IMREG_CLK_CTL_ADDR(dev), data0, data1);

    /* device configuration register: reset the database */
    data0 = MAKE_FIELD(TYPE1_IMREG_DEV_CFG_MSB_SW_RST,
                       TYPE1_IMREG_DEV_CFG_MSB_SW_RST_ON);
    if (subtype == 2) {
        data1 = MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_RSVD1,
                           TYPE1_ST2_IMREG_DEV_CFG_LSB_RSVD1_VALUE) |
                MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_RSVD2,
                           TYPE1_ST2_IMREG_DEV_CFG_LSB_RSVD2_VALUE);
    } else {
        data1 = MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_RSVD1,
                           TYPE1_ST1_IMREG_DEV_CFG_LSB_RSVD1_VALUE);
    }
    if (!sharing) {
        /* Enable NPU1 power save mode since only using NPU0. */
        data1 |= MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_NPU1_PSE, 1);
    }
    type1_er_write_ima(unit, TYPE1_IMREG_DEV_CFG_ADDR(dev), data0, data1);

    SOC_DEBUG(SOC_DBG_TCAM, ("database reset\n"));

    for (i = 0; i < ucode_len; i += 2) {
        if ((i & 0xff) == 0) {
            SOC_DEBUG(SOC_DBG_TCAM, ("loading microcode at %d\n", i >> 1));
        }
        type1_er_write_ima(unit, TYPE1_UCODE_ADDR + i * 4, ucode[i],
                           ucode[i + 1]);
    }

    /* NPU IO parity and FIFO control register */
    data0 = MAKE_FIELD(TYPE1_IMREG_QDR_FIFO_MSB_RSVD,
                       TYPE1_IMREG_QDR_FIFO_MSB_RSVD_VALUE) |
        MAKE_FIELD(TYPE1_IMREG_QDR_FIFO_MSB_MODE, 1) |
        MAKE_FIELD(TYPE1_IMREG_QDR_FIFO_MSB_FCI, 1);
    data1 = MAKE_FIELD(TYPE1_IMREG_QDR_FIFO_LSB_0_AF_OFF, 0x08) |
        MAKE_FIELD(TYPE1_IMREG_QDR_FIFO_LSB_0_AF_ON, 0x0c) |
        MAKE_FIELD(TYPE1_IMREG_QDR_FIFO_LSB_1_AF_OFF, 0x08) |
        MAKE_FIELD(TYPE1_IMREG_QDR_FIFO_LSB_1_AF_ON, 0x0c);
    type1_er_write_ima(unit, TYPE1_IMREG_QDR_FIFO_CTL_ADDR(dev), data0, data1);

    /* QDR IO termination control register*/
    type1_er_write_ima(unit, TYPE1_IMREG_IO_TERM_CTL_ADDR(dev),
                       TYPE1_IMREG_IO_TERM_CTL_INIT_MSB,
                       TYPE1_IMREG_IO_TERM_CTL_INIT_LSB);

    /* device configuration register: reset done, enable ucode */
    data0 = 0;
    if (subtype == 2) {
        data1 = MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_RSVD1,
                           TYPE1_ST2_IMREG_DEV_CFG_LSB_RSVD1_VALUE) |
                MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_RSVD2,
                           TYPE1_ST2_IMREG_DEV_CFG_LSB_RSVD2_VALUE) |
                MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_UCODE_ENA, 1);
    } else {
        data1 = MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_RSVD1,
                           TYPE1_ST1_IMREG_DEV_CFG_LSB_RSVD1_VALUE) |
                MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_UCODE_ENA, 1);
    }
    if (!sharing) {
        /* Enable NPU1 power save mode since only using NPU0. */
        data1 |= MAKE_FIELD(TYPE1_IMREG_DEV_CFG_LSB_NPU1_PSE, 1);
    }
    type1_er_write_ima(unit, TYPE1_IMREG_DEV_CFG_ADDR(dev), data0, data1);

    SOC_DEBUG(SOC_DBG_TCAM, ("common init done\n"));
    return SOC_E_NONE;
}

STATIC int
type1_er_init_config(int unit, int dev, int subtype, int lpm_blks,
                     int acl_blks, int sharing)
{
    int blk;
    int acl_start, acl_mid, acl_end, lpm_start, lpm_mid, lpm_end;
    uint32 data0, data1, bmask_em[4], bmask_lpm[4];

    /* device id register */
    type1_er_write_dbreg(unit, TYPE1_DBREG_DEVID_ADDR(dev), 0, dev);

    /* database configuration register */
    if (subtype == 2) {
        data0 = MAKE_FIELD(TYPE1_DBREG_DBCFG_MSB_XYMODE, 1);
    } else {
        data0 = 0;
    }
    data1 = 1;
    type1_er_write_dbreg(unit, TYPE1_DBREG_DBCFG_ADDR(dev), data0, data1);

    acl_start = 0;
    acl_end = acl_blks + acl_start;
    acl_mid = (acl_start + acl_end) / 2;
    lpm_start = acl_end;
    lpm_end = lpm_blks + lpm_start;
    lpm_mid = (lpm_start + lpm_end) / 2;

    sal_memset(bmask_em, 0, sizeof(bmask_em));
    sal_memset(bmask_lpm, 0, sizeof(bmask_lpm));
    bmask_lpm[3] = 0xfc;

    /*
     * block configuration register and block mask registers for ACL
     * set block mask 0 (TYPE1_ER_BMASK_EM) as exact match
     */
    for (blk = acl_start; blk < acl_end; blk++) {
        /* If TCAM sharing, the number of ACL blocks is split in half.  */
        if (sharing && (blk >= acl_mid)) {
            /* subtype 1 and 2 has the same DBREG_BCFG_LTID field */
            type1_er_write_dbreg(unit, TYPE1_DBREG_BCFG_ADDR(dev, blk), 0,
                                 MAKE_FIELD(TYPE1_ST1_DBREG_BCFG_LTID,
                                            TYPE1_ER_LTID_ACL_H1) |
                                 MAKE_FIELD(TYPE1_DBREG_BCFG_WIDTH,
                                            TYPE1_DBREG_BCFG_WIDTH_144));
        } else {
            /* subtype 1 and 2 has the same DBREG_BCFG_LTID field */
            type1_er_write_dbreg(unit, TYPE1_DBREG_BCFG_ADDR(dev, blk), 0,
                                 MAKE_FIELD(TYPE1_ST1_DBREG_BCFG_LTID,
                                            TYPE1_ER_LTID_ACL) |
                                 MAKE_FIELD(TYPE1_DBREG_BCFG_WIDTH,
                                            TYPE1_DBREG_BCFG_WIDTH_144));
        }
        type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                             TYPE1_IP_WRITE_DB_BMR,
                             TYPE1_DBREG_BMASK_ADDR(dev, blk,
                                                    TYPE1_ER_BMASK_EM),
                             bmask_em);
        type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                             TYPE1_IP_WRITE_DB_BMR,
                             TYPE1_DBREG_BMASK_ADDR(dev, blk,
                                                    TYPE1_ER_BMASK_EM) + 1,
                             bmask_em);
    }

    /*
     * block configuration register and block mask registers for DEFIP
     * set block mask 0 (TYPE1_ER_BMASK_EM) for exact prefix match (EPM)
     * set block mask 1 (TYPE1_ER_BMASK_LPM) to ignore 6-bit prefix for LPM
     */
    for (blk = lpm_start; blk < lpm_end; blk++) {
        /* If TCAM sharing, the number of LPM blocks is split in half.  */
        if (sharing && (blk >= lpm_mid)) {
            /* subtype 1 and 2 has the same DBREG_BCFG_LTID field */
            type1_er_write_dbreg(unit, TYPE1_DBREG_BCFG_ADDR(dev, blk), 0,
                                 MAKE_FIELD(TYPE1_ST1_DBREG_BCFG_LTID,
                                            TYPE1_ER_LTID_LPM_H1) |
                                 MAKE_FIELD(TYPE1_DBREG_BCFG_WIDTH,
                                            TYPE1_DBREG_BCFG_WIDTH_72));
        } else {
            /* subtype 1 and 2 has the same DBREG_BCFG_LTID field */
            type1_er_write_dbreg(unit, TYPE1_DBREG_BCFG_ADDR(dev, blk), 0,
                                 MAKE_FIELD(TYPE1_ST1_DBREG_BCFG_LTID,
                                            TYPE1_ER_LTID_LPM) |
                                 MAKE_FIELD(TYPE1_DBREG_BCFG_WIDTH,
                                            TYPE1_DBREG_BCFG_WIDTH_72));
        }
        type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                             TYPE1_IP_WRITE_DB_BMR,
                             TYPE1_DBREG_BMASK_ADDR(dev, blk,
                                                    TYPE1_ER_BMASK_EM),
                             bmask_em);
        /* Mask prefix-length field for datapath lookups */
        type1_er_tcam_access(unit, TYPE1_IPCMD_EXEC_PRIMARY,
                             TYPE1_IP_WRITE_DB_BMR,
                             TYPE1_DBREG_BMASK_ADDR(dev, blk,
                                                    TYPE1_ER_BMASK_LPM),
                             bmask_lpm);
    }

    /*
     * logical table registers
     *   LTR1 (TYPE1_ER_LTBL_LPM): data path DEFIP LPM lookup
     *   LTR2 (TYPE1_ER_LEBL_EPM): route update exact prefix match lookup
     *   LTR3 (TYPE1_ER_LTBL_ACL): ACL lookup
     * LTR 5 - 7 are for tcam sharing, they have same block mask register index
     * but different logical table id compare to their counterpart in LTR 1 - 3
     *   LTR5 (TYPE1_ER_LTBL_LPM_H1): data path DEFIP LPM lookup
     *   LTR6 (TYPE1_ER_LEBL_EPM_H1): route update exact prefix match lookup
     *   LTR7 (TYPE1_ER_LTBL_ACL_H1): ACL lookup
     */
    switch (subtype) {
    case 1:
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_LPM),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_LPM) |
                             MAKE_FIELD(TYPE1_ST1_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_LPM));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_EPM),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_EM) |
                             MAKE_FIELD(TYPE1_ST1_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_LPM));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_ACL),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_EM) |
                             MAKE_FIELD(TYPE1_ST1_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_ACL));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_LPM_H1),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_LPM) |
                             MAKE_FIELD(TYPE1_ST1_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_LPM_H1));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_EPM_H1),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_EM) |
                             MAKE_FIELD(TYPE1_ST1_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_LPM_H1));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_ACL_H1),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_EM) |
                             MAKE_FIELD(TYPE1_ST1_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_ACL_H1));
        break;
    case 2:
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_LPM),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_LPM) |
                             MAKE_FIELD(TYPE1_ST2_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_LPM));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_EPM),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_EM) |
                             MAKE_FIELD(TYPE1_ST2_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_LPM));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_ACL),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_EM) |
                             MAKE_FIELD(TYPE1_ST2_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_ACL));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_LPM_H1),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_LPM) |
                             MAKE_FIELD(TYPE1_ST2_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_LPM_H1));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_EPM_H1),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_EM) |
                             MAKE_FIELD(TYPE1_ST2_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_LPM_H1));
        type1_er_write_dbreg(unit,
                             TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_ER_LTBL_ACL_H1),
                             0,
                             MAKE_FIELD(TYPE1_DBREG_LTBL_BMASK,
                                        TYPE1_ER_BMASK_EM) |
                             MAKE_FIELD(TYPE1_ST2_DBREG_LTBL_LTID,
                                        TYPE1_ER_LTID_ACL_H1));
        break;
    default:
        break;
    }

    return SOC_E_NONE;
}

int
er_tcam_init_type1(int unit, int cfg)
{
    soc_tcam_info_t *tcam_info;
    int dev, subtype, master, slave, sharing = 0;
    int lpm_blks, acl_blks, entries_per_blk, blks_per_dev;

    tcam_info = SOC_CONTROL(unit)->tcam_info;

    master = soc_property_get(unit, spn_EXT_TCAM_SHARING_MASTER, 0);
    slave = soc_property_get(unit, spn_EXT_TCAM_SHARING_SLAVE, 0);
    if (master || slave) {
        if (!soc_feature(unit, soc_feature_ext_tcam_sharing)) {
            return SOC_E_CONFIG;
        }
        sharing = 1;
    }

    SOC_IF_ERROR_RETURN(type1_er_init_qdr_detect(unit, 0, &subtype));
    tcam_info->subtype = subtype;

    /* Only initialize the TCAM device if we are not TCAM sharing OR
     * we are TCAM sharing and this unit is the master.
     */
    if (!sharing || master) {
        SOC_IF_ERROR_RETURN(type1_er_init_qdr(unit, 0, subtype, sharing));
        switch (subtype) {
        case 1:
             entries_per_blk = TYPE1_ST1_ENTRIES_PER_BLK;
             blks_per_dev = TYPE1_ST1_BLKS_PER_DEV;
             break;
        case 2:
             entries_per_blk = TYPE1_ST2_ENTRIES_PER_BLK;
             blks_per_dev = TYPE1_ST2_BLKS_PER_DEV;
             break;
        default:
            return SOC_E_UNAVAIL;
        }

        lpm_blks = configs[cfg].lpm_entries / entries_per_blk;
        acl_blks = configs[cfg].acl_entries * 2 / entries_per_blk;

        for (dev = 0; dev < configs[cfg].tcams; dev++) {
            if (acl_blks > 0) {
                if (acl_blks >= blks_per_dev) {
                    SOC_IF_ERROR_RETURN(type1_er_init_config(unit, dev,
                                                             subtype,
                                                             0, blks_per_dev,
                                                             sharing));
                    acl_blks -= blks_per_dev;
                } else if (lpm_blks >= (blks_per_dev - acl_blks)) {
                    SOC_IF_ERROR_RETURN(type1_er_init_config(unit, dev,
                                                             subtype,
                                                             blks_per_dev -
                                                             acl_blks,
                                                             acl_blks,
                                                             sharing));
                    lpm_blks -= (blks_per_dev - acl_blks);
                    acl_blks = 0;
                } else {
                    SOC_IF_ERROR_RETURN(type1_er_init_config(unit, dev,
                                                             subtype,
                                                             lpm_blks,
                                                             acl_blks,
                                                             sharing));
                    lpm_blks = 0;
                    acl_blks = 0;
                }
            } else if (lpm_blks > 0) {
                if (lpm_blks >= blks_per_dev) {
                    SOC_IF_ERROR_RETURN(type1_er_init_config(unit, dev,
                                                             subtype,
                                                             blks_per_dev, 0,
                                                             sharing));
                    lpm_blks -= blks_per_dev;
                } else {
                    SOC_IF_ERROR_RETURN(type1_er_init_config(unit, dev,
                                                             subtype,
                                                             lpm_blks, 0,
                                                             sharing));
                    lpm_blks = 0;
                }
            }
        }
    }

    SOC_IF_ERROR_RETURN(type1_er_init_bcm(unit, subtype, slave));

    return SOC_E_NONE;
}

int
soc_er_tcam_type1_memtest(int unit, uint32 pattern1, uint32 pattern2) {
    uint32 d0_msb, d1_lsb;
    int i;

    /* Load "Indirect Mapped Address Write/Read" instructions */
    SOC_IF_ERROR_RETURN(
        soc_er_tcam_type1_write_ib(unit, TYPE1_IP_WRITE_IMA, 0x0c20));
    SOC_IF_ERROR_RETURN(
        soc_er_tcam_type1_write_ib(unit, TYPE1_IP_READ_IMA, 0x0800));

    /* Fill in the remaining instruction buffer space with the patterns */
    pattern1 |= 0x1ffff; /* Instruction buffer is 17-bits wide */
    pattern2 |= 0x1ffff;
    for (i = 0x12; i < 0x40; i += 2) {
        SOC_IF_ERROR_RETURN(type1_er_write_ima(unit, i, 0x0, pattern1));
        SOC_IF_ERROR_RETURN(type1_er_write_ima(unit, i + 1, 0x0, pattern2));
    }
    for (i = 0x12; i < 0x40; i += 2) {
        SOC_IF_ERROR_RETURN(type1_er_read_ima(unit, i, &d0_msb, &d1_lsb));
        if (d1_lsb != pattern1) {
            return SOC_E_FAIL;
        }
        SOC_IF_ERROR_RETURN(type1_er_read_ima(unit, i + 1, &d0_msb, &d1_lsb));
        if (d1_lsb != pattern2) {
            return SOC_E_FAIL;
        }
    }
    return SOC_E_NONE;
}
#endif /* BCM_EASYRIDER_SUPPORT */

#ifdef BCM_TRIUMPH_SUPPORT
STATIC int
type1_tr_enable_next_dev(int unit)
{
    uint32 dbus[2 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[2];
    int inst_index;

    sal_memset(dbus, 0, sizeof(dbus));
    inst_index = 0;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = 0;
    ibus[inst_index++] = TYPE1_OPCODE_ENABLE_NEXT_DEV;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = 0;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    return soc_triumph_tcam_access(unit, TCAM_TR_OP_WRITE, inst_index, 0, 1,
                                   dbus, ibus);
}

/* Can't use regular register write to write bmr if require workaround */
STATIC int
type1_tr_write_bmr(int unit, int addr, uint32 d0_msb, uint32 d1, uint32 d2_lsb)
{
    uint32 dbus[6 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[6];
    int inst_index;

    sal_memset(dbus, 0, sizeof(dbus));
    inst_index = 0;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = d2_lsb & 0xc0000000;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = d1;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = d0_msb;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = d2_lsb & 0xc0000000;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = d1;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = d0_msb;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = d2_lsb & 0xc0000000;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = d1;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = d0_msb;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] |= addr;
    ibus[inst_index++] = TYPE1_OPCODE_WR_REG;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = d2_lsb & 0xc0000000;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = d1;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = d0_msb;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] |= addr;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = d2_lsb;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = d1;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = d0_msb;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = d2_lsb;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = d1;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = d0_msb;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    return soc_triumph_tcam_access(unit, TCAM_TR_OP_WRITE, inst_index, 0, 2,
                                   dbus, ibus);
}

STATIC int
type1_tr_write_reg(int unit, int addr, uint32 d0_msb, uint32 d1, uint32 d2_lsb)
{
    uint32 dbus[4 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[4];
    int inst_index;

    sal_memset(dbus, 0, sizeof(dbus));
    inst_index = 0;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr;
    ibus[inst_index++] = TYPE1_OPCODE_WR_REG;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = d2_lsb;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = d1;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = d0_msb;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = d2_lsb;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = d1;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = d0_msb;
    ibus[inst_index++] = TYPE1_OPCODE_NOP;

    return soc_triumph_tcam_access(unit, TCAM_TR_OP_WRITE, inst_index, 0, 2,
                                   dbus, ibus);
}

STATIC int
type1_tr_read_reg(int unit, int addr, uint32 *d0_msb, uint32 *d1,
                  uint32 *d2_lsb)
{
    uint32 dbus[2 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[2];
    int inst_index;

    sal_memset(dbus, 0, sizeof(dbus));
    inst_index = 0;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr;
    ibus[inst_index++] = TYPE1_OPCODE_RD_REG;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr;
    ibus[inst_index++] = TYPE1_OPCODE_RD_REG;

    SOC_IF_ERROR_RETURN(soc_triumph_tcam_access(unit, TCAM_TR_OP_READ,
                                                inst_index, 0, 9, dbus, ibus));
    *d2_lsb = dbus[0];
    *d1 = dbus[1];
    *d0_msb = dbus[2];
    return SOC_E_NONE;
}

int
soc_tr_tcam_type1_write_entry(int unit, int part, int index, uint32 *mask,
                              uint32 *data)
{
    soc_tcam_info_t *tcam_info;
    uint32 dbus[4 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[4];
    int rv, addr, inst_index, len, offset, i;

    tcam_info = SOC_CONTROL(unit)->tcam_info;
    if (tcam_info == NULL) {
        return SOC_E_INIT;
    }

    if (!mask || !data) {
        return SOC_E_PARAM;
    }

    if (part >= TCAM_PARTITION_COUNT ||
        index >= tcam_info->partitions[part].num_entries) {
        return SOC_E_PARAM;
    }

    addr = (index << tcam_info->partitions[part].tcam_width_shift) +
        tcam_info->partitions[part].tcam_base;
    len = 1 << tcam_info->partitions[part].tcam_width_shift;

    for (i = 0; i < len; i++) {
        sal_memset(dbus, 0, sizeof(dbus));
        inst_index = 0;
        offset = (len - 1 - i) * 4;

        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr + i;
        ibus[inst_index++] = TYPE1_OPCODE_WR_RECORD;

        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = data[offset + 3];
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = data[offset + 2];
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = data[offset + 1];
        ibus[inst_index++] = TYPE1_OPCODE_NOP;

        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = mask[offset + 3];
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = mask[offset + 2];
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = mask[offset + 1];
        ibus[inst_index++] = TYPE1_OPCODE_NOP;

        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = mask[offset + 3];
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = mask[offset + 2];
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = mask[offset + 1];
        ibus[inst_index++] = TYPE1_OPCODE_NOP;

        rv = soc_triumph_tcam_access(unit, TCAM_TR_OP_WRITE, inst_index, 0, 2,
                                     dbus, ibus);
        if (rv < 0) {
            return rv;
        }
    }

    return SOC_E_NONE;
}

int
soc_tr_tcam_type1_read_entry(int unit, int part, int index, uint32 *mask,
                             uint32 *data, int *valid)
{
    soc_tcam_info_t *tcam_info;
    uint32 dbus[2 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[2];
    int rv, addr, inst_index, len, offset, i;
    uint32 d0_msb, d1, d2_lsb;

    tcam_info = SOC_CONTROL(unit)->tcam_info;
    if (tcam_info == NULL) {
        return SOC_E_INIT;
    }

    if (!mask || !data || !valid) {
        return SOC_E_PARAM;
    }

    if (part >= TCAM_PARTITION_COUNT ||
        index >= tcam_info->partitions[part].num_entries) {
        return SOC_E_PARAM;
    }

    addr = (index << tcam_info->partitions[part].tcam_width_shift) +
        tcam_info->partitions[part].tcam_base;
    len = 1 << tcam_info->partitions[part].tcam_width_shift;

    *valid = 1;
    for (i = 0; i < len; i++) {
        sal_memset(dbus, 0, sizeof(dbus));
        inst_index = 0;
        offset = (len - 1 - i) * 4;

        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr + i;
        ibus[inst_index++] = TYPE1_OPCODE_RD_DATA;

        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr + i;
        ibus[inst_index++] = TYPE1_OPCODE_RD_DATA;

        rv = soc_triumph_tcam_access(unit, TCAM_TR_OP_READ, inst_index, 0, 9,
                                     dbus, ibus);
        if (rv < 0) {
            *valid = 0;
            return rv;
        }
        data[offset + 3] = dbus[0];
        data[offset + 2] = dbus[1];
        data[offset + 1] = dbus[2];
        data[offset] = 0;

        sal_memset(dbus, 0, sizeof(dbus));
        inst_index = 0;

        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr + i;
        ibus[inst_index++] = TYPE1_OPCODE_RD_MASK;

        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr + i;
        ibus[inst_index++] = TYPE1_OPCODE_RD_MASK;

        rv = soc_triumph_tcam_access(unit, TCAM_TR_OP_READ, inst_index, 0, 9,
                                     dbus, ibus);
        if (rv < 0) {
            *valid = 0;
            return rv;
        }
        mask[offset + 3] = dbus[0];
        mask[offset + 2] = dbus[1];
        mask[offset + 1] = dbus[2] & 0xff;
        mask[offset] = 0;

        rv = type1_tr_read_reg(unit, TYPE1_DBREG_RESULT_ADDR(0, 0),
                               &d0_msb, &d1, &d2_lsb);
        if (rv < 0) {
            *valid = 0;
            return rv;
        }
        if (d2_lsb & (1 << 22)) {
            *valid = 0;
        }
    }
    return SOC_E_NONE;
}

int
soc_tr_tcam_type1_delete_entry(int unit, int part, int index)
{
    soc_tcam_info_t *tcam_info;
    uint32 dbus[2 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[2];
    int addr, inst_index;

    tcam_info = SOC_CONTROL(unit)->tcam_info;
    if (tcam_info == NULL) {
        return SOC_E_INIT;
    }

    if (part >= TCAM_PARTITION_COUNT ||
        index >= tcam_info->partitions[part].num_entries) {
        return SOC_E_PARAM;
    }

    addr = (index << tcam_info->partitions[part].tcam_width_shift) +
        tcam_info->partitions[part].tcam_base;

    sal_memset(dbus, 0, sizeof(dbus));
    inst_index = 0;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr;
    ibus[inst_index++] = TYPE1_OPCODE_DEL_RECORD;

    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = addr;
    ibus[inst_index++] = TYPE1_OPCODE_DEL_RECORD;

    return soc_triumph_tcam_access(unit, TCAM_TR_OP_WRITE, inst_index, 0, 3,
                                   dbus, ibus);
}

int
soc_tr_tcam_type1_search_entry(int unit, int part0, int part1, uint32 *data,
                               int *index0, int *index1)
{
    soc_tcam_info_t *tcam_info;
    uint32 dbus[8 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[8];
    int op_type, inst_index, ltr, width_shift, len, offset, i;

    tcam_info = SOC_CONTROL(unit)->tcam_info;
    if (tcam_info == NULL) {
        return SOC_E_INIT;
    }

    if (!data || !index0 || !index1) {
        return SOC_E_PARAM;
    }

    switch (part0) {
    case TCAM_PARTITION_RAW:
        switch (part1) {
        case TCAM_PARTITION_ACL_IP4:
            ltr = TYPE1_TR_LTBL_ACL_IP4_FWD_NONE;
            break;
        case TCAM_PARTITION_ACL_IP6S:
            ltr = TYPE1_TR_LTBL_ACL_IP6S_FWD_NONE;
            break;
        case TCAM_PARTITION_ACL_IP6F:
            ltr = TYPE1_TR_LTBL_ACL_IP6F_FWD_NONE;
            break;
        case TCAM_PARTITION_ACL_L2C:
            ltr = TYPE1_TR_LTBL_ACL_L2C_FWD_NONE;
            break;
        case TCAM_PARTITION_ACL_IP4C:
            ltr = TYPE1_TR_LTBL_ACL_IP4C_FWD_NONE;
            break;
        case TCAM_PARTITION_ACL_IP6C:
            ltr = TYPE1_TR_LTBL_ACL_IP6C_FWD_NONE;
            break;
        case TCAM_PARTITION_ACL_L2IP4:
            ltr = TYPE1_TR_LTBL_ACL_L2IP4_FWD_NONE;
            break;
        case TCAM_PARTITION_ACL_L2IP6:
            ltr = TYPE1_TR_LTBL_ACL_L2IP6_FWD_NONE;
            break;
        default:
            return SOC_E_PARAM;
        }
        break;
    case TCAM_PARTITION_FWD_L2:
        switch (part1) {
        case TCAM_PARTITION_RAW:
            /* need to find a way to do TYPE1_TR_LTBL_ACL_NONE_FWD_L2_K2 */
            ltr = TYPE1_TR_LTBL_ACL_NONE_FWD_L2;
            break;
        case TCAM_PARTITION_FWD_IP4:
            if (!tcam_info->mode) { /* not for 500 Mhz */
                return SOC_E_PARAM;
            }
            ltr = TYPE1_TR_LTBL_FWD_IP4_FWD_L2;
            break;
        case TCAM_PARTITION_FWD_IP6U:
            if (!tcam_info->mode) { /* not for 500 Mhz */
                return SOC_E_PARAM;
            }
            ltr = TYPE1_TR_LTBL_FWD_IP6U_FWD_L2;
            break;
        case TCAM_PARTITION_ACL_L2:
            ltr = TYPE1_TR_LTBL_ACL_L2_FWD_L2;
            break;
        case TCAM_PARTITION_ACL_L2C: /* ltr used for software test */
            ltr = TYPE1_TR_LTBL_ACL_L2C_FWD_L2;
            break;
        default:
            return SOC_E_PARAM;
        }
        break;
    case TCAM_PARTITION_FWD_IP4:
        switch (part1) {
        case TCAM_PARTITION_RAW:
            /* need to find a way to do TYPE1_TR_LTBL_ACL_NONE_FWD_IP4_K2 */
            ltr = TYPE1_TR_LTBL_ACL_NONE_FWD_IP4;
            break;
        case TCAM_PARTITION_ACL_IP4:
            ltr = TYPE1_TR_LTBL_ACL_IP4_FWD_IP4;
            break;
        default:
            return SOC_E_PARAM;
        }
        break;
    case TCAM_PARTITION_FWD_IP6U:
        switch (part1) {
        case TCAM_PARTITION_RAW:
            /* need to find a way to do TYPE1_TR_LTBL_ACL_NONE_FWD_IP6U_K4 */
            ltr = TYPE1_TR_LTBL_ACL_NONE_FWD_IP6U;
            break;
        case TCAM_PARTITION_ACL_IP6S:
            ltr = TYPE1_TR_LTBL_ACL_IP6S_FWD_IP6U;
            break;
        case TCAM_PARTITION_ACL_IP6F:
            ltr = TYPE1_TR_LTBL_ACL_IP6F_FWD_IP6U;
            break;
        default:
            return SOC_E_PARAM;
        }
        break;
    case TCAM_PARTITION_FWD_IP6:
        switch (part1) {
        case TCAM_PARTITION_RAW:
            /* need to find a way to do TYPE1_TR_LTBL_ACL_NONE_FWD_IP6_K4 */
            ltr = TYPE1_TR_LTBL_ACL_NONE_FWD_IP6;
            break;
        case TCAM_PARTITION_ACL_IP6F:
            ltr = TYPE1_TR_LTBL_ACL_IP6F_FWD_IP6;
            break;
        default:
            return SOC_E_PARAM;
        }
        break;
    default:
        return SOC_E_PARAM;
    }

    if (part0 == TCAM_PARTITION_RAW) {
        op_type = TCAM_TR_OP_SINGLE_SEARCH1;
    } else  if (part1 == TCAM_PARTITION_RAW) {
        op_type = TCAM_TR_OP_SINGLE_SEARCH0;
    } else {
        op_type = TCAM_TR_OP_PARALLEL_SEARCH;
    }
    width_shift = tcam_info->partitions[part0].tcam_width_shift >
        tcam_info->partitions[part1].tcam_width_shift ?
        tcam_info->partitions[part0].tcam_width_shift :
        tcam_info->partitions[part1].tcam_width_shift;
    len = 1 << width_shift;

    sal_memset(dbus, 0, sizeof(dbus));
    inst_index = 0;
    for (i = 1; i < len; i++) {
        offset = (len - 1 - i) * 4;
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = data[offset + 3];
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = data[offset + 2];
        dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = data[offset + 1];
        ibus[inst_index++] = TYPE1_OPCODE_CMP_WORD(i);
    }

    offset = (len - 1) * 4;
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY] = data[offset + 3];
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 1] = data[offset + 2];
    dbus[inst_index * TCAM_TR_WORDS_PER_ENTRY + 2] = data[offset + 1];
    ibus[inst_index++] = TYPE1_OPCODE_SEARCH(ltr);

    SOC_IF_ERROR_RETURN(soc_triumph_tcam_access(unit, op_type, inst_index,
                                                0, 0, dbus, ibus));
    *index0 = dbus[0] & 0xfffff;
    *index1 = dbus[1] & 0xfffff;
    return SOC_E_NONE;
}

int
soc_tr_tcam_type1_memtest_dpeo(int unit, int num_entries, uint32 oe_map,
                               uint32 *data)
{
    uint32 dbus[8 * TCAM_TR_WORDS_PER_ENTRY];
    int ibus[8];
    int offset, i;

    for (i = 0; i < num_entries; i++) {
        offset = i * 4;
        dbus[i * TCAM_TR_WORDS_PER_ENTRY] = data[offset];
        dbus[i * TCAM_TR_WORDS_PER_ENTRY + 1] = data[offset + 1];
        dbus[i * TCAM_TR_WORDS_PER_ENTRY + 2] = data[offset + 2];
        if (oe_map & (1 << i)) {
            ibus[i] = TYPE1_OPCODE_CMP_WORD(i);
        } else {
            ibus[i] = 0x100;
        }
    }

    return soc_triumph_tcam_access(unit, TCAM_TR_OP_WRITE, num_entries, 0, 0,
                                   dbus, ibus);
}

int
soc_tr_tcam_type1_write_reg(int unit, uint32 addr, uint32 d0_msb, uint32 d1,
                            uint32 d2_lsb)
{
    if (SOC_CONTROL(unit)->tcam_info == NULL) {
        return SOC_E_INIT;
    }

    return type1_tr_write_reg(unit, addr, d0_msb, d1, d2_lsb);
}

int
soc_tr_tcam_type1_read_reg(int unit, uint32 addr, uint32 *d0_msb, uint32 *d1,
                           uint32 *d2_lsb)
{
    if (SOC_CONTROL(unit)->tcam_info == NULL) {
        return SOC_E_INIT;
    }

    return type1_tr_read_reg(unit, addr, d0_msb, d1, d2_lsb);
}

int
tr_tcam_init_type1(int unit)
{
    soc_tcam_info_t *tcam_info;
    soc_tcam_partition_t *partitions;
    int rv, part, tcam_base, entries_per_blk, blks_per_dev, i;
    int dev, blk, blk_base, num_blks, mask_len, valid_mask_len;
    uint32 addr, d0, d1, d2, ltid, width;
    int require_bmr_workaround = FALSE;
    int maj_rev, min_rev;

    tcam_info = SOC_CONTROL(unit)->tcam_info;
    if (tcam_info == NULL) {
        return SOC_E_INIT;
    }
    partitions = tcam_info->partitions;

    entries_per_blk = TYPE1_ST3_ENTRIES_PER_BLK;
    blks_per_dev = TYPE1_ST3_BLKS_PER_DEV;

    /* 1. enable next device only on the first time after tcam reset */
    if (!tcam_info->num_tcams) {
        SOC_IF_ERROR_RETURN(type1_tr_enable_next_dev(unit));
    }

    /* read device model number and size */
    rv = type1_tr_read_reg(unit, TYPE1_DBREG_DBCFG_ADDR(0), &d0, &d1, &d2);
    if (SOC_SUCCESS(rv)) {
        maj_rev = (d2 >> TYPE1_ST3_DBREG_DBCFG_LSB_MAJ_REV_oft) &
            TYPE1_ST3_DBREG_DBCFG_LSB_MAJ_REV_mask;
        min_rev = (d2 >> TYPE1_ST3_DBREG_DBCFG_LSB_MIN_REV_oft) &
            TYPE1_ST3_DBREG_DBCFG_LSB_MIN_REV_mask;
        if (!tcam_info->subtype) {
            switch ((d1 >> TYPE1_ST3_DBREG_DBCFG_MSB_FAMILY_oft) &
                    TYPE1_ST3_DBREG_DBCFG_MSB_FAMILY_mask) {
            case 1:
            default:
                tcam_info->subtype = 3;
                break;
            case 2:
                tcam_info->subtype = 4;
                break;
            }
        }
        switch ((((d1 >> TYPE1_ST3_DBREG_DBCFG_MSB_SIZE_oft) &
                  TYPE1_ST3_DBREG_DBCFG_MSB_SIZE_mask) << 8) |
                ((d2 >> TYPE1_ST3_DBREG_DBCFG_LSB_SIZE_oft) &
                 TYPE1_ST3_DBREG_DBCFG_LSB_SIZE_mask)) {
        case 0x0100: /* 512k 36-bit records (256k 72-bit entries, 18M) */
        default:
            partitions[TCAM_PARTITION_RAW].num_entries = 256 * 1024;
            if (tcam_info->subtype == 4 && maj_rev == 1) {
                /* 1024k 36-bit records (512k 72-bit entries, 36M) */
                partitions[TCAM_PARTITION_RAW].num_entries = 512 * 1024;
            }
            break;
        case 0x0080: /* 256k 36-bit records (128k 72-bit entries, 9M) */
            partitions[TCAM_PARTITION_RAW].num_entries = 128 * 1024;
            break;
        case 0x0010: /* 128k 36-bit records (64k 72-bit entries, 4.5M) */
            partitions[TCAM_PARTITION_RAW].num_entries = 64 * 1024;
            break;
        }
        tcam_info->num_tcams =
            partitions[TCAM_PARTITION_RAW].num_entries /
            (entries_per_blk * blks_per_dev);
        if (tcam_info->subtype == 4 && maj_rev == 2 && min_rev == 1 &&
            (partitions[TCAM_PARTITION_RAW].num_entries == 128 * 1024 ||
             partitions[TCAM_PARTITION_RAW].num_entries == 256 * 1024)) {
            require_bmr_workaround = TRUE;
        }
    } else {
        if (!tcam_info->subtype) {
            tcam_info->subtype = 3;
        }
        tcam_info->num_tcams = 1;
        partitions[TCAM_PARTITION_RAW].num_entries =
            entries_per_blk * blks_per_dev;
    }

    partitions[TCAM_PARTITION_RAW].tcam_width_shift = 0;

    /* 2. device id register and device configuration register */
    for (i = 0; i < tcam_info->num_tcams; i++) {
        addr = TYPE1_DBREG_DEVID_ADDR(i);
        d2 = MAKE_FIELD(TYPE1_DBREG_DEVID_ID, i);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        if (tcam_info->subtype == 4) {
            addr = TYPE1_DBREG_DBCFG_ADDR(i);
            d0 = MAKE_FIELD(TYPE1_ST3_DBREG_DBCFG_TOP8_CMP_ANY, 1) |
                 MAKE_FIELD(TYPE1_ST3_DBREG_DBCFG_TOP8_MAP_KEY, 1);
            d2 = MAKE_FIELD(TYPE1_ST3_DBREG_DBCFG_LSB_FG_PS, 1);
            SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, d0, 0, d2));
        }
    }

    tcam_base = 0;
    for (part = TCAM_PARTITION_RAW + 1; part < TCAM_PARTITION_COUNT; part++) {
        if (!partitions[part].num_entries) {
            continue;
        }
        switch (part) {
        case TCAM_PARTITION_FWD_L2:
        case TCAM_PARTITION_FWD_IP4:
        case TCAM_PARTITION_FWD_IP6U:
            partitions[part].tcam_width_shift = 0;
            break;
        case TCAM_PARTITION_FWD_IP6:
        case TCAM_PARTITION_ACL_L2C:
        case TCAM_PARTITION_ACL_IP4C:
        case TCAM_PARTITION_ACL_IP6C:
            partitions[part].tcam_width_shift = 1;
            break;
        case TCAM_PARTITION_ACL_L2:
        case TCAM_PARTITION_ACL_IP4:
            partitions[part].tcam_width_shift = 2;
            break;
        case TCAM_PARTITION_ACL_IP6S:
        case TCAM_PARTITION_ACL_IP6F:
        case TCAM_PARTITION_ACL_L2IP4:
        case TCAM_PARTITION_ACL_L2IP6:
            partitions[part].tcam_width_shift = 3;
            break;
        default:
            break;
        }

        num_blks = ((partitions[part].num_entries <<
                     partitions[part].tcam_width_shift) +
                    entries_per_blk - 1) / entries_per_blk;
        partitions[part].num_entries_include_pad =
            (num_blks * entries_per_blk) >> partitions[part].tcam_width_shift;
        partitions[part].tcam_base = tcam_base;
        tcam_base += num_blks * entries_per_blk;
    }
    if (tcam_base > partitions[TCAM_PARTITION_RAW].num_entries) {
        soc_cm_debug(DK_ERR, "tr_tcam_init_type1: unit %d number of entries "
                     "configured exceeds physical device size\n",
                     unit);
        return SOC_E_PARAM;
    }

    /*
     * 3. program block configuration registers for all devices
     */
    blk = 0;
    for (part = TCAM_PARTITION_RAW + 1; part < TCAM_PARTITION_COUNT; part++) {
        if (!partitions[part].num_entries) {
            continue;
        }

        switch (part) {
        case TCAM_PARTITION_FWD_L2: ltid = TYPE1_TR_LTID_FWD_L2; break;
        case TCAM_PARTITION_FWD_IP4: ltid = TYPE1_TR_LTID_FWD_IP4; break;
        case TCAM_PARTITION_FWD_IP6U: ltid = TYPE1_TR_LTID_FWD_IP6U; break;
        case TCAM_PARTITION_FWD_IP6: ltid = TYPE1_TR_LTID_FWD_IP6; break;
        case TCAM_PARTITION_ACL_L2: ltid = TYPE1_TR_LTID_ACL_L2; break;
        case TCAM_PARTITION_ACL_IP4: ltid = TYPE1_TR_LTID_ACL_IP4; break;
        case TCAM_PARTITION_ACL_IP6S: ltid = TYPE1_TR_LTID_ACL_IP6S; break;
        case TCAM_PARTITION_ACL_IP6F: ltid = TYPE1_TR_LTID_ACL_IP6F; break;
        case TCAM_PARTITION_ACL_L2C: ltid = TYPE1_TR_LTID_ACL_L2C; break;
        case TCAM_PARTITION_ACL_IP4C: ltid = TYPE1_TR_LTID_ACL_IP4C; break;
        case TCAM_PARTITION_ACL_IP6C: ltid = TYPE1_TR_LTID_ACL_IP6C; break;
        case TCAM_PARTITION_ACL_L2IP4: ltid = TYPE1_TR_LTID_ACL_L2IP4; break;
        case TCAM_PARTITION_ACL_L2IP6: ltid = TYPE1_TR_LTID_ACL_L2IP6; break;
        default: continue;
        }

        switch (partitions[part].tcam_width_shift) {
        case 0: width = TYPE1_DBREG_BCFG_WIDTH_72; break;
        case 1: width = TYPE1_DBREG_BCFG_WIDTH_144; break;
        case 2: width = TYPE1_DBREG_BCFG_WIDTH_288; break;
        case 3: width = TYPE1_DBREG_BCFG_WIDTH_576; break;
        default: continue;
        }

        num_blks = ((partitions[part].num_entries <<
                     partitions[part].tcam_width_shift) +
                    entries_per_blk - 1) / entries_per_blk;
        blk_base = partitions[part].tcam_base /entries_per_blk;
        for (blk = blk_base; blk < blk_base + num_blks; blk++) {
            addr = TYPE1_DBREG_BCFG_ADDR(blk / blks_per_dev,
                                         blk % blks_per_dev);
            d2 = MAKE_FIELD(TYPE1_ST3_DBREG_BCFG_LTID, ltid) |
                 MAKE_FIELD(TYPE1_DBREG_BCFG_WIDTH, width);
            SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));
        }
    }
    /*
     * Fill the unused block configuration registers with zero.
     * Since blocks are arranged in continuously ascending order, all free
     * blocks are at the bottom */
    for (; blk < tcam_info->num_tcams * blks_per_dev; blk++) {
        addr = TYPE1_DBREG_BCFG_ADDR(blk / blks_per_dev, blk % blks_per_dev);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, 0));
    }

    /*
     * 4. program block configuration registers and logical table registers
     * of each device
     */
    for (dev = 0; dev < tcam_info->num_tcams; dev++) {
        /*
         * 4-1. block mask registers
         */
        blk = 0;
        for (part = TCAM_PARTITION_RAW + 1; part < TCAM_PARTITION_COUNT;
             part++) {
            if (!partitions[part].num_entries) {
                continue;
            }

            mask_len = 1 << partitions[part].tcam_width_shift;
            if (part == TCAM_PARTITION_ACL_IP6S) {
                valid_mask_len = 5; /* use only 72 * 5 = 360 bits */
            } else if (part == TCAM_PARTITION_ACL_IP6F ||
                       part == TCAM_PARTITION_ACL_L2IP4 ||
                       part == TCAM_PARTITION_ACL_L2IP6) {
                valid_mask_len = 6; /* use only 72 * 6 = 432 bits */
            } else {
                valid_mask_len = mask_len;
            }

            num_blks = ((partitions[part].num_entries <<
                         partitions[part].tcam_width_shift) +
                        entries_per_blk - 1) / entries_per_blk;
            blk_base = partitions[part].tcam_base /entries_per_blk;
            for (blk = blk_base; blk < blk_base + num_blks; blk++) {
                if (blk /blks_per_dev != dev) {
                    continue;
                }
                addr = TYPE1_DBREG_BMASK_ADDR(dev, blk % blks_per_dev,
                                              TYPE1_TR_BMASK);
                /* useful portion */
                for (i = 0; i < valid_mask_len; i++) {
                    if (require_bmr_workaround) {
                        SOC_IF_ERROR_RETURN(type1_tr_write_bmr(unit, addr + i,
                                                               0, 0, 0));
                    } else {
                        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr + i,
                                                               0, 0, 0));
                    }
                }
                /* unused portion */
                for (; i < mask_len; i++) {
                    if (require_bmr_workaround) {
                        SOC_IF_ERROR_RETURN(type1_tr_write_bmr(unit, addr + i,
                                                               0xff,
                                                               0xffffffff,
                                                               0xffffffff));
                    } else {
                        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr + i,
                                                               0xff,
                                                               0xffffffff,
                                                               0xffffffff));
                    }
                }
            }
        }

        /*
         * 4-2. logical table registers
         */
        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_NONE_FWD_L2);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_L2);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_NONE_FWD_IP4);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_IP4);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_NONE_FWD_IP6U);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_IP6U);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_NONE_FWD_IP6);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_IP6);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_L2_FWD_L2);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_L2) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_L2);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP4_FWD_NONE);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP4);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP4_FWD_IP4);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_IP4) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP4);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP6S_FWD_NONE);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP6S);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP6S_FWD_IP6U);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_IP6U) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP6S);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP6F_FWD_NONE);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP6F);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP6F_FWD_IP6U);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_IP6U) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP6F);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP6F_FWD_IP6);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_IP6) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP6F);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_L2C_FWD_NONE);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_L2C);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP4C_FWD_NONE);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP4C);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_IP6C_FWD_NONE);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_IP6C);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_L2IP4_FWD_NONE);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_L2IP4);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        addr = TYPE1_DBREG_LTBL_ADDR(dev, TYPE1_TR_LTBL_ACL_L2IP6_FWD_NONE);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_L2IP6);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));

        if (tcam_info->subtype == 4) {
            if (tcam_info->mode) { /* 4 cycles per packet - 350 Mhz */
                addr = TYPE1_DBREG_LTBL_ADDR(dev,
                                             TYPE1_TR_LTBL_ACL_NONE_FWD_L2_K2);
                d1 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_KEY, 2);
                d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0,
                                TYPE1_TR_LTID_FWD_L2);
                SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, d1, d2));

                addr =
                    TYPE1_DBREG_LTBL_ADDR(dev,
                                          TYPE1_TR_LTBL_ACL_NONE_FWD_IP4_K2);
                d1 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_KEY, 2);
                d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0,
                                TYPE1_TR_LTID_FWD_IP4);
                SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, d1, d2));

                addr = TYPE1_DBREG_LTBL_ADDR(dev,
                                             TYPE1_TR_LTBL_FWD_IP4_FWD_L2);
                d1 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_PCOMP, 1);
                d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0,
                                TYPE1_TR_LTID_FWD_L2) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1,
                                TYPE1_TR_LTID_FWD_IP4);
                SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, d1, d2));

                addr = TYPE1_DBREG_LTBL_ADDR(dev,
                                             TYPE1_TR_LTBL_FWD_IP6U_FWD_L2);
                d1 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_PCOMP, 1);
                d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0,
                                TYPE1_TR_LTID_FWD_L2) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1,
                                TYPE1_TR_LTID_FWD_IP6U);
                SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, d1, d2));
            } else { /* 6 cycles per packet - 500 Mhz */
                addr =
                    TYPE1_DBREG_LTBL_ADDR(dev,
                                          TYPE1_TR_LTBL_ACL_NONE_FWD_IP6U_K4);
                d1 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_KEY, 4);
                d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0,
                                TYPE1_TR_LTID_FWD_IP6U);
                SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, d1, d2));

                addr =
                    TYPE1_DBREG_LTBL_ADDR(dev,
                                          TYPE1_TR_LTBL_ACL_NONE_FWD_IP6_K4);
                d1 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_KEY, 4);
                d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
                     MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0,
                                TYPE1_TR_LTID_FWD_IP6);
                SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, d1, d2));
            }
        }

        /* logical table registers used for software test */
        addr = TYPE1_DBREG_LTBL_ADDR(dev,  TYPE1_TR_LTBL_ACL_L2C_FWD_L2);
        d2 = MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK0, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID0, TYPE1_TR_LTID_FWD_L2) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_BMASK1, TYPE1_TR_BMASK) |
            MAKE_FIELD(TYPE1_ST3_DBREG_LTBL_LTID1, TYPE1_TR_LTID_ACL_L2C);
        SOC_IF_ERROR_RETURN(type1_tr_write_reg(unit, addr, 0, 0, d2));
    }

    return SOC_E_NONE;
}
#endif /* BCM_TRIUMPH_SUPPORT */
