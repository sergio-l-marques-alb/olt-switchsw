/*
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 * $Id: async_run.c,v 1.1 2011/04/18 17:11:01 mruas Exp $
 * $Copyright: Copyright 2009 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * File:	async_run.c
 * Purpose:	Async BCM - execute a request
 * Generator:	mkdispatch 1.35.18.1
 * Generated:	Thu Mar  5 18:02:57 2009
 */

#include <bcm/types.h>
#include <bcm/async.h>
#include <bcm/auth.h>
#include <bcm/bcmi2c.h>
#include <bcm/cosq.h>
#include <bcm/custom.h>
#include <bcm/diffserv.h>
#include <bcm/dmux.h>
#include <bcm/eav.h>
#include <bcm/error.h>
#include <bcm/fabric.h>
#include <bcm/failover.h>
#include <bcm/field.h>
#include <bcm/filter.h>
#include <bcm/htls.h>
#include <bcm/igmp.h>
#include <bcm/init.h>
#include <bcm/ipfix.h>
#include <bcm/ipmc.h>
#include <bcm/l2.h>
#include <bcm/l3.h>
#include <bcm/link.h>
#include <bcm/macsec.h>
#include <bcm/mcast.h>
#include <bcm/meter.h>
#include <bcm/mim.h>
#include <bcm/mirror.h>
#include <bcm/module.h>
#include <bcm/mpls.h>
#include <bcm/multicast.h>
#include <bcm/oam.h>
#include <bcm/pkt.h>
#include <bcm/policer.h>
#include <bcm/port.h>
#include <bcm/proxy.h>
#include <bcm/qos.h>
#include <bcm/rate.h>
#include <bcm/rx.h>
#include <bcm/stack.h>
#include <bcm/stat.h>
#include <bcm/stg.h>
#include <bcm/subport.h>
#include <bcm/switch.h>
#include <bcm/time.h>
#include <bcm/topo.h>
#include <bcm/trunk.h>
#include <bcm/tunnel.h>
#include <bcm/tx.h>
#include <bcm/vlan.h>
#include <bcm/vswitch.h>
#include <bcm/wlan.h>

#include <bcm_int/async_req.h>
#include <bcm_int/async_server.h>

#include <shared/alloc.h>

#ifdef	BCM_ASYNC_SUPPORT

void
bcm_async_run(bcm_async_req_t *req)
{
	int rv;

	switch (req->type) {
	case BCM_ASYNC_ENTRY_SHUTDOWN:
		rv = _bcm_shutdown(
			req->args._shutdown.unit);
		break;
	case BCM_ASYNC_ENTRY_ATTACH:
		rv = bcm_attach(
			req->args.attach.unit,
			req->args.attach.type,
			req->args.attach.subtype,
			req->args.attach.remunit);
		break;
	case BCM_ASYNC_ENTRY_ATTACH_CHECK:
		rv = bcm_attach_check(
			req->args.attach_check.unit);
		break;
	case BCM_ASYNC_ENTRY_ATTACH_MAX:
		rv = bcm_attach_max(
			req->args.attach_max.max_units);
		break;
	case BCM_ASYNC_ENTRY_AUTH_DETACH:
		rv = bcm_auth_detach(
			req->args.auth_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_AUTH_EGRESS_GET:
		rv = bcm_auth_egress_get(
			req->args.auth_egress_get.unit,
			req->args.auth_egress_get.port,
			req->args.auth_egress_get.enable);
		break;
	case BCM_ASYNC_ENTRY_AUTH_EGRESS_SET:
		rv = bcm_auth_egress_set(
			req->args.auth_egress_set.unit,
			req->args.auth_egress_set.port,
			req->args.auth_egress_set.enable);
		break;
	case BCM_ASYNC_ENTRY_AUTH_INIT:
		rv = bcm_auth_init(
			req->args.auth_init.unit);
		break;
	case BCM_ASYNC_ENTRY_AUTH_MAC_ADD:
		rv = bcm_auth_mac_add(
			req->args.auth_mac_add.unit,
			req->args.auth_mac_add.port,
			req->args.auth_mac_add.mac);
		break;
	case BCM_ASYNC_ENTRY_AUTH_MAC_DELETE:
		rv = bcm_auth_mac_delete(
			req->args.auth_mac_delete.unit,
			req->args.auth_mac_delete.port,
			req->args.auth_mac_delete.mac);
		break;
	case BCM_ASYNC_ENTRY_AUTH_MAC_DELETE_ALL:
		rv = bcm_auth_mac_delete_all(
			req->args.auth_mac_delete_all.unit,
			req->args.auth_mac_delete_all.port);
		break;
	case BCM_ASYNC_ENTRY_AUTH_MODE_GET:
		rv = bcm_auth_mode_get(
			req->args.auth_mode_get.unit,
			req->args.auth_mode_get.port,
			req->args.auth_mode_get.modep);
		break;
	case BCM_ASYNC_ENTRY_AUTH_MODE_SET:
		rv = bcm_auth_mode_set(
			req->args.auth_mode_set.unit,
			req->args.auth_mode_set.port,
			req->args.auth_mode_set.mode);
		break;
	case BCM_ASYNC_ENTRY_AUTH_UNAUTH_CALLBACK:
		rv = bcm_auth_unauth_callback(
			req->args.auth_unauth_callback.unit,
			req->args.auth_unauth_callback.func,
			req->args.auth_unauth_callback.cookie);
		break;
	case BCM_ASYNC_ENTRY_CLEAR:
		rv = bcm_clear(
			req->args.clear.unit);
		break;
	case BCM_ASYNC_ENTRY_COSQ_CONFIG_GET:
		rv = bcm_cosq_config_get(
			req->args.cosq_config_get.unit,
			req->args.cosq_config_get.numq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_CONFIG_SET:
		rv = bcm_cosq_config_set(
			req->args.cosq_config_set.unit,
			req->args.cosq_config_set.numq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_CONTROL_GET:
		rv = bcm_cosq_control_get(
			req->args.cosq_control_get.unit,
			req->args.cosq_control_get.port,
			req->args.cosq_control_get.cosq,
			req->args.cosq_control_get.type,
			req->args.cosq_control_get.arg);
		break;
	case BCM_ASYNC_ENTRY_COSQ_CONTROL_SET:
		rv = bcm_cosq_control_set(
			req->args.cosq_control_set.unit,
			req->args.cosq_control_set.port,
			req->args.cosq_control_set.cosq,
			req->args.cosq_control_set.type,
			req->args.cosq_control_set.arg);
		break;
	case BCM_ASYNC_ENTRY_COSQ_DETACH:
		rv = bcm_cosq_detach(
			req->args.cosq_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_COSQ_DISCARD_GET:
		rv = bcm_cosq_discard_get(
			req->args.cosq_discard_get.unit,
			req->args.cosq_discard_get.flags);
		break;
	case BCM_ASYNC_ENTRY_COSQ_DISCARD_PORT_GET:
		rv = bcm_cosq_discard_port_get(
			req->args.cosq_discard_port_get.unit,
			req->args.cosq_discard_port_get.port,
			req->args.cosq_discard_port_get.cosq,
			req->args.cosq_discard_port_get.color,
			req->args.cosq_discard_port_get.drop_start,
			req->args.cosq_discard_port_get.drop_slope,
			req->args.cosq_discard_port_get.average_time);
		break;
	case BCM_ASYNC_ENTRY_COSQ_DISCARD_PORT_SET:
		rv = bcm_cosq_discard_port_set(
			req->args.cosq_discard_port_set.unit,
			req->args.cosq_discard_port_set.port,
			req->args.cosq_discard_port_set.cosq,
			req->args.cosq_discard_port_set.color,
			req->args.cosq_discard_port_set.drop_start,
			req->args.cosq_discard_port_set.drop_slope,
			req->args.cosq_discard_port_set.average_time);
		break;
	case BCM_ASYNC_ENTRY_COSQ_DISCARD_SET:
		rv = bcm_cosq_discard_set(
			req->args.cosq_discard_set.unit,
			req->args.cosq_discard_set.flags);
		break;
	case BCM_ASYNC_ENTRY_COSQ_FABRIC_DISTRIBUTION_ADD:
		rv = bcm_cosq_fabric_distribution_add(
			req->args.cosq_fabric_distribution_add.unit,
			req->args.cosq_fabric_distribution_add.ds_id,
			req->args.cosq_fabric_distribution_add.num_cos_levels,
			req->args.cosq_fabric_distribution_add.flags,
			req->args.cosq_fabric_distribution_add.req_gport);
		break;
	case BCM_ASYNC_ENTRY_COSQ_FABRIC_DISTRIBUTION_GET:
		rv = bcm_cosq_fabric_distribution_get(
			req->args.cosq_fabric_distribution_get.unit,
			req->args.cosq_fabric_distribution_get.ds_id,
			req->args.cosq_fabric_distribution_get.num_cos_levels,
			req->args.cosq_fabric_distribution_get.req_gport,
			req->args.cosq_fabric_distribution_get.flags);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_ADD:
		rv = bcm_cosq_gport_add(
			req->args.cosq_gport_add.unit,
			req->args.cosq_gport_add.port,
			req->args.cosq_gport_add.numq,
			req->args.cosq_gport_add.flags,
			req->args.cosq_gport_add.gport);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_ATTACH:
		rv = bcm_cosq_gport_attach(
			req->args.cosq_gport_attach.unit,
			req->args.cosq_gport_attach.sched_port,
			req->args.cosq_gport_attach.input_port,
			req->args.cosq_gport_attach.cosq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_ATTACH_GET:
		rv = bcm_cosq_gport_attach_get(
			req->args.cosq_gport_attach_get.unit,
			req->args.cosq_gport_attach_get.sched_port,
			req->args.cosq_gport_attach_get.input_port,
			req->args.cosq_gport_attach_get.cosq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_BANDWIDTH_GET:
		rv = bcm_cosq_gport_bandwidth_get(
			req->args.cosq_gport_bandwidth_get.unit,
			req->args.cosq_gport_bandwidth_get.gport,
			req->args.cosq_gport_bandwidth_get.cosq,
			req->args.cosq_gport_bandwidth_get.kbits_sec_min,
			req->args.cosq_gport_bandwidth_get.kbits_sec_max,
			req->args.cosq_gport_bandwidth_get.flags);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_BANDWIDTH_SET:
		rv = bcm_cosq_gport_bandwidth_set(
			req->args.cosq_gport_bandwidth_set.unit,
			req->args.cosq_gport_bandwidth_set.gport,
			req->args.cosq_gport_bandwidth_set.cosq,
			req->args.cosq_gport_bandwidth_set.kbits_sec_min,
			req->args.cosq_gport_bandwidth_set.kbits_sec_max,
			req->args.cosq_gport_bandwidth_set.flags);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_DELETE:
		rv = bcm_cosq_gport_delete(
			req->args.cosq_gport_delete.unit,
			req->args.cosq_gport_delete.gport);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_DETACH:
		rv = bcm_cosq_gport_detach(
			req->args.cosq_gport_detach.unit,
			req->args.cosq_gport_detach.sched_port,
			req->args.cosq_gport_detach.input_port,
			req->args.cosq_gport_detach.cosq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_DISCARD_GET:
		rv = bcm_cosq_gport_discard_get(
			req->args.cosq_gport_discard_get.unit,
			req->args.cosq_gport_discard_get.gport,
			req->args.cosq_gport_discard_get.cosq,
			req->args.cosq_gport_discard_get.discard);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_DISCARD_SET:
		rv = bcm_cosq_gport_discard_set(
			req->args.cosq_gport_discard_set.unit,
			req->args.cosq_gport_discard_set.gport,
			req->args.cosq_gport_discard_set.cosq,
			req->args.cosq_gport_discard_set.discard);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_ENABLE_GET:
		rv = bcm_cosq_gport_enable_get(
			req->args.cosq_gport_enable_get.unit,
			req->args.cosq_gport_enable_get.gport,
			req->args.cosq_gport_enable_get.cosq,
			req->args.cosq_gport_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_ENABLE_SET:
		rv = bcm_cosq_gport_enable_set(
			req->args.cosq_gport_enable_set.unit,
			req->args.cosq_gport_enable_set.gport,
			req->args.cosq_gport_enable_set.cosq,
			req->args.cosq_gport_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_FLOW_CONTROL_GET:
		rv = bcm_cosq_gport_flow_control_get(
			req->args.cosq_gport_flow_control_get.unit,
			req->args.cosq_gport_flow_control_get.port,
			req->args.cosq_gport_flow_control_get.int_pri,
			req->args.cosq_gport_flow_control_get.flow_control_mask);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_FLOW_CONTROL_SET:
		rv = bcm_cosq_gport_flow_control_set(
			req->args.cosq_gport_flow_control_set.unit,
			req->args.cosq_gport_flow_control_set.port,
			req->args.cosq_gport_flow_control_set.int_pri,
			req->args.cosq_gport_flow_control_set.flow_control_mask);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_GET:
		rv = bcm_cosq_gport_get(
			req->args.cosq_gport_get.unit,
			req->args.cosq_gport_get.gport,
			req->args.cosq_gport_get.physical_port,
			req->args.cosq_gport_get.num_cos_levels,
			req->args.cosq_gport_get.flags);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_SCHED_GET:
		rv = bcm_cosq_gport_sched_get(
			req->args.cosq_gport_sched_get.unit,
			req->args.cosq_gport_sched_get.gport,
			req->args.cosq_gport_sched_get.cosq,
			req->args.cosq_gport_sched_get.mode,
			req->args.cosq_gport_sched_get.weight);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_SCHED_SET:
		rv = bcm_cosq_gport_sched_set(
			req->args.cosq_gport_sched_set.unit,
			req->args.cosq_gport_sched_set.gport,
			req->args.cosq_gport_sched_set.cosq,
			req->args.cosq_gport_sched_set.mode,
			req->args.cosq_gport_sched_set.weight);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_SIZE_GET:
		rv = bcm_cosq_gport_size_get(
			req->args.cosq_gport_size_get.unit,
			req->args.cosq_gport_size_get.gport,
			req->args.cosq_gport_size_get.cosq,
			req->args.cosq_gport_size_get.bytes_min,
			req->args.cosq_gport_size_get.bytes_max);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_SIZE_SET:
		rv = bcm_cosq_gport_size_set(
			req->args.cosq_gport_size_set.unit,
			req->args.cosq_gport_size_set.gport,
			req->args.cosq_gport_size_set.cosq,
			req->args.cosq_gport_size_set.bytes_min,
			req->args.cosq_gport_size_set.bytes_max);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_CONFIG_GET:
		rv = bcm_cosq_gport_stat_config_get(
			req->args.cosq_gport_stat_config_get.unit,
			req->args.cosq_gport_stat_config_get.gport,
			req->args.cosq_gport_stat_config_get.lgl_gport,
			req->args.cosq_gport_stat_config_get.cosq,
			req->args.cosq_gport_stat_config_get.flags,
			req->args.cosq_gport_stat_config_get.profile);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_CONFIG_SET:
		rv = bcm_cosq_gport_stat_config_set(
			req->args.cosq_gport_stat_config_set.unit,
			req->args.cosq_gport_stat_config_set.gport,
			req->args.cosq_gport_stat_config_set.lgl_gport,
			req->args.cosq_gport_stat_config_set.cosq,
			req->args.cosq_gport_stat_config_set.flags,
			req->args.cosq_gport_stat_config_set.profile);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_ENABLE_GET:
		rv = bcm_cosq_gport_stat_enable_get(
			req->args.cosq_gport_stat_enable_get.unit,
			req->args.cosq_gport_stat_enable_get.gport,
			req->args.cosq_gport_stat_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_ENABLE_SET:
		rv = bcm_cosq_gport_stat_enable_set(
			req->args.cosq_gport_stat_enable_set.unit,
			req->args.cosq_gport_stat_enable_set.gport,
			req->args.cosq_gport_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_GET:
		rv = bcm_cosq_gport_stat_get(
			req->args.cosq_gport_stat_get.unit,
			req->args.cosq_gport_stat_get.gport,
			req->args.cosq_gport_stat_get.cosq,
			req->args.cosq_gport_stat_get.stat,
			req->args.cosq_gport_stat_get.value);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STAT_SET:
		rv = bcm_cosq_gport_stat_set(
			req->args.cosq_gport_stat_set.unit,
			req->args.cosq_gport_stat_set.gport,
			req->args.cosq_gport_stat_set.cosq,
			req->args.cosq_gport_stat_set.stat,
			req->args.cosq_gport_stat_set.value);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STATISTIC_GET:
		rv = bcm_cosq_gport_statistic_get(
			req->args.cosq_gport_statistic_get.unit,
			req->args.cosq_gport_statistic_get.gport,
			req->args.cosq_gport_statistic_get.lgl_gport,
			req->args.cosq_gport_statistic_get.cosq,
			req->args.cosq_gport_statistic_get.flags,
			req->args.cosq_gport_statistic_get.stat,
			req->args.cosq_gport_statistic_get.value);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STATISTIC_MULTI_GET:
		rv = bcm_cosq_gport_statistic_multi_get(
			req->args.cosq_gport_statistic_multi_get.unit,
			req->args.cosq_gport_statistic_multi_get.gport,
			req->args.cosq_gport_statistic_multi_get.lgl_gport,
			req->args.cosq_gport_statistic_multi_get.cosq,
			req->args.cosq_gport_statistic_multi_get.stat_count,
			req->args.cosq_gport_statistic_multi_get.stats_array,
			req->args.cosq_gport_statistic_multi_get.value_count,
			req->args.cosq_gport_statistic_multi_get.value_array);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STATISTIC_MULTI_SET:
		rv = bcm_cosq_gport_statistic_multi_set(
			req->args.cosq_gport_statistic_multi_set.unit,
			req->args.cosq_gport_statistic_multi_set.gport,
			req->args.cosq_gport_statistic_multi_set.lgl_gport,
			req->args.cosq_gport_statistic_multi_set.cosq,
			req->args.cosq_gport_statistic_multi_set.stat_count,
			req->args.cosq_gport_statistic_multi_set.stats_array,
			req->args.cosq_gport_statistic_multi_set.value);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_STATISTIC_SET:
		rv = bcm_cosq_gport_statistic_set(
			req->args.cosq_gport_statistic_set.unit,
			req->args.cosq_gport_statistic_set.gport,
			req->args.cosq_gport_statistic_set.lgl_gport,
			req->args.cosq_gport_statistic_set.cosq,
			req->args.cosq_gport_statistic_set.flags,
			req->args.cosq_gport_statistic_set.stat,
			req->args.cosq_gport_statistic_set.value);
		break;
	case BCM_ASYNC_ENTRY_COSQ_GPORT_TRAVERSE:
		rv = bcm_cosq_gport_traverse(
			req->args.cosq_gport_traverse.unit,
			req->args.cosq_gport_traverse.cb,
			req->args.cosq_gport_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_COSQ_INIT:
		rv = bcm_cosq_init(
			req->args.cosq_init.unit);
		break;
	case BCM_ASYNC_ENTRY_COSQ_MAPPING_GET:
		rv = bcm_cosq_mapping_get(
			req->args.cosq_mapping_get.unit,
			req->args.cosq_mapping_get.priority,
			req->args.cosq_mapping_get.cosq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_MAPPING_SET:
		rv = bcm_cosq_mapping_set(
			req->args.cosq_mapping_set.unit,
			req->args.cosq_mapping_set.priority,
			req->args.cosq_mapping_set.cosq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_PORT_BANDWIDTH_GET:
		rv = bcm_cosq_port_bandwidth_get(
			req->args.cosq_port_bandwidth_get.unit,
			req->args.cosq_port_bandwidth_get.port,
			req->args.cosq_port_bandwidth_get.cosq,
			req->args.cosq_port_bandwidth_get.kbits_sec_min,
			req->args.cosq_port_bandwidth_get.kbits_sec_max,
			req->args.cosq_port_bandwidth_get.flags);
		break;
	case BCM_ASYNC_ENTRY_COSQ_PORT_BANDWIDTH_SET:
		rv = bcm_cosq_port_bandwidth_set(
			req->args.cosq_port_bandwidth_set.unit,
			req->args.cosq_port_bandwidth_set.port,
			req->args.cosq_port_bandwidth_set.cosq,
			req->args.cosq_port_bandwidth_set.kbits_sec_min,
			req->args.cosq_port_bandwidth_set.kbits_sec_max,
			req->args.cosq_port_bandwidth_set.flags);
		break;
	case BCM_ASYNC_ENTRY_COSQ_PORT_MAPPING_GET:
		rv = bcm_cosq_port_mapping_get(
			req->args.cosq_port_mapping_get.unit,
			req->args.cosq_port_mapping_get.port,
			req->args.cosq_port_mapping_get.priority,
			req->args.cosq_port_mapping_get.cosq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_PORT_MAPPING_SET:
		rv = bcm_cosq_port_mapping_set(
			req->args.cosq_port_mapping_set.unit,
			req->args.cosq_port_mapping_set.port,
			req->args.cosq_port_mapping_set.priority,
			req->args.cosq_port_mapping_set.cosq);
		break;
	case BCM_ASYNC_ENTRY_COSQ_PORT_SCHED_GET:
		rv = bcm_cosq_port_sched_get(
			req->args.cosq_port_sched_get.unit,
			req->args.cosq_port_sched_get.pbm,
			req->args.cosq_port_sched_get.mode,
			req->args.cosq_port_sched_get.weights,
			req->args.cosq_port_sched_get.delay);
		break;
	case BCM_ASYNC_ENTRY_COSQ_PORT_SCHED_SET:
		rv = bcm_cosq_port_sched_set(
			req->args.cosq_port_sched_set.unit,
			req->args.cosq_port_sched_set.pbm,
			req->args.cosq_port_sched_set.mode,
			req->args.cosq_port_sched_set.weights,
			req->args.cosq_port_sched_set.delay);
		break;
	case BCM_ASYNC_ENTRY_COSQ_SCHED_GET:
		rv = bcm_cosq_sched_get(
			req->args.cosq_sched_get.unit,
			req->args.cosq_sched_get.mode,
			req->args.cosq_sched_get.weights,
			req->args.cosq_sched_get.delay);
		break;
	case BCM_ASYNC_ENTRY_COSQ_SCHED_SET:
		rv = bcm_cosq_sched_set(
			req->args.cosq_sched_set.unit,
			req->args.cosq_sched_set.mode,
			req->args.cosq_sched_set.weights,
			req->args.cosq_sched_set.delay);
		break;
	case BCM_ASYNC_ENTRY_COSQ_SCHED_WEIGHT_MAX_GET:
		rv = bcm_cosq_sched_weight_max_get(
			req->args.cosq_sched_weight_max_get.unit,
			req->args.cosq_sched_weight_max_get.mode,
			req->args.cosq_sched_weight_max_get.weight_max);
		break;
	case BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_MAP_ADD:
		rv = bcm_cosq_subscriber_map_add(
			req->args.cosq_subscriber_map_add.unit,
			req->args.cosq_subscriber_map_add.map);
		break;
	case BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_MAP_DELETE:
		rv = bcm_cosq_subscriber_map_delete(
			req->args.cosq_subscriber_map_delete.unit,
			req->args.cosq_subscriber_map_delete.map);
		break;
	case BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_MAP_DELETE_ALL:
		rv = bcm_cosq_subscriber_map_delete_all(
			req->args.cosq_subscriber_map_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_MAP_GET:
		rv = bcm_cosq_subscriber_map_get(
			req->args.cosq_subscriber_map_get.unit,
			req->args.cosq_subscriber_map_get.map);
		break;
	case BCM_ASYNC_ENTRY_COSQ_SUBSCRIBER_TRAVERSE:
		rv = bcm_cosq_subscriber_traverse(
			req->args.cosq_subscriber_traverse.unit,
			req->args.cosq_subscriber_traverse.cb,
			req->args.cosq_subscriber_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_CUSTOM_PORT_GET:
		rv = bcm_custom_port_get(
			req->args.custom_port_get.unit,
			req->args.custom_port_get.port,
			req->args.custom_port_get.type,
			req->args.custom_port_get.args);
		break;
	case BCM_ASYNC_ENTRY_CUSTOM_PORT_SET:
		rv = bcm_custom_port_set(
			req->args.custom_port_set.unit,
			req->args.custom_port_set.port,
			req->args.custom_port_set.type,
			req->args.custom_port_set.args);
		break;
	case BCM_ASYNC_ENTRY_CUSTOM_REGISTER:
		rv = bcm_custom_register(
			req->args.custom_register.unit,
			req->args.custom_register.func);
		break;
	case BCM_ASYNC_ENTRY_CUSTOM_UNREGISTER:
		rv = bcm_custom_unregister(
			req->args.custom_unregister.unit);
		break;
	case BCM_ASYNC_ENTRY_DETACH:
		rv = bcm_detach(
			req->args.detach.unit);
		break;
	case BCM_ASYNC_ENTRY_DMUX_CONFIG_GET:
		rv = bcm_dmux_config_get(
			req->args.dmux_config_get.unit,
			req->args.dmux_config_get.port,
			req->args.dmux_config_get.flags);
		break;
	case BCM_ASYNC_ENTRY_DMUX_CONFIG_SET:
		rv = bcm_dmux_config_set(
			req->args.dmux_config_set.unit,
			req->args.dmux_config_set.port,
			req->args.dmux_config_set.flags);
		break;
	case BCM_ASYNC_ENTRY_DMUX_DEST_ADD:
		rv = bcm_dmux_dest_add(
			req->args.dmux_dest_add.unit,
			req->args.dmux_dest_add.port,
			req->args.dmux_dest_add.dest_mod,
			req->args.dmux_dest_add.dest_port);
		break;
	case BCM_ASYNC_ENTRY_DMUX_DEST_DELETE:
		rv = bcm_dmux_dest_delete(
			req->args.dmux_dest_delete.unit,
			req->args.dmux_dest_delete.port,
			req->args.dmux_dest_delete.dest_mod,
			req->args.dmux_dest_delete.dest_port);
		break;
	case BCM_ASYNC_ENTRY_DMUX_DEST_DELETE_ALL:
		rv = bcm_dmux_dest_delete_all(
			req->args.dmux_dest_delete_all.unit,
			req->args.dmux_dest_delete_all.port);
		break;
	case BCM_ASYNC_ENTRY_DMUX_DEST_GET:
		rv = bcm_dmux_dest_get(
			req->args.dmux_dest_get.unit,
			req->args.dmux_dest_get.port,
			req->args.dmux_dest_get.dest_mod,
			req->args.dmux_dest_get.dest_pbmp);
		break;
	case BCM_ASYNC_ENTRY_DMUX_DETACH:
		rv = bcm_dmux_detach(
			req->args.dmux_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_DMUX_INIT:
		rv = bcm_dmux_init(
			req->args.dmux_init.unit);
		break;
	case BCM_ASYNC_ENTRY_DS_CLASSIFIER_CREATE:
		rv = bcm_ds_classifier_create(
			req->args.ds_classifier_create.unit,
			req->args.ds_classifier_create.dpid,
			req->args.ds_classifier_create.clfr,
			req->args.ds_classifier_create.inp_actn,
			req->args.ds_classifier_create.outp_actn,
			req->args.ds_classifier_create.nm_actn,
			req->args.ds_classifier_create.cfid);
		break;
	case BCM_ASYNC_ENTRY_DS_CLASSIFIER_CREATE_ID:
		rv = bcm_ds_classifier_create_id(
			req->args.ds_classifier_create_id.unit,
			req->args.ds_classifier_create_id.dpid,
			req->args.ds_classifier_create_id.clfr,
			req->args.ds_classifier_create_id.inp_actn,
			req->args.ds_classifier_create_id.outp_actn,
			req->args.ds_classifier_create_id.nm_actn,
			req->args.ds_classifier_create_id.cfid);
		break;
	case BCM_ASYNC_ENTRY_DS_CLASSIFIER_DELETE:
		rv = bcm_ds_classifier_delete(
			req->args.ds_classifier_delete.unit,
			req->args.ds_classifier_delete.dpid,
			req->args.ds_classifier_delete.cfid);
		break;
	case BCM_ASYNC_ENTRY_DS_CLASSIFIER_GET:
		rv = bcm_ds_classifier_get(
			req->args.ds_classifier_get.unit,
			req->args.ds_classifier_get.dpid,
			req->args.ds_classifier_get.cfid,
			req->args.ds_classifier_get.clfr,
			req->args.ds_classifier_get.inp_actn,
			req->args.ds_classifier_get.outp_actn,
			req->args.ds_classifier_get.nm_actn);
		break;
	case BCM_ASYNC_ENTRY_DS_CLASSIFIER_TRAVERSE:
		rv = bcm_ds_classifier_traverse(
			req->args.ds_classifier_traverse.unit,
			req->args.ds_classifier_traverse.dpid,
			req->args.ds_classifier_traverse.cb,
			req->args.ds_classifier_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_DS_CLASSIFIER_UPDATE:
		rv = bcm_ds_classifier_update(
			req->args.ds_classifier_update.unit,
			req->args.ds_classifier_update.dpid,
			req->args.ds_classifier_update.cfid,
			req->args.ds_classifier_update.flags,
			req->args.ds_classifier_update.inp_actn,
			req->args.ds_classifier_update.outp_actn);
		break;
	case BCM_ASYNC_ENTRY_DS_COUNTER_GET:
		rv = bcm_ds_counter_get(
			req->args.ds_counter_get.unit,
			req->args.ds_counter_get.dpid,
			req->args.ds_counter_get.cfid,
			req->args.ds_counter_get.counter);
		break;
	case BCM_ASYNC_ENTRY_DS_DATAPATH_CREATE:
		rv = bcm_ds_datapath_create(
			req->args.ds_datapath_create.unit,
			req->args.ds_datapath_create.flags,
			req->args.ds_datapath_create.ports,
			req->args.ds_datapath_create.dpid);
		break;
	case BCM_ASYNC_ENTRY_DS_DATAPATH_CREATE_ID:
		rv = bcm_ds_datapath_create_id(
			req->args.ds_datapath_create_id.unit,
			req->args.ds_datapath_create_id.flags,
			req->args.ds_datapath_create_id.ports,
			req->args.ds_datapath_create_id.dpid);
		break;
	case BCM_ASYNC_ENTRY_DS_DATAPATH_DELETE:
		rv = bcm_ds_datapath_delete(
			req->args.ds_datapath_delete.unit,
			req->args.ds_datapath_delete.dpid);
		break;
	case BCM_ASYNC_ENTRY_DS_DATAPATH_INSTALL:
		rv = bcm_ds_datapath_install(
			req->args.ds_datapath_install.unit,
			req->args.ds_datapath_install.dpid);
		break;
	case BCM_ASYNC_ENTRY_DS_DPID_CFID_BIND:
		rv = bcm_ds_dpid_cfid_bind(
			req->args.ds_dpid_cfid_bind.unit,
			req->args.ds_dpid_cfid_bind.mibid,
			req->args.ds_dpid_cfid_bind.dpid,
			req->args.ds_dpid_cfid_bind.cfid);
		break;
	case BCM_ASYNC_ENTRY_DS_DPID_CFID_GET:
		rv = bcm_ds_dpid_cfid_get(
			req->args.ds_dpid_cfid_get.unit,
			req->args.ds_dpid_cfid_get.mibid,
			req->args.ds_dpid_cfid_get.dpid,
			req->args.ds_dpid_cfid_get.cfid);
		break;
	case BCM_ASYNC_ENTRY_DS_DPID_CFID_UNBIND:
		rv = bcm_ds_dpid_cfid_unbind(
			req->args.ds_dpid_cfid_unbind.unit,
			req->args.ds_dpid_cfid_unbind.mibid,
			req->args.ds_dpid_cfid_unbind.dpid,
			req->args.ds_dpid_cfid_unbind.cfid);
		break;
	case BCM_ASYNC_ENTRY_DS_INIT:
		rv = bcm_ds_init(
			req->args.ds_init.unit);
		break;
	case BCM_ASYNC_ENTRY_DS_SCHEDULER_ADD:
		rv = bcm_ds_scheduler_add(
			req->args.ds_scheduler_add.unit,
			req->args.ds_scheduler_add.dpid,
			req->args.ds_scheduler_add.scheduler);
		break;
	case BCM_ASYNC_ENTRY_EAV_BANDWIDTH_GET:
		rv = bcm_eav_bandwidth_get(
			req->args.eav_bandwidth_get.unit,
			req->args.eav_bandwidth_get.port,
			req->args.eav_bandwidth_get.type,
			req->args.eav_bandwidth_get.bytes_sec,
			req->args.eav_bandwidth_get.bytes_burst);
		break;
	case BCM_ASYNC_ENTRY_EAV_BANDWIDTH_SET:
		rv = bcm_eav_bandwidth_set(
			req->args.eav_bandwidth_set.unit,
			req->args.eav_bandwidth_set.port,
			req->args.eav_bandwidth_set.type,
			req->args.eav_bandwidth_set.bytes_sec,
			req->args.eav_bandwidth_set.bytes_burst);
		break;
	case BCM_ASYNC_ENTRY_EAV_CONTROL_GET:
		rv = bcm_eav_control_get(
			req->args.eav_control_get.unit,
			req->args.eav_control_get.type,
			req->args.eav_control_get.arg,
			req->args.eav_control_get.arg2);
		break;
	case BCM_ASYNC_ENTRY_EAV_CONTROL_SET:
		rv = bcm_eav_control_set(
			req->args.eav_control_set.unit,
			req->args.eav_control_set.type,
			req->args.eav_control_set.arg,
			req->args.eav_control_set.arg2);
		break;
	case BCM_ASYNC_ENTRY_EAV_INIT:
		rv = bcm_eav_init(
			req->args.eav_init.unit);
		break;
	case BCM_ASYNC_ENTRY_EAV_LINK_STATUS_GET:
		rv = bcm_eav_link_status_get(
			req->args.eav_link_status_get.unit,
			req->args.eav_link_status_get.port,
			req->args.eav_link_status_get.link);
		break;
	case BCM_ASYNC_ENTRY_EAV_LINK_STATUS_SET:
		rv = bcm_eav_link_status_set(
			req->args.eav_link_status_set.unit,
			req->args.eav_link_status_set.port,
			req->args.eav_link_status_set.link);
		break;
	case BCM_ASYNC_ENTRY_EAV_PCP_MAPPING_GET:
		rv = bcm_eav_pcp_mapping_get(
			req->args.eav_pcp_mapping_get.unit,
			req->args.eav_pcp_mapping_get.type,
			req->args.eav_pcp_mapping_get.pcp,
			req->args.eav_pcp_mapping_get.remapped_pcp);
		break;
	case BCM_ASYNC_ENTRY_EAV_PCP_MAPPING_SET:
		rv = bcm_eav_pcp_mapping_set(
			req->args.eav_pcp_mapping_set.unit,
			req->args.eav_pcp_mapping_set.type,
			req->args.eav_pcp_mapping_set.pcp,
			req->args.eav_pcp_mapping_set.remapped_pcp);
		break;
	case BCM_ASYNC_ENTRY_EAV_PORT_ENABLE_GET:
		rv = bcm_eav_port_enable_get(
			req->args.eav_port_enable_get.unit,
			req->args.eav_port_enable_get.port,
			req->args.eav_port_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_EAV_PORT_ENABLE_SET:
		rv = bcm_eav_port_enable_set(
			req->args.eav_port_enable_set.unit,
			req->args.eav_port_enable_set.port,
			req->args.eav_port_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_EAV_SRP_MAC_ETHERTYPE_GET:
		rv = bcm_eav_srp_mac_ethertype_get(
			req->args.eav_srp_mac_ethertype_get.unit,
			req->args.eav_srp_mac_ethertype_get.mac,
			req->args.eav_srp_mac_ethertype_get.ethertype);
		break;
	case BCM_ASYNC_ENTRY_EAV_SRP_MAC_ETHERTYPE_SET:
		rv = bcm_eav_srp_mac_ethertype_set(
			req->args.eav_srp_mac_ethertype_set.unit,
			req->args.eav_srp_mac_ethertype_set.mac,
			req->args.eav_srp_mac_ethertype_set.ethertype);
		break;
	case BCM_ASYNC_ENTRY_EAV_TIMESTAMP_GET:
		rv = bcm_eav_timestamp_get(
			req->args.eav_timestamp_get.unit,
			req->args.eav_timestamp_get.port,
			req->args.eav_timestamp_get.timestamp);
		break;
	case BCM_ASYNC_ENTRY_EAV_TIMESYNC_MAC_GET:
		rv = bcm_eav_timesync_mac_get(
			req->args.eav_timesync_mac_get.unit,
			req->args.eav_timesync_mac_get.eav_mac);
		break;
	case BCM_ASYNC_ENTRY_EAV_TIMESYNC_MAC_SET:
		rv = bcm_eav_timesync_mac_set(
			req->args.eav_timesync_mac_set.unit,
			req->args.eav_timesync_mac_set.eav_mac);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CALENDAR_ACTIVE:
		rv = bcm_fabric_calendar_active(
			req->args.fabric_calendar_active.unit);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CALENDAR_GET:
		rv = bcm_fabric_calendar_get(
			req->args.fabric_calendar_get.unit,
			req->args.fabric_calendar_get.cindex,
			req->args.fabric_calendar_get.connection,
			req->args.fabric_calendar_get.dest_port,
			req->args.fabric_calendar_get.dest_cosq);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CALENDAR_MAX_GET:
		rv = bcm_fabric_calendar_max_get(
			req->args.fabric_calendar_max_get.unit,
			req->args.fabric_calendar_max_get.max_size);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CALENDAR_MULTI_GET:
		rv = bcm_fabric_calendar_multi_get(
			req->args.fabric_calendar_multi_get.unit,
			req->args.fabric_calendar_multi_get.array_size,
			req->args.fabric_calendar_multi_get.connection_array,
			req->args.fabric_calendar_multi_get.dest_port_array,
			req->args.fabric_calendar_multi_get.dest_cosq_array);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CALENDAR_MULTI_SET:
		rv = bcm_fabric_calendar_multi_set(
			req->args.fabric_calendar_multi_set.unit,
			req->args.fabric_calendar_multi_set.array_size,
			req->args.fabric_calendar_multi_set.connection_array,
			req->args.fabric_calendar_multi_set.dest_port_array,
			req->args.fabric_calendar_multi_set.dest_cosq_array);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CALENDAR_SET:
		rv = bcm_fabric_calendar_set(
			req->args.fabric_calendar_set.unit,
			req->args.fabric_calendar_set.cindex,
			req->args.fabric_calendar_set.connection,
			req->args.fabric_calendar_set.dest_port,
			req->args.fabric_calendar_set.dest_cosq);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CALENDAR_SIZE_GET:
		rv = bcm_fabric_calendar_size_get(
			req->args.fabric_calendar_size_get.unit,
			req->args.fabric_calendar_size_get.config_size);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CALENDAR_SIZE_SET:
		rv = bcm_fabric_calendar_size_set(
			req->args.fabric_calendar_size_set.unit,
			req->args.fabric_calendar_size_set.config_size);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONGESTION_SIZE_GET:
		rv = bcm_fabric_congestion_size_get(
			req->args.fabric_congestion_size_get.unit,
			req->args.fabric_congestion_size_get.module_id,
			req->args.fabric_congestion_size_get.max_ports);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONGESTION_SIZE_SET:
		rv = bcm_fabric_congestion_size_set(
			req->args.fabric_congestion_size_set.unit,
			req->args.fabric_congestion_size_set.module_id,
			req->args.fabric_congestion_size_set.max_ports);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONNECTION_BYTES_GET:
		rv = bcm_fabric_connection_bytes_get(
			req->args.fabric_connection_bytes_get.unit,
			req->args.fabric_connection_bytes_get.src_modid,
			req->args.fabric_connection_bytes_get.dst_modid,
			req->args.fabric_connection_bytes_get.mode,
			req->args.fabric_connection_bytes_get.link_fail_count,
			req->args.fabric_connection_bytes_get.max_bytes);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONNECTION_INTERVAL_GET:
		rv = bcm_fabric_connection_interval_get(
			req->args.fabric_connection_interval_get.unit,
			req->args.fabric_connection_interval_get.link_fail_count,
			req->args.fabric_connection_interval_get.connection_interval);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONNECTION_MAX_GET:
		rv = bcm_fabric_connection_max_get(
			req->args.fabric_connection_max_get.unit,
			req->args.fabric_connection_max_get.link_fail_count,
			req->args.fabric_connection_max_get.connection);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONTROL_GET:
		rv = bcm_fabric_control_get(
			req->args.fabric_control_get.unit,
			req->args.fabric_control_get.type,
			req->args.fabric_control_get.arg);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONTROL_REDUNDANCY_REGISTER:
		rv = bcm_fabric_control_redundancy_register(
			req->args.fabric_control_redundancy_register.unit,
			req->args.fabric_control_redundancy_register.f);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONTROL_REDUNDANCY_UNREGISTER:
		rv = bcm_fabric_control_redundancy_unregister(
			req->args.fabric_control_redundancy_unregister.unit,
			req->args.fabric_control_redundancy_unregister.f);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CONTROL_SET:
		rv = bcm_fabric_control_set(
			req->args.fabric_control_set.unit,
			req->args.fabric_control_set.type,
			req->args.fabric_control_set.arg);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_CONNECTION_GET:
		rv = bcm_fabric_crossbar_connection_get(
			req->args.fabric_crossbar_connection_get.unit,
			req->args.fabric_crossbar_connection_get.xbar,
			req->args.fabric_crossbar_connection_get.src_modid,
			req->args.fabric_crossbar_connection_get.src_xbport,
			req->args.fabric_crossbar_connection_get.dst_modid,
			req->args.fabric_crossbar_connection_get.dst_xbport);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_CONNECTION_SET:
		rv = bcm_fabric_crossbar_connection_set(
			req->args.fabric_crossbar_connection_set.unit,
			req->args.fabric_crossbar_connection_set.xbar,
			req->args.fabric_crossbar_connection_set.src_modid,
			req->args.fabric_crossbar_connection_set.src_xbport,
			req->args.fabric_crossbar_connection_set.dst_modid,
			req->args.fabric_crossbar_connection_set.dst_xbport);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_CONNECTION_STATUS_GET:
		rv = bcm_fabric_crossbar_connection_status_get(
			req->args.fabric_crossbar_connection_status_get.unit,
			req->args.fabric_crossbar_connection_status_get.src_modid,
			req->args.fabric_crossbar_connection_status_get.dst_modid,
			req->args.fabric_crossbar_connection_status_get.mode,
			req->args.fabric_crossbar_connection_status_get.xbars);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_ENABLE_GET:
		rv = bcm_fabric_crossbar_enable_get(
			req->args.fabric_crossbar_enable_get.unit,
			req->args.fabric_crossbar_enable_get.xbars);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_ENABLE_SET:
		rv = bcm_fabric_crossbar_enable_set(
			req->args.fabric_crossbar_enable_set.unit,
			req->args.fabric_crossbar_enable_set.xbars);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_MAPPING_GET:
		rv = bcm_fabric_crossbar_mapping_get(
			req->args.fabric_crossbar_mapping_get.unit,
			req->args.fabric_crossbar_mapping_get.modid,
			req->args.fabric_crossbar_mapping_get.switch_fabric_arbiter_id,
			req->args.fabric_crossbar_mapping_get.xbar,
			req->args.fabric_crossbar_mapping_get.port);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_MAPPING_SET:
		rv = bcm_fabric_crossbar_mapping_set(
			req->args.fabric_crossbar_mapping_set.unit,
			req->args.fabric_crossbar_mapping_set.modid,
			req->args.fabric_crossbar_mapping_set.switch_fabric_arbiter_id,
			req->args.fabric_crossbar_mapping_set.xbar,
			req->args.fabric_crossbar_mapping_set.port);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_CROSSBAR_STATUS_GET:
		rv = bcm_fabric_crossbar_status_get(
			req->args.fabric_crossbar_status_get.unit,
			req->args.fabric_crossbar_status_get.xbars);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_CONTROL_GET:
		rv = bcm_fabric_distribution_control_get(
			req->args.fabric_distribution_control_get.unit,
			req->args.fabric_distribution_control_get.ds_id,
			req->args.fabric_distribution_control_get.type,
			req->args.fabric_distribution_control_get.value);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_CONTROL_SET:
		rv = bcm_fabric_distribution_control_set(
			req->args.fabric_distribution_control_set.unit,
			req->args.fabric_distribution_control_set.ds_id,
			req->args.fabric_distribution_control_set.type,
			req->args.fabric_distribution_control_set.value);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_CREATE:
		rv = bcm_fabric_distribution_create(
			req->args.fabric_distribution_create.unit,
			req->args.fabric_distribution_create.flags,
			req->args.fabric_distribution_create.ds_id);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_DESTROY:
		rv = bcm_fabric_distribution_destroy(
			req->args.fabric_distribution_destroy.unit,
			req->args.fabric_distribution_destroy.ds_id);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_GET:
		rv = bcm_fabric_distribution_get(
			req->args.fabric_distribution_get.unit,
			req->args.fabric_distribution_get.ds_id,
			req->args.fabric_distribution_get.max_count,
			req->args.fabric_distribution_get.dist_modids,
			req->args.fabric_distribution_get.count);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_DISTRIBUTION_SET:
		rv = bcm_fabric_distribution_set(
			req->args.fabric_distribution_set.unit,
			req->args.fabric_distribution_set.ds_id,
			req->args.fabric_distribution_set.modid_count,
			req->args.fabric_distribution_set.dist_modids);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_INIT:
		rv = bcm_fabric_init(
			req->args.fabric_init.unit);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_OPERATING_INTERVAL_GET:
		rv = bcm_fabric_operating_interval_get(
			req->args.fabric_operating_interval_get.unit,
			req->args.fabric_operating_interval_get.link_fail_count,
			req->args.fabric_operating_interval_get.operating_interval);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_PACKET_ADJUST_GET:
		rv = bcm_fabric_packet_adjust_get(
			req->args.fabric_packet_adjust_get.unit,
			req->args.fabric_packet_adjust_get.pkt_adjust_selector,
			req->args.fabric_packet_adjust_get.pkt_adjust_len);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_PACKET_ADJUST_SET:
		rv = bcm_fabric_packet_adjust_set(
			req->args.fabric_packet_adjust_set.unit,
			req->args.fabric_packet_adjust_set.pkt_adjust_selector,
			req->args.fabric_packet_adjust_set.pkt_adjust_len);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_PORT_CREATE:
		rv = bcm_fabric_port_create(
			req->args.fabric_port_create.unit,
			req->args.fabric_port_create.parent_port,
			req->args.fabric_port_create.offset,
			req->args.fabric_port_create.flags,
			req->args.fabric_port_create.port);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_PORT_DESTROY:
		rv = bcm_fabric_port_destroy(
			req->args.fabric_port_destroy.unit,
			req->args.fabric_port_destroy.parent_port);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_PORT_FAILOVER_GET:
		rv = bcm_fabric_port_failover_get(
			req->args.fabric_port_failover_get.unit,
			req->args.fabric_port_failover_get.port,
			req->args.fabric_port_failover_get.failover_id,
			req->args.fabric_port_failover_get.failover_port);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_PORT_FAILOVER_SET:
		rv = bcm_fabric_port_failover_set(
			req->args.fabric_port_failover_set.unit,
			req->args.fabric_port_failover_set.port,
			req->args.fabric_port_failover_set.failover_id,
			req->args.fabric_port_failover_set.failover_port);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_TDM_ENABLE_GET:
		rv = bcm_fabric_tdm_enable_get(
			req->args.fabric_tdm_enable_get.unit,
			req->args.fabric_tdm_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_FABRIC_TDM_ENABLE_SET:
		rv = bcm_fabric_tdm_enable_set(
			req->args.fabric_tdm_enable_set.unit,
			req->args.fabric_tdm_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_FAILOVER_CLEANUP:
		rv = bcm_failover_cleanup(
			req->args.failover_cleanup.unit);
		break;
	case BCM_ASYNC_ENTRY_FAILOVER_CREATE:
		rv = bcm_failover_create(
			req->args.failover_create.unit,
			req->args.failover_create.flags,
			req->args.failover_create.failover_id);
		break;
	case BCM_ASYNC_ENTRY_FAILOVER_DESTROY:
		rv = bcm_failover_destroy(
			req->args.failover_destroy.unit,
			req->args.failover_destroy.failover_id);
		break;
	case BCM_ASYNC_ENTRY_FAILOVER_GET:
		rv = bcm_failover_get(
			req->args.failover_get.unit,
			req->args.failover_get.failover_id,
			req->args.failover_get.enable);
		break;
	case BCM_ASYNC_ENTRY_FAILOVER_INIT:
		rv = bcm_failover_init(
			req->args.failover_init.unit);
		break;
	case BCM_ASYNC_ENTRY_FAILOVER_SET:
		rv = bcm_failover_set(
			req->args.failover_set.unit,
			req->args.failover_set.failover_id,
			req->args.failover_set.enable);
		break;
	case BCM_ASYNC_ENTRY_FFPCOUNTER_CREATE:
		rv = bcm_ffpcounter_create(
			req->args.ffpcounter_create.unit,
			req->args.ffpcounter_create.port,
			req->args.ffpcounter_create.ffpcounterid);
		break;
	case BCM_ASYNC_ENTRY_FFPCOUNTER_DELETE:
		rv = bcm_ffpcounter_delete(
			req->args.ffpcounter_delete.unit,
			req->args.ffpcounter_delete.port,
			req->args.ffpcounter_delete.ffpcounterid);
		break;
	case BCM_ASYNC_ENTRY_FFPCOUNTER_DELETE_ALL:
		rv = bcm_ffpcounter_delete_all(
			req->args.ffpcounter_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_FFPCOUNTER_GET:
		rv = bcm_ffpcounter_get(
			req->args.ffpcounter_get.unit,
			req->args.ffpcounter_get.port,
			req->args.ffpcounter_get.ffpcounterid,
			req->args.ffpcounter_get.val);
		break;
	case BCM_ASYNC_ENTRY_FFPCOUNTER_INIT:
		rv = bcm_ffpcounter_init(
			req->args.ffpcounter_init.unit);
		break;
	case BCM_ASYNC_ENTRY_FFPCOUNTER_SET:
		rv = bcm_ffpcounter_set(
			req->args.ffpcounter_set.unit,
			req->args.ffpcounter_set.port,
			req->args.ffpcounter_set.ffpcounterid,
			req->args.ffpcounter_set.val);
		break;
	case BCM_ASYNC_ENTRY_FFPPACKETCOUNTER_GET:
		rv = bcm_ffppacketcounter_get(
			req->args.ffppacketcounter_get.unit,
			req->args.ffppacketcounter_get.port,
			req->args.ffppacketcounter_get.mid,
			req->args.ffppacketcounter_get.val);
		break;
	case BCM_ASYNC_ENTRY_FFPPACKETCOUNTER_SET:
		rv = bcm_ffppacketcounter_set(
			req->args.ffppacketcounter_set.unit,
			req->args.ffppacketcounter_set.port,
			req->args.ffppacketcounter_set.mid,
			req->args.ffppacketcounter_set.val);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_ADD:
		rv = bcm_field_action_add(
			req->args.field_action_add.unit,
			req->args.field_action_add.entry,
			req->args.field_action_add.action,
			req->args.field_action_add.param0,
			req->args.field_action_add.param1);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_DELETE:
		rv = bcm_field_action_delete(
			req->args.field_action_delete.unit,
			req->args.field_action_delete.entry,
			req->args.field_action_delete.action,
			req->args.field_action_delete.param0,
			req->args.field_action_delete.param1);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_GET:
		rv = bcm_field_action_get(
			req->args.field_action_get.unit,
			req->args.field_action_get.entry,
			req->args.field_action_get.action,
			req->args.field_action_get.param0,
			req->args.field_action_get.param1);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_MAC_ADD:
		rv = bcm_field_action_mac_add(
			req->args.field_action_mac_add.unit,
			req->args.field_action_mac_add.entry,
			req->args.field_action_mac_add.action,
			req->args.field_action_mac_add.mac);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_MAC_GET:
		rv = bcm_field_action_mac_get(
			req->args.field_action_mac_get.unit,
			req->args.field_action_mac_get.entry,
			req->args.field_action_mac_get.action,
			req->args.field_action_mac_get.mac);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_PORTS_ADD:
		rv = bcm_field_action_ports_add(
			req->args.field_action_ports_add.unit,
			req->args.field_action_ports_add.entry,
			req->args.field_action_ports_add.action,
			req->args.field_action_ports_add.pbmp);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_PORTS_GET:
		rv = bcm_field_action_ports_get(
			req->args.field_action_ports_get.unit,
			req->args.field_action_ports_get.entry,
			req->args.field_action_ports_get.action,
			req->args.field_action_ports_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_REMOVE:
		rv = bcm_field_action_remove(
			req->args.field_action_remove.unit,
			req->args.field_action_remove.entry,
			req->args.field_action_remove.action);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ACTION_REMOVE_ALL:
		rv = bcm_field_action_remove_all(
			req->args.field_action_remove_all.unit,
			req->args.field_action_remove_all.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_CONTROL_GET:
		rv = bcm_field_control_get(
			req->args.field_control_get.unit,
			req->args.field_control_get.control,
			req->args.field_control_get.state);
		break;
	case BCM_ASYNC_ENTRY_FIELD_CONTROL_SET:
		rv = bcm_field_control_set(
			req->args.field_control_set.unit,
			req->args.field_control_set.control,
			req->args.field_control_set.state);
		break;
	case BCM_ASYNC_ENTRY_FIELD_COUNTER_CREATE:
		rv = bcm_field_counter_create(
			req->args.field_counter_create.unit,
			req->args.field_counter_create.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_COUNTER_DESTROY:
		rv = bcm_field_counter_destroy(
			req->args.field_counter_destroy.unit,
			req->args.field_counter_destroy.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_COUNTER_GET:
		rv = bcm_field_counter_get(
			req->args.field_counter_get.unit,
			req->args.field_counter_get.entry,
			req->args.field_counter_get.counter_num,
			req->args.field_counter_get.valp);
		break;
	case BCM_ASYNC_ENTRY_FIELD_COUNTER_GET32:
		rv = bcm_field_counter_get32(
			req->args.field_counter_get32.unit,
			req->args.field_counter_get32.entry,
			req->args.field_counter_get32.counter_num,
			req->args.field_counter_get32.valp);
		break;
	case BCM_ASYNC_ENTRY_FIELD_COUNTER_SET:
		rv = bcm_field_counter_set(
			req->args.field_counter_set.unit,
			req->args.field_counter_set.entry,
			req->args.field_counter_set.counter_num,
			req->args.field_counter_set.val);
		break;
	case BCM_ASYNC_ENTRY_FIELD_COUNTER_SET32:
		rv = bcm_field_counter_set32(
			req->args.field_counter_set32.unit,
			req->args.field_counter_set32.entry,
			req->args.field_counter_set32.counter_num,
			req->args.field_counter_set32.val);
		break;
	case BCM_ASYNC_ENTRY_FIELD_COUNTER_SHARE:
		rv = bcm_field_counter_share(
			req->args.field_counter_share.unit,
			req->args.field_counter_share.src_entry,
			req->args.field_counter_share.dst_entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_CREATE:
		rv = bcm_field_data_qualifier_create(
			req->args.field_data_qualifier_create.unit,
			req->args.field_data_qualifier_create.data_qualifier);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_DESTROY:
		rv = bcm_field_data_qualifier_destroy(
			req->args.field_data_qualifier_destroy.unit,
			req->args.field_data_qualifier_destroy.qual_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_DESTROY_ALL:
		rv = bcm_field_data_qualifier_destroy_all(
			req->args.field_data_qualifier_destroy_all.unit);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_ETHERTYPE_ADD:
		rv = bcm_field_data_qualifier_ethertype_add(
			req->args.field_data_qualifier_ethertype_add.unit,
			req->args.field_data_qualifier_ethertype_add.qual_id,
			req->args.field_data_qualifier_ethertype_add.etype);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_ETHERTYPE_DELETE:
		rv = bcm_field_data_qualifier_ethertype_delete(
			req->args.field_data_qualifier_ethertype_delete.unit,
			req->args.field_data_qualifier_ethertype_delete.qual_id,
			req->args.field_data_qualifier_ethertype_delete.etype);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_IP_PROTOCOL_ADD:
		rv = bcm_field_data_qualifier_ip_protocol_add(
			req->args.field_data_qualifier_ip_protocol_add.unit,
			req->args.field_data_qualifier_ip_protocol_add.qual_id,
			req->args.field_data_qualifier_ip_protocol_add.ip_protocol);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_IP_PROTOCOL_DELETE:
		rv = bcm_field_data_qualifier_ip_protocol_delete(
			req->args.field_data_qualifier_ip_protocol_delete.unit,
			req->args.field_data_qualifier_ip_protocol_delete.qual_id,
			req->args.field_data_qualifier_ip_protocol_delete.ip_protocol);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_PACKET_FORMAT_ADD:
		rv = bcm_field_data_qualifier_packet_format_add(
			req->args.field_data_qualifier_packet_format_add.unit,
			req->args.field_data_qualifier_packet_format_add.qual_id,
			req->args.field_data_qualifier_packet_format_add.packet_format);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DATA_QUALIFIER_PACKET_FORMAT_DELETE:
		rv = bcm_field_data_qualifier_packet_format_delete(
			req->args.field_data_qualifier_packet_format_delete.unit,
			req->args.field_data_qualifier_packet_format_delete.qual_id,
			req->args.field_data_qualifier_packet_format_delete.packet_format);
		break;
	case BCM_ASYNC_ENTRY_FIELD_DETACH:
		rv = bcm_field_detach(
			req->args.field_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_COPY:
		rv = bcm_field_entry_copy(
			req->args.field_entry_copy.unit,
			req->args.field_entry_copy.src_entry,
			req->args.field_entry_copy.dst_entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_COPY_ID:
		rv = bcm_field_entry_copy_id(
			req->args.field_entry_copy_id.unit,
			req->args.field_entry_copy_id.src_entry,
			req->args.field_entry_copy_id.dst_entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_CREATE:
		rv = bcm_field_entry_create(
			req->args.field_entry_create.unit,
			req->args.field_entry_create.group,
			req->args.field_entry_create.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_CREATE_ID:
		rv = bcm_field_entry_create_id(
			req->args.field_entry_create_id.unit,
			req->args.field_entry_create_id.group,
			req->args.field_entry_create_id.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_DESTROY:
		rv = bcm_field_entry_destroy(
			req->args.field_entry_destroy.unit,
			req->args.field_entry_destroy.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_DESTROY_ALL:
		rv = bcm_field_entry_destroy_all(
			req->args.field_entry_destroy_all.unit);
		break;
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_DUMP:
		rv = bcm_field_entry_dump(
			req->args.field_entry_dump.unit,
			req->args.field_entry_dump.entry);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_INSTALL:
		rv = bcm_field_entry_install(
			req->args.field_entry_install.unit,
			req->args.field_entry_install.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_POLICER_ATTACH:
		rv = bcm_field_entry_policer_attach(
			req->args.field_entry_policer_attach.unit,
			req->args.field_entry_policer_attach.entry_id,
			req->args.field_entry_policer_attach.level,
			req->args.field_entry_policer_attach.policer_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_POLICER_DETACH:
		rv = bcm_field_entry_policer_detach(
			req->args.field_entry_policer_detach.unit,
			req->args.field_entry_policer_detach.entry_id,
			req->args.field_entry_policer_detach.level);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_POLICER_DETACH_ALL:
		rv = bcm_field_entry_policer_detach_all(
			req->args.field_entry_policer_detach_all.unit,
			req->args.field_entry_policer_detach_all.entry_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_POLICER_GET:
		rv = bcm_field_entry_policer_get(
			req->args.field_entry_policer_get.unit,
			req->args.field_entry_policer_get.entry_id,
			req->args.field_entry_policer_get.level,
			req->args.field_entry_policer_get.policer_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_PRIO_GET:
		rv = bcm_field_entry_prio_get(
			req->args.field_entry_prio_get.unit,
			req->args.field_entry_prio_get.entry,
			req->args.field_entry_prio_get.prio);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_PRIO_SET:
		rv = bcm_field_entry_prio_set(
			req->args.field_entry_prio_set.unit,
			req->args.field_entry_prio_set.entry,
			req->args.field_entry_prio_set.prio);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_REINSTALL:
		rv = bcm_field_entry_reinstall(
			req->args.field_entry_reinstall.unit,
			req->args.field_entry_reinstall.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_REMOVE:
		rv = bcm_field_entry_remove(
			req->args.field_entry_remove.unit,
			req->args.field_entry_remove.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_STAT_ATTACH:
		rv = bcm_field_entry_stat_attach(
			req->args.field_entry_stat_attach.unit,
			req->args.field_entry_stat_attach.entry,
			req->args.field_entry_stat_attach.stat_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_STAT_DETACH:
		rv = bcm_field_entry_stat_detach(
			req->args.field_entry_stat_detach.unit,
			req->args.field_entry_stat_detach.entry,
			req->args.field_entry_stat_detach.stat_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_ENTRY_STAT_GET:
		rv = bcm_field_entry_stat_get(
			req->args.field_entry_stat_get.unit,
			req->args.field_entry_stat_get.entry,
			req->args.field_entry_stat_get.stat_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_COMPRESS:
		rv = bcm_field_group_compress(
			req->args.field_group_compress.unit,
			req->args.field_group_compress.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_CREATE:
		rv = bcm_field_group_create(
			req->args.field_group_create.unit,
			req->args.field_group_create.qset,
			req->args.field_group_create.pri,
			req->args.field_group_create.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_CREATE_ID:
		rv = bcm_field_group_create_id(
			req->args.field_group_create_id.unit,
			req->args.field_group_create_id.qset,
			req->args.field_group_create_id.pri,
			req->args.field_group_create_id.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_CREATE_MODE:
		rv = bcm_field_group_create_mode(
			req->args.field_group_create_mode.unit,
			req->args.field_group_create_mode.qset,
			req->args.field_group_create_mode.pri,
			req->args.field_group_create_mode.mode,
			req->args.field_group_create_mode.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_CREATE_MODE_ID:
		rv = bcm_field_group_create_mode_id(
			req->args.field_group_create_mode_id.unit,
			req->args.field_group_create_mode_id.qset,
			req->args.field_group_create_mode_id.pri,
			req->args.field_group_create_mode_id.mode,
			req->args.field_group_create_mode_id.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_DESTROY:
		rv = bcm_field_group_destroy(
			req->args.field_group_destroy.unit,
			req->args.field_group_destroy.group);
		break;
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_FIELD_GROUP_DUMP:
		rv = bcm_field_group_dump(
			req->args.field_group_dump.unit,
			req->args.field_group_dump.group);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_FIELD_GROUP_ENABLE_GET:
		rv = bcm_field_group_enable_get(
			req->args.field_group_enable_get.unit,
			req->args.field_group_enable_get.group,
			req->args.field_group_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_ENABLE_SET:
		rv = bcm_field_group_enable_set(
			req->args.field_group_enable_set.unit,
			req->args.field_group_enable_set.group,
			req->args.field_group_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_FLUSH:
		rv = bcm_field_group_flush(
			req->args.field_group_flush.unit,
			req->args.field_group_flush.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_GET:
		rv = bcm_field_group_get(
			req->args.field_group_get.unit,
			req->args.field_group_get.group,
			req->args.field_group_get.qset);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_INSTALL:
		rv = bcm_field_group_install(
			req->args.field_group_install.unit,
			req->args.field_group_install.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_MODE_GET:
		rv = bcm_field_group_mode_get(
			req->args.field_group_mode_get.unit,
			req->args.field_group_mode_get.group,
			req->args.field_group_mode_get.mode);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_PORT_CREATE_MODE:
		rv = bcm_field_group_port_create_mode(
			req->args.field_group_port_create_mode.unit,
			req->args.field_group_port_create_mode.port,
			req->args.field_group_port_create_mode.qset,
			req->args.field_group_port_create_mode.pri,
			req->args.field_group_port_create_mode.mode,
			req->args.field_group_port_create_mode.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_PORT_CREATE_MODE_ID:
		rv = bcm_field_group_port_create_mode_id(
			req->args.field_group_port_create_mode_id.unit,
			req->args.field_group_port_create_mode_id.port,
			req->args.field_group_port_create_mode_id.qset,
			req->args.field_group_port_create_mode_id.pri,
			req->args.field_group_port_create_mode_id.mode,
			req->args.field_group_port_create_mode_id.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_PORTS_CREATE_MODE:
		rv = bcm_field_group_ports_create_mode(
			req->args.field_group_ports_create_mode.unit,
			req->args.field_group_ports_create_mode.pbmp,
			req->args.field_group_ports_create_mode.qset,
			req->args.field_group_ports_create_mode.pri,
			req->args.field_group_ports_create_mode.mode,
			req->args.field_group_ports_create_mode.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_PORTS_CREATE_MODE_ID:
		rv = bcm_field_group_ports_create_mode_id(
			req->args.field_group_ports_create_mode_id.unit,
			req->args.field_group_ports_create_mode_id.pbmp,
			req->args.field_group_ports_create_mode_id.qset,
			req->args.field_group_ports_create_mode_id.pri,
			req->args.field_group_ports_create_mode_id.mode,
			req->args.field_group_ports_create_mode_id.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_PRIORITY_GET:
		rv = bcm_field_group_priority_get(
			req->args.field_group_priority_get.unit,
			req->args.field_group_priority_get.group,
			req->args.field_group_priority_get.priority);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_PRIORITY_SET:
		rv = bcm_field_group_priority_set(
			req->args.field_group_priority_set.unit,
			req->args.field_group_priority_set.group,
			req->args.field_group_priority_set.priority);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_REMOVE:
		rv = bcm_field_group_remove(
			req->args.field_group_remove.unit,
			req->args.field_group_remove.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_SET:
		rv = bcm_field_group_set(
			req->args.field_group_set.unit,
			req->args.field_group_set.group,
			req->args.field_group_set.qset);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_STATUS_GET:
		rv = bcm_field_group_status_get(
			req->args.field_group_status_get.unit,
			req->args.field_group_status_get.group,
			req->args.field_group_status_get.status);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_TRAVERSE:
		rv = bcm_field_group_traverse(
			req->args.field_group_traverse.unit,
			req->args.field_group_traverse.callback,
			req->args.field_group_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_WLAN_CREATE_MODE:
		rv = bcm_field_group_wlan_create_mode(
			req->args.field_group_wlan_create_mode.unit,
			req->args.field_group_wlan_create_mode.qset,
			req->args.field_group_wlan_create_mode.pri,
			req->args.field_group_wlan_create_mode.mode,
			req->args.field_group_wlan_create_mode.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_GROUP_WLAN_CREATE_MODE_ID:
		rv = bcm_field_group_wlan_create_mode_id(
			req->args.field_group_wlan_create_mode_id.unit,
			req->args.field_group_wlan_create_mode_id.qset,
			req->args.field_group_wlan_create_mode_id.pri,
			req->args.field_group_wlan_create_mode_id.mode,
			req->args.field_group_wlan_create_mode_id.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_INIT:
		rv = bcm_field_init(
			req->args.field_init.unit);
		break;
	case BCM_ASYNC_ENTRY_FIELD_METER_CREATE:
		rv = bcm_field_meter_create(
			req->args.field_meter_create.unit,
			req->args.field_meter_create.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_METER_DESTROY:
		rv = bcm_field_meter_destroy(
			req->args.field_meter_destroy.unit,
			req->args.field_meter_destroy.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_METER_GET:
		rv = bcm_field_meter_get(
			req->args.field_meter_get.unit,
			req->args.field_meter_get.entry,
			req->args.field_meter_get.meter_num,
			req->args.field_meter_get.kbits_sec,
			req->args.field_meter_get.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_FIELD_METER_SET:
		rv = bcm_field_meter_set(
			req->args.field_meter_set.unit,
			req->args.field_meter_set.entry,
			req->args.field_meter_set.meter_num,
			req->args.field_meter_set.kbits_sec,
			req->args.field_meter_set.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_FIELD_METER_SHARE:
		rv = bcm_field_meter_share(
			req->args.field_meter_share.unit,
			req->args.field_meter_share.src_entry,
			req->args.field_meter_share.dst_entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QSET_ADD_UDF:
		rv = bcm_field_qset_add_udf(
			req->args.field_qset_add_udf.unit,
			req->args.field_qset_add_udf.qset,
			req->args.field_qset_add_udf.udf_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QSET_DATA_QUALIFIER_ADD:
		rv = bcm_field_qset_data_qualifier_add(
			req->args.field_qset_data_qualifier_add.unit,
			req->args.field_qset_data_qualifier_add.qset,
			req->args.field_qset_data_qualifier_add.qual_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QSET_DATA_QUALIFIER_GET:
		rv = bcm_field_qset_data_qualifier_get(
			req->args.field_qset_data_qualifier_get.unit,
			req->args.field_qset_data_qualifier_get.qset,
			req->args.field_qset_data_qualifier_get.qual_max,
			req->args.field_qset_data_qualifier_get.qual_arr,
			req->args.field_qset_data_qualifier_get.qual_count);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QSET_UDF_GET:
		rv = bcm_field_qset_udf_get(
			req->args.field_qset_udf_get.unit,
			req->args.field_qset_udf_get.qset,
			req->args.field_qset_udf_get.udf_max,
			req->args.field_qset_udf_get.udf_arr,
			req->args.field_qset_udf_get.udf_count);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFIER_DELETE:
		rv = bcm_field_qualifier_delete(
			req->args.field_qualifier_delete.unit,
			req->args.field_qualifier_delete.entry,
			req->args.field_qualifier_delete.qual_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_BIGICMPCHECK:
		rv = bcm_field_qualify_BigIcmpCheck(
			req->args.field_qualify_BigIcmpCheck.unit,
			req->args.field_qualify_BigIcmpCheck.entry,
			req->args.field_qualify_BigIcmpCheck.flag,
			req->args.field_qualify_BigIcmpCheck.size);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_BIGICMPCHECK_GET:
		rv = bcm_field_qualify_BigIcmpCheck_get(
			req->args.field_qualify_BigIcmpCheck_get.unit,
			req->args.field_qualify_BigIcmpCheck_get.entry,
			req->args.field_qualify_BigIcmpCheck_get.flag,
			req->args.field_qualify_BigIcmpCheck_get.size);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_COLOR:
		rv = bcm_field_qualify_Color(
			req->args.field_qualify_Color.unit,
			req->args.field_qualify_Color.entry,
			req->args.field_qualify_Color.color);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_COLOR_GET:
		rv = bcm_field_qualify_Color_get(
			req->args.field_qualify_Color_get.unit,
			req->args.field_qualify_Color_get.entry,
			req->args.field_qualify_Color_get.color);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSCP:
		rv = bcm_field_qualify_DSCP(
			req->args.field_qualify_DSCP.unit,
			req->args.field_qualify_DSCP.entry,
			req->args.field_qualify_DSCP.data,
			req->args.field_qualify_DSCP.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSCP_GET:
		rv = bcm_field_qualify_DSCP_get(
			req->args.field_qualify_DSCP_get.unit,
			req->args.field_qualify_DSCP_get.entry,
			req->args.field_qualify_DSCP_get.data,
			req->args.field_qualify_DSCP_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DECAP:
		rv = bcm_field_qualify_Decap(
			req->args.field_qualify_Decap.unit,
			req->args.field_qualify_Decap.entry,
			req->args.field_qualify_Decap.decap);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DOSATTACK:
		rv = bcm_field_qualify_DosAttack(
			req->args.field_qualify_DosAttack.unit,
			req->args.field_qualify_DosAttack.entry,
			req->args.field_qualify_DosAttack.data,
			req->args.field_qualify_DosAttack.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DOSATTACK_GET:
		rv = bcm_field_qualify_DosAttack_get(
			req->args.field_qualify_DosAttack_get.unit,
			req->args.field_qualify_DosAttack_get.entry,
			req->args.field_qualify_DosAttack_get.data,
			req->args.field_qualify_DosAttack_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DROP:
		rv = bcm_field_qualify_Drop(
			req->args.field_qualify_Drop.unit,
			req->args.field_qualify_Drop.entry,
			req->args.field_qualify_Drop.data,
			req->args.field_qualify_Drop.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DROP_GET:
		rv = bcm_field_qualify_Drop_get(
			req->args.field_qualify_Drop_get.unit,
			req->args.field_qualify_Drop_get.entry,
			req->args.field_qualify_Drop_get.data,
			req->args.field_qualify_Drop_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSFIELD:
		rv = bcm_field_qualify_DstClassField(
			req->args.field_qualify_DstClassField.unit,
			req->args.field_qualify_DstClassField.entry,
			req->args.field_qualify_DstClassField.data,
			req->args.field_qualify_DstClassField.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSFIELD_GET:
		rv = bcm_field_qualify_DstClassField_get(
			req->args.field_qualify_DstClassField_get.unit,
			req->args.field_qualify_DstClassField_get.entry,
			req->args.field_qualify_DstClassField_get.data,
			req->args.field_qualify_DstClassField_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL2:
		rv = bcm_field_qualify_DstClassL2(
			req->args.field_qualify_DstClassL2.unit,
			req->args.field_qualify_DstClassL2.entry,
			req->args.field_qualify_DstClassL2.data,
			req->args.field_qualify_DstClassL2.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL2_GET:
		rv = bcm_field_qualify_DstClassL2_get(
			req->args.field_qualify_DstClassL2_get.unit,
			req->args.field_qualify_DstClassL2_get.entry,
			req->args.field_qualify_DstClassL2_get.data,
			req->args.field_qualify_DstClassL2_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL3:
		rv = bcm_field_qualify_DstClassL3(
			req->args.field_qualify_DstClassL3.unit,
			req->args.field_qualify_DstClassL3.entry,
			req->args.field_qualify_DstClassL3.data,
			req->args.field_qualify_DstClassL3.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTCLASSL3_GET:
		rv = bcm_field_qualify_DstClassL3_get(
			req->args.field_qualify_DstClassL3_get.unit,
			req->args.field_qualify_DstClassL3_get.entry,
			req->args.field_qualify_DstClassL3_get.data,
			req->args.field_qualify_DstClassL3_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTHIGIG:
		rv = bcm_field_qualify_DstHiGig(
			req->args.field_qualify_DstHiGig.unit,
			req->args.field_qualify_DstHiGig.entry,
			req->args.field_qualify_DstHiGig.data,
			req->args.field_qualify_DstHiGig.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTHIGIG_GET:
		rv = bcm_field_qualify_DstHiGig_get(
			req->args.field_qualify_DstHiGig_get.unit,
			req->args.field_qualify_DstHiGig_get.entry,
			req->args.field_qualify_DstHiGig_get.data,
			req->args.field_qualify_DstHiGig_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP:
		rv = bcm_field_qualify_DstIp(
			req->args.field_qualify_DstIp.unit,
			req->args.field_qualify_DstIp.entry,
			req->args.field_qualify_DstIp.data,
			req->args.field_qualify_DstIp.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6:
		rv = bcm_field_qualify_DstIp6(
			req->args.field_qualify_DstIp6.unit,
			req->args.field_qualify_DstIp6.entry,
			req->args.field_qualify_DstIp6.data,
			req->args.field_qualify_DstIp6.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6HIGH:
		rv = bcm_field_qualify_DstIp6High(
			req->args.field_qualify_DstIp6High.unit,
			req->args.field_qualify_DstIp6High.entry,
			req->args.field_qualify_DstIp6High.data,
			req->args.field_qualify_DstIp6High.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6HIGH_GET:
		rv = bcm_field_qualify_DstIp6High_get(
			req->args.field_qualify_DstIp6High_get.unit,
			req->args.field_qualify_DstIp6High_get.entry,
			req->args.field_qualify_DstIp6High_get.data,
			req->args.field_qualify_DstIp6High_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP6_GET:
		rv = bcm_field_qualify_DstIp6_get(
			req->args.field_qualify_DstIp6_get.unit,
			req->args.field_qualify_DstIp6_get.entry,
			req->args.field_qualify_DstIp6_get.data,
			req->args.field_qualify_DstIp6_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTIP_GET:
		rv = bcm_field_qualify_DstIp_get(
			req->args.field_qualify_DstIp_get.unit,
			req->args.field_qualify_DstIp_get.entry,
			req->args.field_qualify_DstIp_get.data,
			req->args.field_qualify_DstIp_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3EGRESS:
		rv = bcm_field_qualify_DstL3Egress(
			req->args.field_qualify_DstL3Egress.unit,
			req->args.field_qualify_DstL3Egress.entry,
			req->args.field_qualify_DstL3Egress.if_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTL3EGRESS_GET:
		rv = bcm_field_qualify_DstL3Egress_get(
			req->args.field_qualify_DstL3Egress_get.unit,
			req->args.field_qualify_DstL3Egress_get.entry,
			req->args.field_qualify_DstL3Egress_get.if_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMAC:
		rv = bcm_field_qualify_DstMac(
			req->args.field_qualify_DstMac.unit,
			req->args.field_qualify_DstMac.entry,
			req->args.field_qualify_DstMac.data,
			req->args.field_qualify_DstMac.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMAC_GET:
		rv = bcm_field_qualify_DstMac_get(
			req->args.field_qualify_DstMac_get.unit,
			req->args.field_qualify_DstMac_get.entry,
			req->args.field_qualify_DstMac_get.data,
			req->args.field_qualify_DstMac_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMIMGPORT:
		rv = bcm_field_qualify_DstMimGport(
			req->args.field_qualify_DstMimGport.unit,
			req->args.field_qualify_DstMimGport.entry,
			req->args.field_qualify_DstMimGport.mim_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMIMGPORT_GET:
		rv = bcm_field_qualify_DstMimGport_get(
			req->args.field_qualify_DstMimGport_get.unit,
			req->args.field_qualify_DstMimGport_get.entry,
			req->args.field_qualify_DstMimGport_get.mim_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMODID:
		rv = bcm_field_qualify_DstModid(
			req->args.field_qualify_DstModid.unit,
			req->args.field_qualify_DstModid.entry,
			req->args.field_qualify_DstModid.data,
			req->args.field_qualify_DstModid.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMODID_GET:
		rv = bcm_field_qualify_DstModid_get(
			req->args.field_qualify_DstModid_get.unit,
			req->args.field_qualify_DstModid_get.entry,
			req->args.field_qualify_DstModid_get.data,
			req->args.field_qualify_DstModid_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMPLSGPORT:
		rv = bcm_field_qualify_DstMplsGport(
			req->args.field_qualify_DstMplsGport.unit,
			req->args.field_qualify_DstMplsGport.entry,
			req->args.field_qualify_DstMplsGport.mpls_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMPLSGPORT_GET:
		rv = bcm_field_qualify_DstMplsGport_get(
			req->args.field_qualify_DstMplsGport_get.unit,
			req->args.field_qualify_DstMplsGport_get.entry,
			req->args.field_qualify_DstMplsGport_get.mpls_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTICASTGROUP:
		rv = bcm_field_qualify_DstMulticastGroup(
			req->args.field_qualify_DstMulticastGroup.unit,
			req->args.field_qualify_DstMulticastGroup.entry,
			req->args.field_qualify_DstMulticastGroup.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTMULTICASTGROUP_GET:
		rv = bcm_field_qualify_DstMulticastGroup_get(
			req->args.field_qualify_DstMulticastGroup_get.unit,
			req->args.field_qualify_DstMulticastGroup_get.entry,
			req->args.field_qualify_DstMulticastGroup_get.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORT:
		rv = bcm_field_qualify_DstPort(
			req->args.field_qualify_DstPort.unit,
			req->args.field_qualify_DstPort.entry,
			req->args.field_qualify_DstPort.data_modid,
			req->args.field_qualify_DstPort.mask_modid,
			req->args.field_qualify_DstPort.data_port,
			req->args.field_qualify_DstPort.mask_port);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTTGID:
		rv = bcm_field_qualify_DstPortTgid(
			req->args.field_qualify_DstPortTgid.unit,
			req->args.field_qualify_DstPortTgid.entry,
			req->args.field_qualify_DstPortTgid.data,
			req->args.field_qualify_DstPortTgid.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORTTGID_GET:
		rv = bcm_field_qualify_DstPortTgid_get(
			req->args.field_qualify_DstPortTgid_get.unit,
			req->args.field_qualify_DstPortTgid_get.entry,
			req->args.field_qualify_DstPortTgid_get.data,
			req->args.field_qualify_DstPortTgid_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTPORT_GET:
		rv = bcm_field_qualify_DstPort_get(
			req->args.field_qualify_DstPort_get.unit,
			req->args.field_qualify_DstPort_get.entry,
			req->args.field_qualify_DstPort_get.data_modid,
			req->args.field_qualify_DstPort_get.mask_modid,
			req->args.field_qualify_DstPort_get.data_port,
			req->args.field_qualify_DstPort_get.mask_port);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTTRUNK:
		rv = bcm_field_qualify_DstTrunk(
			req->args.field_qualify_DstTrunk.unit,
			req->args.field_qualify_DstTrunk.entry,
			req->args.field_qualify_DstTrunk.data,
			req->args.field_qualify_DstTrunk.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTTRUNK_GET:
		rv = bcm_field_qualify_DstTrunk_get(
			req->args.field_qualify_DstTrunk_get.unit,
			req->args.field_qualify_DstTrunk_get.entry,
			req->args.field_qualify_DstTrunk_get.data,
			req->args.field_qualify_DstTrunk_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTWLANGPORT:
		rv = bcm_field_qualify_DstWlanGport(
			req->args.field_qualify_DstWlanGport.unit,
			req->args.field_qualify_DstWlanGport.entry,
			req->args.field_qualify_DstWlanGport.wlan_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DSTWLANGPORT_GET:
		rv = bcm_field_qualify_DstWlanGport_get(
			req->args.field_qualify_DstWlanGport_get.unit,
			req->args.field_qualify_DstWlanGport_get.entry,
			req->args.field_qualify_DstWlanGport_get.wlan_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_EQUALL4PORT:
		rv = bcm_field_qualify_EqualL4Port(
			req->args.field_qualify_EqualL4Port.unit,
			req->args.field_qualify_EqualL4Port.entry,
			req->args.field_qualify_EqualL4Port.flag);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_EQUALL4PORT_GET:
		rv = bcm_field_qualify_EqualL4Port_get(
			req->args.field_qualify_EqualL4Port_get.unit,
			req->args.field_qualify_EqualL4Port_get.entry,
			req->args.field_qualify_EqualL4Port_get.flag);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERTYPE:
		rv = bcm_field_qualify_EtherType(
			req->args.field_qualify_EtherType.unit,
			req->args.field_qualify_EtherType.entry,
			req->args.field_qualify_EtherType.data,
			req->args.field_qualify_EtherType.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_ETHERTYPE_GET:
		rv = bcm_field_qualify_EtherType_get(
			req->args.field_qualify_EtherType_get.unit,
			req->args.field_qualify_EtherType_get.entry,
			req->args.field_qualify_EtherType_get.data,
			req->args.field_qualify_EtherType_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERSUBCODE:
		rv = bcm_field_qualify_ExtensionHeaderSubCode(
			req->args.field_qualify_ExtensionHeaderSubCode.unit,
			req->args.field_qualify_ExtensionHeaderSubCode.entry,
			req->args.field_qualify_ExtensionHeaderSubCode.data,
			req->args.field_qualify_ExtensionHeaderSubCode.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERSUBCODE_GET:
		rv = bcm_field_qualify_ExtensionHeaderSubCode_get(
			req->args.field_qualify_ExtensionHeaderSubCode_get.unit,
			req->args.field_qualify_ExtensionHeaderSubCode_get.entry,
			req->args.field_qualify_ExtensionHeaderSubCode_get.data,
			req->args.field_qualify_ExtensionHeaderSubCode_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERTYPE:
		rv = bcm_field_qualify_ExtensionHeaderType(
			req->args.field_qualify_ExtensionHeaderType.unit,
			req->args.field_qualify_ExtensionHeaderType.entry,
			req->args.field_qualify_ExtensionHeaderType.data,
			req->args.field_qualify_ExtensionHeaderType.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_EXTENSIONHEADERTYPE_GET:
		rv = bcm_field_qualify_ExtensionHeaderType_get(
			req->args.field_qualify_ExtensionHeaderType_get.unit,
			req->args.field_qualify_ExtensionHeaderType_get.entry,
			req->args.field_qualify_ExtensionHeaderType_get.data,
			req->args.field_qualify_ExtensionHeaderType_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGTYPE:
		rv = bcm_field_qualify_ForwardingType(
			req->args.field_qualify_ForwardingType.unit,
			req->args.field_qualify_ForwardingType.entry,
			req->args.field_qualify_ForwardingType.type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGTYPE_GET:
		rv = bcm_field_qualify_ForwardingType_get(
			req->args.field_qualify_ForwardingType_get.unit,
			req->args.field_qualify_ForwardingType_get.entry,
			req->args.field_qualify_ForwardingType_get.type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANID:
		rv = bcm_field_qualify_ForwardingVlanId(
			req->args.field_qualify_ForwardingVlanId.unit,
			req->args.field_qualify_ForwardingVlanId.entry,
			req->args.field_qualify_ForwardingVlanId.data,
			req->args.field_qualify_ForwardingVlanId.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANID_GET:
		rv = bcm_field_qualify_ForwardingVlanId_get(
			req->args.field_qualify_ForwardingVlanId_get.unit,
			req->args.field_qualify_ForwardingVlanId_get.entry,
			req->args.field_qualify_ForwardingVlanId_get.data,
			req->args.field_qualify_ForwardingVlanId_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANVALID:
		rv = bcm_field_qualify_ForwardingVlanValid(
			req->args.field_qualify_ForwardingVlanValid.unit,
			req->args.field_qualify_ForwardingVlanValid.entry,
			req->args.field_qualify_ForwardingVlanValid.data,
			req->args.field_qualify_ForwardingVlanValid.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_FORWARDINGVLANVALID_GET:
		rv = bcm_field_qualify_ForwardingVlanValid_get(
			req->args.field_qualify_ForwardingVlanValid_get.unit,
			req->args.field_qualify_ForwardingVlanValid_get.entry,
			req->args.field_qualify_ForwardingVlanValid_get.data,
			req->args.field_qualify_ForwardingVlanValid_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIG:
		rv = bcm_field_qualify_HiGig(
			req->args.field_qualify_HiGig.unit,
			req->args.field_qualify_HiGig.entry,
			req->args.field_qualify_HiGig.data,
			req->args.field_qualify_HiGig.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_HIGIG_GET:
		rv = bcm_field_qualify_HiGig_get(
			req->args.field_qualify_HiGig_get.unit,
			req->args.field_qualify_HiGig_get.entry,
			req->args.field_qualify_HiGig_get.data,
			req->args.field_qualify_HiGig_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_ICMPTYPECODE:
		rv = bcm_field_qualify_IcmpTypeCode(
			req->args.field_qualify_IcmpTypeCode.unit,
			req->args.field_qualify_IcmpTypeCode.entry,
			req->args.field_qualify_IcmpTypeCode.data,
			req->args.field_qualify_IcmpTypeCode.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_ICMPTYPECODE_GET:
		rv = bcm_field_qualify_IcmpTypeCode_get(
			req->args.field_qualify_IcmpTypeCode_get.unit,
			req->args.field_qualify_IcmpTypeCode_get.entry,
			req->args.field_qualify_IcmpTypeCode_get.data,
			req->args.field_qualify_IcmpTypeCode_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IGMPTYPEMAXRESPTIME:
		rv = bcm_field_qualify_IgmpTypeMaxRespTime(
			req->args.field_qualify_IgmpTypeMaxRespTime.unit,
			req->args.field_qualify_IgmpTypeMaxRespTime.entry,
			req->args.field_qualify_IgmpTypeMaxRespTime.data,
			req->args.field_qualify_IgmpTypeMaxRespTime.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IGMPTYPEMAXRESPTIME_GET:
		rv = bcm_field_qualify_IgmpTypeMaxRespTime_get(
			req->args.field_qualify_IgmpTypeMaxRespTime_get.unit,
			req->args.field_qualify_IgmpTypeMaxRespTime_get.entry,
			req->args.field_qualify_IgmpTypeMaxRespTime_get.data,
			req->args.field_qualify_IgmpTypeMaxRespTime_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INPORT:
		rv = bcm_field_qualify_InPort(
			req->args.field_qualify_InPort.unit,
			req->args.field_qualify_InPort.entry,
			req->args.field_qualify_InPort.data,
			req->args.field_qualify_InPort.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INPORT_GET:
		rv = bcm_field_qualify_InPort_get(
			req->args.field_qualify_InPort_get.unit,
			req->args.field_qualify_InPort_get.entry,
			req->args.field_qualify_InPort_get.data,
			req->args.field_qualify_InPort_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INPORTS:
		rv = bcm_field_qualify_InPorts(
			req->args.field_qualify_InPorts.unit,
			req->args.field_qualify_InPorts.entry,
			req->args.field_qualify_InPorts.data,
			req->args.field_qualify_InPorts.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INPORTS_GET:
		rv = bcm_field_qualify_InPorts_get(
			req->args.field_qualify_InPorts_get.unit,
			req->args.field_qualify_InPorts_get.entry,
			req->args.field_qualify_InPorts_get.data,
			req->args.field_qualify_InPorts_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSSTPSTATE:
		rv = bcm_field_qualify_IngressStpState(
			req->args.field_qualify_IngressStpState.unit,
			req->args.field_qualify_IngressStpState.entry,
			req->args.field_qualify_IngressStpState.data,
			req->args.field_qualify_IngressStpState.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INGRESSSTPSTATE_GET:
		rv = bcm_field_qualify_IngressStpState_get(
			req->args.field_qualify_IngressStpState_get.unit,
			req->args.field_qualify_IngressStpState_get.entry,
			req->args.field_qualify_IngressStpState_get.data,
			req->args.field_qualify_IngressStpState_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSCP:
		rv = bcm_field_qualify_InnerDSCP(
			req->args.field_qualify_InnerDSCP.unit,
			req->args.field_qualify_InnerDSCP.entry,
			req->args.field_qualify_InnerDSCP.data,
			req->args.field_qualify_InnerDSCP.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSCP_GET:
		rv = bcm_field_qualify_InnerDSCP_get(
			req->args.field_qualify_InnerDSCP_get.unit,
			req->args.field_qualify_InnerDSCP_get.entry,
			req->args.field_qualify_InnerDSCP_get.data,
			req->args.field_qualify_InnerDSCP_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP:
		rv = bcm_field_qualify_InnerDstIp(
			req->args.field_qualify_InnerDstIp.unit,
			req->args.field_qualify_InnerDstIp.entry,
			req->args.field_qualify_InnerDstIp.data,
			req->args.field_qualify_InnerDstIp.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6:
		rv = bcm_field_qualify_InnerDstIp6(
			req->args.field_qualify_InnerDstIp6.unit,
			req->args.field_qualify_InnerDstIp6.entry,
			req->args.field_qualify_InnerDstIp6.data,
			req->args.field_qualify_InnerDstIp6.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6HIGH:
		rv = bcm_field_qualify_InnerDstIp6High(
			req->args.field_qualify_InnerDstIp6High.unit,
			req->args.field_qualify_InnerDstIp6High.entry,
			req->args.field_qualify_InnerDstIp6High.data,
			req->args.field_qualify_InnerDstIp6High.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6HIGH_GET:
		rv = bcm_field_qualify_InnerDstIp6High_get(
			req->args.field_qualify_InnerDstIp6High_get.unit,
			req->args.field_qualify_InnerDstIp6High_get.entry,
			req->args.field_qualify_InnerDstIp6High_get.data,
			req->args.field_qualify_InnerDstIp6High_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP6_GET:
		rv = bcm_field_qualify_InnerDstIp6_get(
			req->args.field_qualify_InnerDstIp6_get.unit,
			req->args.field_qualify_InnerDstIp6_get.entry,
			req->args.field_qualify_InnerDstIp6_get.data,
			req->args.field_qualify_InnerDstIp6_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERDSTIP_GET:
		rv = bcm_field_qualify_InnerDstIp_get(
			req->args.field_qualify_InnerDstIp_get.unit,
			req->args.field_qualify_InnerDstIp_get.entry,
			req->args.field_qualify_InnerDstIp_get.data,
			req->args.field_qualify_InnerDstIp_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6FLOWLABEL:
		rv = bcm_field_qualify_InnerIp6FlowLabel(
			req->args.field_qualify_InnerIp6FlowLabel.unit,
			req->args.field_qualify_InnerIp6FlowLabel.entry,
			req->args.field_qualify_InnerIp6FlowLabel.data,
			req->args.field_qualify_InnerIp6FlowLabel.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIP6FLOWLABEL_GET:
		rv = bcm_field_qualify_InnerIp6FlowLabel_get(
			req->args.field_qualify_InnerIp6FlowLabel_get.unit,
			req->args.field_qualify_InnerIp6FlowLabel_get.entry,
			req->args.field_qualify_InnerIp6FlowLabel_get.data,
			req->args.field_qualify_InnerIp6FlowLabel_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPFRAG:
		rv = bcm_field_qualify_InnerIpFrag(
			req->args.field_qualify_InnerIpFrag.unit,
			req->args.field_qualify_InnerIpFrag.entry,
			req->args.field_qualify_InnerIpFrag.frag_info);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPFRAG_GET:
		rv = bcm_field_qualify_InnerIpFrag_get(
			req->args.field_qualify_InnerIpFrag_get.unit,
			req->args.field_qualify_InnerIpFrag_get.entry,
			req->args.field_qualify_InnerIpFrag_get.frag_info);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOL:
		rv = bcm_field_qualify_InnerIpProtocol(
			req->args.field_qualify_InnerIpProtocol.unit,
			req->args.field_qualify_InnerIpProtocol.entry,
			req->args.field_qualify_InnerIpProtocol.data,
			req->args.field_qualify_InnerIpProtocol.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOLCOMMON:
		rv = bcm_field_qualify_InnerIpProtocolCommon(
			req->args.field_qualify_InnerIpProtocolCommon.unit,
			req->args.field_qualify_InnerIpProtocolCommon.entry,
			req->args.field_qualify_InnerIpProtocolCommon.protocol);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOLCOMMON_GET:
		rv = bcm_field_qualify_InnerIpProtocolCommon_get(
			req->args.field_qualify_InnerIpProtocolCommon_get.unit,
			req->args.field_qualify_InnerIpProtocolCommon_get.entry,
			req->args.field_qualify_InnerIpProtocolCommon_get.protocol);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPPROTOCOL_GET:
		rv = bcm_field_qualify_InnerIpProtocol_get(
			req->args.field_qualify_InnerIpProtocol_get.unit,
			req->args.field_qualify_InnerIpProtocol_get.entry,
			req->args.field_qualify_InnerIpProtocol_get.data,
			req->args.field_qualify_InnerIpProtocol_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPTYPE:
		rv = bcm_field_qualify_InnerIpType(
			req->args.field_qualify_InnerIpType.unit,
			req->args.field_qualify_InnerIpType.entry,
			req->args.field_qualify_InnerIpType.type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERIPTYPE_GET:
		rv = bcm_field_qualify_InnerIpType_get(
			req->args.field_qualify_InnerIpType_get.unit,
			req->args.field_qualify_InnerIpType_get.entry,
			req->args.field_qualify_InnerIpType_get.type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4DSTPORT:
		rv = bcm_field_qualify_InnerL4DstPort(
			req->args.field_qualify_InnerL4DstPort.unit,
			req->args.field_qualify_InnerL4DstPort.entry,
			req->args.field_qualify_InnerL4DstPort.data,
			req->args.field_qualify_InnerL4DstPort.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4DSTPORT_GET:
		rv = bcm_field_qualify_InnerL4DstPort_get(
			req->args.field_qualify_InnerL4DstPort_get.unit,
			req->args.field_qualify_InnerL4DstPort_get.entry,
			req->args.field_qualify_InnerL4DstPort_get.data,
			req->args.field_qualify_InnerL4DstPort_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4SRCPORT:
		rv = bcm_field_qualify_InnerL4SrcPort(
			req->args.field_qualify_InnerL4SrcPort.unit,
			req->args.field_qualify_InnerL4SrcPort.entry,
			req->args.field_qualify_InnerL4SrcPort.data,
			req->args.field_qualify_InnerL4SrcPort.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERL4SRCPORT_GET:
		rv = bcm_field_qualify_InnerL4SrcPort_get(
			req->args.field_qualify_InnerL4SrcPort_get.unit,
			req->args.field_qualify_InnerL4SrcPort_get.entry,
			req->args.field_qualify_InnerL4SrcPort_get.data,
			req->args.field_qualify_InnerL4SrcPort_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP:
		rv = bcm_field_qualify_InnerSrcIp(
			req->args.field_qualify_InnerSrcIp.unit,
			req->args.field_qualify_InnerSrcIp.entry,
			req->args.field_qualify_InnerSrcIp.data,
			req->args.field_qualify_InnerSrcIp.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6:
		rv = bcm_field_qualify_InnerSrcIp6(
			req->args.field_qualify_InnerSrcIp6.unit,
			req->args.field_qualify_InnerSrcIp6.entry,
			req->args.field_qualify_InnerSrcIp6.data,
			req->args.field_qualify_InnerSrcIp6.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6HIGH:
		rv = bcm_field_qualify_InnerSrcIp6High(
			req->args.field_qualify_InnerSrcIp6High.unit,
			req->args.field_qualify_InnerSrcIp6High.entry,
			req->args.field_qualify_InnerSrcIp6High.data,
			req->args.field_qualify_InnerSrcIp6High.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6HIGH_GET:
		rv = bcm_field_qualify_InnerSrcIp6High_get(
			req->args.field_qualify_InnerSrcIp6High_get.unit,
			req->args.field_qualify_InnerSrcIp6High_get.entry,
			req->args.field_qualify_InnerSrcIp6High_get.data,
			req->args.field_qualify_InnerSrcIp6High_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP6_GET:
		rv = bcm_field_qualify_InnerSrcIp6_get(
			req->args.field_qualify_InnerSrcIp6_get.unit,
			req->args.field_qualify_InnerSrcIp6_get.entry,
			req->args.field_qualify_InnerSrcIp6_get.data,
			req->args.field_qualify_InnerSrcIp6_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERSRCIP_GET:
		rv = bcm_field_qualify_InnerSrcIp_get(
			req->args.field_qualify_InnerSrcIp_get.unit,
			req->args.field_qualify_InnerSrcIp_get.entry,
			req->args.field_qualify_InnerSrcIp_get.data,
			req->args.field_qualify_InnerSrcIp_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTPID:
		rv = bcm_field_qualify_InnerTpid(
			req->args.field_qualify_InnerTpid.unit,
			req->args.field_qualify_InnerTpid.entry,
			req->args.field_qualify_InnerTpid.tpid);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTPID_GET:
		rv = bcm_field_qualify_InnerTpid_get(
			req->args.field_qualify_InnerTpid_get.unit,
			req->args.field_qualify_InnerTpid_get.entry,
			req->args.field_qualify_InnerTpid_get.tpid);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTTL:
		rv = bcm_field_qualify_InnerTtl(
			req->args.field_qualify_InnerTtl.unit,
			req->args.field_qualify_InnerTtl.entry,
			req->args.field_qualify_InnerTtl.data,
			req->args.field_qualify_InnerTtl.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERTTL_GET:
		rv = bcm_field_qualify_InnerTtl_get(
			req->args.field_qualify_InnerTtl_get.unit,
			req->args.field_qualify_InnerTtl_get.entry,
			req->args.field_qualify_InnerTtl_get.data,
			req->args.field_qualify_InnerTtl_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLAN:
		rv = bcm_field_qualify_InnerVlan(
			req->args.field_qualify_InnerVlan.unit,
			req->args.field_qualify_InnerVlan.entry,
			req->args.field_qualify_InnerVlan.data,
			req->args.field_qualify_InnerVlan.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANCFI:
		rv = bcm_field_qualify_InnerVlanCfi(
			req->args.field_qualify_InnerVlanCfi.unit,
			req->args.field_qualify_InnerVlanCfi.entry,
			req->args.field_qualify_InnerVlanCfi.data,
			req->args.field_qualify_InnerVlanCfi.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANCFI_GET:
		rv = bcm_field_qualify_InnerVlanCfi_get(
			req->args.field_qualify_InnerVlanCfi_get.unit,
			req->args.field_qualify_InnerVlanCfi_get.entry,
			req->args.field_qualify_InnerVlanCfi_get.data,
			req->args.field_qualify_InnerVlanCfi_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANID:
		rv = bcm_field_qualify_InnerVlanId(
			req->args.field_qualify_InnerVlanId.unit,
			req->args.field_qualify_InnerVlanId.entry,
			req->args.field_qualify_InnerVlanId.data,
			req->args.field_qualify_InnerVlanId.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANID_GET:
		rv = bcm_field_qualify_InnerVlanId_get(
			req->args.field_qualify_InnerVlanId_get.unit,
			req->args.field_qualify_InnerVlanId_get.entry,
			req->args.field_qualify_InnerVlanId_get.data,
			req->args.field_qualify_InnerVlanId_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANPRI:
		rv = bcm_field_qualify_InnerVlanPri(
			req->args.field_qualify_InnerVlanPri.unit,
			req->args.field_qualify_InnerVlanPri.entry,
			req->args.field_qualify_InnerVlanPri.data,
			req->args.field_qualify_InnerVlanPri.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLANPRI_GET:
		rv = bcm_field_qualify_InnerVlanPri_get(
			req->args.field_qualify_InnerVlanPri_get.unit,
			req->args.field_qualify_InnerVlanPri_get.entry,
			req->args.field_qualify_InnerVlanPri_get.data,
			req->args.field_qualify_InnerVlanPri_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INNERVLAN_GET:
		rv = bcm_field_qualify_InnerVlan_get(
			req->args.field_qualify_InnerVlan_get.unit,
			req->args.field_qualify_InnerVlan_get.entry,
			req->args.field_qualify_InnerVlan_get.data,
			req->args.field_qualify_InnerVlan_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTPRIORITY:
		rv = bcm_field_qualify_IntPriority(
			req->args.field_qualify_IntPriority.unit,
			req->args.field_qualify_IntPriority.entry,
			req->args.field_qualify_IntPriority.data,
			req->args.field_qualify_IntPriority.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTPRIORITY_GET:
		rv = bcm_field_qualify_IntPriority_get(
			req->args.field_qualify_IntPriority_get.unit,
			req->args.field_qualify_IntPriority_get.entry,
			req->args.field_qualify_IntPriority_get.data,
			req->args.field_qualify_IntPriority_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL2:
		rv = bcm_field_qualify_InterfaceClassL2(
			req->args.field_qualify_InterfaceClassL2.unit,
			req->args.field_qualify_InterfaceClassL2.entry,
			req->args.field_qualify_InterfaceClassL2.data,
			req->args.field_qualify_InterfaceClassL2.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL2_GET:
		rv = bcm_field_qualify_InterfaceClassL2_get(
			req->args.field_qualify_InterfaceClassL2_get.unit,
			req->args.field_qualify_InterfaceClassL2_get.entry,
			req->args.field_qualify_InterfaceClassL2_get.data,
			req->args.field_qualify_InterfaceClassL2_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL3:
		rv = bcm_field_qualify_InterfaceClassL3(
			req->args.field_qualify_InterfaceClassL3.unit,
			req->args.field_qualify_InterfaceClassL3.entry,
			req->args.field_qualify_InterfaceClassL3.data,
			req->args.field_qualify_InterfaceClassL3.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSL3_GET:
		rv = bcm_field_qualify_InterfaceClassL3_get(
			req->args.field_qualify_InterfaceClassL3_get.unit,
			req->args.field_qualify_InterfaceClassL3_get.entry,
			req->args.field_qualify_InterfaceClassL3_get.data,
			req->args.field_qualify_InterfaceClassL3_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSPORT:
		rv = bcm_field_qualify_InterfaceClassPort(
			req->args.field_qualify_InterfaceClassPort.unit,
			req->args.field_qualify_InterfaceClassPort.entry,
			req->args.field_qualify_InterfaceClassPort.data,
			req->args.field_qualify_InterfaceClassPort.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_INTERFACECLASSPORT_GET:
		rv = bcm_field_qualify_InterfaceClassPort_get(
			req->args.field_qualify_InterfaceClassPort_get.unit,
			req->args.field_qualify_InterfaceClassPort_get.entry,
			req->args.field_qualify_InterfaceClassPort_get.data,
			req->args.field_qualify_InterfaceClassPort_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6FLOWLABEL:
		rv = bcm_field_qualify_Ip6FlowLabel(
			req->args.field_qualify_Ip6FlowLabel.unit,
			req->args.field_qualify_Ip6FlowLabel.entry,
			req->args.field_qualify_Ip6FlowLabel.data,
			req->args.field_qualify_Ip6FlowLabel.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6FLOWLABEL_GET:
		rv = bcm_field_qualify_Ip6FlowLabel_get(
			req->args.field_qualify_Ip6FlowLabel_get.unit,
			req->args.field_qualify_Ip6FlowLabel_get.entry,
			req->args.field_qualify_Ip6FlowLabel_get.data,
			req->args.field_qualify_Ip6FlowLabel_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6HOPLIMIT:
		rv = bcm_field_qualify_Ip6HopLimit(
			req->args.field_qualify_Ip6HopLimit.unit,
			req->args.field_qualify_Ip6HopLimit.entry,
			req->args.field_qualify_Ip6HopLimit.data,
			req->args.field_qualify_Ip6HopLimit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6HOPLIMIT_GET:
		rv = bcm_field_qualify_Ip6HopLimit_get(
			req->args.field_qualify_Ip6HopLimit_get.unit,
			req->args.field_qualify_Ip6HopLimit_get.entry,
			req->args.field_qualify_Ip6HopLimit_get.data,
			req->args.field_qualify_Ip6HopLimit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6NEXTHEADER:
		rv = bcm_field_qualify_Ip6NextHeader(
			req->args.field_qualify_Ip6NextHeader.unit,
			req->args.field_qualify_Ip6NextHeader.entry,
			req->args.field_qualify_Ip6NextHeader.data,
			req->args.field_qualify_Ip6NextHeader.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6NEXTHEADER_GET:
		rv = bcm_field_qualify_Ip6NextHeader_get(
			req->args.field_qualify_Ip6NextHeader_get.unit,
			req->args.field_qualify_Ip6NextHeader_get.entry,
			req->args.field_qualify_Ip6NextHeader_get.data,
			req->args.field_qualify_Ip6NextHeader_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6TRAFFICCLASS:
		rv = bcm_field_qualify_Ip6TrafficClass(
			req->args.field_qualify_Ip6TrafficClass.unit,
			req->args.field_qualify_Ip6TrafficClass.entry,
			req->args.field_qualify_Ip6TrafficClass.data,
			req->args.field_qualify_Ip6TrafficClass.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IP6TRAFFICCLASS_GET:
		rv = bcm_field_qualify_Ip6TrafficClass_get(
			req->args.field_qualify_Ip6TrafficClass_get.unit,
			req->args.field_qualify_Ip6TrafficClass_get.entry,
			req->args.field_qualify_Ip6TrafficClass_get.data,
			req->args.field_qualify_Ip6TrafficClass_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPAUTH:
		rv = bcm_field_qualify_IpAuth(
			req->args.field_qualify_IpAuth.unit,
			req->args.field_qualify_IpAuth.entry,
			req->args.field_qualify_IpAuth.data,
			req->args.field_qualify_IpAuth.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPAUTH_GET:
		rv = bcm_field_qualify_IpAuth_get(
			req->args.field_qualify_IpAuth_get.unit,
			req->args.field_qualify_IpAuth_get.entry,
			req->args.field_qualify_IpAuth_get.data,
			req->args.field_qualify_IpAuth_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFLAGS:
		rv = bcm_field_qualify_IpFlags(
			req->args.field_qualify_IpFlags.unit,
			req->args.field_qualify_IpFlags.entry,
			req->args.field_qualify_IpFlags.data,
			req->args.field_qualify_IpFlags.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFLAGS_GET:
		rv = bcm_field_qualify_IpFlags_get(
			req->args.field_qualify_IpFlags_get.unit,
			req->args.field_qualify_IpFlags_get.entry,
			req->args.field_qualify_IpFlags_get.data,
			req->args.field_qualify_IpFlags_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFRAG:
		rv = bcm_field_qualify_IpFrag(
			req->args.field_qualify_IpFrag.unit,
			req->args.field_qualify_IpFrag.entry,
			req->args.field_qualify_IpFrag.frag_info);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPFRAG_GET:
		rv = bcm_field_qualify_IpFrag_get(
			req->args.field_qualify_IpFrag_get.unit,
			req->args.field_qualify_IpFrag_get.entry,
			req->args.field_qualify_IpFrag_get.frag_info);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPINFO:
		rv = bcm_field_qualify_IpInfo(
			req->args.field_qualify_IpInfo.unit,
			req->args.field_qualify_IpInfo.entry,
			req->args.field_qualify_IpInfo.data,
			req->args.field_qualify_IpInfo.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPINFO_GET:
		rv = bcm_field_qualify_IpInfo_get(
			req->args.field_qualify_IpInfo_get.unit,
			req->args.field_qualify_IpInfo_get.entry,
			req->args.field_qualify_IpInfo_get.data,
			req->args.field_qualify_IpInfo_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOL:
		rv = bcm_field_qualify_IpProtocol(
			req->args.field_qualify_IpProtocol.unit,
			req->args.field_qualify_IpProtocol.entry,
			req->args.field_qualify_IpProtocol.data,
			req->args.field_qualify_IpProtocol.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOLCOMMON:
		rv = bcm_field_qualify_IpProtocolCommon(
			req->args.field_qualify_IpProtocolCommon.unit,
			req->args.field_qualify_IpProtocolCommon.entry,
			req->args.field_qualify_IpProtocolCommon.protocol);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOLCOMMON_GET:
		rv = bcm_field_qualify_IpProtocolCommon_get(
			req->args.field_qualify_IpProtocolCommon_get.unit,
			req->args.field_qualify_IpProtocolCommon_get.entry,
			req->args.field_qualify_IpProtocolCommon_get.protocol);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPPROTOCOL_GET:
		rv = bcm_field_qualify_IpProtocol_get(
			req->args.field_qualify_IpProtocol_get.unit,
			req->args.field_qualify_IpProtocol_get.entry,
			req->args.field_qualify_IpProtocol_get.data,
			req->args.field_qualify_IpProtocol_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPTYPE:
		rv = bcm_field_qualify_IpType(
			req->args.field_qualify_IpType.unit,
			req->args.field_qualify_IpType.entry,
			req->args.field_qualify_IpType.type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPTYPE_GET:
		rv = bcm_field_qualify_IpType_get(
			req->args.field_qualify_IpType_get.unit,
			req->args.field_qualify_IpType_get.entry,
			req->args.field_qualify_IpType_get.type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCSTARGROUPHIT:
		rv = bcm_field_qualify_IpmcStarGroupHit(
			req->args.field_qualify_IpmcStarGroupHit.unit,
			req->args.field_qualify_IpmcStarGroupHit.entry,
			req->args.field_qualify_IpmcStarGroupHit.data,
			req->args.field_qualify_IpmcStarGroupHit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_IPMCSTARGROUPHIT_GET:
		rv = bcm_field_qualify_IpmcStarGroupHit_get(
			req->args.field_qualify_IpmcStarGroupHit_get.unit,
			req->args.field_qualify_IpmcStarGroupHit_get.entry,
			req->args.field_qualify_IpmcStarGroupHit_get.data,
			req->args.field_qualify_IpmcStarGroupHit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2CACHEHIT:
		rv = bcm_field_qualify_L2CacheHit(
			req->args.field_qualify_L2CacheHit.unit,
			req->args.field_qualify_L2CacheHit.entry,
			req->args.field_qualify_L2CacheHit.data,
			req->args.field_qualify_L2CacheHit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2CACHEHIT_GET:
		rv = bcm_field_qualify_L2CacheHit_get(
			req->args.field_qualify_L2CacheHit_get.unit,
			req->args.field_qualify_L2CacheHit_get.entry,
			req->args.field_qualify_L2CacheHit_get.data,
			req->args.field_qualify_L2CacheHit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTHIT:
		rv = bcm_field_qualify_L2DestHit(
			req->args.field_qualify_L2DestHit.unit,
			req->args.field_qualify_L2DestHit.entry,
			req->args.field_qualify_L2DestHit.data,
			req->args.field_qualify_L2DestHit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2DESTHIT_GET:
		rv = bcm_field_qualify_L2DestHit_get(
			req->args.field_qualify_L2DestHit_get.unit,
			req->args.field_qualify_L2DestHit_get.entry,
			req->args.field_qualify_L2DestHit_get.data,
			req->args.field_qualify_L2DestHit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2FORMAT:
		rv = bcm_field_qualify_L2Format(
			req->args.field_qualify_L2Format.unit,
			req->args.field_qualify_L2Format.entry,
			req->args.field_qualify_L2Format.type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2FORMAT_GET:
		rv = bcm_field_qualify_L2Format_get(
			req->args.field_qualify_L2Format_get.unit,
			req->args.field_qualify_L2Format_get.entry,
			req->args.field_qualify_L2Format_get.type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCHIT:
		rv = bcm_field_qualify_L2SrcHit(
			req->args.field_qualify_L2SrcHit.unit,
			req->args.field_qualify_L2SrcHit.entry,
			req->args.field_qualify_L2SrcHit.data,
			req->args.field_qualify_L2SrcHit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCHIT_GET:
		rv = bcm_field_qualify_L2SrcHit_get(
			req->args.field_qualify_L2SrcHit_get.unit,
			req->args.field_qualify_L2SrcHit_get.entry,
			req->args.field_qualify_L2SrcHit_get.data,
			req->args.field_qualify_L2SrcHit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCSTATIC:
		rv = bcm_field_qualify_L2SrcStatic(
			req->args.field_qualify_L2SrcStatic.unit,
			req->args.field_qualify_L2SrcStatic.entry,
			req->args.field_qualify_L2SrcStatic.data,
			req->args.field_qualify_L2SrcStatic.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2SRCSTATIC_GET:
		rv = bcm_field_qualify_L2SrcStatic_get(
			req->args.field_qualify_L2SrcStatic_get.unit,
			req->args.field_qualify_L2SrcStatic_get.entry,
			req->args.field_qualify_L2SrcStatic_get.data,
			req->args.field_qualify_L2SrcStatic_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2STATIONMOVE:
		rv = bcm_field_qualify_L2StationMove(
			req->args.field_qualify_L2StationMove.unit,
			req->args.field_qualify_L2StationMove.entry,
			req->args.field_qualify_L2StationMove.data,
			req->args.field_qualify_L2StationMove.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L2STATIONMOVE_GET:
		rv = bcm_field_qualify_L2StationMove_get(
			req->args.field_qualify_L2StationMove_get.unit,
			req->args.field_qualify_L2StationMove_get.entry,
			req->args.field_qualify_L2StationMove_get.data,
			req->args.field_qualify_L2StationMove_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTHOSTHIT:
		rv = bcm_field_qualify_L3DestHostHit(
			req->args.field_qualify_L3DestHostHit.unit,
			req->args.field_qualify_L3DestHostHit.entry,
			req->args.field_qualify_L3DestHostHit.data,
			req->args.field_qualify_L3DestHostHit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTHOSTHIT_GET:
		rv = bcm_field_qualify_L3DestHostHit_get(
			req->args.field_qualify_L3DestHostHit_get.unit,
			req->args.field_qualify_L3DestHostHit_get.entry,
			req->args.field_qualify_L3DestHostHit_get.data,
			req->args.field_qualify_L3DestHostHit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTROUTEHIT:
		rv = bcm_field_qualify_L3DestRouteHit(
			req->args.field_qualify_L3DestRouteHit.unit,
			req->args.field_qualify_L3DestRouteHit.entry,
			req->args.field_qualify_L3DestRouteHit.data,
			req->args.field_qualify_L3DestRouteHit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3DESTROUTEHIT_GET:
		rv = bcm_field_qualify_L3DestRouteHit_get(
			req->args.field_qualify_L3DestRouteHit_get.unit,
			req->args.field_qualify_L3DestRouteHit_get.entry,
			req->args.field_qualify_L3DestRouteHit_get.data,
			req->args.field_qualify_L3DestRouteHit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3INTFGROUP:
		rv = bcm_field_qualify_L3IntfGroup(
			req->args.field_qualify_L3IntfGroup.unit,
			req->args.field_qualify_L3IntfGroup.entry,
			req->args.field_qualify_L3IntfGroup.data,
			req->args.field_qualify_L3IntfGroup.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3INTFGROUP_GET:
		rv = bcm_field_qualify_L3IntfGroup_get(
			req->args.field_qualify_L3IntfGroup_get.unit,
			req->args.field_qualify_L3IntfGroup_get.entry,
			req->args.field_qualify_L3IntfGroup_get.data,
			req->args.field_qualify_L3IntfGroup_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3ROUTABLE:
		rv = bcm_field_qualify_L3Routable(
			req->args.field_qualify_L3Routable.unit,
			req->args.field_qualify_L3Routable.entry,
			req->args.field_qualify_L3Routable.data,
			req->args.field_qualify_L3Routable.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3ROUTABLE_GET:
		rv = bcm_field_qualify_L3Routable_get(
			req->args.field_qualify_L3Routable_get.unit,
			req->args.field_qualify_L3Routable_get.entry,
			req->args.field_qualify_L3Routable_get.data,
			req->args.field_qualify_L3Routable_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCHOSTHIT:
		rv = bcm_field_qualify_L3SrcHostHit(
			req->args.field_qualify_L3SrcHostHit.unit,
			req->args.field_qualify_L3SrcHostHit.entry,
			req->args.field_qualify_L3SrcHostHit.data,
			req->args.field_qualify_L3SrcHostHit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L3SRCHOSTHIT_GET:
		rv = bcm_field_qualify_L3SrcHostHit_get(
			req->args.field_qualify_L3SrcHostHit_get.unit,
			req->args.field_qualify_L3SrcHostHit_get.entry,
			req->args.field_qualify_L3SrcHostHit_get.data,
			req->args.field_qualify_L3SrcHostHit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4DSTPORT:
		rv = bcm_field_qualify_L4DstPort(
			req->args.field_qualify_L4DstPort.unit,
			req->args.field_qualify_L4DstPort.entry,
			req->args.field_qualify_L4DstPort.data,
			req->args.field_qualify_L4DstPort.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4DSTPORT_GET:
		rv = bcm_field_qualify_L4DstPort_get(
			req->args.field_qualify_L4DstPort_get.unit,
			req->args.field_qualify_L4DstPort_get.entry,
			req->args.field_qualify_L4DstPort_get.data,
			req->args.field_qualify_L4DstPort_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4PORTS:
		rv = bcm_field_qualify_L4Ports(
			req->args.field_qualify_L4Ports.unit,
			req->args.field_qualify_L4Ports.entry,
			req->args.field_qualify_L4Ports.data,
			req->args.field_qualify_L4Ports.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4PORTS_GET:
		rv = bcm_field_qualify_L4Ports_get(
			req->args.field_qualify_L4Ports_get.unit,
			req->args.field_qualify_L4Ports_get.entry,
			req->args.field_qualify_L4Ports_get.data,
			req->args.field_qualify_L4Ports_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4SRCPORT:
		rv = bcm_field_qualify_L4SrcPort(
			req->args.field_qualify_L4SrcPort.unit,
			req->args.field_qualify_L4SrcPort.entry,
			req->args.field_qualify_L4SrcPort.data,
			req->args.field_qualify_L4SrcPort.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_L4SRCPORT_GET:
		rv = bcm_field_qualify_L4SrcPort_get(
			req->args.field_qualify_L4SrcPort_get.unit,
			req->args.field_qualify_L4SrcPort_get.entry,
			req->args.field_qualify_L4SrcPort_get.data,
			req->args.field_qualify_L4SrcPort_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LLC:
		rv = bcm_field_qualify_Llc(
			req->args.field_qualify_Llc.unit,
			req->args.field_qualify_Llc.entry,
			req->args.field_qualify_Llc.data,
			req->args.field_qualify_Llc.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LLC_GET:
		rv = bcm_field_qualify_Llc_get(
			req->args.field_qualify_Llc_get.unit,
			req->args.field_qualify_Llc_get.entry,
			req->args.field_qualify_Llc_get.data,
			req->args.field_qualify_Llc_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOKUPCLASS0:
		rv = bcm_field_qualify_LookupClass0(
			req->args.field_qualify_LookupClass0.unit,
			req->args.field_qualify_LookupClass0.entry,
			req->args.field_qualify_LookupClass0.data,
			req->args.field_qualify_LookupClass0.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOKUPCLASS0_GET:
		rv = bcm_field_qualify_LookupClass0_get(
			req->args.field_qualify_LookupClass0_get.unit,
			req->args.field_qualify_LookupClass0_get.entry,
			req->args.field_qualify_LookupClass0_get.data,
			req->args.field_qualify_LookupClass0_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOKUPSTATUS:
		rv = bcm_field_qualify_LookupStatus(
			req->args.field_qualify_LookupStatus.unit,
			req->args.field_qualify_LookupStatus.entry,
			req->args.field_qualify_LookupStatus.data,
			req->args.field_qualify_LookupStatus.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACK:
		rv = bcm_field_qualify_Loopback(
			req->args.field_qualify_Loopback.unit,
			req->args.field_qualify_Loopback.entry,
			req->args.field_qualify_Loopback.data,
			req->args.field_qualify_Loopback.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKTYPE:
		rv = bcm_field_qualify_LoopbackType(
			req->args.field_qualify_LoopbackType.unit,
			req->args.field_qualify_LoopbackType.entry,
			req->args.field_qualify_LoopbackType.loopback_type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACKTYPE_GET:
		rv = bcm_field_qualify_LoopbackType_get(
			req->args.field_qualify_LoopbackType_get.unit,
			req->args.field_qualify_LoopbackType_get.entry,
			req->args.field_qualify_LoopbackType_get.loopback_type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_LOOPBACK_GET:
		rv = bcm_field_qualify_Loopback_get(
			req->args.field_qualify_Loopback_get.unit,
			req->args.field_qualify_Loopback_get.entry,
			req->args.field_qualify_Loopback_get.data,
			req->args.field_qualify_Loopback_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_MHOPCODE:
		rv = bcm_field_qualify_MHOpcode(
			req->args.field_qualify_MHOpcode.unit,
			req->args.field_qualify_MHOpcode.entry,
			req->args.field_qualify_MHOpcode.data,
			req->args.field_qualify_MHOpcode.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_MHOPCODE_GET:
		rv = bcm_field_qualify_MHOpcode_get(
			req->args.field_qualify_MHOpcode_get.unit,
			req->args.field_qualify_MHOpcode_get.entry,
			req->args.field_qualify_MHOpcode_get.data,
			req->args.field_qualify_MHOpcode_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIRRORCOPY:
		rv = bcm_field_qualify_MirrorCopy(
			req->args.field_qualify_MirrorCopy.unit,
			req->args.field_qualify_MirrorCopy.entry,
			req->args.field_qualify_MirrorCopy.data,
			req->args.field_qualify_MirrorCopy.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_MIRRORCOPY_GET:
		rv = bcm_field_qualify_MirrorCopy_get(
			req->args.field_qualify_MirrorCopy_get.unit,
			req->args.field_qualify_MirrorCopy_get.entry,
			req->args.field_qualify_MirrorCopy_get.data,
			req->args.field_qualify_MirrorCopy_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATED:
		rv = bcm_field_qualify_MplsTerminated(
			req->args.field_qualify_MplsTerminated.unit,
			req->args.field_qualify_MplsTerminated.entry,
			req->args.field_qualify_MplsTerminated.data,
			req->args.field_qualify_MplsTerminated.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_MPLSTERMINATED_GET:
		rv = bcm_field_qualify_MplsTerminated_get(
			req->args.field_qualify_MplsTerminated_get.unit,
			req->args.field_qualify_MplsTerminated_get.entry,
			req->args.field_qualify_MplsTerminated_get.data,
			req->args.field_qualify_MplsTerminated_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORT:
		rv = bcm_field_qualify_OutPort(
			req->args.field_qualify_OutPort.unit,
			req->args.field_qualify_OutPort.entry,
			req->args.field_qualify_OutPort.data,
			req->args.field_qualify_OutPort.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORT_GET:
		rv = bcm_field_qualify_OutPort_get(
			req->args.field_qualify_OutPort_get.unit,
			req->args.field_qualify_OutPort_get.entry,
			req->args.field_qualify_OutPort_get.data,
			req->args.field_qualify_OutPort_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORTS:
		rv = bcm_field_qualify_OutPorts(
			req->args.field_qualify_OutPorts.unit,
			req->args.field_qualify_OutPorts.entry,
			req->args.field_qualify_OutPorts.data,
			req->args.field_qualify_OutPorts.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTPORTS_GET:
		rv = bcm_field_qualify_OutPorts_get(
			req->args.field_qualify_OutPorts_get.unit,
			req->args.field_qualify_OutPorts_get.entry,
			req->args.field_qualify_OutPorts_get.data,
			req->args.field_qualify_OutPorts_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERTPID:
		rv = bcm_field_qualify_OuterTpid(
			req->args.field_qualify_OuterTpid.unit,
			req->args.field_qualify_OuterTpid.entry,
			req->args.field_qualify_OuterTpid.tpid);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERTPID_GET:
		rv = bcm_field_qualify_OuterTpid_get(
			req->args.field_qualify_OuterTpid_get.unit,
			req->args.field_qualify_OuterTpid_get.entry,
			req->args.field_qualify_OuterTpid_get.tpid);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLAN:
		rv = bcm_field_qualify_OuterVlan(
			req->args.field_qualify_OuterVlan.unit,
			req->args.field_qualify_OuterVlan.entry,
			req->args.field_qualify_OuterVlan.data,
			req->args.field_qualify_OuterVlan.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANCFI:
		rv = bcm_field_qualify_OuterVlanCfi(
			req->args.field_qualify_OuterVlanCfi.unit,
			req->args.field_qualify_OuterVlanCfi.entry,
			req->args.field_qualify_OuterVlanCfi.data,
			req->args.field_qualify_OuterVlanCfi.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANCFI_GET:
		rv = bcm_field_qualify_OuterVlanCfi_get(
			req->args.field_qualify_OuterVlanCfi_get.unit,
			req->args.field_qualify_OuterVlanCfi_get.entry,
			req->args.field_qualify_OuterVlanCfi_get.data,
			req->args.field_qualify_OuterVlanCfi_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANID:
		rv = bcm_field_qualify_OuterVlanId(
			req->args.field_qualify_OuterVlanId.unit,
			req->args.field_qualify_OuterVlanId.entry,
			req->args.field_qualify_OuterVlanId.data,
			req->args.field_qualify_OuterVlanId.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANID_GET:
		rv = bcm_field_qualify_OuterVlanId_get(
			req->args.field_qualify_OuterVlanId_get.unit,
			req->args.field_qualify_OuterVlanId_get.entry,
			req->args.field_qualify_OuterVlanId_get.data,
			req->args.field_qualify_OuterVlanId_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANPRI:
		rv = bcm_field_qualify_OuterVlanPri(
			req->args.field_qualify_OuterVlanPri.unit,
			req->args.field_qualify_OuterVlanPri.entry,
			req->args.field_qualify_OuterVlanPri.data,
			req->args.field_qualify_OuterVlanPri.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLANPRI_GET:
		rv = bcm_field_qualify_OuterVlanPri_get(
			req->args.field_qualify_OuterVlanPri_get.unit,
			req->args.field_qualify_OuterVlanPri_get.entry,
			req->args.field_qualify_OuterVlanPri_get.data,
			req->args.field_qualify_OuterVlanPri_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_OUTERVLAN_GET:
		rv = bcm_field_qualify_OuterVlan_get(
			req->args.field_qualify_OuterVlan_get.unit,
			req->args.field_qualify_OuterVlan_get.entry,
			req->args.field_qualify_OuterVlan_get.data,
			req->args.field_qualify_OuterVlan_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETFORMAT:
		rv = bcm_field_qualify_PacketFormat(
			req->args.field_qualify_PacketFormat.unit,
			req->args.field_qualify_PacketFormat.entry,
			req->args.field_qualify_PacketFormat.data,
			req->args.field_qualify_PacketFormat.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETFORMAT_GET:
		rv = bcm_field_qualify_PacketFormat_get(
			req->args.field_qualify_PacketFormat_get.unit,
			req->args.field_qualify_PacketFormat_get.entry,
			req->args.field_qualify_PacketFormat_get.data,
			req->args.field_qualify_PacketFormat_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETRES:
		rv = bcm_field_qualify_PacketRes(
			req->args.field_qualify_PacketRes.unit,
			req->args.field_qualify_PacketRes.entry,
			req->args.field_qualify_PacketRes.data,
			req->args.field_qualify_PacketRes.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_PACKETRES_GET:
		rv = bcm_field_qualify_PacketRes_get(
			req->args.field_qualify_PacketRes_get.unit,
			req->args.field_qualify_PacketRes_get.entry,
			req->args.field_qualify_PacketRes_get.data,
			req->args.field_qualify_PacketRes_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_PORTCLASS:
		rv = bcm_field_qualify_PortClass(
			req->args.field_qualify_PortClass.unit,
			req->args.field_qualify_PortClass.entry,
			req->args.field_qualify_PortClass.data,
			req->args.field_qualify_PortClass.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_PORTCLASS_GET:
		rv = bcm_field_qualify_PortClass_get(
			req->args.field_qualify_PortClass_get.unit,
			req->args.field_qualify_PortClass_get.entry,
			req->args.field_qualify_PortClass_get.data,
			req->args.field_qualify_PortClass_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_RANGECHECK:
		rv = bcm_field_qualify_RangeCheck(
			req->args.field_qualify_RangeCheck.unit,
			req->args.field_qualify_RangeCheck.entry,
			req->args.field_qualify_RangeCheck.range,
			req->args.field_qualify_RangeCheck.invert);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_RANGECHECK_GET:
		rv = bcm_field_qualify_RangeCheck_get(
			req->args.field_qualify_RangeCheck_get.unit,
			req->args.field_qualify_RangeCheck_get.entry,
			req->args.field_qualify_RangeCheck_get.max_count,
			req->args.field_qualify_RangeCheck_get.range,
			req->args.field_qualify_RangeCheck_get.invert,
			req->args.field_qualify_RangeCheck_get.count);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SNAP:
		rv = bcm_field_qualify_Snap(
			req->args.field_qualify_Snap.unit,
			req->args.field_qualify_Snap.entry,
			req->args.field_qualify_Snap.data,
			req->args.field_qualify_Snap.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SNAP_GET:
		rv = bcm_field_qualify_Snap_get(
			req->args.field_qualify_Snap_get.unit,
			req->args.field_qualify_Snap_get.entry,
			req->args.field_qualify_Snap_get.data,
			req->args.field_qualify_Snap_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSFIELD:
		rv = bcm_field_qualify_SrcClassField(
			req->args.field_qualify_SrcClassField.unit,
			req->args.field_qualify_SrcClassField.entry,
			req->args.field_qualify_SrcClassField.data,
			req->args.field_qualify_SrcClassField.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSFIELD_GET:
		rv = bcm_field_qualify_SrcClassField_get(
			req->args.field_qualify_SrcClassField_get.unit,
			req->args.field_qualify_SrcClassField_get.entry,
			req->args.field_qualify_SrcClassField_get.data,
			req->args.field_qualify_SrcClassField_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL2:
		rv = bcm_field_qualify_SrcClassL2(
			req->args.field_qualify_SrcClassL2.unit,
			req->args.field_qualify_SrcClassL2.entry,
			req->args.field_qualify_SrcClassL2.data,
			req->args.field_qualify_SrcClassL2.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL2_GET:
		rv = bcm_field_qualify_SrcClassL2_get(
			req->args.field_qualify_SrcClassL2_get.unit,
			req->args.field_qualify_SrcClassL2_get.entry,
			req->args.field_qualify_SrcClassL2_get.data,
			req->args.field_qualify_SrcClassL2_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL3:
		rv = bcm_field_qualify_SrcClassL3(
			req->args.field_qualify_SrcClassL3.unit,
			req->args.field_qualify_SrcClassL3.entry,
			req->args.field_qualify_SrcClassL3.data,
			req->args.field_qualify_SrcClassL3.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCCLASSL3_GET:
		rv = bcm_field_qualify_SrcClassL3_get(
			req->args.field_qualify_SrcClassL3_get.unit,
			req->args.field_qualify_SrcClassL3_get.entry,
			req->args.field_qualify_SrcClassL3_get.data,
			req->args.field_qualify_SrcClassL3_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP:
		rv = bcm_field_qualify_SrcIp(
			req->args.field_qualify_SrcIp.unit,
			req->args.field_qualify_SrcIp.entry,
			req->args.field_qualify_SrcIp.data,
			req->args.field_qualify_SrcIp.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6:
		rv = bcm_field_qualify_SrcIp6(
			req->args.field_qualify_SrcIp6.unit,
			req->args.field_qualify_SrcIp6.entry,
			req->args.field_qualify_SrcIp6.data,
			req->args.field_qualify_SrcIp6.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6HIGH:
		rv = bcm_field_qualify_SrcIp6High(
			req->args.field_qualify_SrcIp6High.unit,
			req->args.field_qualify_SrcIp6High.entry,
			req->args.field_qualify_SrcIp6High.data,
			req->args.field_qualify_SrcIp6High.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6HIGH_GET:
		rv = bcm_field_qualify_SrcIp6High_get(
			req->args.field_qualify_SrcIp6High_get.unit,
			req->args.field_qualify_SrcIp6High_get.entry,
			req->args.field_qualify_SrcIp6High_get.data,
			req->args.field_qualify_SrcIp6High_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP6_GET:
		rv = bcm_field_qualify_SrcIp6_get(
			req->args.field_qualify_SrcIp6_get.unit,
			req->args.field_qualify_SrcIp6_get.entry,
			req->args.field_qualify_SrcIp6_get.data,
			req->args.field_qualify_SrcIp6_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPEQUALDSTIP:
		rv = bcm_field_qualify_SrcIpEqualDstIp(
			req->args.field_qualify_SrcIpEqualDstIp.unit,
			req->args.field_qualify_SrcIpEqualDstIp.entry,
			req->args.field_qualify_SrcIpEqualDstIp.flag);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIPEQUALDSTIP_GET:
		rv = bcm_field_qualify_SrcIpEqualDstIp_get(
			req->args.field_qualify_SrcIpEqualDstIp_get.unit,
			req->args.field_qualify_SrcIpEqualDstIp_get.entry,
			req->args.field_qualify_SrcIpEqualDstIp_get.flag);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCIP_GET:
		rv = bcm_field_qualify_SrcIp_get(
			req->args.field_qualify_SrcIp_get.unit,
			req->args.field_qualify_SrcIp_get.entry,
			req->args.field_qualify_SrcIp_get.data,
			req->args.field_qualify_SrcIp_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMAC:
		rv = bcm_field_qualify_SrcMac(
			req->args.field_qualify_SrcMac.unit,
			req->args.field_qualify_SrcMac.entry,
			req->args.field_qualify_SrcMac.data,
			req->args.field_qualify_SrcMac.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMACGROUP:
		rv = bcm_field_qualify_SrcMacGroup(
			req->args.field_qualify_SrcMacGroup.unit,
			req->args.field_qualify_SrcMacGroup.entry,
			req->args.field_qualify_SrcMacGroup.data,
			req->args.field_qualify_SrcMacGroup.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMACGROUP_GET:
		rv = bcm_field_qualify_SrcMacGroup_get(
			req->args.field_qualify_SrcMacGroup_get.unit,
			req->args.field_qualify_SrcMacGroup_get.entry,
			req->args.field_qualify_SrcMacGroup_get.data,
			req->args.field_qualify_SrcMacGroup_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMAC_GET:
		rv = bcm_field_qualify_SrcMac_get(
			req->args.field_qualify_SrcMac_get.unit,
			req->args.field_qualify_SrcMac_get.entry,
			req->args.field_qualify_SrcMac_get.data,
			req->args.field_qualify_SrcMac_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMIMGPORT:
		rv = bcm_field_qualify_SrcMimGport(
			req->args.field_qualify_SrcMimGport.unit,
			req->args.field_qualify_SrcMimGport.entry,
			req->args.field_qualify_SrcMimGport.mim_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMIMGPORT_GET:
		rv = bcm_field_qualify_SrcMimGport_get(
			req->args.field_qualify_SrcMimGport_get.unit,
			req->args.field_qualify_SrcMimGport_get.entry,
			req->args.field_qualify_SrcMimGport_get.mim_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODPORTGPORT:
		rv = bcm_field_qualify_SrcModPortGport(
			req->args.field_qualify_SrcModPortGport.unit,
			req->args.field_qualify_SrcModPortGport.entry,
			req->args.field_qualify_SrcModPortGport.data);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODPORTGPORT_GET:
		rv = bcm_field_qualify_SrcModPortGport_get(
			req->args.field_qualify_SrcModPortGport_get.unit,
			req->args.field_qualify_SrcModPortGport_get.entry,
			req->args.field_qualify_SrcModPortGport_get.data);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODID:
		rv = bcm_field_qualify_SrcModid(
			req->args.field_qualify_SrcModid.unit,
			req->args.field_qualify_SrcModid.entry,
			req->args.field_qualify_SrcModid.data,
			req->args.field_qualify_SrcModid.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMODID_GET:
		rv = bcm_field_qualify_SrcModid_get(
			req->args.field_qualify_SrcModid_get.unit,
			req->args.field_qualify_SrcModid_get.entry,
			req->args.field_qualify_SrcModid_get.data,
			req->args.field_qualify_SrcModid_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMPLSGPORT:
		rv = bcm_field_qualify_SrcMplsGport(
			req->args.field_qualify_SrcMplsGport.unit,
			req->args.field_qualify_SrcMplsGport.entry,
			req->args.field_qualify_SrcMplsGport.mpls_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCMPLSGPORT_GET:
		rv = bcm_field_qualify_SrcMplsGport_get(
			req->args.field_qualify_SrcMplsGport_get.unit,
			req->args.field_qualify_SrcMplsGport_get.entry,
			req->args.field_qualify_SrcMplsGport_get.mpls_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORT:
		rv = bcm_field_qualify_SrcPort(
			req->args.field_qualify_SrcPort.unit,
			req->args.field_qualify_SrcPort.entry,
			req->args.field_qualify_SrcPort.data_modid,
			req->args.field_qualify_SrcPort.mask_modid,
			req->args.field_qualify_SrcPort.data_port,
			req->args.field_qualify_SrcPort.mask_port);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTTGID:
		rv = bcm_field_qualify_SrcPortTgid(
			req->args.field_qualify_SrcPortTgid.unit,
			req->args.field_qualify_SrcPortTgid.entry,
			req->args.field_qualify_SrcPortTgid.data,
			req->args.field_qualify_SrcPortTgid.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORTTGID_GET:
		rv = bcm_field_qualify_SrcPortTgid_get(
			req->args.field_qualify_SrcPortTgid_get.unit,
			req->args.field_qualify_SrcPortTgid_get.entry,
			req->args.field_qualify_SrcPortTgid_get.data,
			req->args.field_qualify_SrcPortTgid_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCPORT_GET:
		rv = bcm_field_qualify_SrcPort_get(
			req->args.field_qualify_SrcPort_get.unit,
			req->args.field_qualify_SrcPort_get.entry,
			req->args.field_qualify_SrcPort_get.data_modid,
			req->args.field_qualify_SrcPort_get.mask_modid,
			req->args.field_qualify_SrcPort_get.data_port,
			req->args.field_qualify_SrcPort_get.mask_port);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCTRUNK:
		rv = bcm_field_qualify_SrcTrunk(
			req->args.field_qualify_SrcTrunk.unit,
			req->args.field_qualify_SrcTrunk.entry,
			req->args.field_qualify_SrcTrunk.data,
			req->args.field_qualify_SrcTrunk.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCTRUNK_GET:
		rv = bcm_field_qualify_SrcTrunk_get(
			req->args.field_qualify_SrcTrunk_get.unit,
			req->args.field_qualify_SrcTrunk_get.entry,
			req->args.field_qualify_SrcTrunk_get.data,
			req->args.field_qualify_SrcTrunk_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCWLANGPORT:
		rv = bcm_field_qualify_SrcWlanGport(
			req->args.field_qualify_SrcWlanGport.unit,
			req->args.field_qualify_SrcWlanGport.entry,
			req->args.field_qualify_SrcWlanGport.wlan_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_SRCWLANGPORT_GET:
		rv = bcm_field_qualify_SrcWlanGport_get(
			req->args.field_qualify_SrcWlanGport_get.unit,
			req->args.field_qualify_SrcWlanGport_get.entry,
			req->args.field_qualify_SrcWlanGport_get.wlan_port_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_STAGE:
		rv = bcm_field_qualify_Stage(
			req->args.field_qualify_Stage.unit,
			req->args.field_qualify_Stage.entry,
			req->args.field_qualify_Stage.stage);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPCONTROL:
		rv = bcm_field_qualify_TcpControl(
			req->args.field_qualify_TcpControl.unit,
			req->args.field_qualify_TcpControl.entry,
			req->args.field_qualify_TcpControl.data,
			req->args.field_qualify_TcpControl.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPCONTROL_GET:
		rv = bcm_field_qualify_TcpControl_get(
			req->args.field_qualify_TcpControl_get.unit,
			req->args.field_qualify_TcpControl_get.entry,
			req->args.field_qualify_TcpControl_get.data,
			req->args.field_qualify_TcpControl_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPHEADERSIZE:
		rv = bcm_field_qualify_TcpHeaderSize(
			req->args.field_qualify_TcpHeaderSize.unit,
			req->args.field_qualify_TcpHeaderSize.entry,
			req->args.field_qualify_TcpHeaderSize.data,
			req->args.field_qualify_TcpHeaderSize.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPHEADERSIZE_GET:
		rv = bcm_field_qualify_TcpHeaderSize_get(
			req->args.field_qualify_TcpHeaderSize_get.unit,
			req->args.field_qualify_TcpHeaderSize_get.entry,
			req->args.field_qualify_TcpHeaderSize_get.data,
			req->args.field_qualify_TcpHeaderSize_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPSEQUENCEZERO:
		rv = bcm_field_qualify_TcpSequenceZero(
			req->args.field_qualify_TcpSequenceZero.unit,
			req->args.field_qualify_TcpSequenceZero.entry,
			req->args.field_qualify_TcpSequenceZero.flag);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TCPSEQUENCEZERO_GET:
		rv = bcm_field_qualify_TcpSequenceZero_get(
			req->args.field_qualify_TcpSequenceZero_get.unit,
			req->args.field_qualify_TcpSequenceZero_get.entry,
			req->args.field_qualify_TcpSequenceZero_get.flag);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TOS:
		rv = bcm_field_qualify_Tos(
			req->args.field_qualify_Tos.unit,
			req->args.field_qualify_Tos.entry,
			req->args.field_qualify_Tos.data,
			req->args.field_qualify_Tos.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDVLANFORMAT:
		rv = bcm_field_qualify_TranslatedVlanFormat(
			req->args.field_qualify_TranslatedVlanFormat.unit,
			req->args.field_qualify_TranslatedVlanFormat.entry,
			req->args.field_qualify_TranslatedVlanFormat.data,
			req->args.field_qualify_TranslatedVlanFormat.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TRANSLATEDVLANFORMAT_GET:
		rv = bcm_field_qualify_TranslatedVlanFormat_get(
			req->args.field_qualify_TranslatedVlanFormat_get.unit,
			req->args.field_qualify_TranslatedVlanFormat_get.entry,
			req->args.field_qualify_TranslatedVlanFormat_get.data,
			req->args.field_qualify_TranslatedVlanFormat_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TTL:
		rv = bcm_field_qualify_Ttl(
			req->args.field_qualify_Ttl.unit,
			req->args.field_qualify_Ttl.entry,
			req->args.field_qualify_Ttl.data,
			req->args.field_qualify_Ttl.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TTL_GET:
		rv = bcm_field_qualify_Ttl_get(
			req->args.field_qualify_Ttl_get.unit,
			req->args.field_qualify_Ttl_get.entry,
			req->args.field_qualify_Ttl_get.data,
			req->args.field_qualify_Ttl_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATED:
		rv = bcm_field_qualify_TunnelTerminated(
			req->args.field_qualify_TunnelTerminated.unit,
			req->args.field_qualify_TunnelTerminated.entry,
			req->args.field_qualify_TunnelTerminated.data,
			req->args.field_qualify_TunnelTerminated.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTERMINATED_GET:
		rv = bcm_field_qualify_TunnelTerminated_get(
			req->args.field_qualify_TunnelTerminated_get.unit,
			req->args.field_qualify_TunnelTerminated_get.entry,
			req->args.field_qualify_TunnelTerminated_get.data,
			req->args.field_qualify_TunnelTerminated_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTYPE:
		rv = bcm_field_qualify_TunnelType(
			req->args.field_qualify_TunnelType.unit,
			req->args.field_qualify_TunnelType.entry,
			req->args.field_qualify_TunnelType.tunnel_type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_TUNNELTYPE_GET:
		rv = bcm_field_qualify_TunnelType_get(
			req->args.field_qualify_TunnelType_get.unit,
			req->args.field_qualify_TunnelType_get.entry,
			req->args.field_qualify_TunnelType_get.tunnel_type);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_USERDEFINED:
		rv = bcm_field_qualify_UserDefined(
			req->args.field_qualify_UserDefined.unit,
			req->args.field_qualify_UserDefined.entry,
			req->args.field_qualify_UserDefined.udf_id,
			req->args.field_qualify_UserDefined.data,
			req->args.field_qualify_UserDefined.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_USERDEFINED_GET:
		rv = bcm_field_qualify_UserDefined_get(
			req->args.field_qualify_UserDefined_get.unit,
			req->args.field_qualify_UserDefined_get.entry,
			req->args.field_qualify_UserDefined_get.udf_id,
			req->args.field_qualify_UserDefined_get.data,
			req->args.field_qualify_UserDefined_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANFORMAT:
		rv = bcm_field_qualify_VlanFormat(
			req->args.field_qualify_VlanFormat.unit,
			req->args.field_qualify_VlanFormat.entry,
			req->args.field_qualify_VlanFormat.data,
			req->args.field_qualify_VlanFormat.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANFORMAT_GET:
		rv = bcm_field_qualify_VlanFormat_get(
			req->args.field_qualify_VlanFormat_get.unit,
			req->args.field_qualify_VlanFormat_get.entry,
			req->args.field_qualify_VlanFormat_get.data,
			req->args.field_qualify_VlanFormat_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANTRANSLATIONHIT:
		rv = bcm_field_qualify_VlanTranslationHit(
			req->args.field_qualify_VlanTranslationHit.unit,
			req->args.field_qualify_VlanTranslationHit.entry,
			req->args.field_qualify_VlanTranslationHit.data,
			req->args.field_qualify_VlanTranslationHit.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_VLANTRANSLATIONHIT_GET:
		rv = bcm_field_qualify_VlanTranslationHit_get(
			req->args.field_qualify_VlanTranslationHit_get.unit,
			req->args.field_qualify_VlanTranslationHit_get.entry,
			req->args.field_qualify_VlanTranslationHit_get.data,
			req->args.field_qualify_VlanTranslationHit_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_VPN:
		rv = bcm_field_qualify_Vpn(
			req->args.field_qualify_Vpn.unit,
			req->args.field_qualify_Vpn.entry,
			req->args.field_qualify_Vpn.data,
			req->args.field_qualify_Vpn.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_VPN_GET:
		rv = bcm_field_qualify_Vpn_get(
			req->args.field_qualify_Vpn_get.unit,
			req->args.field_qualify_Vpn_get.entry,
			req->args.field_qualify_Vpn_get.data,
			req->args.field_qualify_Vpn_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_VRF:
		rv = bcm_field_qualify_Vrf(
			req->args.field_qualify_Vrf.unit,
			req->args.field_qualify_Vrf.entry,
			req->args.field_qualify_Vrf.data,
			req->args.field_qualify_Vrf.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_VRF_GET:
		rv = bcm_field_qualify_Vrf_get(
			req->args.field_qualify_Vrf_get.unit,
			req->args.field_qualify_Vrf_get.entry,
			req->args.field_qualify_Vrf_get.data,
			req->args.field_qualify_Vrf_get.mask);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_CLEAR:
		rv = bcm_field_qualify_clear(
			req->args.field_qualify_clear.unit,
			req->args.field_qualify_clear.entry);
		break;
	case BCM_ASYNC_ENTRY_FIELD_QUALIFY_DATA:
		rv = bcm_field_qualify_data(
			req->args.field_qualify_data.unit,
			req->args.field_qualify_data.eid,
			req->args.field_qualify_data.qual_id,
			req->args.field_qualify_data.data,
			req->args.field_qualify_data.mask,
			req->args.field_qualify_data.length);
		break;
	case BCM_ASYNC_ENTRY_FIELD_RANGE_CREATE:
		rv = bcm_field_range_create(
			req->args.field_range_create.unit,
			req->args.field_range_create.range,
			req->args.field_range_create.flags,
			req->args.field_range_create.min,
			req->args.field_range_create.max);
		break;
	case BCM_ASYNC_ENTRY_FIELD_RANGE_CREATE_ID:
		rv = bcm_field_range_create_id(
			req->args.field_range_create_id.unit,
			req->args.field_range_create_id.range,
			req->args.field_range_create_id.flags,
			req->args.field_range_create_id.min,
			req->args.field_range_create_id.max);
		break;
	case BCM_ASYNC_ENTRY_FIELD_RANGE_DESTROY:
		rv = bcm_field_range_destroy(
			req->args.field_range_destroy.unit,
			req->args.field_range_destroy.range);
		break;
	case BCM_ASYNC_ENTRY_FIELD_RANGE_GET:
		rv = bcm_field_range_get(
			req->args.field_range_get.unit,
			req->args.field_range_get.range,
			req->args.field_range_get.flags,
			req->args.field_range_get.min,
			req->args.field_range_get.max);
		break;
	case BCM_ASYNC_ENTRY_FIELD_RANGE_GROUP_CREATE:
		rv = bcm_field_range_group_create(
			req->args.field_range_group_create.unit,
			req->args.field_range_group_create.range,
			req->args.field_range_group_create.flags,
			req->args.field_range_group_create.min,
			req->args.field_range_group_create.max,
			req->args.field_range_group_create.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_RANGE_GROUP_CREATE_ID:
		rv = bcm_field_range_group_create_id(
			req->args.field_range_group_create_id.unit,
			req->args.field_range_group_create_id.range,
			req->args.field_range_group_create_id.flags,
			req->args.field_range_group_create_id.min,
			req->args.field_range_group_create_id.max,
			req->args.field_range_group_create_id.group);
		break;
	case BCM_ASYNC_ENTRY_FIELD_RESYNC:
		rv = bcm_field_resync(
			req->args.field_resync.unit);
		break;
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_FIELD_SHOW:
		rv = bcm_field_show(
			req->args.field_show.unit,
			req->args.field_show.pfx);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_FIELD_STAT_ALL_SET:
		rv = bcm_field_stat_all_set(
			req->args.field_stat_all_set.unit,
			req->args.field_stat_all_set.stat_id,
			req->args.field_stat_all_set.value);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_ALL_SET32:
		rv = bcm_field_stat_all_set32(
			req->args.field_stat_all_set32.unit,
			req->args.field_stat_all_set32.stat_id,
			req->args.field_stat_all_set32.value);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_CONFIG_GET:
		rv = bcm_field_stat_config_get(
			req->args.field_stat_config_get.unit,
			req->args.field_stat_config_get.stat_id,
			req->args.field_stat_config_get.nstat,
			req->args.field_stat_config_get.stat_arr);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_CREATE:
		rv = bcm_field_stat_create(
			req->args.field_stat_create.unit,
			req->args.field_stat_create.group,
			req->args.field_stat_create.nstat,
			req->args.field_stat_create.stat_arr,
			req->args.field_stat_create.stat_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_DESTROY:
		rv = bcm_field_stat_destroy(
			req->args.field_stat_destroy.unit,
			req->args.field_stat_destroy.stat_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_GET:
		rv = bcm_field_stat_get(
			req->args.field_stat_get.unit,
			req->args.field_stat_get.stat_id,
			req->args.field_stat_get.stat,
			req->args.field_stat_get.value);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_GET32:
		rv = bcm_field_stat_get32(
			req->args.field_stat_get32.unit,
			req->args.field_stat_get32.stat_id,
			req->args.field_stat_get32.stat,
			req->args.field_stat_get32.value);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_MULTI_GET:
		rv = bcm_field_stat_multi_get(
			req->args.field_stat_multi_get.unit,
			req->args.field_stat_multi_get.stat_id,
			req->args.field_stat_multi_get.nstat,
			req->args.field_stat_multi_get.stat_arr,
			req->args.field_stat_multi_get.value_arr);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_MULTI_GET32:
		rv = bcm_field_stat_multi_get32(
			req->args.field_stat_multi_get32.unit,
			req->args.field_stat_multi_get32.stat_id,
			req->args.field_stat_multi_get32.nstat,
			req->args.field_stat_multi_get32.stat_arr,
			req->args.field_stat_multi_get32.value_arr);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_SET:
		rv = bcm_field_stat_set(
			req->args.field_stat_set.unit,
			req->args.field_stat_set.stat_id,
			req->args.field_stat_set.stat,
			req->args.field_stat_set.value);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_SET32:
		rv = bcm_field_stat_set32(
			req->args.field_stat_set32.unit,
			req->args.field_stat_set32.stat_id,
			req->args.field_stat_set32.stat,
			req->args.field_stat_set32.value);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STAT_SIZE:
		rv = bcm_field_stat_size(
			req->args.field_stat_size.unit,
			req->args.field_stat_size.stat_id,
			req->args.field_stat_size.stat_size);
		break;
	case BCM_ASYNC_ENTRY_FIELD_STATUS_GET:
		rv = bcm_field_status_get(
			req->args.field_status_get.unit,
			req->args.field_status_get.status);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_CREATE:
		rv = bcm_field_udf_create(
			req->args.field_udf_create.unit,
			req->args.field_udf_create.udf_spec,
			req->args.field_udf_create.udf_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_CREATE_ID:
		rv = bcm_field_udf_create_id(
			req->args.field_udf_create_id.unit,
			req->args.field_udf_create_id.udf_spec,
			req->args.field_udf_create_id.udf_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_DESTROY:
		rv = bcm_field_udf_destroy(
			req->args.field_udf_destroy.unit,
			req->args.field_udf_destroy.udf_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_ETHERTYPE_GET:
		rv = bcm_field_udf_ethertype_get(
			req->args.field_udf_ethertype_get.unit,
			req->args.field_udf_ethertype_get.index,
			req->args.field_udf_ethertype_get.frametype,
			req->args.field_udf_ethertype_get.ethertype);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_ETHERTYPE_SET:
		rv = bcm_field_udf_ethertype_set(
			req->args.field_udf_ethertype_set.unit,
			req->args.field_udf_ethertype_set.index,
			req->args.field_udf_ethertype_set.frametype,
			req->args.field_udf_ethertype_set.ethertype);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_GET:
		rv = bcm_field_udf_get(
			req->args.field_udf_get.unit,
			req->args.field_udf_get.udf_spec,
			req->args.field_udf_get.udf_id);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_IPPROTOCOL_GET:
		rv = bcm_field_udf_ipprotocol_get(
			req->args.field_udf_ipprotocol_get.unit,
			req->args.field_udf_ipprotocol_get.index,
			req->args.field_udf_ipprotocol_get.flags,
			req->args.field_udf_ipprotocol_get.proto);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_IPPROTOCOL_SET:
		rv = bcm_field_udf_ipprotocol_set(
			req->args.field_udf_ipprotocol_set.unit,
			req->args.field_udf_ipprotocol_set.index,
			req->args.field_udf_ipprotocol_set.flags,
			req->args.field_udf_ipprotocol_set.proto);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_SPEC_GET:
		rv = bcm_field_udf_spec_get(
			req->args.field_udf_spec_get.unit,
			req->args.field_udf_spec_get.udf_spec,
			req->args.field_udf_spec_get.flags,
			req->args.field_udf_spec_get.offset);
		break;
	case BCM_ASYNC_ENTRY_FIELD_UDF_SPEC_SET:
		rv = bcm_field_udf_spec_set(
			req->args.field_udf_spec_set.unit,
			req->args.field_udf_spec_set.udf_spec,
			req->args.field_udf_spec_set.flags,
			req->args.field_udf_spec_set.offset);
		break;
	case BCM_ASYNC_ENTRY_FILTER_ACTION_MATCH:
		rv = bcm_filter_action_match(
			req->args.filter_action_match.unit,
			req->args.filter_action_match.f,
			req->args.filter_action_match.action,
			req->args.filter_action_match.param);
		break;
	case BCM_ASYNC_ENTRY_FILTER_ACTION_NO_MATCH:
		rv = bcm_filter_action_no_match(
			req->args.filter_action_no_match.unit,
			req->args.filter_action_no_match.f,
			req->args.filter_action_no_match.action,
			req->args.filter_action_no_match.param);
		break;
	case BCM_ASYNC_ENTRY_FILTER_ACTION_OUT_PROFILE:
		rv = bcm_filter_action_out_profile(
			req->args.filter_action_out_profile.unit,
			req->args.filter_action_out_profile.f,
			req->args.filter_action_out_profile.action,
			req->args.filter_action_out_profile.param,
			req->args.filter_action_out_profile.meter_id);
		break;
	case BCM_ASYNC_ENTRY_FILTER_COPY:
		rv = bcm_filter_copy(
			req->args.filter_copy.unit,
			req->args.filter_copy.f_src,
			req->args.filter_copy.f_return);
		break;
	case BCM_ASYNC_ENTRY_FILTER_COPY_ID:
		rv = bcm_filter_copy_id(
			req->args.filter_copy_id.unit,
			req->args.filter_copy_id.f_src,
			req->args.filter_copy_id.f_dest);
		break;
	case BCM_ASYNC_ENTRY_FILTER_CREATE:
		rv = bcm_filter_create(
			req->args.filter_create.unit,
			req->args.filter_create.f_return);
		break;
	case BCM_ASYNC_ENTRY_FILTER_CREATE_ID:
		rv = bcm_filter_create_id(
			req->args.filter_create_id.unit,
			req->args.filter_create_id.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_DESTROY:
		rv = bcm_filter_destroy(
			req->args.filter_destroy.unit,
			req->args.filter_destroy.f);
		break;
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_FILTER_DUMP:
		rv = bcm_filter_dump(
			req->args.filter_dump.unit,
			req->args.filter_dump.f);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_FILTER_INIT:
		rv = bcm_filter_init(
			req->args.filter_init.unit);
		break;
	case BCM_ASYNC_ENTRY_FILTER_INSTALL:
		rv = bcm_filter_install(
			req->args.filter_install.unit,
			req->args.filter_install.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_BROADCAST:
		rv = bcm_filter_qualify_broadcast(
			req->args.filter_qualify_broadcast.unit,
			req->args.filter_qualify_broadcast.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_DATA:
		rv = bcm_filter_qualify_data(
			req->args.filter_qualify_data.unit,
			req->args.filter_qualify_data.f,
			req->args.filter_qualify_data.offset,
			req->args.filter_qualify_data.len,
			req->args.filter_qualify_data.data,
			req->args.filter_qualify_data.mask);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_DATA16:
		rv = bcm_filter_qualify_data16(
			req->args.filter_qualify_data16.unit,
			req->args.filter_qualify_data16.f,
			req->args.filter_qualify_data16.offset,
			req->args.filter_qualify_data16.val,
			req->args.filter_qualify_data16.mask);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_DATA32:
		rv = bcm_filter_qualify_data32(
			req->args.filter_qualify_data32.unit,
			req->args.filter_qualify_data32.f,
			req->args.filter_qualify_data32.offset,
			req->args.filter_qualify_data32.val,
			req->args.filter_qualify_data32.mask);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_DATA8:
		rv = bcm_filter_qualify_data8(
			req->args.filter_qualify_data8.unit,
			req->args.filter_qualify_data8.f,
			req->args.filter_qualify_data8.offset,
			req->args.filter_qualify_data8.val,
			req->args.filter_qualify_data8.mask);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_EGRESS:
		rv = bcm_filter_qualify_egress(
			req->args.filter_qualify_egress.unit,
			req->args.filter_qualify_egress.f,
			req->args.filter_qualify_egress.pbmp);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_EGRESS_MODID:
		rv = bcm_filter_qualify_egress_modid(
			req->args.filter_qualify_egress_modid.unit,
			req->args.filter_qualify_egress_modid.f,
			req->args.filter_qualify_egress_modid.module_id);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_FORMAT:
		rv = bcm_filter_qualify_format(
			req->args.filter_qualify_format.unit,
			req->args.filter_qualify_format.f,
			req->args.filter_qualify_format.format);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_INGRESS:
		rv = bcm_filter_qualify_ingress(
			req->args.filter_qualify_ingress.unit,
			req->args.filter_qualify_ingress.f,
			req->args.filter_qualify_ingress.pbmp);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_KNOWN_MCAST:
		rv = bcm_filter_qualify_known_mcast(
			req->args.filter_qualify_known_mcast.unit,
			req->args.filter_qualify_known_mcast.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_KNOWN_UCAST:
		rv = bcm_filter_qualify_known_ucast(
			req->args.filter_qualify_known_ucast.unit,
			req->args.filter_qualify_known_ucast.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_PRIORITY:
		rv = bcm_filter_qualify_priority(
			req->args.filter_qualify_priority.unit,
			req->args.filter_qualify_priority.f,
			req->args.filter_qualify_priority.prio);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_STOP:
		rv = bcm_filter_qualify_stop(
			req->args.filter_qualify_stop.unit,
			req->args.filter_qualify_stop.f,
			req->args.filter_qualify_stop.partial_match);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_UNKNOWN_MCAST:
		rv = bcm_filter_qualify_unknown_mcast(
			req->args.filter_qualify_unknown_mcast.unit,
			req->args.filter_qualify_unknown_mcast.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_QUALIFY_UNKNOWN_UCAST:
		rv = bcm_filter_qualify_unknown_ucast(
			req->args.filter_qualify_unknown_ucast.unit,
			req->args.filter_qualify_unknown_ucast.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_REINSTALL:
		rv = bcm_filter_reinstall(
			req->args.filter_reinstall.unit,
			req->args.filter_reinstall.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_REMOVE:
		rv = bcm_filter_remove(
			req->args.filter_remove.unit,
			req->args.filter_remove.f);
		break;
	case BCM_ASYNC_ENTRY_FILTER_REMOVE_ALL:
		rv = bcm_filter_remove_all(
			req->args.filter_remove_all.unit);
		break;
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_FILTER_SHOW:
		rv = bcm_filter_show(
			req->args.filter_show.unit,
			req->args.filter_show.pfx);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_FIND:
		rv = bcm_find(
			req->args.find.type,
			req->args.find.subtype,
			req->args.find.remunit);
		break;
	case BCM_ASYNC_ENTRY_HTLS_EGRESS_PORT_GET:
		rv = bcm_htls_egress_port_get(
			req->args.htls_egress_port_get.unit,
			req->args.htls_egress_port_get.port,
			req->args.htls_egress_port_get.ttl,
			req->args.htls_egress_port_get.mmc_type,
			req->args.htls_egress_port_get.flags);
		break;
	case BCM_ASYNC_ENTRY_HTLS_EGRESS_PORT_SET:
		rv = bcm_htls_egress_port_set(
			req->args.htls_egress_port_set.unit,
			req->args.htls_egress_port_set.port,
			req->args.htls_egress_port_set.ttl,
			req->args.htls_egress_port_set.mmc_type,
			req->args.htls_egress_port_set.flags);
		break;
	case BCM_ASYNC_ENTRY_HTLS_MODE_GET:
		rv = bcm_htls_mode_get(
			req->args.htls_mode_get.unit,
			req->args.htls_mode_get.enable);
		break;
	case BCM_ASYNC_ENTRY_HTLS_MODE_SET:
		rv = bcm_htls_mode_set(
			req->args.htls_mode_set.unit,
			req->args.htls_mode_set.enable);
		break;
	case BCM_ASYNC_ENTRY_HTLS_TUNNEL_LABEL_GET:
		rv = bcm_htls_tunnel_label_get(
			req->args.htls_tunnel_label_get.unit,
			req->args.htls_tunnel_label_get.port,
			req->args.htls_tunnel_label_get.tunnel_label);
		break;
	case BCM_ASYNC_ENTRY_HTLS_TUNNEL_LABEL_SET:
		rv = bcm_htls_tunnel_label_set(
			req->args.htls_tunnel_label_set.unit,
			req->args.htls_tunnel_label_set.port,
			req->args.htls_tunnel_label_set.tunnel_label);
		break;
	case BCM_ASYNC_ENTRY_HTLS_UPLINK_DA_GET:
		rv = bcm_htls_uplink_da_get(
			req->args.htls_uplink_da_get.unit,
			req->args.htls_uplink_da_get.port,
			req->args.htls_uplink_da_get.dest_mac);
		break;
	case BCM_ASYNC_ENTRY_HTLS_UPLINK_DA_SET:
		rv = bcm_htls_uplink_da_set(
			req->args.htls_uplink_da_set.unit,
			req->args.htls_uplink_da_set.port,
			req->args.htls_uplink_da_set.dest_mac);
		break;
	case BCM_ASYNC_ENTRY_HTLS_UPLINK_SA_GET:
		rv = bcm_htls_uplink_sa_get(
			req->args.htls_uplink_sa_get.unit,
			req->args.htls_uplink_sa_get.port,
			req->args.htls_uplink_sa_get.src_mac);
		break;
	case BCM_ASYNC_ENTRY_HTLS_UPLINK_SA_SET:
		rv = bcm_htls_uplink_sa_set(
			req->args.htls_uplink_sa_set.unit,
			req->args.htls_uplink_sa_set.port,
			req->args.htls_uplink_sa_set.src_mac);
		break;
	case BCM_ASYNC_ENTRY_HTLS_VCLABEL_GET:
		rv = bcm_htls_vclabel_get(
			req->args.htls_vclabel_get.unit,
			req->args.htls_vclabel_get.port,
			req->args.htls_vclabel_get.vc_label);
		break;
	case BCM_ASYNC_ENTRY_HTLS_VCLABEL_SET:
		rv = bcm_htls_vclabel_set(
			req->args.htls_vclabel_set.unit,
			req->args.htls_vclabel_set.port,
			req->args.htls_vclabel_set.vc_label);
		break;
#ifdef	INCLUDE_I2C
	case BCM_ASYNC_ENTRY_I2C_IOCTL:
		rv = bcm_i2c_ioctl(
			req->args.i2c_ioctl.unit,
			req->args.i2c_ioctl.fd,
			req->args.i2c_ioctl.opcode,
			req->args.i2c_ioctl.data,
			req->args.i2c_ioctl.len);
		break;
	case BCM_ASYNC_ENTRY_I2C_OPEN:
		rv = bcm_i2c_open(
			req->args.i2c_open.unit,
			req->args.i2c_open.devname,
			req->args.i2c_open.flags,
			req->args.i2c_open.speed);
		break;
	case BCM_ASYNC_ENTRY_I2C_READ:
		rv = bcm_i2c_read(
			req->args.i2c_read.unit,
			req->args.i2c_read.fd,
			req->args.i2c_read.addr,
			req->args.i2c_read.data,
			req->args.i2c_read.nbytes);
		break;
	case BCM_ASYNC_ENTRY_I2C_WRITE:
		rv = bcm_i2c_write(
			req->args.i2c_write.unit,
			req->args.i2c_write.fd,
			req->args.i2c_write.addr,
			req->args.i2c_write.data,
			req->args.i2c_write.nbytes);
		break;
#endif	/* INCLUDE_I2C */
	case BCM_ASYNC_ENTRY_IGMP_SNOOPING_ENABLE_GET:
		rv = bcm_igmp_snooping_enable_get(
			req->args.igmp_snooping_enable_get.unit,
			req->args.igmp_snooping_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_IGMP_SNOOPING_ENABLE_SET:
		rv = bcm_igmp_snooping_enable_set(
			req->args.igmp_snooping_enable_set.unit,
			req->args.igmp_snooping_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_IGMP_SNOOPING_INIT:
		rv = bcm_igmp_snooping_init(
			req->args.igmp_snooping_init.unit);
		break;
	case BCM_ASYNC_ENTRY_INFO_GET:
		rv = bcm_info_get(
			req->args.info_get.unit,
			req->args.info_get.info);
		break;
	case BCM_ASYNC_ENTRY_INIT:
		rv = bcm_init(
			req->args.init.unit);
		break;
	case BCM_ASYNC_ENTRY_INIT_CHECK:
		rv = bcm_init_check(
			req->args.init_check.unit);
		break;
	case BCM_ASYNC_ENTRY_INIT_PHY_ID_MAP:
		rv = bcm_init_phy_id_map(
			req->args.init_phy_id_map.unit,
			req->args.init_phy_id_map.map);
		break;
	case BCM_ASYNC_ENTRY_INIT_SELECTIVE:
		rv = bcm_init_selective(
			req->args.init_selective.unit,
			req->args.init_selective.flags);
		break;
	case BCM_ASYNC_ENTRY_IP6_MASK_CREATE:
		rv = bcm_ip6_mask_create(
			req->args.ip6_mask_create.ip6,
			req->args.ip6_mask_create.len);
		break;
	case BCM_ASYNC_ENTRY_IP6_MASK_LENGTH:
		rv = bcm_ip6_mask_length(
			req->args.ip6_mask_length.mask);
		break;
	/* bcm_ip_mask_create has a non int return type */
	case BCM_ASYNC_ENTRY_IP_MASK_LENGTH:
		rv = bcm_ip_mask_length(
			req->args.ip_mask_length.ip);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_CONFIG_GET:
		rv = bcm_ipfix_config_get(
			req->args.ipfix_config_get.unit,
			req->args.ipfix_config_get.stage,
			req->args.ipfix_config_get.port,
			req->args.ipfix_config_get.config);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_CONFIG_SET:
		rv = bcm_ipfix_config_set(
			req->args.ipfix_config_set.unit,
			req->args.ipfix_config_set.stage,
			req->args.ipfix_config_set.port,
			req->args.ipfix_config_set.config);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_MIRROR_CONFIG_GET:
		rv = bcm_ipfix_mirror_config_get(
			req->args.ipfix_mirror_config_get.unit,
			req->args.ipfix_mirror_config_get.stage,
			req->args.ipfix_mirror_config_get.port,
			req->args.ipfix_mirror_config_get.config);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_MIRROR_CONFIG_SET:
		rv = bcm_ipfix_mirror_config_set(
			req->args.ipfix_mirror_config_set.unit,
			req->args.ipfix_mirror_config_set.stage,
			req->args.ipfix_mirror_config_set.port,
			req->args.ipfix_mirror_config_set.config);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_ADD:
		rv = bcm_ipfix_mirror_port_dest_add(
			req->args.ipfix_mirror_port_dest_add.unit,
			req->args.ipfix_mirror_port_dest_add.stage,
			req->args.ipfix_mirror_port_dest_add.port,
			req->args.ipfix_mirror_port_dest_add.mirror_dest_id);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_DELETE:
		rv = bcm_ipfix_mirror_port_dest_delete(
			req->args.ipfix_mirror_port_dest_delete.unit,
			req->args.ipfix_mirror_port_dest_delete.stage,
			req->args.ipfix_mirror_port_dest_delete.port,
			req->args.ipfix_mirror_port_dest_delete.mirror_dest_id);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_DELETE_ALL:
		rv = bcm_ipfix_mirror_port_dest_delete_all(
			req->args.ipfix_mirror_port_dest_delete_all.unit,
			req->args.ipfix_mirror_port_dest_delete_all.stage,
			req->args.ipfix_mirror_port_dest_delete_all.port);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_MIRROR_PORT_DEST_GET:
		rv = bcm_ipfix_mirror_port_dest_get(
			req->args.ipfix_mirror_port_dest_get.unit,
			req->args.ipfix_mirror_port_dest_get.stage,
			req->args.ipfix_mirror_port_dest_get.port,
			req->args.ipfix_mirror_port_dest_get.mirror_dest_size,
			req->args.ipfix_mirror_port_dest_get.mirror_dest_id,
			req->args.ipfix_mirror_port_dest_get.mirror_dest_count);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_CREATE:
		rv = bcm_ipfix_rate_create(
			req->args.ipfix_rate_create.unit,
			req->args.ipfix_rate_create.rate_info);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_DESTROY:
		rv = bcm_ipfix_rate_destroy(
			req->args.ipfix_rate_destroy.unit,
			req->args.ipfix_rate_destroy.rate_id);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_DESTROY_ALL:
		rv = bcm_ipfix_rate_destroy_all(
			req->args.ipfix_rate_destroy_all.unit);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_GET:
		rv = bcm_ipfix_rate_get(
			req->args.ipfix_rate_get.unit,
			req->args.ipfix_rate_get.rate_info);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_MIRROR_ADD:
		rv = bcm_ipfix_rate_mirror_add(
			req->args.ipfix_rate_mirror_add.unit,
			req->args.ipfix_rate_mirror_add.rate_id,
			req->args.ipfix_rate_mirror_add.mirror_dest_id);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_MIRROR_DELETE:
		rv = bcm_ipfix_rate_mirror_delete(
			req->args.ipfix_rate_mirror_delete.unit,
			req->args.ipfix_rate_mirror_delete.rate_id,
			req->args.ipfix_rate_mirror_delete.mirror_dest_id);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_MIRROR_DELETE_ALL:
		rv = bcm_ipfix_rate_mirror_delete_all(
			req->args.ipfix_rate_mirror_delete_all.unit,
			req->args.ipfix_rate_mirror_delete_all.rate_id);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_MIRROR_GET:
		rv = bcm_ipfix_rate_mirror_get(
			req->args.ipfix_rate_mirror_get.unit,
			req->args.ipfix_rate_mirror_get.rate_id,
			req->args.ipfix_rate_mirror_get.mirror_dest_size,
			req->args.ipfix_rate_mirror_get.mirror_dest_id,
			req->args.ipfix_rate_mirror_get.mirror_dest_count);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_RATE_TRAVERSE:
		rv = bcm_ipfix_rate_traverse(
			req->args.ipfix_rate_traverse.unit,
			req->args.ipfix_rate_traverse.cb,
			req->args.ipfix_rate_traverse.userdata);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_REGISTER:
		rv = bcm_ipfix_register(
			req->args.ipfix_register.unit,
			req->args.ipfix_register.callback,
			req->args.ipfix_register.userdata);
		break;
	case BCM_ASYNC_ENTRY_IPFIX_UNREGISTER:
		rv = bcm_ipfix_unregister(
			req->args.ipfix_unregister.unit,
			req->args.ipfix_unregister.callback,
			req->args.ipfix_unregister.userdata);
		break;
#ifdef	INCLUDE_L3
	case BCM_ASYNC_ENTRY_IPMC_ADD:
		rv = bcm_ipmc_add(
			req->args.ipmc_add.unit,
			req->args.ipmc_add.data);
		break;
	case BCM_ASYNC_ENTRY_IPMC_ADD_L2_PORTS:
		rv = bcm_ipmc_add_l2_ports(
			req->args.ipmc_add_l2_ports.unit,
			req->args.ipmc_add_l2_ports.s_ip_addr,
			req->args.ipmc_add_l2_ports.mc_ip_addr,
			req->args.ipmc_add_l2_ports.vid,
			req->args.ipmc_add_l2_ports.pbmp,
			req->args.ipmc_add_l2_ports.ut_pbmp);
		break;
	case BCM_ASYNC_ENTRY_IPMC_ADD_L3_PORTS:
		rv = bcm_ipmc_add_l3_ports(
			req->args.ipmc_add_l3_ports.unit,
			req->args.ipmc_add_l3_ports.s_ip_addr,
			req->args.ipmc_add_l3_ports.mc_ip_addr,
			req->args.ipmc_add_l3_ports.vid,
			req->args.ipmc_add_l3_ports.pbmp);
		break;
	case BCM_ASYNC_ENTRY_IPMC_AGE:
		rv = bcm_ipmc_age(
			req->args.ipmc_age.unit,
			req->args.ipmc_age.flags,
			req->args.ipmc_age.age_cb,
			req->args.ipmc_age.user_data);
		break;
	case BCM_ASYNC_ENTRY_IPMC_BITMAP_DEL:
		rv = bcm_ipmc_bitmap_del(
			req->args.ipmc_bitmap_del.unit,
			req->args.ipmc_bitmap_del.ipmc_idx,
			req->args.ipmc_bitmap_del.port,
			req->args.ipmc_bitmap_del.pbmp);
		break;
	case BCM_ASYNC_ENTRY_IPMC_BITMAP_GET:
		rv = bcm_ipmc_bitmap_get(
			req->args.ipmc_bitmap_get.unit,
			req->args.ipmc_bitmap_get.ipmc_idx,
			req->args.ipmc_bitmap_get.port,
			req->args.ipmc_bitmap_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_IPMC_BITMAP_MAX_GET:
		rv = bcm_ipmc_bitmap_max_get(
			req->args.ipmc_bitmap_max_get.unit,
			req->args.ipmc_bitmap_max_get.max_index);
		break;
	case BCM_ASYNC_ENTRY_IPMC_BITMAP_SET:
		rv = bcm_ipmc_bitmap_set(
			req->args.ipmc_bitmap_set.unit,
			req->args.ipmc_bitmap_set.ipmc_idx,
			req->args.ipmc_bitmap_set.port,
			req->args.ipmc_bitmap_set.pbmp);
		break;
	case BCM_ASYNC_ENTRY_IPMC_COS_SET:
		rv = bcm_ipmc_cos_set(
			req->args.ipmc_cos_set.unit,
			req->args.ipmc_cos_set.s_ip_addr,
			req->args.ipmc_cos_set.mc_ip_addr,
			req->args.ipmc_cos_set.vid,
			req->args.ipmc_cos_set.cos);
		break;
	case BCM_ASYNC_ENTRY_IPMC_COUNTERS_GET:
		rv = bcm_ipmc_counters_get(
			req->args.ipmc_counters_get.unit,
			req->args.ipmc_counters_get.port,
			req->args.ipmc_counters_get.counters);
		break;
	case BCM_ASYNC_ENTRY_IPMC_DELETE:
		rv = bcm_ipmc_delete(
			req->args.ipmc_delete.unit,
			req->args.ipmc_delete.s_ip_addr,
			req->args.ipmc_delete.mc_ip_addr,
			req->args.ipmc_delete.vid,
			req->args.ipmc_delete.keep);
		break;
	case BCM_ASYNC_ENTRY_IPMC_DELETE_ALL:
		rv = bcm_ipmc_delete_all(
			req->args.ipmc_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_IPMC_DELETE_L2_PORTS:
		rv = bcm_ipmc_delete_l2_ports(
			req->args.ipmc_delete_l2_ports.unit,
			req->args.ipmc_delete_l2_ports.s_ip_addr,
			req->args.ipmc_delete_l2_ports.mc_ip_addr,
			req->args.ipmc_delete_l2_ports.vid,
			req->args.ipmc_delete_l2_ports.port);
		break;
	case BCM_ASYNC_ENTRY_IPMC_DELETE_L3_PORT:
		rv = bcm_ipmc_delete_l3_port(
			req->args.ipmc_delete_l3_port.unit,
			req->args.ipmc_delete_l3_port.s_ip_addr,
			req->args.ipmc_delete_l3_port.mc_ip_addr,
			req->args.ipmc_delete_l3_port.vid,
			req->args.ipmc_delete_l3_port.port);
		break;
	case BCM_ASYNC_ENTRY_IPMC_DETACH:
		rv = bcm_ipmc_detach(
			req->args.ipmc_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_IPMC_EGRESS_INTF_ADD:
		rv = bcm_ipmc_egress_intf_add(
			req->args.ipmc_egress_intf_add.unit,
			req->args.ipmc_egress_intf_add.mc_index,
			req->args.ipmc_egress_intf_add.port,
			req->args.ipmc_egress_intf_add.l3_intf);
		break;
	case BCM_ASYNC_ENTRY_IPMC_EGRESS_INTF_DELETE:
		rv = bcm_ipmc_egress_intf_delete(
			req->args.ipmc_egress_intf_delete.unit,
			req->args.ipmc_egress_intf_delete.mc_index,
			req->args.ipmc_egress_intf_delete.port,
			req->args.ipmc_egress_intf_delete.l3_intf);
		break;
	case BCM_ASYNC_ENTRY_IPMC_EGRESS_INTF_DELETE_ALL:
		rv = bcm_ipmc_egress_intf_delete_all(
			req->args.ipmc_egress_intf_delete_all.unit,
			req->args.ipmc_egress_intf_delete_all.mc_index,
			req->args.ipmc_egress_intf_delete_all.port);
		break;
	case BCM_ASYNC_ENTRY_IPMC_EGRESS_INTF_GET:
		rv = bcm_ipmc_egress_intf_get(
			req->args.ipmc_egress_intf_get.unit,
			req->args.ipmc_egress_intf_get.mc_index,
			req->args.ipmc_egress_intf_get.port,
			req->args.ipmc_egress_intf_get.if_max,
			req->args.ipmc_egress_intf_get.if_array,
			req->args.ipmc_egress_intf_get.if_count);
		break;
	case BCM_ASYNC_ENTRY_IPMC_EGRESS_INTF_SET:
		rv = bcm_ipmc_egress_intf_set(
			req->args.ipmc_egress_intf_set.unit,
			req->args.ipmc_egress_intf_set.mc_index,
			req->args.ipmc_egress_intf_set.port,
			req->args.ipmc_egress_intf_set.if_count,
			req->args.ipmc_egress_intf_set.if_array);
		break;
	case BCM_ASYNC_ENTRY_IPMC_EGRESS_PORT_GET:
		rv = bcm_ipmc_egress_port_get(
			req->args.ipmc_egress_port_get.unit,
			req->args.ipmc_egress_port_get.port,
			req->args.ipmc_egress_port_get.mac,
			req->args.ipmc_egress_port_get.untag,
			req->args.ipmc_egress_port_get.vid,
			req->args.ipmc_egress_port_get.ttl_threshold);
		break;
	case BCM_ASYNC_ENTRY_IPMC_EGRESS_PORT_INIT:
		rv = bcm_ipmc_egress_port_init(
			req->args.ipmc_egress_port_init.unit);
		break;
	case BCM_ASYNC_ENTRY_IPMC_EGRESS_PORT_SET:
		rv = bcm_ipmc_egress_port_set(
			req->args.ipmc_egress_port_set.unit,
			req->args.ipmc_egress_port_set.port,
			req->args.ipmc_egress_port_set.mac,
			req->args.ipmc_egress_port_set.untag,
			req->args.ipmc_egress_port_set.vid,
			req->args.ipmc_egress_port_set.ttl_threshold);
		break;
	case BCM_ASYNC_ENTRY_IPMC_ENABLE:
		rv = bcm_ipmc_enable(
			req->args.ipmc_enable.unit,
			req->args.ipmc_enable.enable);
		break;
	case BCM_ASYNC_ENTRY_IPMC_ENTRY_ENABLE_SET:
		rv = bcm_ipmc_entry_enable_set(
			req->args.ipmc_entry_enable_set.unit,
			req->args.ipmc_entry_enable_set.s_ip_addr,
			req->args.ipmc_entry_enable_set.mc_ip_addr,
			req->args.ipmc_entry_enable_set.vid,
			req->args.ipmc_entry_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_IPMC_FIND:
		rv = bcm_ipmc_find(
			req->args.ipmc_find.unit,
			req->args.ipmc_find.data);
		break;
	case BCM_ASYNC_ENTRY_IPMC_GET:
		rv = bcm_ipmc_get(
			req->args.ipmc_get.unit,
			req->args.ipmc_get.s_ip_addr,
			req->args.ipmc_get.mc_ip_addr,
			req->args.ipmc_get.vid,
			req->args.ipmc_get.data);
		break;
	case BCM_ASYNC_ENTRY_IPMC_GET_BY_INDEX:
		rv = bcm_ipmc_get_by_index(
			req->args.ipmc_get_by_index.unit,
			req->args.ipmc_get_by_index.index,
			req->args.ipmc_get_by_index.data);
		break;
	case BCM_ASYNC_ENTRY_IPMC_INIT:
		rv = bcm_ipmc_init(
			req->args.ipmc_init.unit);
		break;
	case BCM_ASYNC_ENTRY_IPMC_PORT_MODID_SET:
		rv = bcm_ipmc_port_modid_set(
			req->args.ipmc_port_modid_set.unit,
			req->args.ipmc_port_modid_set.s_ip_addr,
			req->args.ipmc_port_modid_set.mc_ip_addr,
			req->args.ipmc_port_modid_set.vid,
			req->args.ipmc_port_modid_set.mod_id);
		break;
	case BCM_ASYNC_ENTRY_IPMC_PORT_TGID_SET:
		rv = bcm_ipmc_port_tgid_set(
			req->args.ipmc_port_tgid_set.unit,
			req->args.ipmc_port_tgid_set.s_ip_addr,
			req->args.ipmc_port_tgid_set.mc_ip_addr,
			req->args.ipmc_port_tgid_set.vid,
			req->args.ipmc_port_tgid_set.ts,
			req->args.ipmc_port_tgid_set.port_tgid);
		break;
	case BCM_ASYNC_ENTRY_IPMC_REMOVE:
		rv = bcm_ipmc_remove(
			req->args.ipmc_remove.unit,
			req->args.ipmc_remove.data);
		break;
	case BCM_ASYNC_ENTRY_IPMC_REMOVE_ALL:
		rv = bcm_ipmc_remove_all(
			req->args.ipmc_remove_all.unit);
		break;
	case BCM_ASYNC_ENTRY_IPMC_REPL_ADD:
		rv = bcm_ipmc_repl_add(
			req->args.ipmc_repl_add.unit,
			req->args.ipmc_repl_add.index,
			req->args.ipmc_repl_add.pbmp,
			req->args.ipmc_repl_add.vlan);
		break;
	case BCM_ASYNC_ENTRY_IPMC_REPL_DELETE:
		rv = bcm_ipmc_repl_delete(
			req->args.ipmc_repl_delete.unit,
			req->args.ipmc_repl_delete.index,
			req->args.ipmc_repl_delete.pbmp,
			req->args.ipmc_repl_delete.vlan);
		break;
	case BCM_ASYNC_ENTRY_IPMC_REPL_DELETE_ALL:
		rv = bcm_ipmc_repl_delete_all(
			req->args.ipmc_repl_delete_all.unit,
			req->args.ipmc_repl_delete_all.index,
			req->args.ipmc_repl_delete_all.pbmp);
		break;
	case BCM_ASYNC_ENTRY_IPMC_REPL_GET:
		rv = bcm_ipmc_repl_get(
			req->args.ipmc_repl_get.unit,
			req->args.ipmc_repl_get.index,
			req->args.ipmc_repl_get.port,
			req->args.ipmc_repl_get.vlan_vec);
		break;
	case BCM_ASYNC_ENTRY_IPMC_REPL_SET:
		rv = bcm_ipmc_repl_set(
			req->args.ipmc_repl_set.unit,
			req->args.ipmc_repl_set.mc_index,
			req->args.ipmc_repl_set.port,
			req->args.ipmc_repl_set.vlan_vec);
		break;
	case BCM_ASYNC_ENTRY_IPMC_SOURCE_IP_SEARCH:
		rv = bcm_ipmc_source_ip_search(
			req->args.ipmc_source_ip_search.unit,
			req->args.ipmc_source_ip_search.enable);
		break;
	case BCM_ASYNC_ENTRY_IPMC_SOURCE_PORT_CHECK:
		rv = bcm_ipmc_source_port_check(
			req->args.ipmc_source_port_check.unit,
			req->args.ipmc_source_port_check.enable);
		break;
	case BCM_ASYNC_ENTRY_IPMC_TRAVERSE:
		rv = bcm_ipmc_traverse(
			req->args.ipmc_traverse.unit,
			req->args.ipmc_traverse.flags,
			req->args.ipmc_traverse.cb,
			req->args.ipmc_traverse.user_data);
		break;
#endif	/* INCLUDE_L3 */
	case BCM_ASYNC_ENTRY_L2_ADDR_ADD:
		rv = bcm_l2_addr_add(
			req->args.l2_addr_add.unit,
			req->args.l2_addr_add.l2addr);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_DELETE:
		rv = bcm_l2_addr_delete(
			req->args.l2_addr_delete.unit,
			req->args.l2_addr_delete.mac,
			req->args.l2_addr_delete.vid);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_MAC:
		rv = bcm_l2_addr_delete_by_mac(
			req->args.l2_addr_delete_by_mac.unit,
			req->args.l2_addr_delete_by_mac.mac,
			req->args.l2_addr_delete_by_mac.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_MAC_PORT:
		rv = bcm_l2_addr_delete_by_mac_port(
			req->args.l2_addr_delete_by_mac_port.unit,
			req->args.l2_addr_delete_by_mac_port.mac,
			req->args.l2_addr_delete_by_mac_port.mod,
			req->args.l2_addr_delete_by_mac_port.port,
			req->args.l2_addr_delete_by_mac_port.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_PORT:
		rv = bcm_l2_addr_delete_by_port(
			req->args.l2_addr_delete_by_port.unit,
			req->args.l2_addr_delete_by_port.mod,
			req->args.l2_addr_delete_by_port.port,
			req->args.l2_addr_delete_by_port.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_TRUNK:
		rv = bcm_l2_addr_delete_by_trunk(
			req->args.l2_addr_delete_by_trunk.unit,
			req->args.l2_addr_delete_by_trunk.tid,
			req->args.l2_addr_delete_by_trunk.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN:
		rv = bcm_l2_addr_delete_by_vlan(
			req->args.l2_addr_delete_by_vlan.unit,
			req->args.l2_addr_delete_by_vlan.vid,
			req->args.l2_addr_delete_by_vlan.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN_PORT:
		rv = bcm_l2_addr_delete_by_vlan_port(
			req->args.l2_addr_delete_by_vlan_port.unit,
			req->args.l2_addr_delete_by_vlan_port.vid,
			req->args.l2_addr_delete_by_vlan_port.mod,
			req->args.l2_addr_delete_by_vlan_port.port,
			req->args.l2_addr_delete_by_vlan_port.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_DELETE_BY_VLAN_TRUNK:
		rv = bcm_l2_addr_delete_by_vlan_trunk(
			req->args.l2_addr_delete_by_vlan_trunk.unit,
			req->args.l2_addr_delete_by_vlan_trunk.vid,
			req->args.l2_addr_delete_by_vlan_trunk.tid,
			req->args.l2_addr_delete_by_vlan_trunk.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_FREEZE:
		rv = bcm_l2_addr_freeze(
			req->args.l2_addr_freeze.unit);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_GET:
		rv = bcm_l2_addr_get(
			req->args.l2_addr_get.unit,
			req->args.l2_addr_get.mac_addr,
			req->args.l2_addr_get.vid,
			req->args.l2_addr_get.l2addr);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_REGISTER:
		rv = bcm_l2_addr_register(
			req->args.l2_addr_register.unit,
			req->args.l2_addr_register.callback,
			req->args.l2_addr_register.userdata);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_THAW:
		rv = bcm_l2_addr_thaw(
			req->args.l2_addr_thaw.unit);
		break;
	case BCM_ASYNC_ENTRY_L2_ADDR_UNREGISTER:
		rv = bcm_l2_addr_unregister(
			req->args.l2_addr_unregister.unit,
			req->args.l2_addr_unregister.callback,
			req->args.l2_addr_unregister.userdata);
		break;
	case BCM_ASYNC_ENTRY_L2_AGE_TIMER_GET:
		rv = bcm_l2_age_timer_get(
			req->args.l2_age_timer_get.unit,
			req->args.l2_age_timer_get.age_seconds);
		break;
	case BCM_ASYNC_ENTRY_L2_AGE_TIMER_SET:
		rv = bcm_l2_age_timer_set(
			req->args.l2_age_timer_set.unit,
			req->args.l2_age_timer_set.age_seconds);
		break;
	case BCM_ASYNC_ENTRY_L2_BPDU_COUNT:
		rv = bcm_l2_bpdu_count(
			req->args.l2_bpdu_count.unit);
		break;
	case BCM_ASYNC_ENTRY_L2_BPDU_GET:
		rv = bcm_l2_bpdu_get(
			req->args.l2_bpdu_get.unit,
			req->args.l2_bpdu_get.index,
			req->args.l2_bpdu_get.addr);
		break;
	case BCM_ASYNC_ENTRY_L2_BPDU_SET:
		rv = bcm_l2_bpdu_set(
			req->args.l2_bpdu_set.unit,
			req->args.l2_bpdu_set.index,
			req->args.l2_bpdu_set.addr);
		break;
	case BCM_ASYNC_ENTRY_L2_CACHE_DELETE:
		rv = bcm_l2_cache_delete(
			req->args.l2_cache_delete.unit,
			req->args.l2_cache_delete.index);
		break;
	case BCM_ASYNC_ENTRY_L2_CACHE_DELETE_ALL:
		rv = bcm_l2_cache_delete_all(
			req->args.l2_cache_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_L2_CACHE_GET:
		rv = bcm_l2_cache_get(
			req->args.l2_cache_get.unit,
			req->args.l2_cache_get.index,
			req->args.l2_cache_get.addr);
		break;
	case BCM_ASYNC_ENTRY_L2_CACHE_INIT:
		rv = bcm_l2_cache_init(
			req->args.l2_cache_init.unit);
		break;
	case BCM_ASYNC_ENTRY_L2_CACHE_SET:
		rv = bcm_l2_cache_set(
			req->args.l2_cache_set.unit,
			req->args.l2_cache_set.index,
			req->args.l2_cache_set.addr,
			req->args.l2_cache_set.index_used);
		break;
	case BCM_ASYNC_ENTRY_L2_CACHE_SIZE_GET:
		rv = bcm_l2_cache_size_get(
			req->args.l2_cache_size_get.unit,
			req->args.l2_cache_size_get.size);
		break;
	case BCM_ASYNC_ENTRY_L2_CLEAR:
		rv = bcm_l2_clear(
			req->args.l2_clear.unit);
		break;
	case BCM_ASYNC_ENTRY_L2_CONFLICT_GET:
		rv = bcm_l2_conflict_get(
			req->args.l2_conflict_get.unit,
			req->args.l2_conflict_get.addr,
			req->args.l2_conflict_get.cf_array,
			req->args.l2_conflict_get.cf_max,
			req->args.l2_conflict_get.cf_count);
		break;
	case BCM_ASYNC_ENTRY_L2_DETACH:
		rv = bcm_l2_detach(
			req->args.l2_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_L2_EGRESS_CREATE:
		rv = bcm_l2_egress_create(
			req->args.l2_egress_create.unit,
			req->args.l2_egress_create.egr);
		break;
	case BCM_ASYNC_ENTRY_L2_EGRESS_DESTROY:
		rv = bcm_l2_egress_destroy(
			req->args.l2_egress_destroy.unit,
			req->args.l2_egress_destroy.encap_id);
		break;
	case BCM_ASYNC_ENTRY_L2_EGRESS_FIND:
		rv = bcm_l2_egress_find(
			req->args.l2_egress_find.unit,
			req->args.l2_egress_find.egr,
			req->args.l2_egress_find.encap_id);
		break;
	case BCM_ASYNC_ENTRY_L2_EGRESS_GET:
		rv = bcm_l2_egress_get(
			req->args.l2_egress_get.unit,
			req->args.l2_egress_get.encap_id,
			req->args.l2_egress_get.egr);
		break;
	case BCM_ASYNC_ENTRY_L2_EGRESS_TRAVERSE:
		rv = bcm_l2_egress_traverse(
			req->args.l2_egress_traverse.unit,
			req->args.l2_egress_traverse.trav_fn,
			req->args.l2_egress_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_L2_INIT:
		rv = bcm_l2_init(
			req->args.l2_init.unit);
		break;
	case BCM_ASYNC_ENTRY_L2_KEY_DUMP:
		rv = bcm_l2_key_dump(
			req->args.l2_key_dump.unit,
			req->args.l2_key_dump.pfx,
			req->args.l2_key_dump.entry,
			req->args.l2_key_dump.sfx);
		break;
	case BCM_ASYNC_ENTRY_L2_LEARN_CLASS_GET:
		rv = bcm_l2_learn_class_get(
			req->args.l2_learn_class_get.unit,
			req->args.l2_learn_class_get.lclass,
			req->args.l2_learn_class_get.lclass_prio,
			req->args.l2_learn_class_get.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_LEARN_CLASS_SET:
		rv = bcm_l2_learn_class_set(
			req->args.l2_learn_class_set.unit,
			req->args.l2_learn_class_set.lclass,
			req->args.l2_learn_class_set.lclass_prio,
			req->args.l2_learn_class_set.flags);
		break;
	case BCM_ASYNC_ENTRY_L2_LEARN_LIMIT_GET:
		rv = bcm_l2_learn_limit_get(
			req->args.l2_learn_limit_get.unit,
			req->args.l2_learn_limit_get.limit);
		break;
	case BCM_ASYNC_ENTRY_L2_LEARN_LIMIT_SET:
		rv = bcm_l2_learn_limit_set(
			req->args.l2_learn_limit_set.unit,
			req->args.l2_learn_limit_set.limit);
		break;
	case BCM_ASYNC_ENTRY_L2_LEARN_PORT_CLASS_GET:
		rv = bcm_l2_learn_port_class_get(
			req->args.l2_learn_port_class_get.unit,
			req->args.l2_learn_port_class_get.port,
			req->args.l2_learn_port_class_get.lclass);
		break;
	case BCM_ASYNC_ENTRY_L2_LEARN_PORT_CLASS_SET:
		rv = bcm_l2_learn_port_class_set(
			req->args.l2_learn_port_class_set.unit,
			req->args.l2_learn_port_class_set.port,
			req->args.l2_learn_port_class_set.lclass);
		break;
	case BCM_ASYNC_ENTRY_L2_PORT_NATIVE:
		rv = bcm_l2_port_native(
			req->args.l2_port_native.unit,
			req->args.l2_port_native.modid,
			req->args.l2_port_native.port);
		break;
	case BCM_ASYNC_ENTRY_L2_REPLACE:
		rv = bcm_l2_replace(
			req->args.l2_replace.unit,
			req->args.l2_replace.flags,
			req->args.l2_replace.match_addr,
			req->args.l2_replace.new_module,
			req->args.l2_replace.new_port,
			req->args.l2_replace.new_trunk);
		break;
	case BCM_ASYNC_ENTRY_L2_STAT_ENABLE_SET:
		rv = bcm_l2_stat_enable_set(
			req->args.l2_stat_enable_set.unit,
			req->args.l2_stat_enable_set.l2_addr,
			req->args.l2_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_L2_STAT_GET:
		rv = bcm_l2_stat_get(
			req->args.l2_stat_get.unit,
			req->args.l2_stat_get.l2_addr,
			req->args.l2_stat_get.stat,
			req->args.l2_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_L2_STAT_GET32:
		rv = bcm_l2_stat_get32(
			req->args.l2_stat_get32.unit,
			req->args.l2_stat_get32.l2_addr,
			req->args.l2_stat_get32.stat,
			req->args.l2_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_L2_STAT_SET:
		rv = bcm_l2_stat_set(
			req->args.l2_stat_set.unit,
			req->args.l2_stat_set.l2_addr,
			req->args.l2_stat_set.stat,
			req->args.l2_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_L2_STAT_SET32:
		rv = bcm_l2_stat_set32(
			req->args.l2_stat_set32.unit,
			req->args.l2_stat_set32.l2_addr,
			req->args.l2_stat_set32.stat,
			req->args.l2_stat_set32.val);
		break;
	case BCM_ASYNC_ENTRY_L2_TRAVERSE:
		rv = bcm_l2_traverse(
			req->args.l2_traverse.unit,
			req->args.l2_traverse.trav_fn,
			req->args.l2_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_L2_TUNNEL_ADD:
		rv = bcm_l2_tunnel_add(
			req->args.l2_tunnel_add.unit,
			req->args.l2_tunnel_add.mac,
			req->args.l2_tunnel_add.vlan);
		break;
	case BCM_ASYNC_ENTRY_L2_TUNNEL_DELETE:
		rv = bcm_l2_tunnel_delete(
			req->args.l2_tunnel_delete.unit,
			req->args.l2_tunnel_delete.mac,
			req->args.l2_tunnel_delete.vlan);
		break;
	case BCM_ASYNC_ENTRY_L2_TUNNEL_DELETE_ALL:
		rv = bcm_l2_tunnel_delete_all(
			req->args.l2_tunnel_delete_all.unit);
		break;
#ifdef	INCLUDE_L3
	case BCM_ASYNC_ENTRY_L3_AGE:
		rv = bcm_l3_age(
			req->args.l3_age.unit,
			req->args.l3_age.flags,
			req->args.l3_age.age_out);
		break;
	case BCM_ASYNC_ENTRY_L3_CLEANUP:
		rv = bcm_l3_cleanup(
			req->args.l3_cleanup.unit);
		break;
	case BCM_ASYNC_ENTRY_L3_CONFLICT_GET:
		rv = bcm_l3_conflict_get(
			req->args.l3_conflict_get.unit,
			req->args.l3_conflict_get.ipkey,
			req->args.l3_conflict_get.cf_array,
			req->args.l3_conflict_get.cf_max,
			req->args.l3_conflict_get.cf_count);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_ADD:
		rv = bcm_l3_defip_add(
			req->args.l3_defip_add.unit,
			req->args.l3_defip_add.info);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_AGE:
		rv = bcm_l3_defip_age(
			req->args.l3_defip_age.unit,
			req->args.l3_defip_age.age_out);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_DELETE:
		rv = bcm_l3_defip_delete(
			req->args.l3_defip_delete.unit,
			req->args.l3_defip_delete.info);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_DELETE_ALL:
		rv = bcm_l3_defip_delete_all(
			req->args.l3_defip_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_DELETE_BY_INTERFACE:
		rv = bcm_l3_defip_delete_by_interface(
			req->args.l3_defip_delete_by_interface.unit,
			req->args.l3_defip_delete_by_interface.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_FIND_INDEX:
		rv = bcm_l3_defip_find_index(
			req->args.l3_defip_find_index.unit,
			req->args.l3_defip_find_index.index,
			req->args.l3_defip_find_index.info);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_GET:
		rv = bcm_l3_defip_get(
			req->args.l3_defip_get.unit,
			req->args.l3_defip_get.info);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_MAX_ECMP_GET:
		rv = bcm_l3_defip_max_ecmp_get(
			req->args.l3_defip_max_ecmp_get.unit,
			req->args.l3_defip_max_ecmp_get.max);
		break;
	case BCM_ASYNC_ENTRY_L3_DEFIP_MAX_ECMP_SET:
		rv = bcm_l3_defip_max_ecmp_set(
			req->args.l3_defip_max_ecmp_set.unit,
			req->args.l3_defip_max_ecmp_set.max);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_CREATE:
		rv = bcm_l3_egress_create(
			req->args.l3_egress_create.unit,
			req->args.l3_egress_create.flags,
			req->args.l3_egress_create.egr,
			req->args.l3_egress_create.if_id);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_DESTROY:
		rv = bcm_l3_egress_destroy(
			req->args.l3_egress_destroy.unit,
			req->args.l3_egress_destroy.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_FIND:
		rv = bcm_l3_egress_find(
			req->args.l3_egress_find.unit,
			req->args.l3_egress_find.egr,
			req->args.l3_egress_find.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_GET:
		rv = bcm_l3_egress_get(
			req->args.l3_egress_get.unit,
			req->args.l3_egress_get.intf,
			req->args.l3_egress_get.egr);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_ADD:
		rv = bcm_l3_egress_multipath_add(
			req->args.l3_egress_multipath_add.unit,
			req->args.l3_egress_multipath_add.mpintf,
			req->args.l3_egress_multipath_add.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_CREATE:
		rv = bcm_l3_egress_multipath_create(
			req->args.l3_egress_multipath_create.unit,
			req->args.l3_egress_multipath_create.flags,
			req->args.l3_egress_multipath_create.intf_count,
			req->args.l3_egress_multipath_create.intf_array,
			req->args.l3_egress_multipath_create.mpintf);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_DELETE:
		rv = bcm_l3_egress_multipath_delete(
			req->args.l3_egress_multipath_delete.unit,
			req->args.l3_egress_multipath_delete.mpintf,
			req->args.l3_egress_multipath_delete.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_DESTROY:
		rv = bcm_l3_egress_multipath_destroy(
			req->args.l3_egress_multipath_destroy.unit,
			req->args.l3_egress_multipath_destroy.mpintf);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_FIND:
		rv = bcm_l3_egress_multipath_find(
			req->args.l3_egress_multipath_find.unit,
			req->args.l3_egress_multipath_find.intf_count,
			req->args.l3_egress_multipath_find.intf_array,
			req->args.l3_egress_multipath_find.mpintf);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_GET:
		rv = bcm_l3_egress_multipath_get(
			req->args.l3_egress_multipath_get.unit,
			req->args.l3_egress_multipath_get.mpintf,
			req->args.l3_egress_multipath_get.intf_size,
			req->args.l3_egress_multipath_get.intf_array,
			req->args.l3_egress_multipath_get.intf_count);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_MULTIPATH_TRAVERSE:
		rv = bcm_l3_egress_multipath_traverse(
			req->args.l3_egress_multipath_traverse.unit,
			req->args.l3_egress_multipath_traverse.trav_fn,
			req->args.l3_egress_multipath_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_STAT_ENABLE_SET:
		rv = bcm_l3_egress_stat_enable_set(
			req->args.l3_egress_stat_enable_set.unit,
			req->args.l3_egress_stat_enable_set.egr,
			req->args.l3_egress_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_STAT_GET:
		rv = bcm_l3_egress_stat_get(
			req->args.l3_egress_stat_get.unit,
			req->args.l3_egress_stat_get.egr,
			req->args.l3_egress_stat_get.stat,
			req->args.l3_egress_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_STAT_GET32:
		rv = bcm_l3_egress_stat_get32(
			req->args.l3_egress_stat_get32.unit,
			req->args.l3_egress_stat_get32.egr,
			req->args.l3_egress_stat_get32.stat,
			req->args.l3_egress_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_STAT_SET:
		rv = bcm_l3_egress_stat_set(
			req->args.l3_egress_stat_set.unit,
			req->args.l3_egress_stat_set.egr,
			req->args.l3_egress_stat_set.stat,
			req->args.l3_egress_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_STAT_SET32:
		rv = bcm_l3_egress_stat_set32(
			req->args.l3_egress_stat_set32.unit,
			req->args.l3_egress_stat_set32.egr,
			req->args.l3_egress_stat_set32.stat,
			req->args.l3_egress_stat_set32.val);
		break;
	case BCM_ASYNC_ENTRY_L3_EGRESS_TRAVERSE:
		rv = bcm_l3_egress_traverse(
			req->args.l3_egress_traverse.unit,
			req->args.l3_egress_traverse.trav_fn,
			req->args.l3_egress_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_L3_ENABLE_SET:
		rv = bcm_l3_enable_set(
			req->args.l3_enable_set.unit,
			req->args.l3_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_ADD:
		rv = bcm_l3_host_add(
			req->args.l3_host_add.unit,
			req->args.l3_host_add.info);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_AGE:
		rv = bcm_l3_host_age(
			req->args.l3_host_age.unit,
			req->args.l3_host_age.flags,
			req->args.l3_host_age.age_cb,
			req->args.l3_host_age.user_data);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_CONFLICT_GET:
		rv = bcm_l3_host_conflict_get(
			req->args.l3_host_conflict_get.unit,
			req->args.l3_host_conflict_get.ipkey,
			req->args.l3_host_conflict_get.cf_array,
			req->args.l3_host_conflict_get.cf_max,
			req->args.l3_host_conflict_get.cf_count);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_DELETE:
		rv = bcm_l3_host_delete(
			req->args.l3_host_delete.unit,
			req->args.l3_host_delete.ip_addr);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_DELETE_ALL:
		rv = bcm_l3_host_delete_all(
			req->args.l3_host_delete_all.unit,
			req->args.l3_host_delete_all.info);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_DELETE_BY_INTERFACE:
		rv = bcm_l3_host_delete_by_interface(
			req->args.l3_host_delete_by_interface.unit,
			req->args.l3_host_delete_by_interface.info);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_DELETE_BY_NETWORK:
		rv = bcm_l3_host_delete_by_network(
			req->args.l3_host_delete_by_network.unit,
			req->args.l3_host_delete_by_network.ip_addr);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_FIND:
		rv = bcm_l3_host_find(
			req->args.l3_host_find.unit,
			req->args.l3_host_find.info);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_INVALIDATE_ENTRY:
		rv = bcm_l3_host_invalidate_entry(
			req->args.l3_host_invalidate_entry.unit,
			req->args.l3_host_invalidate_entry.info);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_STAT_ENABLE_SET:
		rv = bcm_l3_host_stat_enable_set(
			req->args.l3_host_stat_enable_set.unit,
			req->args.l3_host_stat_enable_set.host,
			req->args.l3_host_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_STAT_GET:
		rv = bcm_l3_host_stat_get(
			req->args.l3_host_stat_get.unit,
			req->args.l3_host_stat_get.host,
			req->args.l3_host_stat_get.stat,
			req->args.l3_host_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_STAT_GET32:
		rv = bcm_l3_host_stat_get32(
			req->args.l3_host_stat_get32.unit,
			req->args.l3_host_stat_get32.host,
			req->args.l3_host_stat_get32.stat,
			req->args.l3_host_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_STAT_SET:
		rv = bcm_l3_host_stat_set(
			req->args.l3_host_stat_set.unit,
			req->args.l3_host_stat_set.host,
			req->args.l3_host_stat_set.stat,
			req->args.l3_host_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_STAT_SET32:
		rv = bcm_l3_host_stat_set32(
			req->args.l3_host_stat_set32.unit,
			req->args.l3_host_stat_set32.host,
			req->args.l3_host_stat_set32.stat,
			req->args.l3_host_stat_set32.val);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_TRAVERSE:
		rv = bcm_l3_host_traverse(
			req->args.l3_host_traverse.unit,
			req->args.l3_host_traverse.flags,
			req->args.l3_host_traverse.start,
			req->args.l3_host_traverse.end,
			req->args.l3_host_traverse.cb,
			req->args.l3_host_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_L3_HOST_VALIDATE_ENTRY:
		rv = bcm_l3_host_validate_entry(
			req->args.l3_host_validate_entry.unit,
			req->args.l3_host_validate_entry.info);
		break;
	case BCM_ASYNC_ENTRY_L3_INFO:
		rv = bcm_l3_info(
			req->args.l3_info.unit,
			req->args.l3_info.l3info);
		break;
	case BCM_ASYNC_ENTRY_L3_INIT:
		rv = bcm_l3_init(
			req->args.l3_init.unit);
		break;
	case BCM_ASYNC_ENTRY_L3_INTERFACE_CREATE:
		rv = bcm_l3_interface_create(
			req->args.l3_interface_create.unit,
			req->args.l3_interface_create.mac_addr,
			req->args.l3_interface_create.vid,
			req->args.l3_interface_create.add_to_arl);
		break;
	case BCM_ASYNC_ENTRY_L3_INTERFACE_DESTROY:
		rv = bcm_l3_interface_destroy(
			req->args.l3_interface_destroy.unit,
			req->args.l3_interface_destroy.intf_id);
		break;
	case BCM_ASYNC_ENTRY_L3_INTERFACE_FIND:
		rv = bcm_l3_interface_find(
			req->args.l3_interface_find.unit,
			req->args.l3_interface_find.intf_id,
			req->args.l3_interface_find.vid,
			req->args.l3_interface_find.mac_addr);
		break;
	case BCM_ASYNC_ENTRY_L3_INTERFACE_FIND_BY_VLAN:
		rv = bcm_l3_interface_find_by_vlan(
			req->args.l3_interface_find_by_vlan.unit,
			req->args.l3_interface_find_by_vlan.vid,
			req->args.l3_interface_find_by_vlan.intf_id);
		break;
	case BCM_ASYNC_ENTRY_L3_INTERFACE_ID_CREATE:
		rv = bcm_l3_interface_id_create(
			req->args.l3_interface_id_create.unit,
			req->args.l3_interface_id_create.mac_addr,
			req->args.l3_interface_id_create.vid,
			req->args.l3_interface_id_create.intf_idx,
			req->args.l3_interface_id_create.add_to_arl);
		break;
	case BCM_ASYNC_ENTRY_L3_INTERFACE_ID_UPDATE:
		rv = bcm_l3_interface_id_update(
			req->args.l3_interface_id_update.unit,
			req->args.l3_interface_id_update.mac_addr,
			req->args.l3_interface_id_update.vid,
			req->args.l3_interface_id_update.intf_idx,
			req->args.l3_interface_id_update.add_to_arl);
		break;
	case BCM_ASYNC_ENTRY_L3_INTERFACE_LOOKUP:
		rv = bcm_l3_interface_lookup(
			req->args.l3_interface_lookup.unit,
			req->args.l3_interface_lookup.mac_addr,
			req->args.l3_interface_lookup.vid,
			req->args.l3_interface_lookup.intf_id);
		break;
	case BCM_ASYNC_ENTRY_L3_INTF_CREATE:
		rv = bcm_l3_intf_create(
			req->args.l3_intf_create.unit,
			req->args.l3_intf_create.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_INTF_DELETE:
		rv = bcm_l3_intf_delete(
			req->args.l3_intf_delete.unit,
			req->args.l3_intf_delete.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_INTF_DELETE_ALL:
		rv = bcm_l3_intf_delete_all(
			req->args.l3_intf_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_L3_INTF_FIND:
		rv = bcm_l3_intf_find(
			req->args.l3_intf_find.unit,
			req->args.l3_intf_find.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_INTF_FIND_VLAN:
		rv = bcm_l3_intf_find_vlan(
			req->args.l3_intf_find_vlan.unit,
			req->args.l3_intf_find_vlan.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_INTF_GET:
		rv = bcm_l3_intf_get(
			req->args.l3_intf_get.unit,
			req->args.l3_intf_get.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_INVALIDATE_ENTRY:
		rv = bcm_l3_invalidate_entry(
			req->args.l3_invalidate_entry.unit,
			req->args.l3_invalidate_entry.l3_addr);
		break;
	case BCM_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_ADD:
		rv = bcm_l3_ip6_prefix_map_add(
			req->args.l3_ip6_prefix_map_add.unit,
			req->args.l3_ip6_prefix_map_add.ip6_addr);
		break;
	case BCM_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_DELETE:
		rv = bcm_l3_ip6_prefix_map_delete(
			req->args.l3_ip6_prefix_map_delete.unit,
			req->args.l3_ip6_prefix_map_delete.ip6_addr);
		break;
	case BCM_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_DELETE_ALL:
		rv = bcm_l3_ip6_prefix_map_delete_all(
			req->args.l3_ip6_prefix_map_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_L3_IP6_PREFIX_MAP_GET:
		rv = bcm_l3_ip6_prefix_map_get(
			req->args.l3_ip6_prefix_map_get.unit,
			req->args.l3_ip6_prefix_map_get.map_size,
			req->args.l3_ip6_prefix_map_get.ip6_array,
			req->args.l3_ip6_prefix_map_get.ip6_count);
		break;
	case BCM_ASYNC_ENTRY_L3_IP_ADD:
		rv = bcm_l3_ip_add(
			req->args.l3_ip_add.unit,
			req->args.l3_ip_add.info);
		break;
	case BCM_ASYNC_ENTRY_L3_IP_DELETE:
		rv = bcm_l3_ip_delete(
			req->args.l3_ip_delete.unit,
			req->args.l3_ip_delete.ip_addr);
		break;
	case BCM_ASYNC_ENTRY_L3_IP_DELETE_ALL:
		rv = bcm_l3_ip_delete_all(
			req->args.l3_ip_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_L3_IP_DELETE_BY_INTERFACE:
		rv = bcm_l3_ip_delete_by_interface(
			req->args.l3_ip_delete_by_interface.unit,
			req->args.l3_ip_delete_by_interface.intf);
		break;
	case BCM_ASYNC_ENTRY_L3_IP_DELETE_BY_PREFIX:
		rv = bcm_l3_ip_delete_by_prefix(
			req->args.l3_ip_delete_by_prefix.unit,
			req->args.l3_ip_delete_by_prefix.ip_addr,
			req->args.l3_ip_delete_by_prefix.mask);
		break;
	case BCM_ASYNC_ENTRY_L3_IP_FIND:
		rv = bcm_l3_ip_find(
			req->args.l3_ip_find.unit,
			req->args.l3_ip_find.info);
		break;
	case BCM_ASYNC_ENTRY_L3_IP_FIND_INDEX:
		rv = bcm_l3_ip_find_index(
			req->args.l3_ip_find_index.unit,
			req->args.l3_ip_find_index.index,
			req->args.l3_ip_find_index.info);
		break;
	case BCM_ASYNC_ENTRY_L3_IP_UPDATE_ENTRY_BY_KEY:
		rv = bcm_l3_ip_update_entry_by_key(
			req->args.l3_ip_update_entry_by_key.unit,
			req->args.l3_ip_update_entry_by_key.info);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_ADD:
		rv = bcm_l3_route_add(
			req->args.l3_route_add.unit,
			req->args.l3_route_add.info);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_AGE:
		rv = bcm_l3_route_age(
			req->args.l3_route_age.unit,
			req->args.l3_route_age.flags,
			req->args.l3_route_age.age_out,
			req->args.l3_route_age.user_data);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_DELETE:
		rv = bcm_l3_route_delete(
			req->args.l3_route_delete.unit,
			req->args.l3_route_delete.info);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_DELETE_ALL:
		rv = bcm_l3_route_delete_all(
			req->args.l3_route_delete_all.unit,
			req->args.l3_route_delete_all.info);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_DELETE_BY_INTERFACE:
		rv = bcm_l3_route_delete_by_interface(
			req->args.l3_route_delete_by_interface.unit,
			req->args.l3_route_delete_by_interface.info);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_GET:
		rv = bcm_l3_route_get(
			req->args.l3_route_get.unit,
			req->args.l3_route_get.info);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_MAX_ECMP_GET:
		rv = bcm_l3_route_max_ecmp_get(
			req->args.l3_route_max_ecmp_get.unit,
			req->args.l3_route_max_ecmp_get.max);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_MAX_ECMP_SET:
		rv = bcm_l3_route_max_ecmp_set(
			req->args.l3_route_max_ecmp_set.unit,
			req->args.l3_route_max_ecmp_set.max);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_MULTIPATH_GET:
		rv = bcm_l3_route_multipath_get(
			req->args.l3_route_multipath_get.unit,
			req->args.l3_route_multipath_get.the_route,
			req->args.l3_route_multipath_get.path_array,
			req->args.l3_route_multipath_get.max_path,
			req->args.l3_route_multipath_get.path_count);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_STAT_ENABLE_SET:
		rv = bcm_l3_route_stat_enable_set(
			req->args.l3_route_stat_enable_set.unit,
			req->args.l3_route_stat_enable_set.route,
			req->args.l3_route_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_STAT_GET:
		rv = bcm_l3_route_stat_get(
			req->args.l3_route_stat_get.unit,
			req->args.l3_route_stat_get.route,
			req->args.l3_route_stat_get.stat,
			req->args.l3_route_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_STAT_GET32:
		rv = bcm_l3_route_stat_get32(
			req->args.l3_route_stat_get32.unit,
			req->args.l3_route_stat_get32.route,
			req->args.l3_route_stat_get32.stat,
			req->args.l3_route_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_STAT_SET:
		rv = bcm_l3_route_stat_set(
			req->args.l3_route_stat_set.unit,
			req->args.l3_route_stat_set.route,
			req->args.l3_route_stat_set.stat,
			req->args.l3_route_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_STAT_SET32:
		rv = bcm_l3_route_stat_set32(
			req->args.l3_route_stat_set32.unit,
			req->args.l3_route_stat_set32.route,
			req->args.l3_route_stat_set32.stat,
			req->args.l3_route_stat_set32.val);
		break;
	case BCM_ASYNC_ENTRY_L3_ROUTE_TRAVERSE:
		rv = bcm_l3_route_traverse(
			req->args.l3_route_traverse.unit,
			req->args.l3_route_traverse.flags,
			req->args.l3_route_traverse.start,
			req->args.l3_route_traverse.end,
			req->args.l3_route_traverse.trav_fn,
			req->args.l3_route_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_L3_SOURCE_BIND_ADD:
		rv = bcm_l3_source_bind_add(
			req->args.l3_source_bind_add.unit,
			req->args.l3_source_bind_add.info);
		break;
	case BCM_ASYNC_ENTRY_L3_SOURCE_BIND_DELETE:
		rv = bcm_l3_source_bind_delete(
			req->args.l3_source_bind_delete.unit,
			req->args.l3_source_bind_delete.info);
		break;
	case BCM_ASYNC_ENTRY_L3_SOURCE_BIND_DELETE_ALL:
		rv = bcm_l3_source_bind_delete_all(
			req->args.l3_source_bind_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_L3_SOURCE_BIND_ENABLE_GET:
		rv = bcm_l3_source_bind_enable_get(
			req->args.l3_source_bind_enable_get.unit,
			req->args.l3_source_bind_enable_get.port,
			req->args.l3_source_bind_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_L3_SOURCE_BIND_ENABLE_SET:
		rv = bcm_l3_source_bind_enable_set(
			req->args.l3_source_bind_enable_set.unit,
			req->args.l3_source_bind_enable_set.port,
			req->args.l3_source_bind_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_L3_SOURCE_BIND_GET:
		rv = bcm_l3_source_bind_get(
			req->args.l3_source_bind_get.unit,
			req->args.l3_source_bind_get.info);
		break;
	case BCM_ASYNC_ENTRY_L3_SOURCE_BIND_TRAVERSE:
		rv = bcm_l3_source_bind_traverse(
			req->args.l3_source_bind_traverse.unit,
			req->args.l3_source_bind_traverse.cb,
			req->args.l3_source_bind_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_L3_STATUS:
		rv = bcm_l3_status(
			req->args.l3_status.unit,
			req->args.l3_status.free_l3intf,
			req->args.l3_status.free_l3,
			req->args.l3_status.free_defip,
			req->args.l3_status.free_lpm_blk);
		break;
	case BCM_ASYNC_ENTRY_L3_UNTAGGED_UPDATE:
		rv = bcm_l3_untagged_update(
			req->args.l3_untagged_update.unit);
		break;
	case BCM_ASYNC_ENTRY_L3_VALIDATE_ENTRY:
		rv = bcm_l3_validate_entry(
			req->args.l3_validate_entry.unit,
			req->args.l3_validate_entry.l3_addr);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_ENABLE_SET:
		rv = bcm_l3_vrf_stat_enable_set(
			req->args.l3_vrf_stat_enable_set.unit,
			req->args.l3_vrf_stat_enable_set.vrf,
			req->args.l3_vrf_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_GET:
		rv = bcm_l3_vrf_stat_get(
			req->args.l3_vrf_stat_get.unit,
			req->args.l3_vrf_stat_get.vrf,
			req->args.l3_vrf_stat_get.stat,
			req->args.l3_vrf_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_GET32:
		rv = bcm_l3_vrf_stat_get32(
			req->args.l3_vrf_stat_get32.unit,
			req->args.l3_vrf_stat_get32.vrf,
			req->args.l3_vrf_stat_get32.stat,
			req->args.l3_vrf_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_MULTI_GET:
		rv = bcm_l3_vrf_stat_multi_get(
			req->args.l3_vrf_stat_multi_get.unit,
			req->args.l3_vrf_stat_multi_get.vrf,
			req->args.l3_vrf_stat_multi_get.nstat,
			req->args.l3_vrf_stat_multi_get.stat_arr,
			req->args.l3_vrf_stat_multi_get.value_arr);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_MULTI_GET32:
		rv = bcm_l3_vrf_stat_multi_get32(
			req->args.l3_vrf_stat_multi_get32.unit,
			req->args.l3_vrf_stat_multi_get32.vrf,
			req->args.l3_vrf_stat_multi_get32.nstat,
			req->args.l3_vrf_stat_multi_get32.stat_arr,
			req->args.l3_vrf_stat_multi_get32.value_arr);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_MULTI_SET:
		rv = bcm_l3_vrf_stat_multi_set(
			req->args.l3_vrf_stat_multi_set.unit,
			req->args.l3_vrf_stat_multi_set.vrf,
			req->args.l3_vrf_stat_multi_set.nstat,
			req->args.l3_vrf_stat_multi_set.stat_arr,
			req->args.l3_vrf_stat_multi_set.value_arr);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_MULTI_SET32:
		rv = bcm_l3_vrf_stat_multi_set32(
			req->args.l3_vrf_stat_multi_set32.unit,
			req->args.l3_vrf_stat_multi_set32.vrf,
			req->args.l3_vrf_stat_multi_set32.nstat,
			req->args.l3_vrf_stat_multi_set32.stat_arr,
			req->args.l3_vrf_stat_multi_set32.value_arr);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_SET:
		rv = bcm_l3_vrf_stat_set(
			req->args.l3_vrf_stat_set.unit,
			req->args.l3_vrf_stat_set.vrf,
			req->args.l3_vrf_stat_set.stat,
			req->args.l3_vrf_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_L3_VRF_STAT_SET32:
		rv = bcm_l3_vrf_stat_set32(
			req->args.l3_vrf_stat_set32.unit,
			req->args.l3_vrf_stat_set32.vrf,
			req->args.l3_vrf_stat_set32.stat,
			req->args.l3_vrf_stat_set32.val);
		break;
	case BCM_ASYNC_ENTRY_L3_VRRP_ADD:
		rv = bcm_l3_vrrp_add(
			req->args.l3_vrrp_add.unit,
			req->args.l3_vrrp_add.vlan,
			req->args.l3_vrrp_add.vrid);
		break;
	case BCM_ASYNC_ENTRY_L3_VRRP_DELETE:
		rv = bcm_l3_vrrp_delete(
			req->args.l3_vrrp_delete.unit,
			req->args.l3_vrrp_delete.vlan,
			req->args.l3_vrrp_delete.vrid);
		break;
	case BCM_ASYNC_ENTRY_L3_VRRP_DELETE_ALL:
		rv = bcm_l3_vrrp_delete_all(
			req->args.l3_vrrp_delete_all.unit,
			req->args.l3_vrrp_delete_all.vlan);
		break;
	case BCM_ASYNC_ENTRY_L3_VRRP_GET:
		rv = bcm_l3_vrrp_get(
			req->args.l3_vrrp_get.unit,
			req->args.l3_vrrp_get.vlan,
			req->args.l3_vrrp_get.alloc_size,
			req->args.l3_vrrp_get.vrid_array,
			req->args.l3_vrrp_get.count);
		break;
#endif	/* INCLUDE_L3 */
	case BCM_ASYNC_ENTRY_LINK_CHANGE:
		rv = bcm_link_change(
			req->args.link_change.unit,
			req->args.link_change.pbmp);
		break;
	case BCM_ASYNC_ENTRY_LINK_WAIT:
		rv = bcm_link_wait(
			req->args.link_wait.unit,
			req->args.link_wait.pbm,
			req->args.link_wait.us);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_DETACH:
		rv = bcm_linkscan_detach(
			req->args.linkscan_detach.unit);
		break;
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_LINKSCAN_DUMP:
		rv = bcm_linkscan_dump(
			req->args.linkscan_dump.unit);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_LINKSCAN_ENABLE_GET:
		rv = bcm_linkscan_enable_get(
			req->args.linkscan_enable_get.unit,
			req->args.linkscan_enable_get.us);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_ENABLE_PORT_GET:
		rv = bcm_linkscan_enable_port_get(
			req->args.linkscan_enable_port_get.unit,
			req->args.linkscan_enable_port_get.port);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_ENABLE_SET:
		rv = bcm_linkscan_enable_set(
			req->args.linkscan_enable_set.unit,
			req->args.linkscan_enable_set.us);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_INIT:
		rv = bcm_linkscan_init(
			req->args.linkscan_init.unit);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_MODE_GET:
		rv = bcm_linkscan_mode_get(
			req->args.linkscan_mode_get.unit,
			req->args.linkscan_mode_get.port,
			req->args.linkscan_mode_get.mode);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_MODE_SET:
		rv = bcm_linkscan_mode_set(
			req->args.linkscan_mode_set.unit,
			req->args.linkscan_mode_set.port,
			req->args.linkscan_mode_set.mode);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_MODE_SET_PBM:
		rv = bcm_linkscan_mode_set_pbm(
			req->args.linkscan_mode_set_pbm.unit,
			req->args.linkscan_mode_set_pbm.pbm,
			req->args.linkscan_mode_set_pbm.mode);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_PORT_REGISTER:
		rv = bcm_linkscan_port_register(
			req->args.linkscan_port_register.unit,
			req->args.linkscan_port_register.port,
			req->args.linkscan_port_register.f);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_PORT_UNREGISTER:
		rv = bcm_linkscan_port_unregister(
			req->args.linkscan_port_unregister.unit,
			req->args.linkscan_port_unregister.port,
			req->args.linkscan_port_unregister.f);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_REGISTER:
		rv = bcm_linkscan_register(
			req->args.linkscan_register.unit,
			req->args.linkscan_register.f);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_UNREGISTER:
		rv = bcm_linkscan_unregister(
			req->args.linkscan_unregister.unit,
			req->args.linkscan_unregister.f);
		break;
	case BCM_ASYNC_ENTRY_LINKSCAN_UPDATE:
		rv = bcm_linkscan_update(
			req->args.linkscan_update.unit,
			req->args.linkscan_update.pbm);
		break;
#ifdef	INCLUDE_MACSEC
	case BCM_ASYNC_ENTRY_MACSEC_EVENT_ENABLE_GET:
		rv = bcm_macsec_event_enable_get(
			req->args.macsec_event_enable_get.unit,
			req->args.macsec_event_enable_get.t,
			req->args.macsec_event_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_EVENT_ENABLE_SET:
		rv = bcm_macsec_event_enable_set(
			req->args.macsec_event_enable_set.unit,
			req->args.macsec_event_enable_set.t,
			req->args.macsec_event_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_EVENT_REGISTER:
		rv = bcm_macsec_event_register(
			req->args.macsec_event_register.unit,
			req->args.macsec_event_register.cb,
			req->args.macsec_event_register.user_data);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_EVENT_UNREGISTER:
		rv = bcm_macsec_event_unregister(
			req->args.macsec_event_unregister.unit,
			req->args.macsec_event_unregister.cb);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_FLOW_CREATE:
		rv = bcm_macsec_flow_create(
			req->args.macsec_flow_create.unit,
			req->args.macsec_flow_create.port,
			req->args.macsec_flow_create.flags,
			req->args.macsec_flow_create.flow,
			req->args.macsec_flow_create.action,
			req->args.macsec_flow_create.flowId);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_FLOW_DESTROY:
		rv = bcm_macsec_flow_destroy(
			req->args.macsec_flow_destroy.unit,
			req->args.macsec_flow_destroy.port,
			req->args.macsec_flow_destroy.flowId);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_FLOW_GET:
		rv = bcm_macsec_flow_get(
			req->args.macsec_flow_get.unit,
			req->args.macsec_flow_get.port,
			req->args.macsec_flow_get.flowId,
			req->args.macsec_flow_get.flow,
			req->args.macsec_flow_get.a);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_FLOW_TRAVERSE:
		rv = bcm_macsec_flow_traverse(
			req->args.macsec_flow_traverse.unit,
			req->args.macsec_flow_traverse.port,
			req->args.macsec_flow_traverse.callbk,
			req->args.macsec_flow_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_PORT_CONFIG_GET:
		rv = bcm_macsec_port_config_get(
			req->args.macsec_port_config_get.unit,
			req->args.macsec_port_config_get.port,
			req->args.macsec_port_config_get.cfg);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_PORT_CONFIG_SET:
		rv = bcm_macsec_port_config_set(
			req->args.macsec_port_config_set.unit,
			req->args.macsec_port_config_set.port,
			req->args.macsec_port_config_set.cfg);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_PORT_TRAVERSE:
		rv = bcm_macsec_port_traverse(
			req->args.macsec_port_traverse.unit,
			req->args.macsec_port_traverse.callbk,
			req->args.macsec_port_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_SECURE_ASSOC_CREATE:
		rv = bcm_macsec_secure_assoc_create(
			req->args.macsec_secure_assoc_create.unit,
			req->args.macsec_secure_assoc_create.port,
			req->args.macsec_secure_assoc_create.flags,
			req->args.macsec_secure_assoc_create.chanId,
			req->args.macsec_secure_assoc_create.assoc,
			req->args.macsec_secure_assoc_create.assocId);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_SECURE_ASSOC_DESTROY:
		rv = bcm_macsec_secure_assoc_destroy(
			req->args.macsec_secure_assoc_destroy.unit,
			req->args.macsec_secure_assoc_destroy.port,
			req->args.macsec_secure_assoc_destroy.assocId);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_SECURE_ASSOC_GET:
		rv = bcm_macsec_secure_assoc_get(
			req->args.macsec_secure_assoc_get.unit,
			req->args.macsec_secure_assoc_get.port,
			req->args.macsec_secure_assoc_get.assocId,
			req->args.macsec_secure_assoc_get.assoc,
			req->args.macsec_secure_assoc_get.chanId);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_SECURE_ASSOC_TRAVERSE:
		rv = bcm_macsec_secure_assoc_traverse(
			req->args.macsec_secure_assoc_traverse.unit,
			req->args.macsec_secure_assoc_traverse.port,
			req->args.macsec_secure_assoc_traverse.chanId,
			req->args.macsec_secure_assoc_traverse.cb,
			req->args.macsec_secure_assoc_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_SECURE_CHAN_CREATE:
		rv = bcm_macsec_secure_chan_create(
			req->args.macsec_secure_chan_create.unit,
			req->args.macsec_secure_chan_create.port,
			req->args.macsec_secure_chan_create.flags,
			req->args.macsec_secure_chan_create.chan,
			req->args.macsec_secure_chan_create.chanId);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_SECURE_CHAN_DESTROY:
		rv = bcm_macsec_secure_chan_destroy(
			req->args.macsec_secure_chan_destroy.unit,
			req->args.macsec_secure_chan_destroy.port,
			req->args.macsec_secure_chan_destroy.chanId);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_SECURE_CHAN_GET:
		rv = bcm_macsec_secure_chan_get(
			req->args.macsec_secure_chan_get.unit,
			req->args.macsec_secure_chan_get.port,
			req->args.macsec_secure_chan_get.chanId,
			req->args.macsec_secure_chan_get.chan);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_SECURE_CHAN_TRAVERSE:
		rv = bcm_macsec_secure_chan_traverse(
			req->args.macsec_secure_chan_traverse.unit,
			req->args.macsec_secure_chan_traverse.port,
			req->args.macsec_secure_chan_traverse.calback,
			req->args.macsec_secure_chan_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_STAT_CLEAR:
		rv = bcm_macsec_stat_clear(
			req->args.macsec_stat_clear.unit,
			req->args.macsec_stat_clear.port);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_STAT_GET:
		rv = bcm_macsec_stat_get(
			req->args.macsec_stat_get.unit,
			req->args.macsec_stat_get.port,
			req->args.macsec_stat_get.stat,
			req->args.macsec_stat_get.chanId,
			req->args.macsec_stat_get.assocId,
			req->args.macsec_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_STAT_GET32:
		rv = bcm_macsec_stat_get32(
			req->args.macsec_stat_get32.unit,
			req->args.macsec_stat_get32.port,
			req->args.macsec_stat_get32.stat,
			req->args.macsec_stat_get32.chanId,
			req->args.macsec_stat_get32.assocId,
			req->args.macsec_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_STAT_SET:
		rv = bcm_macsec_stat_set(
			req->args.macsec_stat_set.unit,
			req->args.macsec_stat_set.port,
			req->args.macsec_stat_set.stat,
			req->args.macsec_stat_set.chanId,
			req->args.macsec_stat_set.assocId,
			req->args.macsec_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_MACSEC_STAT_SET32:
		rv = bcm_macsec_stat_set32(
			req->args.macsec_stat_set32.unit,
			req->args.macsec_stat_set32.port,
			req->args.macsec_stat_set32.stat,
			req->args.macsec_stat_set32.chanId,
			req->args.macsec_stat_set32.assocId,
			req->args.macsec_stat_set32.val);
		break;
#endif	/* INCLUDE_MACSEC */
	case BCM_ASYNC_ENTRY_MCAST_ADDR_ADD:
		rv = bcm_mcast_addr_add(
			req->args.mcast_addr_add.unit,
			req->args.mcast_addr_add.mcaddr);
		break;
	case BCM_ASYNC_ENTRY_MCAST_ADDR_ADD_W_L2MCINDEX:
		rv = bcm_mcast_addr_add_w_l2mcindex(
			req->args.mcast_addr_add_w_l2mcindex.unit,
			req->args.mcast_addr_add_w_l2mcindex.mcaddr);
		break;
	case BCM_ASYNC_ENTRY_MCAST_ADDR_REMOVE:
		rv = bcm_mcast_addr_remove(
			req->args.mcast_addr_remove.unit,
			req->args.mcast_addr_remove.mac,
			req->args.mcast_addr_remove.vid);
		break;
	case BCM_ASYNC_ENTRY_MCAST_ADDR_REMOVE_W_L2MCINDEX:
		rv = bcm_mcast_addr_remove_w_l2mcindex(
			req->args.mcast_addr_remove_w_l2mcindex.unit,
			req->args.mcast_addr_remove_w_l2mcindex.mcaddr);
		break;
	case BCM_ASYNC_ENTRY_MCAST_BITMAP_DEL:
		rv = bcm_mcast_bitmap_del(
			req->args.mcast_bitmap_del.unit,
			req->args.mcast_bitmap_del.mc_idx,
			req->args.mcast_bitmap_del.in_port,
			req->args.mcast_bitmap_del.pbmp);
		break;
	case BCM_ASYNC_ENTRY_MCAST_BITMAP_GET:
		rv = bcm_mcast_bitmap_get(
			req->args.mcast_bitmap_get.unit,
			req->args.mcast_bitmap_get.mc_idx,
			req->args.mcast_bitmap_get.in_port,
			req->args.mcast_bitmap_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_MCAST_BITMAP_MAX_GET:
		rv = bcm_mcast_bitmap_max_get(
			req->args.mcast_bitmap_max_get.unit,
			req->args.mcast_bitmap_max_get.max_index);
		break;
	case BCM_ASYNC_ENTRY_MCAST_BITMAP_SET:
		rv = bcm_mcast_bitmap_set(
			req->args.mcast_bitmap_set.unit,
			req->args.mcast_bitmap_set.mc_idx,
			req->args.mcast_bitmap_set.in_port,
			req->args.mcast_bitmap_set.pbmp);
		break;
	case BCM_ASYNC_ENTRY_MCAST_INIT:
		rv = bcm_mcast_init(
			req->args.mcast_init.unit);
		break;
	case BCM_ASYNC_ENTRY_MCAST_JOIN:
		rv = bcm_mcast_join(
			req->args.mcast_join.unit,
			req->args.mcast_join.mcMacAddr,
			req->args.mcast_join.vlanId,
			req->args.mcast_join.srcPort,
			req->args.mcast_join.mcaddr,
			req->args.mcast_join.allRouterBmp);
		break;
	case BCM_ASYNC_ENTRY_MCAST_LEAVE:
		rv = bcm_mcast_leave(
			req->args.mcast_leave.unit,
			req->args.mcast_leave.mcMacAddr,
			req->args.mcast_leave.vlanId,
			req->args.mcast_leave.srcPort);
		break;
	case BCM_ASYNC_ENTRY_MCAST_PORT_ADD:
		rv = bcm_mcast_port_add(
			req->args.mcast_port_add.unit,
			req->args.mcast_port_add.mcaddr);
		break;
	case BCM_ASYNC_ENTRY_MCAST_PORT_GET:
		rv = bcm_mcast_port_get(
			req->args.mcast_port_get.unit,
			req->args.mcast_port_get.mac,
			req->args.mcast_port_get.vid,
			req->args.mcast_port_get.mcaddr);
		break;
	case BCM_ASYNC_ENTRY_MCAST_PORT_REMOVE:
		rv = bcm_mcast_port_remove(
			req->args.mcast_port_remove.unit,
			req->args.mcast_port_remove.mcaddr);
		break;
	case BCM_ASYNC_ENTRY_METER_CREATE:
		rv = bcm_meter_create(
			req->args.meter_create.unit,
			req->args.meter_create.port,
			req->args.meter_create.mid);
		break;
	case BCM_ASYNC_ENTRY_METER_DELETE:
		rv = bcm_meter_delete(
			req->args.meter_delete.unit,
			req->args.meter_delete.port,
			req->args.meter_delete.mid);
		break;
	case BCM_ASYNC_ENTRY_METER_DELETE_ALL:
		rv = bcm_meter_delete_all(
			req->args.meter_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_METER_GET:
		rv = bcm_meter_get(
			req->args.meter_get.unit,
			req->args.meter_get.port,
			req->args.meter_get.mid,
			req->args.meter_get.kbits_sec,
			req->args.meter_get.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_METER_INIT:
		rv = bcm_meter_init(
			req->args.meter_init.unit);
		break;
	case BCM_ASYNC_ENTRY_METER_SET:
		rv = bcm_meter_set(
			req->args.meter_set.unit,
			req->args.meter_set.port,
			req->args.meter_set.mid,
			req->args.meter_set.kbits_sec,
			req->args.meter_set.kbits_burst);
		break;
#ifdef	INCLUDE_L3
	case BCM_ASYNC_ENTRY_MIM_DETACH:
		rv = bcm_mim_detach(
			req->args.mim_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_MIM_INIT:
		rv = bcm_mim_init(
			req->args.mim_init.unit);
		break;
	case BCM_ASYNC_ENTRY_MIM_PORT_ADD:
		rv = bcm_mim_port_add(
			req->args.mim_port_add.unit,
			req->args.mim_port_add.vpn,
			req->args.mim_port_add.mim_port);
		break;
	case BCM_ASYNC_ENTRY_MIM_PORT_DELETE:
		rv = bcm_mim_port_delete(
			req->args.mim_port_delete.unit,
			req->args.mim_port_delete.vpn,
			req->args.mim_port_delete.mim_port_id);
		break;
	case BCM_ASYNC_ENTRY_MIM_PORT_DELETE_ALL:
		rv = bcm_mim_port_delete_all(
			req->args.mim_port_delete_all.unit,
			req->args.mim_port_delete_all.vpn);
		break;
	case BCM_ASYNC_ENTRY_MIM_PORT_GET:
		rv = bcm_mim_port_get(
			req->args.mim_port_get.unit,
			req->args.mim_port_get.vpn,
			req->args.mim_port_get.mim_port);
		break;
	case BCM_ASYNC_ENTRY_MIM_PORT_GET_ALL:
		rv = bcm_mim_port_get_all(
			req->args.mim_port_get_all.unit,
			req->args.mim_port_get_all.vpn,
			req->args.mim_port_get_all.port_max,
			req->args.mim_port_get_all.port_array,
			req->args.mim_port_get_all.port_count);
		break;
	case BCM_ASYNC_ENTRY_MIM_VPN_CREATE:
		rv = bcm_mim_vpn_create(
			req->args.mim_vpn_create.unit,
			req->args.mim_vpn_create.info);
		break;
	case BCM_ASYNC_ENTRY_MIM_VPN_DESTROY:
		rv = bcm_mim_vpn_destroy(
			req->args.mim_vpn_destroy.unit,
			req->args.mim_vpn_destroy.vpn);
		break;
	case BCM_ASYNC_ENTRY_MIM_VPN_DESTROY_ALL:
		rv = bcm_mim_vpn_destroy_all(
			req->args.mim_vpn_destroy_all.unit);
		break;
	case BCM_ASYNC_ENTRY_MIM_VPN_GET:
		rv = bcm_mim_vpn_get(
			req->args.mim_vpn_get.unit,
			req->args.mim_vpn_get.vpn,
			req->args.mim_vpn_get.info);
		break;
	case BCM_ASYNC_ENTRY_MIM_VPN_TRAVERSE:
		rv = bcm_mim_vpn_traverse(
			req->args.mim_vpn_traverse.unit,
			req->args.mim_vpn_traverse.cb,
			req->args.mim_vpn_traverse.user_data);
		break;
#endif	/* INCLUDE_L3 */
	case BCM_ASYNC_ENTRY_MIRROR_DESTINATION_CREATE:
		rv = bcm_mirror_destination_create(
			req->args.mirror_destination_create.unit,
			req->args.mirror_destination_create.mirror_dest);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_DESTINATION_DESTROY:
		rv = bcm_mirror_destination_destroy(
			req->args.mirror_destination_destroy.unit,
			req->args.mirror_destination_destroy.mirror_dest_id);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_DESTINATION_GET:
		rv = bcm_mirror_destination_get(
			req->args.mirror_destination_get.unit,
			req->args.mirror_destination_get.mirror_dest_id,
			req->args.mirror_destination_get.mirror_dest);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_DESTINATION_TRAVERSE:
		rv = bcm_mirror_destination_traverse(
			req->args.mirror_destination_traverse.unit,
			req->args.mirror_destination_traverse.cb,
			req->args.mirror_destination_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_EGRESS_GET:
		rv = bcm_mirror_egress_get(
			req->args.mirror_egress_get.unit,
			req->args.mirror_egress_get.port,
			req->args.mirror_egress_get.val);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_EGRESS_PATH_GET:
		rv = bcm_mirror_egress_path_get(
			req->args.mirror_egress_path_get.unit,
			req->args.mirror_egress_path_get.modid,
			req->args.mirror_egress_path_get.port);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_EGRESS_PATH_SET:
		rv = bcm_mirror_egress_path_set(
			req->args.mirror_egress_path_set.unit,
			req->args.mirror_egress_path_set.modid,
			req->args.mirror_egress_path_set.port);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_EGRESS_SET:
		rv = bcm_mirror_egress_set(
			req->args.mirror_egress_set.unit,
			req->args.mirror_egress_set.port,
			req->args.mirror_egress_set.val);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_INGRESS_GET:
		rv = bcm_mirror_ingress_get(
			req->args.mirror_ingress_get.unit,
			req->args.mirror_ingress_get.port,
			req->args.mirror_ingress_get.val);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_INGRESS_SET:
		rv = bcm_mirror_ingress_set(
			req->args.mirror_ingress_set.unit,
			req->args.mirror_ingress_set.port,
			req->args.mirror_ingress_set.val);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_INIT:
		rv = bcm_mirror_init(
			req->args.mirror_init.unit);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_MODE_GET:
		rv = bcm_mirror_mode_get(
			req->args.mirror_mode_get.unit,
			req->args.mirror_mode_get.mode);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_MODE_SET:
		rv = bcm_mirror_mode_set(
			req->args.mirror_mode_set.unit,
			req->args.mirror_mode_set.mode);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_PFMT_GET:
		rv = bcm_mirror_pfmt_get(
			req->args.mirror_pfmt_get.unit,
			req->args.mirror_pfmt_get.val);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_PFMT_SET:
		rv = bcm_mirror_pfmt_set(
			req->args.mirror_pfmt_set.unit,
			req->args.mirror_pfmt_set.val);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_PORT_DEST_ADD:
		rv = bcm_mirror_port_dest_add(
			req->args.mirror_port_dest_add.unit,
			req->args.mirror_port_dest_add.port,
			req->args.mirror_port_dest_add.flags,
			req->args.mirror_port_dest_add.mirror_dest_id);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_PORT_DEST_DELETE:
		rv = bcm_mirror_port_dest_delete(
			req->args.mirror_port_dest_delete.unit,
			req->args.mirror_port_dest_delete.port,
			req->args.mirror_port_dest_delete.flags,
			req->args.mirror_port_dest_delete.mirror_dest_id);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_PORT_DEST_DELETE_ALL:
		rv = bcm_mirror_port_dest_delete_all(
			req->args.mirror_port_dest_delete_all.unit,
			req->args.mirror_port_dest_delete_all.port,
			req->args.mirror_port_dest_delete_all.flags);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_PORT_DEST_GET:
		rv = bcm_mirror_port_dest_get(
			req->args.mirror_port_dest_get.unit,
			req->args.mirror_port_dest_get.port,
			req->args.mirror_port_dest_get.flags,
			req->args.mirror_port_dest_get.mirror_dest_size,
			req->args.mirror_port_dest_get.mirror_dest,
			req->args.mirror_port_dest_get.mirror_dest_count);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_PORT_GET:
		rv = bcm_mirror_port_get(
			req->args.mirror_port_get.unit,
			req->args.mirror_port_get.port,
			req->args.mirror_port_get.dest_mod,
			req->args.mirror_port_get.dest_port,
			req->args.mirror_port_get.flags);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_PORT_SET:
		rv = bcm_mirror_port_set(
			req->args.mirror_port_set.unit,
			req->args.mirror_port_set.port,
			req->args.mirror_port_set.dest_mod,
			req->args.mirror_port_set.dest_port,
			req->args.mirror_port_set.flags);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_TO_GET:
		rv = bcm_mirror_to_get(
			req->args.mirror_to_get.unit,
			req->args.mirror_to_get.port);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_TO_PBMP_GET:
		rv = bcm_mirror_to_pbmp_get(
			req->args.mirror_to_pbmp_get.unit,
			req->args.mirror_to_pbmp_get.port,
			req->args.mirror_to_pbmp_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_TO_PBMP_SET:
		rv = bcm_mirror_to_pbmp_set(
			req->args.mirror_to_pbmp_set.unit,
			req->args.mirror_to_pbmp_set.port,
			req->args.mirror_to_pbmp_set.pbmp);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_TO_SET:
		rv = bcm_mirror_to_set(
			req->args.mirror_to_set.unit,
			req->args.mirror_to_set.port);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_VLAN_GET:
		rv = bcm_mirror_vlan_get(
			req->args.mirror_vlan_get.unit,
			req->args.mirror_vlan_get.port,
			req->args.mirror_vlan_get.tpid,
			req->args.mirror_vlan_get.vlan);
		break;
	case BCM_ASYNC_ENTRY_MIRROR_VLAN_SET:
		rv = bcm_mirror_vlan_set(
			req->args.mirror_vlan_set.unit,
			req->args.mirror_vlan_set.port,
			req->args.mirror_vlan_set.tpid,
			req->args.mirror_vlan_set.vlan);
		break;
	/* bcm_module_name has a non int return type */
#ifdef	INCLUDE_L3
	case BCM_ASYNC_ENTRY_MPLS_CLEANUP:
		rv = bcm_mpls_cleanup(
			req->args.mpls_cleanup.unit);
		break;
	case BCM_ASYNC_ENTRY_MPLS_EXP_MAP_CREATE:
		rv = bcm_mpls_exp_map_create(
			req->args.mpls_exp_map_create.unit,
			req->args.mpls_exp_map_create.flags,
			req->args.mpls_exp_map_create.exp_map_id);
		break;
	case BCM_ASYNC_ENTRY_MPLS_EXP_MAP_DESTROY:
		rv = bcm_mpls_exp_map_destroy(
			req->args.mpls_exp_map_destroy.unit,
			req->args.mpls_exp_map_destroy.exp_map_id);
		break;
	case BCM_ASYNC_ENTRY_MPLS_EXP_MAP_GET:
		rv = bcm_mpls_exp_map_get(
			req->args.mpls_exp_map_get.unit,
			req->args.mpls_exp_map_get.exp_map_id,
			req->args.mpls_exp_map_get.exp_map);
		break;
	case BCM_ASYNC_ENTRY_MPLS_EXP_MAP_SET:
		rv = bcm_mpls_exp_map_set(
			req->args.mpls_exp_map_set.unit,
			req->args.mpls_exp_map_set.exp_map_id,
			req->args.mpls_exp_map_set.exp_map);
		break;
	case BCM_ASYNC_ENTRY_MPLS_INFO:
		rv = bcm_mpls_info(
			req->args.mpls_info.unit,
			req->args.mpls_info.info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_INIT:
		rv = bcm_mpls_init(
			req->args.mpls_init.unit);
		break;
	case BCM_ASYNC_ENTRY_MPLS_L3_INITIATOR_CLEAR:
		rv = bcm_mpls_l3_initiator_clear(
			req->args.mpls_l3_initiator_clear.unit,
			req->args.mpls_l3_initiator_clear.intf);
		break;
	case BCM_ASYNC_ENTRY_MPLS_L3_INITIATOR_CLEAR_ALL:
		rv = bcm_mpls_l3_initiator_clear_all(
			req->args.mpls_l3_initiator_clear_all.unit);
		break;
	case BCM_ASYNC_ENTRY_MPLS_L3_INITIATOR_GET:
		rv = bcm_mpls_l3_initiator_get(
			req->args.mpls_l3_initiator_get.unit,
			req->args.mpls_l3_initiator_get.intf,
			req->args.mpls_l3_initiator_get.mpls_label);
		break;
	case BCM_ASYNC_ENTRY_MPLS_L3_INITIATOR_SET:
		rv = bcm_mpls_l3_initiator_set(
			req->args.mpls_l3_initiator_set.unit,
			req->args.mpls_l3_initiator_set.intf,
			req->args.mpls_l3_initiator_set.mpls_label);
		break;
	case BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_CLEAR:
		rv = bcm_mpls_label_stat_clear(
			req->args.mpls_label_stat_clear.unit,
			req->args.mpls_label_stat_clear.label,
			req->args.mpls_label_stat_clear.port,
			req->args.mpls_label_stat_clear.stat);
		break;
	case BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_GET:
		rv = bcm_mpls_label_stat_get(
			req->args.mpls_label_stat_get.unit,
			req->args.mpls_label_stat_get.label,
			req->args.mpls_label_stat_get.port,
			req->args.mpls_label_stat_get.stat,
			req->args.mpls_label_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_MPLS_LABEL_STAT_GET32:
		rv = bcm_mpls_label_stat_get32(
			req->args.mpls_label_stat_get32.unit,
			req->args.mpls_label_stat_get32.label,
			req->args.mpls_label_stat_get32.port,
			req->args.mpls_label_stat_get32.stat,
			req->args.mpls_label_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_ADD:
		rv = bcm_mpls_port_add(
			req->args.mpls_port_add.unit,
			req->args.mpls_port_add.vpn,
			req->args.mpls_port_add.mpls_port);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_BLOCK_GET:
		rv = bcm_mpls_port_block_get(
			req->args.mpls_port_block_get.unit,
			req->args.mpls_port_block_get.vpn,
			req->args.mpls_port_block_get.port,
			req->args.mpls_port_block_get.enable);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_BLOCK_SET:
		rv = bcm_mpls_port_block_set(
			req->args.mpls_port_block_set.unit,
			req->args.mpls_port_block_set.vpn,
			req->args.mpls_port_block_set.port,
			req->args.mpls_port_block_set.enable);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_DELETE:
		rv = bcm_mpls_port_delete(
			req->args.mpls_port_delete.unit,
			req->args.mpls_port_delete.vpn,
			req->args.mpls_port_delete.mpls_port_id);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_DELETE_ALL:
		rv = bcm_mpls_port_delete_all(
			req->args.mpls_port_delete_all.unit,
			req->args.mpls_port_delete_all.vpn);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_GET:
		rv = bcm_mpls_port_get(
			req->args.mpls_port_get.unit,
			req->args.mpls_port_get.vpn,
			req->args.mpls_port_get.mpls_port);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_GET_ALL:
		rv = bcm_mpls_port_get_all(
			req->args.mpls_port_get_all.unit,
			req->args.mpls_port_get_all.vpn,
			req->args.mpls_port_get_all.port_max,
			req->args.mpls_port_get_all.port_array,
			req->args.mpls_port_get_all.port_count);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_STAT_ENABLE_SET:
		rv = bcm_mpls_port_stat_enable_set(
			req->args.mpls_port_stat_enable_set.unit,
			req->args.mpls_port_stat_enable_set.mpls_port,
			req->args.mpls_port_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_STAT_GET:
		rv = bcm_mpls_port_stat_get(
			req->args.mpls_port_stat_get.unit,
			req->args.mpls_port_stat_get.mpls_port,
			req->args.mpls_port_stat_get.cos,
			req->args.mpls_port_stat_get.stat,
			req->args.mpls_port_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_STAT_GET32:
		rv = bcm_mpls_port_stat_get32(
			req->args.mpls_port_stat_get32.unit,
			req->args.mpls_port_stat_get32.mpls_port,
			req->args.mpls_port_stat_get32.cos,
			req->args.mpls_port_stat_get32.stat,
			req->args.mpls_port_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_STAT_SET:
		rv = bcm_mpls_port_stat_set(
			req->args.mpls_port_stat_set.unit,
			req->args.mpls_port_stat_set.mpls_port,
			req->args.mpls_port_stat_set.cos,
			req->args.mpls_port_stat_set.stat,
			req->args.mpls_port_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_MPLS_PORT_STAT_SET32:
		rv = bcm_mpls_port_stat_set32(
			req->args.mpls_port_stat_set32.unit,
			req->args.mpls_port_stat_set32.mpls_port,
			req->args.mpls_port_stat_set32.cos,
			req->args.mpls_port_stat_set32.stat,
			req->args.mpls_port_stat_set32.val);
		break;
	case BCM_ASYNC_ENTRY_MPLS_SWITCH_ADD:
		rv = bcm_mpls_switch_add(
			req->args.mpls_switch_add.unit,
			req->args.mpls_switch_add.mswitch_info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_SWITCH_DELETE:
		rv = bcm_mpls_switch_delete(
			req->args.mpls_switch_delete.unit,
			req->args.mpls_switch_delete.mswitch_info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_SWITCH_DELETE_ALL:
		rv = bcm_mpls_switch_delete_all(
			req->args.mpls_switch_delete_all.unit,
			req->args.mpls_switch_delete_all.flag);
		break;
	case BCM_ASYNC_ENTRY_MPLS_SWITCH_GET:
		rv = bcm_mpls_switch_get(
			req->args.mpls_switch_get.unit,
			req->args.mpls_switch_get.mswitch_info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_SWITCH_TRAVERSE:
		rv = bcm_mpls_switch_traverse(
			req->args.mpls_switch_traverse.unit,
			req->args.mpls_switch_traverse.flags,
			req->args.mpls_switch_traverse.start,
			req->args.mpls_switch_traverse.end,
			req->args.mpls_switch_traverse.trav_fn,
			req->args.mpls_switch_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_CLEAR:
		rv = bcm_mpls_tunnel_initiator_clear(
			req->args.mpls_tunnel_initiator_clear.unit,
			req->args.mpls_tunnel_initiator_clear.intf);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_CLEAR_ALL:
		rv = bcm_mpls_tunnel_initiator_clear_all(
			req->args.mpls_tunnel_initiator_clear_all.unit);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_GET:
		rv = bcm_mpls_tunnel_initiator_get(
			req->args.mpls_tunnel_initiator_get.unit,
			req->args.mpls_tunnel_initiator_get.intf,
			req->args.mpls_tunnel_initiator_get.label_max,
			req->args.mpls_tunnel_initiator_get.label_array,
			req->args.mpls_tunnel_initiator_get.label_count);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_INITIATOR_SET:
		rv = bcm_mpls_tunnel_initiator_set(
			req->args.mpls_tunnel_initiator_set.unit,
			req->args.mpls_tunnel_initiator_set.intf,
			req->args.mpls_tunnel_initiator_set.num_labels,
			req->args.mpls_tunnel_initiator_set.label_array);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_ADD:
		rv = bcm_mpls_tunnel_switch_add(
			req->args.mpls_tunnel_switch_add.unit,
			req->args.mpls_tunnel_switch_add.info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_DELETE:
		rv = bcm_mpls_tunnel_switch_delete(
			req->args.mpls_tunnel_switch_delete.unit,
			req->args.mpls_tunnel_switch_delete.info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_DELETE_ALL:
		rv = bcm_mpls_tunnel_switch_delete_all(
			req->args.mpls_tunnel_switch_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_GET:
		rv = bcm_mpls_tunnel_switch_get(
			req->args.mpls_tunnel_switch_get.unit,
			req->args.mpls_tunnel_switch_get.info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_TUNNEL_SWITCH_TRAVERSE:
		rv = bcm_mpls_tunnel_switch_traverse(
			req->args.mpls_tunnel_switch_traverse.unit,
			req->args.mpls_tunnel_switch_traverse.cb,
			req->args.mpls_tunnel_switch_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_ADD:
		rv = bcm_mpls_vpn_add(
			req->args.mpls_vpn_add.unit,
			req->args.mpls_vpn_add.vpn,
			req->args.mpls_vpn_add.vpn_info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_CIRCUIT_ADD:
		rv = bcm_mpls_vpn_circuit_add(
			req->args.mpls_vpn_circuit_add.unit,
			req->args.mpls_vpn_circuit_add.vpn,
			req->args.mpls_vpn_circuit_add.vc_info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_CIRCUIT_DELETE:
		rv = bcm_mpls_vpn_circuit_delete(
			req->args.mpls_vpn_circuit_delete.unit,
			req->args.mpls_vpn_circuit_delete.vpn,
			req->args.mpls_vpn_circuit_delete.vc_info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_CIRCUIT_DELETE_ALL:
		rv = bcm_mpls_vpn_circuit_delete_all(
			req->args.mpls_vpn_circuit_delete_all.unit,
			req->args.mpls_vpn_circuit_delete_all.vpn);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_CIRCUIT_GET:
		rv = bcm_mpls_vpn_circuit_get(
			req->args.mpls_vpn_circuit_get.unit,
			req->args.mpls_vpn_circuit_get.vpn,
			req->args.mpls_vpn_circuit_get.vc_array,
			req->args.mpls_vpn_circuit_get.vc_info,
			req->args.mpls_vpn_circuit_get.vc_count);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_CREATE:
		rv = bcm_mpls_vpn_create(
			req->args.mpls_vpn_create.unit,
			req->args.mpls_vpn_create.vpn,
			req->args.mpls_vpn_create.flags);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_DELETE:
		rv = bcm_mpls_vpn_delete(
			req->args.mpls_vpn_delete.unit,
			req->args.mpls_vpn_delete.vpn,
			req->args.mpls_vpn_delete.key);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_DELETE_ALL:
		rv = bcm_mpls_vpn_delete_all(
			req->args.mpls_vpn_delete_all.unit,
			req->args.mpls_vpn_delete_all.vpn);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_DESTROY:
		rv = bcm_mpls_vpn_destroy(
			req->args.mpls_vpn_destroy.unit,
			req->args.mpls_vpn_destroy.vpn);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_GET:
		rv = bcm_mpls_vpn_get(
			req->args.mpls_vpn_get.unit,
			req->args.mpls_vpn_get.vpn,
			req->args.mpls_vpn_get.max_out,
			req->args.mpls_vpn_get.vpn_info,
			req->args.mpls_vpn_get.real_count);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_ID_CREATE:
		rv = bcm_mpls_vpn_id_create(
			req->args.mpls_vpn_id_create.unit,
			req->args.mpls_vpn_id_create.info);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_ID_DESTROY:
		rv = bcm_mpls_vpn_id_destroy(
			req->args.mpls_vpn_id_destroy.unit,
			req->args.mpls_vpn_id_destroy.vpn);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_ID_DESTROY_ALL:
		rv = bcm_mpls_vpn_id_destroy_all(
			req->args.mpls_vpn_id_destroy_all.unit);
		break;
	case BCM_ASYNC_ENTRY_MPLS_VPN_ID_GET:
		rv = bcm_mpls_vpn_id_get(
			req->args.mpls_vpn_id_get.unit,
			req->args.mpls_vpn_id_get.vpn,
			req->args.mpls_vpn_id_get.info);
		break;
#endif	/* INCLUDE_L3 */
	case BCM_ASYNC_ENTRY_MULTICAST_CREATE:
		rv = bcm_multicast_create(
			req->args.multicast_create.unit,
			req->args.multicast_create.flags,
			req->args.multicast_create.group);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_DESTROY:
		rv = bcm_multicast_destroy(
			req->args.multicast_destroy.unit,
			req->args.multicast_destroy.group);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_EGRESS_ADD:
		rv = bcm_multicast_egress_add(
			req->args.multicast_egress_add.unit,
			req->args.multicast_egress_add.group,
			req->args.multicast_egress_add.port,
			req->args.multicast_egress_add.encap_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_EGRESS_DELETE:
		rv = bcm_multicast_egress_delete(
			req->args.multicast_egress_delete.unit,
			req->args.multicast_egress_delete.group,
			req->args.multicast_egress_delete.port,
			req->args.multicast_egress_delete.encap_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_EGRESS_DELETE_ALL:
		rv = bcm_multicast_egress_delete_all(
			req->args.multicast_egress_delete_all.unit,
			req->args.multicast_egress_delete_all.group);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_EGRESS_GET:
		rv = bcm_multicast_egress_get(
			req->args.multicast_egress_get.unit,
			req->args.multicast_egress_get.group,
			req->args.multicast_egress_get.port_max,
			req->args.multicast_egress_get.port_array,
			req->args.multicast_egress_get.encap_id_array,
			req->args.multicast_egress_get.port_count);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_EGRESS_SET:
		rv = bcm_multicast_egress_set(
			req->args.multicast_egress_set.unit,
			req->args.multicast_egress_set.group,
			req->args.multicast_egress_set.port_count,
			req->args.multicast_egress_set.port_array,
			req->args.multicast_egress_set.encap_id_array);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_FABRIC_DISTRIBUTION_GET:
		rv = bcm_multicast_fabric_distribution_get(
			req->args.multicast_fabric_distribution_get.unit,
			req->args.multicast_fabric_distribution_get.group,
			req->args.multicast_fabric_distribution_get.ds_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_FABRIC_DISTRIBUTION_SET:
		rv = bcm_multicast_fabric_distribution_set(
			req->args.multicast_fabric_distribution_set.unit,
			req->args.multicast_fabric_distribution_set.group,
			req->args.multicast_fabric_distribution_set.ds_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_L2_ENCAP_GET:
		rv = bcm_multicast_l2_encap_get(
			req->args.multicast_l2_encap_get.unit,
			req->args.multicast_l2_encap_get.group,
			req->args.multicast_l2_encap_get.port,
			req->args.multicast_l2_encap_get.vlan,
			req->args.multicast_l2_encap_get.encap_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_L3_ENCAP_GET:
		rv = bcm_multicast_l3_encap_get(
			req->args.multicast_l3_encap_get.unit,
			req->args.multicast_l3_encap_get.group,
			req->args.multicast_l3_encap_get.port,
			req->args.multicast_l3_encap_get.intf,
			req->args.multicast_l3_encap_get.encap_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_MIM_ENCAP_GET:
		rv = bcm_multicast_mim_encap_get(
			req->args.multicast_mim_encap_get.unit,
			req->args.multicast_mim_encap_get.group,
			req->args.multicast_mim_encap_get.port,
			req->args.multicast_mim_encap_get.mim_port_id,
			req->args.multicast_mim_encap_get.encap_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_SUBPORT_ENCAP_GET:
		rv = bcm_multicast_subport_encap_get(
			req->args.multicast_subport_encap_get.unit,
			req->args.multicast_subport_encap_get.group,
			req->args.multicast_subport_encap_get.port,
			req->args.multicast_subport_encap_get.subport,
			req->args.multicast_subport_encap_get.encap_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_VPLS_ENCAP_GET:
		rv = bcm_multicast_vpls_encap_get(
			req->args.multicast_vpls_encap_get.unit,
			req->args.multicast_vpls_encap_get.group,
			req->args.multicast_vpls_encap_get.port,
			req->args.multicast_vpls_encap_get.mpls_port_id,
			req->args.multicast_vpls_encap_get.encap_id);
		break;
	case BCM_ASYNC_ENTRY_MULTICAST_WLAN_ENCAP_GET:
		rv = bcm_multicast_wlan_encap_get(
			req->args.multicast_wlan_encap_get.unit,
			req->args.multicast_wlan_encap_get.group,
			req->args.multicast_wlan_encap_get.port,
			req->args.multicast_wlan_encap_get.wlan_port_id,
			req->args.multicast_wlan_encap_get.encap_id);
		break;
	case BCM_ASYNC_ENTRY_OAM_DELAY_ADD:
		rv = bcm_oam_delay_add(
			req->args.oam_delay_add.unit,
			req->args.oam_delay_add.delay_ptr);
		break;
	case BCM_ASYNC_ENTRY_OAM_DELAY_DELETE:
		rv = bcm_oam_delay_delete(
			req->args.oam_delay_delete.unit,
			req->args.oam_delay_delete.delay_ptr);
		break;
	case BCM_ASYNC_ENTRY_OAM_DELAY_GET:
		rv = bcm_oam_delay_get(
			req->args.oam_delay_get.unit,
			req->args.oam_delay_get.delay_ptr);
		break;
	case BCM_ASYNC_ENTRY_OAM_DETACH:
		rv = bcm_oam_detach(
			req->args.oam_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_OAM_ENDPOINT_CREATE:
		rv = bcm_oam_endpoint_create(
			req->args.oam_endpoint_create.unit,
			req->args.oam_endpoint_create.endpoint_info);
		break;
	case BCM_ASYNC_ENTRY_OAM_ENDPOINT_DESTROY:
		rv = bcm_oam_endpoint_destroy(
			req->args.oam_endpoint_destroy.unit,
			req->args.oam_endpoint_destroy.endpoint);
		break;
	case BCM_ASYNC_ENTRY_OAM_ENDPOINT_DESTROY_ALL:
		rv = bcm_oam_endpoint_destroy_all(
			req->args.oam_endpoint_destroy_all.unit,
			req->args.oam_endpoint_destroy_all.group);
		break;
	case BCM_ASYNC_ENTRY_OAM_ENDPOINT_GET:
		rv = bcm_oam_endpoint_get(
			req->args.oam_endpoint_get.unit,
			req->args.oam_endpoint_get.endpoint,
			req->args.oam_endpoint_get.endpoint_info);
		break;
	case BCM_ASYNC_ENTRY_OAM_ENDPOINT_TRAVERSE:
		rv = bcm_oam_endpoint_traverse(
			req->args.oam_endpoint_traverse.unit,
			req->args.oam_endpoint_traverse.group,
			req->args.oam_endpoint_traverse.cb,
			req->args.oam_endpoint_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_OAM_EVENT_REGISTER:
		rv = bcm_oam_event_register(
			req->args.oam_event_register.unit,
			req->args.oam_event_register.event_types,
			req->args.oam_event_register.cb,
			req->args.oam_event_register.user_data);
		break;
	case BCM_ASYNC_ENTRY_OAM_EVENT_UNREGISTER:
		rv = bcm_oam_event_unregister(
			req->args.oam_event_unregister.unit,
			req->args.oam_event_unregister.event_types,
			req->args.oam_event_unregister.cb);
		break;
	case BCM_ASYNC_ENTRY_OAM_GROUP_CREATE:
		rv = bcm_oam_group_create(
			req->args.oam_group_create.unit,
			req->args.oam_group_create.group_info);
		break;
	case BCM_ASYNC_ENTRY_OAM_GROUP_DESTROY:
		rv = bcm_oam_group_destroy(
			req->args.oam_group_destroy.unit,
			req->args.oam_group_destroy.group);
		break;
	case BCM_ASYNC_ENTRY_OAM_GROUP_DESTROY_ALL:
		rv = bcm_oam_group_destroy_all(
			req->args.oam_group_destroy_all.unit);
		break;
	case BCM_ASYNC_ENTRY_OAM_GROUP_GET:
		rv = bcm_oam_group_get(
			req->args.oam_group_get.unit,
			req->args.oam_group_get.group,
			req->args.oam_group_get.group_info);
		break;
	case BCM_ASYNC_ENTRY_OAM_GROUP_TRAVERSE:
		rv = bcm_oam_group_traverse(
			req->args.oam_group_traverse.unit,
			req->args.oam_group_traverse.cb,
			req->args.oam_group_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_OAM_INIT:
		rv = bcm_oam_init(
			req->args.oam_init.unit);
		break;
	case BCM_ASYNC_ENTRY_OAM_LOSS_ADD:
		rv = bcm_oam_loss_add(
			req->args.oam_loss_add.unit,
			req->args.oam_loss_add.loss_ptr);
		break;
	case BCM_ASYNC_ENTRY_OAM_LOSS_DELETE:
		rv = bcm_oam_loss_delete(
			req->args.oam_loss_delete.unit,
			req->args.oam_loss_delete.loss_ptr);
		break;
	case BCM_ASYNC_ENTRY_OAM_LOSS_GET:
		rv = bcm_oam_loss_get(
			req->args.oam_loss_get.unit,
			req->args.oam_loss_get.loss_ptr);
		break;
	case BCM_ASYNC_ENTRY_PKT_ALLOC:
		rv = bcm_pkt_alloc(
			req->args.pkt_alloc.unit,
			req->args.pkt_alloc.size,
			req->args.pkt_alloc.flags,
			req->args.pkt_alloc.pkt_buf);
		break;
	case BCM_ASYNC_ENTRY_PKT_BLK_ALLOC:
		rv = bcm_pkt_blk_alloc(
			req->args.pkt_blk_alloc.unit,
			req->args.pkt_blk_alloc.count,
			req->args.pkt_blk_alloc.size,
			req->args.pkt_blk_alloc.flags,
			req->args.pkt_blk_alloc.packet_array);
		break;
	case BCM_ASYNC_ENTRY_PKT_BLK_FREE:
		rv = bcm_pkt_blk_free(
			req->args.pkt_blk_free.unit,
			req->args.pkt_blk_free.pkt,
			req->args.pkt_blk_free.count);
		break;
	case BCM_ASYNC_ENTRY_PKT_BYTE_INDEX:
		rv = bcm_pkt_byte_index(
			req->args.pkt_byte_index.pkt,
			req->args.pkt_byte_index.n,
			req->args.pkt_byte_index.len,
			req->args.pkt_byte_index.blk_idx,
			req->args.pkt_byte_index.location);
		break;
	case BCM_ASYNC_ENTRY_PKT_CLEAR:
		rv = bcm_pkt_clear(
			req->args.pkt_clear.unit,
			req->args.pkt_clear.pkt,
			req->args.pkt_clear.blks,
			req->args.pkt_clear.blk_count,
			req->args.pkt_clear.flags,
			req->args.pkt_clear.pkt_buf);
		break;
	case BCM_ASYNC_ENTRY_PKT_FLAGS_INIT:
		rv = bcm_pkt_flags_init(
			req->args.pkt_flags_init.unit,
			req->args.pkt_flags_init.pkt,
			req->args.pkt_flags_init.init_flags);
		break;
	case BCM_ASYNC_ENTRY_PKT_FLAGS_LEN_SETUP:
		rv = bcm_pkt_flags_len_setup(
			req->args.pkt_flags_len_setup.unit,
			req->args.pkt_flags_len_setup.pkt,
			req->args.pkt_flags_len_setup.alloc_bytes,
			req->args.pkt_flags_len_setup.payload_len,
			req->args.pkt_flags_len_setup.flags);
		break;
	case BCM_ASYNC_ENTRY_PKT_FREE:
		rv = bcm_pkt_free(
			req->args.pkt_free.unit,
			req->args.pkt_free.pkt);
		break;
	case BCM_ASYNC_ENTRY_PKT_MEMCPY:
		rv = bcm_pkt_memcpy(
			req->args.pkt_memcpy.pkt,
			req->args.pkt_memcpy.dest_byte,
			req->args.pkt_memcpy.src,
			req->args.pkt_memcpy.len);
		break;
	case BCM_ASYNC_ENTRY_PKT_RX_ALLOC:
		rv = bcm_pkt_rx_alloc(
			req->args.pkt_rx_alloc.unit,
			req->args.pkt_rx_alloc.len,
			req->args.pkt_rx_alloc.pkt_buf);
		break;
	case BCM_ASYNC_ENTRY_PKT_RX_FREE:
		rv = bcm_pkt_rx_free(
			req->args.pkt_rx_free.unit,
			req->args.pkt_rx_free.pkt);
		break;
	case BCM_ASYNC_ENTRY_POLICER_CREATE:
		rv = bcm_policer_create(
			req->args.policer_create.unit,
			req->args.policer_create.pol_cfg,
			req->args.policer_create.policer_id);
		break;
	case BCM_ASYNC_ENTRY_POLICER_DESTROY:
		rv = bcm_policer_destroy(
			req->args.policer_destroy.unit,
			req->args.policer_destroy.policer_id);
		break;
	case BCM_ASYNC_ENTRY_POLICER_DESTROY_ALL:
		rv = bcm_policer_destroy_all(
			req->args.policer_destroy_all.unit);
		break;
	case BCM_ASYNC_ENTRY_POLICER_GET:
		rv = bcm_policer_get(
			req->args.policer_get.unit,
			req->args.policer_get.policer_id,
			req->args.policer_get.pol_cfg);
		break;
	case BCM_ASYNC_ENTRY_POLICER_GROUP_CREATE:
		rv = bcm_policer_group_create(
			req->args.policer_group_create.unit,
			req->args.policer_group_create.mode,
			req->args.policer_group_create.policer_id,
			req->args.policer_group_create.npolicers);
		break;
	case BCM_ASYNC_ENTRY_POLICER_INIT:
		rv = bcm_policer_init(
			req->args.policer_init.unit);
		break;
	case BCM_ASYNC_ENTRY_POLICER_SET:
		rv = bcm_policer_set(
			req->args.policer_set.unit,
			req->args.policer_set.policer_id,
			req->args.policer_set.pol_cfg);
		break;
	case BCM_ASYNC_ENTRY_POLICER_STAT_ENABLE_GET:
		rv = bcm_policer_stat_enable_get(
			req->args.policer_stat_enable_get.unit,
			req->args.policer_stat_enable_get.policer_id,
			req->args.policer_stat_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_POLICER_STAT_ENABLE_SET:
		rv = bcm_policer_stat_enable_set(
			req->args.policer_stat_enable_set.unit,
			req->args.policer_stat_enable_set.policer_id,
			req->args.policer_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_POLICER_STAT_GET:
		rv = bcm_policer_stat_get(
			req->args.policer_stat_get.unit,
			req->args.policer_stat_get.policer_id,
			req->args.policer_stat_get.int_pri,
			req->args.policer_stat_get.stat,
			req->args.policer_stat_get.value);
		break;
	case BCM_ASYNC_ENTRY_POLICER_STAT_GET32:
		rv = bcm_policer_stat_get32(
			req->args.policer_stat_get32.unit,
			req->args.policer_stat_get32.policer_id,
			req->args.policer_stat_get32.int_pri,
			req->args.policer_stat_get32.stat,
			req->args.policer_stat_get32.value);
		break;
	case BCM_ASYNC_ENTRY_POLICER_STAT_SET:
		rv = bcm_policer_stat_set(
			req->args.policer_stat_set.unit,
			req->args.policer_stat_set.policer_id,
			req->args.policer_stat_set.int_pri,
			req->args.policer_stat_set.stat,
			req->args.policer_stat_set.value);
		break;
	case BCM_ASYNC_ENTRY_POLICER_STAT_SET32:
		rv = bcm_policer_stat_set32(
			req->args.policer_stat_set32.unit,
			req->args.policer_stat_set32.policer_id,
			req->args.policer_stat_set32.int_pri,
			req->args.policer_stat_set32.stat,
			req->args.policer_stat_set32.value);
		break;
	case BCM_ASYNC_ENTRY_POLICER_TRAVERSE:
		rv = bcm_policer_traverse(
			req->args.policer_traverse.unit,
			req->args.policer_traverse.cb,
			req->args.policer_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_PORT_ABILITY_ADVERT_GET:
		rv = bcm_port_ability_advert_get(
			req->args.port_ability_advert_get.unit,
			req->args.port_ability_advert_get.port,
			req->args.port_ability_advert_get.ability_mask);
		break;
	case BCM_ASYNC_ENTRY_PORT_ABILITY_ADVERT_SET:
		rv = bcm_port_ability_advert_set(
			req->args.port_ability_advert_set.unit,
			req->args.port_ability_advert_set.port,
			req->args.port_ability_advert_set.ability_mask);
		break;
	case BCM_ASYNC_ENTRY_PORT_ABILITY_GET:
		rv = bcm_port_ability_get(
			req->args.port_ability_get.unit,
			req->args.port_ability_get.port,
			req->args.port_ability_get.local_ability_mask);
		break;
	case BCM_ASYNC_ENTRY_PORT_ABILITY_LOCAL_GET:
		rv = bcm_port_ability_local_get(
			req->args.port_ability_local_get.unit,
			req->args.port_ability_local_get.port,
			req->args.port_ability_local_get.local_ability_mask);
		break;
	case BCM_ASYNC_ENTRY_PORT_ABILITY_REMOTE_GET:
		rv = bcm_port_ability_remote_get(
			req->args.port_ability_remote_get.unit,
			req->args.port_ability_remote_get.port,
			req->args.port_ability_remote_get.ability_mask);
		break;
	case BCM_ASYNC_ENTRY_PORT_ADVERT_GET:
		rv = bcm_port_advert_get(
			req->args.port_advert_get.unit,
			req->args.port_advert_get.port,
			req->args.port_advert_get.ability_mask);
		break;
	case BCM_ASYNC_ENTRY_PORT_ADVERT_REMOTE_GET:
		rv = bcm_port_advert_remote_get(
			req->args.port_advert_remote_get.unit,
			req->args.port_advert_remote_get.port,
			req->args.port_advert_remote_get.ability_mask);
		break;
	case BCM_ASYNC_ENTRY_PORT_ADVERT_SET:
		rv = bcm_port_advert_set(
			req->args.port_advert_set.unit,
			req->args.port_advert_set.port,
			req->args.port_advert_set.ability_mask);
		break;
	case BCM_ASYNC_ENTRY_PORT_AUTONEG_GET:
		rv = bcm_port_autoneg_get(
			req->args.port_autoneg_get.unit,
			req->args.port_autoneg_get.port,
			req->args.port_autoneg_get.autoneg);
		break;
	case BCM_ASYNC_ENTRY_PORT_AUTONEG_SET:
		rv = bcm_port_autoneg_set(
			req->args.port_autoneg_set.unit,
			req->args.port_autoneg_set.port,
			req->args.port_autoneg_set.autoneg);
		break;
	case BCM_ASYNC_ENTRY_PORT_BPDU_ENABLE_GET:
		rv = bcm_port_bpdu_enable_get(
			req->args.port_bpdu_enable_get.unit,
			req->args.port_bpdu_enable_get.port,
			req->args.port_bpdu_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_BPDU_ENABLE_SET:
		rv = bcm_port_bpdu_enable_set(
			req->args.port_bpdu_enable_set.unit,
			req->args.port_bpdu_enable_set.port,
			req->args.port_bpdu_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_CABLE_DIAG:
		rv = bcm_port_cable_diag(
			req->args.port_cable_diag.unit,
			req->args.port_cable_diag.port,
			req->args.port_cable_diag.status);
		break;
	case BCM_ASYNC_ENTRY_PORT_CFI_COLOR_GET:
		rv = bcm_port_cfi_color_get(
			req->args.port_cfi_color_get.unit,
			req->args.port_cfi_color_get.port,
			req->args.port_cfi_color_get.cfi,
			req->args.port_cfi_color_get.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_CFI_COLOR_SET:
		rv = bcm_port_cfi_color_set(
			req->args.port_cfi_color_set.unit,
			req->args.port_cfi_color_set.port,
			req->args.port_cfi_color_set.cfi,
			req->args.port_cfi_color_set.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_CLASS_GET:
		rv = bcm_port_class_get(
			req->args.port_class_get.unit,
			req->args.port_class_get.port,
			req->args.port_class_get.pclass,
			req->args.port_class_get.class_id);
		break;
	case BCM_ASYNC_ENTRY_PORT_CLASS_SET:
		rv = bcm_port_class_set(
			req->args.port_class_set.unit,
			req->args.port_class_set.port,
			req->args.port_class_set.pclass,
			req->args.port_class_set.class_id);
		break;
	case BCM_ASYNC_ENTRY_PORT_CLEAR:
		rv = bcm_port_clear(
			req->args.port_clear.unit);
		break;
	case BCM_ASYNC_ENTRY_PORT_CONFIG_GET:
		rv = bcm_port_config_get(
			req->args.port_config_get.unit,
			req->args.port_config_get.config);
		break;
	case BCM_ASYNC_ENTRY_PORT_CONGESTION_CONFIG_GET:
		rv = bcm_port_congestion_config_get(
			req->args.port_congestion_config_get.unit,
			req->args.port_congestion_config_get.port,
			req->args.port_congestion_config_get.config);
		break;
	case BCM_ASYNC_ENTRY_PORT_CONGESTION_CONFIG_SET:
		rv = bcm_port_congestion_config_set(
			req->args.port_congestion_config_set.unit,
			req->args.port_congestion_config_set.port,
			req->args.port_congestion_config_set.config);
		break;
	case BCM_ASYNC_ENTRY_PORT_CONTROL_GET:
		rv = bcm_port_control_get(
			req->args.port_control_get.unit,
			req->args.port_control_get.port,
			req->args.port_control_get.type,
			req->args.port_control_get.value);
		break;
	case BCM_ASYNC_ENTRY_PORT_CONTROL_SET:
		rv = bcm_port_control_set(
			req->args.port_control_set.unit,
			req->args.port_control_set.port,
			req->args.port_control_set.type,
			req->args.port_control_set.value);
		break;
	case BCM_ASYNC_ENTRY_PORT_DETACH:
		rv = bcm_port_detach(
			req->args.port_detach.unit,
			req->args.port_detach.pbmp,
			req->args.port_detach.detached);
		break;
	case BCM_ASYNC_ENTRY_PORT_DISCARD_GET:
		rv = bcm_port_discard_get(
			req->args.port_discard_get.unit,
			req->args.port_discard_get.port,
			req->args.port_discard_get.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_DISCARD_SET:
		rv = bcm_port_discard_set(
			req->args.port_discard_set.unit,
			req->args.port_discard_set.port,
			req->args.port_discard_set.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_DSCP_MAP_GET:
		rv = bcm_port_dscp_map_get(
			req->args.port_dscp_map_get.unit,
			req->args.port_dscp_map_get.port,
			req->args.port_dscp_map_get.srccp,
			req->args.port_dscp_map_get.mapcp,
			req->args.port_dscp_map_get.prio);
		break;
	case BCM_ASYNC_ENTRY_PORT_DSCP_MAP_MODE_GET:
		rv = bcm_port_dscp_map_mode_get(
			req->args.port_dscp_map_mode_get.unit,
			req->args.port_dscp_map_mode_get.port,
			req->args.port_dscp_map_mode_get.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_DSCP_MAP_MODE_SET:
		rv = bcm_port_dscp_map_mode_set(
			req->args.port_dscp_map_mode_set.unit,
			req->args.port_dscp_map_mode_set.port,
			req->args.port_dscp_map_mode_set.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_DSCP_MAP_SET:
		rv = bcm_port_dscp_map_set(
			req->args.port_dscp_map_set.unit,
			req->args.port_dscp_map_set.port,
			req->args.port_dscp_map_set.srccp,
			req->args.port_dscp_map_set.mapcp,
			req->args.port_dscp_map_set.prio);
		break;
	case BCM_ASYNC_ENTRY_PORT_DSCP_UNMAP_GET:
		rv = bcm_port_dscp_unmap_get(
			req->args.port_dscp_unmap_get.unit,
			req->args.port_dscp_unmap_get.port,
			req->args.port_dscp_unmap_get.internal_pri,
			req->args.port_dscp_unmap_get.color,
			req->args.port_dscp_unmap_get.pkt_dscp);
		break;
	case BCM_ASYNC_ENTRY_PORT_DSCP_UNMAP_SET:
		rv = bcm_port_dscp_unmap_set(
			req->args.port_dscp_unmap_set.unit,
			req->args.port_dscp_unmap_set.port,
			req->args.port_dscp_unmap_set.internal_pri,
			req->args.port_dscp_unmap_set.color,
			req->args.port_dscp_unmap_set.pkt_dscp);
		break;
	case BCM_ASYNC_ENTRY_PORT_DTAG_MODE_GET:
		rv = bcm_port_dtag_mode_get(
			req->args.port_dtag_mode_get.unit,
			req->args.port_dtag_mode_get.port,
			req->args.port_dtag_mode_get.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_DTAG_MODE_SET:
		rv = bcm_port_dtag_mode_set(
			req->args.port_dtag_mode_set.unit,
			req->args.port_dtag_mode_set.port,
			req->args.port_dtag_mode_set.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_DUPLEX_GET:
		rv = bcm_port_duplex_get(
			req->args.port_duplex_get.unit,
			req->args.port_duplex_get.port,
			req->args.port_duplex_get.duplex);
		break;
	case BCM_ASYNC_ENTRY_PORT_DUPLEX_SET:
		rv = bcm_port_duplex_set(
			req->args.port_duplex_set.unit,
			req->args.port_duplex_set.port,
			req->args.port_duplex_set.duplex);
		break;
	case BCM_ASYNC_ENTRY_PORT_EGRESS_GET:
		rv = bcm_port_egress_get(
			req->args.port_egress_get.unit,
			req->args.port_egress_get.port,
			req->args.port_egress_get.modid,
			req->args.port_egress_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_PORT_EGRESS_SET:
		rv = bcm_port_egress_set(
			req->args.port_egress_set.unit,
			req->args.port_egress_set.port,
			req->args.port_egress_set.modid,
			req->args.port_egress_set.pbmp);
		break;
	case BCM_ASYNC_ENTRY_PORT_ENABLE_GET:
		rv = bcm_port_enable_get(
			req->args.port_enable_get.unit,
			req->args.port_enable_get.port,
			req->args.port_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_ENABLE_SET:
		rv = bcm_port_enable_set(
			req->args.port_enable_set.unit,
			req->args.port_enable_set.port,
			req->args.port_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_ENCAP_CONFIG_GET:
		rv = bcm_port_encap_config_get(
			req->args.port_encap_config_get.unit,
			req->args.port_encap_config_get.gport,
			req->args.port_encap_config_get.encap_config);
		break;
	case BCM_ASYNC_ENTRY_PORT_ENCAP_CONFIG_SET:
		rv = bcm_port_encap_config_set(
			req->args.port_encap_config_set.unit,
			req->args.port_encap_config_set.gport,
			req->args.port_encap_config_set.encap_config);
		break;
	case BCM_ASYNC_ENTRY_PORT_ENCAP_GET:
		rv = bcm_port_encap_get(
			req->args.port_encap_get.unit,
			req->args.port_encap_get.port,
			req->args.port_encap_get.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_ENCAP_SET:
		rv = bcm_port_encap_set(
			req->args.port_encap_set.unit,
			req->args.port_encap_set.port,
			req->args.port_encap_set.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_FAULT_GET:
		rv = bcm_port_fault_get(
			req->args.port_fault_get.unit,
			req->args.port_fault_get.port,
			req->args.port_fault_get.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_FLOOD_BLOCK_GET:
		rv = bcm_port_flood_block_get(
			req->args.port_flood_block_get.unit,
			req->args.port_flood_block_get.ingress_port,
			req->args.port_flood_block_get.egress_port,
			req->args.port_flood_block_get.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_FLOOD_BLOCK_SET:
		rv = bcm_port_flood_block_set(
			req->args.port_flood_block_set.unit,
			req->args.port_flood_block_set.ingress_port,
			req->args.port_flood_block_set.egress_port,
			req->args.port_flood_block_set.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_FORCE_FORWARD_GET:
		rv = bcm_port_force_forward_get(
			req->args.port_force_forward_get.unit,
			req->args.port_force_forward_get.port,
			req->args.port_force_forward_get.egr_port,
			req->args.port_force_forward_get.enabled);
		break;
	case BCM_ASYNC_ENTRY_PORT_FORCE_FORWARD_SET:
		rv = bcm_port_force_forward_set(
			req->args.port_force_forward_set.unit,
			req->args.port_force_forward_set.port,
			req->args.port_force_forward_set.egr_port,
			req->args.port_force_forward_set.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_FORCE_VLAN_GET:
		rv = bcm_port_force_vlan_get(
			req->args.port_force_vlan_get.unit,
			req->args.port_force_vlan_get.port,
			req->args.port_force_vlan_get.vlan,
			req->args.port_force_vlan_get.pkt_prio,
			req->args.port_force_vlan_get.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_FORCE_VLAN_SET:
		rv = bcm_port_force_vlan_set(
			req->args.port_force_vlan_set.unit,
			req->args.port_force_vlan_set.port,
			req->args.port_force_vlan_set.vlan,
			req->args.port_force_vlan_set.pkt_prio,
			req->args.port_force_vlan_set.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_FRAME_MAX_GET:
		rv = bcm_port_frame_max_get(
			req->args.port_frame_max_get.unit,
			req->args.port_frame_max_get.port,
			req->args.port_frame_max_get.size);
		break;
	case BCM_ASYNC_ENTRY_PORT_FRAME_MAX_SET:
		rv = bcm_port_frame_max_set(
			req->args.port_frame_max_set.unit,
			req->args.port_frame_max_set.port,
			req->args.port_frame_max_set.size);
		break;
	case BCM_ASYNC_ENTRY_PORT_GPORT_GET:
		rv = bcm_port_gport_get(
			req->args.port_gport_get.unit,
			req->args.port_gport_get.port,
			req->args.port_gport_get.gport);
		break;
	case BCM_ASYNC_ENTRY_PORT_IFG_GET:
		rv = bcm_port_ifg_get(
			req->args.port_ifg_get.unit,
			req->args.port_ifg_get.port,
			req->args.port_ifg_get.speed,
			req->args.port_ifg_get.duplex,
			req->args.port_ifg_get.bit_times);
		break;
	case BCM_ASYNC_ENTRY_PORT_IFG_SET:
		rv = bcm_port_ifg_set(
			req->args.port_ifg_set.unit,
			req->args.port_ifg_set.port,
			req->args.port_ifg_set.speed,
			req->args.port_ifg_set.duplex,
			req->args.port_ifg_set.bit_times);
		break;
	case BCM_ASYNC_ENTRY_PORT_IFILTER_GET:
		rv = bcm_port_ifilter_get(
			req->args.port_ifilter_get.unit,
			req->args.port_ifilter_get.port,
			req->args.port_ifilter_get.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_IFILTER_SET:
		rv = bcm_port_ifilter_set(
			req->args.port_ifilter_set.unit,
			req->args.port_ifilter_set.port,
			req->args.port_ifilter_set.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_INFO_GET:
		rv = bcm_port_info_get(
			req->args.port_info_get.unit,
			req->args.port_info_get.port,
			req->args.port_info_get.info);
		break;
	case BCM_ASYNC_ENTRY_PORT_INFO_RESTORE:
		rv = bcm_port_info_restore(
			req->args.port_info_restore.unit,
			req->args.port_info_restore.port,
			req->args.port_info_restore.info);
		break;
	case BCM_ASYNC_ENTRY_PORT_INFO_SAVE:
		rv = bcm_port_info_save(
			req->args.port_info_save.unit,
			req->args.port_info_save.port,
			req->args.port_info_save.info);
		break;
	case BCM_ASYNC_ENTRY_PORT_INFO_SET:
		rv = bcm_port_info_set(
			req->args.port_info_set.unit,
			req->args.port_info_set.port,
			req->args.port_info_set.info);
		break;
	case BCM_ASYNC_ENTRY_PORT_INIT:
		rv = bcm_port_init(
			req->args.port_init.unit);
		break;
	case BCM_ASYNC_ENTRY_PORT_INNER_TPID_GET:
		rv = bcm_port_inner_tpid_get(
			req->args.port_inner_tpid_get.unit,
			req->args.port_inner_tpid_get.port,
			req->args.port_inner_tpid_get.tpid);
		break;
	case BCM_ASYNC_ENTRY_PORT_INNER_TPID_SET:
		rv = bcm_port_inner_tpid_set(
			req->args.port_inner_tpid_set.unit,
			req->args.port_inner_tpid_set.port,
			req->args.port_inner_tpid_set.tpid);
		break;
	case BCM_ASYNC_ENTRY_PORT_INTERFACE_GET:
		rv = bcm_port_interface_get(
			req->args.port_interface_get.unit,
			req->args.port_interface_get.port,
			req->args.port_interface_get.intf);
		break;
	case BCM_ASYNC_ENTRY_PORT_INTERFACE_SET:
		rv = bcm_port_interface_set(
			req->args.port_interface_set.unit,
			req->args.port_interface_set.port,
			req->args.port_interface_set.intf);
		break;
	case BCM_ASYNC_ENTRY_PORT_IPMC_MODIFY_GET:
		rv = bcm_port_ipmc_modify_get(
			req->args.port_ipmc_modify_get.unit,
			req->args.port_ipmc_modify_get.port,
			req->args.port_ipmc_modify_get.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_IPMC_MODIFY_SET:
		rv = bcm_port_ipmc_modify_set(
			req->args.port_ipmc_modify_set.unit,
			req->args.port_ipmc_modify_set.port,
			req->args.port_ipmc_modify_set.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_JAM_GET:
		rv = bcm_port_jam_get(
			req->args.port_jam_get.unit,
			req->args.port_jam_get.port,
			req->args.port_jam_get.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_JAM_SET:
		rv = bcm_port_jam_set(
			req->args.port_jam_set.unit,
			req->args.port_jam_set.port,
			req->args.port_jam_set.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_L3_ENABLE_GET:
		rv = bcm_port_l3_enable_get(
			req->args.port_l3_enable_get.unit,
			req->args.port_l3_enable_get.port,
			req->args.port_l3_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_L3_ENABLE_SET:
		rv = bcm_port_l3_enable_set(
			req->args.port_l3_enable_set.unit,
			req->args.port_l3_enable_set.port,
			req->args.port_l3_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_L3_MODIFY_GET:
		rv = bcm_port_l3_modify_get(
			req->args.port_l3_modify_get.unit,
			req->args.port_l3_modify_get.port,
			req->args.port_l3_modify_get.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_L3_MODIFY_SET:
		rv = bcm_port_l3_modify_set(
			req->args.port_l3_modify_set.unit,
			req->args.port_l3_modify_set.port,
			req->args.port_l3_modify_set.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_L3_MTU_GET:
		rv = bcm_port_l3_mtu_get(
			req->args.port_l3_mtu_get.unit,
			req->args.port_l3_mtu_get.port,
			req->args.port_l3_mtu_get.size);
		break;
	case BCM_ASYNC_ENTRY_PORT_L3_MTU_SET:
		rv = bcm_port_l3_mtu_set(
			req->args.port_l3_mtu_set.unit,
			req->args.port_l3_mtu_set.port,
			req->args.port_l3_mtu_set.size);
		break;
	case BCM_ASYNC_ENTRY_PORT_LEARN_GET:
		rv = bcm_port_learn_get(
			req->args.port_learn_get.unit,
			req->args.port_learn_get.port,
			req->args.port_learn_get.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_LEARN_MODIFY:
		rv = bcm_port_learn_modify(
			req->args.port_learn_modify.unit,
			req->args.port_learn_modify.port,
			req->args.port_learn_modify.add,
			req->args.port_learn_modify.remove);
		break;
	case BCM_ASYNC_ENTRY_PORT_LEARN_SET:
		rv = bcm_port_learn_set(
			req->args.port_learn_set.unit,
			req->args.port_learn_set.port,
			req->args.port_learn_set.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_LINK_FAILED_CLEAR:
		rv = bcm_port_link_failed_clear(
			req->args.port_link_failed_clear.unit,
			req->args.port_link_failed_clear.port);
		break;
	case BCM_ASYNC_ENTRY_PORT_LINK_STATUS_GET:
		rv = bcm_port_link_status_get(
			req->args.port_link_status_get.unit,
			req->args.port_link_status_get.port,
			req->args.port_link_status_get.status);
		break;
	case BCM_ASYNC_ENTRY_PORT_LINKSCAN_GET:
		rv = bcm_port_linkscan_get(
			req->args.port_linkscan_get.unit,
			req->args.port_linkscan_get.port,
			req->args.port_linkscan_get.linkscan);
		break;
	case BCM_ASYNC_ENTRY_PORT_LINKSCAN_SET:
		rv = bcm_port_linkscan_set(
			req->args.port_linkscan_set.unit,
			req->args.port_linkscan_set.port,
			req->args.port_linkscan_set.linkscan);
		break;
	case BCM_ASYNC_ENTRY_PORT_LOCAL_GET:
		rv = bcm_port_local_get(
			req->args.port_local_get.unit,
			req->args.port_local_get.gport,
			req->args.port_local_get.local_port);
		break;
	case BCM_ASYNC_ENTRY_PORT_LOOPBACK_GET:
		rv = bcm_port_loopback_get(
			req->args.port_loopback_get.unit,
			req->args.port_loopback_get.port,
			req->args.port_loopback_get.loopback);
		break;
	case BCM_ASYNC_ENTRY_PORT_LOOPBACK_SET:
		rv = bcm_port_loopback_set(
			req->args.port_loopback_set.unit,
			req->args.port_loopback_set.port,
			req->args.port_loopback_set.loopback);
		break;
	case BCM_ASYNC_ENTRY_PORT_MASTER_GET:
		rv = bcm_port_master_get(
			req->args.port_master_get.unit,
			req->args.port_master_get.port,
			req->args.port_master_get.ms);
		break;
	case BCM_ASYNC_ENTRY_PORT_MASTER_SET:
		rv = bcm_port_master_set(
			req->args.port_master_set.unit,
			req->args.port_master_set.port,
			req->args.port_master_set.ms);
		break;
	case BCM_ASYNC_ENTRY_PORT_MDIX_GET:
		rv = bcm_port_mdix_get(
			req->args.port_mdix_get.unit,
			req->args.port_mdix_get.port,
			req->args.port_mdix_get.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_MDIX_SET:
		rv = bcm_port_mdix_set(
			req->args.port_mdix_set.unit,
			req->args.port_mdix_set.port,
			req->args.port_mdix_set.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_MDIX_STATUS_GET:
		rv = bcm_port_mdix_status_get(
			req->args.port_mdix_status_get.unit,
			req->args.port_mdix_status_get.port,
			req->args.port_mdix_status_get.status);
		break;
	case BCM_ASYNC_ENTRY_PORT_MEDIUM_CONFIG_GET:
		rv = bcm_port_medium_config_get(
			req->args.port_medium_config_get.unit,
			req->args.port_medium_config_get.port,
			req->args.port_medium_config_get.medium,
			req->args.port_medium_config_get.config);
		break;
	case BCM_ASYNC_ENTRY_PORT_MEDIUM_CONFIG_SET:
		rv = bcm_port_medium_config_set(
			req->args.port_medium_config_set.unit,
			req->args.port_medium_config_set.port,
			req->args.port_medium_config_set.medium,
			req->args.port_medium_config_set.config);
		break;
	case BCM_ASYNC_ENTRY_PORT_MEDIUM_GET:
		rv = bcm_port_medium_get(
			req->args.port_medium_get.unit,
			req->args.port_medium_get.port,
			req->args.port_medium_get.medium);
		break;
	case BCM_ASYNC_ENTRY_PORT_MEDIUM_STATUS_REGISTER:
		rv = bcm_port_medium_status_register(
			req->args.port_medium_status_register.unit,
			req->args.port_medium_status_register.port,
			req->args.port_medium_status_register.callback,
			req->args.port_medium_status_register.user_data);
		break;
	case BCM_ASYNC_ENTRY_PORT_MEDIUM_STATUS_UNREGISTER:
		rv = bcm_port_medium_status_unregister(
			req->args.port_medium_status_unregister.unit,
			req->args.port_medium_status_unregister.port,
			req->args.port_medium_status_unregister.callback,
			req->args.port_medium_status_unregister.user_data);
		break;
	case BCM_ASYNC_ENTRY_PORT_MODID_EGRESS_GET:
		rv = bcm_port_modid_egress_get(
			req->args.port_modid_egress_get.unit,
			req->args.port_modid_egress_get.port,
			req->args.port_modid_egress_get.modid,
			req->args.port_modid_egress_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_PORT_MODID_EGRESS_SET:
		rv = bcm_port_modid_egress_set(
			req->args.port_modid_egress_set.unit,
			req->args.port_modid_egress_set.port,
			req->args.port_modid_egress_set.modid,
			req->args.port_modid_egress_set.pbmp);
		break;
	case BCM_ASYNC_ENTRY_PORT_MODID_ENABLE_GET:
		rv = bcm_port_modid_enable_get(
			req->args.port_modid_enable_get.unit,
			req->args.port_modid_enable_get.port,
			req->args.port_modid_enable_get.modid,
			req->args.port_modid_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_MODID_ENABLE_SET:
		rv = bcm_port_modid_enable_set(
			req->args.port_modid_enable_set.unit,
			req->args.port_modid_enable_set.port,
			req->args.port_modid_enable_set.modid,
			req->args.port_modid_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_PAUSE_ADDR_GET:
		rv = bcm_port_pause_addr_get(
			req->args.port_pause_addr_get.unit,
			req->args.port_pause_addr_get.port,
			req->args.port_pause_addr_get.mac);
		break;
	case BCM_ASYNC_ENTRY_PORT_PAUSE_ADDR_SET:
		rv = bcm_port_pause_addr_set(
			req->args.port_pause_addr_set.unit,
			req->args.port_pause_addr_set.port,
			req->args.port_pause_addr_set.mac);
		break;
	case BCM_ASYNC_ENTRY_PORT_PAUSE_GET:
		rv = bcm_port_pause_get(
			req->args.port_pause_get.unit,
			req->args.port_pause_get.port,
			req->args.port_pause_get.pause_tx,
			req->args.port_pause_get.pause_rx);
		break;
	case BCM_ASYNC_ENTRY_PORT_PAUSE_SET:
		rv = bcm_port_pause_set(
			req->args.port_pause_set.unit,
			req->args.port_pause_set.port,
			req->args.port_pause_set.pause_tx,
			req->args.port_pause_set.pause_rx);
		break;
	case BCM_ASYNC_ENTRY_PORT_PAUSE_SYM_GET:
		rv = bcm_port_pause_sym_get(
			req->args.port_pause_sym_get.unit,
			req->args.port_pause_sym_get.port,
			req->args.port_pause_sym_get.pause);
		break;
	case BCM_ASYNC_ENTRY_PORT_PAUSE_SYM_SET:
		rv = bcm_port_pause_sym_set(
			req->args.port_pause_sym_set.unit,
			req->args.port_pause_sym_set.port,
			req->args.port_pause_sym_set.pause);
		break;
	case BCM_ASYNC_ENTRY_PORT_PFM_GET:
		rv = bcm_port_pfm_get(
			req->args.port_pfm_get.unit,
			req->args.port_pfm_get.port,
			req->args.port_pfm_get.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_PFM_SET:
		rv = bcm_port_pfm_set(
			req->args.port_pfm_set.unit,
			req->args.port_pfm_set.port,
			req->args.port_pfm_set.mode);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_CONTROL_GET:
		rv = bcm_port_phy_control_get(
			req->args.port_phy_control_get.unit,
			req->args.port_phy_control_get.port,
			req->args.port_phy_control_get.type,
			req->args.port_phy_control_get.value);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_CONTROL_SET:
		rv = bcm_port_phy_control_set(
			req->args.port_phy_control_set.unit,
			req->args.port_phy_control_set.port,
			req->args.port_phy_control_set.type,
			req->args.port_phy_control_set.value);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_DRV_NAME_GET:
		rv = bcm_port_phy_drv_name_get(
			req->args.port_phy_drv_name_get.unit,
			req->args.port_phy_drv_name_get.port,
			req->args.port_phy_drv_name_get.name,
			req->args.port_phy_drv_name_get.len);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_FIRMWARE_SET:
		rv = bcm_port_phy_firmware_set(
			req->args.port_phy_firmware_set.unit,
			req->args.port_phy_firmware_set.port,
			req->args.port_phy_firmware_set.flags,
			req->args.port_phy_firmware_set.offset,
			req->args.port_phy_firmware_set.array,
			req->args.port_phy_firmware_set.length);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_GET:
		rv = bcm_port_phy_get(
			req->args.port_phy_get.unit,
			req->args.port_phy_get.port,
			req->args.port_phy_get.flags,
			req->args.port_phy_get.phy_reg_addr,
			req->args.port_phy_get.phy_data);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_RESET:
		rv = bcm_port_phy_reset(
			req->args.port_phy_reset.unit,
			req->args.port_phy_reset.port);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_RESET_REGISTER:
		rv = bcm_port_phy_reset_register(
			req->args.port_phy_reset_register.unit,
			req->args.port_phy_reset_register.port,
			req->args.port_phy_reset_register.callback,
			req->args.port_phy_reset_register.user_data);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_RESET_UNREGISTER:
		rv = bcm_port_phy_reset_unregister(
			req->args.port_phy_reset_unregister.unit,
			req->args.port_phy_reset_unregister.port,
			req->args.port_phy_reset_unregister.callback,
			req->args.port_phy_reset_unregister.user_data);
		break;
	case BCM_ASYNC_ENTRY_PORT_PHY_SET:
		rv = bcm_port_phy_set(
			req->args.port_phy_set.unit,
			req->args.port_phy_set.port,
			req->args.port_phy_set.flags,
			req->args.port_phy_set.phy_reg_addr,
			req->args.port_phy_set.phy_data);
		break;
	case BCM_ASYNC_ENTRY_PORT_POLICER_GET:
		rv = bcm_port_policer_get(
			req->args.port_policer_get.unit,
			req->args.port_policer_get.port,
			req->args.port_policer_get.policer_id);
		break;
	case BCM_ASYNC_ENTRY_PORT_POLICER_SET:
		rv = bcm_port_policer_set(
			req->args.port_policer_set.unit,
			req->args.port_policer_set.port,
			req->args.port_policer_set.policer_id);
		break;
	case BCM_ASYNC_ENTRY_PORT_PRIORITY_COLOR_GET:
		rv = bcm_port_priority_color_get(
			req->args.port_priority_color_get.unit,
			req->args.port_priority_color_get.port,
			req->args.port_priority_color_get.prio,
			req->args.port_priority_color_get.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_PRIORITY_COLOR_SET:
		rv = bcm_port_priority_color_set(
			req->args.port_priority_color_set.unit,
			req->args.port_priority_color_set.port,
			req->args.port_priority_color_set.prio,
			req->args.port_priority_color_set.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_PROBE:
		rv = bcm_port_probe(
			req->args.port_probe.unit,
			req->args.port_probe.pbmp,
			req->args.port_probe.okay_pbmp);
		break;
	case BCM_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_ADD:
		rv = bcm_port_protocol_vlan_add(
			req->args.port_protocol_vlan_add.unit,
			req->args.port_protocol_vlan_add.port,
			req->args.port_protocol_vlan_add.frame,
			req->args.port_protocol_vlan_add.ether,
			req->args.port_protocol_vlan_add.vid);
		break;
	case BCM_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_DELETE:
		rv = bcm_port_protocol_vlan_delete(
			req->args.port_protocol_vlan_delete.unit,
			req->args.port_protocol_vlan_delete.port,
			req->args.port_protocol_vlan_delete.frame,
			req->args.port_protocol_vlan_delete.ether);
		break;
	case BCM_ASYNC_ENTRY_PORT_PROTOCOL_VLAN_DELETE_ALL:
		rv = bcm_port_protocol_vlan_delete_all(
			req->args.port_protocol_vlan_delete_all.unit,
			req->args.port_protocol_vlan_delete_all.port);
		break;
	case BCM_ASYNC_ENTRY_PORT_QUEUED_COUNT_GET:
		rv = bcm_port_queued_count_get(
			req->args.port_queued_count_get.unit,
			req->args.port_queued_count_get.port,
			req->args.port_queued_count_get.count);
		break;
	case BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_GET:
		rv = bcm_port_rate_egress_get(
			req->args.port_rate_egress_get.unit,
			req->args.port_rate_egress_get.port,
			req->args.port_rate_egress_get.kbits_sec,
			req->args.port_rate_egress_get.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_SET:
		rv = bcm_port_rate_egress_set(
			req->args.port_rate_egress_set.unit,
			req->args.port_rate_egress_set.port,
			req->args.port_rate_egress_set.kbits_sec,
			req->args.port_rate_egress_set.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_TRAFFIC_GET:
		rv = bcm_port_rate_egress_traffic_get(
			req->args.port_rate_egress_traffic_get.unit,
			req->args.port_rate_egress_traffic_get.port,
			req->args.port_rate_egress_traffic_get.traffic_types,
			req->args.port_rate_egress_traffic_get.kbits_sec,
			req->args.port_rate_egress_traffic_get.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_PORT_RATE_EGRESS_TRAFFIC_SET:
		rv = bcm_port_rate_egress_traffic_set(
			req->args.port_rate_egress_traffic_set.unit,
			req->args.port_rate_egress_traffic_set.port,
			req->args.port_rate_egress_traffic_set.traffic_types,
			req->args.port_rate_egress_traffic_set.kbits_sec,
			req->args.port_rate_egress_traffic_set.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_PORT_RATE_INGRESS_GET:
		rv = bcm_port_rate_ingress_get(
			req->args.port_rate_ingress_get.unit,
			req->args.port_rate_ingress_get.port,
			req->args.port_rate_ingress_get.kbits_sec,
			req->args.port_rate_ingress_get.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_PORT_RATE_INGRESS_SET:
		rv = bcm_port_rate_ingress_set(
			req->args.port_rate_ingress_set.unit,
			req->args.port_rate_ingress_set.port,
			req->args.port_rate_ingress_set.kbits_sec,
			req->args.port_rate_ingress_set.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_PORT_RATE_PAUSE_GET:
		rv = bcm_port_rate_pause_get(
			req->args.port_rate_pause_get.unit,
			req->args.port_rate_pause_get.port,
			req->args.port_rate_pause_get.kbits_pause,
			req->args.port_rate_pause_get.kbits_resume);
		break;
	case BCM_ASYNC_ENTRY_PORT_RATE_PAUSE_SET:
		rv = bcm_port_rate_pause_set(
			req->args.port_rate_pause_set.unit,
			req->args.port_rate_pause_set.port,
			req->args.port_rate_pause_set.kbits_pause,
			req->args.port_rate_pause_set.kbits_resume);
		break;
	case BCM_ASYNC_ENTRY_PORT_SAMPLE_RATE_GET:
		rv = bcm_port_sample_rate_get(
			req->args.port_sample_rate_get.unit,
			req->args.port_sample_rate_get.port,
			req->args.port_sample_rate_get.ingress_rate,
			req->args.port_sample_rate_get.egress_rate);
		break;
	case BCM_ASYNC_ENTRY_PORT_SAMPLE_RATE_SET:
		rv = bcm_port_sample_rate_set(
			req->args.port_sample_rate_set.unit,
			req->args.port_sample_rate_set.port,
			req->args.port_sample_rate_set.ingress_rate,
			req->args.port_sample_rate_set.egress_rate);
		break;
	case BCM_ASYNC_ENTRY_PORT_SELECTIVE_GET:
		rv = bcm_port_selective_get(
			req->args.port_selective_get.unit,
			req->args.port_selective_get.port,
			req->args.port_selective_get.info);
		break;
	case BCM_ASYNC_ENTRY_PORT_SELECTIVE_SET:
		rv = bcm_port_selective_set(
			req->args.port_selective_set.unit,
			req->args.port_selective_set.port,
			req->args.port_selective_set.info);
		break;
	case BCM_ASYNC_ENTRY_PORT_SPEED_GET:
		rv = bcm_port_speed_get(
			req->args.port_speed_get.unit,
			req->args.port_speed_get.port,
			req->args.port_speed_get.speed);
		break;
	case BCM_ASYNC_ENTRY_PORT_SPEED_MAX:
		rv = bcm_port_speed_max(
			req->args.port_speed_max.unit,
			req->args.port_speed_max.port,
			req->args.port_speed_max.speed);
		break;
	case BCM_ASYNC_ENTRY_PORT_SPEED_SET:
		rv = bcm_port_speed_set(
			req->args.port_speed_set.unit,
			req->args.port_speed_set.port,
			req->args.port_speed_set.speed);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_ENABLE_SET:
		rv = bcm_port_stat_enable_set(
			req->args.port_stat_enable_set.unit,
			req->args.port_stat_enable_set.port,
			req->args.port_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_GET:
		rv = bcm_port_stat_get(
			req->args.port_stat_get.unit,
			req->args.port_stat_get.port,
			req->args.port_stat_get.stat,
			req->args.port_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_GET32:
		rv = bcm_port_stat_get32(
			req->args.port_stat_get32.unit,
			req->args.port_stat_get32.port,
			req->args.port_stat_get32.stat,
			req->args.port_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_MULTI_GET:
		rv = bcm_port_stat_multi_get(
			req->args.port_stat_multi_get.unit,
			req->args.port_stat_multi_get.port,
			req->args.port_stat_multi_get.nstat,
			req->args.port_stat_multi_get.stat_arr,
			req->args.port_stat_multi_get.value_arr);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_MULTI_GET32:
		rv = bcm_port_stat_multi_get32(
			req->args.port_stat_multi_get32.unit,
			req->args.port_stat_multi_get32.port,
			req->args.port_stat_multi_get32.nstat,
			req->args.port_stat_multi_get32.stat_arr,
			req->args.port_stat_multi_get32.value_arr);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_MULTI_SET:
		rv = bcm_port_stat_multi_set(
			req->args.port_stat_multi_set.unit,
			req->args.port_stat_multi_set.port,
			req->args.port_stat_multi_set.nstat,
			req->args.port_stat_multi_set.stat_arr,
			req->args.port_stat_multi_set.value_arr);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_MULTI_SET32:
		rv = bcm_port_stat_multi_set32(
			req->args.port_stat_multi_set32.unit,
			req->args.port_stat_multi_set32.port,
			req->args.port_stat_multi_set32.nstat,
			req->args.port_stat_multi_set32.stat_arr,
			req->args.port_stat_multi_set32.value_arr);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_SET:
		rv = bcm_port_stat_set(
			req->args.port_stat_set.unit,
			req->args.port_stat_set.port,
			req->args.port_stat_set.stat,
			req->args.port_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_PORT_STAT_SET32:
		rv = bcm_port_stat_set32(
			req->args.port_stat_set32.unit,
			req->args.port_stat_set32.port,
			req->args.port_stat_set32.stat,
			req->args.port_stat_set32.val);
		break;
	case BCM_ASYNC_ENTRY_PORT_STP_GET:
		rv = bcm_port_stp_get(
			req->args.port_stp_get.unit,
			req->args.port_stp_get.port,
			req->args.port_stp_get.state);
		break;
	case BCM_ASYNC_ENTRY_PORT_STP_SET:
		rv = bcm_port_stp_set(
			req->args.port_stp_set.unit,
			req->args.port_stp_set.port,
			req->args.port_stp_set.state);
		break;
	case BCM_ASYNC_ENTRY_PORT_SUBSIDIARY_PORTS_GET:
		rv = bcm_port_subsidiary_ports_get(
			req->args.port_subsidiary_ports_get.unit,
			req->args.port_subsidiary_ports_get.port,
			req->args.port_subsidiary_ports_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_PORT_TGID_GET:
		rv = bcm_port_tgid_get(
			req->args.port_tgid_get.unit,
			req->args.port_tgid_get.port,
			req->args.port_tgid_get.tgid,
			req->args.port_tgid_get.psc);
		break;
	case BCM_ASYNC_ENTRY_PORT_TGID_SET:
		rv = bcm_port_tgid_set(
			req->args.port_tgid_set.unit,
			req->args.port_tgid_set.port,
			req->args.port_tgid_set.tgid,
			req->args.port_tgid_set.psc);
		break;
	case BCM_ASYNC_ENTRY_PORT_TPID_ADD:
		rv = bcm_port_tpid_add(
			req->args.port_tpid_add.unit,
			req->args.port_tpid_add.port,
			req->args.port_tpid_add.tpid,
			req->args.port_tpid_add.color_select);
		break;
	case BCM_ASYNC_ENTRY_PORT_TPID_DELETE:
		rv = bcm_port_tpid_delete(
			req->args.port_tpid_delete.unit,
			req->args.port_tpid_delete.port,
			req->args.port_tpid_delete.tpid);
		break;
	case BCM_ASYNC_ENTRY_PORT_TPID_DELETE_ALL:
		rv = bcm_port_tpid_delete_all(
			req->args.port_tpid_delete_all.unit,
			req->args.port_tpid_delete_all.port);
		break;
	case BCM_ASYNC_ENTRY_PORT_TPID_GET:
		rv = bcm_port_tpid_get(
			req->args.port_tpid_get.unit,
			req->args.port_tpid_get.port,
			req->args.port_tpid_get.tpid);
		break;
	case BCM_ASYNC_ENTRY_PORT_TPID_SET:
		rv = bcm_port_tpid_set(
			req->args.port_tpid_set.unit,
			req->args.port_tpid_set.port,
			req->args.port_tpid_set.tpid);
		break;
	case BCM_ASYNC_ENTRY_PORT_TRUNK_INDEX_GET:
		rv = bcm_port_trunk_index_get(
			req->args.port_trunk_index_get.unit,
			req->args.port_trunk_index_get.port,
			req->args.port_trunk_index_get.port_index);
		break;
	case BCM_ASYNC_ENTRY_PORT_TRUNK_INDEX_SET:
		rv = bcm_port_trunk_index_set(
			req->args.port_trunk_index_set.unit,
			req->args.port_trunk_index_set.port,
			req->args.port_trunk_index_set.port_index);
		break;
	case BCM_ASYNC_ENTRY_PORT_UNTAGGED_PRIORITY_GET:
		rv = bcm_port_untagged_priority_get(
			req->args.port_untagged_priority_get.unit,
			req->args.port_untagged_priority_get.port,
			req->args.port_untagged_priority_get.priority);
		break;
	case BCM_ASYNC_ENTRY_PORT_UNTAGGED_PRIORITY_SET:
		rv = bcm_port_untagged_priority_set(
			req->args.port_untagged_priority_set.unit,
			req->args.port_untagged_priority_set.port,
			req->args.port_untagged_priority_set.priority);
		break;
	case BCM_ASYNC_ENTRY_PORT_UNTAGGED_VLAN_GET:
		rv = bcm_port_untagged_vlan_get(
			req->args.port_untagged_vlan_get.unit,
			req->args.port_untagged_vlan_get.port,
			req->args.port_untagged_vlan_get.vid_ptr);
		break;
	case BCM_ASYNC_ENTRY_PORT_UNTAGGED_VLAN_SET:
		rv = bcm_port_untagged_vlan_set(
			req->args.port_untagged_vlan_set.unit,
			req->args.port_untagged_vlan_set.port,
			req->args.port_untagged_vlan_set.vid);
		break;
	case BCM_ASYNC_ENTRY_PORT_UPDATE:
		rv = bcm_port_update(
			req->args.port_update.unit,
			req->args.port_update.port,
			req->args.port_update.link);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_DSCP_MAP_GET:
		rv = bcm_port_vlan_dscp_map_get(
			req->args.port_vlan_dscp_map_get.unit,
			req->args.port_vlan_dscp_map_get.port,
			req->args.port_vlan_dscp_map_get.vlan,
			req->args.port_vlan_dscp_map_get.dscp,
			req->args.port_vlan_dscp_map_get.internal_pri,
			req->args.port_vlan_dscp_map_get.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_DSCP_MAP_SET:
		rv = bcm_port_vlan_dscp_map_set(
			req->args.port_vlan_dscp_map_set.unit,
			req->args.port_vlan_dscp_map_set.port,
			req->args.port_vlan_dscp_map_set.vlan,
			req->args.port_vlan_dscp_map_set.dscp,
			req->args.port_vlan_dscp_map_set.internal_pri,
			req->args.port_vlan_dscp_map_set.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_INNER_TAG_GET:
		rv = bcm_port_vlan_inner_tag_get(
			req->args.port_vlan_inner_tag_get.unit,
			req->args.port_vlan_inner_tag_get.port,
			req->args.port_vlan_inner_tag_get.inner_tag);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_INNER_TAG_SET:
		rv = bcm_port_vlan_inner_tag_set(
			req->args.port_vlan_inner_tag_set.unit,
			req->args.port_vlan_inner_tag_set.port,
			req->args.port_vlan_inner_tag_set.inner_tag);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_MEMBER_GET:
		rv = bcm_port_vlan_member_get(
			req->args.port_vlan_member_get.unit,
			req->args.port_vlan_member_get.port,
			req->args.port_vlan_member_get.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_MEMBER_SET:
		rv = bcm_port_vlan_member_set(
			req->args.port_vlan_member_set.unit,
			req->args.port_vlan_member_set.port,
			req->args.port_vlan_member_set.flags);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_PRI_MAP_GET:
		rv = bcm_port_vlan_pri_map_get(
			req->args.port_vlan_pri_map_get.unit,
			req->args.port_vlan_pri_map_get.port,
			req->args.port_vlan_pri_map_get.vlan,
			req->args.port_vlan_pri_map_get.pkt_pri,
			req->args.port_vlan_pri_map_get.cfi,
			req->args.port_vlan_pri_map_get.internal_pri,
			req->args.port_vlan_pri_map_get.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_PRI_MAP_SET:
		rv = bcm_port_vlan_pri_map_set(
			req->args.port_vlan_pri_map_set.unit,
			req->args.port_vlan_pri_map_set.port,
			req->args.port_vlan_pri_map_set.vlan,
			req->args.port_vlan_pri_map_set.pkt_pri,
			req->args.port_vlan_pri_map_set.cfi,
			req->args.port_vlan_pri_map_set.internal_pri,
			req->args.port_vlan_pri_map_set.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAP_GET:
		rv = bcm_port_vlan_priority_map_get(
			req->args.port_vlan_priority_map_get.unit,
			req->args.port_vlan_priority_map_get.port,
			req->args.port_vlan_priority_map_get.pkt_pri,
			req->args.port_vlan_priority_map_get.cfi,
			req->args.port_vlan_priority_map_get.internal_pri,
			req->args.port_vlan_priority_map_get.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAP_SET:
		rv = bcm_port_vlan_priority_map_set(
			req->args.port_vlan_priority_map_set.unit,
			req->args.port_vlan_priority_map_set.port,
			req->args.port_vlan_priority_map_set.pkt_pri,
			req->args.port_vlan_priority_map_set.cfi,
			req->args.port_vlan_priority_map_set.internal_pri,
			req->args.port_vlan_priority_map_set.color);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAPPING_GET:
		rv = bcm_port_vlan_priority_mapping_get(
			req->args.port_vlan_priority_mapping_get.unit,
			req->args.port_vlan_priority_mapping_get.port,
			req->args.port_vlan_priority_mapping_get.vid,
			req->args.port_vlan_priority_mapping_get.pkt_pri,
			req->args.port_vlan_priority_mapping_get.cfi,
			req->args.port_vlan_priority_mapping_get.pri_map);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_MAPPING_SET:
		rv = bcm_port_vlan_priority_mapping_set(
			req->args.port_vlan_priority_mapping_set.unit,
			req->args.port_vlan_priority_mapping_set.port,
			req->args.port_vlan_priority_mapping_set.vid,
			req->args.port_vlan_priority_mapping_set.pkt_pri,
			req->args.port_vlan_priority_mapping_set.cfi,
			req->args.port_vlan_priority_mapping_set.pri_map);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_UNMAP_GET:
		rv = bcm_port_vlan_priority_unmap_get(
			req->args.port_vlan_priority_unmap_get.unit,
			req->args.port_vlan_priority_unmap_get.port,
			req->args.port_vlan_priority_unmap_get.internal_pri,
			req->args.port_vlan_priority_unmap_get.color,
			req->args.port_vlan_priority_unmap_get.pkt_pri,
			req->args.port_vlan_priority_unmap_get.cfi);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_PRIORITY_UNMAP_SET:
		rv = bcm_port_vlan_priority_unmap_set(
			req->args.port_vlan_priority_unmap_set.unit,
			req->args.port_vlan_priority_unmap_set.port,
			req->args.port_vlan_priority_unmap_set.internal_pri,
			req->args.port_vlan_priority_unmap_set.color,
			req->args.port_vlan_priority_unmap_set.pkt_pri,
			req->args.port_vlan_priority_unmap_set.cfi);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_VECTOR_GET:
		rv = bcm_port_vlan_vector_get(
			req->args.port_vlan_vector_get.unit,
			req->args.port_vlan_vector_get.port_id,
			req->args.port_vlan_vector_get.vlan_vec);
		break;
	case BCM_ASYNC_ENTRY_PORT_VLAN_VECTOR_SET:
		rv = bcm_port_vlan_vector_set(
			req->args.port_vlan_vector_set.unit,
			req->args.port_vlan_vector_set.port_id,
			req->args.port_vlan_vector_set.vlan_vec);
		break;
#ifdef	INCLUDE_L3
	case BCM_ASYNC_ENTRY_PROXY_CLEANUP:
		rv = bcm_proxy_cleanup(
			req->args.proxy_cleanup.unit);
		break;
	case BCM_ASYNC_ENTRY_PROXY_CLIENT_SET:
		rv = bcm_proxy_client_set(
			req->args.proxy_client_set.unit,
			req->args.proxy_client_set.client_port,
			req->args.proxy_client_set.proto_type,
			req->args.proxy_client_set.server_modid,
			req->args.proxy_client_set.server_port,
			req->args.proxy_client_set.enable);
		break;
	case BCM_ASYNC_ENTRY_PROXY_INIT:
		rv = bcm_proxy_init(
			req->args.proxy_init.unit);
		break;
	case BCM_ASYNC_ENTRY_PROXY_SERVER_GET:
		rv = bcm_proxy_server_get(
			req->args.proxy_server_get.unit,
			req->args.proxy_server_get.server_port,
			req->args.proxy_server_get.mode,
			req->args.proxy_server_get.enable);
		break;
	case BCM_ASYNC_ENTRY_PROXY_SERVER_SET:
		rv = bcm_proxy_server_set(
			req->args.proxy_server_set.unit,
			req->args.proxy_server_set.server_port,
			req->args.proxy_server_set.mode,
			req->args.proxy_server_set.enable);
		break;
#endif	/* INCLUDE_L3 */
	case BCM_ASYNC_ENTRY_QOS_DETACH:
		rv = bcm_qos_detach(
			req->args.qos_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_QOS_INIT:
		rv = bcm_qos_init(
			req->args.qos_init.unit);
		break;
	case BCM_ASYNC_ENTRY_QOS_MAP_ADD:
		rv = bcm_qos_map_add(
			req->args.qos_map_add.unit,
			req->args.qos_map_add.flags,
			req->args.qos_map_add.map,
			req->args.qos_map_add.map_id);
		break;
	case BCM_ASYNC_ENTRY_QOS_MAP_CREATE:
		rv = bcm_qos_map_create(
			req->args.qos_map_create.unit,
			req->args.qos_map_create.flags,
			req->args.qos_map_create.map_id);
		break;
	case BCM_ASYNC_ENTRY_QOS_MAP_DELETE:
		rv = bcm_qos_map_delete(
			req->args.qos_map_delete.unit,
			req->args.qos_map_delete.flags,
			req->args.qos_map_delete.map,
			req->args.qos_map_delete.map_id);
		break;
	case BCM_ASYNC_ENTRY_QOS_MAP_DESTROY:
		rv = bcm_qos_map_destroy(
			req->args.qos_map_destroy.unit,
			req->args.qos_map_destroy.map_id);
		break;
	case BCM_ASYNC_ENTRY_QOS_PORT_MAP_SET:
		rv = bcm_qos_port_map_set(
			req->args.qos_port_map_set.unit,
			req->args.qos_port_map_set.port,
			req->args.qos_port_map_set.ing_map,
			req->args.qos_port_map_set.egr_map);
		break;
	case BCM_ASYNC_ENTRY_RATE_BANDWIDTH_GET:
		rv = bcm_rate_bandwidth_get(
			req->args.rate_bandwidth_get.unit,
			req->args.rate_bandwidth_get.port,
			req->args.rate_bandwidth_get.flags,
			req->args.rate_bandwidth_get.kbits_sec,
			req->args.rate_bandwidth_get.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_RATE_BANDWIDTH_SET:
		rv = bcm_rate_bandwidth_set(
			req->args.rate_bandwidth_set.unit,
			req->args.rate_bandwidth_set.port,
			req->args.rate_bandwidth_set.flags,
			req->args.rate_bandwidth_set.kbits_sec,
			req->args.rate_bandwidth_set.kbits_burst);
		break;
	case BCM_ASYNC_ENTRY_RATE_BCAST_GET:
		rv = bcm_rate_bcast_get(
			req->args.rate_bcast_get.unit,
			req->args.rate_bcast_get.pps,
			req->args.rate_bcast_get.flags,
			req->args.rate_bcast_get.port);
		break;
	case BCM_ASYNC_ENTRY_RATE_BCAST_SET:
		rv = bcm_rate_bcast_set(
			req->args.rate_bcast_set.unit,
			req->args.rate_bcast_set.pps,
			req->args.rate_bcast_set.flags,
			req->args.rate_bcast_set.port);
		break;
	case BCM_ASYNC_ENTRY_RATE_DLFBC_GET:
		rv = bcm_rate_dlfbc_get(
			req->args.rate_dlfbc_get.unit,
			req->args.rate_dlfbc_get.pps,
			req->args.rate_dlfbc_get.flags,
			req->args.rate_dlfbc_get.port);
		break;
	case BCM_ASYNC_ENTRY_RATE_DLFBC_SET:
		rv = bcm_rate_dlfbc_set(
			req->args.rate_dlfbc_set.unit,
			req->args.rate_dlfbc_set.pps,
			req->args.rate_dlfbc_set.flags,
			req->args.rate_dlfbc_set.port);
		break;
	case BCM_ASYNC_ENTRY_RATE_GET:
		rv = bcm_rate_get(
			req->args.rate_get.unit,
			req->args.rate_get.pps,
			req->args.rate_get.flags);
		break;
	case BCM_ASYNC_ENTRY_RATE_MCAST_GET:
		rv = bcm_rate_mcast_get(
			req->args.rate_mcast_get.unit,
			req->args.rate_mcast_get.pps,
			req->args.rate_mcast_get.flags,
			req->args.rate_mcast_get.port);
		break;
	case BCM_ASYNC_ENTRY_RATE_MCAST_SET:
		rv = bcm_rate_mcast_set(
			req->args.rate_mcast_set.unit,
			req->args.rate_mcast_set.pps,
			req->args.rate_mcast_set.flags,
			req->args.rate_mcast_set.port);
		break;
	case BCM_ASYNC_ENTRY_RATE_SET:
		rv = bcm_rate_set(
			req->args.rate_set.unit,
			req->args.rate_set.pps,
			req->args.rate_set.flags);
		break;
	case BCM_ASYNC_ENTRY_RATE_TYPE_GET:
		rv = bcm_rate_type_get(
			req->args.rate_type_get.unit,
			req->args.rate_type_get.rl);
		break;
	case BCM_ASYNC_ENTRY_RATE_TYPE_SET:
		rv = bcm_rate_type_set(
			req->args.rate_type_set.unit,
			req->args.rate_type_set.rl);
		break;
	case BCM_ASYNC_ENTRY_RX_ACTIVE:
		rv = bcm_rx_active(
			req->args.rx_active.unit);
		break;
	case BCM_ASYNC_ENTRY_RX_ALLOC:
		rv = bcm_rx_alloc(
			req->args.rx_alloc.unit,
			req->args.rx_alloc.pkt_size,
			req->args.rx_alloc.flags,
			req->args.rx_alloc.buf);
		break;
	case BCM_ASYNC_ENTRY_RX_BURST_GET:
		rv = bcm_rx_burst_get(
			req->args.rx_burst_get.unit,
			req->args.rx_burst_get.burst);
		break;
	case BCM_ASYNC_ENTRY_RX_BURST_SET:
		rv = bcm_rx_burst_set(
			req->args.rx_burst_set.unit,
			req->args.rx_burst_set.burst);
		break;
	case BCM_ASYNC_ENTRY_RX_CFG_GET:
		rv = bcm_rx_cfg_get(
			req->args.rx_cfg_get.unit,
			req->args.rx_cfg_get.cfg);
		break;
	case BCM_ASYNC_ENTRY_RX_CFG_INIT:
		rv = bcm_rx_cfg_init(
			req->args.rx_cfg_init.unit);
		break;
	case BCM_ASYNC_ENTRY_RX_CHANNELS_RUNNING:
		rv = bcm_rx_channels_running(
			req->args.rx_channels_running.unit,
			req->args.rx_channels_running.channels);
		break;
	case BCM_ASYNC_ENTRY_RX_CLEAR:
		rv = bcm_rx_clear(
			req->args.rx_clear.unit);
		break;
	case BCM_ASYNC_ENTRY_RX_CONTROL_GET:
		rv = bcm_rx_control_get(
			req->args.rx_control_get.unit,
			req->args.rx_control_get.type,
			req->args.rx_control_get.arg);
		break;
	case BCM_ASYNC_ENTRY_RX_CONTROL_SET:
		rv = bcm_rx_control_set(
			req->args.rx_control_set.unit,
			req->args.rx_control_set.type,
			req->args.rx_control_set.arg);
		break;
	case BCM_ASYNC_ENTRY_RX_COS_BURST_GET:
		rv = bcm_rx_cos_burst_get(
			req->args.rx_cos_burst_get.unit,
			req->args.rx_cos_burst_get.cos,
			req->args.rx_cos_burst_get.burst);
		break;
	case BCM_ASYNC_ENTRY_RX_COS_BURST_SET:
		rv = bcm_rx_cos_burst_set(
			req->args.rx_cos_burst_set.unit,
			req->args.rx_cos_burst_set.cos,
			req->args.rx_cos_burst_set.burst);
		break;
	case BCM_ASYNC_ENTRY_RX_COS_MAX_LEN_GET:
		rv = bcm_rx_cos_max_len_get(
			req->args.rx_cos_max_len_get.unit,
			req->args.rx_cos_max_len_get.cos,
			req->args.rx_cos_max_len_get.max_q_len);
		break;
	case BCM_ASYNC_ENTRY_RX_COS_MAX_LEN_SET:
		rv = bcm_rx_cos_max_len_set(
			req->args.rx_cos_max_len_set.unit,
			req->args.rx_cos_max_len_set.cos,
			req->args.rx_cos_max_len_set.max_q_len);
		break;
	case BCM_ASYNC_ENTRY_RX_COS_RATE_GET:
		rv = bcm_rx_cos_rate_get(
			req->args.rx_cos_rate_get.unit,
			req->args.rx_cos_rate_get.cos,
			req->args.rx_cos_rate_get.pps);
		break;
	case BCM_ASYNC_ENTRY_RX_COS_RATE_SET:
		rv = bcm_rx_cos_rate_set(
			req->args.rx_cos_rate_set.unit,
			req->args.rx_cos_rate_set.cos,
			req->args.rx_cos_rate_set.pps);
		break;
	case BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_DELETE:
		rv = bcm_rx_cosq_mapping_delete(
			req->args.rx_cosq_mapping_delete.unit,
			req->args.rx_cosq_mapping_delete.index);
		break;
	case BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_GET:
		rv = bcm_rx_cosq_mapping_get(
			req->args.rx_cosq_mapping_get.unit,
			req->args.rx_cosq_mapping_get.index,
			req->args.rx_cosq_mapping_get.reasons,
			req->args.rx_cosq_mapping_get.reasons_mask,
			req->args.rx_cosq_mapping_get.int_prio,
			req->args.rx_cosq_mapping_get.int_prio_mask,
			req->args.rx_cosq_mapping_get.packet_type,
			req->args.rx_cosq_mapping_get.packet_type_mask,
			req->args.rx_cosq_mapping_get.cosq);
		break;
	case BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_REASONS_GET:
		rv = bcm_rx_cosq_mapping_reasons_get(
			req->args.rx_cosq_mapping_reasons_get.unit,
			req->args.rx_cosq_mapping_reasons_get.reasons);
		break;
	case BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_SET:
		rv = bcm_rx_cosq_mapping_set(
			req->args.rx_cosq_mapping_set.unit,
			req->args.rx_cosq_mapping_set.index,
			req->args.rx_cosq_mapping_set.reasons,
			req->args.rx_cosq_mapping_set.reasons_mask,
			req->args.rx_cosq_mapping_set.int_prio,
			req->args.rx_cosq_mapping_set.int_prio_mask,
			req->args.rx_cosq_mapping_set.packet_type,
			req->args.rx_cosq_mapping_set.packet_type_mask,
			req->args.rx_cosq_mapping_set.cosq);
		break;
	case BCM_ASYNC_ENTRY_RX_COSQ_MAPPING_SIZE_GET:
		rv = bcm_rx_cosq_mapping_size_get(
			req->args.rx_cosq_mapping_size_get.unit,
			req->args.rx_cosq_mapping_size_get.size);
		break;
	case BCM_ASYNC_ENTRY_RX_CPU_RATE_GET:
		rv = bcm_rx_cpu_rate_get(
			req->args.rx_cpu_rate_get.unit,
			req->args.rx_cpu_rate_get.pps);
		break;
	case BCM_ASYNC_ENTRY_RX_CPU_RATE_SET:
		rv = bcm_rx_cpu_rate_set(
			req->args.rx_cpu_rate_set.unit,
			req->args.rx_cpu_rate_set.pps);
		break;
	case BCM_ASYNC_ENTRY_RX_FREE:
		rv = bcm_rx_free(
			req->args.rx_free.unit,
			req->args.rx_free.pkt_data);
		break;
	case BCM_ASYNC_ENTRY_RX_FREE_ENQUEUE:
		rv = bcm_rx_free_enqueue(
			req->args.rx_free_enqueue.unit,
			req->args.rx_free_enqueue.pkt_data);
		break;
	case BCM_ASYNC_ENTRY_RX_INIT:
		rv = bcm_rx_init(
			req->args.rx_init.unit);
		break;
	case BCM_ASYNC_ENTRY_RX_POOL_ALLOC:
		rv = bcm_rx_pool_alloc(
			req->args.rx_pool_alloc.unit,
			req->args.rx_pool_alloc.size,
			req->args.rx_pool_alloc.flags,
			req->args.rx_pool_alloc.pool);
		break;
	case BCM_ASYNC_ENTRY_RX_POOL_CLEANUP:
		rv = bcm_rx_pool_cleanup(
			);
		break;
	case BCM_ASYNC_ENTRY_RX_POOL_FREE:
		rv = bcm_rx_pool_free(
			req->args.rx_pool_free.unit,
			req->args.rx_pool_free.buf);
		break;
	case BCM_ASYNC_ENTRY_RX_POOL_SETUP:
		rv = bcm_rx_pool_setup(
			req->args.rx_pool_setup.pkt_count,
			req->args.rx_pool_setup.bytes_per_pkt);
		break;
	case BCM_ASYNC_ENTRY_RX_POOL_SETUP_DONE:
		rv = bcm_rx_pool_setup_done(
			);
		break;
	case BCM_ASYNC_ENTRY_RX_QUEUE_CHANNEL_GET:
		rv = bcm_rx_queue_channel_get(
			req->args.rx_queue_channel_get.unit,
			req->args.rx_queue_channel_get.queue_id,
			req->args.rx_queue_channel_get.chan_id);
		break;
	case BCM_ASYNC_ENTRY_RX_QUEUE_CHANNEL_SET:
		rv = bcm_rx_queue_channel_set(
			req->args.rx_queue_channel_set.unit,
			req->args.rx_queue_channel_set.queue_id,
			req->args.rx_queue_channel_set.chan_id);
		break;
	case BCM_ASYNC_ENTRY_RX_QUEUE_MAX_GET:
		rv = bcm_rx_queue_max_get(
			req->args.rx_queue_max_get.unit,
			req->args.rx_queue_max_get.cosq);
		break;
	case BCM_ASYNC_ENTRY_RX_QUEUE_PACKET_COUNT_GET:
		rv = bcm_rx_queue_packet_count_get(
			req->args.rx_queue_packet_count_get.unit,
			req->args.rx_queue_packet_count_get.cosq,
			req->args.rx_queue_packet_count_get.packet_count);
		break;
	case BCM_ASYNC_ENTRY_RX_QUEUE_RATE_LIMIT_STATUS_GET:
		rv = bcm_rx_queue_rate_limit_status_get(
			req->args.rx_queue_rate_limit_status_get.unit,
			req->args.rx_queue_rate_limit_status_get.cosq,
			req->args.rx_queue_rate_limit_status_get.packet_tokens);
		break;
	case BCM_ASYNC_ENTRY_RX_QUEUE_REGISTER:
		rv = bcm_rx_queue_register(
			req->args.rx_queue_register.unit,
			req->args.rx_queue_register.name,
			req->args.rx_queue_register.cosq,
			req->args.rx_queue_register.callback,
			req->args.rx_queue_register.priority,
			req->args.rx_queue_register.cookie,
			req->args.rx_queue_register.flags);
		break;
	case BCM_ASYNC_ENTRY_RX_QUEUE_UNREGISTER:
		rv = bcm_rx_queue_unregister(
			req->args.rx_queue_unregister.unit,
			req->args.rx_queue_unregister.cosq,
			req->args.rx_queue_unregister.callback,
			req->args.rx_queue_unregister.priority);
		break;
	case BCM_ASYNC_ENTRY_RX_RATE_GET:
		rv = bcm_rx_rate_get(
			req->args.rx_rate_get.unit,
			req->args.rx_rate_get.pps);
		break;
	case BCM_ASYNC_ENTRY_RX_RATE_SET:
		rv = bcm_rx_rate_set(
			req->args.rx_rate_set.unit,
			req->args.rx_rate_set.pps);
		break;
	case BCM_ASYNC_ENTRY_RX_REASONS_GET:
		rv = bcm_rx_reasons_get(
			req->args.rx_reasons_get.unit,
			req->args.rx_reasons_get.reasons);
		break;
	case BCM_ASYNC_ENTRY_RX_REASONS_POLICER_SET:
		rv = bcm_rx_reasons_policer_set(
			req->args.rx_reasons_policer_set.unit,
			req->args.rx_reasons_policer_set.rx_reasons,
			req->args.rx_reasons_policer_set.polid);
		break;
	case BCM_ASYNC_ENTRY_RX_REGISTER:
		rv = bcm_rx_register(
			req->args.rx_register.unit,
			req->args.rx_register.name,
			req->args.rx_register.callback,
			req->args.rx_register.priority,
			req->args.rx_register.cookie,
			req->args.rx_register.flags);
		break;
#ifdef	BCM_RPC_SUPPORT
	case BCM_ASYNC_ENTRY_RX_REMOTE_PKT_ALLOC:
		rv = bcm_rx_remote_pkt_alloc(
			req->args.rx_remote_pkt_alloc.len,
			req->args.rx_remote_pkt_alloc.pkt);
		break;
#endif	/* BCM_RPC_SUPPORT */
	case BCM_ASYNC_ENTRY_RX_REMOTE_PKT_ENQUEUE:
		rv = bcm_rx_remote_pkt_enqueue(
			req->args.rx_remote_pkt_enqueue.unit,
			req->args.rx_remote_pkt_enqueue.pkt);
		break;
#ifdef	BCM_RPC_SUPPORT
	case BCM_ASYNC_ENTRY_RX_REMOTE_PKT_FREE:
		rv = bcm_rx_remote_pkt_free(
			req->args.rx_remote_pkt_free.pkt);
		break;
#endif	/* BCM_RPC_SUPPORT */
	case BCM_ASYNC_ENTRY_RX_SCHED_REGISTER:
		rv = bcm_rx_sched_register(
			req->args.rx_sched_register.unit,
			req->args.rx_sched_register.sched_cb);
		break;
	case BCM_ASYNC_ENTRY_RX_SCHED_UNREGISTER:
		rv = bcm_rx_sched_unregister(
			req->args.rx_sched_unregister.unit);
		break;
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_RX_SHOW:
		rv = bcm_rx_show(
			req->args.rx_show.unit);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_RX_START:
		rv = bcm_rx_start(
			req->args.rx_start.unit,
			req->args.rx_start.cfg);
		break;
	case BCM_ASYNC_ENTRY_RX_STOP:
		rv = bcm_rx_stop(
			req->args.rx_stop.unit,
			req->args.rx_stop.cfg);
		break;
	case BCM_ASYNC_ENTRY_RX_UNIT_NEXT_GET:
		rv = bcm_rx_unit_next_get(
			req->args.rx_unit_next_get.unit,
			req->args.rx_unit_next_get.next_unit);
		break;
	case BCM_ASYNC_ENTRY_RX_UNREGISTER:
		rv = bcm_rx_unregister(
			req->args.rx_unregister.unit,
			req->args.rx_unregister.callback,
			req->args.rx_unregister.priority);
		break;
	case BCM_ASYNC_ENTRY_STAT_CLEAR:
		rv = bcm_stat_clear(
			req->args.stat_clear.unit,
			req->args.stat_clear.port);
		break;
	case BCM_ASYNC_ENTRY_STAT_CUSTOM_ADD:
		rv = bcm_stat_custom_add(
			req->args.stat_custom_add.unit,
			req->args.stat_custom_add.port,
			req->args.stat_custom_add.type,
			req->args.stat_custom_add.trigger);
		break;
	case BCM_ASYNC_ENTRY_STAT_CUSTOM_CHECK:
		rv = bcm_stat_custom_check(
			req->args.stat_custom_check.unit,
			req->args.stat_custom_check.port,
			req->args.stat_custom_check.type,
			req->args.stat_custom_check.trigger,
			req->args.stat_custom_check.result);
		break;
	case BCM_ASYNC_ENTRY_STAT_CUSTOM_DELETE:
		rv = bcm_stat_custom_delete(
			req->args.stat_custom_delete.unit,
			req->args.stat_custom_delete.port,
			req->args.stat_custom_delete.type,
			req->args.stat_custom_delete.trigger);
		break;
	case BCM_ASYNC_ENTRY_STAT_CUSTOM_DELETE_ALL:
		rv = bcm_stat_custom_delete_all(
			req->args.stat_custom_delete_all.unit,
			req->args.stat_custom_delete_all.port,
			req->args.stat_custom_delete_all.type);
		break;
	case BCM_ASYNC_ENTRY_STAT_CUSTOM_GET:
		rv = bcm_stat_custom_get(
			req->args.stat_custom_get.unit,
			req->args.stat_custom_get.port,
			req->args.stat_custom_get.type,
			req->args.stat_custom_get.flags);
		break;
	case BCM_ASYNC_ENTRY_STAT_CUSTOM_SET:
		rv = bcm_stat_custom_set(
			req->args.stat_custom_set.unit,
			req->args.stat_custom_set.port,
			req->args.stat_custom_set.type,
			req->args.stat_custom_set.flags);
		break;
	case BCM_ASYNC_ENTRY_STAT_GET:
		rv = bcm_stat_get(
			req->args.stat_get.unit,
			req->args.stat_get.port,
			req->args.stat_get.type,
			req->args.stat_get.value);
		break;
	case BCM_ASYNC_ENTRY_STAT_GET32:
		rv = bcm_stat_get32(
			req->args.stat_get32.unit,
			req->args.stat_get32.port,
			req->args.stat_get32.type,
			req->args.stat_get32.value);
		break;
	case BCM_ASYNC_ENTRY_STAT_INIT:
		rv = bcm_stat_init(
			req->args.stat_init.unit);
		break;
	case BCM_ASYNC_ENTRY_STAT_SYNC:
		rv = bcm_stat_sync(
			req->args.stat_sync.unit);
		break;
	case BCM_ASYNC_ENTRY_STG_CLEAR:
		rv = bcm_stg_clear(
			req->args.stg_clear.unit);
		break;
	case BCM_ASYNC_ENTRY_STG_COUNT_GET:
		rv = bcm_stg_count_get(
			req->args.stg_count_get.unit,
			req->args.stg_count_get.max_stg);
		break;
	case BCM_ASYNC_ENTRY_STG_CREATE:
		rv = bcm_stg_create(
			req->args.stg_create.unit,
			req->args.stg_create.stg_ptr);
		break;
	case BCM_ASYNC_ENTRY_STG_CREATE_ID:
		rv = bcm_stg_create_id(
			req->args.stg_create_id.unit,
			req->args.stg_create_id.stg);
		break;
	case BCM_ASYNC_ENTRY_STG_DEFAULT_GET:
		rv = bcm_stg_default_get(
			req->args.stg_default_get.unit,
			req->args.stg_default_get.stg_ptr);
		break;
	case BCM_ASYNC_ENTRY_STG_DEFAULT_SET:
		rv = bcm_stg_default_set(
			req->args.stg_default_set.unit,
			req->args.stg_default_set.stg);
		break;
	case BCM_ASYNC_ENTRY_STG_DESTROY:
		rv = bcm_stg_destroy(
			req->args.stg_destroy.unit,
			req->args.stg_destroy.stg);
		break;
	case BCM_ASYNC_ENTRY_STG_INIT:
		rv = bcm_stg_init(
			req->args.stg_init.unit);
		break;
	case BCM_ASYNC_ENTRY_STG_LIST:
		rv = bcm_stg_list(
			req->args.stg_list.unit,
			req->args.stg_list.list,
			req->args.stg_list.count);
		break;
	case BCM_ASYNC_ENTRY_STG_LIST_DESTROY:
		rv = bcm_stg_list_destroy(
			req->args.stg_list_destroy.unit,
			req->args.stg_list_destroy.list,
			req->args.stg_list_destroy.count);
		break;
	case BCM_ASYNC_ENTRY_STG_STP_GET:
		rv = bcm_stg_stp_get(
			req->args.stg_stp_get.unit,
			req->args.stg_stp_get.stg,
			req->args.stg_stp_get.port,
			req->args.stg_stp_get.stp_state);
		break;
	case BCM_ASYNC_ENTRY_STG_STP_SET:
		rv = bcm_stg_stp_set(
			req->args.stg_stp_set.unit,
			req->args.stg_stp_set.stg,
			req->args.stg_stp_set.port,
			req->args.stg_stp_set.stp_state);
		break;
	case BCM_ASYNC_ENTRY_STG_VLAN_ADD:
		rv = bcm_stg_vlan_add(
			req->args.stg_vlan_add.unit,
			req->args.stg_vlan_add.stg,
			req->args.stg_vlan_add.vid);
		break;
	case BCM_ASYNC_ENTRY_STG_VLAN_LIST:
		rv = bcm_stg_vlan_list(
			req->args.stg_vlan_list.unit,
			req->args.stg_vlan_list.stg,
			req->args.stg_vlan_list.list,
			req->args.stg_vlan_list.count);
		break;
	case BCM_ASYNC_ENTRY_STG_VLAN_LIST_DESTROY:
		rv = bcm_stg_vlan_list_destroy(
			req->args.stg_vlan_list_destroy.unit,
			req->args.stg_vlan_list_destroy.list,
			req->args.stg_vlan_list_destroy.count);
		break;
	case BCM_ASYNC_ENTRY_STG_VLAN_REMOVE:
		rv = bcm_stg_vlan_remove(
			req->args.stg_vlan_remove.unit,
			req->args.stg_vlan_remove.stg,
			req->args.stg_vlan_remove.vid);
		break;
	case BCM_ASYNC_ENTRY_STG_VLAN_REMOVE_ALL:
		rv = bcm_stg_vlan_remove_all(
			req->args.stg_vlan_remove_all.unit,
			req->args.stg_vlan_remove_all.stg);
		break;
	case BCM_ASYNC_ENTRY_STK_FABRIC_MAP_GET:
		rv = bcm_stk_fabric_map_get(
			req->args.stk_fabric_map_get.unit,
			req->args.stk_fabric_map_get.switch_port,
			req->args.stk_fabric_map_get.fabric_port);
		break;
	case BCM_ASYNC_ENTRY_STK_FABRIC_MAP_SET:
		rv = bcm_stk_fabric_map_set(
			req->args.stk_fabric_map_set.unit,
			req->args.stk_fabric_map_set.switch_port,
			req->args.stk_fabric_map_set.fabric_port);
		break;
	case BCM_ASYNC_ENTRY_STK_FMOD_LMOD_MAPPING_GET:
		rv = bcm_stk_fmod_lmod_mapping_get(
			req->args.stk_fmod_lmod_mapping_get.unit,
			req->args.stk_fmod_lmod_mapping_get.port,
			req->args.stk_fmod_lmod_mapping_get.fmod,
			req->args.stk_fmod_lmod_mapping_get.lmod);
		break;
	case BCM_ASYNC_ENTRY_STK_FMOD_LMOD_MAPPING_SET:
		rv = bcm_stk_fmod_lmod_mapping_set(
			req->args.stk_fmod_lmod_mapping_set.unit,
			req->args.stk_fmod_lmod_mapping_set.port,
			req->args.stk_fmod_lmod_mapping_set.fmod,
			req->args.stk_fmod_lmod_mapping_set.lmod);
		break;
	case BCM_ASYNC_ENTRY_STK_FMOD_SMOD_MAPPING_GET:
		rv = bcm_stk_fmod_smod_mapping_get(
			req->args.stk_fmod_smod_mapping_get.unit,
			req->args.stk_fmod_smod_mapping_get.port,
			req->args.stk_fmod_smod_mapping_get.fmod,
			req->args.stk_fmod_smod_mapping_get.smod,
			req->args.stk_fmod_smod_mapping_get.sport,
			req->args.stk_fmod_smod_mapping_get.nports);
		break;
	case BCM_ASYNC_ENTRY_STK_FMOD_SMOD_MAPPING_SET:
		rv = bcm_stk_fmod_smod_mapping_set(
			req->args.stk_fmod_smod_mapping_set.unit,
			req->args.stk_fmod_smod_mapping_set.port,
			req->args.stk_fmod_smod_mapping_set.fmod,
			req->args.stk_fmod_smod_mapping_set.smod,
			req->args.stk_fmod_smod_mapping_set.sport,
			req->args.stk_fmod_smod_mapping_set.nports);
		break;
	case BCM_ASYNC_ENTRY_STK_INIT:
		rv = bcm_stk_init(
			req->args.stk_init.unit);
		break;
	case BCM_ASYNC_ENTRY_STK_MODE_GET:
		rv = bcm_stk_mode_get(
			req->args.stk_mode_get.unit,
			req->args.stk_mode_get.flags);
		break;
	case BCM_ASYNC_ENTRY_STK_MODE_SET:
		rv = bcm_stk_mode_set(
			req->args.stk_mode_set.unit,
			req->args.stk_mode_set.flags);
		break;
	case BCM_ASYNC_ENTRY_STK_MODID_COUNT:
		rv = bcm_stk_modid_count(
			req->args.stk_modid_count.unit,
			req->args.stk_modid_count.num_modid);
		break;
	case BCM_ASYNC_ENTRY_STK_MODID_GET:
		rv = bcm_stk_modid_get(
			req->args.stk_modid_get.unit,
			req->args.stk_modid_get.modid);
		break;
	case BCM_ASYNC_ENTRY_STK_MODID_SET:
		rv = bcm_stk_modid_set(
			req->args.stk_modid_set.unit,
			req->args.stk_modid_set.modid);
		break;
	case BCM_ASYNC_ENTRY_STK_MODMAP_ENABLE_GET:
		rv = bcm_stk_modmap_enable_get(
			req->args.stk_modmap_enable_get.unit,
			req->args.stk_modmap_enable_get.port,
			req->args.stk_modmap_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_STK_MODMAP_ENABLE_SET:
		rv = bcm_stk_modmap_enable_set(
			req->args.stk_modmap_enable_set.unit,
			req->args.stk_modmap_enable_set.port,
			req->args.stk_modmap_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_STK_MODMAP_MAP:
		rv = bcm_stk_modmap_map(
			req->args.stk_modmap_map.unit,
			req->args.stk_modmap_map.setget,
			req->args.stk_modmap_map.mod_in,
			req->args.stk_modmap_map.port_in,
			req->args.stk_modmap_map.mod_out,
			req->args.stk_modmap_map.port_out);
		break;
	case BCM_ASYNC_ENTRY_STK_MODMAP_REGISTER:
		rv = bcm_stk_modmap_register(
			req->args.stk_modmap_register.unit,
			req->args.stk_modmap_register.func);
		break;
	case BCM_ASYNC_ENTRY_STK_MODMAP_UNREGISTER:
		rv = bcm_stk_modmap_unregister(
			req->args.stk_modmap_unregister.unit);
		break;
	case BCM_ASYNC_ENTRY_STK_MODPORT_ADD:
		rv = bcm_stk_modport_add(
			req->args.stk_modport_add.unit,
			req->args.stk_modport_add.modid,
			req->args.stk_modport_add.port);
		break;
	case BCM_ASYNC_ENTRY_STK_MODPORT_CLEAR:
		rv = bcm_stk_modport_clear(
			req->args.stk_modport_clear.unit,
			req->args.stk_modport_clear.modid);
		break;
	case BCM_ASYNC_ENTRY_STK_MODPORT_CLEAR_ALL:
		rv = bcm_stk_modport_clear_all(
			req->args.stk_modport_clear_all.unit);
		break;
	case BCM_ASYNC_ENTRY_STK_MODPORT_DELETE:
		rv = bcm_stk_modport_delete(
			req->args.stk_modport_delete.unit,
			req->args.stk_modport_delete.modid,
			req->args.stk_modport_delete.port);
		break;
	case BCM_ASYNC_ENTRY_STK_MODPORT_GET:
		rv = bcm_stk_modport_get(
			req->args.stk_modport_get.unit,
			req->args.stk_modport_get.modid,
			req->args.stk_modport_get.port);
		break;
	case BCM_ASYNC_ENTRY_STK_MODPORT_GET_ALL:
		rv = bcm_stk_modport_get_all(
			req->args.stk_modport_get_all.unit,
			req->args.stk_modport_get_all.modid,
			req->args.stk_modport_get_all.port_max,
			req->args.stk_modport_get_all.port_array,
			req->args.stk_modport_get_all.port_count);
		break;
	case BCM_ASYNC_ENTRY_STK_MODPORT_SET:
		rv = bcm_stk_modport_set(
			req->args.stk_modport_set.unit,
			req->args.stk_modport_set.modid,
			req->args.stk_modport_set.port);
		break;
	case BCM_ASYNC_ENTRY_STK_MODULE_ENABLE:
		rv = bcm_stk_module_enable(
			req->args.stk_module_enable.unit,
			req->args.stk_module_enable.modid,
			req->args.stk_module_enable.nports,
			req->args.stk_module_enable.enable);
		break;
	case BCM_ASYNC_ENTRY_STK_MODULE_PROTOCOL_GET:
		rv = bcm_stk_module_protocol_get(
			req->args.stk_module_protocol_get.unit,
			req->args.stk_module_protocol_get.modid,
			req->args.stk_module_protocol_get.protocol);
		break;
	case BCM_ASYNC_ENTRY_STK_MODULE_PROTOCOL_SET:
		rv = bcm_stk_module_protocol_set(
			req->args.stk_module_protocol_set.unit,
			req->args.stk_module_protocol_set.modid,
			req->args.stk_module_protocol_set.protocol);
		break;
	case BCM_ASYNC_ENTRY_STK_MY_MODID_GET:
		rv = bcm_stk_my_modid_get(
			req->args.stk_my_modid_get.unit,
			req->args.stk_my_modid_get.my_modid);
		break;
	case BCM_ASYNC_ENTRY_STK_MY_MODID_SET:
		rv = bcm_stk_my_modid_set(
			req->args.stk_my_modid_set.unit,
			req->args.stk_my_modid_set.my_modid);
		break;
	case BCM_ASYNC_ENTRY_STK_PBMP_GET:
		rv = bcm_stk_pbmp_get(
			req->args.stk_pbmp_get.unit,
			req->args.stk_pbmp_get.cur_pbm,
			req->args.stk_pbmp_get.inactive_pbm);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_GET:
		rv = bcm_stk_port_get(
			req->args.stk_port_get.unit,
			req->args.stk_port_get.port,
			req->args.stk_port_get.flags);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODMAP_GROUP_GET:
		rv = bcm_stk_port_modmap_group_get(
			req->args.stk_port_modmap_group_get.unit,
			req->args.stk_port_modmap_group_get.port,
			req->args.stk_port_modmap_group_get.group);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODMAP_GROUP_MAX_GET:
		rv = bcm_stk_port_modmap_group_max_get(
			req->args.stk_port_modmap_group_max_get.unit,
			req->args.stk_port_modmap_group_max_get.max_group);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODMAP_GROUP_SET:
		rv = bcm_stk_port_modmap_group_set(
			req->args.stk_port_modmap_group_set.unit,
			req->args.stk_port_modmap_group_set.port,
			req->args.stk_port_modmap_group_set.group);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODPORT_ADD:
		rv = bcm_stk_port_modport_add(
			req->args.stk_port_modport_add.unit,
			req->args.stk_port_modport_add.ing_port,
			req->args.stk_port_modport_add.dest_modid,
			req->args.stk_port_modport_add.dest_port);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODPORT_CLEAR:
		rv = bcm_stk_port_modport_clear(
			req->args.stk_port_modport_clear.unit,
			req->args.stk_port_modport_clear.ing_port,
			req->args.stk_port_modport_clear.dest_modid);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODPORT_CLEAR_ALL:
		rv = bcm_stk_port_modport_clear_all(
			req->args.stk_port_modport_clear_all.unit,
			req->args.stk_port_modport_clear_all.ing_port);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODPORT_DELETE:
		rv = bcm_stk_port_modport_delete(
			req->args.stk_port_modport_delete.unit,
			req->args.stk_port_modport_delete.ing_port,
			req->args.stk_port_modport_delete.dest_modid,
			req->args.stk_port_modport_delete.dest_port);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODPORT_GET:
		rv = bcm_stk_port_modport_get(
			req->args.stk_port_modport_get.unit,
			req->args.stk_port_modport_get.ing_port,
			req->args.stk_port_modport_get.dest_modid,
			req->args.stk_port_modport_get.dest_port);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODPORT_GET_ALL:
		rv = bcm_stk_port_modport_get_all(
			req->args.stk_port_modport_get_all.unit,
			req->args.stk_port_modport_get_all.ing_port,
			req->args.stk_port_modport_get_all.dest_modid,
			req->args.stk_port_modport_get_all.dest_port_max,
			req->args.stk_port_modport_get_all.dest_port_array,
			req->args.stk_port_modport_get_all.dest_port_count);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_MODPORT_SET:
		rv = bcm_stk_port_modport_set(
			req->args.stk_port_modport_set.unit,
			req->args.stk_port_modport_set.ing_port,
			req->args.stk_port_modport_set.dest_modid,
			req->args.stk_port_modport_set.dest_port);
		break;
	case BCM_ASYNC_ENTRY_STK_PORT_SET:
		rv = bcm_stk_port_set(
			req->args.stk_port_set.unit,
			req->args.stk_port_set.port,
			req->args.stk_port_set.flags);
		break;
	case BCM_ASYNC_ENTRY_STK_SL_SIMPLEX_COUNT_GET:
		rv = bcm_stk_sl_simplex_count_get(
			req->args.stk_sl_simplex_count_get.unit,
			req->args.stk_sl_simplex_count_get.count);
		break;
	case BCM_ASYNC_ENTRY_STK_SL_SIMPLEX_COUNT_SET:
		rv = bcm_stk_sl_simplex_count_set(
			req->args.stk_sl_simplex_count_set.unit,
			req->args.stk_sl_simplex_count_set.count);
		break;
	case BCM_ASYNC_ENTRY_STK_UCBITMAP_DEL:
		rv = bcm_stk_ucbitmap_del(
			req->args.stk_ucbitmap_del.unit,
			req->args.stk_ucbitmap_del.port,
			req->args.stk_ucbitmap_del.modid,
			req->args.stk_ucbitmap_del.pbmp);
		break;
	case BCM_ASYNC_ENTRY_STK_UCBITMAP_GET:
		rv = bcm_stk_ucbitmap_get(
			req->args.stk_ucbitmap_get.unit,
			req->args.stk_ucbitmap_get.port,
			req->args.stk_ucbitmap_get.modid,
			req->args.stk_ucbitmap_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_STK_UCBITMAP_SET:
		rv = bcm_stk_ucbitmap_set(
			req->args.stk_ucbitmap_set.unit,
			req->args.stk_ucbitmap_set.port,
			req->args.stk_ucbitmap_set.modid,
			req->args.stk_ucbitmap_set.pbmp);
		break;
	case BCM_ASYNC_ENTRY_STK_UPDATE_CALLBACK_REGISTER:
		rv = bcm_stk_update_callback_register(
			req->args.stk_update_callback_register.unit,
			req->args.stk_update_callback_register.cb,
			req->args.stk_update_callback_register.cookie);
		break;
	case BCM_ASYNC_ENTRY_STK_UPDATE_CALLBACK_UNREGISTER:
		rv = bcm_stk_update_callback_unregister(
			req->args.stk_update_callback_unregister.unit,
			req->args.stk_update_callback_unregister.cb,
			req->args.stk_update_callback_unregister.cookie);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_CLEANUP:
		rv = bcm_subport_cleanup(
			req->args.subport_cleanup.unit);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_GROUP_CREATE:
		rv = bcm_subport_group_create(
			req->args.subport_group_create.unit,
			req->args.subport_group_create.config,
			req->args.subport_group_create.group);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_GROUP_DESTROY:
		rv = bcm_subport_group_destroy(
			req->args.subport_group_destroy.unit,
			req->args.subport_group_destroy.group);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_GROUP_GET:
		rv = bcm_subport_group_get(
			req->args.subport_group_get.unit,
			req->args.subport_group_get.group,
			req->args.subport_group_get.config);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_INIT:
		rv = bcm_subport_init(
			req->args.subport_init.unit);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_PORT_ADD:
		rv = bcm_subport_port_add(
			req->args.subport_port_add.unit,
			req->args.subport_port_add.config,
			req->args.subport_port_add.port);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_PORT_DELETE:
		rv = bcm_subport_port_delete(
			req->args.subport_port_delete.unit,
			req->args.subport_port_delete.port);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_PORT_GET:
		rv = bcm_subport_port_get(
			req->args.subport_port_get.unit,
			req->args.subport_port_get.port,
			req->args.subport_port_get.config);
		break;
	case BCM_ASYNC_ENTRY_SUBPORT_PORT_TRAVERSE:
		rv = bcm_subport_port_traverse(
			req->args.subport_port_traverse.unit,
			req->args.subport_port_traverse.cb,
			req->args.subport_port_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_SWITCH_CONTROL_GET:
		rv = bcm_switch_control_get(
			req->args.switch_control_get.unit,
			req->args.switch_control_get.type,
			req->args.switch_control_get.arg);
		break;
	case BCM_ASYNC_ENTRY_SWITCH_CONTROL_PORT_GET:
		rv = bcm_switch_control_port_get(
			req->args.switch_control_port_get.unit,
			req->args.switch_control_port_get.port,
			req->args.switch_control_port_get.type,
			req->args.switch_control_port_get.arg);
		break;
	case BCM_ASYNC_ENTRY_SWITCH_CONTROL_PORT_SET:
		rv = bcm_switch_control_port_set(
			req->args.switch_control_port_set.unit,
			req->args.switch_control_port_set.port,
			req->args.switch_control_port_set.type,
			req->args.switch_control_port_set.arg);
		break;
	case BCM_ASYNC_ENTRY_SWITCH_CONTROL_SET:
		rv = bcm_switch_control_set(
			req->args.switch_control_set.unit,
			req->args.switch_control_set.type,
			req->args.switch_control_set.arg);
		break;
	case BCM_ASYNC_ENTRY_TIME_CAPTURE_GET:
		rv = bcm_time_capture_get(
			req->args.time_capture_get.unit,
			req->args.time_capture_get.intf_id,
			req->args.time_capture_get.time);
		break;
	case BCM_ASYNC_ENTRY_TIME_DEINIT:
		rv = bcm_time_deinit(
			req->args.time_deinit.unit);
		break;
	case BCM_ASYNC_ENTRY_TIME_HEARTBEAT_ENABLE_GET:
		rv = bcm_time_heartbeat_enable_get(
			req->args.time_heartbeat_enable_get.unit,
			req->args.time_heartbeat_enable_get.id,
			req->args.time_heartbeat_enable_get.enable);
		break;
	case BCM_ASYNC_ENTRY_TIME_HEARTBEAT_ENABLE_SET:
		rv = bcm_time_heartbeat_enable_set(
			req->args.time_heartbeat_enable_set.unit,
			req->args.time_heartbeat_enable_set.id,
			req->args.time_heartbeat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_TIME_HEARTBEAT_REGISTER:
		rv = bcm_time_heartbeat_register(
			req->args.time_heartbeat_register.unit,
			req->args.time_heartbeat_register.id,
			req->args.time_heartbeat_register.f,
			req->args.time_heartbeat_register.user_data);
		break;
	case BCM_ASYNC_ENTRY_TIME_HEARTBEAT_UNREGISTER:
		rv = bcm_time_heartbeat_unregister(
			req->args.time_heartbeat_unregister.unit,
			req->args.time_heartbeat_unregister.id);
		break;
	case BCM_ASYNC_ENTRY_TIME_INIT:
		rv = bcm_time_init(
			req->args.time_init.unit);
		break;
	case BCM_ASYNC_ENTRY_TIME_INTERFACE_ADD:
		rv = bcm_time_interface_add(
			req->args.time_interface_add.unit,
			req->args.time_interface_add.intf);
		break;
	case BCM_ASYNC_ENTRY_TIME_INTERFACE_DELETE:
		rv = bcm_time_interface_delete(
			req->args.time_interface_delete.unit,
			req->args.time_interface_delete.intf_id);
		break;
	case BCM_ASYNC_ENTRY_TIME_INTERFACE_DELETE_ALL:
		rv = bcm_time_interface_delete_all(
			req->args.time_interface_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_TIME_INTERFACE_GET:
		rv = bcm_time_interface_get(
			req->args.time_interface_get.unit,
			req->args.time_interface_get.intf);
		break;
	case BCM_ASYNC_ENTRY_TIME_INTERFACE_TRAVERSE:
		rv = bcm_time_interface_traverse(
			req->args.time_interface_traverse.unit,
			req->args.time_interface_traverse.cb,
			req->args.time_interface_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_TOPO_PORT_GET:
		rv = bcm_topo_port_get(
			req->args.topo_port_get.unit,
			req->args.topo_port_get.dest_modid,
			req->args.topo_port_get.exit_port);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_BITMAP_EXPAND:
		rv = bcm_trunk_bitmap_expand(
			req->args.trunk_bitmap_expand.unit,
			req->args.trunk_bitmap_expand.pbmp_ptr);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_CHIP_INFO_GET:
		rv = bcm_trunk_chip_info_get(
			req->args.trunk_chip_info_get.unit,
			req->args.trunk_chip_info_get.ta_info);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_CREATE:
		rv = bcm_trunk_create(
			req->args.trunk_create.unit,
			req->args.trunk_create.tid);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_CREATE_ID:
		rv = bcm_trunk_create_id(
			req->args.trunk_create_id.unit,
			req->args.trunk_create_id.tid);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_DESTROY:
		rv = bcm_trunk_destroy(
			req->args.trunk_destroy.unit,
			req->args.trunk_destroy.tid);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_DETACH:
		rv = bcm_trunk_detach(
			req->args.trunk_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_EGRESS_GET:
		rv = bcm_trunk_egress_get(
			req->args.trunk_egress_get.unit,
			req->args.trunk_egress_get.tid,
			req->args.trunk_egress_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_EGRESS_SET:
		rv = bcm_trunk_egress_set(
			req->args.trunk_egress_set.unit,
			req->args.trunk_egress_set.tid,
			req->args.trunk_egress_set.pbmp);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_FAILOVER_GET:
		rv = bcm_trunk_failover_get(
			req->args.trunk_failover_get.unit,
			req->args.trunk_failover_get.tid,
			req->args.trunk_failover_get.failport,
			req->args.trunk_failover_get.psc,
			req->args.trunk_failover_get.flags,
			req->args.trunk_failover_get.array_size,
			req->args.trunk_failover_get.fail_to_array,
			req->args.trunk_failover_get.array_count);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_FAILOVER_SET:
		rv = bcm_trunk_failover_set(
			req->args.trunk_failover_set.unit,
			req->args.trunk_failover_set.tid,
			req->args.trunk_failover_set.failport,
			req->args.trunk_failover_set.psc,
			req->args.trunk_failover_set.flags,
			req->args.trunk_failover_set.count,
			req->args.trunk_failover_set.fail_to_array);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_FIND:
		rv = bcm_trunk_find(
			req->args.trunk_find.unit,
			req->args.trunk_find.modid,
			req->args.trunk_find.port,
			req->args.trunk_find.tid);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_GET:
		rv = bcm_trunk_get(
			req->args.trunk_get.unit,
			req->args.trunk_get.tid,
			req->args.trunk_get.t_data);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_INIT:
		rv = bcm_trunk_init(
			req->args.trunk_init.unit);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_MCAST_JOIN:
		rv = bcm_trunk_mcast_join(
			req->args.trunk_mcast_join.unit,
			req->args.trunk_mcast_join.tid,
			req->args.trunk_mcast_join.vid,
			req->args.trunk_mcast_join.mac);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_IPMC_GET:
		rv = bcm_trunk_override_ipmc_get(
			req->args.trunk_override_ipmc_get.unit,
			req->args.trunk_override_ipmc_get.port,
			req->args.trunk_override_ipmc_get.tid,
			req->args.trunk_override_ipmc_get.idx,
			req->args.trunk_override_ipmc_get.enable);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_IPMC_SET:
		rv = bcm_trunk_override_ipmc_set(
			req->args.trunk_override_ipmc_set.unit,
			req->args.trunk_override_ipmc_set.port,
			req->args.trunk_override_ipmc_set.tid,
			req->args.trunk_override_ipmc_set.idx,
			req->args.trunk_override_ipmc_set.enable);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_MCAST_GET:
		rv = bcm_trunk_override_mcast_get(
			req->args.trunk_override_mcast_get.unit,
			req->args.trunk_override_mcast_get.port,
			req->args.trunk_override_mcast_get.tid,
			req->args.trunk_override_mcast_get.idx,
			req->args.trunk_override_mcast_get.enable);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_MCAST_SET:
		rv = bcm_trunk_override_mcast_set(
			req->args.trunk_override_mcast_set.unit,
			req->args.trunk_override_mcast_set.port,
			req->args.trunk_override_mcast_set.tid,
			req->args.trunk_override_mcast_set.idx,
			req->args.trunk_override_mcast_set.enable);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_UCAST_GET:
		rv = bcm_trunk_override_ucast_get(
			req->args.trunk_override_ucast_get.unit,
			req->args.trunk_override_ucast_get.port,
			req->args.trunk_override_ucast_get.tid,
			req->args.trunk_override_ucast_get.modid,
			req->args.trunk_override_ucast_get.enable);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_UCAST_SET:
		rv = bcm_trunk_override_ucast_set(
			req->args.trunk_override_ucast_set.unit,
			req->args.trunk_override_ucast_set.port,
			req->args.trunk_override_ucast_set.tid,
			req->args.trunk_override_ucast_set.modid,
			req->args.trunk_override_ucast_set.enable);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_VLAN_GET:
		rv = bcm_trunk_override_vlan_get(
			req->args.trunk_override_vlan_get.unit,
			req->args.trunk_override_vlan_get.port,
			req->args.trunk_override_vlan_get.tid,
			req->args.trunk_override_vlan_get.vid,
			req->args.trunk_override_vlan_get.enable);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_OVERRIDE_VLAN_SET:
		rv = bcm_trunk_override_vlan_set(
			req->args.trunk_override_vlan_set.unit,
			req->args.trunk_override_vlan_set.port,
			req->args.trunk_override_vlan_set.tid,
			req->args.trunk_override_vlan_set.vid,
			req->args.trunk_override_vlan_set.enable);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_POOL_GET:
		rv = bcm_trunk_pool_get(
			req->args.trunk_pool_get.unit,
			req->args.trunk_pool_get.port,
			req->args.trunk_pool_get.tid,
			req->args.trunk_pool_get.size,
			req->args.trunk_pool_get.weights);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_POOL_SET:
		rv = bcm_trunk_pool_set(
			req->args.trunk_pool_set.unit,
			req->args.trunk_pool_set.port,
			req->args.trunk_pool_set.tid,
			req->args.trunk_pool_set.size,
			req->args.trunk_pool_set.weights);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_PSC_GET:
		rv = bcm_trunk_psc_get(
			req->args.trunk_psc_get.unit,
			req->args.trunk_psc_get.tid,
			req->args.trunk_psc_get.psc);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_PSC_SET:
		rv = bcm_trunk_psc_set(
			req->args.trunk_psc_set.unit,
			req->args.trunk_psc_set.tid,
			req->args.trunk_psc_set.psc);
		break;
	case BCM_ASYNC_ENTRY_TRUNK_SET:
		rv = bcm_trunk_set(
			req->args.trunk_set.unit,
			req->args.trunk_set.tid,
			req->args.trunk_set.add_info);
		break;
#ifdef	INCLUDE_L3
	case BCM_ASYNC_ENTRY_TUNNEL_CONFIG_GET:
		rv = bcm_tunnel_config_get(
			req->args.tunnel_config_get.unit,
			req->args.tunnel_config_get.tconfig);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_CONFIG_SET:
		rv = bcm_tunnel_config_set(
			req->args.tunnel_config_set.unit,
			req->args.tunnel_config_set.tconfig);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_CREATE:
		rv = bcm_tunnel_dscp_map_create(
			req->args.tunnel_dscp_map_create.unit,
			req->args.tunnel_dscp_map_create.flags,
			req->args.tunnel_dscp_map_create.dscp_map_id);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_DESTROY:
		rv = bcm_tunnel_dscp_map_destroy(
			req->args.tunnel_dscp_map_destroy.unit,
			req->args.tunnel_dscp_map_destroy.dscp_map_id);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_GET:
		rv = bcm_tunnel_dscp_map_get(
			req->args.tunnel_dscp_map_get.unit,
			req->args.tunnel_dscp_map_get.dscp_map_id,
			req->args.tunnel_dscp_map_get.dscp_map);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_PORT_GET:
		rv = bcm_tunnel_dscp_map_port_get(
			req->args.tunnel_dscp_map_port_get.unit,
			req->args.tunnel_dscp_map_port_get.port,
			req->args.tunnel_dscp_map_port_get.dscp_map);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_PORT_SET:
		rv = bcm_tunnel_dscp_map_port_set(
			req->args.tunnel_dscp_map_port_set.unit,
			req->args.tunnel_dscp_map_port_set.port,
			req->args.tunnel_dscp_map_port_set.dscp_map);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_DSCP_MAP_SET:
		rv = bcm_tunnel_dscp_map_set(
			req->args.tunnel_dscp_map_set.unit,
			req->args.tunnel_dscp_map_set.dscp_map_id,
			req->args.tunnel_dscp_map_set.dscp_map);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_INITIATOR_CLEAR:
		rv = bcm_tunnel_initiator_clear(
			req->args.tunnel_initiator_clear.unit,
			req->args.tunnel_initiator_clear.intf);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_INITIATOR_GET:
		rv = bcm_tunnel_initiator_get(
			req->args.tunnel_initiator_get.unit,
			req->args.tunnel_initiator_get.intf,
			req->args.tunnel_initiator_get.tunnel);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_INITIATOR_SET:
		rv = bcm_tunnel_initiator_set(
			req->args.tunnel_initiator_set.unit,
			req->args.tunnel_initiator_set.intf,
			req->args.tunnel_initiator_set.tunnel);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_ADD:
		rv = bcm_tunnel_terminator_add(
			req->args.tunnel_terminator_add.unit,
			req->args.tunnel_terminator_add.info);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_DELETE:
		rv = bcm_tunnel_terminator_delete(
			req->args.tunnel_terminator_delete.unit,
			req->args.tunnel_terminator_delete.info);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_GET:
		rv = bcm_tunnel_terminator_get(
			req->args.tunnel_terminator_get.unit,
			req->args.tunnel_terminator_get.info);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_UPDATE:
		rv = bcm_tunnel_terminator_update(
			req->args.tunnel_terminator_update.unit,
			req->args.tunnel_terminator_update.info);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_VLAN_GET:
		rv = bcm_tunnel_terminator_vlan_get(
			req->args.tunnel_terminator_vlan_get.unit,
			req->args.tunnel_terminator_vlan_get.tunnel,
			req->args.tunnel_terminator_vlan_get.vlan_vec);
		break;
	case BCM_ASYNC_ENTRY_TUNNEL_TERMINATOR_VLAN_SET:
		rv = bcm_tunnel_terminator_vlan_set(
			req->args.tunnel_terminator_vlan_set.unit,
			req->args.tunnel_terminator_vlan_set.tunnel,
			req->args.tunnel_terminator_vlan_set.vlan_vec);
		break;
#endif	/* INCLUDE_L3 */
	case BCM_ASYNC_ENTRY_TX:
		rv = bcm_tx(
			req->args.tx.unit,
			req->args.tx.tx_pkt,
			req->args.tx.cookie);
		break;
	case BCM_ASYNC_ENTRY_TX_ARRAY:
		rv = bcm_tx_array(
			req->args.tx_array.unit,
			req->args.tx_array.pkt,
			req->args.tx_array.count,
			req->args.tx_array.all_done_cb,
			req->args.tx_array.cookie);
		break;
#ifdef	BCM_RPC_SUPPORT
	case BCM_ASYNC_ENTRY_TX_CPU_TUNNEL:
		rv = bcm_tx_cpu_tunnel(
			req->args.tx_cpu_tunnel.pkt,
			req->args.tx_cpu_tunnel.dest_unit,
			req->args.tx_cpu_tunnel.remote_port,
			req->args.tx_cpu_tunnel.flags,
			req->args.tx_cpu_tunnel.mode);
		break;
	case BCM_ASYNC_ENTRY_TX_CPU_TUNNEL_GET:
		rv = bcm_tx_cpu_tunnel_get(
			req->args.tx_cpu_tunnel_get.f);
		break;
	case BCM_ASYNC_ENTRY_TX_CPU_TUNNEL_SET:
		rv = bcm_tx_cpu_tunnel_set(
			req->args.tx_cpu_tunnel_set.f);
		break;
#endif	/* BCM_RPC_SUPPORT */
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_TX_DV_DUMP:
		rv = bcm_tx_dv_dump(
			req->args.tx_dv_dump.unit,
			req->args.tx_dv_dump.dv_p);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_TX_INIT:
		rv = bcm_tx_init(
			req->args.tx_init.unit);
		break;
	case BCM_ASYNC_ENTRY_TX_LIST:
		rv = bcm_tx_list(
			req->args.tx_list.unit,
			req->args.tx_list.pkt,
			req->args.tx_list.all_done_cb,
			req->args.tx_list.cookie);
		break;
	case BCM_ASYNC_ENTRY_TX_PKT_L2_MAP:
		rv = bcm_tx_pkt_l2_map(
			req->args.tx_pkt_l2_map.unit,
			req->args.tx_pkt_l2_map.pkt,
			req->args.tx_pkt_l2_map.dest_mac,
			req->args.tx_pkt_l2_map.vid);
		break;
	case BCM_ASYNC_ENTRY_TX_PKT_SETUP:
		rv = bcm_tx_pkt_setup(
			req->args.tx_pkt_setup.unit,
			req->args.tx_pkt_setup.tx_pkt);
		break;
#ifdef	BROADCOM_DEBUG
	case BCM_ASYNC_ENTRY_TX_SHOW:
		rv = bcm_tx_show(
			req->args.tx_show.unit);
		break;
#endif	/* BROADCOM_DEBUG */
	case BCM_ASYNC_ENTRY_VLAN_BLOCK_GET:
		rv = bcm_vlan_block_get(
			req->args.vlan_block_get.unit,
			req->args.vlan_block_get.vlan,
			req->args.vlan_block_get.vlan_block);
		break;
	case BCM_ASYNC_ENTRY_VLAN_BLOCK_SET:
		rv = bcm_vlan_block_set(
			req->args.vlan_block_set.unit,
			req->args.vlan_block_set.vlan,
			req->args.vlan_block_set.vlan_block);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CONTROL_GET:
		rv = bcm_vlan_control_get(
			req->args.vlan_control_get.unit,
			req->args.vlan_control_get.type,
			req->args.vlan_control_get.arg);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CONTROL_PORT_GET:
		rv = bcm_vlan_control_port_get(
			req->args.vlan_control_port_get.unit,
			req->args.vlan_control_port_get.port,
			req->args.vlan_control_port_get.type,
			req->args.vlan_control_port_get.arg);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CONTROL_PORT_SET:
		rv = bcm_vlan_control_port_set(
			req->args.vlan_control_port_set.unit,
			req->args.vlan_control_port_set.port,
			req->args.vlan_control_port_set.type,
			req->args.vlan_control_port_set.arg);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CONTROL_SET:
		rv = bcm_vlan_control_set(
			req->args.vlan_control_set.unit,
			req->args.vlan_control_set.type,
			req->args.vlan_control_set.arg);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CONTROL_VLAN_GET:
		rv = bcm_vlan_control_vlan_get(
			req->args.vlan_control_vlan_get.unit,
			req->args.vlan_control_vlan_get.vlan,
			req->args.vlan_control_vlan_get.control);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CONTROL_VLAN_SET:
		rv = bcm_vlan_control_vlan_set(
			req->args.vlan_control_vlan_set.unit,
			req->args.vlan_control_vlan_set.vlan,
			req->args.vlan_control_vlan_set.control);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CREATE:
		rv = bcm_vlan_create(
			req->args.vlan_create.unit,
			req->args.vlan_create.vid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CROSS_CONNECT_ADD:
		rv = bcm_vlan_cross_connect_add(
			req->args.vlan_cross_connect_add.unit,
			req->args.vlan_cross_connect_add.outer_vlan,
			req->args.vlan_cross_connect_add.inner_vlan,
			req->args.vlan_cross_connect_add.port_1,
			req->args.vlan_cross_connect_add.port_2);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CROSS_CONNECT_DELETE:
		rv = bcm_vlan_cross_connect_delete(
			req->args.vlan_cross_connect_delete.unit,
			req->args.vlan_cross_connect_delete.outer_vlan,
			req->args.vlan_cross_connect_delete.inner_vlan);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CROSS_CONNECT_DELETE_ALL:
		rv = bcm_vlan_cross_connect_delete_all(
			req->args.vlan_cross_connect_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_CROSS_CONNECT_TRAVERSE:
		rv = bcm_vlan_cross_connect_traverse(
			req->args.vlan_cross_connect_traverse.unit,
			req->args.vlan_cross_connect_traverse.cb,
			req->args.vlan_cross_connect_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DEFAULT_GET:
		rv = bcm_vlan_default_get(
			req->args.vlan_default_get.unit,
			req->args.vlan_default_get.vid_ptr);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DEFAULT_SET:
		rv = bcm_vlan_default_set(
			req->args.vlan_default_set.unit,
			req->args.vlan_default_set.vid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DESTROY:
		rv = bcm_vlan_destroy(
			req->args.vlan_destroy.unit,
			req->args.vlan_destroy.vid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DESTROY_ALL:
		rv = bcm_vlan_destroy_all(
			req->args.vlan_destroy_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_ADD:
		rv = bcm_vlan_dtag_add(
			req->args.vlan_dtag_add.unit,
			req->args.vlan_dtag_add.port,
			req->args.vlan_dtag_add.old_vid,
			req->args.vlan_dtag_add.new_vid,
			req->args.vlan_dtag_add.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_DELETE:
		rv = bcm_vlan_dtag_delete(
			req->args.vlan_dtag_delete.unit,
			req->args.vlan_dtag_delete.port,
			req->args.vlan_dtag_delete.old_vid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_DELETE_ALL:
		rv = bcm_vlan_dtag_delete_all(
			req->args.vlan_dtag_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_GET:
		rv = bcm_vlan_dtag_get(
			req->args.vlan_dtag_get.unit,
			req->args.vlan_dtag_get.port,
			req->args.vlan_dtag_get.old_vid,
			req->args.vlan_dtag_get.new_vid,
			req->args.vlan_dtag_get.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_ADD:
		rv = bcm_vlan_dtag_range_add(
			req->args.vlan_dtag_range_add.unit,
			req->args.vlan_dtag_range_add.port,
			req->args.vlan_dtag_range_add.old_vid_low,
			req->args.vlan_dtag_range_add.old_vid_high,
			req->args.vlan_dtag_range_add.new_vid,
			req->args.vlan_dtag_range_add.int_prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_DELETE:
		rv = bcm_vlan_dtag_range_delete(
			req->args.vlan_dtag_range_delete.unit,
			req->args.vlan_dtag_range_delete.port,
			req->args.vlan_dtag_range_delete.old_vid_low,
			req->args.vlan_dtag_range_delete.old_vid_high);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_DELETE_ALL:
		rv = bcm_vlan_dtag_range_delete_all(
			req->args.vlan_dtag_range_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_GET:
		rv = bcm_vlan_dtag_range_get(
			req->args.vlan_dtag_range_get.unit,
			req->args.vlan_dtag_range_get.port,
			req->args.vlan_dtag_range_get.old_vid_low,
			req->args.vlan_dtag_range_get.old_vid_high,
			req->args.vlan_dtag_range_get.new_vid,
			req->args.vlan_dtag_range_get.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_RANGE_TRAVERSE:
		rv = bcm_vlan_dtag_range_traverse(
			req->args.vlan_dtag_range_traverse.unit,
			req->args.vlan_dtag_range_traverse.cb,
			req->args.vlan_dtag_range_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_DTAG_TRAVERSE:
		rv = bcm_vlan_dtag_traverse(
			req->args.vlan_dtag_traverse.unit,
			req->args.vlan_dtag_traverse.cb,
			req->args.vlan_dtag_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_GPORT_ADD:
		rv = bcm_vlan_gport_add(
			req->args.vlan_gport_add.unit,
			req->args.vlan_gport_add.vlan,
			req->args.vlan_gport_add.port,
			req->args.vlan_gport_add.is_untagged);
		break;
	case BCM_ASYNC_ENTRY_VLAN_GPORT_DELETE:
		rv = bcm_vlan_gport_delete(
			req->args.vlan_gport_delete.unit,
			req->args.vlan_gport_delete.vlan,
			req->args.vlan_gport_delete.port);
		break;
	case BCM_ASYNC_ENTRY_VLAN_GPORT_DELETE_ALL:
		rv = bcm_vlan_gport_delete_all(
			req->args.vlan_gport_delete_all.unit,
			req->args.vlan_gport_delete_all.vlan);
		break;
	case BCM_ASYNC_ENTRY_VLAN_GPORT_GET:
		rv = bcm_vlan_gport_get(
			req->args.vlan_gport_get.unit,
			req->args.vlan_gport_get.vlan,
			req->args.vlan_gport_get.port,
			req->args.vlan_gport_get.is_untagged);
		break;
	case BCM_ASYNC_ENTRY_VLAN_GPORT_GET_ALL:
		rv = bcm_vlan_gport_get_all(
			req->args.vlan_gport_get_all.unit,
			req->args.vlan_gport_get_all.vlan,
			req->args.vlan_gport_get_all.array_max,
			req->args.vlan_gport_get_all.gport_array,
			req->args.vlan_gport_get_all.is_untagged,
			req->args.vlan_gport_get_all.array_size);
		break;
	case BCM_ASYNC_ENTRY_VLAN_INIT:
		rv = bcm_vlan_init(
			req->args.vlan_init.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP4_ADD:
		rv = bcm_vlan_ip4_add(
			req->args.vlan_ip4_add.unit,
			req->args.vlan_ip4_add.ipaddr,
			req->args.vlan_ip4_add.netmask,
			req->args.vlan_ip4_add.vid,
			req->args.vlan_ip4_add.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP4_DELETE:
		rv = bcm_vlan_ip4_delete(
			req->args.vlan_ip4_delete.unit,
			req->args.vlan_ip4_delete.ipaddr,
			req->args.vlan_ip4_delete.netmask);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP4_DELETE_ALL:
		rv = bcm_vlan_ip4_delete_all(
			req->args.vlan_ip4_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP_ACTION_ADD:
		rv = bcm_vlan_ip_action_add(
			req->args.vlan_ip_action_add.unit,
			req->args.vlan_ip_action_add.vlan_ip,
			req->args.vlan_ip_action_add.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP_ACTION_DELETE:
		rv = bcm_vlan_ip_action_delete(
			req->args.vlan_ip_action_delete.unit,
			req->args.vlan_ip_action_delete.vlan_ip);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP_ACTION_DELETE_ALL:
		rv = bcm_vlan_ip_action_delete_all(
			req->args.vlan_ip_action_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP_ACTION_GET:
		rv = bcm_vlan_ip_action_get(
			req->args.vlan_ip_action_get.unit,
			req->args.vlan_ip_action_get.vlan_ip,
			req->args.vlan_ip_action_get.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP_ACTION_TRAVERSE:
		rv = bcm_vlan_ip_action_traverse(
			req->args.vlan_ip_action_traverse.unit,
			req->args.vlan_ip_action_traverse.cb,
			req->args.vlan_ip_action_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP_ADD:
		rv = bcm_vlan_ip_add(
			req->args.vlan_ip_add.unit,
			req->args.vlan_ip_add.vlan_ip);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP_DELETE:
		rv = bcm_vlan_ip_delete(
			req->args.vlan_ip_delete.unit,
			req->args.vlan_ip_delete.vlan_ip);
		break;
	case BCM_ASYNC_ENTRY_VLAN_IP_DELETE_ALL:
		rv = bcm_vlan_ip_delete_all(
			req->args.vlan_ip_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_LIST:
		rv = bcm_vlan_list(
			req->args.vlan_list.unit,
			req->args.vlan_list.listp,
			req->args.vlan_list.countp);
		break;
	case BCM_ASYNC_ENTRY_VLAN_LIST_BY_PBMP:
		rv = bcm_vlan_list_by_pbmp(
			req->args.vlan_list_by_pbmp.unit,
			req->args.vlan_list_by_pbmp.ports,
			req->args.vlan_list_by_pbmp.listp,
			req->args.vlan_list_by_pbmp.countp);
		break;
	case BCM_ASYNC_ENTRY_VLAN_LIST_DESTROY:
		rv = bcm_vlan_list_destroy(
			req->args.vlan_list_destroy.unit,
			req->args.vlan_list_destroy.list,
			req->args.vlan_list_destroy.count);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_ADD:
		rv = bcm_vlan_mac_action_add(
			req->args.vlan_mac_action_add.unit,
			req->args.vlan_mac_action_add.mac,
			req->args.vlan_mac_action_add.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_DELETE:
		rv = bcm_vlan_mac_action_delete(
			req->args.vlan_mac_action_delete.unit,
			req->args.vlan_mac_action_delete.mac);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_DELETE_ALL:
		rv = bcm_vlan_mac_action_delete_all(
			req->args.vlan_mac_action_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_GET:
		rv = bcm_vlan_mac_action_get(
			req->args.vlan_mac_action_get.unit,
			req->args.vlan_mac_action_get.mac,
			req->args.vlan_mac_action_get.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MAC_ACTION_TRAVERSE:
		rv = bcm_vlan_mac_action_traverse(
			req->args.vlan_mac_action_traverse.unit,
			req->args.vlan_mac_action_traverse.cb,
			req->args.vlan_mac_action_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MAC_ADD:
		rv = bcm_vlan_mac_add(
			req->args.vlan_mac_add.unit,
			req->args.vlan_mac_add.mac,
			req->args.vlan_mac_add.vid,
			req->args.vlan_mac_add.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MAC_DELETE:
		rv = bcm_vlan_mac_delete(
			req->args.vlan_mac_delete.unit,
			req->args.vlan_mac_delete.mac);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MAC_DELETE_ALL:
		rv = bcm_vlan_mac_delete_all(
			req->args.vlan_mac_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MCAST_FLOOD_GET:
		rv = bcm_vlan_mcast_flood_get(
			req->args.vlan_mcast_flood_get.unit,
			req->args.vlan_mcast_flood_get.vlan,
			req->args.vlan_mcast_flood_get.mode);
		break;
	case BCM_ASYNC_ENTRY_VLAN_MCAST_FLOOD_SET:
		rv = bcm_vlan_mcast_flood_set(
			req->args.vlan_mcast_flood_set.unit,
			req->args.vlan_mcast_flood_set.vlan,
			req->args.vlan_mcast_flood_set.mode);
		break;
	case BCM_ASYNC_ENTRY_VLAN_POLICER_GET:
		rv = bcm_vlan_policer_get(
			req->args.vlan_policer_get.unit,
			req->args.vlan_policer_get.vlan,
			req->args.vlan_policer_get.policer_id);
		break;
	case BCM_ASYNC_ENTRY_VLAN_POLICER_SET:
		rv = bcm_vlan_policer_set(
			req->args.vlan_policer_set.unit,
			req->args.vlan_policer_set.vlan,
			req->args.vlan_policer_set.policer_id);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_ADD:
		rv = bcm_vlan_port_add(
			req->args.vlan_port_add.unit,
			req->args.vlan_port_add.vid,
			req->args.vlan_port_add.pbmp,
			req->args.vlan_port_add.ubmp);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_CREATE:
		rv = bcm_vlan_port_create(
			req->args.vlan_port_create.unit,
			req->args.vlan_port_create.vlan_port);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_DELETE:
		rv = bcm_vlan_port_default_action_delete(
			req->args.vlan_port_default_action_delete.unit,
			req->args.vlan_port_default_action_delete.port);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_GET:
		rv = bcm_vlan_port_default_action_get(
			req->args.vlan_port_default_action_get.unit,
			req->args.vlan_port_default_action_get.port,
			req->args.vlan_port_default_action_get.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_DEFAULT_ACTION_SET:
		rv = bcm_vlan_port_default_action_set(
			req->args.vlan_port_default_action_set.unit,
			req->args.vlan_port_default_action_set.port,
			req->args.vlan_port_default_action_set.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_DESTROY:
		rv = bcm_vlan_port_destroy(
			req->args.vlan_port_destroy.unit,
			req->args.vlan_port_destroy.gport);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_DELETE:
		rv = bcm_vlan_port_egress_default_action_delete(
			req->args.vlan_port_egress_default_action_delete.unit,
			req->args.vlan_port_egress_default_action_delete.port);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_GET:
		rv = bcm_vlan_port_egress_default_action_get(
			req->args.vlan_port_egress_default_action_get.unit,
			req->args.vlan_port_egress_default_action_get.port,
			req->args.vlan_port_egress_default_action_get.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_EGRESS_DEFAULT_ACTION_SET:
		rv = bcm_vlan_port_egress_default_action_set(
			req->args.vlan_port_egress_default_action_set.unit,
			req->args.vlan_port_egress_default_action_set.port,
			req->args.vlan_port_egress_default_action_set.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_FIND:
		rv = bcm_vlan_port_find(
			req->args.vlan_port_find.unit,
			req->args.vlan_port_find.vlan_port);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_GET:
		rv = bcm_vlan_port_get(
			req->args.vlan_port_get.unit,
			req->args.vlan_port_get.vid,
			req->args.vlan_port_get.pbmp,
			req->args.vlan_port_get.ubmp);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_POLICER_GET:
		rv = bcm_vlan_port_policer_get(
			req->args.vlan_port_policer_get.unit,
			req->args.vlan_port_policer_get.vlan,
			req->args.vlan_port_policer_get.port,
			req->args.vlan_port_policer_get.policer_id);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_POLICER_SET:
		rv = bcm_vlan_port_policer_set(
			req->args.vlan_port_policer_set.unit,
			req->args.vlan_port_policer_set.vlan,
			req->args.vlan_port_policer_set.port,
			req->args.vlan_port_policer_set.policer_id);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_ADD:
		rv = bcm_vlan_port_protocol_action_add(
			req->args.vlan_port_protocol_action_add.unit,
			req->args.vlan_port_protocol_action_add.port,
			req->args.vlan_port_protocol_action_add.frame,
			req->args.vlan_port_protocol_action_add.ether,
			req->args.vlan_port_protocol_action_add.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_DELETE:
		rv = bcm_vlan_port_protocol_action_delete(
			req->args.vlan_port_protocol_action_delete.unit,
			req->args.vlan_port_protocol_action_delete.port,
			req->args.vlan_port_protocol_action_delete.frame,
			req->args.vlan_port_protocol_action_delete.ether);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_DELETE_ALL:
		rv = bcm_vlan_port_protocol_action_delete_all(
			req->args.vlan_port_protocol_action_delete_all.unit,
			req->args.vlan_port_protocol_action_delete_all.port);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_GET:
		rv = bcm_vlan_port_protocol_action_get(
			req->args.vlan_port_protocol_action_get.unit,
			req->args.vlan_port_protocol_action_get.port,
			req->args.vlan_port_protocol_action_get.frame,
			req->args.vlan_port_protocol_action_get.ether,
			req->args.vlan_port_protocol_action_get.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_PROTOCOL_ACTION_TRAVERSE:
		rv = bcm_vlan_port_protocol_action_traverse(
			req->args.vlan_port_protocol_action_traverse.unit,
			req->args.vlan_port_protocol_action_traverse.cb,
			req->args.vlan_port_protocol_action_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_PORT_REMOVE:
		rv = bcm_vlan_port_remove(
			req->args.vlan_port_remove.unit,
			req->args.vlan_port_remove.vid,
			req->args.vlan_port_remove.pbmp);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_ATTACH:
		rv = bcm_vlan_queue_map_attach(
			req->args.vlan_queue_map_attach.unit,
			req->args.vlan_queue_map_attach.vlan,
			req->args.vlan_queue_map_attach.qmid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_ATTACH_GET:
		rv = bcm_vlan_queue_map_attach_get(
			req->args.vlan_queue_map_attach_get.unit,
			req->args.vlan_queue_map_attach_get.vlan,
			req->args.vlan_queue_map_attach_get.qmid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_CREATE:
		rv = bcm_vlan_queue_map_create(
			req->args.vlan_queue_map_create.unit,
			req->args.vlan_queue_map_create.flags,
			req->args.vlan_queue_map_create.qmid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_DESTROY:
		rv = bcm_vlan_queue_map_destroy(
			req->args.vlan_queue_map_destroy.unit,
			req->args.vlan_queue_map_destroy.qmid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_DESTROY_ALL:
		rv = bcm_vlan_queue_map_destroy_all(
			req->args.vlan_queue_map_destroy_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_DETACH:
		rv = bcm_vlan_queue_map_detach(
			req->args.vlan_queue_map_detach.unit,
			req->args.vlan_queue_map_detach.vlan);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_DETACH_ALL:
		rv = bcm_vlan_queue_map_detach_all(
			req->args.vlan_queue_map_detach_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_GET:
		rv = bcm_vlan_queue_map_get(
			req->args.vlan_queue_map_get.unit,
			req->args.vlan_queue_map_get.qmid,
			req->args.vlan_queue_map_get.pkt_pri,
			req->args.vlan_queue_map_get.cfi,
			req->args.vlan_queue_map_get.queue,
			req->args.vlan_queue_map_get.color);
		break;
	case BCM_ASYNC_ENTRY_VLAN_QUEUE_MAP_SET:
		rv = bcm_vlan_queue_map_set(
			req->args.vlan_queue_map_set.unit,
			req->args.vlan_queue_map_set.qmid,
			req->args.vlan_queue_map_set.pkt_pri,
			req->args.vlan_queue_map_set.cfi,
			req->args.vlan_queue_map_set.queue,
			req->args.vlan_queue_map_set.color);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_ENABLE_SET:
		rv = bcm_vlan_stat_enable_set(
			req->args.vlan_stat_enable_set.unit,
			req->args.vlan_stat_enable_set.vlan,
			req->args.vlan_stat_enable_set.enable);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_GET:
		rv = bcm_vlan_stat_get(
			req->args.vlan_stat_get.unit,
			req->args.vlan_stat_get.vlan,
			req->args.vlan_stat_get.cos,
			req->args.vlan_stat_get.stat,
			req->args.vlan_stat_get.val);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_GET32:
		rv = bcm_vlan_stat_get32(
			req->args.vlan_stat_get32.unit,
			req->args.vlan_stat_get32.vlan,
			req->args.vlan_stat_get32.cos,
			req->args.vlan_stat_get32.stat,
			req->args.vlan_stat_get32.val);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_MULTI_GET:
		rv = bcm_vlan_stat_multi_get(
			req->args.vlan_stat_multi_get.unit,
			req->args.vlan_stat_multi_get.vlan,
			req->args.vlan_stat_multi_get.cos,
			req->args.vlan_stat_multi_get.nstat,
			req->args.vlan_stat_multi_get.stat_arr,
			req->args.vlan_stat_multi_get.value_arr);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_MULTI_GET32:
		rv = bcm_vlan_stat_multi_get32(
			req->args.vlan_stat_multi_get32.unit,
			req->args.vlan_stat_multi_get32.vlan,
			req->args.vlan_stat_multi_get32.cos,
			req->args.vlan_stat_multi_get32.nstat,
			req->args.vlan_stat_multi_get32.stat_arr,
			req->args.vlan_stat_multi_get32.value_arr);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_MULTI_SET:
		rv = bcm_vlan_stat_multi_set(
			req->args.vlan_stat_multi_set.unit,
			req->args.vlan_stat_multi_set.vlan,
			req->args.vlan_stat_multi_set.cos,
			req->args.vlan_stat_multi_set.nstat,
			req->args.vlan_stat_multi_set.stat_arr,
			req->args.vlan_stat_multi_set.value_arr);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_MULTI_SET32:
		rv = bcm_vlan_stat_multi_set32(
			req->args.vlan_stat_multi_set32.unit,
			req->args.vlan_stat_multi_set32.vlan,
			req->args.vlan_stat_multi_set32.cos,
			req->args.vlan_stat_multi_set32.nstat,
			req->args.vlan_stat_multi_set32.stat_arr,
			req->args.vlan_stat_multi_set32.value_arr);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_SET:
		rv = bcm_vlan_stat_set(
			req->args.vlan_stat_set.unit,
			req->args.vlan_stat_set.vlan,
			req->args.vlan_stat_set.cos,
			req->args.vlan_stat_set.stat,
			req->args.vlan_stat_set.val);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STAT_SET32:
		rv = bcm_vlan_stat_set32(
			req->args.vlan_stat_set32.unit,
			req->args.vlan_stat_set32.vlan,
			req->args.vlan_stat_set32.cos,
			req->args.vlan_stat_set32.stat,
			req->args.vlan_stat_set32.val);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STG_GET:
		rv = bcm_vlan_stg_get(
			req->args.vlan_stg_get.unit,
			req->args.vlan_stg_get.vid,
			req->args.vlan_stg_get.stg_ptr);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STG_SET:
		rv = bcm_vlan_stg_set(
			req->args.vlan_stg_set.unit,
			req->args.vlan_stg_set.vid,
			req->args.vlan_stg_set.stg);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STP_GET:
		rv = bcm_vlan_stp_get(
			req->args.vlan_stp_get.unit,
			req->args.vlan_stp_get.vid,
			req->args.vlan_stp_get.port,
			req->args.vlan_stp_get.stp_state);
		break;
	case BCM_ASYNC_ENTRY_VLAN_STP_SET:
		rv = bcm_vlan_stp_set(
			req->args.vlan_stp_set.unit,
			req->args.vlan_stp_set.vid,
			req->args.vlan_stp_set.port,
			req->args.vlan_stp_set.stp_state);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_ADD:
		rv = bcm_vlan_translate_action_add(
			req->args.vlan_translate_action_add.unit,
			req->args.vlan_translate_action_add.port,
			req->args.vlan_translate_action_add.key_type,
			req->args.vlan_translate_action_add.outer_vlan,
			req->args.vlan_translate_action_add.inner_vlan,
			req->args.vlan_translate_action_add.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_DELETE:
		rv = bcm_vlan_translate_action_delete(
			req->args.vlan_translate_action_delete.unit,
			req->args.vlan_translate_action_delete.port,
			req->args.vlan_translate_action_delete.key_type,
			req->args.vlan_translate_action_delete.outer_vlan,
			req->args.vlan_translate_action_delete.inner_vlan);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_GET:
		rv = bcm_vlan_translate_action_get(
			req->args.vlan_translate_action_get.unit,
			req->args.vlan_translate_action_get.port,
			req->args.vlan_translate_action_get.key_type,
			req->args.vlan_translate_action_get.outer_vlan,
			req->args.vlan_translate_action_get.inner_vlan,
			req->args.vlan_translate_action_get.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_ADD:
		rv = bcm_vlan_translate_action_range_add(
			req->args.vlan_translate_action_range_add.unit,
			req->args.vlan_translate_action_range_add.port,
			req->args.vlan_translate_action_range_add.outer_vlan_low,
			req->args.vlan_translate_action_range_add.outer_vlan_high,
			req->args.vlan_translate_action_range_add.inner_vlan_low,
			req->args.vlan_translate_action_range_add.inner_vlan_high,
			req->args.vlan_translate_action_range_add.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_DELETE:
		rv = bcm_vlan_translate_action_range_delete(
			req->args.vlan_translate_action_range_delete.unit,
			req->args.vlan_translate_action_range_delete.port,
			req->args.vlan_translate_action_range_delete.outer_vlan_low,
			req->args.vlan_translate_action_range_delete.outer_vlan_high,
			req->args.vlan_translate_action_range_delete.inner_vlan_low,
			req->args.vlan_translate_action_range_delete.inner_vlan_high);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_DELETE_ALL:
		rv = bcm_vlan_translate_action_range_delete_all(
			req->args.vlan_translate_action_range_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_GET:
		rv = bcm_vlan_translate_action_range_get(
			req->args.vlan_translate_action_range_get.unit,
			req->args.vlan_translate_action_range_get.port,
			req->args.vlan_translate_action_range_get.outer_vlan_low,
			req->args.vlan_translate_action_range_get.outer_vlan_high,
			req->args.vlan_translate_action_range_get.inner_vlan_low,
			req->args.vlan_translate_action_range_get.inner_vlan_high,
			req->args.vlan_translate_action_range_get.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_RANGE_TRAVERSE:
		rv = bcm_vlan_translate_action_range_traverse(
			req->args.vlan_translate_action_range_traverse.unit,
			req->args.vlan_translate_action_range_traverse.cb,
			req->args.vlan_translate_action_range_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ACTION_TRAVERSE:
		rv = bcm_vlan_translate_action_traverse(
			req->args.vlan_translate_action_traverse.unit,
			req->args.vlan_translate_action_traverse.cb,
			req->args.vlan_translate_action_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_ADD:
		rv = bcm_vlan_translate_add(
			req->args.vlan_translate_add.unit,
			req->args.vlan_translate_add.port,
			req->args.vlan_translate_add.old_vid,
			req->args.vlan_translate_add.new_vid,
			req->args.vlan_translate_add.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_DELETE:
		rv = bcm_vlan_translate_delete(
			req->args.vlan_translate_delete.unit,
			req->args.vlan_translate_delete.port,
			req->args.vlan_translate_delete.old_vid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_DELETE_ALL:
		rv = bcm_vlan_translate_delete_all(
			req->args.vlan_translate_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_ADD:
		rv = bcm_vlan_translate_egress_action_add(
			req->args.vlan_translate_egress_action_add.unit,
			req->args.vlan_translate_egress_action_add.port_class,
			req->args.vlan_translate_egress_action_add.outer_vlan,
			req->args.vlan_translate_egress_action_add.inner_vlan,
			req->args.vlan_translate_egress_action_add.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_DELETE:
		rv = bcm_vlan_translate_egress_action_delete(
			req->args.vlan_translate_egress_action_delete.unit,
			req->args.vlan_translate_egress_action_delete.port_class,
			req->args.vlan_translate_egress_action_delete.outer_vlan,
			req->args.vlan_translate_egress_action_delete.inner_vlan);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_GET:
		rv = bcm_vlan_translate_egress_action_get(
			req->args.vlan_translate_egress_action_get.unit,
			req->args.vlan_translate_egress_action_get.port_class,
			req->args.vlan_translate_egress_action_get.outer_vlan,
			req->args.vlan_translate_egress_action_get.inner_vlan,
			req->args.vlan_translate_egress_action_get.action);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ACTION_TRAVERSE:
		rv = bcm_vlan_translate_egress_action_traverse(
			req->args.vlan_translate_egress_action_traverse.unit,
			req->args.vlan_translate_egress_action_traverse.cb,
			req->args.vlan_translate_egress_action_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_ADD:
		rv = bcm_vlan_translate_egress_add(
			req->args.vlan_translate_egress_add.unit,
			req->args.vlan_translate_egress_add.port,
			req->args.vlan_translate_egress_add.old_vid,
			req->args.vlan_translate_egress_add.new_vid,
			req->args.vlan_translate_egress_add.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_DELETE:
		rv = bcm_vlan_translate_egress_delete(
			req->args.vlan_translate_egress_delete.unit,
			req->args.vlan_translate_egress_delete.port,
			req->args.vlan_translate_egress_delete.old_vid);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_DELETE_ALL:
		rv = bcm_vlan_translate_egress_delete_all(
			req->args.vlan_translate_egress_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_GET:
		rv = bcm_vlan_translate_egress_get(
			req->args.vlan_translate_egress_get.unit,
			req->args.vlan_translate_egress_get.port,
			req->args.vlan_translate_egress_get.old_vid,
			req->args.vlan_translate_egress_get.new_vid,
			req->args.vlan_translate_egress_get.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_EGRESS_TRAVERSE:
		rv = bcm_vlan_translate_egress_traverse(
			req->args.vlan_translate_egress_traverse.unit,
			req->args.vlan_translate_egress_traverse.cb,
			req->args.vlan_translate_egress_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_GET:
		rv = bcm_vlan_translate_get(
			req->args.vlan_translate_get.unit,
			req->args.vlan_translate_get.port,
			req->args.vlan_translate_get.old_vid,
			req->args.vlan_translate_get.new_vid,
			req->args.vlan_translate_get.prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_ADD:
		rv = bcm_vlan_translate_range_add(
			req->args.vlan_translate_range_add.unit,
			req->args.vlan_translate_range_add.port,
			req->args.vlan_translate_range_add.old_vid_low,
			req->args.vlan_translate_range_add.old_vid_high,
			req->args.vlan_translate_range_add.new_vid,
			req->args.vlan_translate_range_add.int_prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_DELETE:
		rv = bcm_vlan_translate_range_delete(
			req->args.vlan_translate_range_delete.unit,
			req->args.vlan_translate_range_delete.port,
			req->args.vlan_translate_range_delete.old_vid_low,
			req->args.vlan_translate_range_delete.old_vid_high);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_DELETE_ALL:
		rv = bcm_vlan_translate_range_delete_all(
			req->args.vlan_translate_range_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_GET:
		rv = bcm_vlan_translate_range_get(
			req->args.vlan_translate_range_get.unit,
			req->args.vlan_translate_range_get.port,
			req->args.vlan_translate_range_get.old_vid_low,
			req->args.vlan_translate_range_get.old_vid_high,
			req->args.vlan_translate_range_get.new_vid,
			req->args.vlan_translate_range_get.int_prio);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_RANGE_TRAVERSE:
		rv = bcm_vlan_translate_range_traverse(
			req->args.vlan_translate_range_traverse.unit,
			req->args.vlan_translate_range_traverse.cb,
			req->args.vlan_translate_range_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VLAN_TRANSLATE_TRAVERSE:
		rv = bcm_vlan_translate_traverse(
			req->args.vlan_translate_traverse.unit,
			req->args.vlan_translate_traverse.cb,
			req->args.vlan_translate_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_VPLS_BITMAP_ADD:
		rv = bcm_vpls_bitmap_add(
			req->args.vpls_bitmap_add.unit,
			req->args.vpls_bitmap_add.vc_label,
			req->args.vpls_bitmap_add.vid,
			req->args.vpls_bitmap_add.pbmp);
		break;
	case BCM_ASYNC_ENTRY_VPLS_BITMAP_DELETE:
		rv = bcm_vpls_bitmap_delete(
			req->args.vpls_bitmap_delete.unit,
			req->args.vpls_bitmap_delete.vc_label);
		break;
	case BCM_ASYNC_ENTRY_VPLS_BITMAP_DELETE_ALL:
		rv = bcm_vpls_bitmap_delete_all(
			req->args.vpls_bitmap_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_VPLS_BITMAP_DETACH:
		rv = bcm_vpls_bitmap_detach(
			req->args.vpls_bitmap_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_VPLS_BITMAP_GET:
		rv = bcm_vpls_bitmap_get(
			req->args.vpls_bitmap_get.unit,
			req->args.vpls_bitmap_get.vc_label,
			req->args.vpls_bitmap_get.vid,
			req->args.vpls_bitmap_get.pbmp);
		break;
	case BCM_ASYNC_ENTRY_VPLS_BITMAP_INIT:
		rv = bcm_vpls_bitmap_init(
			req->args.vpls_bitmap_init.unit);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_CREATE:
		rv = bcm_vswitch_create(
			req->args.vswitch_create.unit,
			req->args.vswitch_create.vsi);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_CREATE_WITH_ID:
		rv = bcm_vswitch_create_with_id(
			req->args.vswitch_create_with_id.unit,
			req->args.vswitch_create_with_id.vsi);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_DESTROY:
		rv = bcm_vswitch_destroy(
			req->args.vswitch_destroy.unit,
			req->args.vswitch_destroy.vsi);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_DETACH:
		rv = bcm_vswitch_detach(
			req->args.vswitch_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_INIT:
		rv = bcm_vswitch_init(
			req->args.vswitch_init.unit);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_PORT_ADD:
		rv = bcm_vswitch_port_add(
			req->args.vswitch_port_add.unit,
			req->args.vswitch_port_add.vsi,
			req->args.vswitch_port_add.port);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_PORT_DELETE:
		rv = bcm_vswitch_port_delete(
			req->args.vswitch_port_delete.unit,
			req->args.vswitch_port_delete.vsi,
			req->args.vswitch_port_delete.port);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_PORT_DELETE_ALL:
		rv = bcm_vswitch_port_delete_all(
			req->args.vswitch_port_delete_all.unit,
			req->args.vswitch_port_delete_all.vsi);
		break;
	case BCM_ASYNC_ENTRY_VSWITCH_PORT_GET:
		rv = bcm_vswitch_port_get(
			req->args.vswitch_port_get.unit,
			req->args.vswitch_port_get.port,
			req->args.vswitch_port_get.vsi);
		break;
#ifdef	INCLUDE_L3
	case BCM_ASYNC_ENTRY_WLAN_CLIENT_ADD:
		rv = bcm_wlan_client_add(
			req->args.wlan_client_add.unit,
			req->args.wlan_client_add.info);
		break;
	case BCM_ASYNC_ENTRY_WLAN_CLIENT_DELETE:
		rv = bcm_wlan_client_delete(
			req->args.wlan_client_delete.unit,
			req->args.wlan_client_delete.mac);
		break;
	case BCM_ASYNC_ENTRY_WLAN_CLIENT_DELETE_ALL:
		rv = bcm_wlan_client_delete_all(
			req->args.wlan_client_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_WLAN_CLIENT_GET:
		rv = bcm_wlan_client_get(
			req->args.wlan_client_get.unit,
			req->args.wlan_client_get.mac,
			req->args.wlan_client_get.info);
		break;
	case BCM_ASYNC_ENTRY_WLAN_CLIENT_TRAVERSE:
		rv = bcm_wlan_client_traverse(
			req->args.wlan_client_traverse.unit,
			req->args.wlan_client_traverse.cb,
			req->args.wlan_client_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_WLAN_DETACH:
		rv = bcm_wlan_detach(
			req->args.wlan_detach.unit);
		break;
	case BCM_ASYNC_ENTRY_WLAN_INIT:
		rv = bcm_wlan_init(
			req->args.wlan_init.unit);
		break;
	case BCM_ASYNC_ENTRY_WLAN_PORT_ADD:
		rv = bcm_wlan_port_add(
			req->args.wlan_port_add.unit,
			req->args.wlan_port_add.info);
		break;
	case BCM_ASYNC_ENTRY_WLAN_PORT_DELETE:
		rv = bcm_wlan_port_delete(
			req->args.wlan_port_delete.unit,
			req->args.wlan_port_delete.wlan_port_id);
		break;
	case BCM_ASYNC_ENTRY_WLAN_PORT_DELETE_ALL:
		rv = bcm_wlan_port_delete_all(
			req->args.wlan_port_delete_all.unit);
		break;
	case BCM_ASYNC_ENTRY_WLAN_PORT_GET:
		rv = bcm_wlan_port_get(
			req->args.wlan_port_get.unit,
			req->args.wlan_port_get.wlan_port_id,
			req->args.wlan_port_get.info);
		break;
	case BCM_ASYNC_ENTRY_WLAN_PORT_TRAVERSE:
		rv = bcm_wlan_port_traverse(
			req->args.wlan_port_traverse.unit,
			req->args.wlan_port_traverse.cb,
			req->args.wlan_port_traverse.user_data);
		break;
	case BCM_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_CREATE:
		rv = bcm_wlan_tunnel_initiator_create(
			req->args.wlan_tunnel_initiator_create.unit,
			req->args.wlan_tunnel_initiator_create.info);
		break;
	case BCM_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_DESTROY:
		rv = bcm_wlan_tunnel_initiator_destroy(
			req->args.wlan_tunnel_initiator_destroy.unit,
			req->args.wlan_tunnel_initiator_destroy.wlan_tunnel_id);
		break;
	case BCM_ASYNC_ENTRY_WLAN_TUNNEL_INITIATOR_GET:
		rv = bcm_wlan_tunnel_initiator_get(
			req->args.wlan_tunnel_initiator_get.unit,
			req->args.wlan_tunnel_initiator_get.info);
		break;
#endif	/* INCLUDE_L3 */
	default:
		rv = BCM_E_UNAVAIL;
	}
	if (req->callback != 0) {
		(*req->callback)(req->cookie, rv);
	}
	sal_free(req);
}

#endif	/* BCM_ASYNC_SUPPORT */
