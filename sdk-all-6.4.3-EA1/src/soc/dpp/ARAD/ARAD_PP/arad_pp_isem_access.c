#include <shared/bsl.h>

#include <soc/mcm/memregs.h>
#if defined(BCM_88650_A0)
/*
 * $Id: arad_pp_isem_access.c,v 1.162 Broadcom SDK $
 *
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 */

#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_SOC_LIF
#include <soc/mem.h>

/*************
 * INCLUDES  *
 *************/
/* { */

#include <soc/dcmn/error.h>
#include <soc/dpp/SAND/Utils/sand_header.h>

#include <soc/dpp/SAND/Management/sand_general_macros.h>
#include <soc/dpp/SAND/Management/sand_error_code.h>
#include <soc/dpp/SAND/Management/sand_general_macros.h>
#include <soc/dpp/SAND/Management/sand_low_level.h>
#include <soc/dpp/SAND/Utils/sand_os_interface.h>

#include <soc/dpp/ARAD/arad_tbl_access.h>
#include <soc/dpp/ARAD/arad_reg_access.h>
#include <soc/dpp/ARAD/arad_api_ports.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_api_framework.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_vsi.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_isem_access.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_ce_instruction.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_sw_db.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_port.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_frwrd_fcf.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_api_rif.h>
#include <soc/dpp/drv.h>

#ifdef PLISIM
  #include <sim/dpp/ChipSim/chip_sim_em.h>
#endif

/* } */
/*************
 * DEFINES   *
 *************/
/* { */

#define ARAD_PP_IHP_ISEM_DIAGNOSTICS_KEY_REG_MULT_NOF_REGS            (3)

#define ARAD_PP_ISEM_ACCESS_DEBUG                                     (0)


#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB                        (0)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_MSB                        (2)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB                         (11)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_MSB                         (SOC_IS_JERICHO(unit)? 60:51)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_LSB                     (SOC_IS_JERICHO(unit)? 61:52)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_MSB                     (SOC_IS_JERICHO(unit)? 77:67)
#define ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE                            (ARAD_PP_IHP_ISEM_DIAGNOSTICS_KEY_REG_MULT_NOF_REGS)


/* Field overlaps other fields. MUST be set first */
#define ARAD_PP_ISEM_ACCESS_LSB_PREFIX                              (SOC_IS_JERICHO(unit)? 44: 37)
#define ARAD_PP_ISEM_ACCESS_MSB_PREFIX                              (SOC_IS_JERICHO(unit)? 49: 40)
#define ARAD_PP_ISEM_ACCESS_NOF_BITS_PREFIX                         (ARAD_PP_ISEM_ACCESS_MSB_PREFIX - ARAD_PP_ISEM_ACCESS_LSB_PREFIX + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(bos_key_feature)       (bos_key_feature ? 1:0)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_MSB(bos_key_feature)       (bos_key_feature ? 20:19)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(bos_key_feature)  (ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_MSB(bos_key_feature) - ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(bos_key_feature) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB                    (0)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_MSB                    (0)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS               (ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_MSB - ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_LSB(bos_key_feature)         (bos_key_feature ? 21:20)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_MSB(bos_key_feature)         (bos_key_feature ? 32:31)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_NOF_BITS(bos_key_feature)    (ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_MSB(bos_key_feature) - ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_LSB(bos_key_feature) + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_LSB(bos_key_feature)   (bos_key_feature ? 33:32)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_MSB(bos_key_feature)   (bos_key_feature ? 33:32)
#define ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_NOF_BITS(bos_key_feature)(ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_MSB(bos_key_feature) - ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_LSB(bos_key_feature) + 1)


#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB                  (12)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_MSB                  (31)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_NOF_BITS             (ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_MSB - ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_LSB                  (44)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_MSB                  (63)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_NOF_BITS             (ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_MSB - ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_LSB              (40)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MSB              (40)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MSB - ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_LSB + 1)

/* MASK */
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_START          (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_END            (11)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_TTL_MASK_BIT_START   (32)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_TTL_MASK_BIT_END     (39)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MASK_BIT_START   (40)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MASK_BIT_END     (40)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_EXP_MASK_BIT_START   (41)
#define ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_EXP_MASK_BIT_END     (43)

/* 
 * AC lookups look as:
 * [MSB-LSB] Bridge-Prefix, ... , [Inner], [Outer/Initial], 2bits, VD
 * 2bits indication stand for:
 * 00 : Initial-VID
 * 01 : Invalid (Inner-VID)
 * 10 : Outer-VID
 * 11 : Double-Tag
 */
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB            (0)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_MSB            (7)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_NOF_BITS       (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_LSB       (8)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_MSB       (9)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_NOF_BITS  (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_LSB              (10)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_MSB              (21)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_LSB              (22)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_MSB              (33)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_LSB              (22)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_MSB              (22)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_LSB              (23)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_MSB              (25)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_LSB        (12)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_LSB   (20)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_MSB   (21)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_NOF_BITS  (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_LSB          (0)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_MSB          (11)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_LSB          (22)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_MSB          (33)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_LSB          (34)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_MSB          (34)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB          (35)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_MSB          (37)
#define ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_MSB - ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB                     (0)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_MSB                     (31)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS                (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB + 1)


#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB                (12)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MSB                (43)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_NOF_BITS           (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB                (44)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MSB                (75)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_NOF_BITS           (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB      (76)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MSB      (83)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB      (84)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_MSB      (87)
#define ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_MSB - ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB + 1)


#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_LSB                   (24)
#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_MSB                   (29)
#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_NOF_BITS              (ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB                          (0)
#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_MSB                          (23)
#define ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_NOF_BITS                     (ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_MSB - ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_LSB                   (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_MSB                   (15)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_NOF_BITS              (ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_LSB      (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_MSB      (14)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_LSB      (15)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_MSB      (22)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_MSB             (15)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_LSB + 1)

/* Trill VSI */
/* Pad first 8bits with zeros */
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_LSB                   (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_MSB                   (7)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_NOF_BITS              (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB        (8)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_MSB        (9)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB        (10)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_MSB        (21)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB        (22)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_MSB        (33)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_LSB        (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_MSB        (11)
#define ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_LSB + 1)


/* GRE {*/
/* vpn key */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_MSB             (23)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB + 1)

/* flags  */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB             (24)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_MSB             (27)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB + 1)
/* gre flags value */
/* checksum=0,routing = 0,key = 1 , SeqN = 0 */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_VAL             (2)
/* GRE }*/

/* IPv6 tunnel DIP {*/
/* DIP */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_MSB             127
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB + 1)
/* IPv6 tunnel }*/

/* PON { */
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_LSB         (0)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_MSB         (2)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_NOF_BITS    (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_LSB + 1)
                
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_LSB              (3)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_MSB              (13)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB           (14)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_MSB           (25)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_LSB           (26)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_MSB           (37)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB         (0)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_MSB         (2)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS    (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB + 1)
   
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB              (3)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_MSB              (13)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_NOF_BITS         (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB + 1)
      
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB           (14)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_MSB           (29)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB + 1)
  
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB           (30)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_MSB           (41)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB + 1)
  
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB           (42)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_MSB           (42)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB + 1)
  
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB           (43)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_MSB           (45)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB + 1)
  
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB           (46)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_MSB           (57)
#define ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_NOF_BITS      (ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB + 1)   
/* PON } */

/* Spoof { */
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_LSB (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_MSB (31)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_LSB (32)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_MSB (39)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_LSB + 1)


#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_LSB (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_MSB (127)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_LSB (128)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_MSB (134)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_LSB (40)
#define ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_MSB (47)
#define ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_NOF_BITS (ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_MSB - ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_LSB + 1)
/* Spoof } */


#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_MSB             (23)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB             (24)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_MSB             (27)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB + 1)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_VAL             (2)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_MSB             127
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_MSB             (23)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_LSB + 1)


#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_LSB             (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_MSB             (7)
#define ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_NOF_BITS        (ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_LSB + 1)


/* SIP OVERLAY for learn info */
#define ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_LSB                 (0)
#define ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_MSB                 (31)
#define ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_NOF_BITS            (ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_LSB + 1)

/* RPA */
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_LSB                 (0)
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_MSB                 (27)
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_NOF_BITS            (ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_MSB - ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_LSB                 (28)
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_MSB                 (36)
#define ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_NOF_BITS            (ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_MSB - ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_LSB + 1)

/* Flexible QinQ */
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB          (0)
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_MSB          (11)
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB        (12)
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_MSB        (19)
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_LSB          (20)
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_MSB          (31)
#define ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_LSB + 1)

/* TST */
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB        (0)
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_MSB        (7)
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS   (ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_MSB - ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB + 1)

#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB          (8)
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_MSB          (19)
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB + 1)                             
                               
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB          (20)
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_MSB          (31)
#define ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_NOF_BITS     (ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_MSB - ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB + 1)




#define ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_LSB          (0)
#define ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_MSB          (15)
#define ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_NOF_BITS     (ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_LSB + 1)

/* 
 * Defines for 2 bits indication
 */
#define ARAD_PP_ISEM_ACCESS_KEY_2BITS_INITIAL_VID (0)
#define ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID   (2)
#define ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG  (3)

/* 
 * VTT TCAM defines { 
 */
#define ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE  (4)
#define ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS    (0)


/* Access profile ID being concat to Key */
#define ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_LSB       (161)
#define ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_MSB       (166)
#define ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_NOF_BITS  (ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_MSB - ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_LSB + 1)


/* 
 * VTT TCAM defines }
 */


/* 
 * Program selection defines {
 */ 
#define ARAD_PP_ISEM_PFC_PART_NONE               0x0
#define ARAD_PP_ISEM_PFC_PART_E                  0x1
#define ARAD_PP_ISEM_PFC_PART_IPV4               0x2
#define ARAD_PP_ISEM_PFC_PART_TRILL              0x4
#define ARAD_PP_ISEM_PFC_PART_MPLS1              0x5
#define ARAD_PP_ISEM_PFC_PART_MPLS2              0x6
#define ARAD_PP_ISEM_PFC_PART_MPLS3              0x7

/* 3 LSBs tells which is above Ethernet (second header), 3 MSBs which is above second header */
#define ARAD_PP_ISEM_PFC_SET(MSB_HEAD,LSB_HEAD) \
  ((MSB_HEAD << 3) | LSB_HEAD)

/* Packet format codes:                                   [5:3]                [2:0] */
#define ARAD_PP_ISEM_PFC_E            (ARAD_PP_ISEM_PFC_SET(ARAD_PP_ISEM_PFC_PART_NONE , ARAD_PP_ISEM_PFC_PART_NONE))
#define ARAD_PP_ISEM_PFC_IPv4oMPLS2oE (ARAD_PP_ISEM_PFC_SET(ARAD_PP_ISEM_PFC_PART_IPV4 , ARAD_PP_ISEM_PFC_PART_MPLS2))
#define ARAD_PP_ISEM_PFC_IPv4oMPLS2oE (ARAD_PP_ISEM_PFC_SET(ARAD_PP_ISEM_PFC_PART_IPV4 , ARAD_PP_ISEM_PFC_PART_MPLS2))
#define ARAD_PP_ISEM_PFC_EoTRILLoE    (ARAD_PP_ISEM_PFC_SET(ARAD_PP_ISEM_PFC_PART_E    , ARAD_PP_ISEM_PFC_PART_TRILL))
/* traped in VTT:*/

/* 
 * Qualifier - [10:7] Next Protocol, [6:5] Encapsulation, [4:3] Outer Tag Format, [2] Priority Pkt, [1:0] Inner tag format
 * Tag Formats are: 2b00 None 2b01 TPID1 2b10 TPID2 2b11 TPID3
 * MPLS Coupling is defined by NXT_PROTOCOL = (7) (one of the user defined)
 */
 
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL               (0x00)  /* Untagged Pkts*/
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1        (0x08)  /* Assuming Next Protocol is Maksed */
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2        (0x10)  /* Assuming Next Protocol is Maksed*/
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID1        (0x01)  /* Assuming Next Protocol is Maksed*/
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID2        (0x02)  /* Assuming Next Protocol is Maksed*/
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_PCP          (0x04)  /* Assuming Next Protocol is Maksed*/

#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL  (0x780)
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP         (0x060)
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID    (0x018)
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP     (0x004)
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID    (0x003)


#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS (0xF << 7)
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS_COUPLING (7 << 7)
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MAC_IN_MAC (9 << 7)
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_ARP (10 << 7)
#define ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MISS (0 << 7)

/* Bits 1:2 Range1, 3:4 Range2, 5:6 Range 3 */
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L1                (0x006)  /* 00=Range1 (ELI), 01=Range2(None), 10=Range3(GAL), 11=Not in Range */
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L2ELI             (0x000)
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L3ELI             (0x000)
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L1GAL             (0x010)
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L2GAL             (0x040)
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_GAL               (0x004)

#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT  (0x781)            
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_NEXT_PROT      (0x780)            
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1             (0x006)            
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2             (0x018)            
#define ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3             (0x060)            

#define ARAD_PP_ISEM_ACCESS_QLFR_IP_NEXT_PROTOCOL_MPLS    (0xF << 7)
#define ARAD_PP_ISEM_ACCESS_16B_INST_PP_PORT_KEY_VAR_X_LSBS(X) (0x448 | ((X-1) << 12))

#define ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK                     (0x7)
#define ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID  (0x6)
#define ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID         (0x1)
#define ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_DOUBLE_TAG          (0x2)
/* 
 * Program selection defines }
 */ 

/* VTT KBR get defines { */
/* { */
#define ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VSI                                     (SOC_IS_JERICHO(unit)? 0x7cd8: 0x7ad8)
#define ARAD_PP_ISEM_ACCESS_16B_INST_IN_RIF_VALID_VRF_9_LSBS                         (SOC_IS_JERICHO(unit)? 0x99a8: 0x95a8)
#define ARAD_PP_ISEM_ACCESS_32B_INST_IN_RIF_VALID_IN_RIF                             (SOC_IS_JERICHO(unit)? 0x7c78: 0x6288)
#define ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_INNER_VID                                (SOC_IS_JERICHO(unit)? 0x5a98: 0x5a68)
#define ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID                                (SOC_IS_JERICHO(unit)? 0xb568: 0xb508)
#define ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID                                (SOC_IS_JERICHO(unit)? 0x5a78: 0x5a48)
#define ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID                                (SOC_IS_JERICHO(unit)? 0xb528: 0xb4c8)
#define ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID                                     (SOC_IS_JERICHO(unit)? 0x5a58: 0x5a28)
#define ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID                                     (SOC_IS_JERICHO(unit)? 0xb4e8: 0xb488)
#define ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN                                     (SOC_IS_JERICHO(unit)? 0x3938: 0x3928)
#define ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN                                     (SOC_IS_JERICHO(unit)? 0x72a8: 0x7288)
#define ARAD_PP_ISEM_ACCESS_32B_INST_IN_PORT                                         (SOC_IS_JERICHO(unit)? 0x3918: 0x3918)
#define ARAD_PP_ISEM_ACCESS_16B_INST_PROGRAM_VAR_2_BITS                              (SOC_IS_JERICHO(unit)? 0x1048: 0x1048)
#define ARAD_PP_ISEM_ACCESS_16B_INST_PROGRAM_VAR_12_BITS                             (SOC_IS_JERICHO(unit)? 0xb048: 0xb048)
#define ARAD_PP_ISEM_ACCESS_32B_INST_PROGRAM_VAR_2_BITS                              (SOC_IS_JERICHO(unit)? 0x0808: 0x0808)
#define ARAD_PP_ISEM_ACCESS_32B_INST_PON_VLAN_DOMAIN                                 (SOC_IS_JERICHO(unit)? 0x1138: 0x1128) /* Assumption of still 3 bits for PON.VLAN-Domain in Jericho */
#define ARAD_PP_ISEM_ACCESS_16B_INST_PON_VLAN_DOMAIN                                 (SOC_IS_JERICHO(unit)? 0x22a8: 0x2288) /* Assumption of still 3 bits for PON.VLAN-Domain in Jericho */

/* 32BITS CE: [15:11] num of bits, [10:4] offset, [3] sel, [2:0] offset select
   16BITS CE: [15:12] num of bits, [11:4] offset, [3] sel, [2:0] offset select */
/* only should be used in VT */
#define ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(X) ((SOC_IS_JERICHO(unit)? 0x0088: 0x0088) | ((X-1) << 11))
#define ARAD_PP_ISEM_ACCESS_32B_INST_X_ONES(X)  ((SOC_IS_JERICHO(unit)? 0x0048: 0x0048) | ((X-1) << 11))
#define ARAD_PP_ISEM_ACCESS_16B_INST_X_ZEROS(X) ((SOC_IS_JERICHO(unit)? 0x0148: 0x0148) | ((X-1) << 12))
#define ARAD_PP_ISEM_ACCESS_16B_INST_X_ONES(X)  ((SOC_IS_JERICHO(unit)? 0x00C8: 0x00C8) | ((X-1) << 12))
#define ARAD_PP_ISEM_ACCESS_32B_INST_32_ONES    (ARAD_PP_ISEM_ACCESS_32B_INST_X_ONES(32))
#define ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES     (ARAD_PP_ISEM_ACCESS_32B_INST_X_ONES(2))
#define ARAD_PP_ISEM_ACCESS_32B_INST_1_ONES     (ARAD_PP_ISEM_ACCESS_32B_INST_X_ONES(1))
#define ARAD_PP_ISEM_ACCESS_32B_INST_2_ZEROS    (ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(2))
#define ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS    (ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(1))
#define ARAD_PP_ISEM_ACCESS_16B_INST_2_ONES     (ARAD_PP_ISEM_ACCESS_16B_INST_X_ONES(2))
#define ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES     (ARAD_PP_ISEM_ACCESS_16B_INST_X_ONES(1))
#define ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS    (ARAD_PP_ISEM_ACCESS_16B_INST_X_ZEROS(2)) 
#define ARAD_PP_ISEM_ACCESS_16B_INST_1_ZEROS    (ARAD_PP_ISEM_ACCESS_16B_INST_X_ZEROS(1))


#define ARAD_PP_ISEM_ACCESS_16B_INST_FC_D_ID_8_MSB                                                               (0x7002)
#define ARAD_PP_ISEM_ACCESS_16B_INST_FC_WITH_VFT_D_ID_8_MSB                                                      (0x7003)
/* kbr defines } */
/* VTT KBR get defines } */

/* VTT logical DataBasesprefixes */
#define  ARAD_PP_ISEM_ACCESS_NULL_PREFIX               (0) /* Means that this value is irrelevant the IS is not searched*/
#define  ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX             (0) /* ISA and ISB DBs includes: VDxInitial-VID, VDxOuter-VID, VDxOuterxInner*/
#define  ARAD_PP_ISEM_ACCESS_OVERLAY_SIP_PREFIX        (1) /* ISA */ 
#define  ARAD_PP_ISEM_ACCESS_IP_PREFIX                 (1) /* ISB */
#define  ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_DOUBLE    (2) /* ISA */
#define  ARAD_PP_ISEM_ACCESS_BRIDGE_DT                 (2) /* ISA */
#define  ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_SINGLE    (2) /* ISB */
#define  ARAD_PP_ISEM_ACCESS_BRIDGE_ST                 (2) /* ISB */
#define  ARAD_PP_ISEM_ACCESS_ISID_DOMAIN_ISID_PREFIX   (3) /* ISA */
#define  ARAD_PP_ISEM_ACCESS_FC_PREFIX                 (3)/* ISB (TRILL_VSI isnt used in this case)  */
#define  ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX          (3) /* ISB (FC_PREFIX isnt used in this case) */
#define  ARAD_PP_ISEM_ACCESS_TRILL_FINE_A_GRAINED_PREFIX (4)/* ISA, ISB (IPV4_SPOOF_PREFIX isnt used in this case) */
#define  ARAD_PP_ISEM_ACCESS_VD_OUTER_PCP_PREFIX       (5) /* ISA */
#define  ARAD_PP_ISEM_ACCESS_RPA_ID_PREFIX             (6) /* ISA */
#define  ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX         (7) /* ISA - TRILL */
#define  ARAD_PP_ISEM_ACCESS_TRILL_DESIGNATED_VID_PREFIX (8) /* ISB - TRILL Designated-VLAN */
#define  ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX             (9) /* ISB  (PON not supported with overlay) */
#define  ARAD_PP_ISEM_ACCESS_MPLS_L1ELI_PREFIX         (11) /* ISA or ISB (PON not supported with Indexed ELI) */
#define  ARAD_PP_ISEM_ACCESS_MPLS_L1L3ELI_PREFIX       (11) /* ISA or ISB (PON not supported with Indexed ELI) */
#define  ARAD_PP_ISEM_ACCESS_MPLS_L1L2ELI_PREFIX       (11) /* ISA or ISB (PON not supported with Indexed ELI) */
#define  ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX (12) /* ISA or ISB */
#define  ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX            (12) /* ISA or ISB cant exist ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX*/
#define  ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX          (12) /* ISA or ISB cant exist ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX*/
#define  ARAD_PP_ISEM_ACCESS_MPLS_L2_PREFIX            (13) /* ISA or ISB */
#define  ARAD_PP_ISEM_ACCESS_MPLS_L3_PREFIX            (13) /* ISB or ISA */
#define  ARAD_PP_ISEM_ACCESS_MPLS_L1L3_PREFIX          (13) /* ISB or ISA */
#define  ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX     (13) /* ISA or ISB */
#define  ARAD_PP_ISEM_ACCESS_MPLS_L2ELI_PREFIX         (14) /* ISB or ISA (PON not supported with Indexed sELI) */
#define  ARAD_PP_ISEM_ACCESS_TRILL_NICK_PREFIX         (15) /* ISA */
#define  ARAD_PP_ISEM_ACCESS_MPLS_PWE_GAL              (15) /* ISB or ISA (Trill and PWE GAL cant exist toghether */

/* PON application prefix value  */
#define  ARAD_PP_ISEM_ACCESS_PON_UNTAGGED_PREFIX       (1) /* ISA */
#define  ARAD_PP_ISEM_ACCESS_PON_TLS_PREFIX            (1) /* ISB (Not supported with CUS_PON_TWO_TAGS) */
#define  ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX        (2) /* ISA & ISB overwrite TRILL (isnt supported with PON) */
#define  ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX       (4) /* ISA (cover prefixes 4-7) */
#define  ARAD_PP_ISEM_ACCESS_CUS_PON_TWO_TAGS_PREFIX   (4) /* ISB (cover prefixes 4-7) */
#define  ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX   (3) /* ISA */
#define  ARAD_PP_ISEM_ACCESS_IPV4_SPOOF_PREFIX         (8) /* ISB (cover prefixes 8-15) */

#define  ARAD_PP_ISEM_ACCESS_VT_PROFILE_PON_ANY_MASK   (0x3)
#define  ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS (0x2)

/* priority of each key field in TCAM */
#define ARAD_PP_ISEM_ACCESS_PON_ETHERTYPE_PRIO    (1)
#define ARAD_PP_ISEM_ACCESS_PON_OUTER_DEI_PRIO    (1)
#define ARAD_PP_ISEM_ACCESS_PON_OUTER_PCP_PRIO    (10)
#define ARAD_PP_ISEM_ACCESS_PON_OUTER_VID_PRIO    (50)
#define ARAD_PP_ISEM_ACCESS_PON_INNER_VID_PRIO    (50)
#define ARAD_PP_ISEM_ACCESS_PON_TUNNEL_ID_PRIO    (50)
#define ARAD_PP_ISEM_ACCESS_PON_VD_PRIO           (50)

/* EVB default S-channel */
#define ARAD_PP_ISEM_ACCESS_EVB_DEFAULT_S_CHANNEL (0x1)

/* } */
/*************
 * MACROS    *
 *************/
/* { */
          
/* } */
/*************
 * TYPE DEFS *
 *************/
/* { */

typedef enum
{
  ARAD_PP_ISEM_ACCESS_ACTION_TYPE_DELETE = 0,
  ARAD_PP_ISEM_ACCESS_ACTION_TYPE_INSERT = 1,
  ARAD_PP_ISEM_ACCESS_ACTION_TYPE_DEFRAG = 4
}ARAD_PP_ISEM_ACCESS_ACTION_TYPE;

typedef struct
{
  uint8 mpls_use_in_rif;
  uint8 port_vlan_pcp_lookup;
  uint8 match_port_vlan_critiria_64K;
  uint8 mpls_index;
  uint8 spoof_enable;
  uint8 trill_mode; /* 0 - disabled. 1 - VL legacy. 2 - FGL supported */
  uint8 trill_appointed_fwd; /* fine-grained-A mode */
  uint8 ipv6_term_enable;
  uint8 ipv4_term_enable;
  uint8 ipv4_term_dip_sip_enable; /* 0 - disable, 1 - enable, 2 - include IPV4 next protocol */
  uint8 e_o_ip_enable;
  uint8 vxlan_enable;
  uint8 nvgre_enable;
  uint8 spoof_ipv6_enable;
  uint8 fast_reroute_labels_enable;
  uint8 coupling_enable;
  uint8 is_bos_in_key_enable;
  uint8 pon_enable; /* If set, PON application is enabled (at least one port is PON port) */
  uint8 use_pon_tcam_lkup; /* If set, Also enable loookup of VD(3bits), Tunnel, 2VLANs, Ethertype and COS */
  uint8 tls_db_enable; /* If set, PON application include also TLS DB */
  uint8 custom_pon_enable; /* custom PON two tags application for ARAD+ */
  uint8 tls_in_tcam_enable; /* If set, TLS DB resides in TCAM */
  uint8 evb_enable; /* If set, EVB application is on */
  uint8 fcoe_enable; /* If set, FCOE is enabled*/
  uint8 ipv4mc_bidir_enable; /* If set, IPV4 MC BIDIR is enabled*/
  uint8 mim_enable; /* If set, MiM is enabled */
  uint8 eli_enable; /* If set, device supports ELI programs */
  uint8 mpls_1_namespace;  /* 0 - L1, 1 - L2, 2 - L3, 4 - L1L3, 5 - L1L2, 6 - L2L3 , 255 - Invalid */
  uint8 mpls_2_namespace;  /* 0 - L1, 1 - L2, 2 - L3, 4 - L1L3, 5 - L1L2, 6 - L2L3 , 255 - Invalid */
  uint8 mpls_3_namespace;  /* 0 - L1, 1 - L2, 2 - L3, 4 - L1L3, 5 - L1L2, 6 - L2L3 , 255 - Invalid */
  uint8 mpls_1_database;   /* 0 - SEM-A, 1 - SEM-B, 255 - invalid */
  uint8 mpls_2_database;   /* 0 - SEM-A, 1 - SEM-B, 255 - invalid */
  uint8 mpls_3_database;   /* 0 - SEM-A, 1 - SEM-B, 255 - invalid */  
  uint8 mpls_tp_mac_address; /* 1 - enable */
  uint8 trill_disable_designated_vlan_check; /* If set, bcmPortControlTrillDesignatedVlan is not applicable*/
  uint8 designated_vlan_inlif_enable;
  uint8 q_in_q_ip_5_tuple; /* If set, special port property prefer IPV4 5-tuple */
  uint8 custom_feature_vt_tst1; /* If set, Test 1 is set */
  uint8 tunnel_termination_in_tt_only; /* If set, Tunnel termination only in TT stage */
  uint8 pwe_gal_support; /* IF set, PWE-GAL database exist */
  uint8 trill_transparent_service; /* 0 - disabled. 1 - enabled */
  uint8 explicit_null_support; /* If set, Explicit-null database exist */
}ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES;


ARAD_PP_ISEM_ACCESS_PROGRAM_INFO vt_programs[SOC_MAX_NUM_DEVICES][ARAD_PP_ISEM_ACCESS_PROG_VT_NOF_PROGS];
ARAD_PP_ISEM_ACCESS_PROGRAM_INFO tt_programs[SOC_MAX_NUM_DEVICES][ARAD_PP_ISEM_ACCESS_PROG_TT_NOF_PROGS];

#define SET_VT_PROGRAM_ID(unit, program_name) \
  { \
    if (last_vt_program_id >= (SOC_DPP_DEFS_GET(unit, nof_vtt_programs) -1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8100, exit); \
    } \
    vt_programs[unit][program_name].prog_used = last_vt_program_id++; \
  }

#define SET_TT_PROGRAM_ID(program_name) \
  { \
    if (last_tt_program_id >= (SOC_DPP_DEFS_GET(unit, nof_vtt_programs)-1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8110, exit); \
    } \
    tt_programs[unit][program_name].prog_used = last_tt_program_id++; \
  }

#define SET_VT_PROGRAM_SELECTION(prog_idx) \
  { \
    prog_idx++; \
    if (prog_idx > (SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines)-1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8120, exit); \
    } \
  }

#define SET_VT_2_PROGRAM_SELECTION(prog_idx) \
  { \
    prog_idx++; \
    if (prog_idx+1 > (SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines)-1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8130, exit); \
    } \
  }


#define SET_TT_PROGRAM_SELECTION(prog_idx) \
  { \
    prog_idx++; \
    if (prog_idx > (SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines)-1)) \
    { \
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR, 8140, exit); \
    } \
  }


#define ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(valid_prog) \
  ((valid_prog != -1) ? (tmp+1):tmp)
   
#define ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX_WO_ELI(mpls_namespace) \
  ((mpls_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1) ? ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX: \
  (mpls_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L2) ? ARAD_PP_ISEM_ACCESS_MPLS_L2_PREFIX: \
  (mpls_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L3) ? ARAD_PP_ISEM_ACCESS_MPLS_L3_PREFIX: \
  (mpls_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L3_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX)

#define ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX_ELI(mpls_namespace) \
  ((mpls_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1) ? ARAD_PP_ISEM_ACCESS_MPLS_L1ELI_PREFIX: \
  (mpls_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L2) ? ARAD_PP_ISEM_ACCESS_MPLS_L2ELI_PREFIX: \
  (mpls_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L3ELI_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L1L2ELI_PREFIX)

#define ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_namespace,is_eli) \
  ((is_eli) ? ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX_ELI(mpls_namespace):ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX_WO_ELI(mpls_namespace))

/* Second stage parsing is disabled for Jericho. Might be added later part of LB enhancements */
#define ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit) (SOC_IS_JERICHO(unit) ? (0x0) : (0x1)) 


CONST STATIC SOC_PROCEDURE_DESC_ELEMENT
  Arad_pp_procedure_desc_element_isem_access[] =
{
  /*
   * Auto generated. Do not edit following section {
   */
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_ISEM_ACCESS_GET_PROCS_PTR),
  SOC_PROCEDURE_DESC_ELEMENT_DEF(ARAD_PP_ISEM_ACCESS_GET_ERRS_PTR),
  /*
   * } Auto generated. Do not edit previous section.
   */

  /*
   * Last element. Do no touch.
   */
  SOC_PROCEDURE_DESC_ELEMENT_DEF_LAST
};

CONST STATIC SOC_ERROR_DESC_ELEMENT
  Arad_pp_error_desc_element_isem_access[] =
{
  /*
   * Auto generated. Do not edit following section {
   */
  /*
   * } Auto generated. Do not edit previous section.
   */

  {
    ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR,
    "ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR",
    "Unknown key type. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_NOT_READY_ERR,
    "ARAD_PP_ISEM_ACCESS_NOT_READY_ERR",
    "Sem is not ready. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_MPLS_IN_RIF_NOT_SUPPORTED_ERR,
    "ARAD_PP_ISEM_ACCESS_MPLS_IN_RIF_NOT_SUPPORTED_ERR",
    "MPLS_IN_RIF entries are not supported when working in mpls core mode. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_LABEL_INDEX_OUT_OF_RANGE_ERR,
    "ARAD_PP_ISEM_ACCESS_LABEL_INDEX_OUT_OF_RANGE_ERR",
    "label_index is out of range. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_LABEL_INDEX_NOT_SUPPORTED_ERR,
    "ARAD_PP_ISEM_ACCESS_LABEL_INDEX_NOT_SUPPORTED_ERR",
    "label_index is not supported when working in mpls labels share mode. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_PROG_SEL_INCORRECT_DEF_ALLOCATION_ERR,
    "ARAD_PP_ISEM_ACCESS_PROG_SEL_INCORRECT_DEF_ALLOCATION_ERR",
    "default allocation of program selection excess nof entries. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_PROG_SEL_USR_INDEX_OUT_OF_RANGE_ERR,
    "ARAD_PP_ISEM_ACCESS_PROG_SEL_USR_INDEX_OUT_OF_RANGE_ERR",
    "user define entry index excess nof entries. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_PROG_SEL_INVALID_LIF_KEY_RANGE_ERR,
    "ARAD_PP_ISEM_ACCESS_PROG_SEL_INVALID_LIF_KEY_RANGE_ERR",
    "invalid convertion lif key from , to program selection. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_AC_KEY_SET_NOT_SUPPORTED_ERR,
    "ARAD_PP_ISEM_ACCESS_AC_KEY_SET_NOT_SUPPORTED_ERR",
    "ac map key is not supported when working in simple vlan translation mode. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR,
    "ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR",
    "Illegal configuration of vlan translation programs in vtt: inmatch soc properties. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR,
    "ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR",
    "Trying to add entry in TCAM when key type is not supported for TCAM. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },
  {
    ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR,
    "ARAD_PP_ISEM_ACCESS_PROGRAMS_FULL_ERR",
    "Number of allocated VT, TT programs is over the possible number of programs. \n\r ",
    SOC_SAND_SVR_ERR,
    FALSE
  },

  /*
   * Last element. Do no touch.
   */
SOC_ERR_DESC_ELEMENT_DEF_LAST
};

/* } */
/*************
 * GLOBALS   *
 *************/
/* { */

ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES g_prog_soc_prop[BCM_MAX_NUM_UNITS] = {{0}};
int                                         is_g_prog_soc_prop_initilized[BCM_MAX_NUM_UNITS] = {0};   

/* Result to use values */

/* Priority decoter bitmap enable set */

/* } */
/*************
 * FUNCTIONS *
 *************/
STATIC
uint32
  arad_pp_isem_access_programs_soc_properties_get(
    SOC_SAND_IN int                                  unit);

/* { */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_tm_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TM_RULE_NUM */ 
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is not ethernet */
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  prog_selection_1st_cam_tbl.packet_format_code          = (0x20);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.parser_leaf_context         = (0x0);
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x0);
  prog_selection_1st_cam_tbl.parser_leaf_context_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_tm_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_lookup_initialvid_set(
     int unit,     
     int prog_indx,
     int prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: all packets with the following port profile, up until now we tried to match double and single tag */
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* UnTagged and priority packets, assume one-tag packets already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL;  
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask   = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */  
  prog_selection_1st_cam_tbl.packet_format_code_mask          = (0x1F);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY); /* also ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY_INITIAL_VID*/ 
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID); 
                                                                    /* ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY_INITIAL_VID,
                                                                       ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY */  
  prog_selection_1st_cam_tbl.llvp_prog_sel                 = prog_sel;
  prog_selection_1st_cam_tbl.valid                         = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_lookup_initialvid_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_set(
     int unit,     
     int prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_RULE_NUM */
     int prog_indx1,  
     uint32 port_profile,   
     int prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ethernet and no tags on packet */
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* UnTagged packets, assume one-tag packets already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL;  
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask   = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */  
  prog_selection_1st_cam_tbl.packet_format_code_mask          = (0x1F);
  if (port_profile == SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES) 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (0x0);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK);
  } 
  else 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (port_profile);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID);
  }
  prog_selection_1st_cam_tbl.llvp_prog_sel                       = prog_sel;
  prog_selection_1st_cam_tbl.valid                         = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  /* Match: packet format code is ethernet and no tags on packet */
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* priority packets, assume one-tag and untagged packets already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_PCP;  
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask   = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */  
  prog_selection_1st_cam_tbl.packet_format_code_mask          = (0x1F);
  if (port_profile == SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES) 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (0x0);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK);
  } 
  else 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (port_profile);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID);
  }
  prog_selection_1st_cam_tbl.llvp_prog_sel                       = prog_sel;
  prog_selection_1st_cam_tbl.valid                         = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_RULE */
     uint32 prog_indx1, 
     uint32 port_profile,
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Tagged packets Outer-tag1 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);

  if (port_profile == SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES) 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (0x0);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID);
  } 
  else 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (port_profile);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (0x0);
  }

  
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Tagged packets Outer-tag2 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  if (port_profile == SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES) 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (0x0);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID);
  } 
  else 
  {
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (port_profile);  
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (0x0);
  }
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_inner_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_RULE_NUM_0 */     
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Last rule assume tag and untagged already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (0x0); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (0x0);
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x7);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_inner_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_untagged_tst(
     int unit,
     uint32 prog_indx, 
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /*pure untagged */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (0x0); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (0x0);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x7);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_untagged_tst", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_untagged_tst_explicit_null_set(
     int unit,
     uint32 prog_indx1, 
     uint32 prog_indx2, 
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /*pure untagged */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (SOC_PPC_PORT_DEFINED_VT_PROFILE_EXPLICIT_NULL);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx2, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  /*pure untagged */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (SOC_PPC_PORT_DEFINED_VT_PROFILE_IGNORE_2ND_TAG_EXPLICIT_NULL);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx2, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_untagged_tst_explicit_null_set", prog_indx1, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_tag_tst(
     int unit,
     uint32 prog_indx0, 
     uint32 prog_indx1,     
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Double-Tagged packets inner TPID 1-2 is set */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask  = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP 
                                                                | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask         = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_DEFAULT);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID2);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask  = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP 
                                                                | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask         = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_DEFAULT);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                    = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_tag_tst", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_tag_tst_explicit_null_set(
     int unit,
     uint32 prog_indx0, 
     uint32 prog_indx1,     
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Double-Tagged packets inner TPID 1-2 is set */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask  = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP 
                                                                | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask         = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (SOC_PPC_PORT_DEFINED_VT_PROFILE_EXPLICIT_NULL);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID2);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask  = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP 
                                                                | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask         = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (SOC_PPC_PORT_DEFINED_VT_PROFILE_EXPLICIT_NULL);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask    = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                    = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_tag_tst_explicit_null_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_single_tag_tst(
     int unit,
     uint32 prog_indx, 
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* assume last program (and inner is 0) */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (0x0); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID 
                                                               | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (0x0);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x7);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_single_tag_tst", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_single_tag_tst_explicit_null_set(
     int unit,
     uint32 prog_indx0, 
     uint32 prog_indx1, 
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* assume last program (and inner is 0) */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID 
                                                               | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (SOC_PPC_PORT_DEFINED_VT_PROFILE_EXPLICIT_NULL);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* assume last program (and inner is 0) */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID 
                                                               | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (SOC_PPC_PORT_DEFINED_VT_PROFILE_IGNORE_2ND_TAG_EXPLICIT_NULL);  
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_single_tag_tst_explicit_null_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_high_vd_outer_inner_or_low_vd_outer_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER_RULE */
     uint32 prog_indx1, 
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Double tag exist - inner tag1 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     =  (ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID1); 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);

  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY;
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Double tag exist - inner tag2 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     =  (ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID2); 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);

  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY;
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_high_vd_outer_inner_or_low_vd_outer_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_double_tag_pri_initialvid_set(
     int unit,
     uint32 prog_indx0,
     uint32 prog_indx1,
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID1); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);

  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY_INITIAL_VID;
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_INNER_TPID2); /* */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);

  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY_INITIAL_VID;
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_double_tag_pri_initialvid_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_designated_vid_trill_set(
     uint32 unit,
     uint32 prog_indx0,
     uint32 prog_indx1, 
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Trill for Tagged packets Outer-tag1 with designated VID */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1); 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask  = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (ARAD_PP_ISEM_PFC_EoTRILLoE);
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x0);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Trill for Tagged packets Outer-tag2 with designated VID */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2); 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask  = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (ARAD_PP_ISEM_PFC_EoTRILLoE);
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x0);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_trill_set", prog_indx0, prog_sel);
}


STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_trill_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL_PORT_RULE_NUM */
     uint32 prog_indx1,     
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Trill for UnTagged and priority packets, assume one-tag packets already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL;
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask   = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask          = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile             = (ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL); /* ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL_USE_INITIAL_VID */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask         = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID);
  prog_selection_1st_cam_tbl.llvp_prog_sel                       = prog_sel;
  prog_selection_1st_cam_tbl.valid                         = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Trill for UnTagged and priority packets, assume one-tag packets already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_PCP;
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask   = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code              = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask          = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile             = (ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL); /* ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL_USE_INITIAL_VID */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask         = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID);
  prog_selection_1st_cam_tbl.llvp_prog_sel                       = prog_sel;
  prog_selection_1st_cam_tbl.valid                         = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
    
exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_trill_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_trill_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL_PORT_RULE */
     uint32 prog_indx1, 
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Trill for Tagged packets Outer-tag1 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1); 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask  = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Trill for Tagged packets Outer-tag2 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1       = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2); 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask  = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  
  

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_trill_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_inner_trill_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL_PORT_RULE_NUM_0 */     
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = 0x0; /* last program selection for Trill */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL); /* also ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL_USE_INITIAL_VID */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F); 
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x1); /* Double-tag refer to both TRILL and TRILL USE INITIAL VID */
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_inner_trill_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_untagged_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED_RULE */
     uint32 prog_indx1, /* ARAD_PP_ISEM_ACCESS_PROG_VT_PON_PRIORITY_TAG_RULE */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL; /* no tags */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_PON_DEFAULT); /* any pon port */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_PON_ANY_MASK);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_PCP; /* priority tags */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_PON_DEFAULT); /* any pon port */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_PON_ANY_MASK);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_untagged_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_one_tag_1_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG_RULE_NUM_0 */
     uint32 prog_sel
   )
{
  uint32
    res; 
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_PON_DEFAULT); /* any pon port */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_PON_ANY_MASK);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_one_tag_1_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_one_tag_2_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG_RULE_NUM_1 */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_PON_DEFAULT); /* any pon port */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_PON_ANY_MASK);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_one_tag_2_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_ignore_2nd_tag_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_PON_IGNORE_2ND_TAG_RULE*/
     uint32 prog_sel
   )
{
  uint32
    res; 
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | 
                                                               ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | 
                                                               ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID ); /* 2 tags 0,1 were checked before */
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_IGNORE_2ND_TAG); 
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_ignore_2nd_tag_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_two_tags_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_RULE */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | 
                                                               ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | 
                                                               ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID ); /* 2 tags 0,1 were checked before */
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_PON_DEFAULT); 
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_two_tags_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_two_tags_vs_tunnel_id_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID_RULE */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | 
                                                               ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | 
                                                               ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID ); /* 2 tags 0,1 were checked before */
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_PON_TUNNEL_ID); 
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_two_tags_vs_tunnel_id_set", prog_indx, prog_sel);
}

/* L1 + ELI, L2 + ELI, L3 + ELI
 *  L2=ELI 1st lkup on L1, No further actions on TT - No more labels
 *  L2!=ELI, 1st lkup L1, 2nd lkup: (a) L3=ELI, lkup L2 in L2+ELI
 *                                  (b) L2=NIR & L3!=ELI, lkup L2 in L2
 */

/* check L1+ELI for Untagged pkts - */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vdxinitialvid_l1_l2eli_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI_RULE_NUM_0 */
     uint32 prog_indx1, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI_RULE_NUM_1 */     
     uint32 prog_sel 
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* UnTagged packets, assume one-tag packets already matched */ 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L2ELI | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_1st_cam_tbl.packet_format_code            = (0x6); /* At least 2 MPLS labels */  
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x19); /* 6'b01_1001 */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile           = (0x0);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask       = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK);
  prog_selection_1st_cam_tbl.llvp_prog_sel                     = prog_sel;
  prog_selection_1st_cam_tbl.valid                       = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* UnTagged and priority packets, assume one-tag packets already matched */ 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L2ELI | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_1st_cam_tbl.packet_format_code            = (0x6); /* At least 2 MPLS labels */  
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x19); /* 6'b01_1001 */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile           = (0x0);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask       = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK);
  prog_selection_1st_cam_tbl.llvp_prog_sel                     = prog_sel;
  prog_selection_1st_cam_tbl.valid                       = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);   

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vdxinitialvid_l1_l2eli_set", prog_indx0, prog_sel);
}

/* check L2=ELI for Tagged pkts */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vdxoutervid_l1_l2eli_set(
     int unit,
     uint32 prog_indx0,/* ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI_RULE*/
     uint32 prog_indx1,
     uint32 prog_sel
   )
{
  uint32
    res; 
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* ELI Tagged packets Outer-tag1 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);

  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L2ELI | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);

  prog_selection_1st_cam_tbl.packet_format_code            = (0x6); /* At least 2 MPLS labels */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile           = (0x0);
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x19); /* 6'b01_1001 */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask       = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID);
  prog_selection_1st_cam_tbl.llvp_prog_sel                     = prog_sel;
  prog_selection_1st_cam_tbl.valid                       = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  /* ELI Tagged packets Outer-tag2 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);

  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L2ELI | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);

  prog_selection_1st_cam_tbl.packet_format_code            = (0x6); /* At least 2 MPLS labels */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile           = (0x0);
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x19); /* 6'b01_1001 */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask       = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID);
  prog_selection_1st_cam_tbl.llvp_prog_sel                     = prog_sel;
  prog_selection_1st_cam_tbl.valid                       = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);



exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vdxoutervid_l1_l2eli_set", prog_indx0, prog_sel);
}

/* 
 *  L1 = FRR on 1st cycle check {L1,L2} and L1,                                                   
 *  on 2nd cycle check L3 if L1=FRR or L2 if L1!=FRR                                              
 *  Note: FRR is portProfile attribute                                                            
 *  check {L1,L2} and L1 for Untagged pkts 
 */

/* check {L1,L2} and L1 */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_l1frr_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR_RULE_NUM_0 */
     uint32 prog_indx1, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR_RULE_NUM_1 */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  if (prog_indx0 != SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines)) 
  {
    res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
    SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

    /* FRR for UnTagged, assume one-tag packets already matched */
    prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL);
    prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
    prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (0x0);
    prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
    prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */   
    prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING; /* ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING_USE_INITIAL_VID */
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID | ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_DOUBLE_TAG);
    prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
    prog_selection_1st_cam_tbl.valid                     = (0x1);
    
    res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
    SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  }
  
  if (prog_indx1 != SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines)) 
  {
    res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
    SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

    /* FRR for UnTagged and priority packets, assume one-tag packets already matched */
    prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_PCP);
    prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
    prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (0x0);
    prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
    prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */    
    prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING; /* ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING_USE_INITIAL_VID */
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID | ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_DOUBLE_TAG);
    prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
    prog_selection_1st_cam_tbl.valid                     = (0x1);
    
    res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
    SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  }

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_l1frr_set", prog_indx0, prog_sel);
}

/* check {L1,L2} and L1 */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outervid_l1frr_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR_RULE */
     uint32 prog_indx1,
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* FRR for Tagged packets Outer-tag1 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (0x0);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING;
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* FRR for Tagged packets Outer-tag2 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (0x0);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING;
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  
  

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outervid_l1frr_set", prog_indx0, prog_sel);
}

/* 
 *  
 * Coupling: on 1st cyclst cycle check {L1,L2}, on 2nd cycle check {L3,L4}
 * Coupling is decided according to ETH_TYPE - 0x7                                                      
 * check {L1,L2} for UnTagged pkts 
 */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_l1l2_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2_RULE_NUM_0 */
     uint32 prog_indx1,     
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Coupling for UnTagged, assume one-tag packets already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS_COUPLING | ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (0x0);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 |ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING); /* ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING_USE_INITIAL_VID */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  /* Coupling for priority packets, assume one-tag packets already matched */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS_COUPLING | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_PCP);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (0x0);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 |ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING); /* ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING_USE_INITIAL_VID */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_INITIAL_VID);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
  
exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_l1l2_set", prog_indx0, prog_sel);
}

/* check {L1,L2} for Tagged pkts */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outervid_l1l2_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2_RULE */
     uint32 prog_indx1,
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Coupling for Tagged packets Outer-tag1 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS_COUPLING | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (0x0);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 |ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Coupling for Tagged packets Outer-tag2 */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS_COUPLING | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2);
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2     = (0x0);
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 |ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile         = (ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outervid_l1l2_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_initial_vid_set(
     int unit,
     uint32 prog_indx0, /* ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIALVID_RULE */
     uint32 prog_indx1,
     uint32 prog_sel
   )
{
  uint32
    res; 
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Assuming outer tag already checked, untagged or priority */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL; /* no tags */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x2);  /*(PacketFormatCode[5]==0) ==> starts with ethernet and IHP_PFC_PART_IPV4 */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x38);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Assuming outer tag already checked, untagged or priority */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_PCP; /* no tags */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x2);  /*(PacketFormatCode[5]==0) ==> starts with ethernet and IHP_PFC_PART_IPV4 */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x38);
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_initial_vid_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_initial_vid_after_recycle_set(
     int unit,
     uint32 prog_indx0,
     uint32 prog_indx1,
     uint32 prog_sel
   )
{
  uint32
    res; 
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Assuming outer tag already checked, untagged or priority */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL; /* no tags */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x2);  /*(PacketFormatCode[5]==0) ==> starts with ethernet and IHP_PFC_PART_IPV4 */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x38);
  prog_selection_1st_cam_tbl.ptc_vt_profile                 = (ARAD_PORTS_VT_PROFILE_OVERLAY_RCY);
  prog_selection_1st_cam_tbl.ptc_vt_profile_mask            = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx0, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Assuming outer tag already checked, untagged or priority */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_PCP; /* no tags */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x2);  /*(PacketFormatCode[5]==0) ==> starts with ethernet and IHP_PFC_PART_IPV4 */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x38);
  prog_selection_1st_cam_tbl.ptc_vt_profile                 = (ARAD_PORTS_VT_PROFILE_OVERLAY_RCY);
  prog_selection_1st_cam_tbl.ptc_vt_profile_mask            = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx1, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_initial_vid_set", prog_indx0, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_1_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_RULE_NUM_0 */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x2);  /* IHP_PFC_PART_IPV4 (3b???,3b010) (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x38); /* 6b11_1000 */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile        = (0x0);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask   =  ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID;
  prog_selection_1st_cam_tbl.llvp_prog_sel                = prog_sel;
  prog_selection_1st_cam_tbl.valid                        = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_1_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_2_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_RULE_NUM_1 */
     uint32 prog_sel
   )
{
  uint32
    res; 
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1     = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code          = (0x2);  /* IHP_PFC_PART_IPV4 (3b???,3b010) (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask      = (0x38); /* 6b11_1000 */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile        = (0x0);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask   =  ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID;
  prog_selection_1st_cam_tbl.llvp_prog_sel                   = prog_sel;
  prog_selection_1st_cam_tbl.valid                     = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_2_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_1_after_recycle_set(
     int unit,
     uint32 prog_indx,
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x2);  /* IHP_PFC_PART_IPV4 (3b???,3b010) (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x38); /* 6b11_1000 */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (0x0);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     =  ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID;
  prog_selection_1st_cam_tbl.ptc_vt_profile                 = (ARAD_PORTS_VT_PROFILE_OVERLAY_RCY);
  prog_selection_1st_cam_tbl.ptc_vt_profile_mask            = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_1_after_recycle_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_2_after_recycle_set(
     int unit,
     uint32 prog_indx,
     uint32 prog_sel
   )
{
  uint32
    res; 
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID2); /* one tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x2);  /* IHP_PFC_PART_IPV4 (3b???,3b010) (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x38); /* 6b11_1000 */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (0x0);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     =  ARAD_PP_ISEM_ACCESS_VT_PROFILE_MASK_EXCEPT_INITIAL_VID;
  prog_selection_1st_cam_tbl.ptc_vt_profile                 = (ARAD_PORTS_VT_PROFILE_OVERLAY_RCY);
  prog_selection_1st_cam_tbl.ptc_vt_profile_mask            = (0x0);
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_2_after_recycle_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_evb_stag_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG_RULE */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_OUTER_TPID1); /* one s tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (ARAD_PP_PORT_DEFINED_VT_PROFILE_EVB); /* EVB port */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = 0x0;
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_evb_stag_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_evb_untag_ctag_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG_RULE */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* In case no Inner TPID then it is UN_C_TAG (OuterTPID = 1 is already checked ) */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL); /* one s tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x0);  /*Only PacketFormatCode[5] matters (PacketFormatCode[5]==0) ==> starts with ethernet */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (ARAD_PP_PORT_DEFINED_VT_PROFILE_EVB); /* EVB port */
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = 0x0;
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_evb_untag_ctag_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_single_tag_5_ip_tuple_set(
     int unit,
     uint32 prog_indx, /* */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* In case no Inner TPID then it is Initial (one-tag or untag) */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL); /* one s tag */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x2);  /*(PacketFormatCode[5]==0) ==> starts with ethernet and IHP_PFC_PART_IPV4 */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x38);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (SOC_PPC_PORT_DEFINED_VT_PROFILE_FLEXIBLE_Q_IN_Q );
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = 0x0;
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_single_tag_5_ip_tuple_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_1st_vt_double_tag_5_ip_tuple_set(
     int unit,
     uint32 prog_indx, /* */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* Must be double-tag no need to check */
  prog_selection_1st_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NULL); 
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_NXT_PROTOCOL | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID);
  prog_selection_1st_cam_tbl.packet_format_code             = (0x2);  /*(PacketFormatCode[5]==0) ==> starts with ethernet and IHP_PFC_PART_IPV4 */
  prog_selection_1st_cam_tbl.packet_format_code_mask        = (0x38);
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = (SOC_PPC_PORT_DEFINED_VT_PROFILE_FLEXIBLE_Q_IN_Q);          
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = 0x0;
  prog_selection_1st_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_1st_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_vt_double_tag_5_ip_tuple_set", prog_indx, prog_sel);
}

STATIC
uint32
  arad_pp_vtt_prog_sel_cam_key_program_1st_set(
    int unit,
    ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES *prog_soc_prop
  )
{
  uint32
    res,
    prog_indx = 0;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);


  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG].prog_used != -1) 
  {
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_tm_prog_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG, exit);
  }

  /* Exit here in case of TM init */
  if (SOC_DPP_CONFIG(unit)->arad->init.pp_enable == FALSE) 
  {
    ARAD_DO_NOTHING_AND_EXIT;
  }


  /* 
   * Ethernet logic in general: 
   * 1. One-tag packets and no priority (2 program selection per program) 
   * 2. Untagged, priority tag and Initial-VID port (2 program selection per program)
   * 3. Double-tag packets and no priority (1 program selection per program)    
   */

  /* 
   * PON logic: 
   * Special Port profile
   * 1. Untagged packet
   * 2. One tag packet
   * 3. Double tag packets under different PonPortprofile. 
   * {
   */
   
   
  /* Untagged and priority-tag */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_untagged_set(unit, prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED, exit);
    prog_indx++;
  }

  /* one-tag */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_one_tag_1_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG, exit);

    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_one_tag_2_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG, exit);
  }

  /* Double tags */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_two_tags_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_two_tags_vs_tunnel_id_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_pon_ignore_2nd_tag_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG, exit);
  }
  /* 
   * PON logic 
   * }
   */
   
  /* 
   * FRR logic: 
   * Special Port profile 
   * 1. Outer tag
   * 2. Untagged + priority + initial-VID
   * Note : no support for double-tag.
   * {   
   */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outervid_l1frr_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outervid_l1frr_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }  
  
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_l1frr_set(unit,prog_indx,prog_indx+1,
                                                                                vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR, exit);      
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_l1frr_set(unit,prog_indx,prog_indx+1,
                                                                              vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  /* 
   * FRR logic
   * }   
   */
   
  /*
   * Coupling logic:
   * Special port profile
   * 1. Outer tag
   * 2. Untagged + priority + initial-VID
   * Note : no support for double-tag. No support for coupling in indexed mode
   * {   
   */    
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outervid_l1l2_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }
  
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_l1l2_set(unit,prog_indx,prog_indx+1,
                                                                               vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2].prog_used);         
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }
  
  /*
   * Coupling logic
   * }
   */
   
  /*
   * EVB logic:
   * Special port profile
   * 1. Stag 
   * 2. Ctag or untagged
   * {
   */
  
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_evb_stag_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG].prog_used);                      
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG, exit);
  }  

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_evb_untag_ctag_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG, exit);
  }
  
  /*
   * EVB logic
   * }   
   */

  /* 
   * 5 tuple logic 
   * Special port profile 
   * 1. Untagged + Initial-VID 
   * 2. Double-tag 
   */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_single_tag_5_ip_tuple_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q, exit);    
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_double_tag_5_ip_tuple_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q, exit);    
  }


  /*
   * Trill logic:
   * Special port profile
   * 1. Designate-VID
   * 2. Outer tag
   * 3. Untagged + initial-VID
   * 4. Double-tag   
   * {
   */
  if (prog_soc_prop->trill_mode &&
      vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_designated_vid_trill_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL].prog_used);                 
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (prog_soc_prop->trill_mode &&
      vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_trill_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL].prog_used);                 
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }
   
  if (prog_soc_prop->trill_mode &&
      vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_trill_set(unit,prog_indx,prog_indx+1,
                                                                              vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL].prog_used);                       
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (prog_soc_prop->trill_mode &&
      vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL].prog_used != -1) 
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_inner_trill_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL].prog_used);                 
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL, exit);    
  }  
  /*
   * Trill logic
   * }
   */

  /*
   * Double-lookup logic:
   * Special port profile.
   * 1. In case packet is double-tagged then two lookups
   * 2. Otherwise one lookup (needed only in case MPLS database in ISEM-B, 
   * in case MPLS database is in ISEM-A then we already have matched programs for that. 
   * {
   */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_high_vd_outer_inner_or_low_vd_outer_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER, exit);
    prog_indx++; /* adding 2 program selections in one call */
  } 

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_high_vd_outer_inner_or_low_vd_outer_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }
  
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_double_tag_pri_initialvid_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID, exit);
    prog_indx++; /* adding 2 program selections in one call */
  } 

  /*
   * Defaults in case of no match in double lookup. 
   * Two cases: 
   * 1. Single-tag and Untagged packets which dont match Double tag special programs. 
   *  Note: Only needed in case MPLS deafults located in ISEM-B then we dont have existed program
   *  that can use Bridge database in ISEM-B.
   *  Note2: Double lookup port will support MPLS only in case MPLS database is located in SEM-A.
   */      
  if (prog_soc_prop->mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B &&
       vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL].prog_used != -1) 
  {
    /* Add new program selections for outer vid in SEM-B */    
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY,
                                                                   vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL].prog_used);                        
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL, exit); 
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (prog_soc_prop->mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B &&
      vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL].prog_used != -1) 
  {    
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_lookup_initialvid_set(unit,prog_indx,                                                                        
                                                                      vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL].prog_used);                            
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL, exit);    
  }      

  /*
   * Double-lookup logic
   * }
   */
  
  /*
   * Logic for special PCP programs 
   * 1. Tagged 
   * 2. Untag 
   * 3. Double-tag 
   * Note: In case PCP programs are set no IP , MPLS tunnels can be used
   * {
   */ 
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,
                                                                   vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (prog_soc_prop->port_vlan_pcp_lookup &&
      vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_set(unit,prog_indx,prog_indx+1,
                                                                        SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,                                                                        
                                                                        vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1].prog_used);      
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }    

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_inner_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used);                        
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP, exit);    
  }    
  
  /*
   * Logic for special PCP programs
   * }
   */  
   
  /*
   * Logic for special 64K programs 
   * 1. Tagged 
   * 2. Untag 
   * 3. Double-tag
   * Note: In case 64K programs are set no IP , MPLS tunnels can be used
   */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,
                                                                   vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_set(unit,prog_indx,prog_indx+1,
                                                                        SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,                                                                        
                                                                        vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID].prog_used);      
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_inner_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_used);                        
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER, exit);    
  }
  
  /*
   * Logic for special 64K programs
   * }
   */
    /*
     * Logic for IP-LIF-DUMMY
     * 1. Outer tag
     * 2. Untagged + priority + initial-VID
     * Note : no support for double-tag.
     * {
     */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_1_after_recycle_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE, exit);
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_2_after_recycle_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE, exit);
  }
  
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_initial_vid_after_recycle_set(unit,prog_indx,prog_indx+1,
                                                                           vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }  

  /*
   * Logic for IP tunnels
   * 1. Outer tag
   * 2. Untagged + priority + initial-VID
   * Note : no support for double-tag.
   * {
   */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_1_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID, exit);
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_outer_vid_2_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID, exit);
  }
  
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_ipv4_initial_vid_set(unit,prog_indx,prog_indx+1,
                                                                           vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }  
  /*
   * Logic for IP tunnels
   * }
   */
  
  /* 
   * MPLS logic 
   * 1. ELI valid for Unindex and Indexed - second MPLS label is ELI.     
   *  a. In case tagged
   *  b. In case untagged or priority or Initial-VID
   * Note: ELI is not valid when MPLS context include RIF. 
   * 2. MPLS context RIF 
   *  a. In case tagged
   *  b. In case untagged or priority or Initial-VID
   * Note: Also used as default programs in case there is not match so far
   * {
   */

  /* ELI logic { */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vdxoutervid_l1_l2eli_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vdxinitialvid_l1_l2eli_set(unit,prog_indx,prog_indx+1,
                                                                                   vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI].prog_used);    
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI, exit);
    prog_indx++; /* adding 2 program selections in one call */
  } 
  
  /* ELI logic } */ 

  /* MPLS context RIF logic { */

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,
                                                                   vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_set(unit,prog_indx,prog_indx+1,
                                                                        SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,                                                                                                                                                
                                                                        vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3].prog_used);      
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }
  /* MPLS context RIF logic } */


  /* MPLS Defaults Unindex { */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,
                                                                   vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }  
  
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_set(unit,prog_indx,prog_indx+1,
                                                                          SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,                                                                          
                                                                          vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }     
  /* MPLS Defaults Unindex } */


  /* MPLS Defaults Indexed { */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_set(unit,prog_indx,prog_indx+1,
                                                                   SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,
                                                                   vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }    

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_initialvid_set(unit,prog_indx,prog_indx+1,
                                                                          SOC_PPC_NOF_PORT_DEFINED_VT_PROFILES,                                                               
                                                                          vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }
  /* MPLS Defaults Indexed } */  

  /* Double-tag packets which dont match MAC termination programs. */
  /* Double tag defaults { */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_outer_inner_set(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER].prog_used);                        
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER, exit);    
  }  
  /* Double tag defaults } */  

  /* Test programs Untagged then Double-tag then Single-tag { */
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_untagged_tst_explicit_null_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL].prog_used);                        
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL, exit);    
    prog_indx++; /* adding 2 program selections in one call */
  }  

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_untagged_tst(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID].prog_used);                        
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID, exit);    
  }  

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_tag_tst_explicit_null_set(unit,prog_indx,prog_indx+1,
                                                                          vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG].prog_used != -1) 
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_double_tag_tst(unit,prog_indx,prog_indx+1,
                                                                          vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG, exit);
    prog_indx++; /* adding 2 program selections in one call */
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL].prog_used != -1)
  {
    SET_VT_2_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_single_tag_tst_explicit_null_set(unit,prog_indx,prog_indx+1,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL].prog_used);                        
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL, exit);
    prog_indx++; /* adding 2 program selections in one call */    
  } 

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG].prog_used != -1)
  {
    SET_VT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_1st_vt_vd_single_tag_tst(unit,prog_indx,vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG].prog_used);                        
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG, exit);    
  } 
  /* Test programs Untagged > Double-tag > Single-tag } */

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_1st_set()", prog_indx, 0);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_tm_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TM_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  
  prog_selection_2nd_cam_tbl.packet_format_code     = (0x20);
  prog_selection_2nd_cam_tbl.packet_format_code_mask = (0x1F);
  prog_selection_2nd_cam_tbl.llvp_prog_sel              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                = (0x1);
     
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_tm_prog_set", prog_indx, prog_sel);
}

/* L3!=ELI, lkup L2 */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_L2_RULE_NUM */
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 tunnel_termination_in_tt_only, /* 1 - MPLS termination is done only in TT */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask            = (0x7F);
  if (tunnel_termination_in_tt_only) {
    prog_selection_2nd_cam_tbl.packet_format_code                        = (ARAD_PP_ISEM_PFC_PART_MPLS3); /* At least 3 labels */
    prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x18); /* ignore only 3:4 bits as 0:2 tell us about MPLS3; and bit 5 that it is ethernet packet */
    prog_selection_2nd_cam_tbl.in_pp_port_tt_profile                     = (SOC_PPC_PORT_DEFINED_TT_PROFILE_EXPLICIT_NULL);
    prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                = (0x0);
    prog_selection_2nd_cam_tbl.tcam_lookup_match                         = (0x1);
    prog_selection_2nd_cam_tbl.tcam_lookup_match_mask                    = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.packet_format_code                       = (0x0); 
    prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x1F);
  }
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                                = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                  = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_set", prog_indx, prog_sel);
}

/*
 * P13 
 * L1 = FRR --> expected MATCH on ISA
 * lkup L3                                                                                                     
 */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l3_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_L3_RULE */
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask  = (0x7F);

  prog_selection_2nd_cam_tbl.packet_format_code                       = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x1F);
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile                      = ARAD_PP_PORT_DEFINED_TT_PROFILE_FRR_COUPLING;
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                  = (0x0);
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.tcam_lookup_match                         = (0x1); /* {L1,L2}->Match */
  prog_selection_2nd_cam_tbl.tcam_lookup_match_mask                    = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel                                = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                  = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l3_set", prog_indx, prog_sel);
}


/* L3=ELI, lkup L2 in +ELI DB */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3eli_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI_RULE_NUM */
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask             = (0x7F);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2                 = ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L3ELI;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask             = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);

  prog_selection_2nd_cam_tbl.packet_format_code                       = (0x7); /* 3 MPLS labels */
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x18); /*6'b011000*/
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                                =prog_sel;
  prog_selection_2nd_cam_tbl.valid                                  = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3eli_set", prog_indx, prog_sel);
}

/* 
 *  2nd cycle Coupling; lkup {L3,L4}                                                                         
 * first cycle  was on both ISA and ISB - A match is expected on either one
 */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_coupling_l3_l4_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4_RULE_NUM */
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS_COUPLING);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask             = (0x7F);

  prog_selection_2nd_cam_tbl.packet_format_code                       = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x1F);
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile                      = (ARAD_PP_PORT_DEFINED_TT_PROFILE_FRR_COUPLING);
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                  = (0x0);
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                                = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                  = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_coupling_l3_l4_set", prog_indx, prog_sel);
}

/* TT Rule #2 L2=ELI -> lkup L1+ELI + Index (with\without In-RIF) */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_indx_l1_l2eli_inrif_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_RULE_NUM */
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask             = (0x7F);
                                                               
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2                 = ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L2ELI;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask             = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
                                                               
  prog_selection_2nd_cam_tbl.packet_format_code                       = (0x6); /* At least 2 MPLS labels */
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x19); /* 6'b011001 */
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile                      = (0x0);
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                  = (0x0);
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                                = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                  = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_indx_l1_l2eli_inrif_set", prog_indx, prog_sel);
}

/* Decide according to 1 label in stack only */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_set(
     int unit,
     uint32 prog_indx, 
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask            = (0x7F);
  prog_selection_2nd_cam_tbl.packet_format_code                        = (ARAD_PP_ISEM_PFC_PART_MPLS1); /* Only one label in stack */
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x18); /* ignore only 3:4 bits as 0:2 tell us about MPLS1; and bit 5 that it is ethernet packet */
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                      = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_set", prog_indx, prog_sel);
}

/* Decide according to 2 labels in stack only and GAL indication */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_gal_set(
     int unit,
     uint32 prog_indx, 
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask            = (0x7F);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2                 = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L1GAL);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask            = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_2nd_cam_tbl.packet_format_code                        = (ARAD_PP_ISEM_PFC_PART_MPLS2); /* Only one label in stack */
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x18); /* ignore only 3:4 bits as 0:2 tell us about MPLS2; and bit 5 that it is ethernet packet */
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                      = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_gal_set", prog_indx, prog_sel);
}


/* Decide according to 1 label in stack only */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_l2_set(
     int unit,
     uint32 prog_indx, 
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask            = (0x7F);
  prog_selection_2nd_cam_tbl.packet_format_code                        = (ARAD_PP_ISEM_PFC_PART_MPLS2); /* Only two labels in stack */
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x18); /* ignore only 3:4 bits as 0:2 tell us about MPLS1; and bit 5 that it is ethernet packet */
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                      = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_l2_set", prog_indx, prog_sel);
}

/* Decide according to 1 label in stack only */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l2_set(
     int unit,
     uint32 prog_indx, 
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask            = (0x7F);
  prog_selection_2nd_cam_tbl.packet_format_code                        = (ARAD_PP_ISEM_PFC_PART_MPLS2); /* Only two labels in stack */
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x18); /* ignore only 3:4 bits as 0:2 tell us about MPLS1; and bit 5 that it is ethernet packet */
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.tcam_lookup_match                          = (0x1); /* Hit TCAM with Explicit NULL */
  prog_selection_2nd_cam_tbl.tcam_lookup_match_mask                     = (0x0);
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile                      = (SOC_PPC_PORT_DEFINED_TT_PROFILE_EXPLICIT_NULL);
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                 = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel                              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                      = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l2_set", prog_indx, prog_sel);
}

/* Decide according to 1 label in stack only */
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_l2_gal_set(
     int unit,
     uint32 prog_indx, 
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask            = (0x7F);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2                 = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_L2GAL);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask            = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_BOS_NEXT_PROT);
  prog_selection_2nd_cam_tbl.packet_format_code                        = (ARAD_PP_ISEM_PFC_PART_MPLS3); /* Only three labels in stack */
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x18); /* ignore only 3:4 bits as 0:2 tell us about MPLS1; and bit 5 that it is ethernet packet */
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                      = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_l2_gal_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3_gal_set(
     int unit,
     uint32 prog_indx, 
     uint32 is_mpls_tp_mc_mac_address, /* 1 - MPLS TP MC reserved address, 0 - regular mymac */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_qualifier_1                 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MPLS);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask            = (0x7F);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2                 = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask            = (ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L1 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L2 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_L3 | ARAD_PP_ISEM_ACCESS_QLFR_MPLS_MASK_NEXT_PROT);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_3_outer_vid_bits  = (0x1); /* GAL is set in Q3 */
  prog_selection_2nd_cam_tbl.packet_format_qualifier_3_outer_vid_bits_mask = (0x6);
  prog_selection_2nd_cam_tbl.packet_format_code                        = (ARAD_PP_ISEM_PFC_PART_MPLS3); /* at least three labels in stack */
  prog_selection_2nd_cam_tbl.packet_format_code_mask                   = (0x18); /* ignore only 3:4 bits as 0:2 tell us about MPLS1; and bit 5 that it is ethernet packet */
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile                     = (SOC_PPC_PORT_DEFINED_TT_PROFILE_EXPLICIT_NULL);
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                = (0x0);
  prog_selection_2nd_cam_tbl.tcam_lookup_match                         = (0x1);
  prog_selection_2nd_cam_tbl.tcam_lookup_match_mask                    = (0x0);
  if (is_mpls_tp_mc_mac_address) {
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges                      = (0x1);
    prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                 = (0x0);
  } else {
    prog_selection_2nd_cam_tbl.my_mac                                   = (0x1);
    prog_selection_2nd_cam_tbl.my_mac_mask                              = (0x0);
  }
  prog_selection_2nd_cam_tbl.llvp_prog_sel                              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                                      = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3_gal_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_mac_in_mac_with_btag_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /*prog_selection_2nd_cam_tbl.in_pp_port_tt_profile     = ARAD_PP_IN_PP_PORT_TT_PROFILE_RCY; */
  /*prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask = 0; */
  prog_selection_2nd_cam_tbl.packet_format_code     = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_code_mask = (0x1F);
  prog_selection_2nd_cam_tbl.my_mac                = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask            = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MAC_IN_MAC);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask = (0x7F);
  prog_selection_2nd_cam_tbl.llvp_prog_sel              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_mac_in_mac_with_btag_prog_set", prog_indx, prog_sel);
}


STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_mac_in_mac_mc_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MAC_MC_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code             = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_code_mask        = (0x1F);
  prog_selection_2nd_cam_tbl.my_mac                         = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask                    = (0x0);
  prog_selection_2nd_cam_tbl.my_b_mac_mc                    = (0x1);
  prog_selection_2nd_cam_tbl.my_b_mac_mc_mask               = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1      = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MAC_IN_MAC);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask = (0x7F);
  prog_selection_2nd_cam_tbl.ptc_tt_profile                 = (ARAD_PORTS_TT_PROFILE_NONE);
  prog_selection_2nd_cam_tbl.ptc_tt_profile_mask            = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel                  = prog_sel;
  prog_selection_2nd_cam_tbl.valid                          = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_mac_in_mac_mc_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_fc_with_vft_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_2ND_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /* according to PLC (FC no VFT)  and MY-MAC */
  prog_selection_2nd_cam_tbl.parser_leaf_context            = (ARAD_PMF_PGM_SEL_PARSER_PROFILE_FCOE_VFT);
  prog_selection_2nd_cam_tbl.parser_leaf_context_mask            = (0x0);
  prog_selection_2nd_cam_tbl.my_mac                 = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask            = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_code = ARAD_PARSER_PKT_HDR_STK_TYPE_FC_STD_ETH;
  prog_selection_2nd_cam_tbl.packet_format_code_mask = 0;
  prog_selection_2nd_cam_tbl.llvp_prog_sel              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_fc_with_vft_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_arp_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code     = ARAD_PP_ISEM_PFC_E;
  prog_selection_2nd_cam_tbl.packet_format_code_mask = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2 = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask = (0x7FF);
  prog_selection_2nd_cam_tbl.my_mac                 = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask            = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1 = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_ARP);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask = (0x7F);
  prog_selection_2nd_cam_tbl.llvp_prog_sel              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_arp_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_fc_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_FC_2ND_RULE_NUM*/
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  /*FCF WITH VFT */
 /* according to PLC (FC no VFT)  and MY-MAC */
  prog_selection_2nd_cam_tbl.parser_leaf_context            = (ARAD_PMF_PGM_SEL_PARSER_PROFILE_FCOE_VFT);
  prog_selection_2nd_cam_tbl.parser_leaf_context_mask       = (0x1);
  prog_selection_2nd_cam_tbl.my_mac                         = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask                    = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_code = ARAD_PARSER_PKT_HDR_STK_TYPE_FC_ENCAP_ETH;
  prog_selection_2nd_cam_tbl.packet_format_code_mask = 1;
  prog_selection_2nd_cam_tbl.llvp_prog_sel              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                = (0x1);
  


  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_fc_prog_set", prog_indx, prog_sel);
}


STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_control_packets_prog_set(
     int unit,
     uint32 prog_indx, /* */
     uint32 prog_sel     
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is exactly ipv4 header & mymac is on. No catch of IP terminated header above so do only router */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code               = 0x2;/*6b00_0010; (should catch IHP_PFC_PART_IPV4 (3b???,3b010) or IHP_PFC_PART_IPV6 (3b???,3b011)*/
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = 0x0;/*6b00_0001;*/ 
  prog_selection_2nd_cam_tbl.my_mac                           = 0x1;/*1b1;*/
  prog_selection_2nd_cam_tbl.my_mac_mask                      = 0x0;
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_control_packets_prog_set", prog_indx, prog_sel);
}


STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_compatiblemc_2nd_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_IP_ROUTER_CompatibleMc_2ND_RULE_NUM */
     uint32 prog_sel,
     uint32 ipv4_comp_mc_disable
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4/ipv6 header & ip compatible mc is on */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code               = 0x3;/*6b00_0011; (should catch IHP_PFC_PART_IPV4 (3b???,3b010) or IHP_PFC_PART_IPV6 (3b???,3b011)*/
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = (ipv4_comp_mc_disable) ? 0x38:0x39;/*6b11_1001;*/ /* Include or not IPV4 */
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc          = 0x1;/*1b1;*/
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc_mask     = 0x0;/*1b0;*/
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_compatiblemc_2nd_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_dip_not_found_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_IPV4_ROUTER_TT_DIP_NOT_FOUND_PROG_RULE_NUM */
     uint32 mpls_1_database,
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4 & DIP lookup was not found */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code               = 0x2;/*6b00_0010; (should catch IHP_PFC_PART_IPV4 (3b???,3b010) or IHP_PFC_PART_IPV6 (3b???,3b011)*/
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = 0x38;/*6b11_1000;*/
  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) 
  {
    prog_selection_2nd_cam_tbl.isb_lookup_found                 = 0x0;
    prog_selection_2nd_cam_tbl.isb_lookup_found_mask            = 0x0;  
  }
  else
  {
    prog_selection_2nd_cam_tbl.isa_lookup_found                 = 0x0;
    prog_selection_2nd_cam_tbl.isa_lookup_found_mask            = 0x0;
  }
  
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc          = 0x1;
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc_mask     = 0x0;
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_dip_not_found_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_uc_dip_not_found_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_IPV4_ROUTER_TT_UC_DIP_NOT_FOUND_PROG_RULE_NUM */
     uint32 mpls_1_database, /* Same as IP tunnel database */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4 & DIP lookup was not found */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code               = 0x2;/*6b00_0010; (should catch IHP_PFC_PART_IPV4 (3b???,3b010) or IHP_PFC_PART_IPV6 (3b???,3b011)*/
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = 0x38;/*6b11_1000;*/   
  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) 
  {
    prog_selection_2nd_cam_tbl.isb_lookup_found                 = 0x0;
    prog_selection_2nd_cam_tbl.isb_lookup_found_mask            = 0x0;
  }
  else
  {
    prog_selection_2nd_cam_tbl.isa_lookup_found                 = 0x0;
    prog_selection_2nd_cam_tbl.isa_lookup_found_mask            = 0x0;
  }
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc          = 0x0;
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc_mask     = 0x0;
  prog_selection_2nd_cam_tbl.my_mac                           = 0x1;
  prog_selection_2nd_cam_tbl.my_mac_mask                      = 0x0;
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_uc_dip_not_found_prog_set", prog_indx, prog_sel);
}

uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_pwe_gre_ipmc_overlay_after_recycle_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_IPMC_OVERLAY_AFTER_RECYCLE_RULE_NUM */
     uint32 prog_sel,
     uint32 ipv4_comp_mc_disable
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4/ipv6 header & ip compatible mc is on */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code               = 0x2;/*6b00_0011; (should catch IHP_PFC_PART_IPV4 (3b???,3b010) or IHP_PFC_PART_IPV6 (3b???,3b011)*/
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = (ipv4_comp_mc_disable) ? 0x38:0x39;/*6b11_1001;*/ /* Include or not IPV4 */
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc          = 0x1;/*1b1;*/
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc_mask     = 0x0;/*1b0;*/
  prog_selection_2nd_cam_tbl.ptc_tt_profile                   = ARAD_PORTS_TT_PROFILE_OVERLAY_RCY;
  prog_selection_2nd_cam_tbl.ptc_tt_profile_mask              = 0x0;
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2        = ARAD_PP_ISEM_ACCESS_QLFR_IP_NEXT_PROTOCOL_MPLS;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask   = (0x7F);
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_pwe_gre_ipmc_overlay_after_recycle_prog_set", prog_indx, prog_sel);
}

uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipmc_overlay_after_recycle_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_IPMC_OVERLAY_AFTER_RECYCLE_RULE_NUM */
     uint32 prog_sel,
     uint32 ipv4_comp_mc_disable
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4/ipv6 header & ip compatible mc is on */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code               = 0x2;/*6b00_0011; (should catch IHP_PFC_PART_IPV4 (3b???,3b010) or IHP_PFC_PART_IPV6 (3b???,3b011)*/
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = (ipv4_comp_mc_disable) ? 0x38:0x39;/*6b11_1001;*/ /* Include or not IPV4 */
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc          = 0x1;/*1b1;*/
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc_mask     = 0x0;/*1b0;*/
  prog_selection_2nd_cam_tbl.ptc_tt_profile                   = ARAD_PORTS_TT_PROFILE_OVERLAY_RCY;
  prog_selection_2nd_cam_tbl.ptc_tt_profile_mask              = 0x0;
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipmc_overlay_after_recycle_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_unknown_l3_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4/ipv6 header & ip compatible mc is on */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code               = ARAD_PP_ISEM_PFC_E;
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = 0x0;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1        = ARAD_PP_ISEM_ACCESS_QLFR_ETH_NEXT_PROTOCOL_MISS; /* Next-Protocol-None | None */
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask   = (ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_ENCAP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_TPID | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_OUTER_PCP | ARAD_PP_ISEM_ACCESS_QLFR_ETH_MASK_INNER_TPID );
  prog_selection_2nd_cam_tbl.my_mac                           = 0x1;
  prog_selection_2nd_cam_tbl.my_mac_mask                      = 0x0;
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_unknown_l3_prog_set", prog_indx, prog_sel);
}


STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_vpls_gre_ipv4_router_tt_dip_found_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_IPV4_ROUTER_TT_DIP_FOUND_PROG_RULE_NUM */
     uint32 prog_sel,
     uint32 mpls_1_database,
     uint32 ipv4_comp_mc_disable,
     uint32 ipv4_term_dip_sip_enable
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4 header */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code      = (0x2);  /*(IHP_PFC_PART_IPV4 (3b???,(0x2))) */
  prog_selection_2nd_cam_tbl.packet_format_code_mask = (0x38);
  if (ipv4_term_dip_sip_enable == 0 && mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) {
    prog_selection_2nd_cam_tbl.isb_lookup_found        = (0x1);
    prog_selection_2nd_cam_tbl.isb_lookup_found_mask   = ipv4_comp_mc_disable ? 0x0:0x1; /* always go to DIP found in case of IPMC compatible application enabled */
  } else if (ipv4_term_dip_sip_enable == 0 && mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
    prog_selection_2nd_cam_tbl.isa_lookup_found        = (0x1);
    prog_selection_2nd_cam_tbl.isa_lookup_found_mask   = ipv4_comp_mc_disable ? 0x0:0x1; /* always go to DIP found in case of IPMC compatible application enabled */
  } else {
    prog_selection_2nd_cam_tbl.tcam_lookup_match        = (0x1);
    prog_selection_2nd_cam_tbl.tcam_lookup_match_mask   = ipv4_comp_mc_disable ? 0x0:0x1; /* always go to DIP found in case of IPMC compatible application enabled */
  }
  prog_selection_2nd_cam_tbl.my_mac                  = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask             = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2        = ARAD_PP_ISEM_ACCESS_QLFR_IP_NEXT_PROTOCOL_MPLS;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask   = (0x7F);
  prog_selection_2nd_cam_tbl.llvp_prog_sel           = prog_sel;
  prog_selection_2nd_cam_tbl.valid                   = (0x1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_vpls_gre_ipv4_router_tt_dip_found_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_dip_found_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_IPV4_ROUTER_TT_DIP_FOUND_PROG_RULE_NUM */
     uint32 prog_sel,
     uint32 mpls_1_database,
     uint32 ipv4_comp_mc_disable,
     uint32 ipv4_term_dip_sip_enable
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv4 header */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code      = (0x2);  /*(IHP_PFC_PART_IPV4 (3b???,(0x2))) */
  prog_selection_2nd_cam_tbl.packet_format_code_mask = (0x38);
  if (ipv4_term_dip_sip_enable == 0 && mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) {
    prog_selection_2nd_cam_tbl.isb_lookup_found        = (0x1);
    prog_selection_2nd_cam_tbl.isb_lookup_found_mask   = ipv4_comp_mc_disable ? 0x0:0x1; /* always go to DIP found in case of IPMC compatible application enabled */
  } else if (ipv4_term_dip_sip_enable == 0 && mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
    prog_selection_2nd_cam_tbl.isa_lookup_found        = (0x1);
    prog_selection_2nd_cam_tbl.isa_lookup_found_mask   = ipv4_comp_mc_disable ? 0x0:0x1; /* always go to DIP found in case of IPMC compatible application enabled */
  } else {
    prog_selection_2nd_cam_tbl.tcam_lookup_match        = (0x1);
    prog_selection_2nd_cam_tbl.tcam_lookup_match_mask   = ipv4_comp_mc_disable ? 0x0:0x1; /* always go to DIP found in case of IPMC compatible application enabled */
  }
  prog_selection_2nd_cam_tbl.my_mac                  = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask             = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel           = prog_sel;
  prog_selection_2nd_cam_tbl.valid                   = (0x1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_dip_found_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv6_router_2nd_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_IPV6_ROUTER_2ND_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  /* Match: packet format code is ipv6 header */
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code               = 0x3;/*6b00_0011;  IHP_PFC_PART_IPV6 (3b???,3b011)*/
  prog_selection_2nd_cam_tbl.packet_format_code_mask          = 0x38;/*6b11_1000;*/
  prog_selection_2nd_cam_tbl.my_mac                           = 0x1;/*1b1;*/
  prog_selection_2nd_cam_tbl.my_mac_mask                      = 0x0;/*1b0;*/
  prog_selection_2nd_cam_tbl.llvp_prog_sel                    = prog_sel;
  prog_selection_2nd_cam_tbl.valid                            = 0x1;/*1b1;*/
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv6_router_2nd_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_bridge_star_2nd_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_BRIDGE_STAR_2ND_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code     = (0x0);
  prog_selection_2nd_cam_tbl.packet_format_code_mask = (0x1F);
  prog_selection_2nd_cam_tbl.my_mac                = (0x0);
  prog_selection_2nd_cam_tbl.my_mac_mask            = (0x0);  
  prog_selection_2nd_cam_tbl.llvp_prog_sel              = prog_sel;
  prog_selection_2nd_cam_tbl.valid                = (0x1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_bridge_star_2nd_prog_set", prog_indx, prog_sel);
}
 
STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_RULE_NUM */
     uint32 prog_sel,
     uint8  designated_vlan_disabled
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code       = ARAD_PP_ISEM_PFC_EoTRILLoE;
  prog_selection_2nd_cam_tbl.packet_format_code_mask  = (0x0);
  prog_selection_2nd_cam_tbl.my_mac                   = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask              = (0x0);
  prog_selection_2nd_cam_tbl.vlan_is_designated       = (0x1);
  prog_selection_2nd_cam_tbl.vlan_is_designated_mask  = (designated_vlan_disabled) ? (0x1) : (0x0);
  /* prog_selection_2nd_cam_tbl.parser_leaf_context      = (0x0); */
  /* prog_selection_2nd_cam_tbl.parser_leaf_context_mask = (0x0); */
  prog_selection_2nd_cam_tbl.isa_lookup_found         = (0x0);
  prog_selection_2nd_cam_tbl.isa_lookup_found_mask    = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel            = prog_sel;
  prog_selection_2nd_cam_tbl.valid                    = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_mc_prog_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_MC_PROG_RULE_NUM */
     uint32 prog_sel,
     uint8  designated_vlan_disabled
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code       = ARAD_PP_ISEM_PFC_EoTRILLoE;
  prog_selection_2nd_cam_tbl.packet_format_code_mask  = (0x0);
  prog_selection_2nd_cam_tbl.da_is_all_r_bridges      = (0x1);
  prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask = (0x0);
  prog_selection_2nd_cam_tbl.vlan_is_designated       = (0x1);
  prog_selection_2nd_cam_tbl.vlan_is_designated_mask  = (designated_vlan_disabled) ? (0x1) : (0x0);
  /* prog_selection_2nd_cam_tbl.parser_leaf_context      = (0x0); */
  /* prog_selection_2nd_cam_tbl.parser_leaf_context_mask = (0x0); */
  prog_selection_2nd_cam_tbl.isa_lookup_found         = (0x0);
  prog_selection_2nd_cam_tbl.isa_lookup_found_mask    = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel            = prog_sel;
  prog_selection_2nd_cam_tbl.valid                    = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_mc_prog_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_mc_prog_two_vlans_at_native_eth_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH */
     uint32 prog_sel,
     uint8  designated_vlan_disabled
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code       = ARAD_PP_ISEM_PFC_EoTRILLoE;
  prog_selection_2nd_cam_tbl.packet_format_code_mask  = (0x0);
  prog_selection_2nd_cam_tbl.da_is_all_r_bridges      = (0x1);
  prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask = (0x0);
  prog_selection_2nd_cam_tbl.vlan_is_designated       = (0x1);
  prog_selection_2nd_cam_tbl.vlan_is_designated_mask  = (designated_vlan_disabled) ? (0x1) : (0x0);
  /* prog_selection_2nd_cam_tbl.parser_leaf_context      = (0x8); */
  /* prog_selection_2nd_cam_tbl.parser_leaf_context_mask = (0x0); */
  prog_selection_2nd_cam_tbl.isa_lookup_found         = (0x1);
  prog_selection_2nd_cam_tbl.isa_lookup_found_mask    = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel            = prog_sel;
  prog_selection_2nd_cam_tbl.valid                    = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_mc_prog_two_vlans_at_native_eth_set", 0, 0);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_two_vlans_at_native_eth_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH_RULE_NUM */
     uint32 prog_sel,
     uint8  designated_vlan_disabled
   )
{
  uint32
    res;  
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code       = ARAD_PP_ISEM_PFC_EoTRILLoE;
  prog_selection_2nd_cam_tbl.packet_format_code_mask  = (0x0);
  prog_selection_2nd_cam_tbl.my_mac                   = (0x1);
  prog_selection_2nd_cam_tbl.my_mac_mask              = (0x0);
  prog_selection_2nd_cam_tbl.vlan_is_designated       = (0x1);
  prog_selection_2nd_cam_tbl.vlan_is_designated_mask  = (designated_vlan_disabled) ? (0x1) : (0x0);
  /* prog_selection_2nd_cam_tbl.parser_leaf_context      = (0x8); */
  /* prog_selection_2nd_cam_tbl.parser_leaf_context_mask = (0x0); */
  prog_selection_2nd_cam_tbl.isa_lookup_found         = (0x1);
  prog_selection_2nd_cam_tbl.isa_lookup_found_mask    = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel            = prog_sel;
  prog_selection_2nd_cam_tbl.valid                    = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_two_vlans_at_native_eth_set", prog_indx, prog_sel);
}

STATIC
uint32
   arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_trill_trap_set(
     int unit,
     uint32 prog_indx, /* ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_RULE_NUM */
     uint32 prog_sel
   )
{
  uint32
    res;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_get_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  prog_selection_2nd_cam_tbl.packet_format_code       = ARAD_PP_ISEM_PFC_EoTRILLoE;
  prog_selection_2nd_cam_tbl.packet_format_code_mask  = (0x0);
  prog_selection_2nd_cam_tbl.llvp_prog_sel            = prog_sel;
  prog_selection_2nd_cam_tbl.valid                    = (0x1);
  
  res = arad_pp_ihp_isem_2nd_program_selection_cam_tbl_set_unsafe(unit, prog_indx, &prog_selection_2nd_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

exit:
 SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_trill_trap_set", prog_indx, prog_sel);
}

STATIC
uint32
  arad_pp_isem_prog_sel_cam_key_program_2nd(
    int unit,
    ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES *prog_soc_prop
  )
{
  uint32
    prog_indx = 0,
    res;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG].prog_used != -1) 
  {
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_tm_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG, exit);    
  }

  /* Exit here in case of TM init */
  if (SOC_DPP_CONFIG(unit)->arad->init.pp_enable == FALSE) {
      ARAD_DO_NOTHING_AND_EXIT;
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L3].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l3_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L3].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L3, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l3_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L3].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L3, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l3_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l3_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_coupling_l3_l4_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_coupling_l3_l4_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4, exit);
    }
  }  

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_indx_l1_l2eli_inrif_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF, exit);
    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_indx_l1_l2eli_inrif_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3eli_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3eli_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3eli_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3eli_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3eli_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3eli_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI, exit);
    }
  }
  
  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_set(unit,prog_indx,0,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L2, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_set(unit,prog_indx,1,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L2, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_set(unit,prog_indx,0,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_set(unit,prog_indx,1,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF, exit);
    }
  }  

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_gal_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_gal_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_l2_gal_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_l2_gal_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3_gal_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l3_gal_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_set(unit,prog_indx,0,prog_soc_prop->tunnel_termination_in_tt_only,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_set(unit,prog_indx,1,prog_soc_prop->tunnel_termination_in_tt_only,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l2_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l2_l2_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2, exit);
    }
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_l2_set(unit,prog_indx,0,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2, exit);

    if (prog_soc_prop->mpls_tp_mac_address) 
    {
      SET_TT_PROGRAM_SELECTION(prog_indx);
      res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_l1_l2_set(unit,prog_indx,1,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2].prog_used);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2, exit);
    }
  }   

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_pwe_gre_ipmc_overlay_after_recycle_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG].prog_used,prog_soc_prop->ipv4mc_bidir_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipmc_overlay_after_recycle_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG].prog_used,prog_soc_prop->ipv4mc_bidir_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG].prog_used != -1)
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_mac_in_mac_mc_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_mac_in_mac_with_btag_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG, exit);    
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_arp_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG, exit);
  }
  
  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_control_packets_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG, exit);
  } 
   

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ip_router_compatiblemc_2nd_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG].prog_used,prog_soc_prop->ipv4mc_bidir_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_dip_not_found_prog_set(unit,prog_indx,
                                                                                            prog_soc_prop->mpls_1_database, /* Same as IP tunnel database */
                                                                                            tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG].prog_used != -1)
  { 
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_uc_dip_not_found_prog_set(unit,prog_indx,
                                                                                               prog_soc_prop->mpls_1_database, /* Same as IP tunnel database */
                                                                                               tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv6_router_2nd_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_vpls_gre_ipv4_router_tt_dip_found_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG].prog_used,
                                                                                                 prog_soc_prop->mpls_1_database,
                                                                                                 prog_soc_prop->ipv4mc_bidir_enable,prog_soc_prop->ipv4_term_dip_sip_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_ipv4_router_tt_dip_found_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG].prog_used,
                                                                                        prog_soc_prop->mpls_1_database,
                                                                                        prog_soc_prop->ipv4mc_bidir_enable,prog_soc_prop->ipv4_term_dip_sip_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG, exit);
  }
  
  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG].prog_used, prog_soc_prop->trill_disable_designated_vlan_check);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG, exit);

    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_mc_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG].prog_used, prog_soc_prop->trill_disable_designated_vlan_check);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_two_vlans_at_native_eth_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH].prog_used, prog_soc_prop->trill_disable_designated_vlan_check); 
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH, exit);
  }
  
  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_mc_prog_two_vlans_at_native_eth_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH].prog_used, prog_soc_prop->trill_disable_designated_vlan_check);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_trill_2nd_prog_trill_trap_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG, exit);
  }
  
  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_bridge_star_2nd_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG].prog_used);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_fc_with_vft_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG].prog_used);    
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_fc_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG].prog_used);             
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG].prog_used != -1) 
  {
    SET_TT_PROGRAM_SELECTION(prog_indx);
    res = arad_pp_vtt_prog_sel_cam_key_program_2nd_tt_unknown_l3_prog_set(unit,prog_indx,tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG].prog_used); 
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG, exit);
  }
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_prog_sel_cam_key_program_2nd()", prog_indx, 0);
}

STATIC
uint32
  arad_pp_isem_prog_programs_init(
    int unit
  )
{
  uint32
    i,
    res,
    tmp,
    last_tt_program_id = 0,
    last_vt_program_id = 0;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]
  
  for (i = 0; i < ARAD_PP_ISEM_ACCESS_PROG_VT_NOF_PROGS; i++) {
      vt_programs[unit][i].prog_used = -1;
  }

  for (i = 0; i < ARAD_PP_ISEM_ACCESS_PROG_TT_NOF_PROGS; i++) {
      tt_programs[unit][i].prog_used = -1;
  }

  /* VT  { */ 
  /* Always enabled */
  SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG);  
  
  /* Bridge, Q-in-Q */
  if (!prog_soc_prop.port_vlan_pcp_lookup && !prog_soc_prop.match_port_vlan_critiria_64K && !prog_soc_prop.custom_feature_vt_tst1) 
  {
    /* Defaults */
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER);
    if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled)
    {
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER); 
    }
    if (SOC_DPP_CONFIG(unit)->pp.port_use_initial_vlan_only_enabled)
    {
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID);
    }    

    /* Optimization: Instead of new programs , use trill programs in case it is a must and not added before */
    if (!prog_soc_prop.trill_mode && prog_soc_prop.mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) 
    {
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL);
      if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) {
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL);
      }      
    }
  }
  else if ((prog_soc_prop.port_vlan_pcp_lookup) && (!prog_soc_prop.match_port_vlan_critiria_64K))  
  {
    /* PCP is set but not 64K */
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER);    
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1); /* Initial-VID */
  } 
  else if ((!prog_soc_prop.port_vlan_pcp_lookup) && (prog_soc_prop.match_port_vlan_critiria_64K)) 
  {
    /* PCP is unset but 64K set */
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER);    
  }
  else if (prog_soc_prop.custom_feature_vt_tst1) {
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG);
    if (prog_soc_prop.explicit_null_support) {
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL);
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL);
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL);        
    }
  }
  else
  {
    /* Error: both 64k and pcp are set */
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 60, exit);
  }

  /* MPLS */
  /* MPLS is valid only in case we are not in a special Q-in-Q world */
  if ((!prog_soc_prop.port_vlan_pcp_lookup) && (!prog_soc_prop.match_port_vlan_critiria_64K) && (!prog_soc_prop.custom_feature_vt_tst1)) 
  {
    if (!prog_soc_prop.mpls_use_in_rif)
    {
      if (prog_soc_prop.eli_enable) 
      {
        /* ELI is valid only in case MPLS context is not per RIF */
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI);
        if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
        {
          SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI);
        }
      }
    }
    if (!prog_soc_prop.mpls_index && !prog_soc_prop.mpls_use_in_rif) 
    {
      /* Unindex MPLS. No MPLS context RIF */
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1);
      if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
      {
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1);      
      }
      if (prog_soc_prop.fast_reroute_labels_enable) 
      {
        /* FRR */
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR);
        if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
        {
          SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR);
        }
      }
      if (prog_soc_prop.coupling_enable) 
      {
        /* Coupling */
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2);
        if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
        {
          SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2);
        }
      }
    }
    else if (prog_soc_prop.mpls_index && (!prog_soc_prop.mpls_use_in_rif)) 
    {
      /* MPLS indexed. No MPLS context RIF */      
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1);
      if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
      {
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1);      
      }
      if (prog_soc_prop.fast_reroute_labels_enable) 
      {
        /* FRR */
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1);
        if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
        {
          SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1);
        }
      }
    }
    else
    {
      /* MPLS indexed includes MPLS context RIF */
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3);
      if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
      {
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3);      
      }
      if (prog_soc_prop.fast_reroute_labels_enable) 
      {
        /* FRR */
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1);
        if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
        {
          SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1);
        }
      }
    }
  }

  /* Trill */
  if (prog_soc_prop.trill_mode) 
  {
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL);
    if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
    {
      if (!prog_soc_prop.trill_disable_designated_vlan_check && prog_soc_prop.designated_vlan_inlif_enable) {
        SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL);
      }      
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL);
    }
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL);
  }

  /* PON */
  if (prog_soc_prop.pon_enable) 
  {
    SET_VT_PROGRAM_ID(unit,ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID);
  }

  /* IP-LIF-DUMMY */
  if (SOC_DPP_CONFIG(unit)->pp.ip_lif_dummy_id &&
      prog_soc_prop.ipv4_term_enable && 
      (SOC_DPP_CONFIG(unit)->pp.ingress_ipv4_tunnel_term_mode == SOC_DPP_IP_TUNNEL_L2_LKUP_MODE_SIP_DIP_SEPERATED)) {
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE);
    if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
    {
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE);
    }
  }

  /* IP */
  if (prog_soc_prop.ipv4_term_enable) {
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID);
    if (SOC_DPP_CONFIG(unit)->pp.port_use_outer_vlan_and_initial_vlan_enabled) 
    {
      SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID);
    }
  }
  
  /* EVB */
  if (prog_soc_prop.evb_enable) 
  {
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG);
  }

  /* Q-in-Q 5-IP-tuple */
  if (prog_soc_prop.q_in_q_ip_5_tuple) 
  {
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q);
    SET_VT_PROGRAM_ID(unit, ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q);
  }

  /* VT Self-check { */
  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3].prog_used);  
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 300, exit); /* only one of the VT programs above can be set */
  }

  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 310, exit); /* only one of the VT programs above can be set */
  }

  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1].prog_used);  
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG].prog_used);  
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 320, exit); /* only one of the VT programs above can be set */
  }
  
  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 330, exit); /* only one of the VT programs above can be set */
  }

  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used);  
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 320, exit); /* only one of the VT programs above can be set */
  }

  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1].prog_used);  
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 320, exit); /* only one of the VT programs above can be set */
  }

  /* VT Self-check } */

  /* VT  } */ 

  /* TT  { */ 

  /* Always enabled */
  SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG);

  /* Bridge */
  SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG);

  /* MPLS */
  /* MPLS is valid only in case we are not in a special Q-in-Q world */
  if ((!prog_soc_prop.port_vlan_pcp_lookup) && (!prog_soc_prop.match_port_vlan_critiria_64K))
  {
    if ((!prog_soc_prop.mpls_index) && (!prog_soc_prop.mpls_use_in_rif)) 
    {
      /* Unindex MPLS. No MPLS context RIF. */
      SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_L2);
      if (prog_soc_prop.eli_enable) 
      {      
        SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI);
      }

      if (prog_soc_prop.fast_reroute_labels_enable) 
      {
        /* FRR */
        SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_L3);
      }
      if (prog_soc_prop.coupling_enable) 
      {
        /* Coupling */
        SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4);
      }
    }
    else if (prog_soc_prop.mpls_index && prog_soc_prop.mpls_use_in_rif) 
    {
      /* MPLS index. MPLS context RIF. */
      SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF);
      if (prog_soc_prop.eli_enable) 
      {
        SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF);
        SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF);
      }
      if (prog_soc_prop.fast_reroute_labels_enable) 
      {
        /* FRR */
        SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4);
      }     
    }
    else if (prog_soc_prop.mpls_index && (!prog_soc_prop.mpls_use_in_rif)) {
      if (prog_soc_prop.tunnel_termination_in_tt_only) 
      {
          SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2);
          SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1);
          if (prog_soc_prop.explicit_null_support) 
          {
            SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2);
            SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2);
          }
          if (prog_soc_prop.pwe_gal_support) 
          {
            SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL);
            SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL);
            if (prog_soc_prop.explicit_null_support) 
            {
                SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL);
            }
          }
      } 
      else 
      {
        /* MPLS index. No MPLS context RIF. */
        SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2);
        if (prog_soc_prop.eli_enable) 
        {
          SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI);
        }
        if (prog_soc_prop.fast_reroute_labels_enable) 
        {
          /* FRR */
          SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4);
        } 
      }
    }
  }

  /* Routing , IP termination */
  if (prog_soc_prop.ipv4_term_enable) 
  {
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG);
  }
  SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG);
  SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG);
  SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG);

  if (prog_soc_prop.nvgre_enable) 
  {
    /* Support also PWEoGRE */
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG);
  }

  if (prog_soc_prop.ipv4mc_bidir_enable) 
  {
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG);
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG);
  }
  /* Unknown L3 */
  SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG);

  /* Mac-in-MAC */
  if (prog_soc_prop.mim_enable) 
  {
      SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG);
      if (SOC_IS_ARAD_B0_AND_ABOVE(unit)) 
      {
          SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG);
      }
  }

  /* ARP */
  SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG);

  /* Trill */
  if (prog_soc_prop.trill_mode) 
  {
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG);
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH);
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG);
  }

  /* FCoE */
  if (prog_soc_prop.fcoe_enable) 
  {
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG);
    SET_TT_PROGRAM_ID(ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG);
  }

  /* TT Self check { */
  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L3].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 400, exit); /* only one of the TT programs above can be set */
  }

  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 410, exit); /* only one of the TT programs above can be set */
  }
  
  tmp = 0;
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF].prog_used);
  tmp = ARAD_PP_ISEM_ACCESS_IS_PROGRAM_VALID_AND_INCR(tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2].prog_used);
  if (tmp > 1) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 420, exit); /* only one of the TT programs above can be set */
  }
  /* TT Self check } */
   
  /* TT  } */   

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_prog_programs_init()", last_vt_program_id, last_tt_program_id);
}

STATIC 
uint32
  arad_pp_isem_prog_sel_cam_init(
    int unit
  )
{
  uint32
    res;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;
  ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_2nd_cam_tbl;
  uint32
    data[SOC_SAND_MAX(ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE,ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_ENTRY_SIZE)];

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
    
  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);
  ARAD_CLEAR(&prog_selection_2nd_cam_tbl, ARAD_PP_IHP_VTT2ND_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  prog_selection_1st_cam_tbl.valid = 0;
  prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask     = 0x7FF;
  prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask     = 0x7FF;
  prog_selection_1st_cam_tbl.packet_format_code_mask            = 0x3F;
  prog_selection_1st_cam_tbl.ptc_vt_profile_mask                = 0x3;
  prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask         = 0x7;
  prog_selection_1st_cam_tbl.parser_leaf_context_mask           = 0xF;
  if(SOC_IS_JERICHO(unit))
  {
      prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = 0x1F;
      prog_selection_1st_cam_tbl.incoming_tag_structure_mask    = 0xF;
      prog_selection_1st_cam_tbl.packet_format_qualifier_0_mask = 0x7;
  }

  res = arad_pp_ihp_isem_1st_program_selection_convert_tbl_data_to_data(unit,&prog_selection_1st_cam_tbl,data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);


  /* Clear all program selection and programs tables */
  res = arad_fill_table_with_entry(unit, IHP_VTT_1ST_KEY_PROG_SEL_TCAMm, MEM_BLOCK_ANY, data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 13, exit);

  prog_selection_2nd_cam_tbl.valid                                          = 0x0;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_1_mask                 = 0x7FF;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_2_mask                 = 0x7FF;
  prog_selection_2nd_cam_tbl.packet_format_qualifier_3_outer_vid_bits_mask  = 0x7;
  prog_selection_2nd_cam_tbl.packet_format_code_mask                        = 0x3F;
  prog_selection_2nd_cam_tbl.ptc_tt_profile_mask                            = 0x3;
  prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                     = 0x7;
  prog_selection_2nd_cam_tbl.parser_leaf_context_mask                       = 0xF;
  prog_selection_2nd_cam_tbl.isa_lookup_found_mask                          = 0x1;
  prog_selection_2nd_cam_tbl.isb_lookup_found_mask                          = 0x1;
  prog_selection_2nd_cam_tbl.tcam_lookup_match_mask                         = 0x1;
  prog_selection_2nd_cam_tbl.vt_processing_profile_mask                     = 0x7;
  prog_selection_2nd_cam_tbl.da_is_all_r_bridges_mask                       = 0x1;
  prog_selection_2nd_cam_tbl.packet_is_compatible_mc_mask                   = 0x1;
  prog_selection_2nd_cam_tbl.my_mac_mask                                    = 0x1;
  prog_selection_2nd_cam_tbl.vlan_is_designated_mask                        = 0x1;
  if(SOC_IS_ARAD_B0_AND_ABOVE(unit))
  {
      prog_selection_2nd_cam_tbl.my_b_mac_mc_mask                           = 0x1;
  }
  if(SOC_IS_JERICHO(unit))
  {
      prog_selection_2nd_cam_tbl.in_pp_port_tt_profile_mask                 = 0x1F;
      prog_selection_2nd_cam_tbl.vt_in_lif_profile_mask                     = 0xF; 
  }

  res = arad_pp_ihp_isem_2nd_program_selection_convert_tbl_data_to_data(unit,&prog_selection_2nd_cam_tbl,data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 140, exit);

  res = arad_fill_table_with_entry(unit, IHP_VTT_2ND_KEY_PROG_SEL_TCAMm, MEM_BLOCK_ANY, data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 150, exit);
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_prog_sel_cam_init()", 0, 0);
}

#define ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(field_1,field_2) \
{ \
  uint32 __tmp; \
  __tmp = field_1; \
  field_1 = field_2; \
  field_2 = __tmp; \
}

#define ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(new,old,value_1,value_2) \
{ \
  if (old & value_1) \
  { \
    new |= value_2; \
    new &= ~value_1; \
  } \
  if (old & value_2) \
  { \
    new |= value_1; \
    new &= ~value_2; \
  } \
}

/* 
 * Swap between ISEM-A and ISEM-B data.
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_swap_sem(
    int unit,
    uint32 prog_indx,
    ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA* tbl_data
  )
{
  uint32
    tmp;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_key_valids_1,tbl_data->isb_key_valids_1);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_key_valids_2,tbl_data->isb_key_valids_2);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_and_mask,tbl_data->isb_and_mask);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_lookup_enable,tbl_data->isb_lookup_enable);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_or_mask,tbl_data->isb_or_mask);
  tmp = tbl_data->vlan_translation_0_pd_bitmap;
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->vlan_translation_0_pd_bitmap,tmp,0x2,0x1);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->vlan_translation_0_pd_bitmap,tmp,0x10,0x8);
  tmp = tbl_data->vlan_translation_1_pd_bitmap;
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->vlan_translation_1_pd_bitmap,tmp,0x2,0x1);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->vlan_translation_1_pd_bitmap,tmp,0x10,0x8);

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_swap_sem()", 0, 0);
}

/* 
 * Swap between ISEM-A and ISEM-B data.
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_swap_sem(
    int unit,
    uint32 prog_indx,
    ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA* tbl_data
  )
{
  uint32
    tmp;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_key_valids_1,tbl_data->isb_key_valids_1);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_key_valids_2,tbl_data->isb_key_valids_2);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_and_mask,tbl_data->isb_and_mask);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_lookup_enable,tbl_data->isb_lookup_enable);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_or_mask,tbl_data->isb_or_mask);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_FIELD_CHANGE(tbl_data->isa_key_initial_from_vt,tbl_data->isb_key_initial_from_vt);  
  tmp = tbl_data->termination_0_pd_bitmap;
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->termination_0_pd_bitmap,tmp,0x2,0x1);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->termination_0_pd_bitmap,tmp,0x10,0x8);
  tmp = tbl_data->termination_1_pd_bitmap;
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->termination_1_pd_bitmap,tmp,0x2,0x1);
  ARAD_PP_VTT_1ST_LOOKUP_PROGRAM_SWAP_BITS_CHANGE(tbl_data->termination_1_pd_bitmap,tmp,0x10,0x8);

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_swap_sem()", 0, 0);
}

#define ARAD_PP_VTT_FIND_NAMESPACE_L1(namespace) \
  (namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1 || namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3 \
   || namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L2)

#define ARAD_PP_VTT_FIND_NAMESPACE_L2(namespace) \
  (namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L2 || namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L2)

#define ARAD_PP_VTT_FIND_NAMESPACE_L3(namespace) \
  (namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L3 || namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3)

STATIC
uint32
  arad_pp_vtt_find_namespace_database(
    int unit,
    SOC_PPC_MPLS_TERM_NAMESPACE_TYPE namespace_required,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_database,
    uint32 mpls_2_namespace,
    uint32 mpls_3_database,
    uint32 mpls_3_namespace,
    SOC_PPC_MPLS_TERM_NAMESPACE_TYPE *namespace,
    uint32 *database
  )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  *namespace = mpls_3_namespace;
  *database  = mpls_3_database;

  if (namespace_required == SOC_PPC_MPLS_TERM_NAMESPACE_L1)
  {
    if (ARAD_PP_VTT_FIND_NAMESPACE_L1(mpls_1_namespace)) {
      *namespace = mpls_1_namespace;
      *database  = mpls_1_database;
    } else if (ARAD_PP_VTT_FIND_NAMESPACE_L1(mpls_2_namespace)) {
      *namespace = mpls_2_namespace;
      *database  = mpls_2_database;
    } /* else mpls_3 which already set */
  }

  if (namespace_required == SOC_PPC_MPLS_TERM_NAMESPACE_L2)
  {
    if (ARAD_PP_VTT_FIND_NAMESPACE_L2(mpls_1_namespace)) 
    {
      *namespace = mpls_1_namespace;
      *database  = mpls_1_database;
    } 
    else if (ARAD_PP_VTT_FIND_NAMESPACE_L2(mpls_2_namespace)) 
    {
      *namespace = mpls_2_namespace;
      *database  = mpls_2_database;
    } /* else mpls_3 which already set */   
  }
  
  if (namespace_required == SOC_PPC_MPLS_TERM_NAMESPACE_L3)
  {
    if (ARAD_PP_VTT_FIND_NAMESPACE_L3(mpls_1_namespace)) 
    {
      *namespace = mpls_1_namespace;
      *database  = mpls_1_database;
    } 
    else if (ARAD_PP_VTT_FIND_NAMESPACE_L3(mpls_2_namespace)) 
    {
      *namespace = mpls_2_namespace;
      *database  = mpls_2_database;
    } /* else mpls_3 which already set */   
  }

  ARAD_DO_NOTHING_AND_EXIT;
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_find_namespace_database()", namespace_required, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_tm_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile   = (0x3F);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x0);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_tm_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. VD x Outer x Inner SEM-B
 * 2. VD x Outer x Inner SEM-A
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_set(
    int unit,
    uint32 mpls_1_database
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x0); /* used keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xF); /* dont look in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x2); /* dont look in TCAM but take Outer-VID */
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x0); /* Disable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x8); /* Only ISB is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_high_vd_outer_inner_or_low_vd_outer_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x2); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x2); /* dont look in TCAM, user Outer-VID */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0xC); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0xB); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x18); /* Both ISA and ISB are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_high_vd_outer_inner_or_low_vd_outer_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_double_tag_pri_initialvid_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x2); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x2); /* dont look in TCAM, user initial-VID */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0xC); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x9); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x18); /* Both ISA and ISB are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_double_tag_pri_initialvid_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_single_tag_5_ip_tuple_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  
  /* ISEM-B VLAN-Domain x Initial-VID */
  /* TCAM 5-tuple IP */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_CE_UDP_HDR3_L4SP_L4DP_CB32;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_IPV4_SIP_HDR2_HEADER;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x2); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0xC); /* */  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_IPV4_NEXT_PROTOCOL_HDR2_HEADER_CB16;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_IPV4_DIP_HDR2_HEADER;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x8); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x8); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xE); /* */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x0); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_SINGLE;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id;
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x28); /* Both TCAM, ISB are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_single_tag_5_ip_tuple_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_double_tag_5_ip_tuple_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISEM-A Inner-VID x VLAN-Domain x Initial-VID */
  /* ISEM-B VLAN-Domain x Initial-VID */
  /* TCAM 5-tuple IP */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_CE_UDP_HDR3_L4SP_L4DP_CB32;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_IPV4_SIP_HDR2_HEADER;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x2); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0xC); /* */  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_IPV4_NEXT_PROTOCOL_HDR2_HEADER_CB16;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_IPV4_DIP_HDR2_HEADER;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x8); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x8); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xE); /* */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_DOUBLE;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_SINGLE;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id;
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x38); /* All TCAM, ISA, ISB are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_double_tag_5_ip_tuple_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_untagged_tst(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISEM-A VLAN-Domain x Initial-VID x const 0 */
  /* TCAM   Initial-VID x const 0 (12b) x VLAN-Domain x const 0 (28b) x Ethertype */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_ETH_HEADER_ETH_TYPE_NO_TAGS_16;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(28);
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x5); /* */    
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(12);
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x2); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xe); /* */    
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_DT;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x0); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* Invalid */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x30); /* ISA, TCAM is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_untagged_tst()", 0, 0);
}

/* Untagged packets and Explicit NULL lookup */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_untagged_tst_explicit_null_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISEM-A VLAN-Domain x Initial-VID x const 0 */
  /* TCAM   Label-1 lookup */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_1_15_0;    
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x3); /* */    
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x2); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x8); /* */    
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_DT;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x0); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* Invalid */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10); /* ISA is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x20);  /* TCAM is relevant */

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_untagged_tst_explicit_null_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_single_tag_tst(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISEM-B VLAN-Domain x Compressed-Outer */
  /* ISEM-A VLAN-Domain x Initial-VID */
  /* TCAM   Initial-VID x 0x0(12bit) x VLAN-Domain x Compressed-Outer x 0x0(12bit) x PCP-DEI x Ethertype */  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_ETH_HEADER_ETH_TYPE_ONE_TAG_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_CE_ETH_HEADER_OUTER_PCP;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(12);
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x4); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0xB); /* */    
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(12);
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x2); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xF); /* */  
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_DT;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_ST;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; 
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x38); /* TCAM, ISA, ISB is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_single_tag_tst()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_single_tag_tst_explicit_null_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISEM-B VLAN-Domain x Compressed-Outer */
  /* ISEM-A VLAN-Domain x Initial-VID */
  /* TCAM   Explicit NULL */  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x4); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x3); /* */    
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x2); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x8); /* */  
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_DT;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_ST;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; 
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x18); /* ISA, ISB is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x20); /* TCAM is relevant */

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_single_tag_tst_explicit_null_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_double_tag_tst(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISEM-A VLAN-Domain x Compressed-Outer x Compressed-Inner */
  /* ISEM-B VLAN-Domain x Compressed-Outer */
  /* TCAM   Initial-VID x Inner-VLAN x VLAN-Domain x Compressed-Outer x Compressed-Inner x PCP-DEI x Ethertype */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_ETH_HEADER_ETH_TYPE_TWO_TAGS_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_CE_ETH_HEADER_OUTER_PCP;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_INNER_VID;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x4); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x7); /* */  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_ETH_HEADER_INNER_TAG_CE32;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xF); /* */  
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_DT;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_ST;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; 
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x38); /* TCAM, ISA, ISB is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_double_tag_tst()", 0, 0);
}

/* Double tag lookup and Explicit NULL */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_double_tag_tst_explicit_null_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISEM-A VLAN-Domain x Compressed-Outer x Compressed-Inner */
  /* ISEM-B VLAN-Domain x Compressed-Outer */
  /* TCAM   Label-1 */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_INNER_VID;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x4); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x3); /* */  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x8); /* */  
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_DT;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_ST;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; 
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x18); /* ISA, ISB is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x20); /* TCAM is relevant */

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_double_tag_tst_explicit_null_set()", 0, 0);
}

/* P5 = P2 + PCP */
/* Same rule as P2 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outer_or_vd_outer_pcp_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES *prog_soc_prop = &(g_prog_soc_prop[unit]);

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_ETH_HEADER_OUTER_PCP;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x1); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0xF); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0xF); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x1); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = (prog_soc_prop->pon_enable ? ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX:ARAD_PP_ISEM_ACCESS_VD_OUTER_PCP_PREFIX);
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);   /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x18); /* Both TCAM and ISB are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outer_or_vd_outer_pcp_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_or_vd_outer_inner_outerpcp_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_ETH_HEADER_OUTER_PCP;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_INNER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xC); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* dont look in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x5); /* use all keys in TCAM */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x3); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xB); /* keys in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x0); /* Disable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id;
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x30); /* Only ISA & TCAM are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_or_vd_outer_inner_outerpcp_set()", 0, 0);
}

/* Same RULE as P4 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_high_vd_outer_inner_outerpcp_or_vd_outer_inner_or_vd_outer_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_ETH_HEADER_OUTER_PCP;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_PROGRAM_VAR_2_BITS;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x6); /* use  in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xC); /* use  in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x3); /* use all the keys TCAM */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_program_variable   = (0x2); /* use for prefix for outer VID DB */  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x5); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x4); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xD); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE; */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x38); /* TCAM, ISA and ISB are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_high_vd_outer_inner_outerpcp_or_vd_outer_inner_or_vd_outer_set()", 0, 0);
}

/* same as RULEs for P1 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_or_vd_initialvid_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;    
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_2_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xE); /* use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xE); /* use keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1); 
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);    /* Disable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);    /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);   /* Dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x18); /* Only ISB & ISA are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_or_vd_initialvid_set()", 0, 0);
}

/* Same Rule as P2 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outer_or_vd_outer_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xF); /* use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xF); /* use keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Disable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x18); /* Only ISB & ISA are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outer_or_vd_outer_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_or_vd_outer_inner_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xF); /* use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xF); /* use keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x2); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x18); /* Only ISB & ISA are relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_or_vd_outer_inner_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. MPLS x ELI x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 2. MPLS x ELI x [BOS] SEM-B and VD x Initial-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vdxinitialvid_l1_l2eli_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_indexed
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_2_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xC);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x4);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_3_BOS_16; /* BOS indication of the entropy label */
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x2):(0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = (mpls_indexed) ? ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace,1):
                                                                               ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x8);  /* TT for Label1 according to ISB result */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vdxinitialvid_l1_l2eli_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. MPLS x ELI x [BOS] SEM-A and VD x Outer-VID SEM-B 
 * 2. MPLS x ELI x [BOS] SEM-B and VD x Outer-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1_l2eli_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_indexed
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ONES;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xC);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x4);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_3_BOS_16;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0xC);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x2):(0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = (mpls_indexed) ? ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace,1):
                                                                               ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x8);  /* TT for Label1 according to ISB result */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1_l2eli_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. MPLS x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 2. MPLS x [BOS] SEM-B and VD x Initial-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vdxinitialvid_l1_set(
    int unit,
    uint8  is_bos_in_key_enable,
    uint32 mpls_1_database
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_2_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xC);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x4);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_BOS_16;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x2):(0x0);  
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x8);  /* TT for Label1 according to ISB result */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vdxinitialvid_l1_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. MPLS x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 2. MPLS x [BOS] SEM-B and VD x Initial-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1_set(
    int unit,
    uint8  is_bos_in_key_enable,
    uint32 mpls_1_database
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ONES;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xC);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x4);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ?(0x4):(0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x8);  /* TT for Label1 according to ISB result */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. MPLS x [BOS] SEM-A and VD x Initial-VID SEM-B and FRR x L1 in TCAM 
 * 2. MPLS x [BOS] SEM-B and VD x Initial-VID SEM-A and FRR x L1 in TCAM
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_l1frr_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_MPLS_2_31_0;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x7); /* use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x8); 
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* ISA - Bridge */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3); /* ISB - Only L1 */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xB); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE; */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10); /* VT according to ISEM-A Result, TT on L2 according to ISA */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x28); /* VT according to TCAM Result, TT on L2 according to ISA */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_l1frr_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. MPLS x [BOS] SEM-A and VD x Outer-VID SEM-B and FRR x L1 in TCAM 
 * 2. MPLS x [BOS] SEM-B and VD x Outer-VID SEM-A and FRR x L1 in TCAM
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1frr_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_PROGRAM_VAR_2_BITS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_MPLS_2_31_0;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x7); /* use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* use keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x8); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.key_program_variable   = (0x2); /* use for prefix for outer VID DB */  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* ISA - {L1,L2} */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3); /* ISB - Only L1 */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xB);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE;*/
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10); /* VT according to ISA Result, TT on L2 according to ISA */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x28); /* VT according to TCAM Result, TT on L2 according to ISA */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1frr_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. VD x Initial-VID SEM-B and L2 x L1 in TCAM 
 * 2. VD x Initial-VID SEM-A and L2 x L1 in TCAM
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_l1l2_set(
    int unit,
    uint32 mpls_1_database,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_MPLS_2_31_0;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x3); /* use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* use keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x8);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x4);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xB);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_MPLS_COUPLING_DB_PROFILE; */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10); /* VT according to ISAMA Result */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x20); /* TT on L1L2 = TCAM */
  ihp_vtt1st_key_construction_tbl_data.processing_profile   = (ARAD_PP_IHP_VTT_VT_PROCESSING_PROFILE_COUPLING);

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_l1l2_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. VD x Outer-VID SEM-B and L2 x L1 in TCAM 
 * 2. VD x Outer-VID SEM-A and L2 x L1 in TCAM
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1l2_set(
    int unit,
    uint32 mpls_1_database,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_MPLS_2_31_0;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x7); /* use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* no keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x8);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x4);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xB);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_MPLS_COUPLING_DB_PROFILE; */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10); /* VT according to ISEMA Result */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x20); /* TT on L1L2 = TCAM */
  ihp_vtt1st_key_construction_tbl_data.processing_profile   = (ARAD_PP_IHP_VTT_VT_PROCESSING_PROFILE_COUPLING);

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1l2_set()", 0, 0);
}

/*
 * Indexed MPLS 
 * Possible options: 
 * 1. MPLS_1 L1 x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 2. MPLS_1 L1 x [BOS] SEM-B and VD x Initial-VID SEM-A 
 * 3. MPLS_1 L1L3 x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 4. MPLS_1 L1L3 x [BOS] SEM-B and VD x Initial-VID SEM-A 
 * 5. MPLS_1 L1L2 x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 6. MPLS_1 L1L2 x [BOS] SEM-B and VD x Initial-VID SEM-A  
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_indx_vd_initialvid_l1_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1   = (0x7);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1   = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1  = (0x1);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2   = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2   = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2  = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask        = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable  = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask        = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace,0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable  = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile    = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x8);  /* TT for Label1 according to ISA result */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_indx_vd_initialvid_l1_set()", 0, 0);
}

/*
 * Indexed MPLS 
 * Possible options: 
 * 1. MPLS_1 L1L3 x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 2. MPLS_1 L1L3 x [BOS] SEM-B and VD x Initial-VID SEM-A 
 * 3. MPLS_2 L2L3 x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 4. MPLS_2 L2L3 x [BOS] SEM-B and VD x Initial-VID SEM-A 
 * 5. MPLS_3 L3 x [BOS] SEM-A and VD x Initial-VID SEM-B 
 * 6. MPLS_3 L3 x [BOS] SEM-B and VD x Initial-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_indx_vd_initialvid_l3_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_database,
    uint32 mpls_2_namespace,
    uint32 mpls_3_database,
    uint32 mpls_3_namespace
  )
{
  uint32
    namespace,
    database,
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /* 
   * Determine namespace and database according to required key
   */
  res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L3, mpls_1_database, mpls_1_namespace, 
                                            mpls_2_database, mpls_2_namespace, mpls_3_database, mpls_3_namespace,&namespace,&database);
  SOC_SAND_CHECK_FUNC_RESULT(res, 600+SOC_PPC_MPLS_TERM_NAMESPACE_L3, exit);
  
  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x7);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_3_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_3_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_3_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(namespace,0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x8);  /* TT for Label1 according to ISA result */

  if (database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_indx_vd_initialvid_l3_set()", 0, 0);
}

/*
 * Indexed MPLS 
 * Possible options: 
 * 1. MPLS_1 L1 x [BOS] SEM-A and VD x Outer-VID SEM-B 
 * 2. MPLS_1 L1 x [BOS] SEM-B and VD x Outer-VID SEM-A 
 * 3. MPLS_1 L1L3 x [BOS] SEM-A and VD x Outer-VID SEM-B 
 * 4. MPLS_1 L1L3 x [BOS] SEM-B and VD x Outer-VID SEM-A 
 * 5. MPLS_1 L1L2 x [BOS] SEM-A and VD x Outer-VID SEM-B 
 * 6. MPLS_1 L1L2 x [BOS] SEM-B and VD x Outer-VID SEM-A  
 */ 
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_l1_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xF);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace,0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x8);  /* TT for Label3 according to ISB result */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_l1_set()", 0, 0);
}

/*
 * Indexed MPLS 
 * Possible options: 
 * 1. MPLS_1 L1L3 x [BOS] SEM-A and VD x Outer-VID SEM-B 
 * 2. MPLS_1 L1L3 x [BOS] SEM-B and VD x Outer-VID SEM-A 
 * 3. MPLS_2 L2L3 x [BOS] SEM-A and VD x Outer-VID SEM-B 
 * 4. MPLS_2 L2L3 x [BOS] SEM-B and VD x Outer-VID SEM-A 
 * 5. MPLS_3 L3 x [BOS] SEM-A and VD x Outer-VID SEM-B 
 * 6. MPLS_3 L3 x [BOS] SEM-B and VD x Outer-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_l3_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_database,
    uint32 mpls_2_namespace,
    uint32 mpls_3_database,
    uint32 mpls_3_namespace
  )
{
  uint32
    res,
    namespace,
    database; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /* 
   * Determine namespace and database according to required key
   */
  res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L3, mpls_1_database, mpls_1_namespace, 
                                            mpls_2_database, mpls_2_namespace, mpls_3_database, mpls_3_namespace,&namespace,&database);
  SOC_SAND_CHECK_FUNC_RESULT(res, 600+SOC_PPC_MPLS_TERM_NAMESPACE_L3, exit);
  
  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0xF);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_3_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_3_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_3_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(namespace,0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x8);  /* TT for Label3 according to ISB result */

  if (database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_l3_set()", 0, 0);
}

/*
 * Indexed MPLS 
 * Possible options: 
 * 1. MPLS_1 L1 x [BOS] SEM-A and VD x Initial-VID SEM-B and FRR x L1 in TCAM
 * 2. MPLS_1 L1 x [BOS] SEM-B and VD x Initial-VID SEM-A and FRR x L1 in TCAM
 * 3. MPLS_1 L1L3 x [BOS] SEM-A and VD x Initial-VID SEM-B and FRR x L1 in TCAM
 * 4. MPLS_1 L1L3 x [BOS] SEM-B and VD x Initial-VID SEM-A and FRR x L1 in TCAM
 * 5. MPLS_1 L1L2 x [BOS] SEM-A and VD x Initial-VID SEM-B and FRR x L1 in TCAM
 * 6. MPLS_1 L1L2 x [BOS] SEM-B and VD x Initial-VID SEM-A and FRR x L1 in TCAM 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_indx_vdinitialvid_frr_l1_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_MPLS_2_31_0;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x7); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x8); 
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xB); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace,0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE; */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10); /* VT according to ISEMA Result, TT on L2 according to ISA */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x28); /* FRR according to ISEB&TCAM Result */


  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_indx_vdinitialvid_frr_l1_set()", 0, 0);
}

/*
 * Indexed MPLS 
 * Possible options: 
 * 1. MPLS_1 L1 x [BOS] SEM-A and VD x Outer-VID SEM-B and FRR x L1 in TCAM
 * 2. MPLS_1 L1 x [BOS] SEM-B and VD x Outer-VID SEM-A and FRR x L1 in TCAM
 * 3. MPLS_1 L1L3 x [BOS] SEM-A and VD x Outer-VID SEM-B and FRR x L1 in TCAM
 * 4. MPLS_1 L1L3 x [BOS] SEM-B and VD x Outer-VID SEM-A and FRR x L1 in TCAM
 * 5. MPLS_1 L1L2 x [BOS] SEM-A and VD x Outer-VID SEM-B and FRR x L1 in TCAM
 * 6. MPLS_1 L1L2 x [BOS] SEM-B and VD x Outer-VID SEM-A and FRR x L1 in TCAM 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_frr_l1_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_PROGRAM_VAR_2_BITS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_MPLS_2_31_0;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x7); /* use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0); /* use keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x8); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.key_program_variable   = (0x2); /* use for prefix for outer VID DB */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* ISA - {L1,L2} */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3); /* ISB - Only L3 */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xB); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace,0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE; */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10); /* VT according to ISEMA Result, TT on L2 according to ISA */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x28); /* VT according to TCAM Result, TT on L2 according to ISA */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_frr_l3_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_pon_untagged_set(
    int unit,
    uint8  tls_db_enable,
    uint8  custom_pon_enable,
    uint8  tls_in_tcam_enable,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit) && custom_pon_enable) {
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_is_use_strength = 1;
  }
#endif
  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1        = ARAD_PP_CE_ETH_HEADER_ETH_TYPE_NO_TAGS_32;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1     = (0x0); /* dont use keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1     = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1    = (0x8); 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_CE_TK_PON_LLID_32;   
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3        = ARAD_PP_ISEM_ACCESS_32B_INST_PON_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2     = (!tls_db_enable) ? 0x0:0xc; 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2     = (0xc); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2    = (0xc); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = (!tls_db_enable) ? ARAD_PP_ISEM_ACCESS_NULL_PREFIX:ARAD_PP_ISEM_ACCESS_PON_UNTAGGED_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (!tls_db_enable) ? 0x0:0x1;    /* ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ((!custom_pon_enable) ? ARAD_PP_ISEM_ACCESS_PON_TLS_PREFIX : 0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = ((!custom_pon_enable) ? 0x1 : 0x0);     
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (access_profile_id);  /* ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (tls_in_tcam_enable) ? (0x14):((!tls_db_enable) ? 0x28:0x38); /* Only TCAM & ISB (& ISA) relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
      /*
       * When match the below case, the vlan_translation_0_pd_bitmap is set as 0x38 which enable the ISA and ISB at the same time.
       * so ISA > ISB when default, ISB > ISA when custom_pon_enable
       */
      if (!tls_in_tcam_enable && tls_db_enable) {          
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_is_use_strength = 1;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_tcam_strength = 3;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isa_strength = custom_pon_enable ? 1 : 2;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isb_strength = custom_pon_enable ? 2 : 1;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_tcam_strength = 0;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_isa_strength = 0;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_isb_strength = 0;
      }
  }    
#endif
  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_pon_untagged_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_pon_one_tag_set(
    int unit,
    uint8  custom_pon_enable,
    uint8  tls_in_tcam_enable,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit) && custom_pon_enable) {
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_is_use_strength = 1;
  }
#endif
  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_CE_ETH_HEADER_OUTER_PCP;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_ETH_HEADER_ETH_TYPE_ONE_TAG_32;    
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1     = (0x2); /* used keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1     = (0x0); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1    = (0x7); 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_CE_TK_PON_LLID_32; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3        = ARAD_PP_ISEM_ACCESS_32B_INST_PON_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2     = (0xc); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2     = (0xc); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2    = (0xc); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);    /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ((!custom_pon_enable) ? ARAD_PP_ISEM_ACCESS_PON_TLS_PREFIX : 0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = ((!custom_pon_enable) ? 0x1 : 0x0);    /* Enable ISB lkup */  
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (access_profile_id);  /* ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (tls_in_tcam_enable ? 0x1c:0x38); /* Only TCAM & ISB relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {      
      /*
       * ISA > ISB when default, ISB > ISA when custom_pon_enable.
       */
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_is_use_strength = 1;
      if (tls_in_tcam_enable) {
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_tcam_strength = 1;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isa_strength = custom_pon_enable ? 2 : 3;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isb_strength = custom_pon_enable ? 3 : 2;
      } else {
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_tcam_strength = 3;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isa_strength = custom_pon_enable ? 1 : 2;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isb_strength = custom_pon_enable ? 2 : 1;
      }
        
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_tcam_strength = 0;
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_isa_strength = 0;
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_isb_strength = 0;
  } 
#endif
  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_pon_one_tag_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_pon_two_tags_set(
    int unit,
    uint8 custom_pon_enable,
    uint8 tls_in_tcam_enable,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit) && custom_pon_enable) {
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_is_use_strength = 1;
  }
#endif
  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID; 
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_CE_ETH_HEADER_OUTER_PCP;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1        = ARAD_PP_CE_ETH_HEADER_ETH_TYPE_TWO_TAGS_32;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1     = (custom_pon_enable ? 0x4:0x5); /* used keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1     = (custom_pon_enable ? 0x5:0x4); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1    = (0xf); 
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2        = ARAD_PP_CE_TK_PON_LLID_16; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_ISEM_ACCESS_32B_INST_PON_VLAN_DOMAIN;   
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2     = (0x5); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2     = (0x5); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2    = (0x5); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (custom_pon_enable ? 0x0:0x3); /* pon prefix is actually 2 bits and not 4 */
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = (custom_pon_enable ? ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX : ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX);
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = 0x1;    /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (custom_pon_enable ? 0x3:0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = (custom_pon_enable ? ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX:ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);    /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (access_profile_id);  /* ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (tls_in_tcam_enable ? 0x1c:0x38); /* Only TCAM & ISB relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
      /*
       * ISA > ISB when default, ISB > ISA when custom_pon_enable.
       */
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_is_use_strength = 1;
      if (tls_in_tcam_enable) {
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_tcam_strength = 1;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isa_strength = custom_pon_enable ? 2 : 3;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isb_strength = custom_pon_enable ? 3 : 2;
      } else {
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_tcam_strength = 3;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isa_strength = custom_pon_enable ? 1 : 2;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isb_strength = custom_pon_enable ? 2 : 1;
      }
        
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_tcam_strength = 0;
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_isa_strength = 0;
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_isb_strength = 0;
  } 
#endif
  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_pon_two_tags_set()", custom_pon_enable, access_profile_id);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_pon_two_tags_vs_tunnel_id_set(
    int unit,
    uint8 custom_pon_enable,
    uint8 tls_in_tcam_enable,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit) && custom_pon_enable) {
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_is_use_strength = 1;
  }
#endif
  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID; 
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_CE_ETH_HEADER_OUTER_PCP;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1        = ARAD_PP_CE_ETH_HEADER_ETH_TYPE_TWO_TAGS_32;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1     = (custom_pon_enable ? 0x0:0x5); /* used keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1     = (custom_pon_enable ? 0x5:0x0); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1    = (0xf); 
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2        = ARAD_PP_CE_TK_PON_LLID_16;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3        = ARAD_PP_ISEM_ACCESS_16B_INST_PON_VLAN_DOMAIN; 
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2     = (0x3); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2     = (0x3); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2    = (0x3); 
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (custom_pon_enable ? 0x0:0x3); /* pon prefix is actually 2 bits and not 4 */
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = (custom_pon_enable ? ARAD_PP_ISEM_ACCESS_PON_TLS_PREFIX:ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX);
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (custom_pon_enable ? 0x0:0x1);    /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (custom_pon_enable ? 0x3:0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = (custom_pon_enable ? ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX:ARAD_PP_ISEM_ACCESS_PON_TLS_PREFIX);
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);    /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (access_profile_id);  /* ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (tls_in_tcam_enable? 0x1C:0x38); /* Only TCAM & ISB relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);
#ifdef BCM_88660_A0
  if (SOC_IS_ARADPLUS(unit)) {
      /*
       * ISA > ISB when default, ISB > ISA when custom_pon_enable.
       */
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_is_use_strength = 1;
      if (tls_in_tcam_enable) {
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_tcam_strength = 1;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isa_strength = custom_pon_enable ? 2 : 3;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isb_strength = custom_pon_enable ? 3 : 2;
      } else {
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_tcam_strength = 3;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isa_strength = custom_pon_enable ? 1 : 2;
          ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_isb_strength = custom_pon_enable ? 2 : 1;
      }
        
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_tcam_strength = 0;
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_isa_strength = 0;
      ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_isb_strength = 0;
  } 
#endif  
  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_pon_two_tags_vs_tunnel_id_set()", custom_pon_enable, access_profile_id);
}


/* TRILL Specific keys { */
/* Construct key for VDxDesignated-VID */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_designated_vid_trill_set(
    uint32 unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_IHP_VTT_32B_HEADER3_INNER_TPID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x8); /* used keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x7); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);    /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_TRILL_DESIGNATED_VID_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);    /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);   /* Dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x8); /* Only ISB relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_designated_vid_trill_set()", 0, 0);
}

/* Construct key for VDxInitial-VID */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_trill_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS; 
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_IHP_VTT_32B_HEADER3_INNER_TPID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x8); /* used keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x7); 
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);    /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);    /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);   /* Dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x8); /* Only ISB relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_trill_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outer_trill_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xF); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1); /* */
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2          = ARAD_PP_CE_IHP_VTT_32B_HEADER3_INNER_TPID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x4); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); 
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x8); /* Only ISA is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x10);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outer_trill_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_trill_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_INNER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x0); /* used keys in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xF); /* dont look in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x2); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_IHP_VTT_32B_HEADER3_INNER_TPID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x4); 
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); 
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x8); 
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_trill_set()", 0, 0);
}
/* TRILL Specific keys } */

/*
 * Indexed MPLS 
 * Possible options: 
 * 1. IP tunnel SEM-A and VD x Initial-VID SEM-B 
 * 2. IP tunnel SEM-B and VD x Initial-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_ipv4_initial_vid_set(
    int unit,
    uint8 sip_dip_lookup_enable,
    uint32 mpls_1_database,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_PP_PORT_KEY_VAR_X_LSBS(ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS);
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_CE_IPV4_NEXT_PROTOCOL_HDR2_HEADER_CB32;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_IPV4_SIP_HDR2_HEADER;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (sip_dip_lookup_enable == 2) ? (0xE):(0x8);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_IPV4_DIP_HDR2_HEADER;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x4);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xc);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_IP_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (sip_dip_lookup_enable) ? access_profile_id:0x3f; /* ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE;*/
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x28);  /* */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_ipv4_initial_vid_set()", 0, 0);
}

/*
 * Possible options: 
 * 1. IP tunnel SEM-A and VD x Initial-VID SEM-B 
 * 2. IP tunnel SEM-B and VD x Initial-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_ipv4_initial_vid_after_recycle_set(
    int unit,
    uint8 sip_dip_lookup_enable,
    uint32 mpls_1_database
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_2_ZEROS;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_32_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ONES;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0xC);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_IP_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x28);  /* */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_ipv4_initial_vid_after_recycle_set()", 0, 0);
}

/*
 * Indexed MPLS 
 * Possible options: 
 * 1. IP tunnel SEM-A and VD x Outer-VID SEM-B 
 * 2. IP tunnel SEM-B and VD x Outer-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_ipv4_outer_vid_set(
    int unit,
    uint8 sip_dip_lookup_enable,
    uint32 mpls_1_database,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1      = ARAD_PP_ISEM_ACCESS_16B_INST_PP_PORT_KEY_VAR_X_LSBS(ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS);
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0      = ARAD_PP_CE_IPV4_NEXT_PROTOCOL_HDR2_HEADER_CB32;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1      = ARAD_PP_CE_IPV4_SIP_HDR2_HEADER;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (sip_dip_lookup_enable == 2) ? (0xE):(0x8);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_PROGRAM_VAR_2_BITS;  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_CE_IPV4_DIP_HDR2_HEADER;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x4);
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0xc);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_IP_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = 0x1;
  ihp_vtt1st_key_construction_tbl_data.key_program_variable = (0x2); /* use for prefix for outer VID DB */  
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (sip_dip_lookup_enable) ? access_profile_id:0x3f; /* ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE;*/
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x28);  /* */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_ipv4_outer_vid_set()", 0, 0);
}

/*
 * Possible options: 
 * 1. IP tunnel SEM-A and VD x Outer-VID SEM-B 
 * 2. IP tunnel SEM-B and VD x Outer-VID SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_ipv4_outer_vid_after_recycle_set(
    int unit,
    uint8 sip_dip_lookup_enable,
    uint32 mpls_1_database
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0      = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x1);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0x0);
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst2      = ARAD_PP_ISEM_ACCESS_16B_INST_PROGRAM_VAR_2_BITS;  
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst3      = ARAD_PP_ISEM_ACCESS_16B_INST_VLAN_DOMAIN;  
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst2      = ARAD_PP_ISEM_ACCESS_32B_INST_32_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst3      = ARAD_PP_ISEM_ACCESS_32B_INST_1_ONES;
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x3);
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0xC);
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x1); /* Enable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_IP_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = 0x1;
  ihp_vtt1st_key_construction_tbl_data.key_program_variable = (0x2); /* use for prefix for outer VID DB */  
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x10);  /* */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x28);  /* */

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_1st_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_ipv4_outer_vid_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_evb_untag_ctag_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISB : VD x 2'b11 x 12'bY x Initial-VID */
  /* Y is the default S channel */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0          = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1          = ARAD_PP_ISEM_ACCESS_16B_INST_PROGRAM_VAR_12_BITS;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0          = ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1          = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;
  ihp_vtt1st_key_construction_tbl_data.key_program_variable   = (ARAD_PP_ISEM_ACCESS_EVB_DEFAULT_S_CHANNEL);
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x0); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xF); /* used keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1); /* dont look in TCAM but take Outer-VID */
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x0); /* Disable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x8); /* Only ISB is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_evb_untag_ctag_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_1st_lookup_program_vt_evb_stag_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG].prog_used;
  ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt1st_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt1st_key_construction_tbl_data, ARAD_PP_IHP_VTT1ST_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt1st_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /* ISB : VD x 2'b11 x S-channel x Initial-VID */
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst0          = ARAD_PP_ISEM_ACCESS_16B_INST_INITIAL_VID;
  ihp_vtt1st_key_construction_tbl_data.key_16b_inst1          = ARAD_PP_ISEM_ACCESS_16B_INST_CMPRSD_OUTER_VID; /* S-channel */
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst0          = ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES;
  ihp_vtt1st_key_construction_tbl_data.key_32b_inst1          = ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN;  
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_1       = (0x0); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_1       = (0xF); /* used keys in ISB */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_1      = (0x1); /* dont look in TCAM but take Outer-VID */
  ihp_vtt1st_key_construction_tbl_data.isa_key_valids_2       = (0x0); /* dont look in ISA */
  ihp_vtt1st_key_construction_tbl_data.isb_key_valids_2       = (0x0); /* */
  ihp_vtt1st_key_construction_tbl_data.tcam_key_valids_2      = (0x0); /* dont look in TCAM */
  ihp_vtt1st_key_construction_tbl_data.isa_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isa_or_mask          = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isa_lookup_enable    = (0x0); /* Disable ISA lkup */
  ihp_vtt1st_key_construction_tbl_data.isb_and_mask         = (0x0);
  ihp_vtt1st_key_construction_tbl_data.isb_or_mask          = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
  ihp_vtt1st_key_construction_tbl_data.isb_lookup_enable    = (0x1); /* Enable ISB lkup */
  ihp_vtt1st_key_construction_tbl_data.tcam_db_profile      = (0x3f);
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_0_pd_bitmap = (0x8); /* Only ISB is relevant */
  ihp_vtt1st_key_construction_tbl_data.vlan_translation_1_pd_bitmap = (0x0);

  res = arad_pp_ihp_vtt1st_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt1st_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_vt_evb_stag_set()", 0, 0);
}



STATIC 
uint32
  arad_pp_vtt_1st_lookup_program_set(
    int unit,
    ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES *prog_soc_prop
  )
{
  uint32    
    res; 
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);  

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_tm_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vdxinitialvid_l1_set(unit,prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1_set(unit,prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_set(unit, prog_soc_prop->mpls_1_database);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_high_vd_outer_inner_or_low_vd_outer_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vdxinitialvid_l1_l2eli_set(unit,prog_soc_prop->is_bos_in_key_enable,
                                                                       prog_soc_prop->mpls_1_database,prog_soc_prop->mpls_1_namespace,
                                                                       prog_soc_prop->mpls_index);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1_l2eli_set(unit,prog_soc_prop->is_bos_in_key_enable, 
                                                                     prog_soc_prop->mpls_1_database,prog_soc_prop->mpls_1_namespace,
                                                                     prog_soc_prop->mpls_index);  
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_trill_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_designated_vid_trill_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outer_trill_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_trill_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_l1frr_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1frr_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_l1l2_set(unit, prog_soc_prop->mpls_1_database, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1l2_set(unit, prog_soc_prop->mpls_1_database, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outer_or_vd_outer_pcp_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP, exit);    
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_or_vd_outer_inner_outerpcp_set(unit, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_high_vd_outer_inner_outerpcp_or_vd_outer_inner_or_vd_outer_set(unit, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_or_vd_initialvid_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outer_or_vd_outer_set(unit); 
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_or_vd_outer_inner_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_indx_vd_initialvid_l1_set(unit,prog_soc_prop->is_bos_in_key_enable, 
                                                                      prog_soc_prop->mpls_1_database, prog_soc_prop->mpls_1_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_l1_set(unit,prog_soc_prop->is_bos_in_key_enable,
                                                                   prog_soc_prop->mpls_1_database, prog_soc_prop->mpls_1_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_indx_vdinitialvid_frr_l1_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, 
                                                                         prog_soc_prop->mpls_1_namespace, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1, exit);    
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_frr_l1_set(unit, prog_soc_prop->is_bos_in_key_enable, 
                                                                       prog_soc_prop->mpls_1_database, prog_soc_prop->mpls_1_namespace, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_indx_vd_initialvid_l3_set(unit,prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, prog_soc_prop->mpls_1_namespace,
                                                                      prog_soc_prop->mpls_2_database, prog_soc_prop->mpls_2_namespace,
                                                                      prog_soc_prop->mpls_3_database, prog_soc_prop->mpls_3_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_l3_set(unit,prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, prog_soc_prop->mpls_1_namespace,
                                                                      prog_soc_prop->mpls_2_database, prog_soc_prop->mpls_2_namespace,
                                                                      prog_soc_prop->mpls_3_database, prog_soc_prop->mpls_3_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_pon_untagged_set(unit, prog_soc_prop->tls_db_enable, prog_soc_prop->custom_pon_enable, prog_soc_prop->tls_in_tcam_enable, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_pon_one_tag_set(unit, prog_soc_prop->custom_pon_enable, prog_soc_prop->tls_in_tcam_enable, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_pon_two_tags_set(unit, prog_soc_prop->custom_pon_enable, prog_soc_prop->tls_in_tcam_enable, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_pon_two_tags_vs_tunnel_id_set(unit, prog_soc_prop->custom_pon_enable, prog_soc_prop->tls_in_tcam_enable, ARAD_TCAM_ACCESS_PROFILE_INVALID);     
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_ipv4_initial_vid_set(unit, prog_soc_prop->ipv4_term_dip_sip_enable, prog_soc_prop->mpls_1_database, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_ipv4_outer_vid_set(unit, prog_soc_prop->ipv4_term_dip_sip_enable, prog_soc_prop->mpls_1_database, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_ipv4_initial_vid_after_recycle_set(unit, prog_soc_prop->ipv4_term_dip_sip_enable, prog_soc_prop->mpls_1_database);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_ipv4_outer_vid_after_recycle_set(unit, prog_soc_prop->ipv4_term_dip_sip_enable, prog_soc_prop->mpls_1_database);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG].prog_used != -1)
  { 
    res = arad_pp_vtt_1st_lookup_program_vt_evb_untag_ctag_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_evb_stag_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, 255, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_double_tag_pri_initialvid_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_single_tag_5_ip_tuple_set(unit,ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used != -1)
  {
    res = arad_pp_vtt_1st_lookup_program_vt_double_tag_5_ip_tuple_set(unit,ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q, exit);
  }

  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID].prog_used != -1) 
  {
    res = arad_pp_vtt_1st_lookup_program_vt_untagged_tst(unit, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID, exit);
  }
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL].prog_used != -1) 
  {
    res = arad_pp_vtt_1st_lookup_program_vt_untagged_tst_explicit_null_set(unit, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL, exit);
  }
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG].prog_used != -1) 
  {
    res = arad_pp_vtt_1st_lookup_program_vt_single_tag_tst(unit,ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG, exit);
  }
   if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL].prog_used != -1) 
  {
    res = arad_pp_vtt_1st_lookup_program_vt_single_tag_tst_explicit_null_set(unit,ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL, exit);
  }
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG].prog_used != -1) 
  {
    res = arad_pp_vtt_1st_lookup_program_vt_double_tag_tst(unit,ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG, exit);
  }
  if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL].prog_used != -1) 
  {
    res = arad_pp_vtt_1st_lookup_program_vt_double_tag_tst_explicit_null_set(unit,ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_1st_lookup_program_set()", 0, 0);
}

/* End of 1st lookup programs */

/* Start of 2nd lookup programs*/
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_tm_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable       = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable       = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile         = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code        = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_TM;
  ihp_vtt2nd_key_construction_tbl_data.processing_profile     = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_tm_prog_set()", 0, 0);
}

/* 
 * Unindex MPLS 
 * Possible options: 
 * 1. MPLS_1 [BOS] SEM-B
 * 2. MPLS_1 [BOS] SEM-A
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_l2_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2        = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3        = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_CE_MPLS_2_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2       = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (1);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing    = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);    
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_l2_set()", 0, 0);
}

/* 
 * Unindex MPLS & FRR
 * Possible options: 
 * 1. MPLS_1 [BOS] SEM-B
 * 2. MPLS_1 [BOS] SEM-A
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_l3_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L3].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_CE_MPLS_3_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_CE_MPLS_3_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_MPLS_3_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (1); /* will terminate both L1 and L2 */
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_l3_set()", 0, 0);
}

/* 
 * Unindex MPLS & ELI
 * Possible options: 
 * 1. MPLS_1 [BOS] SEM-B
 * 2. MPLS_1 [BOS] SEM-A
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_l2_l3eli_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_MPLS_4_BOS_32; /* BOS indication of the Entropy label */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (1);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }


  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_l2_l3eli_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_coupling_l3_l4_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0            = ARAD_PP_CE_MPLS_4_31_0;  
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1        = (0x4);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_MPLS_3_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3            = ARAD_PP_CE_MPLS_3_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2            = ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VID;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2        = (0x7);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x20);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile          = (access_profile_id);  /* ARAD_PP_ISEM_ACCESS_TCAM_MPLS_COUPLING_DB_PROFILE */
  ihp_vtt2nd_key_construction_tbl_data.processing_code          = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0          = (1);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1          = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2          = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing     = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile       = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_coupling_l3_l4_set()", 0, 0);
}


/* 
 *  Indexed MPLS + INRIF
 * check L3=ELI & L2!=ELI --> lkup L1,L2 (YES-> L2ELI DB, NO-> L2 DB)                             
 * check L2=ELI --> lkup L1    (YES-> L3ELI DB, NO-> L3 DB) 
 * L3!=ELI | L2!=ELI -> lkup L2 & L1 
 * Possible options: 
 * 1. MPLS_1 InRIF [BOS] SEM-B MPLS_2 [BOS] SEM-A
 * 2. MPLS_1 InRIF [BOS] SEM-A MPLS_2 [BOS] SEM-B
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_inrif_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst1        = ARAD_PP_ISEM_ACCESS_32B_INST_IN_RIF_VALID_IN_RIF; 
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (is_bos_in_key_enable) ? (0xF):(0xB);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2          = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3          = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2          = ARAD_PP_CE_MPLS_2_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2       = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2       = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_2_namespace,0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace,0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8); /* L1 IN ISB */
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x10); /* L2 IN ISA */
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (3);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (1);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_inrif_set()", 0, 0);
}

/* 
 * Indexed MPLS + INRIF + L2 ELI 
 * Possible options: 
 * 1. MPLS_1 InRIF [BOS] SEM-B MPLS_2 [BOS] SEM-A
 * 2. MPLS_1 InRIF [BOS] SEM-A MPLS_2 [BOS] SEM-B
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_l3eli_inrif_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0            = ARAD_PP_CE_MPLS_1_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst1            = ARAD_PP_ISEM_ACCESS_32B_INST_IN_RIF_VALID_IN_RIF;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (is_bos_in_key_enable) ? (0xF):(0xB);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3            = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2            = ARAD_PP_CE_MPLS_4_BOS_32; /* BOS indication of the Entropy label */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_2_namespace, 1);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace, 0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x8); /* L1 */
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x10); /* L2 */
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile          = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code          = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0          = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1          = (3);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2          = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing     = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile       = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_l3eli_inrif_set()", 0, 0);
}


/* 
 * Indexed MPLS + INRIF + L1 ELI 
 * Possible options: 
 * 1. MPLS_1 InRIF [BOS] ELI SEM-B 
 * 2. MPLS_1 InRIF [BOS] ELI SEM-A 
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2eli_inrif_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_MPLS_3_BOS_32; 
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst1        = ARAD_PP_ISEM_ACCESS_32B_INST_IN_RIF_VALID_IN_RIF;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (is_bos_in_key_enable) ? (0xF):(0xB);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace, 1);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2eli_inrif_set()", 0, 0);
}

/* 
 * Indexed MPLS                                                                                  
 * check L3=ELI & L2!=ELI --> lkup L1,L2 (YES-> L2ELI DB, NO-> L2 DB)                             
 * check L2=ELI --> lkup L1    (YES-> L3ELI DB, NO-> L3 DB)                                       
 * L3!=ELI | L2!=ELI -> lkup L2 & L1
 *  
 * MPLS indexed L3, L2 
 * Possible options: 
 * 1. MPLS_1/2/3 (L2) [BOS] SEM-A MPLS_1/2/3 (L3) [BOS] SEM-B
 * 2. MPLS_1/2/3 (L2) [BOS] SEM-B MPLS_1/2/3 (L3) [BOS] SEM-A 
 * 
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l3_l2_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_database,
    uint32 mpls_2_namespace,
    uint32 mpls_3_database,
    uint32 mpls_3_namespace,
    uint32 is_tt_termination_only
  )
{
  uint32
    res,
    namespace_l2,
    database_l2,
    namespace_l3,
    database_l3; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  res = arad_pp_vtt_find_namespace_database(unit, (is_tt_termination_only) ? SOC_PPC_MPLS_TERM_NAMESPACE_L1:SOC_PPC_MPLS_TERM_NAMESPACE_L2,
                                      mpls_1_database, mpls_1_namespace,
                                      mpls_2_database, mpls_2_namespace,
                                      mpls_3_database, mpls_3_namespace,
                                      &namespace_l2,
                                      &database_l2);

  SOC_SAND_CHECK_FUNC_RESULT(res, 900, exit);

  res = arad_pp_vtt_find_namespace_database(unit, (is_tt_termination_only) ? SOC_PPC_MPLS_TERM_NAMESPACE_L2:SOC_PPC_MPLS_TERM_NAMESPACE_L3,
                                      mpls_1_database, mpls_1_namespace,
                                      mpls_2_database, mpls_2_namespace,
                                      mpls_3_database, mpls_3_namespace,
                                      &namespace_l3,
                                      &database_l3);

  SOC_SAND_CHECK_FUNC_RESULT(res, 901, exit);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_CE_MPLS_3_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_CE_MPLS_3_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_MPLS_3_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2        = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3        = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_CE_MPLS_2_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(namespace_l2, 0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(namespace_l3, 0);;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8); /* L3 IN ISB */
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x10); /* L2 IN ISA */
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (1);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (3);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (2);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (!is_tt_termination_only && database_l3 == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }


  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l3_l2_set()", 0, 0);
}

/*
 * FRR was found --> L3 is the 2nd label, L4 is the 3rd label 
 * MPLS indexed L3, L2 
 * Possible options: 
 * 1. MPLS_1/2/3 (L2) [BOS] SEM-A MPLS_1/2/3 (L3) [BOS] SEM-B
 * 2. MPLS_1/2/3 (L2) [BOS] SEM-B MPLS_1/2/3 (L3) [BOS] SEM-A  
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l3_l4_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_database,
    uint32 mpls_2_namespace,
    uint32 mpls_3_database,
    uint32 mpls_3_namespace
  )
{
  uint32
    res,
    namespace_l2,
    database_l2,
    namespace_l3,
    database_l3; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L2,
                                      mpls_1_database, mpls_1_namespace,
                                      mpls_2_database, mpls_2_namespace,
                                      mpls_3_database, mpls_3_namespace,
                                      &namespace_l2,
                                      &database_l2);

  SOC_SAND_CHECK_FUNC_RESULT(res, 900, exit);

  res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L3,
                                      mpls_1_database, mpls_1_namespace,
                                      mpls_2_database, mpls_2_namespace,
                                      mpls_3_database, mpls_3_namespace,
                                      &namespace_l3,
                                      &database_l3);

  SOC_SAND_CHECK_FUNC_RESULT(res, 901, exit);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_CE_MPLS_3_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1        = ARAD_PP_CE_MPLS_3_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_MPLS_3_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (is_bos_in_key_enable) ? (0x7):(0x3); 
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0); 
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2        = ARAD_PP_CE_MPLS_4_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3        = ARAD_PP_CE_MPLS_4_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_CE_MPLS_4_BOS_32;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(namespace_l2, 0); /*in case of FRR L3 will be stored in L2 DB */
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(namespace_l3, 0); /* in FRR L4 will be stored in L3 DB */
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x1);                                                                  
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x10);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (1); /* will terminate both L1 and L2 */
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (3);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (2);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (database_l3 == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l3_l4_set()", 0, 0);
}

/*
 * MPLS indexed L3, L2 
 * Possible options: 
 * 1. MPLS_1/2/3 (L2) [BOS] ELI SEM-A
 * 2. MPLS_1/2/3 (L2) [BOS] ELI SEM-B
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l3eli_set(
    int unit,
    uint32 is_bos_in_key_enable,
    uint32 mpls_1_database,
    uint32 mpls_1_namespace,
    uint32 mpls_2_database,
    uint32 mpls_2_namespace,
    uint32 mpls_3_database,
    uint32 mpls_3_namespace
  )
{
  uint32
    res,
    namespace_l2,
    database_l2; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L2,
                                      mpls_1_database, mpls_1_namespace,
                                      mpls_2_database, mpls_2_namespace,
                                      mpls_3_database, mpls_3_namespace,
                                      &namespace_l2,
                                      &database_l2);

  SOC_SAND_CHECK_FUNC_RESULT(res, 900, exit);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
 
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2        = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3        = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_CE_MPLS_4_BOS_32; /* BOS indication of the Entropy label */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (is_bos_in_key_enable) ? (0x7):(0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(namespace_l2, 1);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x10);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (1);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (3);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  if (database_l2 == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) {
      /* Swap */
      res = arad_pp_vtt_2nd_lookup_program_swap_sem(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  }

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l3eli_set()", 0, 0);
}

/* 
 * Indexed MPLS 
 * MPLS_1 Namespace1 SEM-A
 * MPLS_1 Namespace2 SEM_B 
 * Used in case only one label exist in MPLS Stack 
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l1_set(
    int unit,        
    uint32 mpls_1_namespace,    
    uint32 mpls_2_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  /* ISA label1
     ISB label1
   */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace, 0);;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_2_namespace, 0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x18);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;  

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l1_set()", 0, 0);
}

/* 
 * Indexed MPLS 
 * MPLS_1 Namespace1 SEM-A
 * MPLS_1 Namespace2 SEM_B 
 * Used in case only one label exist in MPLS Stack 
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l2_set(
    int unit,        
    uint32 mpls_1_namespace,    
    uint32 mpls_2_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  /* ISA label1
     ISB label1
   */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace, 0);;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_2_namespace, 0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x18);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (1);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;  

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l2_set()", 0, 0);
}

/* 
 * Indexed MPLS 
 * MPLS_1 Namespace1 SEM-A
 * MPLS_1 x GAL Namespace2 SEM_B 
 * Used in case only one label exist in MPLS Stack 
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l1_gal_set(
    int unit,        
    uint32 mpls_1_namespace,    
    uint32 mpls_2_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  /* ISA label1
     ISB label1
   */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace, 0);;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_MPLS_PWE_GAL;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x18);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;  

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l1_gal_set()", 0, 0);
}

/* 
 * Indexed MPLS 
 * MPLS_1 Namespace1 SEM-A
 * MPLS_2 Namespace2 SEM_B 
 * Used in case when more than one label exist in MPLS Stack 
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_set(
    int unit,        
    uint32 mpls_1_namespace,    
    uint32 mpls_2_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  /* ISA label1
     ISB label2
   */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3            = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace, 0);;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_2_namespace, 0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x10);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x8);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (3);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;  

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_set()", 0, 0);
}


/* 
 * Indexed MPLS 
 * MPLS_1 Namespace1 SEM-A
 * MPLS_2 x GAL Namespace2 SEM_B 
 * Used in case when more than one label exist in MPLS Stack  
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_gal_set(
    int unit,        
    uint32 mpls_1_namespace,    
    uint32 mpls_2_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  /* ISA label1
     ISB label2
   */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_1_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_1_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3            = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace, 0);;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = (0x1);  
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_MPLS_PWE_GAL;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x10);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x8);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (3);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;  

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_gal_set()", 0, 0);
}

/* 
 * Indexed MPLS 
 * MPLS_1 Namespace1 SEM-A
 * MPLS_2 x GAL Namespace2 SEM_B 
 * Used in case when more than one label exist in MPLS Stack  
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l3_gal_set(
    int unit,        
    uint32 mpls_1_namespace,    
    uint32 mpls_2_namespace
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  /* ISA label1
     ISB label2
   */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_MPLS_2_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_CE_MPLS_2_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_MPLS_3_19_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3            = ARAD_PP_CE_MPLS_3_15_0;
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NAMESPACE_TO_PREFIX(mpls_1_namespace, 0);;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = (0x1);  
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_MPLS_PWE_GAL;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x10);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x8);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MPLS;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (1);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (3);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = ARAD_PP_ISEM_SECOND_STAGE_PARSING_ENABLE(unit);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;  

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l3_gal_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_bridge_star_2nd_prog_set(
    int unit,
    uint8 spoof_enable,
    uint8 spoof_ipv6_enable,
    uint8 trill_appointed_fwd,
    uint32 spoof_access_profile_id       
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0        = ARAD_PP_CE_SA_8MSB_CB16;  
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2        = ARAD_PP_CE_IPV4_SIP_HDR2_HEADER_31_16;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3        = ARAD_PP_CE_IPV4_SIP_HDR2_HEADER_15_0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = (trill_appointed_fwd) ? ARAD_PP_ISEM_ACCESS_32B_INST_IN_PORT:ARAD_PP_CE_IPV6_SIP_HDR2_HEADER_127_96;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst1        = (trill_appointed_fwd) ? ARAD_PP_ISEM_ACCESS_32B_INST_INITIAL_VSI:ARAD_PP_CE_IPV6_SIP_HDR2_HEADER_95_64;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_CE_IPV6_SIP_HDR2_HEADER_63_32;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst3        = ARAD_PP_CE_IPV6_SIP_HDR2_HEADER_31_0;
  /*TT0 - {VSI[14:8], IPV4 SIP} in ISB */
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1     = (trill_appointed_fwd) ? (0xC):(0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2     = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask         = (trill_appointed_fwd) ? 0x0:0x7;
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask          = (trill_appointed_fwd) ? ARAD_PP_ISEM_ACCESS_TRILL_FINE_A_GRAINED_PREFIX:ARAD_PP_ISEM_ACCESS_IPV4_SPOOF_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable    = (spoof_enable || trill_appointed_fwd) ? (0x1) : (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x28);
  /*TT1 - {VSI, IPV6} SIP in TCAM */
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1  = (0xd);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2  = (0xc);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile   = spoof_ipv6_enable ? spoof_access_profile_id /* ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE */: (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x20);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1  = (trill_appointed_fwd) ? (0xC):(0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask       = (trill_appointed_fwd) ? (ARAD_PP_ISEM_ACCESS_TRILL_FINE_A_GRAINED_PREFIX):(0x0);
  /*general */
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable = (trill_appointed_fwd) ? (0x1):(0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_BRIDGE;
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_bridge_star_2nd_prog_set()", spoof_enable, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_vpls_gre_ipv4_router_2nd_tt_dip_found_prog_set(
    int unit,
    uint8  sip_dip_lookup_enable
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_NATIVE_VLAN_VSI;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0            = ARAD_PP_CE_SIP_IPV4_HDR2_HEADER;  
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_GRE_8B_CRKS_BITS_CE16;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2            = ARAD_PP_CE_GRE_8B_KEY_31_8_BITS_CE32;
  /*TT0 - DIP in ISA and SIP,DIP in tcam */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x4);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_OVERLAY_SIP_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = sip_dip_lookup_enable ? 0x0:0x1;
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile          =  0x3f;
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x10);
  /* inner-ethernet-vlan , GRE-KEY, VXLAN-VNI */
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x5);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x8);
  /*general */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code          = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_IP;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0          = (1); /* VT1 (DIP lookup) */
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1          = (0); 
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2          = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing     = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile       = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_PWEoGRE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_vpls_gre_ipv4_router_2nd_tt_dip_found_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_dip_found_prog_set(
    int unit,
    uint8  nvgre_enable,
    uint8  vxlan_enable,
    uint8  e_o_ip_enable,
    uint8  sip_dip_lookup_enable
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_NATIVE_VLAN_VSI;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0            = ARAD_PP_CE_SIP_IPV4_HDR2_HEADER;  
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_GRE_8B_CRKS_BITS_CE16;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2            = ARAD_PP_CE_GRE_8B_KEY_31_8_BITS_CE32;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst3            = ARAD_PP_CE_VXLAN_VNI_BITS_CE32;
  /*TT0 - DIP in ISA and SIP,DIP in tcam */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x4);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_OVERLAY_SIP_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = sip_dip_lookup_enable ? 0x0:0x1;
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile          =  0x3f;
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x10);
  /* inner-ethernet-vlan , GRE-KEY, VXLAN-VNI */
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (e_o_ip_enable) ? (0x1):(0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (nvgre_enable) ? (0x5) : ((vxlan_enable) ? 0x8:0x0) ;
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x8);
  /*general */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code          = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_IP;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0          = (1); /* VT1 (DIP lookup) */
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1          = (0); 
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2          = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing     = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile       = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_dip_found_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_dip_not_found_prog_set(
    int unit,
    uint8  nvgre_enable,
    uint8  vxlan_enable,
    uint8  e_o_ip_enable,
    uint8  sip_dip_lookup_enable
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_NATIVE_VLAN_VSI;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1            = ARAD_PP_ISEM_ACCESS_16B_INST_IN_RIF_VALID_VRF_9_LSBS;  
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0            = ARAD_PP_CE_SIP_IPV4_HDR2_HEADER;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst1            = ARAD_PP_CE_DIP_IPV4_HDR2_HEADER_27_0;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_GRE_8B_CRKS_BITS_CE16;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2            = ARAD_PP_CE_GRE_8B_KEY_31_8_BITS_CE32;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst3            = ARAD_PP_CE_VXLAN_VNI_BITS_CE32;
  /*TT0 - VRF,DIP (can be done ISA or TCAM) */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0xa);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_RPA_ID_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = 0x1;
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile          =  0x3f;
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x10);
  /* inner-ethernet-vlan , GRE-KEY, VXLAN-VNI */
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (e_o_ip_enable) ? (0x1):(0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (nvgre_enable) ? (0x5) : ((vxlan_enable) ? 0x8:0x0) ;
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x8);
  /*general */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code          = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_COMPATIBLE_MC;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0          = (1); /* VT1 (DIP lookup) */
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1          = (0); 
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2          = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing     = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile       = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_dip_not_found_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_uc_dip_not_found_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask              = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable        = 0x0;
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile          =  0x3f;
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap  = (0x0);
  /* inner-ethernet-vlan , GRE-KEY, VXLAN-VNI */
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = 0x0;
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = 0x0;
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x0);
  /*general */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code          = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_IP;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0          = (1); /* VT1 (DIP lookup) */
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1          = (0); 
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2          = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing     = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile       = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_uc_dip_not_found_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_ip_router_2nd_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0           = 0x0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst1           = 0x0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2           = 0x0;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst3           = 0x0;  
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask             = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable       = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x00);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2        = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile          = 0x3f; 
  ihp_vtt2nd_key_construction_tbl_data.processing_code          = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_IP;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0          = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1          = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2          = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing     = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile       = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_ip_router_2nd_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_ipv6_router_2nd_prog_set(
    int unit,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_DIP_IPV6_HDR2_HEADER_127_96;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst1        = ARAD_PP_CE_DIP_IPV6_HDR2_HEADER_95_64;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2        = ARAD_PP_CE_DIP_IPV6_HDR2_HEADER_63_32;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst3        = ARAD_PP_CE_DIP_IPV6_HDR2_HEADER_31_0;
  /*TT0 - L2 in ISA */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x20);
  /*TT1 - L3 in ISB */
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x0);
  /*general */
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1        = (0xc);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2        = (0xc);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE; */
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_IP;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_ipv6_router_2nd_prog_set()", 0, 0);
}

/*
 * IPMC TT program (do nothing). also performing overlay lookup for PMF use. if found snoop command for recycle will be created.
 */
STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_ip_router_compatiblemc_2nd_prog_set(
    int unit,
    uint8  nvgre_enable,
    uint8  vxlan_enable,
    uint8  e_o_ip_enable
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0            = ARAD_PP_CE_NATIVE_VLAN_VSI;
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2            = ARAD_PP_CE_GRE_8B_CRKS_BITS_CE16;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2            = ARAD_PP_CE_GRE_8B_KEY_31_8_BITS_CE32;
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst3            = ARAD_PP_CE_VXLAN_VNI_BITS_CE32;
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1         = (e_o_ip_enable) ? (0x1):(0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2         = (nvgre_enable) ? (0x5) : ((vxlan_enable) ? 0x8:0x0) ;
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask              = ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable = (e_o_ip_enable | nvgre_enable | vxlan_enable) ? 0x1:0x0;
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile   = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (e_o_ip_enable | nvgre_enable | vxlan_enable) ? (0x8):(0x0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_COMPATIBLE_MC;
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_ip_router_compatiblemc_2nd_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_unknown_l3_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask                 = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile              = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2             = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask                 = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable            = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt      = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt     = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code              = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_UNKNOWN_L3;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0              = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1              = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2              = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile           = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_unknown_l3_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_mac_in_mac_with_btag_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_ETH_HEADER_ISID;
	/*TT0 - {ISID-DOMAIN=0, ISID} in ISA */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x4);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
	ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = ARAD_PP_ISEM_ACCESS_ISID_DOMAIN_ISID_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x10);
  /*general */
	ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile   = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MIM;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2); /* use tt0 result */
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_MAC_IN_MAC;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_mac_in_mac_with_btag_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_mac_in_mac_mc_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0        = ARAD_PP_CE_ETH_HEADER_ISID;
	/*TT0 - {ISID-DOMAIN=0, ISID} in ISA */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1         = (0x4);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2         = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask            = ARAD_PP_ISEM_ACCESS_ISID_DOMAIN_ISID_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x10);
  /*general */
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile   = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_MY_B_MAC_MC_BRIDGE;
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (2); /* use tt0 result */
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_MAC_IN_MAC;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_mac_in_mac_mc_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_arp_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile   = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_ARP;
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = 0;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_arp_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_fc_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /*TT0 - L2 in ISB */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0 = ARAD_PP_ISEM_ACCESS_16B_INST_FC_D_ID_8_MSB; /*FC_D_ID[23:16] */
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1  = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask          = (0x0);
	ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_FC_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8);
  /*general */
	ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile   = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_CUSTOM_1;
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_FC;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_fc_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_fc_with_vft_prog_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /*TT0 - L2 in ISB */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0 = ARAD_PP_ISEM_ACCESS_16B_INST_FC_WITH_VFT_D_ID_8_MSB; /*FC_D_ID[23:16] */
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1  = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2  = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask          = (0x0);
	ihp_vtt2nd_key_construction_tbl_data.isb_or_mask            = ARAD_PP_ISEM_ACCESS_FC_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap = (0x8);
  /*general */
	ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile        = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0         = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1         = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2         = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing   = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile   = (0x3F);
  ihp_vtt2nd_key_construction_tbl_data.processing_code       = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_CUSTOM_1;
  ihp_vtt2nd_key_construction_tbl_data.processing_profile    = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_FC;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_fc_with_vft_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_trill_uc_prog_set(
    int unit,
    uint8  trill_mode,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  /*
   * SEM A: ingress nick
   * SEM B: Native outer vid + 0b10+ vlan domain
   * TCAM:  Native outer vid + 0b10+ vlan domain
   */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0              = ARAD_PP_CE_NATIVE_VLAN_VSI; 
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1              = ARAD_PP_ISEM_ACCESS_16B_INST_1_ONES; 
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0              = 0;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1           = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1          = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt    = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt    = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt   = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2              = ARAD_PP_CE_TRILL_INGRESS_NICK; 
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3              = 0; 
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2              = ARAD_PP_ISEM_ACCESS_32B_INST_1_ZEROS;
  /* only VL legacy lookup VD . Otherwise pad with zeros */
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst3              = (trill_mode == 1) ? ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN:ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(8); 
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2           = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2           = (0xc); 
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2          = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask               = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask                = ARAD_PP_ISEM_ACCESS_TRILL_NICK_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask               = (0x0);
  /* VL legacy use same Database as bridge */
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask                = (trill_mode == 1) ? ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX:ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX; 
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable          = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable          = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.processing_code            = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_TRILL; 
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0            = (2); /* Use TT0 result */
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1            = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2            = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing       = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap    = (0x10);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap    = (0xc);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile            = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE; */
  ihp_vtt2nd_key_construction_tbl_data.processing_profile         = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_trill_uc_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_trill_uc_two_vlans_at_native_eth_prog_set(
    int unit,
    uint8  trill_mode,
    uint32 access_profile_id
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);
  /*
   * SEM A: ingress nick
   * SEM B: Native outer vid + Native inner vid + 0b11+ vlan domain
   * TCAM:  Native outer vid + 0b11+ vlan domain
   */
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst0              = ARAD_PP_CE_NATIVE_INNER_VLAN_VSI; 
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst1              = ARAD_PP_CE_NATIVE_VLAN_VSI; 
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst0              = 0;
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_1           = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_1           = (0x3);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_1          = (0x2);
  ihp_vtt2nd_key_construction_tbl_data.isa_key_initial_from_vt    = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_initial_from_vt    = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_initial_from_vt   = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst2              = ARAD_PP_CE_TRILL_INGRESS_NICK; 
  ihp_vtt2nd_key_construction_tbl_data.key_16b_inst3              = 0; 
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst2              = ARAD_PP_ISEM_ACCESS_32B_INST_2_ONES;
  /* only VL legacy lookup VD */ 
  ihp_vtt2nd_key_construction_tbl_data.key_32b_inst3              = (trill_mode == 1) ? ARAD_PP_ISEM_ACCESS_32B_INST_VLAN_DOMAIN:ARAD_PP_ISEM_ACCESS_32B_INST_X_ZEROS(8); 
  ihp_vtt2nd_key_construction_tbl_data.isa_key_valids_2           = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_key_valids_2           = (0xc); /* only VL legacy lookup VD */
  ihp_vtt2nd_key_construction_tbl_data.tcam_key_valids_2          = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_and_mask               = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.isa_or_mask                = ARAD_PP_ISEM_ACCESS_TRILL_NICK_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isb_and_mask               = (0x0);
  /* VL legacy use same Database as bridge */
  ihp_vtt2nd_key_construction_tbl_data.isb_or_mask                = (trill_mode == 1) ? ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX:ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX;
  ihp_vtt2nd_key_construction_tbl_data.isa_lookup_enable          = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.isb_lookup_enable          = (0x1);
  ihp_vtt2nd_key_construction_tbl_data.processing_code            = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_TRILL; 
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_0            = (2); /* Use TT0 result */
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_1            = (0);
  ihp_vtt2nd_key_construction_tbl_data.result_to_use_2            = (0);
  ihp_vtt2nd_key_construction_tbl_data.second_stage_parsing       = (0x0);
  ihp_vtt2nd_key_construction_tbl_data.termination_0_pd_bitmap    = (0x10);
  ihp_vtt2nd_key_construction_tbl_data.termination_1_pd_bitmap    = (0xc);
  ihp_vtt2nd_key_construction_tbl_data.tcam_db_profile            = access_profile_id; /* ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE;  */
  ihp_vtt2nd_key_construction_tbl_data.processing_profile         = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_trill_uc_two_vlans_at_native_eth_prog_set()", 0, 0);
}

STATIC
uint32
  arad_pp_vtt_2nd_lookup_program_tt_trill_trap_set(
    int unit
  )
{
  uint32
    res; 
  int
    prog_indx = tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG].prog_used;
  ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA
    ihp_vtt2nd_key_construction_tbl_data;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_CLEAR(&ihp_vtt2nd_key_construction_tbl_data, ARAD_PP_IHP_VTT2ND_KEY_CONSTRUCTION_TBL_DATA, 1);

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_get_unsafe(
            unit,
            prog_indx,
            &ihp_vtt2nd_key_construction_tbl_data
          );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10, exit);

  ihp_vtt2nd_key_construction_tbl_data.processing_code            = ARAD_PP_ISEM_ACCESS_PROCESSING_CODE_TYPE_TRILL_DESIGNATED_VLAN; 
  ihp_vtt2nd_key_construction_tbl_data.processing_profile         = ARAD_PP_IHP_VTT_TT_PROCESSING_PROFILE_NONE;

  res = arad_pp_ihp_vtt2nd_key_construction_tbl_set_unsafe(
              unit,
              prog_indx,
              &ihp_vtt2nd_key_construction_tbl_data
            );
  SOC_SAND_CHECK_FUNC_RESULT(res, prog_indx*10+1, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_tt_trill_trap_set()", 0, 0);
}

STATIC 
uint32
  arad_pp_vtt_2nd_lookup_program_set(
    int unit,
    ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES *prog_soc_prop
  )
{
  uint32
    res; 
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_tm_prog_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG, exit);
  }
   
  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_l2_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L2, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L3].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_l3_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L3, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_l2_l3eli_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_coupling_l3_l4_set(unit, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_arp_prog_set(unit);            
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_bridge_star_2nd_prog_set(unit,prog_soc_prop->spoof_enable,prog_soc_prop->spoof_ipv6_enable,prog_soc_prop->trill_appointed_fwd, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_vpls_gre_ipv4_router_2nd_tt_dip_found_prog_set(unit, prog_soc_prop->ipv4_term_dip_sip_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_dip_found_prog_set(unit, prog_soc_prop->nvgre_enable, 
                                                                                  prog_soc_prop->vxlan_enable,  prog_soc_prop->e_o_ip_enable, prog_soc_prop->ipv4_term_dip_sip_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_dip_not_found_prog_set(unit, prog_soc_prop->nvgre_enable, 
                                                                                      prog_soc_prop->vxlan_enable,  prog_soc_prop->e_o_ip_enable, prog_soc_prop->ipv4_term_dip_sip_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_ipv4_router_2nd_tt_uc_dip_not_found_prog_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_ip_router_2nd_prog_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_ipv6_router_2nd_prog_set(unit, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_ip_router_compatiblemc_2nd_prog_set(unit, prog_soc_prop->nvgre_enable, prog_soc_prop->vxlan_enable,  prog_soc_prop->e_o_ip_enable);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_unknown_l3_prog_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_mac_in_mac_mc_prog_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_mac_in_mac_with_btag_prog_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG, exit);
  }
  
  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_fc_with_vft_prog_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_fc_prog_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_inrif_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, 
                                                                 prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_l3eli_inrif_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, 
                                                                 prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2eli_inrif_set(unit, prog_soc_prop->is_bos_in_key_enable, 
                                                                    prog_soc_prop->mpls_1_database, prog_soc_prop->mpls_1_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l3_l2_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, 
                                                                 prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_database,
                                                                 prog_soc_prop->mpls_2_namespace, prog_soc_prop->mpls_3_database,
                                                                 prog_soc_prop->mpls_3_namespace, prog_soc_prop->tunnel_termination_in_tt_only);

    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l3_l4_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, 
                                                                 prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_database,
                                                                 prog_soc_prop->mpls_2_namespace, prog_soc_prop->mpls_3_database,
                                                                 prog_soc_prop->mpls_3_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4, exit);
  }
  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l3eli_set(unit, prog_soc_prop->is_bos_in_key_enable, prog_soc_prop->mpls_1_database, 
                                                                 prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_database,
                                                                 prog_soc_prop->mpls_2_namespace, prog_soc_prop->mpls_3_database,
                                                                 prog_soc_prop->mpls_3_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI, exit);      
  } 

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l1_set(unit, prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1, exit);      
  } 

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l2_set(unit, prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2, exit);      
  } 

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l1_gal_set(unit, prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL, exit);      
  } 

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_set(unit, prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2, exit);      
  } 

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l1_l2_gal_set(unit, prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL, exit);      
  } 

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_indx_l2_l3_gal_set(unit, prog_soc_prop->mpls_1_namespace, prog_soc_prop->mpls_2_namespace);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL, exit);      
  } 

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_trill_uc_prog_set(unit, prog_soc_prop->trill_mode, ARAD_TCAM_ACCESS_PROFILE_INVALID);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_trill_uc_two_vlans_at_native_eth_prog_set(unit, prog_soc_prop->trill_mode, ARAD_TCAM_ACCESS_PROFILE_INVALID); 
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH, exit);
  }

  if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG].prog_used != -1)
  {
    res = arad_pp_vtt_2nd_lookup_program_tt_trill_trap_set(unit);
    SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_vtt_2nd_lookup_program_set()", 0, 0);
}

STATIC
  uint32
    arad_pp_isem_access_tcam_callback(
      SOC_SAND_IN int unit,
      SOC_SAND_IN uint32  user_data
    )
{  
  uint32
    res = SOC_SAND_OK;
  uint32
    tcam_db_id,
    access_profile_id;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  /* Set access_profile id depending on TCAM DB ID */
  tcam_db_id = user_data;

  res = arad_sw_db_tcam_db_access_profile_id_get(
          unit,
          tcam_db_id,
          0, /* No 320b DB */
          &access_profile_id
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  switch (user_data) /* tcam DB ID */
  {
  case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE:
     
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_l1frr_set(unit, prog_soc_prop.is_bos_in_key_enable, prog_soc_prop.mpls_1_database, access_profile_id);    
      SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);
    }
    
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR].prog_used != -1)
    { 
      res = arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1frr_set(unit, prog_soc_prop.is_bos_in_key_enable, prog_soc_prop.mpls_1_database, access_profile_id);      
      SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);
    }
              
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_indx_vdinitialvid_frr_l1_set(unit, prog_soc_prop.is_bos_in_key_enable, prog_soc_prop.mpls_1_database, prog_soc_prop.mpls_1_namespace, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);
    }
      
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_indx_vdoutervid_frr_l1_set(unit, prog_soc_prop.is_bos_in_key_enable, prog_soc_prop.mpls_1_database, prog_soc_prop.mpls_1_namespace, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);
    }
  
    
    break;
  case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_COUPLING_DB_PROFILE:
    
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_vd_initialvid_l1l2_set(unit, prog_soc_prop.mpls_1_database, access_profile_id);     
      SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);
    }
    
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_vd_outervid_l1l2_set(unit, prog_soc_prop.mpls_1_database, access_profile_id);      
      SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);
    }

    if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4].prog_used != -1)
    {
      res = arad_pp_vtt_2nd_lookup_program_tt_coupling_l3_l4_set(unit, access_profile_id);
      SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);
    }
    break;

  case ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE:

    if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG].prog_used != -1)
    {
      res = arad_pp_vtt_2nd_lookup_program_tt_bridge_star_2nd_prog_set(unit,prog_soc_prop.spoof_enable,prog_soc_prop.spoof_ipv6_enable,prog_soc_prop.trill_appointed_fwd, access_profile_id);  
      SOC_SAND_CHECK_FUNC_RESULT(res, 140, exit);
    }

    break;
    
    break;
 case ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE:

    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_ipv4_initial_vid_set(unit, prog_soc_prop.ipv4_term_dip_sip_enable, prog_soc_prop.mpls_1_database, access_profile_id);
      SOC_SAND_CHECK_FUNC_RESULT(res, 150, exit);
    }

    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_ipv4_outer_vid_set(unit, prog_soc_prop.ipv4_term_dip_sip_enable, prog_soc_prop.mpls_1_database, access_profile_id);
      SOC_SAND_CHECK_FUNC_RESULT(res, 155, exit);
    }
    
    break;
  case ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE:
    if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG].prog_used != -1)
    {
      res = arad_pp_vtt_2nd_lookup_program_tt_ipv6_router_2nd_prog_set(unit, access_profile_id);                  
      SOC_SAND_CHECK_FUNC_RESULT(res, 160, exit);
    }
    break;
  case ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE:
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_vd_outer_inner_or_vd_outer_inner_outerpcp_set(unit, access_profile_id);
      SOC_SAND_CHECK_FUNC_RESULT(res, 190, exit);
    }

    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_high_vd_outer_inner_outerpcp_or_vd_outer_inner_or_vd_outer_set(unit, access_profile_id);
      SOC_SAND_CHECK_FUNC_RESULT(res, 195, exit);
    }
    break;
  case ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE:
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_pon_untagged_set(unit, prog_soc_prop.tls_db_enable, prog_soc_prop.custom_pon_enable, prog_soc_prop.tls_in_tcam_enable, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 240, exit);
    }

    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_pon_one_tag_set(unit, prog_soc_prop.custom_pon_enable, prog_soc_prop.tls_in_tcam_enable, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 245, exit);
    }

    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_pon_two_tags_set(unit, prog_soc_prop.custom_pon_enable, prog_soc_prop.tls_in_tcam_enable, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 250, exit);
    }

    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_pon_two_tags_vs_tunnel_id_set(unit, prog_soc_prop.custom_pon_enable, prog_soc_prop.tls_in_tcam_enable, access_profile_id);
      SOC_SAND_CHECK_FUNC_RESULT(res, 255, exit);
    }

    break;
  case ARAD_PP_ISEM_ACCESS_TCAM_IPV4_MATCH_VT_DB_PROFILE :
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_single_tag_5_ip_tuple_set(unit, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }

    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_double_tag_5_ip_tuple_set(unit, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }
    break;
  case ARAD_PP_ISEM_ACCESS_VT_CLASSIFICATIONS_EFP :  
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_double_tag_tst(unit, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_single_tag_tst(unit, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_untagged_tst(unit, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }
  break;
  case ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE:
    if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG].prog_used != -1)
    {
      res = arad_pp_vtt_2nd_lookup_program_tt_trill_uc_prog_set(unit, prog_soc_prop.trill_mode, access_profile_id);
      SOC_SAND_CHECK_FUNC_RESULT(res, ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG, exit);
    }
    if (tt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH].prog_used != -1)
    {
      res = arad_pp_vtt_2nd_lookup_program_tt_trill_uc_two_vlans_at_native_eth_prog_set(unit, prog_soc_prop.trill_mode, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }
    break;
  case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE : /* same programs as EFP */
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_double_tag_tst_explicit_null_set(unit, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_single_tag_tst_explicit_null_set(unit, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }
    if (vt_programs[unit][ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL].prog_used != -1)
    {
      res = arad_pp_vtt_1st_lookup_program_vt_untagged_tst_explicit_null_set(unit, access_profile_id); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 260, exit);
    }
  break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 300, exit);
  }

  ARAD_DO_NOTHING_AND_EXIT;
exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_callback()", 0, 0);
}


STATIC 
uint32
  arad_pp_isem_tcam_init_unsafe(
    int unit,
    uint8 fast_reroute_labels_enable,
    uint8 coupling_enable,
    uint8 spoof_ipv6_enable,
    uint8 trill_mode,    
    uint8 ipv4_term_dip_sip_enable,
    uint8 ipv6_term_enable,
    uint8 port_vlan_pcp_lookup_enable,
    uint8 use_pon_tcam_lkup,
    uint8 q_in_q_ip_5_tuple_enable,
    uint8 custom_feature_vt_tst1,
    uint8 trill_transparent_service,
    uint8 explicit_null_support
  )
{
  uint32
    res = SOC_SAND_OK;
  SOC_SAND_SUCCESS_FAILURE
    success;
  ARAD_TCAM_ACCESS_INFO
    tcam_access_info;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /*
   *  Create TCAM databases
   */
  if (fast_reroute_labels_enable) /* Enable when FRR is enabled */
  {
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS; 
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE;

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);    
  }

  if (coupling_enable) { /* Enable when MPLS context specific is enabled */
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS; 
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_MPLS_COUPLING_DB_PROFILE;

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_MPLS_COUPLING_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);   
  }

  if (spoof_ipv6_enable) /* Enable when IPV6 spoof application is enabled */
  {
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_TT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE;

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);      
  }

  if (ipv4_term_dip_sip_enable) /* Enabled when Required IPV4 Tunnel Termination by SIP & DIP */
  {
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    if (ipv4_term_dip_sip_enable == 2) 
    { 
      /* In case of IPV4 next protocol we pass 80 bits per entry */
      tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS;
    } 
    else 
    {
      tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
    }
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE;

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);    
  }

  if (ipv6_term_enable) /* Enabled when Required IPV6 Tunnel Termination */
  {
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_TT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE;

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);    
  }

  if (port_vlan_pcp_lookup_enable) { /* Enabled when PCP lookup is set */
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE;

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 55, exit);    
  }

  if (use_pon_tcam_lkup) { /* Enabled when PON TCAM application is enabled */
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE;

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);    
  }

  if (q_in_q_ip_5_tuple_enable) { /* Enabled when flexible QinQ application is enabled */
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_160_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_IPV4_MATCH_VT_DB_PROFILE;

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_IPV4_MATCH_VT_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);    
  }

  if (custom_feature_vt_tst1) {
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_VT_CLASSIFICATIONS_EFP;

    if ( soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_use_small_banks",0) )
    {
        tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORCE;
    }

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_VT_CLASSIFICATIONS_EFP,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);    

  }
  if (trill_transparent_service) { /* Enabled when trill transparent service is enabled */
      arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);
  
      tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
      tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
      tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
      tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
      tcam_access_info.is_direct                           = FALSE;
      tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
      tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
      tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE;
  
      res = arad_tcam_access_create_unsafe(
              unit,
              ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE,
              &tcam_access_info,
              &success
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);    
  }

  if (explicit_null_support) {
    arad_ARAD_TCAM_ACCESS_INFO_clear(&tcam_access_info);

    tcam_access_info.action_bitmap_ndx                   = ARAD_TCAM_ACTION_SIZE_FIRST_20_BITS;
    tcam_access_info.bank_owner                          = ARAD_TCAM_BANK_OWNER_VT;
    tcam_access_info.callback                            = arad_pp_isem_access_tcam_callback;
    tcam_access_info.entry_size                          = ARAD_TCAM_BANK_ENTRY_SIZE_80_BITS;
    tcam_access_info.is_direct                           = FALSE;
    tcam_access_info.min_banks                           = ARAD_PP_ISEM_ACCESS_TCAM_DEF_MIN_BANKS;
    tcam_access_info.prefix_size                         = ARAD_PP_ISEM_ACCESS_TCAM_DEF_PREFIX_SIZE;
    tcam_access_info.user_data                           = ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE;

    if ( soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_use_small_banks",0) )
    {
        tcam_access_info.use_small_banks                 = ARAD_TCAM_SMALL_BANKS_FORCE;
    }

    res = arad_tcam_access_create_unsafe(
            unit,
            ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE,
            &tcam_access_info,
            &success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 70, exit);    

  }



exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_tcam_init_unsafe()", 0, 0);
}

void 
arad_pp_isem_access_deinit(int unit)
{
    is_g_prog_soc_prop_initilized[unit] = 0;   
}
uint32
  arad_pp_isem_access_init_unsafe(
    SOC_SAND_IN  int                                 unit
  )
{
  uint32
    res = SOC_SAND_OK;
  uint64 
    failure;
  uint32
      core_id,
    table_data[5] = {0};
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]


  res = arad_fill_table_with_entry(unit, IHP_VTT_1ST_LOOKUP_PROGRAM_0m, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_fill_table_with_entry(unit, IHP_VTT_1ST_LOOKUP_PROGRAM_1m, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);
  
  res = arad_fill_table_with_entry(unit, IHP_VTT_2ND_LOOKUP_PROGRAM_0m, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

  res = arad_fill_table_with_entry(unit, IHP_VTT_2ND_LOOKUP_PROGRAM_1m, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 35, exit);


  /* VTT PTC config */
  res = arad_fill_table_with_entry(unit, IHP_VTT_PTC_CONFIGm, MEM_BLOCK_ANY, table_data);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);  


  if (SOC_IS_JERICHO(unit)) {
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, IHB_ISEM_MANAGEMENT_UNIT_CONFIGURATION_REGISTERr, REG_PORT_ANY, 0, ISEM_MNGMNT_UNIT_ENABLEf,  0x1));

      /* Clear failure indication of ISEM */
      for (core_id = 0; core_id < SOC_DPP_DEFS_GET(unit, nof_cores); core_id++) {
          SOC_SAND_SOC_IF_ERROR_RETURN(res, 1000 + core_id, exit, READ_IHB_ISEM_MANAGEMENT_UNIT_FAILUREr(unit, core_id, &failure));
      }
  } else {
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, IHP_ISA_MANAGEMENT_UNIT_CONFIGURATION_REGISTERr, REG_PORT_ANY, 0, ISA_MNGMNT_UNIT_ENABLEf,  0x1));
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, IHP_ISB_MANAGEMENT_UNIT_CONFIGURATION_REGISTERr, REG_PORT_ANY, 0, ISB_MNGMNT_UNIT_ENABLEf,  0x1));

      /* Clear failure indication of ISEM */
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 1000, exit, READ_IHP_ISA_MANAGEMENT_UNIT_FAILUREr(unit, &failure));
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 1010, exit, READ_IHP_ISB_MANAGEMENT_UNIT_FAILUREr(unit, &failure));
  }


  /* init the programs info */
  res = arad_pp_isem_prog_programs_init(unit);
  SOC_SAND_CHECK_FUNC_RESULT(res, 1578, exit);

  if ((prog_soc_prop.nvgre_enable && prog_soc_prop.e_o_ip_enable) ||
      (prog_soc_prop.nvgre_enable && prog_soc_prop.vxlan_enable) ||
      (prog_soc_prop.e_o_ip_enable && prog_soc_prop.vxlan_enable) ||
      (prog_soc_prop.custom_pon_enable && (!prog_soc_prop.tls_in_tcam_enable))) 
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_SOC_PROPERTIES_ERR, 5055, exit); /* only one OVERLAY can be enabled */
  }

  /* Init isem program selection */
  res = arad_pp_isem_prog_sel_cam_init(
          unit
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);

  /* set 1st lookup programs */
  res = arad_pp_vtt_1st_lookup_program_set(
          unit,
          &prog_soc_prop          
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  /* set 1st lookup programs */
  res = arad_pp_vtt_2nd_lookup_program_set(
          unit,
          &prog_soc_prop
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  /* Program selection { */
  /* set deafult programs 2nd lookup */
  res = arad_pp_vtt_prog_sel_cam_key_program_1st_set(
          unit,
          &prog_soc_prop
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);
  
  /* set deafult programs 2nd lookup */
  res = arad_pp_isem_prog_sel_cam_key_program_2nd(
          unit,
          &prog_soc_prop
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);

  /* Program selection } */

  /* VTT TCAM initial settings { */  
  res = arad_pp_isem_tcam_init_unsafe(
          unit,
          prog_soc_prop.fast_reroute_labels_enable, /* Enable when FRR */
          prog_soc_prop.coupling_enable,/* MPLS Context Specific enabled */
          prog_soc_prop.spoof_ipv6_enable,
          prog_soc_prop.trill_mode,     
          prog_soc_prop.ipv4_term_dip_sip_enable,  
          prog_soc_prop.ipv6_term_enable,
          prog_soc_prop.port_vlan_pcp_lookup,
          prog_soc_prop.use_pon_tcam_lkup,
          prog_soc_prop.q_in_q_ip_5_tuple,
          prog_soc_prop.custom_feature_vt_tst1,
          prog_soc_prop.trill_transparent_service,
          prog_soc_prop.explicit_null_support
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 25, exit);

  /* VTT TCAM initial settings } */


exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_init_unsafe()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_programs_soc_properties_get(
    SOC_SAND_IN int                                  unit)
{
    uint32
       res = SOC_SAND_OK;

    SOC_SAND_INIT_ERROR_DEFINITIONS(0);

#define  prog_soc_prop     (&(g_prog_soc_prop[unit]))

    ARAD_CLEAR(prog_soc_prop, ARAD_PP_ISEM_ACCESS_PROGRAMS_SOC_PROPERTIES, 1);

    if (SOC_DPP_CONFIG(unit)->arad->init.pp_enable == FALSE) {
        ARAD_DO_NOTHING_AND_EXIT;
    }

    res = arad_pp_sw_db_mpls_fast_reroute_labels_enable_get(unit,&(prog_soc_prop->fast_reroute_labels_enable));
    SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

    res = arad_pp_sw_db_mpls_termination_label_index_enable_get(unit,&(prog_soc_prop->mpls_index));
    SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

    res = arad_pp_sw_db_mpls_lookup_include_inrif_enable_get(unit,&(prog_soc_prop->mpls_use_in_rif));
    SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);

    res = arad_pp_sw_db_mpls_coupling_enable_get(unit,&(prog_soc_prop->coupling_enable));
    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);


    prog_soc_prop->port_vlan_pcp_lookup = (SOC_DPP_CONFIG(unit)->pp.vlan_match_db_mode == SOC_DPP_VLAN_DB_MODE_PCP);
    prog_soc_prop->match_port_vlan_critiria_64K = (SOC_DPP_CONFIG(unit)->pp.vlan_match_db_mode == SOC_DPP_VLAN_DB_MODE_FULL_DB);
    prog_soc_prop->spoof_enable = ((SOC_DPP_CONFIG(unit)->pp.l3_source_bind_mode == SOC_DPP_L3_SOURCE_BIND_MODE_IPV4)
                                   ||(SOC_DPP_CONFIG(unit)->pp.l3_source_bind_mode == SOC_DPP_L3_SOURCE_BIND_MODE_IP)); /* IPV4 Spoof enable */
    prog_soc_prop->trill_mode = SOC_DPP_CONFIG(unit)->trill.mode;
    prog_soc_prop->trill_appointed_fwd = FALSE;
	prog_soc_prop->trill_transparent_service = SOC_DPP_CONFIG(unit)->trill.transparent_service;
    prog_soc_prop->spoof_ipv6_enable = ((SOC_DPP_CONFIG(unit)->pp.l3_source_bind_mode == SOC_DPP_L3_SOURCE_BIND_MODE_IPV6)
                                        ||(SOC_DPP_CONFIG(unit)->pp.l3_source_bind_mode == SOC_DPP_L3_SOURCE_BIND_MODE_IP)); /* IPV6 Spoof enable */
    prog_soc_prop->ipv4_term_dip_sip_enable = ((SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_DIP_SIP)
                                               ||(SOC_DPP_CONFIG(unit)->pp.ingress_ipv4_tunnel_term_mode == SOC_DPP_IP_TUNNEL_L2_LKUP_MODE_SIP_DIP_JOIN));
    if (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_DIP_SIP_NEXT_PROTOCOL) {
        prog_soc_prop->ipv4_term_dip_sip_enable = 2; /* IPV4 Next protocol is enabled */
    }
    prog_soc_prop->nvgre_enable = (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_NVGRE);
    prog_soc_prop->vxlan_enable = (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_VXLAN);
    prog_soc_prop->e_o_ip_enable = (SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_ETHER);
    prog_soc_prop->ipv4_term_enable = ((SOC_DPP_CONFIG(unit)->pp.ipv4_tunnel_term_bitmap_enable & SOC_DPP_IP_TUNNEL_TERM_DB_TUNNEL_MASK)
                                       || prog_soc_prop->nvgre_enable || prog_soc_prop->vxlan_enable || prog_soc_prop->e_o_ip_enable);
    prog_soc_prop->ipv6_term_enable = SOC_DPP_CONFIG(unit)->pp.ipv6_tunnel_enable;
    if (SOC_IS_ARAD_B1_AND_BELOW(unit) && (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "mpls_termination_check_bos_disable", 0) == 1)) {
        prog_soc_prop->is_bos_in_key_enable = FALSE;
    } else {
        prog_soc_prop->is_bos_in_key_enable = TRUE;
    }
#ifdef BCM_88660_A0
    if (SOC_IS_ARADPLUS(unit) && soc_property_get(unit, spn_BCM886XX_MPLS_TERMINATION_KEY_MODE, 1)) {
        prog_soc_prop->is_bos_in_key_enable = FALSE;
    }
#endif /* BCM_88660_A0 */
    prog_soc_prop->pon_enable = SOC_DPP_CONFIG(unit)->pp.pon_application_enable;
    prog_soc_prop->use_pon_tcam_lkup = SOC_DPP_CONFIG(unit)->pp.pon_tcam_lkup_enable;
    prog_soc_prop->tls_db_enable = 1;
    prog_soc_prop->custom_pon_enable = SOC_DPP_CONFIG(unit)->pp.pon_custom_enable;
    prog_soc_prop->tls_in_tcam_enable = SOC_DPP_CONFIG(unit)->pp.pon_tls_in_tcam; /* */
    prog_soc_prop->evb_enable = SOC_DPP_CONFIG(unit)->pp.evb_enable;
    prog_soc_prop->fcoe_enable = SOC_DPP_CONFIG(unit)->pp.fcoe_enable;
    prog_soc_prop->ipv4mc_bidir_enable = SOC_DPP_CONFIG(unit)->l3.nof_rps != 0;
    prog_soc_prop->mim_enable = SOC_DPP_CONFIG(unit)->arad->pp_op_mode.mim_enable;
    prog_soc_prop->eli_enable = SOC_DPP_CONFIG(unit)->pp.mpls_eli_enable;
    prog_soc_prop->mpls_1_namespace = SOC_DPP_CONFIG(unit)->pp.mpls_namespaces[0];
    prog_soc_prop->mpls_2_namespace = SOC_DPP_CONFIG(unit)->pp.mpls_namespaces[1];
    prog_soc_prop->mpls_3_namespace = SOC_DPP_CONFIG(unit)->pp.mpls_namespaces[2];
    prog_soc_prop->mpls_1_database  = SOC_DPP_CONFIG(unit)->pp.mpls_databases[0];
    prog_soc_prop->mpls_2_database  = SOC_DPP_CONFIG(unit)->pp.mpls_databases[1];
    prog_soc_prop->mpls_3_database  = SOC_DPP_CONFIG(unit)->pp.mpls_databases[2];
    prog_soc_prop->mpls_tp_mac_address = soc_property_get(unit, spn_MPLS_TP_MYMAC_RESERVED_ADDRESS, 0);
    prog_soc_prop->trill_disable_designated_vlan_check = soc_property_get(unit, spn_TRILL_DESIGNATED_VLAN_CHECK_DISABLE, 0);
    prog_soc_prop->designated_vlan_inlif_enable = SOC_DPP_CONFIG(unit)->trill.designated_vlan_inlif_enable;
    prog_soc_prop->q_in_q_ip_5_tuple = soc_property_get(unit, spn_VLAN_TRANSLATION_MATCH_IPV4, 0);
    prog_soc_prop->custom_feature_vt_tst1 = SOC_DPP_CONFIG(unit)->pp.custom_feature_vt_tst1;
    prog_soc_prop->tunnel_termination_in_tt_only = SOC_DPP_CONFIG(unit)->pp.tunnel_termination_in_tt_only; 
    prog_soc_prop->pwe_gal_support = SOC_DPP_CONFIG(unit)->pp.gal_support;
    prog_soc_prop->explicit_null_support = SOC_DPP_CONFIG(unit)->pp.explicit_null_support;
    is_g_prog_soc_prop_initilized[unit] = 1;    
exit:

#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_programs_soc_properties_get()", 0, 0);    
}


uint32
  arad_pp_sem_key_extend(
     SOC_SAND_IN  int                        unit,
     SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY             *key,
     SOC_SAND_IN  uint32                              insert_index,
     SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_KEY             *extnd_key
  )
{
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /* copy key */
  sal_memcpy(extnd_key,key, sizeof(ARAD_PP_ISEM_ACCESS_KEY));

  /* Special case VD_PCP_VID once add with DEI is on, once add with DEI off */
  if (extnd_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID) {
    extnd_key->key_info.l2_eth.outer_dei = (insert_index) ? 1:0;
  }

  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_sem_key_extend()", 0, 0);
}

/*
 * Returns the requested table to be insert into .
 */
uint32
  arad_pp_isem_access_sem_tables_get(
    SOC_SAND_IN  int                                  unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                 *isem_key,
    SOC_SAND_OUT uint32                                  *nof_tables,
    SOC_SAND_OUT uint32                                  *tables_access_ids,
    SOC_SAND_OUT uint8                                   *is_duplicate_entry
  )
{
  uint8
    found;
  SOC_PPC_MPLS_TERM_NAMESPACE_TYPE
    namespace = SOC_PPC_MPLS_TERM_NOF_NAMESPACE_TYPES;
  uint32
    res,
    vt_profile = 0;
  ARAD_PP_PORT
    port_i;
  ARAD_PP_PORT_INFO
    port_info;
  uint8
    is_trill = FALSE,
    pon_double_lookup_enable = FALSE;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);  

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  SOC_SAND_CHECK_NULL_INPUT(isem_key);
  SOC_SAND_CHECK_NULL_INPUT(nof_tables);
  SOC_SAND_CHECK_NULL_INPUT(tables_access_ids);
  SOC_SAND_CHECK_NULL_INPUT(is_duplicate_entry);

  /*
   * Decision is depended on soc properties and vlan domain. 
   * When decision to add is arbitrary between A & B tables, 
   *    algorithm will always try first table A (Can be changed).
   */
  found = FALSE;
  *nof_tables = 1;
  *is_duplicate_entry = 0;

  

  /* L2 { */
  /* Matching table in case of L2, depends on VT port profile */
  switch(isem_key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:  
    found = TRUE;
    /* Location depends on VT profile and global parameters */
    /* Support up to 64K Key can be located on either A or B */
    if (prog_soc_prop.match_port_vlan_critiria_64K) 
    {
      /* Match both ISEM-A,B */
      *nof_tables = 2;
      *is_duplicate_entry = 0;
    } 
    else if (prog_soc_prop.port_vlan_pcp_lookup) /* PCP lookups */
    {
      /* Static mapping not depended on port */
      if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD || 
          isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID || 
          isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID)
      {
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }
      if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID)
      {
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
      }
      if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID)
      {
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
      }
      if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID) {
        /* Duplicate twice */
        *nof_tables = 2;
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
        tables_access_ids[1] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
        *is_duplicate_entry = 1;
      }
    }    
    else 
    { /* Default lookups : !pcp, !64K */   
      
      /* 
       * retreive VT profile and then decide 
       * Find port that match vlan domain and take accordingly vt_profile
       * Assumption: all ports on the same vlan domain share same vt_profile
       */
      for (port_i = 0; port_i < ARAD_PP_NOF_PORTS; ++port_i)
      {
        res = arad_pp_port_info_get_unsafe(
              unit,
              port_i,
              &port_info
            );
        SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
        if (port_info.vlan_domain == isem_key->key_info.l2_eth.vlan_domain) 
        {

          /* Check if Trill port */
          if (prog_soc_prop.trill_mode) 
          {
            is_trill = (port_info.vlan_translation_profile == ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL || port_info.vlan_translation_profile == ARAD_PP_PORT_DEFINED_VT_PROFILE_TRILL_USE_INITIAL_VID);
          }
          else
          {
            is_trill = FALSE;
          }
          
          vt_profile = port_info.vlan_translation_profile;
          break;
        }
      }

      if (is_trill)
      {
        /* Trill lookups of bridges: Does not support Double lookup */  
        /* All lookups are done in ISEM-B */
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
      }
      else if (vt_profile == ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY ||
               vt_profile == ARAD_PP_PORT_DEFINED_VT_PROFILE_DOUBLE_TAG_PRIORITY_INITIAL_VID)
      {
        /* Special case: VDxVIDxVID (ISA) and VDxVID (ISB) both lookups */
        tables_access_ids[0] = (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_A:ARAD_PP_ISEM_ACCESS_ID_ISEM_B;        
      }
      else if ((prog_soc_prop.fast_reroute_labels_enable || prog_soc_prop.coupling_enable) 
               && (vt_profile == ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING || vt_profile == ARAD_PP_PORT_DEFINED_VT_PROFILE_FRR_COUPLING_USE_INITIAL_VID)) /* Port support FRR and/or Coupling - L2 in TCAM */
      {
        tables_access_ids[0] = (prog_soc_prop.mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }
      else /* Default: PortxOuter/Initial, Double */
      {
        tables_access_ids[0] = (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID) ? prog_soc_prop.mpls_1_database:
                               (prog_soc_prop.mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }
    }
    
    break;
  default:
    break;
  }
  /* L2 } */

  /* PON { */
  switch (isem_key->key_type) {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
    found = TRUE;
    /* PON extend lookup used only in case property tcam lookup is enable */
    if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID)
    {
      if (!prog_soc_prop.use_pon_tcam_lkup) 
      {
        SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 40, exit);
      }

      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
    }
    else if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL) 
    {
      /* ISEM-A or ISEM-B depends on flags */
      tables_access_ids[0] = (isem_key->key_info.l2_pon.flags & ARAD_PP_ISEM_ACCESS_L2_PON_TLS) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
    }
    else if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID) 
    {
      /* ISEM-A  or ISEM-B depends on soc properties */
      tables_access_ids[0] = (prog_soc_prop.custom_pon_enable ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A);
    }
    else 
    {
      for (port_i = 0; port_i < ARAD_PP_NOF_PORTS; ++port_i)
      {
        res = arad_pp_port_info_get_unsafe(
              unit,
              port_i,
              &port_info
            );
        SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
        if (port_info.vlan_domain == isem_key->key_info.l2_eth.vlan_domain) 
        {        
          /* Check if VlanPortDoubleLookupEnable */
          res = arad_pp_sw_db_pon_double_lookup_port_get(unit, port_i, &pon_double_lookup_enable);
          SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
          break;
        }
      }

      /* In case of Double lookup require to add to only ISEM_B for ARAD+ and comton_pon_enable, and both DBs ISEM_A and ISEM_B for other */
      if (pon_double_lookup_enable)
      {
        if (SOC_IS_ARADPLUS(unit) && prog_soc_prop.custom_pon_enable) {
          tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;  
        } else {
          /* Duplicate twice */
          *nof_tables = 2;
          tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
          tables_access_ids[1] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
          *is_duplicate_entry = 1;
        }
      }
      else
      {
        /* Only add to ISEM-A */
        tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      }     
    }
  default:
    /* Other key types will be checked later */
    break;
  }
  /* PON } */
   

  /* MPLS { */
  
  /* Unindexed: Label in ISEM-B */
  /* Indexed: L1 and L3 in ISEM-B. L2 in ISEM-B */
  
  switch(isem_key->key_type)
  {
  /* MPLS */
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1: 
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF_ELI:   
    found = TRUE;
    tables_access_ids[0] = prog_soc_prop.mpls_1_database; /* Assume database 1 always refer to L1 */
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI: 
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL:
    res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L2,
                                        prog_soc_prop.mpls_1_database, prog_soc_prop.mpls_1_namespace,
                                        prog_soc_prop.mpls_2_database, prog_soc_prop.mpls_2_namespace,
                                        prog_soc_prop.mpls_3_database, prog_soc_prop.mpls_3_namespace,
                                        &namespace,
                                        &tables_access_ids[0]);
    SOC_SAND_CHECK_FUNC_RESULT(res, 900, exit);
        
    found = TRUE;    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:
    found = TRUE;
    res = arad_pp_vtt_find_namespace_database(unit, SOC_PPC_MPLS_TERM_NAMESPACE_L3,
                                        prog_soc_prop.mpls_1_database, prog_soc_prop.mpls_1_namespace,
                                        prog_soc_prop.mpls_2_database, prog_soc_prop.mpls_2_namespace,
                                        prog_soc_prop.mpls_3_database, prog_soc_prop.mpls_3_namespace,
                                        &namespace,
                                        &tables_access_ids[0]);
    SOC_SAND_CHECK_FUNC_RESULT(res, 900, exit);    
    break;
  default:
    /* Other key types will be checked later */
    break;
  }
  
  /* MPLS } */
  
  /* Check other key types */
  if (!found)
  {
    *is_duplicate_entry = 0;
    /* General without specific logic */
    switch (isem_key->key_type)
    {
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG:
      /*
       * All of this key types are located in A
       */
      *nof_tables = 1;
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      found = TRUE;
      break;    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER:
     /*
      * All of this key types can be located in A or B or both.
      */
      *nof_tables = 2;      
      found = TRUE;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE:    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:        
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4:    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG:
      /*
       * All of this key types are located in B
       */
      *nof_tables = 1;
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
      if ((isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI) &&
          ((isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_TTS) != 0)) {
          tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
      }
      found = TRUE;
      break;    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_EoIP:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_COUPLING:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
      /*
       * All of this key types are located in TCAM
       */
      *nof_tables = 1;
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_TCAM;
      found = TRUE;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP: /* special case DIP same as MPLS 1 database */
      *nof_tables = 1;
      tables_access_ids[0] = (prog_soc_prop.mpls_1_database == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) ? ARAD_PP_ISEM_ACCESS_ID_ISEM_B:ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
      found = TRUE;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
      found = TRUE;
      /* Trill lookups of bridges: Does not support Double lookup */  
      /* All lookups are done in ISEM-B */
      tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
      break;
    default:
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 60, exit);
      break;
    }
  }
  
  if ((*nof_tables) == 2 && !(*is_duplicate_entry))
  {
     
    tables_access_ids[0] = ARAD_PP_ISEM_ACCESS_ID_ISEM_A;
    tables_access_ids[1] = ARAD_PP_ISEM_ACCESS_ID_ISEM_B;
  }

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_sem_tables_get()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_key_type_to_prefix(
    SOC_SAND_IN int                                  unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY_TYPE           isem_key_in,
    SOC_SAND_IN  uint32                                 table_access_id,
    SOC_SAND_OUT uint32                                 *isem_prefix    
  )
{
  uint32
    res = SOC_SAND_OK;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  *isem_prefix = ARAD_PP_ISEM_ACCESS_NULL_PREFIX;

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]
  
  switch(isem_key_in)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:    
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS: 
    *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:     
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF:
    *isem_prefix = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L3_PREFIX:
        ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX /* ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX */;
    break;         
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_ELI:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_L1ELI_PREFIX /* ARAD_PP_ISEM_ACCESS_MPLS_L1L2ELI_PREFIX, ARAD_PP_ISEM_ACCESS_MPLS_L1L3ELI_PREFIX */;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI:
    *isem_prefix = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L2) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L2ELI_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L2ELI_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
    *isem_prefix = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L2) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L2_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:
    *isem_prefix = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3) ? ARAD_PP_ISEM_ACCESS_MPLS_L1L3_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L3_PREFIX;
    break;  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_ISID_DOMAIN_ISID_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_IP_PREFIX;
    break;  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_OVERLAY_SIP_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_TRILL_NICK_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL:
    *isem_prefix = (table_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_PP_ISEM_ACCESS_PON_UNTAGGED_PREFIX:ARAD_PP_ISEM_ACCESS_PON_TLS_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_TRILL_FINE_A_GRAINED_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_RPA_ID_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_DOUBLE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_SINGLE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_BRIDGE_DT;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG:  
    *isem_prefix = ARAD_PP_ISEM_ACCESS_BRIDGE_ST;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
    *isem_prefix = prog_soc_prop.pon_enable ? ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX:ARAD_PP_ISEM_ACCESS_VD_OUTER_PCP_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4: 
    *isem_prefix = ARAD_PP_ISEM_ACCESS_IPV4_SPOOF_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE:  
    *isem_prefix = ARAD_PP_ISEM_ACCESS_FC_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX;
    break;  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_TRILL_DESIGNATED_VID_PREFIX;
    break;  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL:
    *isem_prefix = ARAD_PP_ISEM_ACCESS_MPLS_PWE_GAL;
    break;
  default:
    break;
  }

  ARAD_DO_NOTHING_AND_EXIT;

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_key_type_to_prefix()", 0, 0);    
}

STATIC
uint32
  arad_pp_isem_access_prefix_to_key_type(
    SOC_SAND_IN int                                  unit,
    SOC_SAND_IN uint32                                  isem_prefix,
    SOC_SAND_IN uint32                                  lookup_num,
    SOC_SAND_IN uint32                                  tables_access_id,
    SOC_SAND_IN uint32                                  *buffer,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_KEY_TYPE           *isem_key_in
  )
{
  uint32
    res = SOC_SAND_OK,
    two_bits_indicate = 0;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  /* Pick default */
  *isem_key_in = ARAD_PP_ISEM_ACCESS_NOF_KEY_TYPES;
  
  if (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A || tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B)
  {

    /* special case for PON , ISEM-A prefix cover several databases (only 2 bits prefix) */
    if (prog_soc_prop.pon_enable && (!prog_soc_prop.custom_pon_enable) && tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A && 
        ((isem_prefix >> (4 - ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS) == (ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX >> (4-ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS))))) 
    {
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID;
    }
    else if (prog_soc_prop.pon_enable && prog_soc_prop.custom_pon_enable && tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B && 
        ((isem_prefix >> (4 - ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS) == (ARAD_PP_ISEM_ACCESS_CUS_PON_TWO_TAGS_PREFIX >> (4-ARAD_PP_ISEM_ACCESS_PON_TWO_TAGS_PREFIX_NOF_BITS))))) 
    {
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID;
    }
    else if (prog_soc_prop.pon_enable && tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B &&
             ((isem_prefix >> (3) == (ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4 >> (3)))))
    {
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4;
    }
    else
    {
      switch(isem_prefix)
      {
      case ARAD_PP_ISEM_ACCESS_BRIDGE_PREFIX:     
        {        
          /* Bridge prefix share more than one logical DB. In that case dont include prefix */
          /* Take 2 bits indication */
          res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_NOF_BITS, &two_bits_indicate);
          SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);

          switch (two_bits_indicate)
          {
          case ARAD_PP_ISEM_ACCESS_KEY_2BITS_INITIAL_VID:
            *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID;
            break;
          case ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID:
            *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID;
            break;
          case ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG:
            *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID;
            break;
          default: /* invalid indication */
            SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 100, exit); 
          }
        }
        break;
      case ARAD_PP_ISEM_ACCESS_IP_PREFIX: /* ARAD_PP_ISEM_ACCESS_OVERLAY_SIP_PREFIX or ARAD_PP_ISEM_ACCESS_PON_UNTAGGED_PREFIX if pon is enabled */       
        if (prog_soc_prop.pon_enable)
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL;
        }
        else
        {
          *isem_key_in = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP:ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP;
        }
        break;
      case ARAD_PP_ISEM_ACCESS_ISID_DOMAIN_ISID_PREFIX: /* ARAD_PP_ISEM_ACCESS_FC_PREFIX, ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX or ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX if pon is enabled */
        if (prog_soc_prop.pon_enable)
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_PON_VD_OUTER_PCP_PREFIX;  
        }
        else
        {
          *isem_key_in = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:((prog_soc_prop.trill_mode == 2 /* FGL enabled */) ? ARAD_PP_ISEM_ACCESS_TRILL_VSI_PREFIX:ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE);
        }
        break;
      case ARAD_PP_ISEM_ACCESS_TRILL_FINE_A_GRAINED_PREFIX:     
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER;
        break;
      case ARAD_PP_ISEM_ACCESS_VD_OUTER_PCP_PREFIX:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID;  
        break;          
        /* 
         * ARAD_PP_ISEM_ACCESS_MPLS_L1L3_PREFIX,
         * ARAD_PP_ISEM_ACCESS_MPLS_L3_PREFIX,
         * ARAD_PP_ISEM_ACCESS_MPLS_L2_PREFIX
         */
      case ARAD_PP_ISEM_ACCESS_MPLS_UNINDEXED_PREFIX: 
        if (prog_soc_prop.mpls_index) 
        {
          if (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L3) 
          {
            if (prog_soc_prop.mpls_1_database == tables_access_id)
            {
              /* MPLS L1 or L3 */
              *isem_key_in = (prog_soc_prop.mpls_use_in_rif) ? ((lookup_num == 0 /* VT */) ? 
                                                                ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1):
                                                               ((lookup_num == 0 /* VT */) ? 
                                                                ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3);
            }
            else
            {
              *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2;
            }
          }
          else
          {
            *isem_key_in = (prog_soc_prop.mpls_2_database == tables_access_id) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3;  
          }
        } else {
          /* Unindexed */
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS;
        }          
        break;
      case ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX: /* ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX, ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX */
        if (prog_soc_prop.mpls_index) 
        {
          *isem_key_in = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1) ? ARAD_PP_ISEM_ACCESS_MPLS_L1_PREFIX:ARAD_PP_ISEM_ACCESS_MPLS_L1L2_PREFIX;
        }
        else
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_MPLS_ELI_UNINDEXED_PREFIX;
        }        
        break;
      case ARAD_PP_ISEM_ACCESS_MPLS_L2ELI_PREFIX:       
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI;
        break;
      case ARAD_PP_ISEM_ACCESS_MPLS_L1ELI_PREFIX: /* ARAD_PP_ISEM_ACCESS_MPLS_L1L3ELI_PREFIX,  ARAD_PP_ISEM_ACCESS_MPLS_L1L2ELI_PREFIX */          
        *isem_key_in = (prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:
                       ((prog_soc_prop.mpls_1_namespace == SOC_PPC_MPLS_TERM_NAMESPACE_L1_L2 && lookup_num == 0 /* VT */) ? 
                        ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI);
        break;
      case ARAD_PP_ISEM_ACCESS_INNER_TPID_PREFIX:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID;
        break;
      case ARAD_PP_ISEM_ACCESS_RPA_ID_PREFIX:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA;
        break;
      case ARAD_PP_ISEM_ACCESS_TRILL_NICK_PREFIX: /* ARAD_PP_ISEM_ACCESS_MPLS_PWE_GAL */
        if (prog_soc_prop.pwe_gal_support) 
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL;                       
        } 
        else 
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK; 
        }
        break;
      case ARAD_PP_ISEM_ACCESS_IP_VSI_PREFIX:
        *isem_key_in = (prog_soc_prop.vxlan_enable ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE);    
        break;      
      case ARAD_PP_ISEM_ACCESS_TRILL_DESIGNATED_VID_PREFIX:
        *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID;
        break;
      case ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_DOUBLE: /* ARAD_PP_ISEM_ACCESS_FLEXIBLE_Q_IN_Q_SINGLE or TST or ARAD_PP_ISEM_ACCESS_PON_ONE_TAG_PREFIX if pon is enabled */
        if (prog_soc_prop.pon_enable)
        {
          *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID;
        }
        else if (prog_soc_prop.custom_feature_vt_tst1) {          
          *isem_key_in = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? 
              ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG;

          if (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) {
              /* DT prefix share more than one logical DB. In that case dont include prefix */
              /* Take inner bits Value 0 indication */
              res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_NOF_BITS, &two_bits_indicate);
              SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);
              if (two_bits_indicate) {
                  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, &two_bits_indicate);
                  SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);
                  *isem_key_in = (two_bits_indicate) ? ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG : ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG; 
              }              
          }
        }
        else
        {
          *isem_key_in = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? 
              ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG;
        }
        break;
      default: /* Includes ARAD_PP_ISEM_ACCESS_NULL_PREFIX: */
        SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 100, exit);
        break;
      }
    }
  }
  else
  {
    switch(isem_prefix) /* TCAM db profile ID */
    {
    case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_COUPLING_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_COUPLING;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI;
      break;
    case ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE:
      *isem_key_in = ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL;
      break;
    
    default: /* Includes ARAD_PP_ISEM_ACCESS_NULL_PREFIX, ARAD_PP_ISEM_ACCESS_MY_B_MAC_MC_PREFIX: */
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 100, exit);
    }
  }
  
  ARAD_DO_NOTHING_AND_EXIT;

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_prefix_to_key_type()", isem_prefix, tables_access_id);    
}

uint32
  arad_pp_isem_access_key_to_buffer(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                *isem_key_in,
    SOC_SAND_IN  uint32                                 table_access_id,
    SOC_SAND_IN  uint32                                 insert_index, /* Inseration iteration */
    SOC_SAND_OUT uint32                                 *buffer
  )
{
  uint32
    res = SOC_SAND_OK,
    tmp;
  uint32
    prefix;
  ARAD_PP_ISEM_ACCESS_KEY
    *isem_key, isem_key_s;
  ARAD_PP_PORT_INFO
    port_info;
  uint32
    mac_U32[SOC_SAND_PP_MAC_ADDRESS_NOF_UINT32S] = {0};

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  
  ARAD_PP_CLEAR(buffer, uint32, ARAD_PP_ISEM_ACCESS_KEY_SIZE);  

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  isem_key = &isem_key_s;

  res = arad_pp_sem_key_extend(unit,isem_key_in,insert_index,isem_key);
  SOC_SAND_CHECK_FUNC_RESULT(res, 15, exit);

  /* Retreive prefix */
  if (table_access_id != ARAD_PP_ISEM_ACCESS_ID_TCAM) {
      res = arad_pp_isem_access_key_type_to_prefix(unit,isem_key_in->key_type,table_access_id,&prefix);
      SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

      res = soc_sand_bitstream_set_any_field(&prefix, ARAD_PP_ISEM_ACCESS_LSB_PREFIX, ARAD_PP_ISEM_ACCESS_NOF_BITS_PREFIX, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
  }
  

  switch(isem_key->key_type)
  {
  /* MPLS / PWE */
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:    
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 33, exit);    

    /* Include BOS */
    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.is_bos), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);    
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF_ELI:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.in_rif, ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_LSB(prog_soc_prop.is_bos_in_key_enable) , ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_NOF_BITS(prog_soc_prop.is_bos_in_key_enable) , buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 37, exit);
    /* Inrif valid shoule be always */
    tmp = 1;
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_VALID_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 39, exit);    

    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.is_bos), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);    
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_COUPLING:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 41, exit);    

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.mpls.label2, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);    

    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_set_any_field(&(isem_key->key_info.mpls.is_bos), ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 43, exit);    

    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 44, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 46, exit);
    
    /* 2 bits indication */
    switch (isem_key->key_type)
    {
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
      tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_INITIAL_VID;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
      tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID;
      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
      tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG;
      break;
    default:
      tmp = 0;
    }
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_2BITS_INDICATION_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 49, exit);    

    /* Other special fields */
    switch (isem_key->key_type)
    {
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 441, exit);
      break;    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_pcp, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_PCP_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 447, exit);

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_dei, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_OUTER_DEI_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 447, exit);
      break;
    default:
      break;
    }    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 4444, exit);
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 4446, exit);

      tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG;
      res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_2BITS_INDICATION_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 4449, exit);    

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_pcp, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 443, exit);
      
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_dei, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 444, exit);

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 445, exit);

      break;
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:    
      /* 
       * Retreive VLAN domain
       */
      res = arad_pp_port_info_get_unsafe(unit, isem_key->key_info.l2_pon.port, &port_info);
      SOC_SAND_CHECK_FUNC_RESULT(res, 5440, exit);

      res = soc_sand_bitstream_set_any_field(&port_info.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 5445, exit);

      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.tunnel_id, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 5450, exit);
      
      /* Other special fields */
      switch (isem_key->key_type)
      {
      case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 5455, exit);
        break;    
      case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 5460, exit);

        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 5465, exit);
        break;      
      default:
        break;
      }       
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
      if (isem_key->key_info.l2_pon.port_valid) 
      {
        /* 
         * Retreive VLAN domain
         */
        res = arad_pp_port_info_get_unsafe(unit, isem_key->key_info.l2_pon.port, &port_info);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6440, exit);

        res = soc_sand_bitstream_set_any_field(&port_info.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6445, exit);
      }
      
      if (isem_key->key_info.l2_pon.tunnel_id_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.tunnel_id, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6450, exit);
      }
      
      if (isem_key->key_info.l2_pon.outer_vid_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6455, exit);      
      }
      
      if (isem_key->key_info.l2_pon.inner_vid_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6460, exit);
      }

      if (isem_key->key_info.l2_pon.outer_pcp_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_pcp, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6465, exit);
      }

      if (isem_key->key_info.l2_pon.outer_dei_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.outer_dei, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6470, exit);
      }

      if (isem_key->key_info.l2_pon.ether_type_valid) 
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_pon.ether_type, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 6475, exit);
      }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.pbb.isid_domain, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 52, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.pbb.isid, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 54, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP:       
    if (isem_key->key_info.ip_tunnel.flags & ARAD_PP_RIF_IP_TERM_FLAG_USE_DIP_DUMMY)
    {
      /* IP-LIF-Dummy, make all 33 bits as 1 */
      tmp = 0xFFFFFFFF;
      res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 56, exit);
      tmp = 0x1;
      res = soc_sand_bitstream_set_any_field(&tmp, 32, 1, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 57, exit);
    }
    else
    {
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.dip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);
    }
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP:       
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.sip, ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 59, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:       
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.dip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.sip, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 62, exit);

    if (prog_soc_prop.ipv4_term_dip_sip_enable == 2 /* IPV4 next protocol enable */) {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.ipv4_next_protocol, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 362, exit);

        soc_sand_bitstream_set_any_field(&isem_key->key_info.ip_tunnel.port_property, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 364, exit);        
    }
  break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:       
    res = soc_sand_bitstream_set_any_field(isem_key->key_info.ip_tunnel.dip6.ipv6_address.address, ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 63, exit);
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.nick_name, ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.vsi, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 74, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.port, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 76, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.native_inner_tpid, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 78, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_gre.gre_key, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);
    tmp = ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_VAL;
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_FLAGS_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 85, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_vni.vni_key, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 92, exit);    
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE:
    tmp = ARAD_PP_FRWRD_FCF_GET_DOMAIN(isem_key->key_info.fcoe.d_id);
    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 92, exit);    
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4:
    /* The function soc_sand_pp_mac_address_struct_to_long writes to indecies 0 and 1 of the second parameter only */
    /* coverity[overrun-buffer-val : FALSE] */   
    res = soc_sand_pp_mac_address_struct_to_long(
            &(isem_key->key_info.spoof_v4.smac),
            mac_U32
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 190, exit);

    tmp = 0;
    res = soc_sand_bitstream_get_any_field(mac_U32, ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_LSB, ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_NOF_BITS, &tmp);
    SOC_SAND_CHECK_FUNC_RESULT(res, 192, exit);

    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 195, exit);

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.spoof_v4.sip, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 200, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:
    /* The function soc_sand_pp_mac_address_struct_to_long writes to indecies 0 and 1 of the second parameter only */
    /* coverity[overrun-buffer-val : FALSE] */   
    res = soc_sand_pp_mac_address_struct_to_long(
            &(isem_key->key_info.spoof_v6.smac),
            mac_U32
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 290, exit);

    tmp = 0;
    res = soc_sand_bitstream_get_any_field(mac_U32, ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_SET_LSB, ARAD_PP_ISEM_ACCESS_KEY_SPOOF_SA_8MSB_NOF_BITS, &tmp);
    SOC_SAND_CHECK_FUNC_RESULT(res, 292, exit);

    res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 295, exit);

    res = soc_sand_bitstream_set_any_field(isem_key->key_info.spoof_v6.sip6.ipv6_address.address, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 210, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    if ((isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_TTS) == 0) {
      tmp = 0;
      res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_ZEROS_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit); 
  
      /* 2 bits indication */
      if (isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_VL) {
          /* VL */
          tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID;
      } else {
          /* FGL ARAD_PP_ISEM_ACCESS_TRILL_VSI_FGL */
          tmp = ARAD_PP_ISEM_ACCESS_KEY_2BITS_DOUBLE_TAG;
      }
  
      res = soc_sand_bitstream_set_any_field(&tmp, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 510, exit); 
      
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.high_vid, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 520, exit); 
  
      if (isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_FGL)  
      {
        res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.low_vid, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_NOF_BITS, buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 530, exit); 
      }
    } else {
      res = soc_sand_bitstream_set_any_field(&isem_key->key_info.trill.high_vid, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_NOF_BITS, buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 520, exit); 
    }      

    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA:       
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.rpa.dip, ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 610, exit);

    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.rpa.vrf, ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_LSB, ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 620, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 740, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 750, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.vlan_domain,ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);                                                                                                                
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.outer_vid, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 740, exit);                                                                                                                
    res = soc_sand_bitstream_set_any_field(&isem_key->key_info.l2_eth.inner_vid, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_NOF_BITS, buffer);
    SOC_SAND_CHECK_FUNC_RESULT(res, 750, exit);
    break;  
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 100, exit);
    break;
  }

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_key_to_buffer()", 0, 0);
}

STATIC uint32
  arad_pp_isem_access_entry_to_buffer(
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_ENTRY                   *isem_entry,
    SOC_SAND_OUT uint32                                  *buffer
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);
  
  ARAD_PP_CLEAR(buffer, uint32, SOC_DPP_DEFS_MAX(ISEM_PAYLOAD_NOF_UINT32));

  res = soc_sand_bitstream_set_any_field(&isem_entry->sem_result_ndx, ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_LSB, ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_NOF_BITS, buffer);
  SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_to_buffer()", 0, 0);
}

uint32
  arad_pp_isem_access_entry_from_buffer(
    SOC_SAND_IN  uint32                                  *buffer,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_ENTRY                   *isem_entry
  )
{
  uint32
    res = SOC_SAND_OK;

  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);
  
  ARAD_PP_CLEAR(isem_entry, ARAD_PP_ISEM_ACCESS_ENTRY, 1);

  res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_LSB, ARAD_PP_ISEM_ACCESS_ENTRY_ISEM_ACCESS_RESULT_NDX_NOF_BITS, &isem_entry->sem_result_ndx);
  SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_from_buffer()", 0, 0);
}

STATIC
  uint32
    arad_pp_isem_access_tcam_db_id_get(
      SOC_SAND_IN ARAD_PP_ISEM_ACCESS_KEY *isem_key
    )
{
  uint32
    tcam_db_id;

  switch (isem_key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR: 
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_MPLS_FRR_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_COUPLING: 
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_MPLS_COUPLING_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_ETH_INNER_OUTER_PCP_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_IPV6_SPOOF_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_IPV4_TT_ETH_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_IPV6_TT_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_PON_EXTEND_LKP_DB_PROFILE;
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_TT_TRILL_TRANSPARENT_SERVICE;
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
    tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_MPLS_EXPLICIT_NULL_VT_DB_PROFILE;
    break;
  default:
    tcam_db_id = ARAD_TCAM_MAX_NOF_LISTS;
    break;
  }

  return tcam_db_id;
}


STATIC
uint32
  arad_pp_isem_access_tcam_isem_key_to_stream(
      SOC_SAND_IN  int                 unit,
      SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY  *key,
      SOC_SAND_OUT uint8                  stream[ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES]
  )
{
  uint32
    long_stream[5];  
  uint32
    res;
  

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);


  res = SOC_SAND_OK; sal_memset(
          long_stream,
          0x0,
          sizeof(uint32) * 5
        );
  SOC_SAND_CHECK_FUNC_RESULT(res,  20, exit);

  switch(key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR: 
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_COUPLING:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:   
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
      res = arad_pp_isem_access_key_to_buffer(unit, key, ARAD_PP_ISEM_ACCESS_ID_TCAM, 0, long_stream); /* Same as other VTT */
      SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);     
      break;
  default:
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 80, exit);      
      break;
  }

  res = soc_sand_U32_to_U8(
          long_stream,
          ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES,
          stream
        );
  SOC_SAND_CHECK_FUNC_RESULT(res,  100, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR( "error in arad_pp_isem_access_tcam_isem_key_to_stream()",0,0);
}

STATIC
  uint32
    arad_pp_isem_access_tcam_entry_mask_build(
      SOC_SAND_IN  int                    unit,
      SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY   *isem_key,
      SOC_SAND_OUT ARAD_TCAM_ENTRY           *entry
  )
{
  uint32
    res;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  switch(isem_key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:
    /* set DIP mask*/
    soc_sand_bitstream_set_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB + isem_key->key_info.ip_tunnel.dip_prefix_len-1); 
    /* set SIP mask*/
    soc_sand_bitstream_set_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB+isem_key->key_info.ip_tunnel.sip_prefix_len-1); 
    /* set Next protocol mask */
    if (prog_soc_prop.ipv4_term_dip_sip_enable == 2)
    {
      soc_sand_bitstream_set_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB, 
                                       ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB+isem_key->key_info.ip_tunnel.ipv4_next_protocol_prefix_len-1); 
      if (isem_key->key_info.ip_tunnel.port_property_en) 
      {
        soc_sand_bitstream_set_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB, 
                                         ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB+ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS-1); 
      }
      
    }
  break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 127); /* Mask all , take into account all entry */     
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 135); /* Mask all , take into account all entry */     
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:
    /* UnMask DEI bit */
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* Mask all , except DEI, take into account all entry */     
    soc_sand_bitstream_reset_bit(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_DEI_LSB); /* Mask all , except DEI, take into account all entry */     
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_COUPLING:    
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* Mask all , except VID, MSBs MPLS 2 take into account all entry */     
    /* UnMask VID LSBs [0:11] */
    soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_END); /* except VID */         
    soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_EXP_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_EXP_MASK_BIT_END); /* except MPLS EXP */         
    soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_TTL_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_TTL_MASK_BIT_END); /* except MPLS TTL */             

    if (!prog_soc_prop.is_bos_in_key_enable) {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_MASK_BIT_END); /* except MPLS BOS */         
    }    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* start by Mask all  */     
    /* On each invalid Unmask related field */
    if (!isem_key->key_info.l2_pon.port_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_MSB); /* No Vlan-domain */         
    }
    if (!isem_key->key_info.l2_pon.inner_vid_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_MSB); /* No inner-vlan */         
    }
    if (!isem_key->key_info.l2_pon.outer_vid_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_MSB); /* No outer-vid */         
    }
    if (!isem_key->key_info.l2_pon.outer_dei_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_MSB); /* No outer-dei */         
    }
    if (!isem_key->key_info.l2_pon.outer_pcp_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_MSB); /* No outer-pcp */         
    }
    if (!isem_key->key_info.l2_pon.tunnel_id_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_MSB); /* No tunnel-id */         
    }
    if (!isem_key->key_info.l2_pon.ether_type_valid) 
    {
      soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_MSB); /* No ethertype */         
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* start by Mask all  */  
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
    soc_sand_bitstream_set_bit_range(entry->mask, 0, 119); /* Mask all  */  
    soc_sand_bitstream_reset_bit_range(entry->mask, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_START, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_VID_MASK_BIT_END); /* except VID */         
    break;
  default:
      SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 80, exit);      
      break;
  }  

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_entry_mask_build()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_tcam_isem_entry_from_action(
      SOC_SAND_IN  ARAD_TCAM_ACTION           *action,
      SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_ENTRY  *entry
  )
{
  uint32
    res;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);

  res = SOC_SAND_OK; sal_memset(
          entry,
          0x0,
          sizeof(ARAD_PP_ISEM_ACCESS_ENTRY)
        );
  SOC_SAND_CHECK_FUNC_RESULT(res,  20, exit);

  entry->sem_result_ndx = action->value[0];

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR( "error in arad_pp_isem_access_tcam_isem_entry_from_action()",0,0);
}

STATIC
uint32
  arad_pp_isem_access_tcam_entry_get_unsafe(
    SOC_SAND_IN  int               unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY *isem_key,
    SOC_SAND_IN  uint8               exact_match,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_ENTRY *isem_entry,
    SOC_SAND_OUT uint8               *found
  )
{
  uint32
    res = SOC_SAND_OK,
    data_indx;
  uint8
      hit_bit,            
    stream[ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES];
  uint32
    entry_id;
  SOC_SAND_HASH_TABLE_INFO
    *hash_tbl;
  uint32
    tcam_db_id;
  uint32
    priority;
  ARAD_TCAM_ENTRY
    entry;
  ARAD_TCAM_ACTION
    action;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  SOC_SAND_CHECK_DRIVER_AND_DEVICE;

  ARAD_TCAM_ENTRY_clear(&entry);
  ARAD_TCAM_ACTION_clear(&action);
  /*
   *  Determine the database ID
   */
  tcam_db_id = arad_pp_isem_access_tcam_db_id_get(
                 isem_key
               );

  if (exact_match)
  {
    /*
     *  Search for the route_key in the route_key -> entry_id hash table
     */
    hash_tbl = arad_sw_db_vtt_isem_key_to_entry_id_get(
                 unit
               );
    res = arad_pp_isem_access_tcam_isem_key_to_stream(
                 unit,
                 isem_key,
                 stream
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
    res = soc_sand_hash_table_entry_lookup(
            hash_tbl,
            stream,
            &data_indx,
            found
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);
    entry_id = data_indx;
  }
  else
  {
    /*
     *  Search the TCAM for the first match
     */
    res = arad_pp_isem_access_tcam_isem_key_to_stream(
                 unit,
                 isem_key,
                 stream
               );
    SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);

    /* Set the valid bit */
    entry.valid = TRUE;

    /*
     * COVERITY
     *
     * Static array "entry.value" is not overrun
     */
    /* coverity[overrun-buffer-arg : FALSE] */
    res = soc_sand_U8_to_U32(
          stream,
          ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES,
          entry.value
        );
    SOC_SAND_CHECK_FUNC_RESULT(res,  15, exit);

    res = arad_pp_isem_access_tcam_entry_mask_build(
      unit,
      isem_key,
      &entry
    );
    SOC_SAND_CHECK_FUNC_RESULT(res,  20, exit);

    res = arad_tcam_db_entry_search_unsafe(
            unit,
            tcam_db_id,
            &entry,
            &entry_id,
            found
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }

  if (*found)
  {
    res = arad_tcam_db_entry_get_unsafe(
            unit,
            tcam_db_id,
            entry_id,
            TRUE, /* hit_bit_clear */
            &priority,
            &entry,
            &action,
            found,
            &hit_bit
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

    res = arad_pp_isem_access_tcam_isem_entry_from_action(
            &action,
            isem_entry
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_entry_get_unsafe()", 0, 0);
}

uint32
  arad_pp_isem_access_entry_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                   *isem_key,
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_ENTRY                 *isem_entry,
    SOC_SAND_OUT uint8                                 *success
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    key_buffer[ARAD_PP_ISEM_ACCESS_KEY_SIZE];
  uint32
    entry_buffer[SOC_DPP_DEFS_MAX(ISEM_PAYLOAD_NOF_UINT32)];
  
#ifdef PLISIM
    uint32 access_addr;
#else 
    uint32  block_port_id, temp; 
    soc_field_t
      tmp_fld_name;
    uint64 
      key_buffer_64b;
    soc_reg_t
      tmp_reg_name;
      
#endif
   uint32
    nof_tables,
    tbl_access_id,
    tbl_access_idx,
    tables_access_ids[ARAD_PP_ISEM_ACCESS_NOF_TABLES];
  uint8
    found;
  uint8
    is_duplicate_entry;
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(isem_key);
  SOC_SAND_CHECK_NULL_INPUT(isem_entry);
  SOC_SAND_CHECK_NULL_INPUT(success);

  ARAD_CLEAR(isem_entry, uint32, SOC_DPP_DEFS_GET(unit, isem_payload_nof_uint32));

  res = arad_pp_isem_access_sem_tables_get(unit, isem_key, &nof_tables, tables_access_ids,&is_duplicate_entry);
  SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);

  *success = FALSE;
  /* Run over all tables that the entry might be there */
  for (tbl_access_idx = 0; tbl_access_idx < nof_tables; tbl_access_idx++)
  {
    if (tbl_access_idx > 0 && *success == TRUE)
    {
      /* Entry already found, no need to check more tables */
      break;
    }
    tbl_access_id = tables_access_ids[tbl_access_idx];    
    if (tbl_access_id != ARAD_PP_ISEM_ACCESS_ID_TCAM) {
        
        res = arad_pp_isem_access_key_to_buffer(unit, isem_key, tbl_access_id, tbl_access_idx, key_buffer);        
        SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);
#ifndef PLISIM
          COMPILER_64_SET(key_buffer_64b, key_buffer[1], key_buffer[0]);
          if (SOC_IS_JERICHO(unit)) {
              block_port_id = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? 0 : 1 ;
              tmp_reg_name = IHB_ISEM_DIAGNOSTICS_KEYr;
          } else {
              block_port_id = REG_PORT_ANY;
              tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? IHP_ISA_DIAGNOSTICS_KEYr: IHP_ISB_DIAGNOSTICS_KEYr;
          }
          SOC_SAND_SOC_IF_ERROR_RETURN(res, 1120, exit, soc_reg_set(unit, tmp_reg_name, block_port_id, 0, key_buffer_64b));


          if (SOC_IS_JERICHO(unit)) {
              tmp_reg_name = IHB_ISEM_DIAGNOSTICSr;
              tmp_fld_name = ISEM_DIAGNOSTICS_LOOKUPf;
          } else {
              tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                  IHP_ISA_DIAGNOSTICSr:IHP_ISB_DIAGNOSTICSr;
              tmp_fld_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                  ISA_DIAGNOSTICS_LOOKUPf:ISB_DIAGNOSTICS_LOOKUPf;
          }
          
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name,  0x1));
          
          res = arad_polling(
                  unit,
                  ARAD_TIMEOUT,
                  ARAD_MIN_POLLS,
                  tmp_reg_name,
                  block_port_id,
                  0,
                  tmp_fld_name,
                  0
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
          
          temp = 0;
          
          if (SOC_IS_JERICHO(unit)) {
              tmp_reg_name = IHB_ISEM_DIAGNOSTICS_LOOKUP_RESULTr;
              tmp_fld_name = ISEM_ENTRY_FOUNDf;
          } else {
              tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                  IHP_ISA_DIAGNOSTICS_LOOKUP_RESULTr:IHP_ISB_DIAGNOSTICS_LOOKUP_RESULTr;
              tmp_fld_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                  ISA_ENTRY_FOUNDf:ISB_ENTRY_FOUNDf;
          }
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name, &temp));
          *success = SOC_SAND_NUM2BOOL(temp);
          
          if (SOC_IS_JERICHO(unit)) {
              tmp_reg_name = IHB_ISEM_DIAGNOSTICS_LOOKUP_RESULTr;
              tmp_fld_name = ISEM_ENTRY_PAYLOADf;
          } else {
              tmp_reg_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                  IHP_ISA_DIAGNOSTICS_LOOKUP_RESULTr:IHP_ISB_DIAGNOSTICS_LOOKUP_RESULTr;
              tmp_fld_name = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                  ISA_ENTRY_PAYLOADf:ISB_ENTRY_PAYLOADf;
          }
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name, &entry_buffer[0]));
#else /* PLISIM*/
          access_addr = (tbl_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
            ARAD_CHIP_SIM_ISEM_A_BASE:ARAD_CHIP_SIM_ISEM_B_BASE;
          res = chip_sim_exact_match_entry_get_unsafe(
                  unit,
                  access_addr,
                  key_buffer,
                  ARAD_PP_ISEM_ACCESS_KEY_SIZE * sizeof(uint32),
                  entry_buffer,
                  SOC_DPP_DEFS_GET(unit, isem_payload_nof_uint32),
                  success
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);
#endif
      
      res = arad_pp_isem_access_entry_from_buffer(entry_buffer, isem_entry);
      SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);
    }
    else
    {
      /* TCAM */
      res = arad_pp_isem_access_tcam_entry_get_unsafe(unit,isem_key,TRUE,isem_entry,&found);
      SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);
      *success = SOC_SAND_NUM2BOOL(found);
    }
  }
  
  

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_get_unsafe()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_isem_entry_add_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 *key_buffer,
    SOC_SAND_IN  uint32                                 *entry_buffer,
    SOC_SAND_IN  uint32                                 tables_access_id,
    SOC_SAND_OUT SOC_SAND_SUCCESS_FAILURE               *success
  )
{
  uint32
    res;
  uint32
    buffer[ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE];
  uint32
    temp,  
    reason;
#ifdef PLISIM
  uint32 access_addr;
#else
  uint32
    is_failed,
      block_port_id,
      block_id;
      
  soc_mem_t
    tmp_mem_name;
  soc_reg_t
    tmp_reg_name;
  soc_field_t
    tmp_fld_name;
#endif
  uint8 is_success = TRUE;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_PP_CLEAR(buffer, uint32, ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE);

  temp = ARAD_PP_ISEM_ACCESS_ACTION_TYPE_INSERT;
  reason = 0;
  res = SOC_SAND_OK;

  res = soc_sand_bitstream_set_any_field(
          &temp,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB + 1,
          buffer
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);

  res = soc_sand_bitstream_set_any_field(
          key_buffer,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB + 1,
          buffer
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 27, exit);

  res = soc_sand_bitstream_set_any_field(
          entry_buffer,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_LSB,
          ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_PAYLOAD_LSB + 1,
          buffer
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
#ifndef PLISIM
      if (SOC_IS_JERICHO(unit)) {
          block_port_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? 0 : 1 ;
      } else {
          block_port_id = REG_PORT_ANY;
      }
#ifdef ARAD_FAST_REGISTERS_AND_FIELDS_ACCESS 
      {
          int tmp_fld_id, tmp_reg_id;
          soc_reg_above_64_val_t data, fld_value;      
          tmp_reg_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
              ARAD_FAST_REG_IHP_ISA_INTERRUPT_REGISTER:ARAD_FAST_REG_IHP_ISB_INTERRUPT_REGISTER;
          tmp_fld_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
              ARAD_FAST_FIELD_IHP_ISA_INTERRUPT_REGISTER_ONE_ISA_MANAGEMENT_COMPLETED:ARAD_FAST_FIELD_IHP_ISB_INTERRUPT_REGISTER_ONE_ISB_MANAGEMENT_COMPLETED;
          SOC_REG_ABOVE_64_CLEAR(fld_value);
          ARAD_FAST_REGISER_GET(tmp_reg_id, data);
          ARAD_FAST_FIELD_GET(tmp_fld_id, data, fld_value);
          temp = fld_value[0];
      }
#else
      if (SOC_IS_JERICHO(unit)) {
          tmp_reg_name = IHB_ISEM_INTERRUPT_REGISTER_ONEr;
          tmp_fld_name = ISEM_MANAGEMENT_COMPLETEDf;        
      } else {
          tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
              IHP_ISA_INTERRUPT_REGISTER_ONEr:IHP_ISB_INTERRUPT_REGISTER_ONEr;
          tmp_fld_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
              ISA_MANAGEMENT_COMPLETEDf:ISB_MANAGEMENT_COMPLETEDf;        
      }
      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  110,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name, &temp));
#endif
      if (temp)
      {
        SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_NOT_READY_ERR, 120, exit);
      }

      tmp_mem_name = SOC_IS_JERICHO(unit)? IHB_ISEM_MANAGEMENT_REQUESTm: 
          ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? IHP_ISA_MANAGEMENT_REQUESTm: IHP_ISB_MANAGEMENT_REQUESTm);
      block_id = SOC_IS_JERICHO(unit)? IHB_BLOCK(unit, block_port_id) : MEM_BLOCK_ALL;
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 1230, exit, soc_mem_write(unit, tmp_mem_name, block_id, 0, buffer));
      
      if (SOC_IS_JERICHO(unit)) {
          tmp_reg_name = IHB_ISEM_INTERRUPT_REGISTER_ONEr;
          tmp_fld_name = ISEM_MANAGEMENT_COMPLETEDf;        
      } else {
          tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
              IHP_ISA_INTERRUPT_REGISTER_ONEr:IHP_ISB_INTERRUPT_REGISTER_ONEr;
          tmp_fld_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                ISA_MANAGEMENT_COMPLETEDf:ISB_MANAGEMENT_COMPLETEDf;        
      }

      res = arad_polling(
              unit,
              ARAD_TIMEOUT,
              ARAD_MIN_POLLS,
              tmp_reg_name,
              block_port_id,
              0,
              tmp_fld_name,
              1
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

      /* clear management_completed by writing 1*/
temp = 1;
#ifdef ARAD_FAST_REGISTERS_AND_FIELDS_ACCESS 
    {
        soc_reg_above_64_val_t data, fld_value;
        int tmp_reg_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_FAST_REG_IHP_ISA_INTERRUPT_REGISTER:ARAD_FAST_REG_IHP_ISB_INTERRUPT_REGISTER;
        int tmp_fld_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? ARAD_FAST_FIELD_IHP_ISA_INTERRUPT_REGISTER_ONE_ISA_MANAGEMENT_COMPLETED:ARAD_FAST_FIELD_IHP_ISB_INTERRUPT_REGISTER_ONE_ISB_MANAGEMENT_COMPLETED;        
        ARAD_FAST_REGISER_GET(tmp_reg_id, data);
        fld_value[0] = temp;
        ARAD_FAST_FIELD_SET(tmp_fld_id, data, fld_value);
        ARAD_FAST_REGISER_SET(tmp_reg_id, data);

        tmp_reg_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
          ARAD_FAST_REG_IHP_ISA_MANAGEMENT_UNIT_FAILURE:ARAD_FAST_REG_IHP_ISB_MANAGEMENT_UNIT_FAILURE;              
        ARAD_FAST_REGISER_GET(tmp_reg_id, data);            
        
        *success = SOC_SAND_SUCCESS;

        tmp_fld_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
          ARAD_FAST_FIELD_IHP_ISA_MANAGEMENT_UNIT_FAILURE_ISA_MNGMNT_UNIT_FAILURE_VALID:ARAD_FAST_FIELD_IHP_ISB_MANAGEMENT_UNIT_FAILURE_ISB_MNGMNT_UNIT_FAILURE_VALID;  
        ARAD_FAST_FIELD_GET(tmp_fld_id, data, fld_value);
        is_failed = fld_value[0];

        if (is_failed)
        {
            tmp_fld_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
            ARAD_FAST_FIELD_IHP_ISA_MANAGEMENT_UNIT_FAILURE_ISA_MNGMNT_UNIT_FAILURE_REASON:ARAD_FAST_FIELD_IHP_ISB_MANAGEMENT_UNIT_FAILURE_ISB_MNGMNT_UNIT_FAILURE_REASON; 
            SOC_REG_ABOVE_64_CLEAR(fld_value);
            ARAD_FAST_FIELD_GET(tmp_fld_id, data, fld_value);
            reason = fld_value[0];
        }
    }

#else 
 {
     uint64 failure;

      SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  150,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name,  temp));

      tmp_reg_name = SOC_IS_JERICHO(unit)? IHB_ISEM_MANAGEMENT_UNIT_FAILUREr: 
          ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? IHP_ISA_MANAGEMENT_UNIT_FAILUREr: IHP_ISB_MANAGEMENT_UNIT_FAILUREr);
      SOC_SAND_SOC_IF_ERROR_RETURN(res, 1240, exit, soc_reg_get(unit, tmp_reg_name, block_port_id, 0, &failure));

      *success = SOC_SAND_SUCCESS;

      tmp_fld_name = SOC_IS_JERICHO(unit)? ISEM_MNGMNT_UNIT_FAILURE_VALIDf: 
          ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? ISA_MNGMNT_UNIT_FAILURE_VALIDf: ISB_MNGMNT_UNIT_FAILURE_VALIDf);
      is_failed = soc_reg64_field32_get(unit, tmp_reg_name, failure, tmp_fld_name);
      if (is_failed)
      {
          tmp_fld_name = SOC_IS_JERICHO(unit)? ISEM_MNGMNT_UNIT_FAILURE_REASONf: 
              ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? ISA_MNGMNT_UNIT_FAILURE_REASONf: ISB_MNGMNT_UNIT_FAILURE_REASONf);

        reason = soc_reg64_field32_get(unit, tmp_reg_name, failure, tmp_fld_name);
      }
 }
#endif 
      if (is_failed)
      {        
        switch(reason)
        {
        case 0x001:/*Notice: Cam table full*/
        case 0x002:/*Notice: Table coherency             */
        case 0x008:/*Notice: Reached max entry limit     */
        case 0x080:/*Notice: Change-fail non exist       */
        case 0x100:/*Notice: Change request over static  */
        case 0x200:/*Notice: Change non-exist from other */
        case 0x400:/*Notice: Change non-exist from self  */
          *success = SOC_SAND_FAILURE_OUT_OF_RESOURCES_2;
        break;
        default:
        break;
        }
      }
  #if ARAD_PP_ISEM_ACCESS_DEBUG
      if (reason)
      {
        switch(reason)
        {
        case 0x001:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Cam table full              ")));
          break;
        case 0x002:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Table coherency             ")));
          break;
        case 0x004:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Delete unknown key          ")));
          break;
        case 0x008:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Reached max entry limit     ")));
          break;
        case 0x010:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Inserted existing           ")));
          break;
        case 0x020:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Learn request over static   ")));
          break;
        case 0x040:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Learn over existing         ")));
          break;
        case 0x080:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Change-fail non exist       ")));
          break;
        case 0x100:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Change request over static  ")));
          break;
        case 0x200:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Change non-exist from other ")));
          break;
        case 0x400:
          LOG_INFO(BSL_LS_SOC_LIF,
                   (BSL_META_U(unit,
                               "Notice: Change non-exist from self  ")));
          break;
        }
      }
  #endif
#else   /* PLISIM */
      access_addr = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
          ARAD_CHIP_SIM_ISEM_A_BASE:ARAD_CHIP_SIM_ISEM_B_BASE;
      res = chip_sim_exact_match_entry_add_unsafe(
              unit,
              access_addr,
              key_buffer,
              ARAD_PP_ISEM_ACCESS_KEY_SIZE * sizeof(uint32),
              entry_buffer,
              SOC_DPP_DEFS_GET(unit, isem_payload_nof_uint32) * sizeof(uint32),
              &is_success
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);
#endif
      *success = is_success ? SOC_SAND_SUCCESS : SOC_SAND_FAILURE_OUT_OF_RESOURCES;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_isem_entry_add_unsafe()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_tcam_isem_entry_to_action(
      SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_ENTRY  *entry,
      SOC_SAND_OUT ARAD_TCAM_ACTION           *action
  )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS_NO_DEVID(0);

  ARAD_TCAM_ACTION_clear(action);

  action->value[0] = entry->sem_result_ndx;

  ARAD_DO_NOTHING_AND_EXIT;

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR( "error in arad_pp_isem_access_tcam_isem_entry_to_action()",0,0);
}

/* Currently no use for priority as it is always exact match */
STATIC uint32
  arad_pp_isem_access_tcam_to_prio(
    SOC_SAND_IN  int                                      unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                     *isem_key
  )
{
  uint32
    prio = SOC_SAND_U32_MAX;

  if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID) /* Special case of PON extend TCAM */
  {
    /* VD */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_VD_PRIO * isem_key->key_info.l2_pon.port_valid);
    
    /* Tunnel */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_TUNNEL_ID_PRIO * isem_key->key_info.l2_pon.tunnel_id_valid);

    /* Inner-VID */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_INNER_VID_PRIO * isem_key->key_info.l2_pon.inner_vid_valid);

    /* Outer-VID */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_OUTER_VID_PRIO * isem_key->key_info.l2_pon.outer_vid_valid);

    /* Outer-DEI */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_OUTER_DEI_PRIO * isem_key->key_info.l2_pon.outer_dei_valid);

    /* Outer-PCP */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_OUTER_PCP_PRIO * isem_key->key_info.l2_pon.outer_pcp_valid);

    /* Ethertype */
    prio = prio - ((uint16)ARAD_PP_ISEM_ACCESS_PON_ETHERTYPE_PRIO * isem_key->key_info.l2_pon.ether_type_valid);
  }
  else if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP) {
      prio -= isem_key->key_info.ip_tunnel.sip_prefix_len;
      prio -= isem_key->key_info.ip_tunnel.dip_prefix_len;
      prio -= isem_key->key_info.ip_tunnel.ipv4_next_protocol_prefix_len;
      prio -= isem_key->key_info.ip_tunnel.port_property_en;
  }
  else
  {
    prio = 0; /* always 0 , all other TCAM inserations are exact match */
  }
   
  return prio;
}

STATIC
uint32
  arad_pp_isem_access_tcam_entry_add_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                *isem_key,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_ENTRY              *isem_entry,
    SOC_SAND_OUT SOC_SAND_SUCCESS_FAILURE               *success
  )
{
  uint32
    res = SOC_SAND_OK,
    data_indx;
  uint32
    priority;
  uint8
    stream[ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES];
  SOC_SAND_HASH_TABLE_INFO
    *hash_tbl;
  uint8
    found,
    entry_added;
  uint32
    tcam_db_id;
  ARAD_TCAM_ENTRY
    entry;
  ARAD_TCAM_ACTION
    action;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  /* TCAM */
  ARAD_TCAM_ENTRY_clear(&entry);
  ARAD_TCAM_ACTION_clear(&action);

  /*
   *  Search for the vtt_key -> entry_id hash table
   */
  hash_tbl = arad_sw_db_vtt_isem_key_to_entry_id_get(
               unit
             );

  res = arad_pp_isem_access_tcam_isem_key_to_stream(
               unit,
               isem_key,
               stream
             );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);

  res = arad_pp_isem_access_tcam_isem_entry_to_action(
               isem_entry,
               &action
             );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);


  res = soc_sand_hash_table_entry_lookup(
          hash_tbl,
          stream,
          &data_indx,
          &found
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  if (!found)
  {
    /*
     *  Insert the rule to the route_key -> entry_id table
     */
    res = soc_sand_hash_table_entry_add(
            hash_tbl,
            stream,
            &data_indx,
            &entry_added
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }
  else
  {
    entry_added = TRUE;
  }

  if (entry_added)
  {
    /*
     *  Remove the old entry, if applicable
     */
    tcam_db_id = arad_pp_isem_access_tcam_db_id_get(
                   isem_key
                 );
    res = arad_tcam_db_entry_remove_unsafe(
            unit,
            FALSE /* is_bank_freed_if_no_entry */,
            tcam_db_id,
            data_indx
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 35, exit);

    /*
     *  Insert the new rule to the TCAM
     */
    priority = arad_pp_isem_access_tcam_to_prio(
                 unit,
                 isem_key
               );

    /* Set the valid bit */
    entry.valid = TRUE;

/*
 * COVERITY
 *
 * Static array "entry.value" is not overrun
 */
/* coverity[overrun-buffer-arg] */
    res = soc_sand_U8_to_U32(
          stream,
          ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES,
          entry.value
        );
    SOC_SAND_CHECK_FUNC_RESULT(res,  100, exit);

    res = arad_pp_isem_access_tcam_entry_mask_build(
      unit,
      isem_key,      
      &entry
    );
    SOC_SAND_CHECK_FUNC_RESULT(res,  200, exit);

    res = arad_tcam_managed_db_entry_add_unsafe(
            unit,
            tcam_db_id,
            data_indx,
            priority,
            &entry,
            &action,
            success
          );
    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

    if ((*success != SOC_SAND_SUCCESS) && (!found))
    {
      res = soc_sand_hash_table_entry_remove_by_index(
              hash_tbl,
              data_indx
            );
      SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);
    }
  }
  else
  {
    *success = SOC_SAND_FAILURE_OUT_OF_RESOURCES;
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_entry_add_unsafe()", 0, 0);
}

uint32
  arad_pp_isem_access_entry_add_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                     *isem_key,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_ENTRY                   *isem_entry,
    SOC_SAND_OUT SOC_SAND_SUCCESS_FAILURE                      *success
  )
{
  uint32
    res = SOC_SAND_OK;  
  uint32
    key_buffer[ARAD_PP_ISEM_ACCESS_KEY_SIZE];
  uint32     
    nof_tables,   
    tbl_access_idx,
    tables_access_id,
    tables_access_ids[ARAD_PP_ISEM_ACCESS_NOF_TABLES],
    entry_buffer[SOC_DPP_DEFS_MAX(ISEM_PAYLOAD_NOF_UINT32)];  
  uint8
    is_duplicate_entry;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(isem_key);
  SOC_SAND_CHECK_NULL_INPUT(isem_entry);
  SOC_SAND_CHECK_NULL_INPUT(success);

  res = arad_pp_isem_access_sem_tables_get(unit, isem_key, &nof_tables, tables_access_ids,&is_duplicate_entry);
  SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);

  *success = SOC_SAND_FAILURE_OUT_OF_RESOURCES;

  /* Run over all tables that the entry should be insert */
  for (tbl_access_idx = 0; tbl_access_idx < nof_tables; tbl_access_idx++)
  {
    /* If insertion is on arbitrary table, exit on success after first iteration*/
    if (!is_duplicate_entry && tbl_access_idx > 0 && *success == SOC_SAND_SUCCESS)
    {
      break;
    }
    tables_access_id = tables_access_ids[tbl_access_idx];
    if (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A ||
        tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B)
    {
      /* add ISEM entry */
      res = arad_pp_isem_access_key_to_buffer(unit, isem_key, tables_access_id, tbl_access_idx, key_buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);

      res = arad_pp_isem_access_entry_to_buffer(isem_entry, entry_buffer);
      SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);

      res = arad_pp_isem_access_isem_entry_add_unsafe(unit,key_buffer,entry_buffer,tables_access_id,success);
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
    }
    else
    {
      /* add TCAM entry */
      res = arad_pp_isem_access_tcam_entry_add_unsafe(unit,isem_key,isem_entry,success);
      SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
    }
  }
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_add_unsafe()", 0, 0);
}

STATIC
uint32
  arad_pp_isem_access_tcam_remove_unsafe(
    SOC_SAND_IN  int                                     unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                       *isem_key
  )
{
  uint32
    res = SOC_SAND_OK,
    data_indx;
  uint8
    found;
  uint8
	  stream[ARAD_PP_ISEM_ACCESS_TCAM_KEY_LEN_BYTES];
  SOC_SAND_HASH_TABLE_INFO
    *hash_tbl;
  uint32
    tcam_db_id;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  SOC_SAND_CHECK_DRIVER_AND_DEVICE;

  /*
   *  Search for the route_key in the route_key -> entry_id hash table
   */
  hash_tbl = arad_sw_db_vtt_isem_key_to_entry_id_get(
               unit
             );
  res = arad_pp_isem_access_tcam_isem_key_to_stream(
               unit,
	        isem_key,
	        stream
	      );
  SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  res = soc_sand_hash_table_entry_lookup(
          hash_tbl,
          stream,
          &data_indx,
          &found
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  if (!found)
  {
    /* Nothing to do */
    SOC_SAND_SET_ERROR_CODE(SOC_PPD_ERR_NOT_EXIST, 30, exit);
  }

  res = soc_sand_hash_table_entry_remove_by_index(
          hash_tbl,
          data_indx
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

  /*
   *  Determine the database ID
   */
  tcam_db_id = arad_pp_isem_access_tcam_db_id_get(
                 isem_key
               );

  res = arad_tcam_managed_db_entry_remove_unsafe(
          unit,
          tcam_db_id,
          data_indx
        );
  SOC_SAND_CHECK_FUNC_RESULT(res, 50, exit);

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_tcam_remove_unsafe()", 0, 0);
}


uint32
  arad_pp_isem_access_entry_remove_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  ARAD_PP_ISEM_ACCESS_KEY                   *isem_key    
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    temp;
#ifdef PLISIM
    uint32 access_addr;
#else
    uint32 block_id;
  soc_mem_t
      tmp_mem_name;
#endif
uint32
    nof_tables,
      block_port_id,
    tbl_access_idx,
    tables_access_id,
    tables_access_ids[ARAD_PP_ISEM_ACCESS_NOF_TABLES],
    buffer[ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE];

  uint8
    is_duplicate_entry;
  soc_reg_t
    tmp_reg_name;
  soc_field_t
    tmp_fld_name;
  uint32
    key_buffer[ARAD_PP_ISEM_ACCESS_KEY_SIZE];
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  SOC_SAND_CHECK_NULL_INPUT(isem_key);

  res = arad_pp_isem_access_sem_tables_get(unit, isem_key, &nof_tables, tables_access_ids,&is_duplicate_entry);
  SOC_SAND_CHECK_FUNC_RESULT(res, 19, exit);
    
  /* Run over all tables that the entry might appear */
  for (tbl_access_idx = 0; tbl_access_idx < nof_tables; tbl_access_idx++)
  {
    tables_access_id = tables_access_ids[tbl_access_idx];

    if (tables_access_id != ARAD_PP_ISEM_ACCESS_ID_TCAM) 
    {
        res = arad_pp_isem_access_key_to_buffer(unit, isem_key, tables_access_id, tbl_access_idx, key_buffer);
        SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);
        
        ARAD_PP_CLEAR(buffer, uint32, ARAD_PP_ISEM_ACCESS_ENTRY_REQ_SIZE);

        temp = ARAD_PP_ISEM_ACCESS_ACTION_TYPE_DELETE;
        res = soc_sand_bitstream_set_any_field(
                &temp,
                ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB,
                ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_TYPE_LSB + 1,
                buffer
              );
        SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);

        res = soc_sand_bitstream_set_any_field(
                key_buffer,
                ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB,
                ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_MSB - ARAD_PP_ISEM_ACCESS_ENTRY_REQ_KEY_LSB + 1,
                buffer
              );
        SOC_SAND_CHECK_FUNC_RESULT(res, 22, exit);

        if (SOC_IS_JERICHO(unit)) {
            block_port_id = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)?  0 : 1 ;
            tmp_reg_name = IHB_ISEM_INTERRUPT_REGISTER_ONEr;
            tmp_fld_name = ISEM_MANAGEMENT_COMPLETEDf;   
        } else {
            block_port_id = REG_PORT_ANY;
            tmp_reg_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                  IHP_ISA_INTERRUPT_REGISTER_ONEr:IHP_ISB_INTERRUPT_REGISTER_ONEr;
            tmp_fld_name = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
                  ISA_MANAGEMENT_COMPLETEDf:ISB_MANAGEMENT_COMPLETEDf;   
        }

#ifndef PLISIM
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  10,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_read(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name, &temp));
          if (temp)
          {
            SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_NOT_READY_ERR, 10, exit);
          }
            tmp_mem_name = SOC_IS_JERICHO(unit)? IHB_ISEM_MANAGEMENT_REQUESTm: 
                ((tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A)? IHP_ISA_MANAGEMENT_REQUESTm: IHP_ISB_MANAGEMENT_REQUESTm);
            block_id = SOC_IS_JERICHO(unit)? IHB_BLOCK(unit, block_port_id) : MEM_BLOCK_ALL;
            SOC_SAND_SOC_IF_ERROR_RETURN(res, 1230, exit, soc_mem_write(unit, tmp_mem_name, block_id, 0, buffer));
          
          res = arad_polling(
                  unit,
                  ARAD_TIMEOUT,
                  ARAD_MIN_POLLS,
                  tmp_reg_name,
                  block_port_id,
                  0,
                  tmp_fld_name,
                  1
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 17, exit);
         
          /* clear management_completed by writing 1*/
          temp = 1;
          SOC_SAND_SOC_IF_ERROR_RETURN_ERR_VAL(res,  19,  exit, ARAD_REG_ACCESS_ERR,soc_reg_above_64_field32_modify(unit, tmp_reg_name, block_port_id, 0, tmp_fld_name,  temp));
#else /* PLISIM */
          access_addr = (tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_A) ? \
             ARAD_CHIP_SIM_ISEM_A_BASE:ARAD_CHIP_SIM_ISEM_B_BASE;
          res = chip_sim_exact_match_entry_remove_unsafe(
                  unit,
                  access_addr,
                  key_buffer,
                  ARAD_PP_ISEM_ACCESS_KEY_SIZE * sizeof(uint32)
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);
#endif /* PLISIM */
    }
    else
    {
      /* TCAM */
      res = arad_pp_isem_access_tcam_remove_unsafe(unit,isem_key);
      SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
    }
  }

exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_remove_unsafe()", 0, 0);
}

uint32
  arad_pp_isem_access_prog_sel_in_rif_key_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_OUT uint8                                 *with_in_rif
  )
{
  uint32
    res = SOC_SAND_OK;
  
  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  SOC_SAND_CHECK_NULL_INPUT(with_in_rif);
  
  *with_in_rif = prog_soc_prop.mpls_use_in_rif; 

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_entry_remove_unsafe()", 0, 0);
}

STATIC
uint32
    arad_pp_isem_access_ac_map_key_type_to_prog_sel(
     int                            unit,
     ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE       key_mapping,
     uint32                            *llvp_prog_sel_val
   )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  switch(key_mapping)
  {
  case ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE_PORT_VLAN:
    *llvp_prog_sel_val = ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1;
    break;
  case ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE_PORT_VLAN_VLAN:
    *llvp_prog_sel_val = ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER;
    break;
  case ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE_PORT_INITIAL_VLAN:
    *llvp_prog_sel_val = ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1;
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROG_SEL_INVALID_LIF_KEY_RANGE_ERR, 14590, exit);
    break;
  }
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_ac_map_key_type_to_prog_sel()", key_mapping, 0);
}

STATIC
uint32
    arad_pp_isem_access_prog_sel_to_ac_map_key_type(
     int                            unit,
     uint32                            llvp_prog_sel_val,
     ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE       *key_mapping    
   )
{

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  switch(llvp_prog_sel_val)
  {
  case ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1:
    *key_mapping = ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE_PORT_VLAN;
    break;
  case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER:
    *key_mapping = ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE_PORT_VLAN_VLAN;
    break;
  case ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1:
    *key_mapping = ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE_PORT_INITIAL_VLAN;
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROG_SEL_INVALID_LIF_KEY_RANGE_ERR, 10, exit);
    break;
  }
  
exit:
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_prog_sel_to_ac_map_key_type()", llvp_prog_sel_val, 0);
}

uint32
  arad_pp_isem_access_prog_sel_ac_key_set_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 entry_ndx,
    SOC_SAND_IN  ARAD_PP_L2_LIF_AC_KEY_QUALIFIER           *qual_key,
    SOC_SAND_IN  ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE            *key_mapping
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;
  uint32
    llvp_prog_sel_val = 0;
  ARAD_PP_MGMT_OPERATION_MODE
    *oper_mode = NULL;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);
  ARAD_ALLOC(oper_mode, ARAD_PP_MGMT_OPERATION_MODE, 1, "arad_pp_isem_access_prog_sel_ac_key_set_unsafe.oper_mode");
  ARAD_PP_MGMT_OPERATION_MODE_clear(oper_mode);

  res = arad_pp_sw_db_oper_mode_get(unit,oper_mode);
  SOC_SAND_CHECK_FUNC_RESULT(res, 2, exit);  

  SOC_SAND_CHECK_NULL_INPUT(qual_key);
  SOC_SAND_CHECK_NULL_INPUT(key_mapping);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1);

  if (entry_ndx > DPP_PP_ISEM_PROG_SEL_1ST_CAM_USR_LAST_ENTRY(unit))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROG_SEL_USR_INDEX_OUT_OF_RANGE_ERR, 10, exit);
  }

  res = arad_pp_isem_access_ac_map_key_type_to_prog_sel(unit,*key_mapping,&llvp_prog_sel_val);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, entry_ndx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  

  if (*key_mapping == ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE_DEFAULT)
  {
    prog_selection_1st_cam_tbl.valid = 0;
    prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask     = 0x7FF;
    prog_selection_1st_cam_tbl.packet_format_qualifier_2_mask     = 0x7FF;
    prog_selection_1st_cam_tbl.packet_format_code_mask            = 0x3F;
    prog_selection_1st_cam_tbl.ptc_vt_profile_mask                = 0x3;
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask         = 0x7;
    prog_selection_1st_cam_tbl.parser_leaf_context_mask           = 0xF;
  }
  else
  {
    prog_selection_1st_cam_tbl.packet_format_qualifier_1      = ((qual_key->pkt_parse_info.outer_tpid << 3) | (qual_key->pkt_parse_info.is_outer_prio << 2) | (qual_key->pkt_parse_info.inner_tpid << 0)); 
    prog_selection_1st_cam_tbl.packet_format_qualifier_1_mask = 0x7e0;/*{11b111_1110_0000}; only ethernet tag format */
    prog_selection_1st_cam_tbl.packet_format_code             = 0x0;/*{6b000000};  (PacketFormatCode[5]==0) ==> starts with ethernet */
    prog_selection_1st_cam_tbl.packet_format_code_mask        = 0x1f;/*6b01_1111*/
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile          = qual_key->port_profile;
    prog_selection_1st_cam_tbl.in_pp_port_vt_profile_mask     = 0x0;/*3b000*/
    prog_selection_1st_cam_tbl.llvp_prog_sel                  = llvp_prog_sel_val;
    prog_selection_1st_cam_tbl.valid                          = 0x1; /*1b1*/
  }
  
  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_set_unsafe(unit, entry_ndx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);

exit:
  ARAD_FREE(oper_mode);
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_prog_sel_ac_key_set_unsafe()", entry_ndx, 0);
}

uint32
  arad_pp_isem_access_prog_sel_ac_key_get_unsafe(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 entry_ndx,
    SOC_SAND_IN  ARAD_PP_L2_LIF_AC_KEY_QUALIFIER           *qual_key,
    SOC_SAND_OUT ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE            *key_mapping    
  )
{
  uint32
    res = SOC_SAND_OK;
  ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA
    prog_selection_1st_cam_tbl;
  ARAD_PP_MGMT_OPERATION_MODE
    *oper_mode = NULL;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_ALLOC(oper_mode, ARAD_PP_MGMT_OPERATION_MODE, 1, "arad_pp_isem_access_prog_sel_ac_key_get_unsafe.oper_mode");
  ARAD_PP_MGMT_OPERATION_MODE_clear(oper_mode);

  res = arad_pp_sw_db_oper_mode_get(unit,oper_mode);
  SOC_SAND_CHECK_FUNC_RESULT(res, 3, exit);

  SOC_SAND_CHECK_NULL_INPUT(qual_key);
  SOC_SAND_CHECK_NULL_INPUT(key_mapping);

  ARAD_CLEAR(&prog_selection_1st_cam_tbl, ARAD_PP_IHP_VTT1ST_KEY_PROGRAM_SELECTION_CAM_TBL_DATA, 1); 

  if (entry_ndx > DPP_PP_ISEM_PROG_SEL_1ST_CAM_USR_LAST_ENTRY(unit))
  {
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_PROG_SEL_USR_INDEX_OUT_OF_RANGE_ERR, 10, exit);
  }

  res = arad_pp_ihp_isem_1st_program_selection_cam_tbl_get_unsafe(unit, entry_ndx, &prog_selection_1st_cam_tbl);
  SOC_SAND_CHECK_FUNC_RESULT(res, 20, exit);

  if (prog_selection_1st_cam_tbl.valid)
  {
    res = arad_pp_isem_access_prog_sel_to_ac_map_key_type(unit,prog_selection_1st_cam_tbl.llvp_prog_sel,key_mapping);
    SOC_SAND_CHECK_FUNC_RESULT(res, 30, exit);
  }
  else
  {
    /* Entry not valid , return key type default - since no match */
    *key_mapping = ARAD_PP_L2_LIF_AC_MAP_KEY_TYPE_DEFAULT;   
  }
  

exit:
  ARAD_FREE(oper_mode);
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_prog_sel_ac_key_get_unsafe()", entry_ndx, 0);
}

/*********************************************************************
*     Get the pointer to the list of procedures of the
 *     arad_pp_api_isem_access module.
 *     Details: in the H file. (search for prototype)
*********************************************************************/
CONST SOC_PROCEDURE_DESC_ELEMENT*
  arad_pp_isem_access_get_procs_ptr(void)
{
  return Arad_pp_procedure_desc_element_isem_access;
}
/*********************************************************************
*     Get the pointer to the list of errors of the
 *     arad_pp_api_isem_access module.
 *     Details: in the H file. (search for prototype)
*********************************************************************/
CONST SOC_ERROR_DESC_ELEMENT*
  arad_pp_isem_access_get_errs_ptr(void)
{
  return Arad_pp_error_desc_element_isem_access;
}

uint32
  arad_pp_isem_access_key_from_buffer(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 *buffer,
    SOC_SAND_IN  uint32                                 lookup_num,
    SOC_SAND_IN  uint32                                 tables_access_id,    
    SOC_SAND_OUT ARAD_PP_ISEM_ACCESS_KEY                *isem_key
  )
{
  uint32
    res = SOC_SAND_OK;
  uint32
    access_profile_from_buffer = 0,
    access_profile_id = 0,
    tcam_db_id = 0,
    tmp = 0,
    prefix=0;
  ARAD_PP_ISEM_ACCESS_KEY_TYPE
    key_type = 0;
  uint32
    mac_U32[SOC_SAND_PP_MAC_ADDRESS_NOF_UINT32S] = {0};
  uint8
    valid;

  SOC_SAND_INIT_ERROR_DEFINITIONS(0);

  ARAD_PP_CLEAR(isem_key,ARAD_PP_ISEM_ACCESS_KEY,1);

  if(is_g_prog_soc_prop_initilized[unit] == 0)
  {
      res = arad_pp_isem_access_programs_soc_properties_get(unit);
      SOC_SAND_CHECK_FUNC_RESULT(res, 10, exit);
  }
#define prog_soc_prop g_prog_soc_prop[unit]

  if (tables_access_id != ARAD_PP_ISEM_ACCESS_ID_TCAM)
  { 
  
     res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_LSB_PREFIX, ARAD_PP_ISEM_ACCESS_NOF_BITS_PREFIX, &prefix);
     SOC_SAND_CHECK_FUNC_RESULT(res, 12, exit);
  }
  else
  {
     res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_LSB, ARAD_PP_ISEM_ACCESS_TCAM_ACCESS_PROFILE_ID_NOF_BITS, &access_profile_from_buffer);
     SOC_SAND_CHECK_FUNC_RESULT(res, 13, exit);

     for (tcam_db_id = ARAD_PP_ISEM_ACCESS_TCAM_BASE; tcam_db_id <= ARAD_PP_ISEM_ACCESS_TCAM_END; tcam_db_id++)
     {
        res = arad_sw_db_tcam_db_valid_get(unit, tcam_db_id, &valid);
        SOC_SAND_CHECK_FUNC_RESULT(res, 13, exit);
        if (valid)
        {
          res = arad_sw_db_tcam_db_access_profile_id_get(
                  unit,
                  tcam_db_id,
                  0, /* No 320b DB */
                  &access_profile_id
                );
          SOC_SAND_CHECK_FUNC_RESULT(res, 13, exit);

          if (access_profile_id == access_profile_from_buffer)
          {
             break;
          }
        }
     }

     if (tcam_db_id > ARAD_PP_ISEM_ACCESS_TCAM_END)
     {
        /* No match */
        SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_KEY_TYPE_TCAM_INVALID_ERR, 300, exit);
     }

     prefix = tcam_db_id; 
  }
  res = arad_pp_isem_access_prefix_to_key_type(unit, prefix, lookup_num, tables_access_id, buffer, &key_type);
  SOC_SAND_CHECK_FUNC_RESULT(res, 14, exit);

  isem_key->key_type = (ARAD_PP_ISEM_ACCESS_KEY_TYPE)key_type;

  switch(isem_key->key_type)
  {
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_INITIAL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_DESIGNATED_VID:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 32, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);

    /* Other special fields */
    switch (isem_key->key_type)
    {
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_VID_VID:
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_eth.inner_vid);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);
      break;    
    case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID:
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_NOF_BITS, &isem_key->key_info.l2_eth.outer_pcp);
      SOC_SAND_CHECK_FUNC_RESULT(res, 447, exit);
      break;
    default:
      break;
    }        
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VD_PCP_VID_VID:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 5532, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 5538, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_OUTER_PCP_NOF_BITS, &isem_key->key_info.l2_eth.outer_pcp);
    SOC_SAND_CHECK_FUNC_RESULT(res, 443, exit);
    
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_VD_PCP_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_eth.inner_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 445, exit);
      
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID:

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_pon.port); /* Returns VLAN domain */
    SOC_SAND_CHECK_FUNC_RESULT(res, 700, exit);

    isem_key->key_info.l2_pon.port_valid = TRUE;

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_TUNNEL_NOF_BITS, &isem_key->key_info.l2_pon.tunnel_id); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 705, exit);
    
    isem_key->key_info.l2_pon.tunnel_id_valid = TRUE;

    if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL &&
        tables_access_id == ARAD_PP_ISEM_ACCESS_ID_ISEM_B) {
        /* TLS service */
        isem_key->key_info.l2_pon.flags = ARAD_PP_ISEM_ACCESS_L2_PON_TLS;
    }

    if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID || 
        isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID ) 
    {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_pon.outer_vid); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);

      isem_key->key_info.l2_pon.outer_vid_valid = TRUE;
    }

    if (isem_key->key_type == ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_TUNNEL_VID_VID) 
    { 
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_TUNNEL_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_pon.inner_vid); 
      SOC_SAND_CHECK_FUNC_RESULT(res, 715, exit);

      isem_key->key_info.l2_pon.inner_vid_valid = TRUE;
    }    

    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID:
    /* In case of only key all attributes are valid */
    isem_key->key_info.l2_pon.port_valid = TRUE; /* Assumed to be always valid */
    isem_key->key_info.l2_pon.tunnel_id_valid = TRUE;
    isem_key->key_info.l2_pon.ether_type_valid = TRUE;
    isem_key->key_info.l2_pon.outer_dei_valid = TRUE;
    isem_key->key_info.l2_pon.outer_pcp_valid = TRUE;
    isem_key->key_info.l2_pon.outer_vid_valid = TRUE;
    isem_key->key_info.l2_pon.inner_vid_valid = TRUE;
    
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_pon.port); /* Returns VLAN domain */
    SOC_SAND_CHECK_FUNC_RESULT(res, 700, exit);  

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_TUNNEL_NOF_BITS, &isem_key->key_info.l2_pon.tunnel_id); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 705, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_pon.outer_vid); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_pon.inner_vid); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 715, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_ETHERTYPE_NOF_BITS, &isem_key->key_info.l2_pon.ether_type); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_DEI_NOF_BITS, &isem_key->key_info.l2_pon.outer_dei); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 725, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_LSB, ARAD_PP_ISEM_ACCESS_KEY_PON_VD_ETHERTYPE_TUNNEL_PCP_VID_VID_OUTER_PCP_NOF_BITS, &isem_key->key_info.l2_pon.outer_pcp); 
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);

    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_PBB:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_DOMAIN_NOF_BITS, &isem_key->key_info.pbb.isid_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 40, exit);
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_LSB, ARAD_PP_ISEM_ACCESS_KEY_PBB_ISID_NOF_BITS, &isem_key->key_info.pbb.isid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 42, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_DIP:       
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_DIP_NOF_BITS, &isem_key->key_info.ip_tunnel.dip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 58, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP:       
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_SIP_OVERLAY_SIP_NOF_BITS, &isem_key->key_info.ip_tunnel.sip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 59, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IP_TUNNEL_SIP_DIP:       
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_DIP_NOF_BITS, &isem_key->key_info.ip_tunnel.dip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 60, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_SIP_NOF_BITS, &isem_key->key_info.ip_tunnel.sip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 362, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_NEXT_PROTOCOL_NOF_BITS, &isem_key->key_info.ip_tunnel.ipv4_next_protocol);
    SOC_SAND_CHECK_FUNC_RESULT(res, 364, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_LSB, ARAD_PP_ISEM_ACCESS_KEY_IP_TUNNEL_TCAM_PORT_PROPERTY_NOF_BITS, &isem_key->key_info.ip_tunnel.port_property);
    SOC_SAND_CHECK_FUNC_RESULT(res, 366, exit);

    isem_key->key_info.ip_tunnel.port_property_en = (isem_key->key_info.ip_tunnel.port_property) ? 1:0;     
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP:       
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_IPV6_TUNNEL_DIP_NOF_BITS, isem_key->key_info.ip_tunnel.dip6.ipv6_address.address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 63, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NICK:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_NICK_NAME_NOF_BITS, &isem_key->key_info.trill.nick_name);
    SOC_SAND_CHECK_FUNC_RESULT(res, 64, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_VSI_NOF_BITS, &isem_key->key_info.trill.vsi);
    SOC_SAND_CHECK_FUNC_RESULT(res, 74, exit);
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_APPOINTED_FORWARDER_PORT_NOF_BITS, &isem_key->key_info.trill.port);
    SOC_SAND_CHECK_FUNC_RESULT(res, 76, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_NATIVE_INNER_TPID_NOF_BITS, &isem_key->key_info.trill.native_inner_tpid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 78, exit);
    break;


  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_GRE:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_GRE_KEY_VPN_NOF_BITS, &isem_key->key_info.l2_gre.gre_key);
    SOC_SAND_CHECK_FUNC_RESULT(res, 90, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_VNI:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_L2_VNI_KEY_VPN_NOF_BITS, &isem_key->key_info.l2_vni.vni_key);
    SOC_SAND_CHECK_FUNC_RESULT(res, 92, exit);
    break;

  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_FCOE_D_ID_NOF_BITS, &tmp);
    SOC_SAND_CHECK_FUNC_RESULT(res, 93, exit);    
    ARAD_PP_FRWRD_FCF_SET_DOMAIN(isem_key->key_info.fcoe.d_id,tmp);
    break;


  /* MPLS / PWE */
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L3:    
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L2_ELI:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_ELI:  
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_PWE_L2_GAL:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), &isem_key->key_info.mpls.label);
    SOC_SAND_CHECK_FUNC_RESULT(res, 34, exit);    

    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, &isem_key->key_info.mpls.is_bos);
      SOC_SAND_CHECK_FUNC_RESULT(res, 36, exit);    
    }    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_L1_IN_RIF_ELI:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_RIF_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), &isem_key->key_info.mpls.in_rif);
    SOC_SAND_CHECK_FUNC_RESULT(res, 37, exit);
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_LSB(prog_soc_prop.is_bos_in_key_enable), ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_NOF_BITS(prog_soc_prop.is_bos_in_key_enable), &isem_key->key_info.mpls.label);
    SOC_SAND_CHECK_FUNC_RESULT(res, 38, exit);    
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_MPLS_LABEL_BOS_NOF_BITS, &isem_key->key_info.mpls.is_bos);
    SOC_SAND_CHECK_FUNC_RESULT(res, 39, exit);    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_COUPLING:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_FRR:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_NOF_BITS, &isem_key->key_info.mpls.label);
    SOC_SAND_CHECK_FUNC_RESULT(res, 140, exit);    

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_NOF_BITS, &isem_key->key_info.mpls.label2);
    SOC_SAND_CHECK_FUNC_RESULT(res, 142, exit);    

    if (prog_soc_prop.is_bos_in_key_enable) 
    {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL2_BOS_NOF_BITS, &isem_key->key_info.mpls.is_bos);
      SOC_SAND_CHECK_FUNC_RESULT(res, 143, exit);    
    }
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV4:   

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SA_8MSB_NOF_BITS, mac_U32);
    SOC_SAND_CHECK_FUNC_RESULT(res, 145, exit);    

    /* The function soc_sand_pp_mac_address_long_to_struct reads from indecies 0 and 1 of the first parameter only */
    /* coverity[overrun-buffer-val : FALSE] */   
    res = soc_sand_pp_mac_address_long_to_struct(
          mac_U32,
          &isem_key->key_info.spoof_v4.smac
        );
    SOC_SAND_CHECK_FUNC_RESULT(res, 146, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V4_SIP_NOF_BITS, &isem_key->key_info.spoof_v4.sip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 147, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_IPV6:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SA_7MSB_NOF_BITS, mac_U32);
    SOC_SAND_CHECK_FUNC_RESULT(res, 245, exit);    

    res = soc_sand_pp_mac_address_long_to_struct(
          mac_U32,
          &isem_key->key_info.spoof_v6.smac
        );
    SOC_SAND_CHECK_FUNC_RESULT(res, 246, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_TYPE_SPOOF_V6_SIP_NOF_BITS, isem_key->key_info.spoof_v6.sip6.ipv6_address.address);
    SOC_SAND_CHECK_FUNC_RESULT(res, 153, exit);

    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TRILL_VSI:
    isem_key->key_info.trill.flags = 0x0;
    tmp = 0;

    if (tables_access_id != ARAD_PP_ISEM_ACCESS_ID_TCAM) {
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_2BITS_INDICATION_NOF_BITS, &tmp);
      SOC_SAND_CHECK_FUNC_RESULT(res, 500, exit);
  
      if (tmp == ARAD_PP_ISEM_ACCESS_KEY_2BITS_OUTER_VID) {
          isem_key->key_info.trill.flags |= ARAD_PP_ISEM_ACCESS_TRILL_VSI_VL; 
      } else {
          isem_key->key_info.trill.flags |= ARAD_PP_ISEM_ACCESS_TRILL_VSI_FGL; 
      }
      
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_OUTER_VID_NOF_BITS, &isem_key->key_info.trill.high_vid);
      SOC_SAND_CHECK_FUNC_RESULT(res, 510, exit);
      
      if (isem_key->key_info.trill.flags & ARAD_PP_ISEM_ACCESS_TRILL_VSI_FGL) 
      {
        res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_NATIVE_INNER_VID_NOF_BITS, &isem_key->key_info.trill.low_vid);
        SOC_SAND_CHECK_FUNC_RESULT(res, 520, exit);
      }
    } else {
      isem_key->key_info.trill.flags |= ARAD_PP_ISEM_ACCESS_TRILL_VSI_TTS; 
      
      res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TRILL_VSI_TTS_NATIVE_OUTER_VID_NOF_BITS, &isem_key->key_info.trill.high_vid);
      SOC_SAND_CHECK_FUNC_RESULT(res, 510, exit);
    }    
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_RPA:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_LSB, ARAD_PP_ISEM_ACCESS_KEY_RPA_DIP_NOF_BITS, &isem_key->key_info.rpa.dip);
    SOC_SAND_CHECK_FUNC_RESULT(res, 610, exit);    

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_LSB, ARAD_PP_ISEM_ACCESS_KEY_RPA_VRF_NOF_BITS, &isem_key->key_info.rpa.vrf);
    SOC_SAND_CHECK_FUNC_RESULT(res, 620, exit); 
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_SINGLE_TAG:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_FLEXIBLE_Q_IN_Q_DOUBLE_TAG:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 740, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_FLEXIBLE_Q_IN_Q_VD_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_eth.inner_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 750, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_INITIAL_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_COMPRESSED_TAG:
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_UNTAG:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 710, exit);

    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 720, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_TST_DOUBLE_TAG:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_VLAN_DOMAIN_NOF_BITS, &isem_key->key_info.l2_eth.vlan_domain);
    SOC_SAND_CHECK_FUNC_RESULT(res, 730, exit);                            
                                                                           
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_OUTER_VID_NOF_BITS, &isem_key->key_info.l2_eth.outer_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 740, exit);                            
                                                                           
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_LSB, ARAD_PP_ISEM_ACCESS_KEY_TST_VD_VID_VID_INNER_VID_NOF_BITS, &isem_key->key_info.l2_eth.inner_vid);
    SOC_SAND_CHECK_FUNC_RESULT(res, 750, exit);
    break;
  case ARAD_PP_ISEM_ACCESS_KEY_TYPE_MPLS_EXPLICIT_NULL:
    res = soc_sand_bitstream_get_any_field(buffer, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_LSB, ARAD_PP_ISEM_ACCESS_KEY_TCAM_MPLS_LABEL1_NOF_BITS, &isem_key->key_info.mpls.label);
    SOC_SAND_CHECK_FUNC_RESULT(res, 760, exit);        
    break;
  default:
    SOC_SAND_SET_ERROR_CODE(ARAD_PP_ISEM_ACCESS_UNKNOWN_KEY_TYPE_ERR, 100, exit); 
    break;
  }

exit:
#undef prog_soc_prop
  SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_key_from_buffer()", 0, 0);
}

STATIC
void
  arad_pp_isem_access_print_vt_program_data(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 program_id
  )
{
    char* prog_name;

    switch(program_id)
    {
    case ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_TM_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_HIGH_VD_OUTER_INNER_OR_LOW_VD_OUTER";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VDxINITIALVID_L1_L2ELI";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VDxOUTERVID_L1_L2ELI";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_TRILL";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DESIGNATED_VID_TRILL";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_TRILL";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_TRILL";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1FRR";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1FRR";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_L1L2";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTERVID_L1L2";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER_PCP";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER_OUTERPCP";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_HIGH_VD_OUTER_INNER_OUTERPCP_OR_VD_OUTER_INNER_OR_VD_OUTER";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_OR_VD_INITIALVID";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_OR_VD_OUTER";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_OUTER_INNER_OR_VD_OUTER_INNER";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L1";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L1";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_FRR_L1";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_FRR_L1";
        break;                
    case ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_INITIALVID_L3";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_INDX_VD_OUTERVID_L3";
        break;                
    case ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_PON_UNTAGGED";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_PON_ONE_TAG";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_PON_TWO_TAGS_VS_TUNNEL_ID";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID";
        break;     
    case ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_S_TAG";
        break;     
    case ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_EVB_UN_C_TAG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_PRIORITY_INITIAL_VID";
        break;        
    case ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_DOUBLE_TAG_5_IP_TUPLE_Q_IN_Q";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_SINGLE_TAG_5_IP_TUPLE_Q_IN_Q";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_INITIAL_VID_AFTER_RECYCLE";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_IPV4_OUTER_VID_AFTER_RECYCLE";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG";
        break;       
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG";
        break;   
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_INITIALVID_EXPLICIT_NULL";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_DOUBLE_TAG_EXPLICIT_NULL";
        break;       
    case ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_VT_VD_SINGLE_TAG_EXPLICIT_NULL";
        break;    
    default:
        prog_name = "Unknown program";
    }

    if (vt_programs[unit][program_id].prog_used != -1) {        
        LOG_CLI((BSL_META_U(unit,
                            "Program %s ID: %d\n"), prog_name,vt_programs[unit][program_id].prog_used));          
    }
}

STATIC
void
  arad_pp_isem_access_print_tt_program_data(
    SOC_SAND_IN  int                                 unit,
    SOC_SAND_IN  uint32                                 program_id
  )
{
    char* prog_name;

    switch(program_id)
    {
    case ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_TM_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_L2:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_L2";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_L3:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_L3";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_L2_L3ELI";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_COUPLING_L3_L4";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_ARP_2ND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_BRIDGE_STAR_2ND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_PWE_GRE_DIP_FOUND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_DIP_FOUND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_MC_DIP_NOT_FOUND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_IPV4_ROUTER_UC_DIP_NOT_FOUND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_2ND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_IPV6_ROUTER_2ND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_IP_ROUTER_CompatibleMc_2ND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_UNKNOWN_L3_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_WITH_BTAG_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_MAC_IN_MAC_MC_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_FC_WITH_VFT_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_FC_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_INRIF";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_L3ELI_INRIF";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2ELI_INRIF";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L2";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L3_L4";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3ELI";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TWO_VLANS_AT_NATIVE_ETH";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_TRILL_2ND_PROG_TRILL_TRAP_PROG";
        break;   
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L1_GAL";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L1_L2_GAL";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L2";
        break;
    case ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL:
        prog_name = "ARAD_PP_ISEM_ACCESS_PROG_TT_INDX_L2_L3_GAL";
        break;
    default:
        prog_name = "Unknown program";
    }
    
    if (tt_programs[unit][program_id].prog_used != -1) {
        LOG_CLI((BSL_META_U(unit,
                            "Program %s ID: %d\n"), prog_name,tt_programs[unit][program_id].prog_used));                       
    }
}


void
  arad_pp_isem_access_print_all_programs_data(
    SOC_SAND_IN  int                                 unit
  )
{
    int program_id;

    LOG_CLI((BSL_META_U(unit,
                        "VT programs:\n")));
    for (program_id = 0; program_id < ARAD_PP_ISEM_ACCESS_PROG_VT_NOF_PROGS; program_id++) {
        arad_pp_isem_access_print_vt_program_data(unit, program_id);
    }
    LOG_CLI((BSL_META_U(unit,
                        "TT programs:\n")));
    for (program_id = 0; program_id < ARAD_PP_ISEM_ACCESS_PROG_TT_NOF_PROGS; program_id++) {
        arad_pp_isem_access_print_tt_program_data(unit, program_id);
    }
}

/*********************************************************************
*     Dump last VT&TT program invoked.
 *     Details: in the H file. (search for prototype)
*********************************************************************/
uint32
  arad_pp_isem_access_print_last_vtt_program_data(
    SOC_SAND_IN   int                 unit
  )
{
    uint8 found = FALSE;
    uint32 fld_val, 
        vt_progs_bmp,
        tt_progs_bmp,
        pgm_ndx,
        program_id,
        res = SOC_SAND_OK;
    uint64 reg_val64;
    

    SOC_SAND_INIT_ERROR_DEFINITIONS(0);

    /* 
     * 1. Read and print all invoked programs
     * 2. Clear the register
     */

    SOC_SAND_SOC_IF_ERROR_RETURN(res, 10, exit, READ_IHP_VTT_PROGRAM_ENCOUNTEREDr(unit, REG_PORT_ANY ,&reg_val64));
    fld_val = soc_reg64_field32_get(unit, IHP_VTT_PROGRAM_ENCOUNTEREDr, reg_val64, SOC_IS_JERICHO(unit) ? VLAN_TRANSLATION_PROGRAM_ENCOUNTEREDf : VTT_PROGRAM_FIRST_LOOKUPf);
    vt_progs_bmp = fld_val;
    fld_val = soc_reg64_field32_get(unit, IHP_VTT_PROGRAM_ENCOUNTEREDr, reg_val64, SOC_IS_JERICHO(unit) ? TUNNEL_TERMINATION_PROGRAM_ENCOUNTEREDf : VTT_PROGRAM_SECOND_LOOKUPf);
    tt_progs_bmp = fld_val;

    LOG_CLI((BSL_META_U(unit,
                        "Last invoked VT program:\n")));
    for (pgm_ndx = 0; pgm_ndx < SOC_DPP_DEFS_GET(unit, nof_vtt_programs); pgm_ndx++)
    {
        if (SOC_SAND_GET_BIT(vt_progs_bmp, pgm_ndx))
        {
            /* Program found */
            found = TRUE;
            for (program_id = 0; program_id < ARAD_PP_ISEM_ACCESS_PROG_VT_NOF_PROGS; program_id++)
            {
                if (vt_programs[unit][program_id].prog_used == pgm_ndx)
                {
                    arad_pp_isem_access_print_vt_program_data(unit, program_id);
                    break;
                }
            }
        }
    }

    if (!found)
    {
        LOG_CLI((BSL_META_U(unit,
                            "No program invoked\n")));
    }

    found = FALSE;
    LOG_CLI((BSL_META_U(unit,
                        "Last invoked TT program:\n")));

    for (pgm_ndx = 0; pgm_ndx < SOC_DPP_DEFS_GET(unit, nof_vtt_program_selection_lines); pgm_ndx++)
    {
        if (SOC_SAND_GET_BIT(tt_progs_bmp, pgm_ndx))
        {
            /* Program found */
            found = TRUE;
            for (program_id = 0; program_id < ARAD_PP_ISEM_ACCESS_PROG_TT_NOF_PROGS; program_id++)
            {
                if (tt_programs[unit][program_id].prog_used == pgm_ndx)
                {
                    arad_pp_isem_access_print_tt_program_data(unit, program_id);
                    break;
                }
            }
        }
    }


    if (!found)
    {
        LOG_CLI((BSL_META_U(unit,
                            "No program invoked\n")));
    }

    /* Set all bits as ones to clear it. */
    COMPILER_64_ALLONES(reg_val64);
    SOC_SAND_SOC_IF_ERROR_RETURN(res, 20, exit, WRITE_IHP_VTT_PROGRAM_ENCOUNTEREDr(unit,REG_PORT_ANY, reg_val64));


exit:
    SOC_SAND_EXIT_AND_SEND_ERROR("error in arad_pp_isem_access_print_last_vtt_program_data()", 0, 0);
}

/* } */
#include <soc/dpp/SAND/Utils/sand_footer.h>


#endif /* of #if defined(BCM_88650_A0) */
