diff -rupN linux-3.12.old/include/net/sock.h linux-3.12.new/include/net/sock.h
--- linux-3.12.old/include/net/sock.h	2015-10-27 10:25:09.000000000 +0000
+++ linux-3.12.new/include/net/sock.h	2015-10-26 16:22:12.000000000 +0000
@@ -427,6 +427,17 @@ struct sock {
 #define SK_CAN_REUSE	1
 #define SK_FORCE_REUSE	2
 
+/*
+ * SK_CAN_REUSE and SK_NO_REUSE on a socket mean that the socket is OK
+ * or not whether his port will be reused by someone else. SK_FORCE_REUSE
+ * on a socket means that the socket will reuse everybody else's port
+ * without looking at the other's sk_reuse value.
+ */
+
+#define SK_NO_REUSE	0
+#define SK_CAN_REUSE	1
+#define SK_FORCE_REUSE	2
+
 static inline int sk_peek_offset(struct sock *sk, int flags)
 {
 	if ((flags & MSG_PEEK) && (sk->sk_peek_off >= 0))
diff -rupN linux-3.12.old/include/net/tcp.h linux-3.12.new/include/net/tcp.h
--- linux-3.12.old/include/net/tcp.h	2015-10-27 10:25:09.000000000 +0000
+++ linux-3.12.new/include/net/tcp.h	2015-10-27 12:35:06.000000000 +0000
@@ -408,6 +408,8 @@ enum tcp_tw_status {
 	TCP_TW_SYN = 3
 };
 
+void tcp_connect_init(struct sock *sk);
+void tcp_finish_connect(struct sock *sk, struct sk_buff *skb);
 
 extern enum tcp_tw_status tcp_timewait_state_process(struct inet_timewait_sock *tw,
 						     struct sk_buff *skb,
@@ -687,6 +689,8 @@ extern u32 __tcp_select_window(struct so
 
 void tcp_send_window_probe(struct sock *sk);
 
+void tcp_send_window_probe(struct sock *sk);
+
 /* TCP timestamps are only 32-bits, this causes a slight
  * complication on 64-bit systems since we store a snapshot
  * of jiffies in the buffer control blocks below.  We decided
diff -rupN linux-3.12.old/net/ipv4/tcp.c linux-3.12.new/net/ipv4/tcp.c
--- linux-3.12.old/net/ipv4/tcp.c	2015-10-27 10:25:09.000000000 +0000
+++ linux-3.12.new/net/ipv4/tcp.c	2015-10-27 12:26:55.000000000 +0000
@@ -1064,7 +1064,7 @@ int tcp_sendmsg(struct kiocb *iocb, stru
 	if (unlikely(tp->repair)) {
 		if (tp->repair_queue == TCP_RECV_QUEUE) {
 			copied = tcp_send_rcvq(sk, msg, size);
-			goto out_nopush;
+			goto out;
 		}
 
 		err = -EINVAL;
@@ -1224,7 +1224,7 @@ new_segment:
 wait_for_sndbuf:
 			set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
 wait_for_memory:
-			if (copied)
+			if (copied && likely(!tp->repair))
 				tcp_push(sk, flags & ~MSG_MORE, mss_now, TCP_NAGLE_PUSH);
 
 			if ((err = sk_stream_wait_memory(sk, &timeo)) != 0)
@@ -1235,9 +1235,9 @@ wait_for_memory:
 	}
 
 out:
-	if (copied)
+	if (copied && likely(!tp->repair))
 		tcp_push(sk, flags, mss_now, tp->nonagle);
-out_nopush:
+//out_nopush:
 	release_sock(sk);
 	return copied + copied_syn;
 
diff -rupN linux-3.12.old/net/ipv4/tcp_ipv4.c linux-3.12.new/net/ipv4/tcp_ipv4.c
--- linux-3.12.old/net/ipv4/tcp_ipv4.c	2015-10-27 10:25:09.000000000 +0000
+++ linux-3.12.new/net/ipv4/tcp_ipv4.c	2015-10-27 09:24:03.000000000 +0000
@@ -141,6 +141,14 @@ int tcp_twsk_unique(struct sock *sk, str
 }
 EXPORT_SYMBOL_GPL(tcp_twsk_unique);
 
+static int tcp_repair_connect(struct sock *sk)
+{
+	tcp_connect_init(sk);
+	tcp_finish_connect(sk, NULL);
+
+	return 0;
+}
+
 /* This will initiate an outgoing connection. */
 int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
@@ -245,7 +253,10 @@ int tcp_v4_connect(struct sock *sk, stru
 
 	inet->inet_id = tp->write_seq ^ jiffies;
 
-	err = tcp_connect(sk);
+	if (likely(!tp->repair))
+		err = tcp_connect(sk);
+	else 
+		err = tcp_repair_connect(sk);
 
 	rt = NULL;
 	if (err)
diff -rupN linux-3.12.old/net/ipv4/tcp_output.c linux-3.12.new/net/ipv4/tcp_output.c
--- linux-3.12.old/net/ipv4/tcp_output.c	2015-10-27 10:25:09.000000000 +0000
+++ linux-3.12.new/net/ipv4/tcp_output.c	2015-10-27 09:29:19.000000000 +0000
@@ -3148,6 +3148,7 @@ void tcp_send_window_probe(struct sock *
 {
 	if (sk->sk_state == TCP_ESTABLISHED) {
 		tcp_sk(sk)->snd_wl1 = tcp_sk(sk)->rcv_nxt - 1;
+		tcp_sk(sk)->snd_nxt = tcp_sk(sk)->write_seq;
 		tcp_xmit_probe_skb(sk, 0);
 	}
 }
