/*

 * $Id$

 * $Copyright: Copyright 2015 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Module: Field Processor APIs
 *
 * Purpose:
 *     'Field Processor' (FP) API for Dune Soc_petra device using PPD
 */

#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_BCM_FP

#include <shared/bsl.h>


#include "bcm_int/common/debug.h"

#include <bcm/types.h>
#include <bcm/debug.h>
#include <bcm/error.h>
#include <bcm/field.h>
#include <bcm/mirror.h>
#include <bcm/stack.h>
#include <bcm/switch.h>
#include <bcm/stg.h>

#include <soc/drv.h>
#include <bcm_int/dpp/field_int.h>
#include <bcm_int/dpp/error.h>
#include <bcm_int/dpp/utils.h>
#include <bcm_int/dpp/gport_mgmt.h>
#include <bcm_int/dpp/counters.h>
#include <bcm_int/dpp/l3.h>
#include <bcm_int/dpp/rx.h>
#include <bcm_int/dpp/switch.h>
#ifdef BCM_WARM_BOOT_SUPPORT
#include <bcm_int/dpp/wb_db_field.h>
#endif /* def BCM_WARM_BOOT_SUPPORT */
#ifdef BCM_PETRAB_SUPPORT
#include <soc/dpp/Petra/PB_PP/pb_pp_api_trap_mgmt.h>
#include <soc/dpp/Petra/PB_PP/pb_pp_trap_mgmt.h>
#include <soc/dpp/Petra/PB_PP/pb_pp_sw_db.h>
#endif /* def BCM_PETRAB_SUPPORT */
#ifdef BCM_ARAD_SUPPORT
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_trap_mgmt.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_general.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_fp_key.h>
#include <soc/dpp/ARAD/ARAD_PP/arad_pp_dbal.h>
#include <soc/dpp/ARAD/arad_ports.h>
#endif /* BCM_ARAD_SUPPORT */

#include <shared/bitop.h>
#include <sal/types.h>
#include <bcm_int/dpp/port.h>

#include <soc/dpp/port_sw_db.h>
#include <soc/dpp/mbcm.h>

#include <soc/dcmn/dcmn_wb.h>

#include <soc/dpp/mbcm_pp.h>

/*
 *  For now, if _BCM_DPP_FIELD_WARM_BOOT_SUPPORT is FALSE, disable warm boot
 *  support here.
 */
#ifdef BCM_WARM_BOOT_SUPPORT
#if !_BCM_DPP_FIELD_WARM_BOOT_SUPPORT
#undef BCM_WARM_BOOT_SUPPORT
#endif  /* BCM_WARM_BOOT_SUPPORT */
#endif /* !_BCM_DPP_FIELD_WARM_BOOT_SUPPORT */

/*
 *  A note about locking:
 *
 *  This module uses one lock per unit (plus there is a lock used by the list
 *  manager when managing 'ranges', plus one lock that is only used to protect
 *  resources global to all units). This unit lock prevents multiple concurrent
 *  transactions against a specific unit. However, this granularity is possibly
 *  suboptimal in some cases (such as those cases where only a group or entry
 *  or range is being manipulated), though not in all (locks for range, entry,
 *  and group would have to be taken when committing changes to the hardware;
 *  for group and entry when inserting/removing entries; &c). It is possible
 *  that a finer granularity could be used, but this means more complicated
 *  locking process and additional resources per unit.  The lock per unit
 *  method was chosen primarily to control complexity, but it also has the
 *  advantage of not needing as many resources.
 */

/*
 *  Entry priority at the BCM layer is maintained strictly by the sort order of
 *  the entries in each group.  This means that the entries within a group at
 *  the BCM layer occur in exactly the order they must have in hardware.
 *  Hopefully this prevents certain sorting issues.  The BCM layer priority has
 *  its own quirks, though, such as the way multiple entries with the same
 *  priority are handled -- the last one to be added gets the lowest 'implied'
 *  priority, with the earlier entries above it (and so on).  This peculiarity
 *  only extends to entries, since the groups must all have unique priority...
 *
 *  However, the PPD has its own idea of priority, and unlike BCM, PPD requires
 *  a 'strict' priority order -- that is, no two entries can have the same
 *  priority.  While this is better as far as coding it (prevents such
 *  ambiguities as insertion order being used to decide relative priority), it
 *  means that we have to map the priorities between the layers.
 *
 *  So, in order to keep things 'simple', the BCM layer is limited to priority
 *  values 0..n where n is one lower than the maximum number of entries
 *  supported, while the PPD priority is mapped based upon a 'phase' plus the
 *  absolute position of the entry within the group.  This allows us to do an
 *  in-place update of an entire group with minimal compromise to the behaviour
 *  of the rules (since we can ripple update in either up or down direction
 *  according to the new phase).  It does, however, result in a rippled glitch
 *  where the currently updating rule will disappear from the hardware for a
 *  moment and then come back with its new priority.
 *
 *  When the phase is even, PPD layer priorities 0..8K-1 are used; when the
 *  phase is odd, PPD layer priorities 8K..16K-1 are used.  Basically this
 *  means that transition 0->1 means we ripple from low priority to high
 *  priority entries (lowest priority gets updated first); transition 1->0
 *  ripples from high to low priority (highest priority gets updated first).
 *  The ripple direction also allows entry priority to be maintained through
 *  the entire update process.
 *
 *  Phase transitions are required when entries are added, or when entries that
 *  are already in hardware reordered (BCM API allows entry priority to change
 *  after creation, something it does not allow for groups).  The phase
 *  transition is required because we will need to insert the entry to the
 *  position in hardware appropriate to its new position in the entry list.
 *
 *  When only committing a single entry, if that entry is NOT new (it was
 *  around during the last phase transition), we can use its existing priority
 *  value, and just write the entry.  But if the entry is new (was not around
 *  during the last phase transition), we must perform a phase transition to
 *  add the entry to hardware.  This means it can easily be an *extremely* time
 *  consuming process to add entries to hardware one at a time.  The group
 *  insert feature is intended for this.
 *
 *  Removing a single entry can always be done in-place, without a phase
 *  transition.  In addition, we can leave the entry priority alone if the
 *  entry is not also being destroyed, thus allowing in-place reinsertion at a
 *  later point without requiring a phase transition.
 */

/*
 *  The old 'counters' concept is pretty simple and does not expose much to the
 *  application layer -- counters are created and attached to an entry in a
 *  single act, they can be shared between entries by using the counter sharing
 *  functions, and counters can be removed from an entry by using the somewhat
 *  unintuitive counter destroy function (which actually only removes the entry
 *  from the list of entries using the counter and finally releases the counter
 *  when there are no more entries sharing it).  Also, counters are
 *  specifically defined as *not* automatically running; they require an
 *  explicit action be attached to entries before anything should happen.
 *
 *  The new 'stats' APIs are a little more interesting.  The application
 *  manages them, and so we can't so easily hide their management (at least in
 *  terms of alloc and free), but we have no need to muck about with the
 *  sharing chains or similar.  Also, there is no explicit action needed, so
 *  merely associating a stat set with an entry means it takes effect
 *  immediately.  Furthermore, the stats definition allows better exposure of
 *  certain aspects of the statistics.  The most obvious issue is that we now
 *  need to keep track of reference counts to stat sets, since the application
 *  can easily alloc/free them and arbitrarily shift associations of stat sets
 *  to entries, including having single or multiple entries for a single set.
 *
 *  Instead of tracking a reference count as such for the counters used for
 *  stats, we link them into lists like we do when sharing counters used for
 *  the counter action.  The counter action lists are only attached to entries,
 *  but we need a base table for the counters used for stats, since the stats
 *  are not implicitly attached to entries (must be explicitly attached by the
 *  application).  So, there is a table with one entry per counter set that
 *  points to the head of the list of entries that use that counter set for
 *  stats work.  In the case of counter sets not used for stats, the pointer in
 *  the table contains 'entries + 1' and for the case of a counter set that is
 *  allocated for stats but not yet joined to any entries, the table contains
 *  'entries' for this pointer (note it's not a literal pointer but an element
 *  ID in the entry table).
 */

/*
 *  Deletion of a qualifier is inferred by this code if the underlying hardware
 *  qualifier ends up with zero mask and zero data (so the qualifier does not
 *  matter).  In this case, the code will simply remove the qualifier from the
 *  BCM layer.
 *
 *  The bcm_petra_field_qualifier_delete function simply takes advantage of
 *  this feature for the standard qualifiers, but does not cover the
 *  programmable qualifiers.
 *
 *  The programmable qualifiers can still be removed by setting both their mask
 *  and data to all zeroes.
 *
 *  Note, that this is merely cosmetic and affects only the BCM layer; the PPD
 *  layer keeps track of all qualifiers for every entry -- even qualifiers
 *  whose mask and data are zero (so they do not matter) are maintained.
 */


/******************************************************************************
 *
 *  Configuration
 */


/******************************************************************************
 *
 *  Local functions and data
 */

/* Global lock, for protecting unit init and detach functions */
static volatile sal_mutex_t _bcm_dpp_field_glob_lock = NULL;

/*
 *  Group priority limit -- we limit group priority to the same range as the
 *  PPD, even though the meaning is inverted, so the mapping is simple.
 */
#define _BCM_PETRA_FIELD_GROUP_PRIOS 128

/*
 *  Switches...
 *
 *  _BCM_DPP_FIELD_ENFORCE_WIDTH controls whether groups created with a 'width'
 *  will be constrained to the specified 'width'.  This needs to be FALSE for
 *  the purpose of the regressions, which assume far wider TCAMs than are used
 *  on Soc_petra (at least 96 trits per 'width' versus 72 on the Soc_petra), but maybe
 *  should be TRUE for normal operation?  Note the maximum width of 288 is
 *  still enforced by the code; only the width specified by the caller is
 *  ignored.
 *
 *  _BCM_PETRA_ALLOW_ACTIVE_STAT_DESTRUCTION controls whether active (in-use)
 *  stats sets can be destroyed.  If TRUE, they can be destroyed and the API
 *  will clean up references to them (but does not automatically commit the
 *  changed entries).  If FALSE, the API will refuse to destroy a set of stats
 *  to which any entry is referring.
 *
 *  _BCM_PETRA_ALLOW_CACHED_STAT_WRITE controls whether setting the field
 *  control bcmFieldControlStatSyncEnable to FALSE will switch to cached writes
 *  of statistics.  Cached read may lag behind real values but it is 'safe' in
 *  the sense that it provides coherent and expected values (at least up to the
 *  point of the last ejection of the requested counter); while cached read may
 *  not show traffic since the last ejection immediately, it will eventually
 *  show that traffic when the counter is ejected again later.  Cached write is
 *  not 'safe' in this sense because the write applies retroactively in cached
 *  mode, to the time of the last counter ejection, so this means frames that
 *  passed between the last counter ejection and the write will be counted as
 *  having occurred *after* the write instead of *before*.  The field control
 *  bcmFieldControlStatSyncEnable will always apply to reads.
 */
#define _BCM_DPP_FIELD_ENFORCE_WIDTH FALSE
#define _BCM_PETRA_ALLOW_CACHED_STAT_WRITE FALSE

_bcm_dpp_field_info_t *_bcm_dpp_field_unit_info[BCM_MAX_NUM_UNITS];

/*
 *  For now, this is hardcoded.  Once traps are managed, need to update the
 *  init function to acquire a trap properly.
 */


#ifdef BCM_ARAD_SUPPORT
/*
 * Qualifier info struct to use for bcmFieldQualifyL2Learn when 
 * Direct Extraction action required L2Learn qulifier for the action
 * must be 1b
 * SOC property custom_feature_l3_learn_force_in_fwd is set (==1). 
 */
static const _bcm_arad_field_device_qual_info_layer_t restricted_l2_learn_type_qual_info = 
    { bcmFieldQualifyL2Learn, -1, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_INGRESS_LEARN_ENABLE,           SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_INGRESS_LEARN_ENABLE,           SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_INGRESS_LEARN_ENABLE,           SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_INGRESS_LEARN_ENABLE,           SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,

        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,

        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,

        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                      SOC_PPD_NOF_FP_QUAL_TYPES
    };
/*
 * Qualifier info struct to use for bcmFieldQualifyForwardingType when 
 * SOC property custom_feature_fp_restricted_forwarding_type is set. 
 */
static const _bcm_arad_field_device_qual_info_layer_t restricted_forwarding_type_qual_info = 
    { bcmFieldQualifyForwardingType, -1, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,                             SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_IRPP_FWD_TYPE,                         SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_ERPP_HEADER_CODE,                      SOC_PPD_NOF_FP_QUAL_TYPES
    };
/*
 * Action info struct to use for bcmFieldActionForwardingTypeNew when
 * SOC property custom_feature_l3_uc_with_rpf_2pass_enabled is set.
 */
static const _bcm_arad_field_device_action_info_layer_t restricted_action_type_act_info =
    { bcmFieldActionForwardingTypeNew,
        SOC_PPD_FP_ACTION_TYPE_FWD_CODE,        SOC_PPD_NOF_FP_ACTION_TYPES,
        SOC_PPD_NOF_FP_ACTION_TYPES,            SOC_PPD_NOF_FP_ACTION_TYPES,
        SOC_PPD_NOF_FP_ACTION_TYPES,            SOC_PPD_NOF_FP_ACTION_TYPES,
        SOC_PPD_NOF_FP_ACTION_TYPES,            SOC_PPD_NOF_FP_ACTION_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t OuterVlanActionRange_qual_info = 
    { bcmFieldQualifyOuterVlanActionRange, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID1,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID1,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID1,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID1,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID1,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t InnerVlanActionRange_qual_info = 
    { bcmFieldQualifyInnerVlanActionRange, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID2,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID2,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID2,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID2,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_EDIT_CMD_VID2,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t classId_qual_info = 
     { bcmFieldQualifyClassId, 8, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_HDR_IPV4_NEXT_PRTCL,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_HDR_IPV4_NEXT_PRTCL,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_HDR_IPV4_NEXT_PRTCL,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_HDR_IPV4_NEXT_PRTCL,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_HDR_IPV4_NEXT_PRTCL,   SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t classId_as_vlan_domain_qual_info = 
     { bcmFieldQualifyClassId, 8, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_VLAN_DOMAIN,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_DOMAIN,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_DOMAIN,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_DOMAIN,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_VLAN_DOMAIN,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES
    };

static const _bcm_arad_field_device_qual_info_layer_t OuterVlanActionRange_as_outer_vid_qual_info = 
    { bcmFieldQualifyOuterVlanActionRange, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_CMPRSD_OUTER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES
    };
static const _bcm_arad_field_device_qual_info_layer_t OuterVlanId_as_initial_vid_qual_info =
    { bcmFieldQualifyOuterVlanId, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_INITIAL_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_INITIAL_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_INITIAL_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_INITIAL_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_INITIAL_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES
    };
static const _bcm_arad_field_device_qual_info_layer_t InnerVlanActionRange_as_inner_vid_qual_info = 
    { bcmFieldQualifyInnerVlanActionRange, 12, 0,
      _BCM_DPP_QUAL_REVERSE_LOOKUP,
        SOC_PPD_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_FP_QUAL_CMPRSD_INNER_VID,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES,
        SOC_PPD_NOF_FP_QUAL_TYPES,  SOC_PPD_NOF_FP_QUAL_TYPES
    };
#endif /* def BCM_ARAD_SUPPORT */

#define _BCM_DPP_FIELD_MAX_NOF_QUALS_IN_QSET                   (16)

/* predefined group status */
#define _BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE     0
#define _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE    1
#define _BCM_DPP_PREDEF_GRP_STATUS_IN_USE          2


typedef struct _bcm_field_predefined_groups_info_s {
    uint32              table_type; /* defined in _bcm_field_vt_classification_table_type_t / _bcm_field_flp_classification_table_type_t */
    uint32              internal_table_id; /* the table ID used in the DBAL */
    uint8               group_id; /* BCM group ID if not -1, the required group ID to match (this way we can identify the group by ID and not by qset ) */
    uint8               nof_quals; /* num of quals in qset */    
    bcm_field_qualify_t bcmQual_array[_BCM_DPP_FIELD_MAX_NOF_QUALS_IN_QSET];   /* qualifiers in qset  */    
} _bcm_field_predefined_groups_info_t;


static 
_bcm_field_predefined_groups_info_t vt_predefined_groups_info[_BCM_DPP_VT_CLASS_COUNT] = {            
            /* type                                |table_id| grp_id |nof quals| qset */
        { _BCM_DPP_VT_CLASS_IPV4_MATCH          ,     0,      -1,        5,   {bcmFieldQualifySrcIp, bcmFieldQualifyDstIp, bcmFieldQualifyL4SrcPort, bcmFieldQualifyL4DstPort, bcmFieldQualifyIpProtocol } },
        { _BCM_DPP_VT_CLASS_EFP                 ,     1                                                     ,      -1,        8,   {bcmFieldQualifyOuterVlanId , bcmFieldQualifyInnerVlanId, bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanActionRange, bcmFieldQualifyInnerVlanActionRange, bcmFieldQualifyOuterVlanPri, bcmFieldQualifyOuterVlanCfi, bcmFieldQualifyEtherType }},
        { _BCM_DPP_VT_QINQ_COMPRESSED_OUTER     ,     SOC_DPP_DBAL_SW_TABLE_ID_QINQ_COMPRESSED_TPID1_SEM_A  ,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyInnerVlanActionRange  }},
        { _BCM_DPP_VT_QINQ_COMPRESSED_INNER     ,     SOC_DPP_DBAL_SW_TABLE_ID_QINQ_COMPRESSED_TPID2_SEM_A  ,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyInnerVlanActionRange  }},
        { _BCM_DPP_VT_QINANY_OUTER              ,     SOC_DPP_DBAL_SW_TABLE_ID_QINANY_TPID1_SEM_B           ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                       }},
        { _BCM_DPP_VT_QINANY_INNER              ,     SOC_DPP_DBAL_SW_TABLE_ID_QINANY_TPID2_SEM_B           ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                       }},
        { _BCM_DPP_VT_QINANY_PCP_OUTER          ,     SOC_DPP_DBAL_SW_TABLE_ID_QINANY_PCP_TPID1_SEM_A       ,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyOuterVlanPriCfi          }},
        { _BCM_DPP_VT_QINANY_PCP_INNER          ,     SOC_DPP_DBAL_SW_TABLE_ID_QINANY_PCP_TPID2_SEM_A       ,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyOuterVlanPriCfi          }},
        { _BCM_DPP_VT_DOT1Q_OUTER               ,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_TPID1_SEM_A               ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                       }},
        { _BCM_DPP_VT_DOT1Q_INNER               ,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_TPID2_SEM_A               ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                       }},
        { _BCM_DPP_VT_DOT1Q_COMPRESSED_OUTER    ,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_COMPRESSED_TPID1_SEM_B    ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanActionRange                              }},
        { _BCM_DPP_VT_DOT1Q_COMPRESSED_INNER    ,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_COMPRESSED_TPID2_SEM_B    ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanActionRange                              }},
        { _BCM_DPP_VT_DOT1Q_COMPRESSED_PCP_OUTER,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_PCP_COMPRESSED_TPID1_SEM_A,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanPriCfi, bcmFieldQualifyOuterVlanActionRange }},
        { _BCM_DPP_VT_DOT1Q_COMPRESSED_PCP_INNER,     SOC_DPP_DBAL_SW_TABLE_ID_1Q_PCP_COMPRESSED_TPID2_SEM_A,      -1,        3,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanPriCfi, bcmFieldQualifyOuterVlanActionRange }},
        { _BCM_DPP_VT_UNTAGGED                  ,     SOC_DPP_DBAL_SW_TABLE_ID_UNTAGGED_SEM_A               ,      -1,        2,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId                                          }},
        { _BCM_DPP_VT_TST2                      ,     SOC_DPP_DBAL_SW_TABLE_ID_TST2_TCAM                    ,      -1,        5,   {bcmFieldQualifyClassId, bcmFieldQualifyOuterVlanId, bcmFieldQualifyOuterVlanPriCfi, bcmFieldQualifyOuterTpid, bcmFieldQualifyInnerVlanId}}
};                                                             

/* BCM layer action to define if it is valid or nor according to sys property */ 
uint8 vt_predefined_groups_status[BCM_MAX_NUM_UNITS][_BCM_DPP_VT_CLASS_COUNT] = {{_BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE}};/* _BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE must be 0*/   


static 
_bcm_field_predefined_groups_info_t flp_predefined_groups_info[_BCM_DPP_FLP_CLASS_COUNT] = {            
            /* type                               |table_id                                      |grp_id|nof quals| temporary qset */
        { _BCM_DPP_FLP_CLASS_IPV4_MPLS_EXTENDED,   _BCM_DPP_INTERNAL_TABLE_ID_EXTENDED_IPV4_MPLS,    -1,      6,   {bcmFieldQualifyStageExternal, bcmFieldQualifyMplsForwardingLabelExp, bcmFieldQualifyMplsForwardingLabelId, bcmFieldQualifyMplsForwardingLabelBos, bcmFieldQualifyVrf, bcmFieldQualifyDstIp }},
/*~key*/{ _BCM_DPP_FLP_CLASS_IPV6_EXTENDED,        _BCM_DPP_INTERNAL_TABLE_ID_EXTENDED_IPV6,         -1,      3,   {bcmFieldQualifyStageExternal, bcmFieldQualifyVrf, bcmFieldQualifyDstIp6}},
/*~key*/{ _BCM_DPP_FLP_CLASS_P2P_EXTENDED,         _BCM_DPP_INTERNAL_TABLE_ID_EXTENDED_P2P,          -1,      2,   {bcmFieldQualifyStageExternal, bcmFieldQualifyInVPort}},
        { _BCM_DPP_FLP_CLASS_IPV4_MC_FLEXIBLE,     _BCM_DPP_INTERNAL_TABLE_ID_EXTENDED_IPV4_MC,      -1,      5,   {bcmFieldQualifyStageExternal, bcmFieldQualifyVrf, bcmFieldQualifyL3Ingress,  bcmFieldQualifySrcIp, bcmFieldQualifyDstIp}},
        { _BCM_DPP_FLP_CLASS_INRIF_MAPPING,        _BCM_DPP_INTERNAL_TABLE_ID_INRIF_MAPPING,         -1,      2,   {bcmFieldQualifyStageExternal, bcmFieldQualifyL3Ingress}},
        { _BCM_DPP_FLP_CLASS_IVL_LEARN,            SOC_DPP_DBAL_SW_TABLE_ID_IVL_LEARN_LEM,           -1,      3,   {bcmFieldQualifyForwardHdrSrcMac, bcmFieldQualifyForwardingVlanId, bcmFieldQualifyForwardHdrVlanId}},
};

/* BCM layer action to define if it is valid or nor according to sys property */ 
uint8 flp_predefined_groups_status[BCM_MAX_NUM_UNITS][_BCM_DPP_FLP_CLASS_COUNT] = {{_BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE}}; /* _BCM_DPP_PREDEF_GRP_STATUS_UNAVAILABLE must be 0*/


/* Max number of possible TCAM entries to configure before installing to HW.
   Limit applies to external TCAM only. */
#ifndef _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES
#define _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit)     SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit)
#endif


#define  _BCM_DPP_FIELD_FHEI_SIZE_0_BYTES (0)
#define  _BCM_DPP_FIELD_FHEI_SIZE_3_BYTES (3)
#define  _BCM_DPP_FIELD_FHEI_SIZE_5_BYTES (5)
#define  _BCM_DPP_FIELD_FHEI_SIZE_8_BYTES (8)

#define  _BCM_DPP_FIELD_FHEI_SIZE_VALID(size) ( (size == _BCM_DPP_FIELD_FHEI_SIZE_0_BYTES) || \
                                                (size == _BCM_DPP_FIELD_FHEI_SIZE_3_BYTES) || \
                                                (size == _BCM_DPP_FIELD_FHEI_SIZE_5_BYTES) || \
                                                (size == _BCM_DPP_FIELD_FHEI_SIZE_8_BYTES) )

/******************************************************************************
 *
 *  Implementation exported functions and data
 */

static const bcm_mac_t _bcm_field_mac_all = {0xFF, 0xFF, 0xFF, 0xFF,
                                             0xFF, 0xFF};
static const bcm_ip6_t _bcm_field_ipv6_all = {0xFF, 0xFF, 0xFF, 0xFF,
                                              0xFF, 0xFF, 0xFF, 0xFF,
                                              0xFF, 0xFF, 0xFF, 0xFF,
                                              0xFF, 0xFF, 0xFF, 0xFF};
static const bcm_ip6_t _bcm_field_ipv6_low = {0x00, 0x00, 0x00, 0x00,
                                              0x00, 0x00, 0x00, 0x00,
                                              0xFF, 0xFF, 0xFF, 0xFF,
                                              0xFF, 0xFF, 0xFF, 0xFF};
static const bcm_ip6_t _bcm_field_ipv6_high = {0xFF, 0xFF, 0xFF, 0xFF,
                                               0xFF, 0xFF, 0xFF, 0xFF,
                                               0x00, 0x00, 0x00, 0x00,
                                               0x00, 0x00, 0x00, 0x00};


int
_bcm_dpp_proc_cntr_from_stat(_bcm_dpp_field_info_t *unitData,
                             int stat,
                             unsigned int *proc,
                             unsigned int *cntr)
{
    unsigned int procs;
    unsigned int cntrs;
    unsigned int eproc;
    unsigned int ecntr;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    _BCM_PETRA_PROC_CNTR_FROM_STAT(eproc, ecntr, stat);
    BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_diag_info_get(unit,
                                                          bcm_dpp_counter_diag_info_num_proc,
                                                          0,
                                                          &procs));
    if (eproc < procs) {
        BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_diag_info_get(unit,
                                                              bcm_dpp_counter_diag_info_counters,
                                                              eproc,
                                                              &cntrs));
    }
    if ((eproc >= procs) || 
        /* In Arad, possible Counter-Pointer size of 21b (for Stat-if) even if the Counter-Processor receives up to 15b */
        (SOC_IS_PETRAB(unit) && (ecntr >= cntrs))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d stat %08X is not valid"),
                          unit,
                          stat));
    }
    *proc = eproc;
    *cntr = ecntr;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_stat_from_proc_cntr
 *   Purpose
 *      encode stat id from proc and ctr
 *   Parameters
 *      (in) int            unit = the unit
 *      (in) unsigned int   proc = the processor
 *      (in) unsigned int   cntr = the cntr index
 *      (out)int            *stat
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if sccessful
 *                    BCM_E_* appropriately otherwise
 */
STATIC int
_bcm_dpp_stat_from_proc_cntr(_bcm_dpp_field_info_t *unitData,
                             unsigned int proc,
                             unsigned int cntr,
                             int *stat) {

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    
    unit = unitData->unit;

    _BCM_PETRA_STAT_FROM_PROC_CNTR(*stat, proc, cntr);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_entry_ppd_to_bcm
 *   Purpose
 *      Given a PPD entry ID (hwHandle) find the corresponding BCM entry ID.
 *   Parameters
 *    (in) unitData = the unit information
 *    (in) hwHandle = the PPD entry ID
 *    (out) bcm_entry = the BCM entry ID
 *    (out) found = indication if entry was founds
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 */
int
_bcm_dpp_field_entry_ppd_to_bcm(int unit,
                                uint32 hwHandle,
                                bcm_field_entry_t *bcm_entry,
                                uint8 *found)
{
    int ent_index;

    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    *found = FALSE;

    /* for each valid BCM entry, check if the corresponding
     * PPD entry is the one we're looking for
     */
    for ( ent_index = 0;
          ent_index < unitData->entryTcLimit;
          ent_index++ )
    {
        if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, ent_index)
            && _BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, ent_index))
        {
            if (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(FALSE, ent_index) & _BCM_DPP_FIELD_ENTRY_IN_USE)
            {
                if(_BCM_DPP_FIELD_TCAM_ENTRY_HW_HANDLE(FALSE, ent_index) == hwHandle)
                {
                    *bcm_entry = ent_index;
                    *found = TRUE;
                    break;
                }
            }
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_entry_common_pointer(_bcm_dpp_field_info_t *unitData,
                                    bcm_field_entry_t entry,
                                    _bcm_dpp_field_entry_common_t **entryCommon,
                                    _bcm_dpp_field_entry_common_ext_t **entryExtCommon,
                                    _bcm_dpp_field_entry_type_t *entryType)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    
    unit = unitData->unit;
    
    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        if(_BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, entry)) {
            if (entryCommon) {
                *entryCommon = &(unitData->entryTc[_BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry)].entryCmn);
            }
            if (entryType) {
                *entryType = _bcmDppFieldEntryTypeInternalTcam;
            }
        } else {
            if (entryCommon) {
                *entryExtCommon = &(unitData->entryExtTc[_BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry)].entryCmn);
            }

            if (entryType) {
                *entryType = _bcmDppFieldEntryTypeExternalTcam;
            }
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                  entry))  {
        if (entryCommon) {
            *entryCommon = &(unitData->entryDe[entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)].entryCmn);
        }
        if (entryType) {
            *entryType = _bcmDppFieldEntryTypeDirExt;
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d is not valid"),
                          unit,
                          entry));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_petra_field_unit_reset
 *   Purpose
 *      Reset the state of the unit at the PPD layer
 *   Parameters
 *      (in) int unit = the unit to reset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if sccessful
 *                    BCM_E_* appropriately otherwise
 *   Notes
 *      This scans the PPD layer and frees resources.  It should not be used
 *      for detach, but must be used for cold init.
 *
 *      Assumes PPD sets up PFG 4 and DB 127 on Soc_petraB.
 *
 *      Only returns last error if more than one occurs.
 */
STATIC int
_bcm_petra_field_unit_reset(int unit)
{
    
    int result;
    int auxRes = BCM_E_NONE;
    uint32 handle;
    uint32 soc_sandResult;
    uint32 soc_sandIndex;
    uint32 soc_sandOffset;
    uint8 okay;
    SOC_PPD_FP_DATABASE_INFO dbInfo;
    SOC_PPD_FP_ENTRY_INFO entInfo;
    unsigned int entries;
    unsigned int groups;
    const _bcm_dpp_field_device_info_t *devInfo;
    BCMDNX_INIT_FUNC_DEFS;

    /* get the descriptor for this device */
#ifdef BCM_PETRAB_SUPPORT
    if (SOC_IS_PETRAB(unit)) {
		{
			devInfo = &_bcm_petra_field_device_info;
		}
    } else
#endif /* def BCM_PETRAB_SUPPORT */
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        devInfo = &_bcm_arad_field_device_info;
    } else
#endif /* def BCM_ARAD_SUPPORT*/
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("not supported")));
    }

    handle = (unit);
    entries = SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
    groups = _BCM_PETRA_FIELD_GROUP_LIMIT(unit);
#ifdef BCM_PETRAB_SUPPORT
    if (SOC_IS_PETRAB(unit)) {
        if (soc_pb_pp_sw_db_ipv4_host_extend_enable_get(handle)) {
            /* top group is reserved for IPv4 host expansion */
            groups--;
        }
    }
#endif /* def BCM_PETRAB_SUPPORT */
    /* walk the databases and destroy their entries, then the databases */
    for (soc_sandIndex = 0; soc_sandIndex < groups; soc_sandIndex++) {
        SOC_PPD_FP_DATABASE_INFO_clear(&dbInfo);
        soc_sandResult = soc_ppd_fp_database_get(handle,
                                                 soc_sandIndex,
                                                 &dbInfo);
        result = handle_sand_result(soc_sandResult);
        if (BCM_E_NONE == result) {
            if (SOC_PPD_NOF_FP_DATABASE_TYPES > dbInfo.db_type) {
                /* the type is valid, so it's in use[?] */
                if ((SOC_PPD_FP_DB_TYPE_TCAM == dbInfo.db_type) ||
                    (SOC_PPD_FP_DB_TYPE_EGRESS == dbInfo.db_type)) {
                    for (soc_sandOffset = 0;
                         soc_sandOffset < entries;
                         soc_sandOffset++) {
                        SOC_PPD_FP_ENTRY_INFO_clear(&entInfo);
                        soc_sandResult = soc_ppd_fp_entry_get(handle,
                                                              soc_sandIndex,
                                                              soc_sandOffset,
                                                              &okay,
                                                              &entInfo);
                        result = handle_sand_result(soc_sandResult);
                        if ((BCM_E_NONE == result) && okay) {
                            soc_sandResult = soc_ppd_fp_entry_remove(handle,
                                                                     soc_sandIndex,
                                                                     soc_sandOffset,
                                                                     0);
                            result = handle_sand_result(soc_sandResult);
                            if (BCM_E_NONE != result) {
                                LOG_ERROR(BSL_LS_BCM_FP,
                                          (BSL_META_U(unit,
                                                      "unable to destroy unit"
                                                      " %d database %d entry"
                                                      " %d: %d (%s)\n"),
                                           unit,
                                           soc_sandIndex,
                                           soc_sandOffset,
                                           result,
                                           _SHR_ERRMSG(result)));
                                auxRes = result;
                            }
                        } else { /* if ((BCM_E_NONE == result) && okay) */
                            LOG_ERROR(BSL_LS_BCM_FP,
                                      (BSL_META_U(unit,
                                                  "unable to get unit %d"
                                                  " database %d entry %d:"
                                                  " %d (%s)\n"),
                                       unit,
                                       soc_sandIndex,
                                       soc_sandOffset,
                                       result,
                                       _SHR_ERRMSG(result)));
                            auxRes = result;
                        } /* if ((BCM_E_NONE == result) && okay) */
                    } /* for (soc_sandOffset = 0; soc_sandOffset < 4K; soc_sandOffset++) */
                    soc_sandResult = soc_ppd_fp_database_destroy(handle,
                                                                 soc_sandIndex);
                    result = handle_sand_result(soc_sandResult);
                    if (BCM_E_NONE != result) {
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unable to destroy unit %d"
                                              " database %d: %d (%s)\n"),
                                   unit,
                                   soc_sandIndex,
                                   result,
                                   _SHR_ERRMSG(result)));
                        auxRes = result;
                    }
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d database %d is unexpected"
                                          " type %d\n"),
                               unit,
                               soc_sandIndex,
                               dbInfo.db_type));
                    auxRes = BCM_E_INTERNAL;
                }
            } /* if (SOC_PPD_NOF_FP_DATABASE_TYPES > dbInfo.db_type) */
        } else { /* if (BCM_E_NONE == result) */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to access unit %d database %d:"
                                  " %d (%s)\n"),
                       unit,
                       soc_sandIndex,
                       result,
                       _SHR_ERRMSG(result)));
            auxRes = result;
        } /* if (BCM_E_NONE == result) */
    } /* for (soc_sandIndex = 0; soc_sandIndex < 128; soc_sandIndex++) */
    /* clear data field qualifier definitions */
    result = _bcm_petra_field_data_qualifier_reset(unit);
    if (BCM_E_NONE != result) {
        auxRes = result;
    }
    /* clear range definitions */
    result = _bcm_dpp_field_range_reset(unit, handle, devInfo);
    if (BCM_E_NONE != result) {
        auxRes = result;
    }
    /* clear PFG definitions */
    result = _bcm_dpp_field_presel_reset(unit);
    if (BCM_E_NONE != result) {
        auxRes = result;
    }

    BCMDNX_IF_ERR_EXIT(auxRes);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_clear_quals
 *  Purpose
 *     Clear qualifiers from an entry.
 *  Parameters
 *     (in) unitData = the unit information
 *     (out) quals = pointer to the entry's quals array
 *  Returns
 *     nothing
 *  Notes
 *     If the entry is in use, marks the entry as changed and the entry's group
 *     as containing changed entry/entries.
 */
STATIC void
_bcm_dpp_field_entry_clear_quals(_bcm_dpp_field_info_t *unitData,
                                 _bcm_dpp_field_qual_t *quals)
{
    unsigned int index;

    sal_memset(quals,
               0x00,
               sizeof(quals[0]) * SOC_PPD_FP_NOF_QUALS_PER_DB_MAX);
    for (index = 0; index < SOC_PPD_FP_NOF_QUALS_PER_DB_MAX; index++) {
        quals[index].qualType = bcmFieldQualifyCount;
        quals[index].hwType = SOC_PPD_NOF_FP_QUAL_TYPES;
    }
}

/*
 *  Function
 *     _bcm_dpp_field_ext_info_entry_clear
 *  Purpose
 *     Clear external TCAM info entry.
 *  Parameters
 *     (out) ext_entry = pointer to the info entry
 *  Returns
 *     nothing
 *  Notes
 */
void
_bcm_dpp_field_ext_info_entry_clear(_bcm_dpp_field_entry_ext_info_t *ext_entry)
{
    unsigned int index;

    sal_memset(ext_entry, 0, sizeof(_bcm_dpp_field_entry_ext_info_t));

    for (index = 0; index < SOC_PPD_FP_NOF_QUALS_PER_DB_MAX; index++) {
        ext_entry->entryQual[index].qualType = bcmFieldQualifyCount;
        ext_entry->entryQual[index].hwType = SOC_PPD_NOF_FP_QUAL_TYPES;
    }
    for (index = 0; index < _BCM_DPP_NOF_BCM_ACTIONS_PER_DB_MAX; index++) {
        ext_entry->tcActB[index].bcmType = bcmFieldActionCount;
    }
    for (index = 0; index < SOC_PPD_FP_NOF_ACTIONS_PER_DB_MAX; index++) {
        ext_entry->tcActP[index].hwType = SOC_PPD_FP_ACTION_TYPE_INVALID;
    }
}

/*
 *  Function
 *     _bcm_dpp_field_group_hardware_remove
 *  Purpose
 *     Remove a group from hardware
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 */
STATIC int
_bcm_dpp_field_group_hardware_remove(_bcm_dpp_field_info_t *unitData,
                                     _bcm_dpp_field_grp_idx_t group)
{
    _bcm_dpp_field_group_t *groupData;
    uint32 ppdr;
    int result = BCM_E_NONE;
    unsigned int index;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    
    groupData = &(unitData->groupD[group]);
    if (0 == (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u not in use"),
                          unit,
                          group));
    }
    if (0 == (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW)) {
        /* nothing to do; it's already not in hardware */
        BCM_EXIT;
    }
    if (groupData->entryCount) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u entries must be"
                                           " removed first"),
                          unit,
                          group));
    }
    if (SHR_BITGET(groupData->pqset, SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED) &&
        (groupData->cascadePair < unitData->groupLimit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u is second in a"
                                           " cascade pair with group %u, which"
                                           " must be removed first"),
                          unit,
                          group,
                          groupData->cascadePair));
    }
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW) {
        /* must destroy existing group first */
		{
			ppdr = soc_ppd_fp_database_destroy(unitData->unitHandle, groupData->hwHandle);
			result = handle_sand_result(ppdr);
		}
        if (BCM_E_NONE == result) {
            if (SHR_BITGET(groupData->paset, SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY)) {
                /* adjust cascade information for this group & its pair */
                unitData->groupD[groupData->cascadePair].cascadePair = unitData->groupLimit;
                unitData->groupD[groupData->cascadePair].groupFlags &= (~_BCM_DPP_FIELD_GROUP_CASCADE);
                groupData->cascadePair = unitData->groupLimit;
                groupData->groupFlags &= (~_BCM_DPP_FIELD_GROUP_CASCADE);
            }
            groupData->groupFlags &= (~_BCM_DPP_FIELD_GROUP_IN_HW);
#ifdef BCM_WARM_BOOT_SUPPORT
            _bcm_dpp_field_group_wb_save(unitData, group, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */
            result = shr_mres_free(unitData->hwResIds,
                                   unitData->stageD[groupData->stage].groupRes,
                                   1 /* count */,
                                   groupData->hwHandle);
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unable to free unit %d group hardware"
                                      " ID %d: %d (%s)\n"),
                           unit,
                           groupData->hwHandle,
                           result,
                           _SHR_ERRMSG(result)));
            }
            /* release reference to cascaded features */
            if ((SHR_BITGET(groupData->pqset, SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) ||
                (SHR_BITGET(groupData->paset, SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY))) {
                unitData->groupCascaded--;
            }
            /* account for removing preselectors that were used before */
            for (index = 0; index < unitData->preselLimit; index++) {
                if (BCM_FIELD_PRESEL_TEST(groupData->preselHw, index)) {
                    unitData->preselRefs[index]--;
                }
            }
            /* dispose of any preselectors no longer implied */
#ifdef BCM_PETRAB_SUPPORT
            if (SOC_IS_PETRAB(unit)) {
                /* PetraB needs implied preselectors; Arad does not */
                result = _bcm_dpp_field_presel_implied_teardown(unitData,
                                                                groupData);
            } /* if (SOC_IS_PETRAB(unit) */
#endif /* def BCM_PETRAB_SUPPORT */
            /* called function displayed diagnostics */
#ifdef BCM_WARM_BOOT_SUPPORT
            _bcm_dpp_field_presel_all_wb_save(unitData, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */
        } else {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to remove unit %d group %d from"
                                  " hardware: %d (%s)\n"),
                       unit,
                       group,
                       result,
                       _SHR_ERRMSG(result)));
            BCMDNX_IF_ERR_EXIT(result);
        }
    } /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_HW) */
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_destroy
 *  Purpose
 *     Destroy a group, after destroying all its entries
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 */
STATIC int
_bcm_dpp_field_group_destroy(_bcm_dpp_field_info_t *unitData,
                             _bcm_dpp_field_grp_idx_t group)
{
    int result = BCM_E_NONE;
    _bcm_dpp_field_group_t *groupData = &(unitData->groupD[group]);
    _bcm_dpp_field_stage_t *stageData = &(unitData->stageD[groupData->stage]);
    _bcm_dpp_field_ent_idx_t entry;
    _bcm_dpp_field_ent_idx_t nextEntry;
    _bcm_dpp_field_entry_type_t entryType;    
    int index;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d(%08X),%d) enter (%s,%s)\n"),
               unit,
               PTR_TO_INT(unitData),
               group,
               (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE)?"+IN_USE":"-in_use",
               (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW)?"+IN_HW":"-in_hw"));
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        entryType = unitData->stageD[groupData->stage].modeBits[groupData->grpMode]->entryType;
        /* remove this group's entries from the PPD */
        nextEntry = groupData->entryHead;
        switch (entryType) {
        case _bcmDppFieldEntryTypeDirExt:
            while ((BCM_E_NONE == result) &&
                   (nextEntry < unitData->entryDeLimit)) {
                entry = nextEntry;
                nextEntry = unitData->entryDe[entry].entryCmn.entryNext;
                result = _bcm_dpp_field_dir_ext_entry_destroy(unitData, entry);
            }
            break;
		default:
			{
				while ((BCM_E_NONE == result) &&
                       (nextEntry < _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType))) {
					entry = nextEntry;
					nextEntry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
					result = _bcm_dpp_field_tcam_entry_destroy(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
				}
			}
		}
        if (BCM_E_NONE != result) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to destroy all entries in unit"
                                  " %d group %d: %d (%s)\n"),
                       unit,
                       group,
                       result,
                       _SHR_ERRMSG(result)));
        } else { /* if (BCM_E_NONE != result) */
            result = _bcm_dpp_field_group_hardware_remove(unitData, group);
        } /* if (BCM_E_NONE != result) */
        if (BCM_E_NONE == result) {
            if (groupData->groupPrev < unitData->groupLimit) {
                unitData->groupD[groupData->groupPrev].groupNext = groupData->groupNext;
            } else {
                stageData->groupHead = groupData->groupNext;
            }
            if (groupData->groupNext < unitData->groupLimit) {
                unitData->groupD[groupData->groupNext].groupPrev = groupData->groupPrev;
            } else {
                stageData->groupTail = groupData->groupPrev;
            }
            groupData->groupNext = unitData->groupFree;
            groupData->groupPrev = unitData->groupLimit;
            groupData->cascadePair = unitData->groupLimit;
            groupData->groupFlags = 0;
            if (unitData->groupFree < unitData->groupLimit) {
                unitData->groupD[unitData->groupFree].groupPrev = group;
            }
            unitData->groupFree = group;
            unitData->groupCount--;
            unitData->stageD[stageData->groupSh1].groupCount--;
            /* account for the group's references to programmable fields */
            for (index = 0; index < unitData->dqLimit; index++) {
                if (SHR_BITGET(groupData->qset.udf_map, index)) {
                    unitData->dataFieldRefs[index]--;
                }
            }
#ifdef BCM_WARM_BOOT_SUPPORT
            _bcm_dpp_field_datafield_all_wb_save(unitData, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */
        } /* if (BCM_E_NONE == result) */
    } else { /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_USE) */
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    } /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_USE) */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d(%08X),%d) return %d (%s)\n"),
               unit,
               PTR_TO_INT(unitData),
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_unit_destroy
 *  Purpose
 *     Destroy all resources used by a unit (except the unit descriptor)
 *  Parameters
 *     (in) unitData = unit information
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 *     Does not destroy the unit descriptor (caller must do that if success).
 */
STATIC int
_bcm_dpp_field_unit_destroy(_bcm_dpp_field_info_t *unitData)
{
    int result = BCM_E_NONE;

/* writing to hw is not needed and not allowed during deinit */

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d(%08X)) enter\n"),
               unitData?unitData->unit:-1,
               PTR_TO_INT(unitData)));
    if (unitData) {
        unit = unitData->unit;

/* writing to hw is not needed and not allowed during deinit */
        /* destroy the lock */
        if (BCM_E_NONE == result) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "destroy HW resoruce ID lists\n")));
            result = shr_mres_destroy(unitData->hwResIds);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "destroy lock\n")));
            sal_mutex_destroy(unitData->unitLock);
            unitData->unitLock = NULL;
        }
    } else { /* if (unitData) */
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit is not in use\n")));
        result = BCM_E_INIT;
    } /* if (unitData) */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d(%08X)) return %d (%s)\n"),
               unitData?unitData->unit:-1,
               PTR_TO_INT(unitData),
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_detach
 *  Purpose
 *     Shut down the field APIs on the unit
 *  Parameters
 *     (in) int unit = the unit number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 *     Assumes caller has already taken global lock
 */
STATIC int
_bcm_dpp_field_detach(int unit)
{
    int result;
    uint32 soc_sand_rv;

    _bcm_dpp_field_info_t *tempData = _bcm_dpp_field_unit_info[unit];

    BCMDNX_INIT_FUNC_DEFS;
    /* disconnect while trying to do this */
    _bcm_dpp_field_unit_info[unit] = NULL;

    if (tempData) {
        
        result = _bcm_dpp_field_unit_destroy(tempData);
        if (BCM_E_NONE != result) {
            /* failed to destroy this unit; link it back */
            _bcm_dpp_field_unit_info[unit] = tempData;
        } else {
            if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                soc_sand_rv = soc_sand_occ_bm_destroy(unit, tempData->extTcamBmp);
                result = handle_sand_result(soc_sand_rv);
                if (BCM_E_NONE != result) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_INIT, (_BSL_BCM_MSG("failed to destroy occupation bitmap")));
                }
            }
            /* free the memory from the unit information */
           BCM_FREE(tempData);
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INIT, (_BSL_BCM_MSG("not initialised")));
    }

    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_quals_to_ppd
 *  Purpose
 *     Convert a BCM qset into a set of PPD qualifiers
 *  Parameters
 *     (in) unitData = unit information
 *     (in) stage = stage for the group
 *     (in) type = type for the group
 *     (in) qset = BCM qset
 *     (out) ppdqset = PPD qset
 *     (out) apisize = number of bits of qualifiers
 *     (out) hwsize = number of trits of TCAM space or similar
 *  Returns
 *     nothing
 *  Notes
 */
STATIC int
_bcm_dpp_field_quals_to_ppd(_bcm_dpp_field_info_t *unitData,
                            _bcm_dpp_field_stage_idx_t stage,
                            uint32 types,
                            bcm_field_qset_t qset,
                            _bcm_dpp_field_qual_set_t *ppdqset,
                            unsigned int *apisize,
                            unsigned int *hwsize)
{
    bcm_field_qualify_t qualId;
    unsigned int index;
    unsigned int hwBits = 0;
    unsigned int apiBits = 0;
    unsigned int hwBitsTemp;
    unsigned int apiBitsTemp;
    SOC_PPD_FP_QUAL_TYPE *qualChain;
    SOC_PPD_FP_QUAL_TYPE qualType;
    int result = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    
    unit = unitData->unit;

    /* scan qset and include PPD qset bits for each standard one */
    sal_memset(ppdqset, 0x00, sizeof(*ppdqset));
    for (qualId = 0;
         (BCM_E_NONE == result) && (qualId < bcmFieldQualifyCount);
         qualId++) {
        if (BCM_FIELD_QSET_TEST(qset, qualId)) {
            result = _bcm_dpp_ppd_qual_from_bcm_qual(unitData,
                                                     stage,
                                                     types,
                                                     qualId,
                                                     &qualChain);
            if (BCM_E_NONE == result) {
                for (index = 0;
                     index < unitData->devInfo->qualChain;
                     index++ ) {
                    if (_BCM_DPP_FIELD_PPD_QUAL_VALID(qualChain[index])) {
                        SHR_BITSET(*ppdqset, qualChain[index]);
                    }
                } /* for (all qualifiers in chain) */
            } /* if (BCM_E_NONE == result) */
        } /* if (BCM_FIELD_QSET_TEST(qset,  qualId)) */
    } /* for (all qualifiers in qset as long as no error) */

    /* scan qset and include PPD qset bits for each programmable one */
    for (index = 0;
         (BCM_E_NONE == result) && (index < unitData->dqLimit);
         index++) {
        if (SHR_BITGET(qset.udf_map, index)) {
            if (!SHR_BITGET(unitData->dataFieldInUse, index)) {
                /*
                 *  This is not paranoia at this point, though it might seem to
                 *  be: it is possible that the data qualifier was created,
                 *  added to the QSET and then destroyed.  Since we can not
                 *  track references based upon QSET (the application can
                 *  create and destroy these at whim), the reference count is
                 *  based upon actual groups using the qualifier, and so a data
                 *  qualifier can be deleted as long as no group in hardware is
                 *  actually using it.
                 */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d udf %d is not in use but"
                                      " qset tries to refer to it\n"),
                           unit,
                           index));
                result = BCM_E_CONFIG;
            }
            if (BCM_E_NONE == result) {
                result = _bcm_petra_field_map_bcm_udf_to_ppd(unitData,
                                                             index,
                                                             &qualType);
            }
            if (BCM_E_NONE == result) {
                SHR_BITSET(*ppdqset, qualType);
            }
        } /* if (SHR_BITGET(qset.udf_map, index)) */
    } /* for (all valid programmable qualifiers as long as no error) */

    if (BCM_E_NONE == result) {
        /* count bits based upon PPD qset sizes */
        for (qualType = 0; qualType < SOC_PPD_NOF_FP_QUAL_TYPES; qualType++) {
            if (SHR_BITGET((*ppdqset), qualType)) {
                result = _bcm_dpp_ppd_qual_bits(unitData,
                                                stage,
                                                qualType,
                                                &apiBitsTemp,
                                                &hwBitsTemp,
                                                NULL);
                if (BCM_E_NONE == result) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "PPD qualifier ID %d (%s) in stage %u"
                                          " types %08X: %u API, %u hw\n"),
                               qualType,
                               SOC_PPD_FP_QUAL_TYPE_to_string(qualType),
                               stage,
                               types,
                               apiBitsTemp,
                               hwBitsTemp));
                    apiBits += apiBitsTemp;
                    hwBits += hwBitsTemp;
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d unable to determine number"
                                          " of bits in PPD qualifier %d (%s) in"
                                          " stage %u types %08X: %d (%s)\n"),
                               unit,
                               qualType,
                               SOC_PPD_FP_QUAL_TYPE_to_string(qualType),
                               stage,
                               types,
                               result,
                               _SHR_ERRMSG(result)));
                }
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "include PPD qualifier %d (%s), bits ="
                                      " %u api, %u hw\n"),
                           qualType,
                           SOC_PPD_FP_QUAL_TYPE_to_string(qualType),
                           apiBitsTemp,
                           hwBitsTemp));
            } /* if (SHR_BITGET((*ppdqset), qualType)) */
        } /* for (all PPD layer qualifier types) */
    } /* if (BCM_E_NONE == result) */
    if (BCM_E_NONE == result) {
        if (apisize) {
            *apisize = apiBits;
        }
        if (hwsize) {
            *hwsize = hwBits;
        }
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "total size = %u api, %u hw\n"),
                   apiBits,
                   hwBits));
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_ppd_field_actions_to_ppd
 *  Purpose
 *     Convert a BCM aset into a set of PPD actions
 *  Parameters
 *     (in) unitData = unit information
 *     (in) stage = stage for the group
 *     (in) type = type for the group
 *     (in) aset = BCM aset
 *     (out) ppdaset = PPD aset
 *     (out) size = number of actions included
 *  Returns
 *     nothing
 *  Notes
 */
STATIC void
_bcm_dpp_field_actions_to_ppd(_bcm_dpp_field_info_t *unitData,
                              _bcm_dpp_field_stage_idx_t stage,
                              bcm_field_aset_t aset,
                              _bcm_dpp_field_action_set_t *ppdaset,
                              unsigned int *size)
{
    bcm_field_action_t actId;
    SOC_PPD_FP_ACTION_TYPE *actChain = NULL;
    SOC_PPD_FP_ACTION_TYPE ppdAct;
    unsigned int index;
    int result = BCM_E_NONE;
    int unit;

    unit = unitData->unit;


    /* scan aset and include PPD aset bits for each one */
    sal_memset(ppdaset, 0x00, sizeof(*ppdaset));
    for (actId = 0;
         (BCM_E_NONE == result) && (actId < bcmFieldActionCount);
         actId++) {
        if (BCM_FIELD_QSET_TEST(aset, actId)) {
            result = _bcm_dpp_ppd_act_from_bcm_act(unitData,
                                                   stage,
                                                   actId,
                                                   &actChain);
            if (BCM_E_NONE == result) {
                for (index = 0;
                     index < unitData->devInfo->actChain;
                     index++ ) {
                    if (_BCM_DPP_FIELD_PPD_ACTION_VALID(actChain[index])) {
                        SHR_BITSET(*ppdaset, actChain[index]);
                    }
                } /* for (all actions in chain) */
            } else { /* if (BCM_E_NONE == result) */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u unable to"
                                      " map action %d (%s) to PPD action:"
                                      " %d (%s); ignoring it\n"),
                           unit,
                           stage,
                           actId,
                           _bcm_dpp_field_action_name[actId],
                           result,
                           _SHR_ERRMSG(result)));
            } /* if (BCM_E_NONE == result) */
        } /* if (BCM_FIELD_ASET_TEST(aset, actId)) */
    } /* for (all actions in aset as long as no error) */

    /* count actions */
    *size = 0;
    for (ppdAct = 0; ppdAct < SOC_PPD_NOF_FP_ACTION_TYPES; ppdAct++) {
        if (SHR_BITGET((*ppdaset), ppdAct)) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "include PPD action %d (%s)\n"),
                       ppdAct,
                       SOC_PPD_FP_ACTION_TYPE_to_string(ppdAct)));
            (*size)++;
        }
    }
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "total actions %d\n"), *size));
}

/*
 *  Function
 *    _bcm_dpp_field_group_mode_from_size
 *  Purpose
 *    Figure out the mode according to the size of the qset in bits
 *  Parameters
 *    (in) unitData = unit information
 *    (in) stage = which stage to use
 *    (in) flags = flags to use
 *    (in) bits = number of pattern bits
 *    (out) mode = where to put the proper mode
 *  Returns
 *     (none)
 *  Notes
 *    Does not modify the value at mode unless autosize flag is set.
 */
STATIC void
_bcm_dpp_field_group_mode_from_size(_bcm_dpp_field_info_t *unitData,
                                    _bcm_dpp_field_stage_idx_t stage,
                                    uint32 flags,
                                    unsigned int bits,
                                    bcm_field_group_mode_t *mode)
{
    bcm_field_group_mode_t index;

    if (0 == (flags & _BCM_DPP_FIELD_GROUP_AUTO_SZ)) {
        return;
    }
    *mode = bcmFieldGroupModeAuto;
    for (index = 0; index < bcmFieldGroupModeCount; index++) {
        if (unitData->stageD[stage].modeBits[index] &&
            (_BCM_DPP_FIELD_ENT_TYPE_IS_TCAM(unitData->stageD[stage].modeBits[index]->entryType)) &&
            (bits <=
             unitData->stageD[stage].modeBits[index]->length)) {
            *mode = index;
            break;
        }
    } /* for (index = 0; index < bcmfieldGroupModeCount; index++) */
}

/*
 *  Function
 *     _bcm_dpp_field_group_vt_predefined_group_init
 *  Purpose
 *     Init the VT classification qset table according to classifications supported
 *  Parameters
 *     (in) qset = proposed group qset
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 *  Notes
 *     This is used by the group create and group set class functions.
 *
 *     Will clobber all out args even if error.
 */
STATIC void
_bcm_dpp_field_group_vt_predefined_group_init(int unit)
{
    if (soc_property_get(unit, spn_VLAN_TRANSLATION_MATCH_IPV4, FALSE) ) 
    {
		vt_predefined_groups_status[unit][_BCM_DPP_VT_CLASS_IPV4_MATCH] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst1", 0) ) 
    {
		vt_predefined_groups_status[unit][_BCM_DPP_VT_CLASS_EFP] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst2", 0) )
    {
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINQ_COMPRESSED_OUTER]      = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINQ_COMPRESSED_INNER]      = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINANY_OUTER]               = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINANY_INNER]               = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINANY_PCP_OUTER]           = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_QINANY_PCP_INNER]           = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_OUTER]                = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_INNER]                = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_COMPRESSED_OUTER]     = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_COMPRESSED_INNER]     = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_COMPRESSED_PCP_OUTER] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_DOT1Q_COMPRESSED_PCP_INNER] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_UNTAGGED]                   = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
        vt_predefined_groups_status[unit][_BCM_DPP_VT_TST2]                       = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
}

STATIC void
_bcm_dpp_field_group_flp_predefined_group_init(int unit)
{
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_ipv4_mpls_extended_fwd_table_size", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IPV4_MPLS_EXTENDED] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_ipv6_extended_fwd_table_size", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IPV6_EXTENDED] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_p2p_extended_fwd_table_size", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_P2P_EXTENDED] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_ipv4_mc_flexible_fwd_table", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IPV4_MC_FLEXIBLE] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "ext_inrif_mapping_table_size", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_INRIF_MAPPING] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "IVL_inlif_profile", 0)) {
        flp_predefined_groups_status[unit][_BCM_DPP_FLP_CLASS_IVL_LEARN] = _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE;
    }
}


/*
 *  Function
 *     _bcm_dpp_field_group_verify_vt_classification_qset
 *  Purpose
 *     Verify the provided qset is acceptable for a 5-tuple group
 *  Parameters
 *     (in) qset = proposed group qset
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 *  Notes
 *     This is used by the group create and group set class functions.
 *
 *     Will clobber all out args even if error.
 */
STATIC int
_bcm_dpp_field_group_verify_vt_classification_qset(int unit, bcm_field_qset_t qset, uint32 *vt_classification, uint8* found, uint32* flag)
{
    bcm_field_qset_t tqset;
    uint8 index , qual_index;
    int result = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    (*found) = FALSE;

    for (index = 0; index < _BCM_DPP_VT_CLASS_COUNT ; index++ ) {
        if ( vt_predefined_groups_status[unit][index] != _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE) {
            continue;
        }

        BCM_FIELD_QSET_INIT(tqset);

        for (qual_index = 0 ; qual_index < vt_predefined_groups_info[index].nof_quals ; qual_index++ ){
            BCM_FIELD_QSET_ADD(tqset, vt_predefined_groups_info[index].bcmQual_array[qual_index]);
        }

        result =  sal_memcmp(&qset,&tqset,sizeof(bcm_field_qset_t));

        if ( BCM_E_NONE == result ) {
            (*found) = TRUE; /*qset is found*/
            (*vt_classification) = vt_predefined_groups_info[index].internal_table_id;
            if ( (vt_predefined_groups_info[index].table_type == _BCM_DPP_VT_CLASS_EFP) ||
                  (vt_predefined_groups_info[index].table_type == _BCM_DPP_VT_CLASS_IPV4_MATCH)) {
            (*flag) = _BCM_DPP_FIELD_GROUP_STAGE_VT_EXTENDED;
            } else {
                (*flag) = _BCM_DPP_FIELD_GROUP_USE_DBAL;
            }
            vt_predefined_groups_status[unit][index] = _BCM_DPP_PREDEF_GRP_STATUS_IN_USE;
            break;
        }
    }
        
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_dpp_field_group_verify_flp_classification_qset(int unit, bcm_field_qset_t qset, uint32 *internal_table_id, uint8* found, uint32* flag)
{
    bcm_field_qset_t tqset;
    uint8 index , qual_index;
    int result = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    (*found) = FALSE;

    for (index = 0; index < _BCM_DPP_FLP_CLASS_COUNT ; index++ ) {
        if ( flp_predefined_groups_status[unit][index] !=  _BCM_DPP_PREDEF_GRP_STATUS_READY_TO_USE) {
            continue;
        }

        BCM_FIELD_QSET_INIT(tqset);

        for (qual_index = 0 ; qual_index < flp_predefined_groups_info[index].nof_quals ; qual_index++ ){
            BCM_FIELD_QSET_ADD(tqset, flp_predefined_groups_info[index].bcmQual_array[qual_index]);
        }

        result = sal_memcmp(&qset, &tqset, sizeof(bcm_field_qset_t)); /* is qset identical*/

        if ( 0 == result ) {
            (*found) = TRUE; /*qset is found*/
            (*internal_table_id) = flp_predefined_groups_info[index].internal_table_id;
            flp_predefined_groups_status[unit][index] =  _BCM_DPP_PREDEF_GRP_STATUS_IN_USE;
            
            if ( (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_IPV4_MPLS_EXTENDED) || 
                  (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_IPV4_MC_FLEXIBLE) || 
                  (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_IPV6_EXTENDED) || 
                  (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_P2P_EXTENDED)  || 
				  (flp_predefined_groups_info[index].table_type == _BCM_DPP_FLP_CLASS_INRIF_MAPPING)) {
                (*flag) = _BCM_DPP_FIELD_GROUP_EXTENDED_DATABASES;
            } else {                       
                (*flag) = _BCM_DPP_FIELD_GROUP_USE_DBAL;
            }
            break;
        }
    }

    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_verify_qset
 *  Purpose
 *     Verify the provided qset is acceptable for a group
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = proposed group ID
 *     (in) qset = proposed group qset
 *     (in) mode = proposed group mode
 *     (out) tqset = where to put adjusted qset (if successful)
 *     (out) flags = where to put flags for the group (if successful)
 *     (out) stage = where to put stage for the group (if successful)
 *     (out) type = where to put type for the group (if successful)
 *     (out) predefKey = where to put predef key index (if successful)
 *     (out) apiWidth = where to put API width of group (if successful)
 *     (out) hwWidth = where to put HW width of group (if successful)
 *     (out) ppdqset = where to put PPD qset of group (if successful)
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 *  Notes
 *     This is used by the group create and group set class functions.
 *
 *     Will clobber all out args even if error.
 */
STATIC int
_bcm_dpp_field_group_verify_qset(_bcm_dpp_field_info_t *unitData,
                                 _bcm_dpp_field_grp_idx_t group,
                                 bcm_field_qset_t qset,
                                 bcm_field_group_mode_t mode,
                                 bcm_field_qset_t *tqset,
                                 uint32 *flags,
                                 _bcm_dpp_field_stage_idx_t *stage,
                                 uint32 *types,
                                 SOC_PPD_FP_PREDEFINED_ACL_KEY *predefKey,
                                 unsigned int *apiWidth,
                                 unsigned int *hwWidth,
                                 _bcm_dpp_field_qual_set_t *ppdqset)
{
    SOC_PPD_FP_QUAL_TYPE tempPpdQuals[SOC_PPD_FP_NOF_QUALS_PER_DB_MAX];
    SOC_PPD_FP_QUAL_TYPE ppdQual;
    bcm_field_qset_t uqset;
    bcm_field_qset_t bqset;
    unsigned int uq0;
    unsigned int uq1;
    unsigned int uq2;
    unsigned int mapId;
    unsigned int index;
    unsigned int base;
    unsigned int awidth;
    unsigned int hwidth;
    uint32 ftypes = 0;
    uint32 tflags;
    int result = 0;
    _bcm_dpp_field_type_idx_t type;
    bcm_field_data_qualifier_t qual;
    bcm_field_stage_t bcmStage;
    uint32 soc_sand_rv;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    /* find a stage that fits the qset and the mode */
    if ((0 > mode) || (bcmFieldGroupModeCount <= mode)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("group mode %d is not valid"),
                          mode));
    }

    sal_memset(tempPpdQuals, 0x0, sizeof(tempPpdQuals));
    /*
     *  There are several types of groups here, based entriely upon the L3
     *  type implied by the qualifiers in the QSET, and the stage specified by
     *  the QSET (or assumed by the lack of such specification combined with
     *  the available qualifiers).
     *
     *  Unhappily, the mechanism is not so simple as to merely choose a type
     *  that is appropriate.  Types can be combined, except in cases where
     *  there are qualifier overlaps.  Right now, in BCM layer, the only
     *  qualifier overlaps of particular significance are between IPv4 and
     *  IPv6, specifically because these overlaps do not exist at PPD layer and
     *  so must be separated here.
     *
     *  In order to allow a single group to include qualifiers from more than
     *  one type, but not across stages or across, we need to be able to build
     *  supersets of the types, but avoid building supersets that span stages
     *  or that include both IPv4 and IPv6 qualifiers.
     *
     *  This is made more complicated by the fact that some stages have fixed
     *  qualifier sets and exactly one of those can be chosen for a group in
     *  such stages (types that can not be combined are noted in the hardware
     *  tables by having a predefined key specified -- those that can be
     *  combined specity SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS).
     */
    for (mapId = 0; mapId < unitData->devInfo->mappings; mapId++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %u checking stage %u (%s) type"
                              " %u (%s) map %u to see if it fits here...\n"),
                   unit,
                   group,
                   unitData->devInfo->stMapInfo[mapId].stmStage,
                   unitData->devInfo->stage[unitData->devInfo->stMapInfo[mapId].stmStage].stageName,
                   unitData->devInfo->stMapInfo[mapId].stmType,
                   unitData->devInfo->typeNames[unitData->devInfo->stMapInfo[mapId].stmType],
                   mapId));
        result = _bcm_dpp_field_qset_subset(unitData->stageD[unitData->devInfo->stMapInfo[mapId].stmStage].qsetType[unitData->devInfo->stMapInfo[mapId].stmType],
                                            qset);
        if (BCM_E_NONE == result) {
            if (bcmFieldGroupModeAuto == mode) {
                /* this one fits, and mode is auto; use this one */
                break;
            } else if (unitData->stageD[unitData->devInfo->stMapInfo[mapId].stmStage].modeBits[mode]) {
                /* this one fits, and requested mode supported; use it */
                break;
            }
        }
    } /* for (index = 0; index < unitData->devInfo->mappings; index++) */
    if (mapId < unitData->devInfo->mappings) {
        /*
         *  Found a stage+type mapping that covers the entire QSET; we don't
         *  need to try to combine things or look further than this; use it.
         */
        *stage = unitData->devInfo->stMapInfo[mapId].stmStage;
        *types = 1 << (unitData->devInfo->stMapInfo[mapId].stmType);
        *flags = unitData->devInfo->stMapInfo[mapId].stmFlags;
        (*flags) |= _BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_PHASE;
        *predefKey = unitData->devInfo->stMapInfo[mapId].predefKey;
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %u appears to fit in stage %u"
                              " (%s) as type %u (%s) -- map ID %u (%08X)\n"),
                   unit,
                   group,
                   *stage,
                   unitData->stageD[*stage].devInfo->stageName,
                   unitData->devInfo->stMapInfo[mapId].stmType,
                   unitData->devInfo->typeNames[unitData->devInfo->stMapInfo[mapId].stmType],
                   mapId,
                   *types));
    } else { /* if (mapId < unitData->devInfo->mappings) */
        /*
         *  The proposed QSET does not match a single stage/type mapping.
         *
         *  It is still possible to combine mappings, to a degree, to obtain a
         *  QSET that will cover the proposed QSET.
         *
         *  There are, however, limitations.
         *
         *  1: it is only possible to combine mappings within a single stage
         *
         *  2: it is not possible to combine mappings that use fixed QSETs
         *
         *  This is also a pretty rigorous check: it tries to verify every
         *  possible combination of types in every possible stage, skipping a
         *  combination only when a proposed combination of types is
         *  impossible for some reason (stage that can not possibly cover the
         *  proposed QSET, a type in a stage uses a fixed QSET, a type that is
         *  not used in a stage, or similar). Thankfully the number of stages
         *  is reasonable, and the number of types per stage is reasonable, so
         *  the procedure's O((#stages) * (2 ^ (#types))) behaviour is not
         *  quite as bad as it might seem.
         */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d unable to find a single stage+type"
                              " that covers proposed QSET; searching for"
                              " combinations of types within each stage\n"),
                   unit));
        *stage = unitData->devInfo->stages; /* best stage so far */
        *flags = 0; /* best flags so far */
        ftypes = 0; /* best stage bits so far (which types in stage) */
        awidth = ~0; /* smallest matching qset union so far (qual count) */
        hwidth = 0; /* best 'type' so far */
        sal_memset(&bqset, 0x00, sizeof(bqset)); /* best fit qset so far */
        *predefKey = SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS; /* no predef keys here */
        for (base = 0; base < unitData->devInfo->stages; base++) {
            result =  _bcm_dpp_field_qset_subset(unitData->stageD[base].stgQset,
                                                 qset);
            if (BCM_E_NONE != result) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u (%s) QSET does not"
                                      " cover all qualifiers in proposed"
                                      " QSET\n"),
                           unit,
                           base,
                           unitData->stageD[base].devInfo->stageName));
                continue;
            }
            if (0 == (unitData->stageD[base].devInfo->stageFlags &
                      _BCM_DPP_FIELD_DEV_STAGE_FLAG_ALLOW_TYPE_MERGE)) {
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u (%s) does not allow"
                                      " qualifier types to be merged\n"),
                           unit,
                           base,
                           unitData->stageD[base].devInfo->stageName));
                continue;
            }
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d stage %u (%s) checking"
                                  " combinations of types to match proposed"
                                  " QSET (%u combinations to check)\n"),
                       unit,
                       base,
                       unitData->stageD[base].devInfo->stageName,
                       1 << unitData->devInfo->types));
            for (ftypes = 0;
                 ftypes < (1 << unitData->devInfo->types);
                 ftypes++) {
                /* for all possible combinations of types in this stage */
                tflags = 0;
                sal_memset(&uqset, 0x00, sizeof(uqset));
                result = BCM_E_NONE;
                type = unitData->devInfo->types;
                for (index = 0; index < unitData->devInfo->types; index++) {
                    /* for all types possible in this stage */
                    if (ftypes & (1 << index)) {
                        /* this type was selected */
                        if (unitData->devInfo->mappings <=
                            unitData->stageD[base].ltOffset[index]) {
                            /* this type does not exist in this stage */
                            result = BCM_E_FAIL;
                            break;
                        }
                        if (SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS >
                            unitData->devInfo->stMapInfo[unitData->stageD[base].ltOffset[index]].predefKey) {
                            /* uses predefined key; can not combine */
                            result = BCM_E_FAIL;
                            break;
                        }
                        if (((_BCM_DPP_FIELD_GROUP_IPV4 & (tflags)) &&
                             (_BCM_DPP_FIELD_GROUP_IPV6 & unitData->devInfo->stMapInfo[unitData->stageD[base].ltOffset[index]].stmFlags)) ||
                            ((_BCM_DPP_FIELD_GROUP_IPV6 & (tflags)) &&
                             (_BCM_DPP_FIELD_GROUP_IPV4 & unitData->devInfo->stMapInfo[unitData->stageD[base].ltOffset[index]].stmFlags))) {
                            /*
                             *  This type includes IPv6 when we already have
                             *  IPv4, or the type includes IPv4 when we already
                             *  have IPv6; can not combine
                             */
                            result = BCM_E_FAIL;
                            break;
                        }
                        /* merge this stage+type flags and qset */
                        type = index;
                        tflags |= unitData->devInfo->stMapInfo[unitData->stageD[base].ltOffset[index]].stmFlags;
                        _bcm_dpp_field_qset_union(uqset,
                                                  unitData->stageD[base].qsetType[index],
                                                  &uqset);
                    } /* if (types & (1 << index)) */
                } /* for (index = 0; index < unitData->devInfo->types; index++) */
                if (BCM_E_NONE == result) {
                    /* this combination of types was valid; check matching */
                    _bcm_dpp_field_qset_subset_count(qset,
                                                     uqset,
                                                     &uq0,
                                                     &uq1,
                                                     &uq2);
                    if ((uq0 <= uq1) && (uq0 == uq2)) {
                        LOG_DEBUG(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unit %d stage %d (%s) types"
                                              " %08X is a candidate for use"
                                              " in matching proposed QSET:"
                                              " %u quals proposed, %u"
                                              " quals in union, flags"
                                              " %08X\n"),
                                   unit,
                                   base,
                                   unitData->stageD[base].devInfo->stageName,
                                   ftypes,
                                   uq0,
                                   uq1,
                                   tflags));
                        /* this union covers it; see if it's best so far */
                        if (uq1 < awidth) {
                            /* this is more compact than prior best; keep it */
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                      (BSL_META_U(unit,
                                                  "unit %d stage %d (%s)"
                                                  " types %08X is best"
                                                  " candidate so far for the"
                                                  " proposed QSET\n"),
                                       unit,
                                       base,
                                       unitData->stageD[base].devInfo->stageName,
                                       ftypes));
                            *stage = base;
                            *flags = tflags | (_BCM_DPP_FIELD_GROUP_IN_USE |
                                               _BCM_DPP_FIELD_GROUP_PHASE);
                            *types = ftypes;
                            awidth = uq1;
                            mapId = unitData->stageD[*stage].ltOffset[type];
                        }
                    } /* if ((uq0 <= uq1) && (uq0 == uq2)) */
                } /* if (BCM_E_NONE == result) */
            } /* for (all possible type combinations) */
        } /* for (base = 0; base < unitData->devInfo->stages; base++) */
    } /* if (mapId < unitData->devInfo->mappings) */
    if (mapId >= unitData->devInfo->mappings) {
        /*
         *  At this point, mapId would either be the single mapping that covers
         *  the proposed QSET, or it would be the last one out of a set of
         *  them to cover the proposed QSET.  In either case, if it is still
         *  not inside the range of valid mappings, could not find any way to
         *  map the proposed QSET to a stage/type combination.
         */
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d does not support a stage"
                                           " and type that includes the"
                                           " requested qset and mode"),
                          unit));
    } /* if (mapId >= unitData->devInfo->mappings) */

    /* Check that all the UDF's stage is the same as the QSET stage */
    _bcm_dpp_bcm_stage_from_ppd_stage(unitData, *stage, &bcmStage);
    for (index = 0;
         (index < BCM_FIELD_USER_NUM_UDFS) && (BCM_E_NONE == result);
         index++) {
        if (SHR_BITGET(qset.udf_map, index)) {
            BCMDNX_IF_ERR_EXIT(_bcm_petra_field_data_qualifier_get(unitData, index, &qual));
            if (bcmStage != qual.stage) {
                result = BCM_E_FAIL;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "stage of data field qualifier %d is "
                                      "not consistant with the qset's stage\n"),
                           index));
            }
        }
    }

    /* need to convert the BCM qset into a PPD qset */
    if (SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS <= (*predefKey)) {
        /* perform conversion based upon actual caller-provided qset */
        result = _bcm_dpp_field_quals_to_ppd(unitData,
                                             *stage,
                                             *types,
                                             qset,
                                             ppdqset,
                                             apiWidth,
                                             hwWidth);
        if (BCM_E_NONE == result) {
            for (ppdQual = 0, index = 0;
                 ppdQual < SOC_PPD_NOF_FP_QUAL_TYPES;
                 ppdQual++) {
                if (SHR_BITGET(*ppdqset, ppdQual)) {
                    if (unitData->devInfo->stage[*stage].entryMaxQuals >
                        index) {
                        tempPpdQuals[index] = ppdQual;
                    }
                    index++;
                }
            }
            if (unitData->devInfo->stage[*stage].entryMaxQuals <= index) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG_NO_UNIT("proposed qset will not fit"
                                                   " in unit %d stage %u: it"
                                                   " has more qualifiers %u"
                                                   " than allowed %u"),
                                  unit,
                                  *stage,
                                  index,
                                  unitData->devInfo->stage[*stage].entryMaxQuals));
            }
        } else { /* if (BCM_E_NONE == result) */
            BCMDNX_IF_ERR_EXIT_MSG(result,
                                (_BSL_BCM_MSG_NO_UNIT("unit %d unable to convert"
                                                  " qset to PPD: %d (%s)"),
                                 unit,
                                 result,
                                 _SHR_ERRMSG(result)));
        } /* if (BCM_E_NONE == result) */
    } else { /* if (SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS > (*predefKey)) */
        /* perform conversion based upon predefined key */
        SOC_PPD_FP_QUAL_TYPE_PRESET(unitData->unitHandle,
                                    *predefKey,
                                    &(tempPpdQuals[0]),
                                    soc_sand_rv);
        BCM_SAND_IF_ERR_EXIT_NO_UNIT(soc_sand_rv);
        sal_memset(ppdqset, 0x00, sizeof(*ppdqset));
        *apiWidth = 0;
        *hwWidth = 0;
        for (index = 0, result = BCM_E_NONE;
             (BCM_E_NONE == result) && (index < SOC_PPD_FP_NOF_QUALS_PER_DB_MAX);
             index++) {
            if (_BCM_DPP_FIELD_PPD_QUAL_VALID(tempPpdQuals[index])) {
                SHR_BITSET(*ppdqset, tempPpdQuals[index]);
                BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_ppd_qual_bits(unitData,
                                                           *stage,
                                                           tempPpdQuals[index],
                                                           &awidth,
                                                           &hwidth,
                                                           NULL),
                                    (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get"
                                                      " number of bits for"
                                                      " preset key %d qual"
                                                      " %s (%d) in stage %u"),
                                     unit,
                                     *predefKey,
                                     SOC_PPD_FP_QUAL_TYPE_to_string(tempPpdQuals[index]),
                                     tempPpdQuals[index],
                                     *stage));
                (*apiWidth) += awidth;
                (*hwWidth) += hwidth;
            }
        }
    } /* if (SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS > (*predefKey)) */

    /*
     *  Now, the list of PPD qualifiers and the PPD qset are aligned, and we
     *  are sure that they amount to a superset of the BCM qualifiers.  In
     *  order to avoid gratuitous state, and allow easier recovery, we go ahead
     *  and assume any BCM qualifiers implied by the PPD qualifier set.  This
     *  means, for each member of the PPD qualifier list, scanning the
     *  qualifier table and adding any BCM qualifiers that refer to that PPD
     *  qualifier in the selected stage and type to the BCM qualifier set.
     */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_qset_recover(unitData,
                                                              *stage,
                                                              *types,
                                                              ppdqset,
                                                              tqset));

    /* make sure the width makes sense */
    if (0 == *hwWidth) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("specified qset does not contain"
                                           " any normal qualifiers")));
    }
    if (bcmFieldGroupModeDirect == 
        unitData->stageD[*stage].modeBits[mode]->mode) {
        if (unitData->stageD[*stage].modeBits[mode]->length < *hwWidth) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG_NO_UNIT("specified qset is too wide %u"
                                               " for specified mode %d (%s) on"
                                               " unit %d stage %u, max %u"),
                              *hwWidth,
                              mode,
                              _bcm_dpp_field_group_mode_name[mode],
                              unit,
                              *stage,
                              unitData->stageD[*stage].modeBits[mode]->length));
        }
    }
    else if (_BCM_DPP_FIELD_ENT_TYPE_IS_TCAM(unitData->stageD[*stage].modeBits[mode]->entryType)) {
        /* TCAM groups must always fit in stage worst case max width */
        if (unitData->stageD[*stage].modeBits[bcmFieldGroupModeAuto]->length <
            *hwWidth) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG_NO_UNIT("specified qset is too wide %u"
                                               " for unit %d stage %u, max %u"),
                              *hwWidth,
                              unit,
                              *stage,
                              unitData->stageD[*stage].modeBits[bcmFieldGroupModeAuto]->length));
        }
#if _BCM_DPP_FIELD_ENFORCE_WIDTH
        /* optional check to force TCAM groups into 'mode' specified width */
        if (unitData->stageD[*stage].modeBits[mode]->length < *hwWidth) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG_NO_UNIT("specified qset is too wide %u"
                                               " for specified mode %d (%s) on"
                                               " unit %d stage %u, max %u"),
                              *hwWidth,
                              mode,
                              _bcm_dpp_field_group_mode_name[mode],
                              unit,
                              *stage,
                              unitData->stageD[*stage].modeBits[mode]->length));
        }
#endif /* _BCM_DPP_FIELD_ENFORCE_WIDTH */
    } else {
        if (SOC_IS_ARADPLUS(unit) 
            && (SHR_BITGET(*ppdqset, SOC_PPD_FP_QUAL_IS_EQUAL)
                || SHR_BITGET(*ppdqset, SOC_PPD_FP_QUAL_KEY_AFTER_HASHING))
            ) 
        {
            /* In ARAD+, in case this field group is for Compare operation,
             * key length can be up to 80 bits (Direct Extraction is max of 
             * 32 bits and in for the second field group, is taken from the 
             * MSB bits [128:159]). 
             */
            if (unitData->stageD[*stage].modeBits[bcmFieldGroupModeSingle]->length < *hwWidth)
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG_NO_UNIT("Specified qset is too wide %u "
                                                   "for specified mode %d (%s) when "
                                                   "flag IS_EQUAL is used on unit %d "
                                                   "stage %u, max %u"),
                                  *hwWidth,
                                  mode,
                                  _bcm_dpp_field_group_mode_name[mode],
                                  unit,
                                  *stage,
                                  unitData->stageD[*stage].modeBits[bcmFieldGroupModeSingle]->length));
            }
        }
        else{ 
            /* other group modes must fit into their specified max widths */
            if (unitData->stageD[*stage].modeBits[mode]->length < *hwWidth) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG_NO_UNIT("specified qset is too wide %u"
                                                   " for specified mode %d (%s) on"
                                                   " unit %d stage %u, max %u"),
                                  *hwWidth,
                                  mode,
                                  _bcm_dpp_field_group_mode_name[mode],
                                  unit,
                                  *stage,
                                  unitData->stageD[*stage].modeBits[mode]->length));
            }
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_verify_aset
 *  Purpose
 *     Convert a BCM aset into a set of PPD actions
 *  Parameters
 *     (in) unitData = unit information
 *     (in) stage = stage for the group
 *     (in) type = type for the group
 *     (in) aset = BCM aset
 *     (out) taset = where to put adjusted aset
 *     (out) ppdaset = where to put PPD aset
 *     (out) size = number of actions included
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if the proposed qset is acceptable
 *        BCM_E_* appropriately if not
 *  Notes
 *     This is used by the group create and group set class functions.
 *
 *     Will clobber all out args even if error.
 */
STATIC int
_bcm_dpp_field_group_verify_aset(_bcm_dpp_field_info_t *unitData,
                                 _bcm_dpp_field_stage_idx_t stage,
                                 bcm_field_aset_t aset,
                                 bcm_field_aset_t *taset,
                                 _bcm_dpp_field_action_set_t *ppdaset)
{
    unsigned int size;
    bcm_field_aset_t xaset;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    sal_memcpy(&(xaset),
               &(unitData->stageD[stage].stgAset),
               sizeof(xaset));
    if (unitData->stageD[stage].devInfo->stageFlags &
        _BCM_DPP_FIELD_DEV_STAGE_FLAG_IMPLIED_ACTION) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d stage %u uses implied action set;"
                              " action set will reflect hardware\n"),
                   unit,
                   stage));
    } else { /* if (this stage has implied action set) */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d stage %u allows configurable action"
                              " set; building action set\n"),
                   unit,
                   stage));
    } /* if (this stage has implied action set) */
    BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_aset_subset(xaset,
                                                   aset),
                        (_BSL_BCM_MSG_NO_UNIT("specified action set is not"
                                          " supported by unit %d stage %u"),
                         unit,
                         stage));
    if (unitData->stageD[stage].devInfo->stageFlags &
        _BCM_DPP_FIELD_DEV_STAGE_FLAG_IMPLIED_ACTION) {
        _bcm_dpp_field_actions_to_ppd(unitData,
                                      stage,
                                      unitData->stageD[stage].stgAset,
                                      ppdaset,
                                      &size);
        sal_memcpy(taset,
                   &(unitData->stageD[stage].stgAset),
                   sizeof(*taset));
    } else { /* if (this stage has implied action set) */
        _bcm_dpp_field_actions_to_ppd(unitData,
                                      stage,
                                      aset,
                                      ppdaset,
                                      &size);
        if (0 == size) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG_NO_UNIT("at least one supported action"
                                               " must be included\n")));
        }
        /* now generate a BCM action set including the implied actions */
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_aset_recover(unitData,
                                                                  stage,
                                                                  ppdaset,
                                                                  taset));
    } /* if (this stage has implied action set) */
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_action_set
 *  Purpose
 *     Set the action set for a group
 *   Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *     (in) aset = group aset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
STATIC int
_bcm_dpp_field_group_action_set(_bcm_dpp_field_info_t *unitData,
                                _bcm_dpp_field_grp_idx_t group,
                                bcm_field_aset_t aset)
{
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_group_t newGroupData;
    int result;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    groupData = &(unitData->groupD[group]);
    if (0 == (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u is not in use"),
                          unit,
                          group));
    }
    /* make a copy of current group state */
    sal_memcpy(&newGroupData, groupData, sizeof(newGroupData));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_group_verify_aset(unitData,
                                                             newGroupData.stage,
                                                             aset,
                                                             &(newGroupData.aset),
                                                             &(newGroupData.paset)));
    /*
     *  Keep a copy of the 'original' (caller's) ASET because if the group is
     *  moved between stages or types (due to changes in the QSET), we want to
     *  recalculate the ASET without including whatever was implied by the
     *  current stage/type (so with only the actions the caller originally
     *  specified when setting the group's ASET).
     */
    sal_memcpy(&(newGroupData.oaset),
               &(aset),
               sizeof(newGroupData.oaset));
    result = _bcm_dpp_field_group_hardware_install(unitData,
                                                   group,
                                                   &newGroupData);
    BCMDNX_IF_ERR_EXIT_MSG(result,
                        (_BSL_BCM_MSG_NO_UNIT("unable to set unit %d group %u to"
                                          " hardware: %d (%s)"),
                         unit,
                         group,
                         result,
                         _SHR_ERRMSG(result)));
    /* we can commit the changes to the state for the group */
    sal_memcpy(groupData, &(newGroupData), sizeof(*groupData));
#ifdef BCM_WARM_BOOT_SUPPORT
    _bcm_dpp_field_group_wb_save(unitData, group, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_group_create_mode_id
 *  Purpose
 *     Create a group with the specified mode and ID
 *  Parameters
 *     (in) unitData = unit information
 *     (in) group = group number
 *     (in) qset = group qset
 *     (in) mode = group mode
 *     (in) priority = group priority
 *  Returns
 *     int (implied cast from bcm_error_t)
 *        BCM_E_NONE if successful
 *        BCM_E_* appropriately if not
 *  Notes
 *     This call is used by all of the group create functions.  It is not
 *     permitted to have two groups of same priority or with same qset.
 *
 *     We only allow priority values 0..127, and they are exactly reversed
 *     between BCM and DPP layers (BCM lower number is lower priority, DPP
 *     higher number is lower priority).
 */
STATIC int
_bcm_dpp_field_group_create_mode_id(_bcm_dpp_field_info_t *unitData,
                                    _bcm_dpp_field_grp_idx_t group,
                                    bcm_field_qset_t qset,
                                    int priority,
                                    uint32 group_config_flags,
                                    bcm_field_group_mode_t mode,
                                    int max_entry_priorities)
{
    int result;
    int auxRes;
    unsigned int apiSize = 0;
    unsigned int hwSize = 0;
    unsigned int index;
    uint32 flags = 0;
    uint32 flags_vt_hs = 0; /*added flags for vlan translation and header selection*/
    uint32 types;
    uint32 internal_table_id = 0;
    _bcm_dpp_field_stage_t *stageInfo;
    _bcm_dpp_field_group_t *groupInfo;
    _bcm_dpp_field_group_t *groupTemp;
    _bcm_dpp_field_grp_idx_t currGroup;
    _bcm_dpp_field_grp_idx_t nextGroup;
    _bcm_dpp_field_stage_idx_t stage = unitData->devInfo->stages;
    _bcm_dpp_field_type_idx_t type;
    _bcm_dpp_field_qual_set_t ppdqset;
    SHR_BITDCL priorities[_SHR_BITDCLSIZE(_BCM_PETRA_FIELD_GROUP_PRIOS)];
    SOC_PPD_FP_PREDEFINED_ACL_KEY predefKey = SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS;
    bcm_field_qset_t tqset;
    int use_small_banks = (group_config_flags & BCM_FIELD_GROUP_CREATE_SMALL)? 1: 0;
    int use_single_bank = (group_config_flags & BCM_FIELD_GROUP_CREATE_SINGLE)? 1: 0;
    int no_insertion_priority_order = (group_config_flags & BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE)? 1: 0;
    int sparse_priorities = (group_config_flags & BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES)? 1: 0;
    int ignore_implied_indicator = (group_config_flags & BCM_FIELD_GROUP_CREATE_WITH_PRESELSET) ? 1 : 0;
    int is_equal = (group_config_flags & BCM_FIELD_GROUP_CREATE_IS_EQUAL)? 1: 0;
    SOC_DPP_DBAL_PHYSICAL_DB_TYPES physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_LEM;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    groupInfo = &(unitData->groupD[group]);
    if (groupInfo->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_EXISTS,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %d already exists"),
                          unit,
                          group));
    }

    /* if bcmFieldQualifyStageIngressVlanTranslation is in the qset, the qset must belong to one of the predefined groups of the VT stage. */
    if ((BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageIngressVlanTranslation)) || (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageIngressTunnelTerminated)))
    {
        uint32 flag = 0;
        uint8 found;
        BCM_FIELD_QSET_REMOVE(qset,bcmFieldQualifyStageIngressVlanTranslation);
        BCM_FIELD_QSET_REMOVE(qset,bcmFieldQualifyStageIngressTunnelTerminated);

        /*Validate QSET is as expected.*/
        result = _bcm_dpp_field_group_verify_vt_classification_qset(unit, qset, &internal_table_id, &found, &flag);

        if (!found) {
             BCMDNX_IF_ERR_EXIT_MSG(result,(_BSL_BCM_MSG_NO_UNIT("unit %d failed to verify group %u"
                                                                  " vt classification qset and related parameters:"
                                                                 " %d (%s)"),unit,group,result,_SHR_ERRMSG(result)));
            flag = _BCM_DPP_FIELD_GROUP_USE_DBAL;
            internal_table_id = 0;
        }

        BCM_FIELD_QSET_ADD(qset,bcmFieldQualifyStageIngress);
        flags_vt_hs |= flag;

        if(mode == bcmFieldGroupModeExactMatch) {
            mode = bcmFieldGroupModeAuto;
            physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_SEM_A;
        }else{
            physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_TCAM;
        }
    }

    
    if ((BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageLookup)) || (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageExternal))){
        uint8 found = 0;
        uint32 flag = 0;
        uint32 is_stage_lookup = 0;

        if(BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyStageLookup)) {
            is_stage_lookup = 1;
        }

        BCM_FIELD_QSET_REMOVE(qset,bcmFieldQualifyStageLookup);
        _bcm_dpp_field_group_verify_flp_classification_qset(unit,qset, &internal_table_id, &found, &flag);

        if (found) {
            flags_vt_hs |= flag;
            if(is_stage_lookup){
                /* stage look is equal to egress by supported qualifiers and actions, the only different is the physical DB the stage external is
                   already implemented so we use it for validations. */
                BCM_FIELD_QSET_ADD(qset,bcmFieldQualifyStageIngress);
            }

        } else {
            if(is_stage_lookup){
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("failed to verify group for Stage Lookup - need predefined configuration in HW")));
                flags_vt_hs |= _BCM_DPP_FIELD_GROUP_USE_DBAL; 
                internal_table_id = 0;
            }
        }

        if(mode == bcmFieldGroupModeExactMatch) {
            mode = bcmFieldGroupModeAuto;
            physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_LEM; /* LEM */
        }else{
            physicalDB = SOC_DPP_DBAL_PHYSICAL_DB_TYPE_TCAM; /* TCAM */
        }
    }


    /*Inner MAC qualifiers requires header selection*/
    if ( ( BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyInnerSrcMac) ) || ( BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyInnerDstMac) ) )
    {
        if ( (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyIp4)) || 
             (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyIp6)) ||
             (BCM_FIELD_QSET_TEST(qset, bcmFieldQualifyMpls)) )
        {
            flags_vt_hs |= _BCM_DPP_FIELD_GROUP_WITH_HEADER_SELECTION ; /*header selction required - take 3rd header for inspection*/
        }
    }

    /* verify qset and related parameters */
    result = _bcm_dpp_field_group_verify_qset(unitData,
                                              group,
                                              qset,
                                              mode,
                                              &tqset,
                                              &flags,
                                              &stage,
                                              &types,
                                              &predefKey,
                                              &apiSize,
                                              &hwSize,
                                              &ppdqset);
    BCMDNX_IF_ERR_EXIT_MSG(result,
                        (_BSL_BCM_MSG_NO_UNIT("unit %d failed to verify group %u"
                                          " qset and related parameters:"
                                          " %d (%s)"),
                         unit,
                         group,
                         result,
                         _SHR_ERRMSG(result)));

    flags |= flags_vt_hs; /*Here we add the vt and header selection flag to the group flags received after field_group_verify_qset*/

    /* verify (or select) priority */
    if ((BCM_FIELD_GROUP_PRIO_ANY != priority) &&
        ((0 > priority) || (_BCM_PETRA_FIELD_GROUP_PRIOS <= priority))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d only supports priority"
                                           " 0..127 or"
                                           " BCM_FIELD_GROUP_PRIO_ANY"),
                          unit));
    }
    if ((max_entry_priorities != 0) && (stage != _BCM_DPP_FIELD_STAGE_INDEX_ING_EXTERNAL)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d only supports max_entry_priorities"
                                           " parameter for external stage"),
                          unit));
    }
    /* Verify for IsEqual field groups that the right mode is being used */
    if (SOC_IS_ARADPLUS(unit)
        && is_equal)
    {
        if(SHR_BITGET(ppdqset, SOC_PPD_FP_QUAL_IS_EQUAL)) 
        {
            if (mode != bcmFieldGroupModeDirectExtraction) 
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u must be "
                                           "of type Direct Extraction "
                                           "for the specified set of "
                                           "qualifiers\n"),
                          unit,
                          group));
            }
            /* create second database for compare */
            flags |= _BCM_DPP_FIELD_GROUP_IS_EQUAL_MSB;
        }
        else 
        {
            if (mode == bcmFieldGroupModeDirectExtraction) 
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u cannot be "
                                           "of type Direct Extraction "
                                           "for the specified set of "
                                           "qualifiers\n"),
                          unit,
                          group));
            }
            /* create first database for compare */
            flags |= _BCM_DPP_FIELD_GROUP_IS_EQUAL_LSB;
        }
    }
    else 
    {
        if (SHR_BITGET(ppdqset, SOC_PPD_FP_QUAL_IS_EQUAL)) {
            /* Qualifier SOC_PPD_FP_QUAL_IS_EQUAL is only allowed
             * in Arad Plus devices and only in case the relevant 
             * flag is set, indicating this database is for Compare. 
             */
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG_NO_UNIT("bcmFieldQualifyIsEqualValue "
                                               "cannot be used in this mode")));
        }
    }

    /*
     *  BCM API definition does not want multiple groups at same priority or
     *  with same qset.  However, BCM_FIELD_GROUP_PRIO_ANY means that the API
     *  is expected to assign the priority value.  Amusingly, regression tests
     *  expect to be able to have groups with same qset, but also not to be
     *  able to have groups at the same priority.
     */
    sal_memset(&(priorities[0]), 0x00, sizeof(priorities));
    stageInfo = &(unitData->stageD[stage]);
    nextGroup = stageInfo->groupHead;
    while (nextGroup < unitData->groupLimit) {
        currGroup = nextGroup;
        groupTemp = &(unitData->groupD[currGroup]);
        nextGroup = groupTemp->groupNext;
        SHR_BITSET(priorities, groupTemp->priority);
    } /* while (nextGroup < unitData->groupLimit) */
    if (BCM_FIELD_GROUP_PRIO_ANY == priority) {
        /* find the first free priority */
        for (priority = 0;
             (priority < _BCM_PETRA_FIELD_GROUP_PRIOS) &&
             (SHR_BITGET(priorities, priority));
             priority++) {
            /* just iterate... */
        }
        if (_BCM_PETRA_FIELD_GROUP_PRIOS <= priority) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG_NO_UNIT("unable to decide upon unit %d"
                                               " group %d priority"),
                              unit,
                              group));
        }
    } else { /* if (BCM_FIELD_GROUP_PRIO_ANY == priority) */
        if (SHR_BITGET(priorities, priority)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d already has a group"
                                               " in stage %u at priority %d"),
                              unit,
                              stage,
                              priority));
        }
    } /* if (BCM_FIELD_GROUP_PRIO_ANY == priority) */
    /* initial checks okay, allocate and fill in the group */
    if (groupInfo->groupPrev < unitData->groupLimit) {
        unitData->groupD[groupInfo->groupPrev].groupNext = groupInfo->groupNext;
    } else {
        unitData->groupFree = groupInfo->groupNext;
    }
    if (groupInfo->groupNext < unitData->groupLimit) {
        unitData->groupD[groupInfo->groupNext].groupPrev = groupInfo->groupPrev;
    }

    if (group_config_flags & BCM_FIELD_GROUP_CREATE_HANDLE_ENTRIES_BY_KEY) {
        flags |= _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY;
    }
        
    stageInfo = &(unitData->stageD[stage]);
    currGroup = groupInfo->groupPrev;
    nextGroup = groupInfo->groupNext;
    sal_memset(groupInfo, 0x00, sizeof(*groupInfo));
    groupInfo->physicalDB = physicalDB;
    groupInfo->groupPrev = currGroup;
    groupInfo->groupNext = nextGroup;
    groupInfo->cascadePair = unitData->groupLimit;
    groupInfo->hwHandle = ~0;
    groupInfo->groupFlags = flags | _BCM_DPP_FIELD_GROUP_PHASE;
    sal_memcpy(&(groupInfo->qset), &(tqset), sizeof(groupInfo->qset));
    sal_memcpy(&(groupInfo->pqset), &(ppdqset), sizeof(groupInfo->pqset));
    groupInfo->priority = priority;
    groupInfo->predefKey = predefKey;
    groupInfo->stage = stage;
    groupInfo->groupTypes = types;
    groupInfo->maxEntryPriorities = max_entry_priorities;
    groupInfo->internal_table_id = internal_table_id;
    groupInfo->handle_by_key_entry_id = _BCM_DPP_FIELD_GROUP_ENTRY_BY_KEY_EMPTY;
    if (bcmFieldGroupModeAuto == mode) {
        groupInfo->groupFlags |= _BCM_DPP_FIELD_GROUP_AUTO_SZ;
        _bcm_dpp_field_group_mode_from_size(unitData,
                                            groupInfo->stage,
                                            groupInfo->groupFlags,
                                            hwSize,
                                            &(groupInfo->grpMode));
    } else { /* if (bcmFieldGroupModeAuto == mode) */
        groupInfo->grpMode = mode;
    } /* if (bcmFieldGroupModeAuto == mode) */
    if (use_small_banks) {
        /* Use the small TCAM banks */
        groupInfo->groupFlags |= _BCM_DPP_FIELD_GROUP_SMALL;
    }
    if (use_single_bank) {
        /* Use single bank */
        groupInfo->groupFlags |= _BCM_DPP_FIELD_GROUP_SINGLE_BANK;
    }
    if (no_insertion_priority_order) {
        /* Cancel the insertion priority order rule */
        groupInfo->groupFlags |= _BCM_DPP_FIELD_GROUP_LOOSE;
    }
    if (sparse_priorities) {
        /* Use the TCAM method with only few priorities */
        groupInfo->groupFlags |= _BCM_DPP_FIELD_GROUP_SPARSE_PRIO;
    }

    switch (stageInfo->modeBits[mode]->entryType) {
    case _bcmDppFieldEntryTypeDirExt:
        groupInfo->entryHead = unitData->entryDeLimit;
        groupInfo->entryTail = unitData->entryDeLimit;
        break;
    case _bcmDppFieldEntryTypeExternalTcam:
        groupInfo->entryHead = unitData->entryExtTcLimit;
        groupInfo->entryTail = unitData->entryExtTcLimit;
        break;
    default:
        /* default is TCAM */
        groupInfo->entryHead = unitData->entryTcLimit;
        groupInfo->entryTail = unitData->entryTcLimit;
    }
    /*
     *  Scan the existing groups and place this one in strict priority order.
     */
    currGroup = stageInfo->groupHead;
    while ((currGroup < unitData->groupLimit) &&
           (unitData->groupD[currGroup].priority < priority)) {
        currGroup = unitData->groupD[currGroup].groupNext;
    }
    /* add the group into the used group list */
    if (currGroup < unitData->groupLimit) {
        /* index points to the group before which to insert new group */
        groupInfo->groupNext = currGroup;
        groupInfo->groupPrev = unitData->groupD[currGroup].groupPrev;
        if (groupInfo->groupPrev < unitData->groupLimit) {
            /* not at head of list */
            unitData->groupD[groupInfo->groupPrev].groupNext = group;
        } else {
            /* at head of list */
            stageInfo->groupHead = group;
        }
        unitData->groupD[currGroup].groupPrev = group;
    } else { /* if (currGroup < unitData->groupLimit) */
        /* fell off the list; tack on as tail */
        groupInfo->groupNext = unitData->groupLimit;
        groupInfo->groupPrev = stageInfo->groupTail;
        if (stageInfo->groupTail < unitData->groupLimit) {
            /* there is a list already, link into it */
            unitData->groupD[stageInfo->groupTail].groupNext = group;
        } else {
            /* no list, so this is also head */
            stageInfo->groupHead = group;
        }
        stageInfo->groupTail = group;
    } /* if (currGroup < unitData->groupLimit) */
    /* account for the group being in use */
    unitData->groupCount++;
    unitData->stageD[stageInfo->groupSh1].groupCount++;
    /* account for the group's references to programmable fields */
    for (index = 0; index < unitData->dqLimit; index++) {
        if (SHR_BITGET(tqset.udf_map, index)) {
            unitData->dataFieldRefs[index]++;
        }
    }
#ifdef BCM_WARM_BOOT_SUPPORT
    _bcm_dpp_field_datafield_all_wb_save(unitData, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */

    if (ignore_implied_indicator 
        && (stageInfo->devInfo->stageFlags & _BCM_DPP_FIELD_DEV_STAGE_FLAG_IMPLIED_ACTION)) 
    {
        groupInfo->groupFlags |= _BCM_DPP_FIELD_GROUP_WITH_PRESEL;
    }
    
    if (stageInfo->devInfo->stageFlags &
        _BCM_DPP_FIELD_DEV_STAGE_FLAG_IMPLIED_ACTION) {
        if (!(groupInfo->groupFlags & _BCM_DPP_FIELD_GROUP_WITH_PRESEL)) {

            type = unitData->devInfo->types;
            while ((0 == (types & (1 << type))) && (type > 0)) {
                type--;
            }
            /*
             *  This group is in a stage that support implied action sets; go ahead
             *  and assume the action set for the stage and type.
             */
            result = _bcm_dpp_field_group_action_set(unitData,
                                                     group,
                                                     stageInfo->stgAset);
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d group %u implied action set failed;"
                                      " backing out group: %d (%s)\n"),
                           unit,
                           group,
                           result,
                           _SHR_ERRMSG(result)));
                auxRes = _bcm_dpp_field_group_destroy(unitData, group);
                if (BCM_E_NONE != result) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d unable to back out group %u"
                                          " after error setting implied action"
                                          " set: %d (%s)\n"),
                               unit,
                               group,
                               auxRes,
                               _SHR_ERRMSG(auxRes)));
                }
            }
        }
    } /* if (stageInfo->devInfo->impliedActionSet) */
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_group_hardware_install(_bcm_dpp_field_info_t *unitData,
                                      _bcm_dpp_field_grp_idx_t group,
                                      _bcm_dpp_field_group_t *newGroupData)
{
    SOC_PPD_FP_DATABASE_INFO dbInfo;
    SOC_PPD_FP_QUAL_TYPE qualType;
    SOC_PPD_FP_ACTION_TYPE actionType;
    uint32 ppdr;
    uint8 is_new_fg_presel_set_void;
    SOC_SAND_SUCCESS_FAILURE success;
    unsigned int index;
    unsigned int offset;
    int result = BCM_E_NONE;
    int auxRes;
    int handle = -1;
    uint32 soc_sand_rv;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    if (0 == (unitData->groupD[group].groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u not in use"),
                          unit,
                          group));
    }
    if (unitData->groupD[group].entryCount > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u can not be"
                                           " changed while it has entries"),
                          unit,
                          group));
    }
    /* fill in the group information */
    SOC_PPD_FP_DATABASE_INFO_clear(&dbInfo);
    dbInfo.strength = newGroupData->priority;
    dbInfo.db_type = unitData->stageD[newGroupData->stage].modeBits[newGroupData->grpMode]->hwType;
    if (newGroupData->maxEntryPriorities == 0){
	    /* invalid value */
        dbInfo.min_priority = -1;
    }
    else {
        dbInfo.min_priority = newGroupData->maxEntryPriorities;
    }
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_SMALL) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_USE_SMALL_BANKS;
    }
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_SINGLE_BANK) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_USE_SINGLE_BANK;
    }
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_LOOSE) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_NO_INSERTION_PRIORITY_ORDER;
    }
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_SPARSE_PRIO) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_SPARSE_PRIORITIES;
    }
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_LARGE) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_ALLOCATE_FES;
    }

    if (SOC_IS_ARADPLUS(unit))
    {
        if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_IS_EQUAL_LSB) {
            dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_IS_EQUAL_LSB;
        }
        if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_IS_EQUAL_MSB) {
            dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_IS_EQUAL_MSB;
        }
    }
	
    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_USE_DBAL) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_USE_DBAL;
        dbInfo.internal_table_id = newGroupData->internal_table_id;
        dbInfo.physicalDB = newGroupData->physicalDB;
    }

    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_HANDLE_ENTRIES_BY_KEY;
    }    

	if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_WITH_HEADER_SELECTION) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_HEADER_SELECTION;
    }


    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_EXTENDED_DATABASES) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_EXTENDED_DATABASES;
        dbInfo.internal_table_id = newGroupData->internal_table_id;        
    }    

    if (newGroupData->groupFlags & _BCM_DPP_FIELD_GROUP_STAGE_VT_EXTENDED) {
        dbInfo.flags |= SOC_PPC_FP_DATABASE_INFO_FLAGS_STAGE_VT_EXTENDED;
        dbInfo.internal_table_id = newGroupData->internal_table_id;
    }    


    newGroupData->cascadePair = unitData->groupLimit;
    if (SHR_BITGET(newGroupData->pqset, SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED) &&
        SHR_BITGET(newGroupData->paset, SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u tries to be both"
                                           " ends of a cascade pair"),
                          unit,
                          group));
    }
    if ((SHR_BITGET(newGroupData->pqset, SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) ||
        (SHR_BITGET(newGroupData->paset, SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY))) {
        if (0 == (unitData->stageD[newGroupData->stage].devInfo->stageFlags &
                  _BCM_DPP_FIELD_DEV_STAGE_FLAG_ALLOW_CASCADE)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d group %u tries to use"
                                               " cascading features in stage"
                                               " %u, which does not support"
                                               " cascading"),
                              unit,
                              group,
                              newGroupData->stage));
        }
        newGroupData->groupFlags |= _BCM_DPP_FIELD_GROUP_CASCADE;
    }
    if (SHR_BITGET(newGroupData->pqset, SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) {
        /*
         *  This group uses the cascaded key qualifier; make sure no other
         *  group in this stage using the cascaded key qualifier also uses any
         *  of the same preselector(s) as this group.
         */
        for (index = 0; index < unitData->groupLimit; index++) {
            if (((_BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_IN_HW) ==
                 (unitData->groupD[index].groupFlags &
                  (_BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_IN_HW))) &&
                (newGroupData->stage == unitData->groupD[index].stage) &&
                SHR_BITGET(unitData->groupD[index].pqset,
                           SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) {
                for (offset = 0; offset < BCM_FIELD_PRESEL_SEL_MAX; offset++) {
                    if (BCM_FIELD_PRESEL_TEST(unitData->groupD[index].preselSet,
                                              offset) &&
                        BCM_FIELD_PRESEL_TEST(newGroupData->preselSet,
                                              offset)) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %u"
                                                           " uses cascade"
                                                           " qualifier but"
                                                           " shares preselector"
                                                           " %u with group %u"),
                                          unit,
                                          group,
                                          offset,
                                          index));
                    }
                } /* for (all possible preselectors) */
            } /* if (group exists, is in hw, same stage, has cascade qual) */
        } /* for (index = 0; index < unitData->groupLimit; index++) */
    } /* if (SHR_BITGET(newGroupData->pqset, SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) */
    if (SHR_BITGET(newGroupData->paset, SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY)) {
        /*
         *  This group uses the cascaded key action; make sure no other group
         *  in this stage using the cascaded key action also uses any of the
         *  same preselector(s) as this group.  Also find the group using the
         *  cascaded key qualifier that uses the same preselector(s) and keep
         *  track of it.
         */
        for (index = 0; index < unitData->groupLimit; index++) {
            if (((_BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_IN_HW) ==
                 (unitData->groupD[index].groupFlags &
                  (_BCM_DPP_FIELD_GROUP_IN_USE | _BCM_DPP_FIELD_GROUP_IN_HW))) &&
                (newGroupData->stage == unitData->groupD[index].stage) &&
                SHR_BITGET(unitData->groupD[index].pqset,
                           SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) {
                /* this group should be the pair for the new one */
                auxRes = BCM_E_NOT_FOUND;
                /* Look if there is a common preselector if the presel-set is not void */
                is_new_fg_presel_set_void = TRUE;
                for (offset = 0; offset < BCM_FIELD_PRESEL_SEL_MAX; offset++) {
                    if (BCM_FIELD_PRESEL_TEST(newGroupData->preselSet,
                                              offset)) {
                        is_new_fg_presel_set_void = FALSE;
                        /* this preselector is in use on new group */
                        if (BCM_FIELD_PRESEL_TEST(unitData->groupD[index].preselSet,
                                                  offset)) {
                            /* the other group shares this preselector */
                            auxRes = BCM_E_EXISTS;
                            break; /* enough to find one common preselector */
                        }
                    }
                }
                if (is_new_fg_presel_set_void) {
                    auxRes = BCM_E_EXISTS;
                }

                /* If an existing group with a cascaded key has been found with a preselector in common, check it is the same preselset */
                if (BCM_E_EXISTS == auxRes) {
                    for (offset = 0; offset < BCM_FIELD_PRESEL_SEL_MAX; offset++) {
                        /* Any preselector must be either present in both groups or none */
                        if ((BCM_FIELD_PRESEL_TEST(unitData->groupD[index].preselSet, offset) > 0) 
                             != (BCM_FIELD_PRESEL_TEST(newGroupData->preselSet, offset) > 0)) {
                                /* mismatch after match; config error */
                                auxRes = BCM_E_CONFIG;
                        }
                    }
                } /* for (all valid preselectors) */
				else {
				    /* No sharing with existing Database, continue searching */
				    continue;
				}

                if (BCM_E_CONFIG == auxRes) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                     (_BSL_BCM_MSG_NO_UNIT("unit %d group %u has"
                                                       " at least one"
                                                       " preselector in common"
                                                       " with group %u, but"
                                                       " the preselector sets"
                                                       " are not equal"),
                                      unit,
                                      index,
                                      group));
                }
                if (unitData->groupLimit >
                    unitData->groupD[index].cascadePair) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                     (_BSL_BCM_MSG_NO_UNIT("unit %d group %u wants"
                                                       " group %u as cascade"
                                                       " pair, but group %u"
                                                       " indicates it has a"
                                                       " different cascade"
                                                       " pair, %u"),
                                      unit,
                                      group,
                                      index,
                                      index,
                                      unitData->groupD[index].cascadePair));
                }
                if (unitData->groupLimit <= newGroupData->cascadePair) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d group %u will use group"
                                          " %u as its cascade pair\n"),
                               unit,
                               group,
                               index));
                    newGroupData->cascadePair = index;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                     (_BSL_BCM_MSG_NO_UNIT("unit %d group %u"
                                                       " wants more than one"
                                                       " group as its cascade"
                                                       " pair: %u, %u"),
                                      unit,
                                      group,
                                      newGroupData->cascadePair,
                                      index));
                }
            } /* if (group exists, is in hw, same stage, has cascade action) */
        } /* for (index = 0; index < unitData->groupLimit; index++) */
    } /* if (SHR_BITGET(newGroupData->paset, SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY)) */
    if (SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS != newGroupData->predefKey) {
        /* using predefined key; fetch it from the driver */
        SOC_PPD_FP_QUAL_TYPE_PRESET(unitData->unitHandle,
                                    newGroupData->predefKey,
                                    &(dbInfo.qual_types[0]),
                                    soc_sand_rv);
        BCM_SAND_IF_ERR_EXIT_NO_UNIT(soc_sand_rv);
    } else { /* if (SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS != groupData->predefKey) */
        /* using versatile key */
        index = 0;
        /* must include cascade key first if it is present */
        if (SHR_BITGET(newGroupData->pqset, SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) {
            dbInfo.qual_types[index] = SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED;
            index++;
        }
        /* build qualifier list from qset */
        for (qualType = 0;
             qualType < SOC_PPD_NOF_FP_QUAL_TYPES;
             qualType++) {
            /* collect qualifiers */
            if (SHR_BITGET(newGroupData->pqset, qualType) &&
                (qualType != SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) {
                /* this qualifier is selected */
                if (index < SOC_PPD_FP_NOF_QUALS_PER_DB_MAX) {
                    dbInfo.qual_types[index] = qualType;
                }
                index++;
            }
        }
        if (index >= SOC_PPD_FP_NOF_QUALS_PER_DB_MAX) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d group %d has too many"
                                               " qualifiers (%d, max %d)"),
                              unit,
                              group,
                              index,
                              SOC_PPD_FP_NOF_QUALS_PER_DB_MAX));
        }
    } /* if (SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS != groupData->predefKey) */
    index = 0;
    /* must include cascade action as first if it is present */
    if (SHR_BITGET(newGroupData->paset, SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY)) {
        dbInfo.action_types[index] = SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY;
        index++;
    }
    for (actionType = 0;
         actionType < SOC_PPD_NOF_FP_ACTION_TYPES;
         actionType++) {
        if (SHR_BITGET(newGroupData->paset, actionType) &&
            (actionType != SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY)) {
            /* this action is selected */
            if (index < SOC_PPD_FP_NOF_ACTIONS_PER_DB_MAX) {
                dbInfo.action_types[index] = actionType;
            }
            index++;
        }
    }
    if (index > SOC_PPD_FP_NOF_ACTIONS_PER_DB_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %d has too many"
                                           " actions (%d, max %d)"),
                          unit,
                          group,
                          index,
                          SOC_PPD_FP_NOF_ACTIONS_PER_DB_MAX));
    }
    /* must not 'early exit' from here onward */
    /* get implied preselector (based upon qset) if applicable */
#ifdef BCM_PETRAB_SUPPORT
    if (SOC_IS_PETRAB(unit)) {
        /* PetraB needs implied preselectors; Arad does not */
        result = _bcm_dpp_field_presel_implied_setup(unitData, newGroupData);
    } /* if (SOC_IS_PETRAB(unit) */
#endif /* def BCM_PETRAB_SUPPORT */
    /* set up PPD layer PFG bit map from preselector set */
    dbInfo.supported_pfgs = 0;
    for (index = 0; index < unitData->preselLimit; index++) {
        if (BCM_FIELD_PRESEL_TEST(newGroupData->preselSet, index)) {
            if (!BCM_FIELD_PRESEL_TEST(unitData->preselInUse, index)) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d group %d wants to use presel"
                                      " %d but it is not in use\n"),
                           unit,
                           group,
                           index));
                result = BCM_E_CONFIG;
            }

            /* set PFG membership - different method between Petra-B and Arad */
#ifdef BCM_PETRAB_SUPPORT
            if (SOC_IS_PETRAB(unit)) {
                dbInfo.supported_pfgs |= (1 << index);
            }
#endif /* def BCM_PETRAB_SUPPORT */
#ifdef BCM_ARAD_SUPPORT
            if (SOC_IS_ARAD(unit)) {
                dbInfo.supported_pfgs_arad[index >> 5] |= (1 << (index & 0x1F));
            }
#endif /* def BCM_ARAD_SUPPORT*/

            /* account for this reference */
            unitData->preselRefs[index]++;
        }
    }
    /* Fill in the cascaded group indicator for PPD layer */
    if (unitData->groupLimit > newGroupData->cascadePair) {
        dbInfo.cascaded_coupled_db_id = unitData->groupD[newGroupData->cascadePair].hwHandle;
    }
    /*
     *  There are no entries in this group; removing it then replacing it
     *  (instead of creating a new one and then destroying the old one) will
     *  not have any effect on traffic.
     */
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_group_hardware_remove(unitData, group);
    }
    if (BCM_E_NONE == result) {
        /* at this point, the group is not, or is no longer, in hardware */
        result = shr_mres_alloc(unitData->hwResIds,
                                unitData->stageD[newGroupData->stage].groupRes,
                                0 /* flags */,
                                1 /* count */,
                                &handle);
    }
    { 
        if (BCM_E_NONE == result) {
            newGroupData->hwHandle = handle;
            ppdr = soc_ppd_fp_database_create(unitData->unitHandle,
                                          newGroupData->hwHandle,
                                          &dbInfo,
                                          &success);
            result = handle_sand_result(ppdr);
            if (BCM_E_NONE == result) {
                result = translate_sand_success_failure(success);
            }
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unable to create unit %d group %d in"
                                      " hardware: %d (%s)\n"),
                           unit,
                           group,
                           result,
                           _SHR_ERRMSG(result)));
            }
        } /* if (BCM_E_NONE == result) */
    } /* if (custom_feature == 0) */
    if (BCM_E_NONE == result) {
        newGroupData->groupFlags |= _BCM_DPP_FIELD_GROUP_IN_HW;
        /* mark the group's preselectors as being in hardware */
        sal_memcpy(&(newGroupData->preselHw),
                   &(newGroupData->preselSet),
                   sizeof(newGroupData->preselHw));
        /* claim cascading features use if any are used */
        if ((SHR_BITGET(newGroupData->pqset, SOC_PPD_FP_QUAL_IRPP_KEY_CHANGED)) ||
            (SHR_BITGET(newGroupData->paset, SOC_PPD_FP_ACTION_TYPE_CHANGE_KEY))) {
            unitData->groupCascaded++;
            unitData->groupD[newGroupData->cascadePair].cascadePair = group;
        }
#ifdef BCM_WARM_BOOT_SUPPORT
        /* ensure presel reference counts are committed to backing store */
        _bcm_dpp_field_presel_all_wb_save(unitData, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */
    } else { /* if (BCM_E_NONE == result) */
        /* free the group handle */
        if (0 <= handle) {
            auxRes = shr_mres_free(unitData->hwResIds,
                                   unitData->stageD[newGroupData->stage].groupRes,
                                   1 /* count */,
                                   handle);
        }
        /* release the preselectors we put in use before */
        for (index = 0; index < unitData->preselLimit; index++) {
            if (BCM_FIELD_PRESEL_TEST(newGroupData->preselSet, index)) {
                unitData->preselRefs[index]--;
            }
        }
        /* dispose of any preselectors no longer implied */
#ifdef BCM_PETRAB_SUPPORT
        if (SOC_IS_PETRAB(unit)) {
            /* PetraB needs implied preselectors; Arad does not */
            auxRes = _bcm_dpp_field_presel_implied_teardown(unitData,
                                                            newGroupData);
        } /* if (SOC_IS_PETRAB(unit) */
#endif /* def BCM_PETRAB_SUPPORT */
        /* called function displayed diagnostic */
    } /* if (BCM_E_NONE == result) */
    BCMDNX_IF_ERR_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_entry_exists(_bcm_dpp_field_info_t *unitData,
                            bcm_field_entry_t entry)
{
    _bcm_dpp_field_entry_common_t *common;
    _bcm_dpp_field_entry_common_ext_t *extCommon;
    _bcm_dpp_field_entry_type_t entryType;
    uint32 entryFlags;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_common_pointer(unitData,
                                                                entry,
                                                                &common,
                                                                &extCommon,
                                                                &entryType));
    if (entryType == _bcmDppFieldEntryTypeExternalTcam) {
        entryFlags = extCommon->entryFlags;
    }
    else { /* internal TCAM / direct extraction */
        entryFlags = common->entryFlags;
    }

    if (0 == (entryFlags & _BCM_DPP_FIELD_ENTRY_IN_USE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d not in use"),
                          unit,
                          entry));
    } /* if (0 == (entryData->flags & _BCM_DPP_FIELD_ENTRY_IN_USE)) */

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualifier_general_set
 *  Purpose
 *     Set a qualifier for an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) count = number of octbytes of data/mask
 *     (in) data = pointer to the data values
 *     (in) mask = pointer to the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 *
 *     Only checks entries for validity.  Other objects (currently only
 *     preselectors) are checked by their own setup code.
 */
STATIC int
_bcm_dpp_field_entry_qualifier_general_set(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_field_qualify_t type,
                                           unsigned int count,
                                           const uint64 *data,
                                           const uint64 *mask)
{
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_entry_qualifier_general_set_int(unitData,
                                                            entry,
                                                            type,
                                                            count,
                                                            data,
                                                            mask);
    _DPP_FIELD_UNIT_UNLOCK(unitData);
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualifier_general_get
 *  Purpose
 *     Get a qualifier for an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) count = number of octbytes of data/mask
 *     (in) data = pointer to the data values
 *     (in) mask = pointer to the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 *
 *     Only checks entries for validity.  Other objects (currently only
 *     preselectors) are checked by their own setup code.
 */
STATIC int
_bcm_dpp_field_entry_qualifier_general_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_field_qualify_t type,
                                           unsigned int count,
                                           uint64 *data,
                                           uint64 *mask)
{
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_entry_qualifier_general_get_int(unitData,
                                                            entry,
                                                            type,
                                                            count,
                                                            data,
                                                            mask);
    BCMDNX_IF_ERR_EXIT(result);
    _DPP_FIELD_UNIT_UNLOCK(unitData);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_macaddr_set
 *  Purpose
 *     Set a qualifier that is based upon MAC address on an entry
 *  Parameters
 *     (in) unit = the unit number
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = the data value
 *     (in) mask = the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held.
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_macaddr_set(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_field_qualify_t type,
                                         const bcm_mac_t data,
                                         const bcm_mac_t mask)
{
    uint64 edata;
    uint64 emask;
    uint64 temp;
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    COMPILER_64_ZERO(edata);
    COMPILER_64_ZERO(emask);
    for (index = 0; index < 6; index++) {
        COMPILER_64_SHL(edata, 8);
        COMPILER_64_SHL(emask, 8);
        COMPILER_64_SET(temp, 0, data[index]);
        COMPILER_64_OR(edata, temp);
        COMPILER_64_SET(temp, 0, mask[index]);
        COMPILER_64_OR(emask, temp);
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               type,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_macaddr_get
 *  Purpose
 *     Get a qualifier that is based upon MAC address from an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_macaddr_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_field_qualify_t type,
                                         bcm_mac_t *data,
                                         bcm_mac_t *mask)
{
    uint64 edata;
    uint64 emask;
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    for (index = 0; index < 6; index++) {
        (*data)[5 - index] = COMPILER_64_LO(edata) & 0xFF;
        (*mask)[5 - index] = COMPILER_64_LO(emask) & 0xFF;
        COMPILER_64_SHR(edata, 8);
        COMPILER_64_SHR(emask, 8);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_ipv6addr_set
 *  Purpose
 *     Set a qualifier that is based upon IPv6 address on an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = the data value
 *     (in) mask = the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 *
 *     If one of the qualifier types is bcmFieldQualifyCount, it will not set
 *     that part of the address, but if both are, it is BCM_E_PARAM.
 */
STATIC int
_bcm_dpp_field_entry_qualify_ipv6addr_set(int unit,
                                          bcm_field_entry_t entry,
                                          bcm_field_qualify_t type,
                                          const bcm_ip6_t data,
                                          const bcm_ip6_t mask)
{
    uint64 edata[2];
    uint64 emask[2];
    uint64 temp;
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    for (index = 0; index < 2; index++) {
        COMPILER_64_ZERO(edata[index]);
        COMPILER_64_ZERO(emask[index]);
    }
    for (index = 0; index < 8; index++) {
        COMPILER_64_SHL(edata[0], 8);
        COMPILER_64_SHL(emask[0], 8);
        COMPILER_64_SHL(edata[1], 8);
        COMPILER_64_SHL(emask[1], 8);
        COMPILER_64_SET(temp, 0, data[index]);
        COMPILER_64_OR(edata[1], temp);
        COMPILER_64_SET(temp, 0, mask[index]);
        COMPILER_64_OR(emask[1], temp);
        COMPILER_64_SET(temp, 0, data[8 + index]);
        COMPILER_64_OR(edata[0], temp);
        COMPILER_64_SET(temp, 0, mask[8 + index]);
        COMPILER_64_OR(emask[0], temp);
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               type,
                                                               2 /* count */,
                                                               &(edata[0]),
                                                               &(emask[0])));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_ipv6addr_get
 *  Purpose
 *     Get a qualifier that is based upon IPv6 address from an entry
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = the data value
 *     (in) mask = the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 *
 *     If one of the qualifier types is bcmFieldQualifyCount, it will not set
 *     that part of the address, but if both are, it is BCM_E_PARAM.
 */
STATIC int
_bcm_dpp_field_entry_qualify_ipv6addr_get(int unit,
                                          bcm_field_entry_t entry,
                                          bcm_field_qualify_t type,
                                          bcm_ip6_t *data,
                                          bcm_ip6_t *mask)
{
    uint64 edata[2];
    uint64 emask[2];
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               2 /* buffers */,
                                                               &(edata[0]),
                                                               &(emask[0])));
    for (index = 0; index < 8; index++) {
        (*data)[15 - index] = COMPILER_64_LO(edata[0]) & 0xFF;
        (*mask)[15 - index] = COMPILER_64_LO(emask[0]) & 0xFF;
        (*data)[7 - index] = COMPILER_64_LO(edata[1]) & 0xFF;
        (*mask)[7 - index] = COMPILER_64_LO(emask[1]) & 0xFF;
        COMPILER_64_SHR(edata[0], 8);
        COMPILER_64_SHR(emask[0], 8);
        COMPILER_64_SHR(edata[1], 8);
        COMPILER_64_SHR(emask[1], 8);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_uint32_get
 *  Purpose
 *     Get a qualifier that is based upon uint32 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
int
_bcm_dpp_field_entry_qualify_uint32_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_qualify_t type,
                                        uint32 *data,
                                        uint32 *mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    *data = COMPILER_64_LO(edata);
    *mask = COMPILER_64_LO(emask);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_uint64_get
 *  Purpose
 *     Get a qualifier that is based upon uint64 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_uint64_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_qualify_t type,
                                        uint64 *data,
                                        uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               data,
                                                               mask));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_uint16_get
 *  Purpose
 *     Get a qualifier that is based upon uint16 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_uint16_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_qualify_t type,
                                        uint16 *data,
                                        uint16 *mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    *data = COMPILER_64_LO(edata) & 0xFFFF;
    *mask = COMPILER_64_LO(emask) & 0xFFFF;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_uint8_get
 *  Purpose
 *     Get a qualifier that is based upon uint8 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_uint8_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_field_qualify_t type,
                                       uint8 *data,
                                       uint8 *mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    *data = COMPILER_64_LO(edata) & 0xFF;
    *mask = COMPILER_64_LO(emask) & 0xFF;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Function
 *     _bcm_dpp_field_entry_qualify_int32_get
 *  Purpose
 *     Get a qualifier that is based upon (signed) int32 type
 *  Parameters
 *     (in) unitData = the unit information
 *     (in) entry = the entry ID
 *     (in) type = the qualifier type
 *     (in) data = where to put the data value
 *     (in) mask = where to put the mask value
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 *     Meant to be called without the lock being held
 *
 *     Must be called with a valid qualifier type (okay even if it is not a
 *     supported one, as long as it is valid).
 */
STATIC int
_bcm_dpp_field_entry_qualify_int32_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_field_qualify_t type,
                                       int32 *data,
                                       int32 *mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;
    if ((!data) || (!mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               type,
                                                               1 /* buffers */,
                                                               &edata,
                                                               &emask));
    *data = (int32)COMPILER_64_LO(edata);
    *mask = (int32)COMPILER_64_LO(emask);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_group_all_hw_set
 *   Purpose
 *      Set whether all entries in a group should (not) be in hardware, then
 *      update the hardware state for all of the entries.
 *   Parameters
 *      (in) _bcm_petra_field_info_t *unitData = unit info pointer
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) int hw_state = TRUE if in hardware, FALSE if not
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
STATIC int
_bcm_dpp_field_group_all_hw_set(_bcm_dpp_field_info_t *unitData,
                                bcm_field_group_t group,
                                int hw_state)
{
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_ent_idx_t entry;
    unsigned int already;
    unsigned int added;
    uint32 state;
    _bcm_dpp_field_entry_type_t entryType; 
    uint32 *entryFlags;   

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    
    groupData = &(unitData->groupD[group]);
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d not available for groups that handles entries by key"),unit,group));
    }

    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        entryType = unitData->stageD[groupData->stage].modeBits[groupData->grpMode]->entryType;
        if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW) {
            /* update whether entries want to be in hardware */
            if (hw_state) {
                state = _BCM_DPP_FIELD_ENTRY_WANT_HW;
            } else {
                state = 0;
            }
            switch (entryType) {
            case _bcmDppFieldEntryTypeDirExt:
                for (entry = groupData->entryHead, added = 0, already = 0;
                     entry < unitData->entryDeLimit;
                     entry = unitData->entryDe[entry].entryCmn.entryNext) {
                    if ((unitData->entryDe[entry].entryCmn.entryFlags &
                         _BCM_DPP_FIELD_ENTRY_WANT_HW) == state) {
                        already++;
                    } else {
                        added++;
                    }
                    unitData->entryDe[entry].entryCmn.entryFlags &= (~_BCM_DPP_FIELD_ENTRY_WANT_HW);
                    unitData->entryDe[entry].entryCmn.entryFlags |= state;
                }
                LOG_DEBUG(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d group %d, updated %d entries,"
                                      " %d already %sIN_HW\n"),
                           unit,
                           group,
                           added,
                           already,
                           hw_state?"":"not "));
                BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_dir_ext_group_hw_refresh(unitData,
                                                                                group,
                                                                                FALSE));
                break;
            default:
                /* default is TCAM */
                if (SOC_IS_ARAD(unit)) {
                    for (entry = groupData->entryHead, added = 0, already = 0;
                         entry < _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
                         entry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry)) {
                        if ((_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry) &
                             _BCM_DPP_FIELD_ENTRY_WANT_HW) == state) {
                            already++;
                        } else {
                            added++;
                        }
                        if(hw_state) {
                            if(!(_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry) & _BCM_DPP_FIELD_ENTRY_IN_HW)) {
                                /* ARAD Only:
                                 * This indicates to the driver that the group_install method was called.
                                 * In that case the driver will insert the entries from top to bottom in 
                                 * the HW tables, instead of in the middle. This is done since when calling 
                                 * group install, there is hte assumption that the group's entries were 
                                 * already created, and they are ordered in the SW according to their 
                                 * priority, and so it should be faster to insert top-to-bottom. 
                                 */
                                entryFlags = _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_PTR(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
                                *entryFlags |= _BCM_DPP_FIELD_GROUP_INSTALL;
                                BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_tcam_entry_install(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry));
                            }
                        }
                        else {
                            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_tcam_entry_remove(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry));
                        }
                    }
                }
                else if (SOC_IS_PETRAB(unit)) {
                    for (entry = groupData->entryHead, added = 0, already = 0;
                         entry < _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
                         entry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry)) {
                        if ((_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry) &
                             _BCM_DPP_FIELD_ENTRY_WANT_HW) == state) {
                            already++;
                        } else {
                            added++;
                        }
                        entryFlags = _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_PTR(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
                        *entryFlags &= (~_BCM_DPP_FIELD_ENTRY_WANT_HW);
                        *entryFlags |= state;
                    }
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d group %d, updated %d entries,"
                                          " %d already %sIN_HW\n"),
                               unit,
                               group,
                               added,
                               already,
                               hw_state?"":"not "));
					{
						BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_tcam_group_hw_refresh(unitData,
																					 group,
																					 FALSE));
					}
                }
                else {
                    /* If Unit is neither Petra-B nor ARAD */
                    BCM_ERR_EXIT_NO_MSG(BCM_E_NOT_FOUND);
                }
            } /* switch (entry type for this group) */
        } else { /* if (groupData->flags & _BCM_DPP_fIELD_GROUP_IN_HW) */
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d group %d is not"
                                               " in hardware"),
                              unit,
                              group));
        } /* if (groupData->flags & _BCM_DPP_fIELD_GROUP_IN_HW) */
    } else { /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_USE) */
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d group %d not in use"),
                          unit,
                          group));
    } /* if (groupData->flags & _BCM_DPP_FIELD_GROUP_IN_USE) */
exit:
      BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_unmap
 *   Purpose
 *      Convert a bcm_dpp_counter_t into a bcm_field_stat_t
 *   Parameters
 *      (in) bcm_dpp_counter_t type = counter type desired
 *      (out) bcm_field_stat_t *stat = which stat is desired
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      There are DPP layer stats (or emulated stats) that do not map to BCM
 *      field stat types; trying to map one of these will result in the
 *      BCM_E_EMPTY error.  Any invalid input will result in BCM_E_PARAM.
 */
STATIC int
_bcm_dpp_field_stat_unmap(bcm_dpp_counter_t type,
                          bcm_field_stat_t *stat)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch (type) {
    case bcm_dpp_counter_pkts:
        *stat = bcmFieldStatPackets;
        break;
    case bcm_dpp_counter_bytes:
        *stat = bcmFieldStatBytes;
        break;
    case bcm_dpp_counter_green_pkts:
        *stat = bcmFieldStatGreenPackets;
        break;
    case bcm_dpp_counter_green_bytes:
        *stat = bcmFieldStatGreenBytes;
        break;
    case bcm_dpp_counter_not_green_pkts:
        *stat = bcmFieldStatNotGreenPackets;
        break;
    case bcm_dpp_counter_not_green_bytes:
        *stat = bcmFieldStatNotGreenBytes;
        break;
    case bcm_dpp_counter_yellow_pkts:
        *stat = bcmFieldStatYellowPackets;
        break;
    case bcm_dpp_counter_yellow_bytes:
        *stat = bcmFieldStatYellowBytes;
        break;
    case bcm_dpp_counter_not_yellow_pkts:
        *stat = bcmFieldStatNotYellowPackets;
        break;
    case bcm_dpp_counter_not_yellow_bytes:
        *stat = bcmFieldStatNotYellowBytes;
        break;
    case bcm_dpp_counter_red_pkts:
        *stat = bcmFieldStatRedPackets;
        break;
    case bcm_dpp_counter_red_bytes:
        *stat = bcmFieldStatRedBytes;
        break;
    case bcm_dpp_counter_not_red_pkts:
        *stat = bcmFieldStatNotRedPackets;
        break;
    case bcm_dpp_counter_not_red_bytes:
        *stat = bcmFieldStatNotRedBytes;
        break;
    case bcm_dpp_counter_fwd_pkts:
        *stat = bcmFieldStatAcceptedPackets;
        break;
    case bcm_dpp_counter_fwd_bytes:
        *stat = bcmFieldStatAcceptedBytes;
        break;
    case bcm_dpp_counter_fwd_green_pkts:
        *stat = bcmFieldStatAcceptedGreenPackets;
        break;
    case bcm_dpp_counter_fwd_green_bytes:
        *stat = bcmFieldStatAcceptedGreenBytes;
        break;
    case bcm_dpp_counter_fwd_not_green_pkts:
        *stat = bcmFieldStatAcceptedNotGreenPackets;
        break;
    case bcm_dpp_counter_fwd_not_green_bytes:
        *stat = bcmFieldStatAcceptedNotGreenBytes;
        break;
    case bcm_dpp_counter_fwd_yellow_pkts:
        *stat = bcmFieldStatAcceptedYellowPackets;
        break;
    case bcm_dpp_counter_fwd_yellow_bytes:
        *stat = bcmFieldStatAcceptedYellowBytes;
        break;
    case bcm_dpp_counter_fwd_not_yellow_pkts:
        *stat = bcmFieldStatAcceptedNotYellowPackets;
        break;
    case bcm_dpp_counter_fwd_not_yellow_bytes:
        *stat = bcmFieldStatAcceptedNotYellowBytes;
        break;
    case bcm_dpp_counter_fwd_red_pkts:
        *stat = bcmFieldStatAcceptedRedPackets;
        break;
    case bcm_dpp_counter_fwd_red_bytes:
        *stat = bcmFieldStatAcceptedRedBytes;
        break;
    case bcm_dpp_counter_fwd_not_red_pkts:
        *stat = bcmFieldStatAcceptedNotRedPackets;
        break;
    case bcm_dpp_counter_fwd_not_red_bytes:
        *stat = bcmFieldStatAcceptedNotRedBytes;
        break;
    case bcm_dpp_counter_drop_pkts:
        *stat = bcmFieldStatDroppedPackets;
        break;
    case bcm_dpp_counter_drop_bytes:
        *stat = bcmFieldStatDroppedBytes;;
        break;
    case bcm_dpp_counter_drop_green_pkts:
        *stat = bcmFieldStatDroppedGreenPackets;
        break;
    case bcm_dpp_counter_drop_green_bytes:
        *stat = bcmFieldStatDroppedGreenBytes;
        break;
    case bcm_dpp_counter_drop_not_green_pkts:
        *stat = bcmFieldStatDroppedNotGreenPackets;
        break;
    case bcm_dpp_counter_drop_not_green_bytes:
        *stat = bcmFieldStatDroppedNotGreenBytes;
        break;
    case bcm_dpp_counter_drop_yellow_pkts:
        *stat = bcmFieldStatDroppedYellowPackets;
        break;
    case bcm_dpp_counter_drop_yellow_bytes:
        *stat = bcmFieldStatDroppedYellowBytes;
        break;
    case bcm_dpp_counter_drop_not_yellow_pkts:
        *stat = bcmFieldStatDroppedNotYellowPackets;
        break;
    case bcm_dpp_counter_drop_not_yellow_bytes:
        *stat = bcmFieldStatDroppedNotYellowBytes;
        break;
    case bcm_dpp_counter_drop_red_pkts:
        *stat = bcmFieldStatDroppedRedPackets;
        break;
    case bcm_dpp_counter_drop_red_bytes:
        *stat = bcmFieldStatDroppedRedBytes;
        break;
    case bcm_dpp_counter_drop_not_red_pkts:
        *stat = bcmFieldStatDroppedNotRedPackets;
        break;
    case bcm_dpp_counter_drop_not_red_bytes:
        *stat = bcmFieldStatDroppedNotRedBytes;
        break;
    case bcm_dpp_counter_offset0_pkts:
        *stat = bcmFieldStatOffset0Packets;
        break;
    case bcm_dpp_counter_offset0_bytes:
        *stat = bcmFieldStatOffset0Bytes;
        break;
    case bcm_dpp_counter_offset1_pkts:
        *stat = bcmFieldStatOffset1Packets;
        break;
    case bcm_dpp_counter_offset1_bytes:
        *stat = bcmFieldStatOffset1Bytes;
        break;
    case bcm_dpp_counter_offset2_pkts:
        *stat = bcmFieldStatOffset2Packets;
        break;
    case bcm_dpp_counter_offset2_bytes:
        *stat = bcmFieldStatOffset2Bytes;
        break;
    case bcm_dpp_counter_offset3_pkts:
        *stat = bcmFieldStatOffset3Packets;
        break;
    case bcm_dpp_counter_offset3_bytes:
        *stat = bcmFieldStatOffset3Bytes;
        break;
    case bcm_dpp_counter_offset4_pkts:
        *stat = bcmFieldStatOffset4Packets;
        break;
    case bcm_dpp_counter_offset4_bytes:
        *stat = bcmFieldStatOffset4Bytes;
        break;
    case bcm_dpp_counter_offset5_pkts:
        *stat = bcmFieldStatOffset5Packets;
        break;
    case bcm_dpp_counter_offset5_bytes:
        *stat = bcmFieldStatOffset5Bytes;
        break;
    case bcm_dpp_counter_offset6_pkts:
        *stat = bcmFieldStatOffset6Packets;
        break;
    case bcm_dpp_counter_offset6_bytes:
        *stat = bcmFieldStatOffset6Bytes;
        break;
    case bcm_dpp_counter_offset7_pkts:
        *stat = bcmFieldStatOffset7Packets;
        break;
    case bcm_dpp_counter_offset7_bytes:
        *stat = bcmFieldStatOffset7Bytes;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("invalid counter type %d"), type));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_map
 *   Purpose
 *      Convert a bcm_field_stat_t into a bcm_dpp_counter_t.
 *   Parameters
 *      (in) bcm_field_stat_t stat = which stat is desired
 *      (out) bcm_dpp_counter_t *type = counter type to request
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
STATIC int
_bcm_dpp_field_stat_map(bcm_field_stat_t stat,
                        bcm_dpp_counter_t *type)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch (stat) {
    case bcmFieldStatBytes:
        *type = bcm_dpp_counter_bytes;
        break;
    case bcmFieldStatPackets:
        *type = bcm_dpp_counter_pkts;
        break;
    case bcmFieldStatGreenBytes:
        *type = bcm_dpp_counter_green_bytes;
        break;
    case bcmFieldStatGreenPackets:
        *type = bcm_dpp_counter_green_pkts;
        break;
    case bcmFieldStatYellowBytes:
        *type = bcm_dpp_counter_yellow_bytes;
        break;
    case bcmFieldStatYellowPackets:
        *type = bcm_dpp_counter_yellow_pkts;
        break;
    case bcmFieldStatRedBytes:
        *type = bcm_dpp_counter_red_bytes;
        break;
    case bcmFieldStatRedPackets:
        *type = bcm_dpp_counter_red_pkts;
        break;
    case bcmFieldStatNotGreenBytes:
        *type = bcm_dpp_counter_not_green_bytes;
        break;
    case bcmFieldStatNotGreenPackets:
        *type = bcm_dpp_counter_not_green_pkts;
        break;
    case bcmFieldStatNotYellowBytes:
        *type = bcm_dpp_counter_not_yellow_bytes;
        break;
    case bcmFieldStatNotYellowPackets:
        *type = bcm_dpp_counter_not_yellow_pkts;
        break;
    case bcmFieldStatNotRedBytes:
        *type = bcm_dpp_counter_not_red_bytes;
        break;
    case bcmFieldStatNotRedPackets:
        *type = bcm_dpp_counter_not_red_pkts;
        break;
    case bcmFieldStatAcceptedBytes:
        *type = bcm_dpp_counter_fwd_bytes;
        break;
    case bcmFieldStatAcceptedPackets:
        *type = bcm_dpp_counter_fwd_pkts;
        break;
    case bcmFieldStatAcceptedGreenBytes:
        *type = bcm_dpp_counter_fwd_green_bytes;
        break;
    case bcmFieldStatAcceptedGreenPackets:
        *type = bcm_dpp_counter_fwd_green_pkts;
        break;
    case bcmFieldStatAcceptedNotGreenBytes:
        *type = bcm_dpp_counter_fwd_not_green_bytes;
        break;
    case bcmFieldStatAcceptedNotGreenPackets:
        *type = bcm_dpp_counter_fwd_not_green_pkts;
        break;
    case bcmFieldStatAcceptedYellowBytes:
        *type = bcm_dpp_counter_fwd_yellow_bytes;
        break;
    case bcmFieldStatAcceptedYellowPackets:
        *type = bcm_dpp_counter_fwd_yellow_pkts;
        break;
    case bcmFieldStatAcceptedNotYellowBytes:
        *type = bcm_dpp_counter_fwd_not_yellow_bytes;
        break;
    case bcmFieldStatAcceptedNotYellowPackets:
        *type = bcm_dpp_counter_fwd_not_yellow_pkts;
        break;
    case bcmFieldStatAcceptedRedBytes:
        *type = bcm_dpp_counter_fwd_red_bytes;
        break;
    case bcmFieldStatAcceptedRedPackets:
        *type = bcm_dpp_counter_fwd_red_pkts;
        break;
    case bcmFieldStatAcceptedNotRedBytes:
        *type = bcm_dpp_counter_fwd_not_red_bytes;
        break;
    case bcmFieldStatAcceptedNotRedPackets:
        *type = bcm_dpp_counter_fwd_not_red_pkts;
       break;
    case bcmFieldStatDroppedBytes:
        *type = bcm_dpp_counter_drop_bytes;
        break;
    case bcmFieldStatDroppedPackets:
        *type = bcm_dpp_counter_drop_pkts;
        break;
    case bcmFieldStatDroppedGreenBytes:
        *type = bcm_dpp_counter_drop_green_bytes;
        break;
    case bcmFieldStatDroppedGreenPackets:
        *type = bcm_dpp_counter_drop_green_pkts;
        break;
    case bcmFieldStatDroppedNotGreenBytes:
        *type = bcm_dpp_counter_drop_not_green_bytes;
        break;
    case bcmFieldStatDroppedNotGreenPackets:
        *type = bcm_dpp_counter_drop_not_green_pkts;
        break;
    case bcmFieldStatDroppedYellowBytes:
        *type = bcm_dpp_counter_drop_yellow_bytes;
        break;
    case bcmFieldStatDroppedYellowPackets:
        *type = bcm_dpp_counter_drop_yellow_pkts;
        break;
    case bcmFieldStatDroppedNotYellowBytes:
        *type = bcm_dpp_counter_drop_not_yellow_bytes;
        break;
    case bcmFieldStatDroppedNotYellowPackets:
        *type = bcm_dpp_counter_drop_not_yellow_pkts;
        break;
    case bcmFieldStatDroppedRedBytes:
        *type = bcm_dpp_counter_drop_red_bytes;
        break;
    case bcmFieldStatDroppedRedPackets:
        *type = bcm_dpp_counter_drop_red_pkts;
        break;
    case bcmFieldStatDroppedNotRedBytes:
        *type = bcm_dpp_counter_drop_not_red_bytes;
        break;
    case bcmFieldStatDroppedNotRedPackets:
        *type = bcm_dpp_counter_drop_not_red_pkts;
        break;
    case bcmFieldStatOffset0Bytes:
        *type = bcm_dpp_counter_offset0_bytes;
        break;
    case bcmFieldStatOffset0Packets:
        *type = bcm_dpp_counter_offset0_pkts;
        break;
    case bcmFieldStatOffset1Bytes:
        *type = bcm_dpp_counter_offset1_bytes;
        break;
    case bcmFieldStatOffset1Packets:
        *type = bcm_dpp_counter_offset1_pkts;
        break;
    case bcmFieldStatOffset2Bytes:
        *type = bcm_dpp_counter_offset2_bytes;
        break;
    case bcmFieldStatOffset2Packets:
        *type = bcm_dpp_counter_offset2_pkts;
        break;
    case bcmFieldStatOffset3Bytes:
        *type = bcm_dpp_counter_offset3_bytes;
        break;
    case bcmFieldStatOffset3Packets:
        *type = bcm_dpp_counter_offset3_pkts;
        break;
    case bcmFieldStatOffset4Bytes:
        *type = bcm_dpp_counter_offset4_bytes;
        break;
    case bcmFieldStatOffset4Packets:
        *type = bcm_dpp_counter_offset4_pkts;
        break;
    case bcmFieldStatOffset5Bytes:
        *type = bcm_dpp_counter_offset5_bytes;
        break;
    case bcmFieldStatOffset5Packets:
        *type = bcm_dpp_counter_offset5_pkts;
        break;
    case bcmFieldStatOffset6Bytes:
        *type = bcm_dpp_counter_offset6_bytes;
        break;
    case bcmFieldStatOffset6Packets:
        *type = bcm_dpp_counter_offset6_pkts;
        break;
    case bcmFieldStatOffset7Bytes:
        *type = bcm_dpp_counter_offset7_bytes;
        break;
    case bcmFieldStatOffset7Packets:
        *type = bcm_dpp_counter_offset7_pkts;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("invalid statistics type %d"),
                          stat));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_proc_counter_check
 *   Purpose
 *      See if a particular counter processor is in the correct mode and
 *      supports the requested statistics.
 *   Parameters
 *      (in) _bcm_petra_field_info_t *unitData = pointer to unit information
 *      (in) unsigned int stage = the stage for the group being considered
 *      (in) unsigned int proc = the counter processor number
 *      (in) int nstat = number of desired statistics
 *      (in) bcm_field_stat_t stat_arr = array of desired statistics
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_CONFIG if wrong mode or requested stat not offered
 *                    BCM_E_* appropriately otherwise
 *   Notes
 */
STATIC int
_bcm_dpp_field_stat_proc_counter_check(_bcm_dpp_field_info_t *unitData,
                                       unsigned int stage,
                                       unsigned int proc,
                                       int nstat,
                                       bcm_field_stat_t *stat_arr)
{
    int result = BCM_E_NONE;
    unsigned int index;
    bcm_dpp_counter_t stat;
    bcm_dpp_counter_set_t counterSet;
    unsigned int procs;
    unsigned int source;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;

    BCMDNX_IF_ERR_EXIT_MSG(bcm_dpp_counter_diag_info_get(unit,
                                                      bcm_dpp_counter_diag_info_num_proc,
                                                      0,
                                                      &procs),
                        (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get number of"
                                          " counter processors"),
                         unit));
    if (proc >= procs) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d counter processor %u"
                                           " is invalid"),
                          unit,
                          proc));
    }
    BCMDNX_IF_ERR_EXIT_MSG(bcm_dpp_counter_diag_info_get(unit,
                                                      bcm_dpp_counter_diag_info_source,
                                                      proc,
                                                      &source),
                        (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get source for"
                                          " counter processor %u"),
                         unit,
                         proc));
    switch (unitData->stageD[stage].devInfo->hwStageId) {
    case SOC_PPD_FP_DATABASE_STAGE_INGRESS_PMF:
        if (SOC_TMC_CNT_SRC_TYPE_ING_PP != source) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d counter processor %u"
                                               " source %s not correct source"
                                               " %s for stage %u"),
                              unit,
                              proc,
                              SOC_TMC_CNT_SRC_TYPE_to_string(source),
                              SOC_TMC_CNT_SRC_TYPE_to_string(SOC_TMC_CNT_SRC_TYPE_ING_PP),
                              stage));
        }
        break;
    case SOC_PPD_FP_DATABASE_STAGE_EGRESS:
        if (SOC_TMC_CNT_SRC_TYPE_EGR_PP != source) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d counter processor %u"
                                               " source %s not correct source"
                                               " %s for stage %u"),
                              unit,
                              proc,
                              SOC_TMC_CNT_SRC_TYPE_to_string(source),
                              SOC_TMC_CNT_SRC_TYPE_to_string(SOC_TMC_CNT_SRC_TYPE_EGR_PP),
                              stage));
        }
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d stage %d does not support"
                                           " counter manipulation"),
                          unit,
                          stage));
    } /* switch (unitData->stage[stage].devInfo->hwStageId) */
    BCMDNX_IF_ERR_EXIT_MSG(bcm_dpp_counter_avail_get(unit,
                                                  proc,
                                                  &counterSet,
                                                  NULL),
                        (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get stats for"
                                          " counter processor %u"),
                         unit,
                         proc));;
    for (index = 0;
         (BCM_E_NONE == result) && (index < nstat);
         index++) {

        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "checking stat %d (%s)\n"),
                   stat_arr[index],
                   _bcm_dpp_field_stats_names[stat_arr[index]]));

        result = _bcm_dpp_field_stat_map(stat_arr[index], &stat);
        if (BCM_E_NONE == result) {
            if (!SHR_BITGET(counterSet, stat)) {
                /* this statistic is not offered */
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                                 (_BSL_BCM_MSG_NO_UNIT("requested statistic %d"
                                                   " no offered by unit %d"
                                                   " counter processor %u"),
                                  stat,
                                  unit,
                                  proc));
            }
        }
    }
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_create
 *   Purpose
 *      Create a statistics set (allocate a counter set)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int with_id = TRUE if WITH_ID, else FALSE
 *      (in) bcm_field_group_t group = the group for which it is to be created
 *      (in) int nstat = number of desired statistics
 *      (in) bcm_field_stat_t stat_arr = array of desired statistics
 *      (in/out) int *stat_id = where to find/put the stat ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Meant to be called without the lock being held
 *
 *      If WITH_ID, this will try to allocate a counter set as specified (note
 *      the specification has the counter processor ID in bits above the
 *      counter set ID, and so if used across units, all units must have the
 *      same configuration for the counter processors that can be used here).
 *      If the specified counter processor does not offer the requested
 *      statistics, or is not in a mode that can be used here, this will return
 *      BCM_E_CONFIG. If the specified counter set is already in use, it will
 *      return BCM_E_RESOURCE.  Per BCM API tradition, a bogus counter
 *      processor ID or counter set that does not exist in the current mode
 *      will return BCM_E_NOT_FOUND.
 *
 *      If not WITH_ID, this will look for a counter processor that is in a
 *      mode that can be used here and offers the requested statistics.  If it
 *      can not find such a counter processor, it will return BCM_E_CONFIG.  If
 *      it finds such a counter processor (or more than one) and is unable to
 *      allocate a counter set from any such counter processor, it will return
 *      BCM_E_RESOURCE.  This will allocate from the first counter processor
 *      that offers the requested statistics, so the configuration should have
 *      limited statistics format counter processors first, before fuller
 *      statistics format counter processors.
 */
STATIC int
_bcm_dpp_field_stat_create(int unit,
                           int with_id,
                           bcm_field_group_t group,
                           int nstat,
                           bcm_field_stat_t *stat_arr,
                           int *stat_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_group_t *groupData;
    unsigned int proc;
    unsigned int cntr;
    unsigned int procs;
    int found;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,%d,%d,*,*) enter\n"),
               unit,
               with_id?"with_id":"avail",
               group,
               nstat));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    if (0 >= nstat) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("number of statistics %d must be positive"),
                          nstat));
    }
    if (!stat_arr) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory in pointer must not be NULL")));
    }
    if (!stat_id) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    if (with_id && (0 > (*stat_id))) {
        
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("with_id stat ID %d is not valid"),
                          *stat_id));
    }
    BCMDNX_IF_ERR_EXIT_MSG(bcm_dpp_counter_diag_info_get(unit,
                                                      bcm_dpp_counter_diag_info_num_proc,
                                                      0,
                                                      &procs),
                        (_BSL_BCM_MSG_NO_UNIT("unit %d unable to get number of"
                                          " counter processors"),
                         unit));
    _DPP_FIELD_UNIT_LOCK(unitData);

    groupData = &(unitData->groupD[group]);

    if (SOC_IS_ARAD(unit))
    {
        if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_EGRESS) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                             (_BSL_BCM_MSG("bcm_petra_field_entry_stat_create "
                                       "is only supported for Ingress")));
        }
    }

    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        if (with_id) {
            result = _bcm_dpp_proc_cntr_from_stat(unitData,
                                                  *stat_id,
                                                  &proc,
                                                  &cntr);
            if (BCM_E_NONE == result) {
                result = _bcm_dpp_field_stat_proc_counter_check(unitData,
                                                                groupData->stage,
                                                                proc,
                                                                nstat,
                                                                stat_arr);
                if (BCM_E_NONE == result) {
                    result = bcm_dpp_counter_alloc(unit,
                                                   BCM_DPP_COUNTER_WITH_ID,
                                                   (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_EGRESS)?
                                                   SOC_TMC_CNT_SRC_TYPE_EGR_PP:SOC_TMC_CNT_SRC_TYPE_ING_PP,
                                                   &proc,
                                                   &cntr);
                    if (BCM_E_NONE != result) {
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unable to allocate unit %d stat"
                                              " ID %08X counter processor %u"
                                              " set %u: %d (%s)\n"),
                                   unit,
                                   *stat_id,
                                   proc,
                                   cntr,
                                   result,
                                   _SHR_ERRMSG(result)));
                    }
                }
            }
        } else { /* if (with_id) */
            found = FALSE;
            for (proc = 0; proc < procs; proc++) {
                result = _bcm_dpp_field_stat_proc_counter_check(unitData,
                                                                groupData->stage,
                                                                proc,
                                                                nstat,
                                                                stat_arr);
                if (BCM_E_NONE == result) {
                    found = TRUE;
                    result = bcm_dpp_counter_alloc(unit,
                                                   BCM_DPP_COUNTER_WITH_PROC,
                                                   SOC_TMC_CNT_SRC_TYPE_ING_PP,
                                                   &proc,
                                                   &cntr);
                    if (BCM_E_NONE == result) {
                        /* got one; stop looking now */
                        break;
                    }
                }
            }
            if (BCM_E_NONE != result) {
                if (found) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has no available counter"
                                          " sets that contain the requested"
                                          " statistics\n"),
                               unit));
                    result = BCM_E_RESOURCE;
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has no counter processor"
                                          " configured to provide the"
                                          " requested statistics\n"),
                               unit));
                    result = BCM_E_CONFIG;
                }
            } else {
                /* report ID back to caller */
                result = _bcm_dpp_stat_from_proc_cntr(unitData,
                                                      proc,
                                                      cntr,
                                                      stat_id);
            }
        } /* if (with_id) */
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,%d,%d,*,&(%08X)) return %d (%s)\n"),
               unit,
               with_id?"with_id":"avail",
               group,
               nstat,
               *stat_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      _bcm_dpp_field_stat_access_single
 *   Purpose
 *      Manipulate a single stat from a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) unsigned int proc = the counter processor
 *      (in) unsigned int cntr = the counter set
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (in) int write = TRUE to write, FALSE to read
 *      (in/out) uint64 *value = where to get/put the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 */
STATIC int
_bcm_dpp_field_stat_access_single(_bcm_dpp_field_info_t *unitData,
                                  int stat_id,
                                  unsigned int proc,
                                  unsigned int cntr,
                                  bcm_field_stat_t stat,
                                  int write,
                                  uint64 *value)
{
    int result;
    bcm_dpp_counter_t type;
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;

    unit = unitData->unit;
    result = _bcm_dpp_field_stat_map(stat, &type);
    if (BCM_E_NONE == result) {
        if (write) {
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
            if (unitData->unitFlags & _BCM_DPP_FIELD_UNIT_STAT_CACHED) {
                result = bcm_dpp_counter_set_cached(unit,
                                                    proc,
                                                    cntr,
                                                    type,
                                                    *value);
            } else {
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
                result = bcm_dpp_counter_set(unit,
                                             proc,
                                             cntr,
                                             type,
                                             *value);
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
            }
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
        } else { /* if (write) */
            if (unitData->unitFlags & _BCM_DPP_FIELD_UNIT_STAT_CACHED) {
                result = bcm_dpp_counter_get_cached(unit,
                                                    proc,
                                                    cntr,
                                                    type,
                                                    value);
            } else {
                result = bcm_dpp_counter_get(unit,
                                             proc,
                                             cntr,
                                             type,
                                             value);
            }
        } /* if (write) */
        if (BCM_E_NONE != result) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to %s unit %d stat %08X proc"
                                  " %u set %u stat %s type %d: %d (%s)\n"),
                       write?"write":"read",
                       unit,
                       stat_id,
                       proc,
                       cntr,
                       _bcm_dpp_field_stats_names[stat],
                       type,
                       result,
                       _SHR_ERRMSG(result)));
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unable to map stat %d to internal type:"
                              " %d (%s)\n"),
                   stat,
                   result,
                   _SHR_ERRMSG(result)));
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/******************************************************************************
 *
 *  API exported functions and data
 */

/*
 *  Function
 *     bcm_petra_field_init
 *  Purpose
 *     Initialise the field APIs.
 *  Parameters
 *     (in) int unit = the unit number
 *  Returns
 *     int (implied cast from bcm_error_t)
 *       BCM_E_NONE if successful
 *       BCM_E_* appropriately if not
 *  Notes
 */
int
bcm_petra_field_init(int unit)
{
    sal_mutex_t tempLock;
    int result = BCM_E_NONE;
    int auxRes;
    int index;
    _bcm_dpp_field_info_t *tempUnit = NULL;
    _bcm_dpp_field_grp_idx_t groups = 0;
    _bcm_dpp_field_ent_idx_t entriesIntTcam = 0;
    _bcm_dpp_field_ent_idx_t entriesExtTcam = 0;
    _bcm_dpp_field_ent_idx_t entriesDe = 0;
    _bcm_dpp_field_ent_idx_t nofEntriesExtTcamInfo = 0;
    uint32 ppdr;
    SOC_SAND_SUCCESS_FAILURE success;
    SOC_PPD_FP_CONTROL_INDEX control_ndx;
    SOC_PPD_FP_CONTROL_INFO control_info;
    unsigned int allocSize=0;

    _bcm_dpp_field_stage_idx_t stage;
    int grpResCount = 0;
    int entResCount = 0;
    int entDeResCount = 0;
    int entDeCount;
    uint32 entCount;
    int grpCount;
    int type;
    int offset;
    int adjust;
    int found;
    int resType;
    int bcmQualSize;
    int32 flags;
    unsigned int ppdQualSize;
    unsigned int tempQualSize;
    unsigned int rangeQualTypes;
    _bcm_dpp_field_device_info_t *devInfo;
    bcm_field_qualify_t qual;
    bcm_field_action_t action;
    bcm_field_qset_t rangeQual;
    char name[64];
    SOC_SAND_OCC_BM_INIT_INFO bmp_init_info; 
    uint32 soc_sand_rv;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d) enter\n"), unit));

    /* Make sure the global lock exists */
    if (!_bcm_dpp_field_glob_lock) {
        /* Global lock does not exist */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "create global lock\n")));
        tempLock = sal_mutex_create("soc_petra_field_global_lock");
        if (!tempLock) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,
                             (_BSL_BCM_MSG("unable to create global lock")));
        }
        /* Claim the global lock before exposing it */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "claim global lock\n")));
        if (sal_mutex_take(tempLock, sal_mutex_FOREVER)) {
            /* something went wrong claiming the lock */
            /* free the working lock even though it's defective */
            sal_mutex_destroy(tempLock);
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG("unable to claim global lock in create")));
        }
        /* Set the global lock to the one we now own, if it's still none */
        if (!_bcm_dpp_field_glob_lock) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set global lock\n")));
            _bcm_dpp_field_glob_lock = tempLock;
        }
        /* Let everybody else catch up */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "give up timeslice\n")));
        sal_thread_yield();
        /* Check for race condition and compensate if needed */
        if (_bcm_dpp_field_glob_lock != tempLock) {
            /* somebody came along during the race hole; yield to them */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "detected race condition on field init for"
                                  " unit %d: trying to compensate\n"),
                       unit));
            /*
             *  We encountered a race condition during the hole beteen testing
             *  whether there was a global lock and setting it.  This hole
             *  seems to be impossible to avoid using C (and may be impossible
             *  to avoid in assembly on any platform that does not support a
             *  move-if-destination-is-zero type of instruction).
             *
             *  We compensate for this condition by destroying the losing copy
             *  of the primary lock (ours, since the other thread stomped ours)
             *  and going on.  We'll pick up the winning copy later (before
             *  filling in the unit data), so there should not be an error here
             *  (though the diagnostic may be useful and we definitely do need
             *  to free our lock in order to avoid leaking it).
             *
             *  If another thread is already waiting on our lock instead of the
             *  winner, it should receive an error during its next timeslice at
             *  the point of the wait, and that will propagate back to the
             *  caller as BCM_E_INTERNAL (there doesn't seem to be anything
             *  better for it).
             *
             *  This is a Bad Thing, but it is not, in itself, unrecoverable.
             *  We therefore continue without any error indication other than
             *  the diagnostic message (and any thread that was waiting on our
             *  lock can retry and should be okay, since it will also pick up
             *  the new global lock).
             *
             *  Unhappily, the race condition check is itself susceptible to
             *  the same condition for which it checks, so there's still a
             *  possibility of leaks and contention here.  Hopefully nobody's
             *  doing parallelised inits of the same subsystem on true parallel
             *  hardware or preemptive timesharing systems...
             */
            sal_mutex_destroy(tempLock);
        } else { /* if (_bcm_dpp_field_glob_lock != tempLock) */
            /* no obvious race condition or we won it */
            /* Clear the global resources */
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "clear global unit information\n")));
            sal_memset(&(_bcm_dpp_field_unit_info),
                       0x00,
                       sizeof(_bcm_dpp_field_unit_info[0]) * BCM_MAX_NUM_UNITS);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up global mapping tables\n")));
            /* release the global lock */
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "release global lock\n")));
            if (sal_mutex_give(tempLock)) {
                /* something went wrong */
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                                 (_BSL_BCM_MSG("unable to release global lock"
                                           " in create")));
            }
        } /* if (_bcm_dpp_field_glob_lock != tempLock) */
    } /* if (!_bcm_dpp_field_glob_lock) */

    /* Take the global lock */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "take global lock\n")));
    if (sal_mutex_take(_bcm_dpp_field_glob_lock, sal_mutex_FOREVER)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unable to take global lock")));
    }

    /* get the descriptor for this device */
#ifdef BCM_PETRAB_SUPPORT
    if (SOC_IS_PETRAB(unit)) {
		{
			devInfo = &_bcm_petra_field_device_info;
		}
    } else
#endif /* def BCM_PETRAB_SUPPORT */
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        devInfo = &_bcm_arad_field_device_info;
        if (!(SOC_DPP_IS_ELK_ENABLE(unit))) {
            /* Set max number of external entries like INCLUDE_KBP compilation flag is not defined */
            devInfo->stage[SOC_PPD_FP_DATABASE_STAGE_INGRESS_PMF].maxEntriesExternalTcam = 2;
        }
    } else
#endif /* def BCM_ARAD_SUPPORT*/
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("not supported")));
    }

    
    if (sizeof(SOC_PPD_FP_QUAL_TYPE) != sizeof(devInfo->qualMap[0])) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unexpected difference in table sizes;"
                                   " must ensure SOC_PPD_FP_QUAL_TYPE is same"
                                   " size as _bcm_dpp_field_device_info_t"
                                   ".qualMaps[0]")));
    }

    /* If the unit is already initialised, tear it down */
    if (_bcm_dpp_field_unit_info[unit]) {
        result = _bcm_dpp_field_detach(unit);
    }
    /* reset the device */
    if (BCM_E_NONE == result) {
#ifdef BCM_WARM_BOOT_SUPPORT
        if (!SOC_WARM_BOOT(unit)) {
#endif /* def BCM_WARM_BOOT_SUPPORT */
            result = _bcm_petra_field_unit_reset(unit);
#ifdef BCM_WARM_BOOT_SUPPORT
        } /* if (!SOC_WARM_BOOT(unit)) */
#endif /* def BCM_WARM_BOOT_SUPPORT */
    } /* if (BCM_E_NONE == result) */

    /* sanity check limits */
    if (devInfo->types > _BCM_DPP_FIELD_MAX_GROUP_TYPES) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d requires adjustment to the"
                              " _BCM_DPP_FIELD_MAX_GROUP_TYPES setting:"
                              " it wants %d but current limit is %d\n"),
                   unit,
                   devInfo->types,
                   _BCM_DPP_FIELD_MAX_GROUP_TYPES));
    }
    if (devInfo->actChain > _BCM_DPP_FIELD_ACTION_CHAIN_MAX) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d requires adjustment to the"
                              " _BCM_DPP_FIELD_ACTION_CHAIN_MAX setting:"
                              " it wants %d but current limit is %d\n"),
                   unit,
                   devInfo->actChain,
                   _BCM_DPP_FIELD_ACTION_CHAIN_MAX));
    }
    if (devInfo->qualChain > _BCM_DPP_FIELD_QUAL_CHAIN_MAX) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d requires adjustment to the"
                              " _BCM_DPP_FIELD_QUAL_CHAIN_MAX setting:"
                              " it wants %d but current limit is %d\n"),
                   unit,
                   devInfo->qualChain,
                   _BCM_DPP_FIELD_QUAL_CHAIN_MAX));
    }

    /* compute certain changeable memory needs up front */
    for (rangeQualTypes = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldQualifyCount > devInfo->ranges[rangeQualTypes].qualifier) &&
         (0 <= devInfo->ranges[rangeQualTypes].qualifier);
         rangeQualTypes++) {
        /* simply count the elements in this table; check details later */
    }

    /* allocate static resources up front */
    if (BCM_E_NONE == result) {
        /* determine number of entries and groups maximum */
        groups = 0;
        entriesIntTcam = 0;
        entriesExtTcam = 0;
        entriesDe = 0;
        {
            for (stage = 0; stage < devInfo->stages; stage++) {
                groups += devInfo->stage[stage].maxGroups;
                entriesIntTcam += devInfo->stage[stage].maxEntriesInternalTcam;
                entriesExtTcam += devInfo->stage[stage].maxEntriesExternalTcam;
                entriesDe += devInfo->stage[stage].maxEntriesDe;
            }
            nofEntriesExtTcamInfo = SOC_SAND_MIN(entriesExtTcam, _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit));
            if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "unbound_uninstalled_external_tcam_entries_number", 0)){                
                nofEntriesExtTcamInfo = entriesExtTcam;/* in this case the SW state will be equal to actual number of entries */
            }			
     
        }
        /* allocate memory for the unit description, groups, entries */
        allocSize = (sizeof(*tempUnit) +
                     sizeof(_bcm_dpp_field_group_t) * groups +
                     sizeof(_bcm_dpp_field_entry_t) * entriesIntTcam +
                     sizeof(_bcm_dpp_field_entry_ext_t) * entriesExtTcam +
                     sizeof(_bcm_dpp_field_entry_ext_info_t) * nofEntriesExtTcamInfo +
                     sizeof(_bcm_dpp_field_entry_dir_ext_t) * entriesDe +
                     sizeof(_bcm_dpp_field_stage_t) * devInfo->stages +
                     sizeof(SHR_BITDCL*) * rangeQualTypes +
                     SHR_BITALLOCSIZE(_BCM_DPP_RANGE_MAX_COUNT) * rangeQualTypes);
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "allocate unit %d memory: %u stages, %u"
                              " groups, %u entries internal, %u entries external, "
                              "%u direct extraction entries, %u preselectors, %d range types;"
                              " %u bytes total\n"),
                   unit,
                   (unsigned int)devInfo->stages,
                   (unsigned int)groups,
                   (unsigned int)entriesIntTcam,
                   (unsigned int)entriesExtTcam,
                   (unsigned int)entriesDe,
                   (unsigned int)devInfo->presels,
                   rangeQualTypes,
                   allocSize));
        BCMDNX_ALLOC(tempUnit, allocSize, "BCM Soc_petra field unit info");
        if (!tempUnit) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to allocate %u bytes for unit %d"
                                  " information\n"),
                       allocSize,
                       unit));
            result = BCM_E_MEMORY;
        }
    } /* if (BCM_E_NONE == result) */
    if (BCM_E_NONE == result) {
        /* initialise allocated memory */
        sal_memset(tempUnit, 0x00, allocSize);
        tempUnit->unit = unit;
        tempUnit->unitHandle = (unit);
        tempUnit->totalSize = allocSize;
        tempUnit->devInfo = devInfo;
        /* set up partitions within the alloc cell */
        tempUnit->stageD = (_bcm_dpp_field_stage_t*)(&(tempUnit[1]));
        tempUnit->groupD = (_bcm_dpp_field_group_t*)(&(tempUnit->stageD[devInfo->stages]));
        tempUnit->entryTc = (_bcm_dpp_field_entry_t*)(&(tempUnit->groupD[groups]));
        tempUnit->entryExtTc = (_bcm_dpp_field_entry_ext_t*)(&(tempUnit->entryTc[entriesIntTcam]));
        tempUnit->extTcamInfo = (_bcm_dpp_field_entry_ext_info_t *)(&(tempUnit->entryExtTc[entriesExtTcam]));
        tempUnit->entryDe = (_bcm_dpp_field_entry_dir_ext_t*)(&(tempUnit->extTcamInfo[nofEntriesExtTcamInfo]));
        tempUnit->rangeQualTypes = rangeQualTypes;
        /* create unit lock */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "create unit %d lock\n"), unit));
        tempUnit->unitLock = sal_mutex_create("BCM Petra Field unit lock");
        if (!(tempUnit->unitLock)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unable to create unit %d lock\n"), unit));
            result = BCM_E_RESOURCE;
        }
    } /* if (BCM_E_NONE == result) */

    if (SOC_DPP_IS_ELK_ENABLE(unit)) {
        if (BCM_E_NONE == result) {
            /* initialize external TCAM info table */
            for(index = 0; index < nofEntriesExtTcamInfo; index++) {
                _bcm_dpp_field_ext_info_entry_clear(&(tempUnit->extTcamInfo[index]));
            }

            /* allocate external TCAM information occupation bitmap */
            soc_sand_SAND_OCC_BM_INIT_INFO_clear(&bmp_init_info);
            bmp_init_info.size = nofEntriesExtTcamInfo;
            soc_sand_rv = soc_sand_occ_bm_create(
                            unit,
                            &bmp_init_info,
                            &(tempUnit->extTcamBmp));
            result = handle_sand_result(soc_sand_rv);
        }/* if (BCM_E_NONE == result) */
    }/* if (SOC_DPP_IS_ELK_ENABLE(unit)) */

    /* compute resource tracking needs */
    if (BCM_E_NONE == result) {
        for (stage = 0;
             (BCM_E_NONE == result) && (stage < devInfo->stages);
             stage++) {
            tempUnit->stageD[stage].devInfo = &(devInfo->stage[stage]);
            tempUnit->stageD[stage].entryRes = -1;
            tempUnit->stageD[stage].entryDeRes = -1;
            tempUnit->stageD[stage].groupRes = -1;
            /* include this stage in global limits */
            tempUnit->groupLimit += devInfo->stage[stage].maxGroups;
            tempUnit->entryTcLimit += devInfo->stage[stage].maxEntriesInternalTcam;
            tempUnit->entryExtTcLimit += devInfo->stage[stage].maxEntriesExternalTcam;
            tempUnit->entryDeLimit += devInfo->stage[stage].maxEntriesDe;
            /* validate shared hardware ID ranges */
            if (devInfo->stage[stage].sharesEntriesTc >= stage) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u shares entry space"
                                      " with not-yet-seen stage %d\n"),
                           unit,
                           stage,
                           devInfo->stage[stage].sharesEntriesTc));
            }
            if (devInfo->stage[stage].sharesGroups >= stage) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u shares group space"
                                      " with not-yet-seen stage %d\n"),
                           unit,
                           stage,
                           devInfo->stage[stage].sharesGroups));
            }
            if (devInfo->stage[stage].sharesEntriesDe >= stage) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d stage %u shares dir ext entry"
                                      " space with not-yet-seen stage %d\n"),
                           unit,
                           stage,
                           devInfo->stage[stage].sharesEntriesDe));
            }
            if (BCM_E_NONE == result) {
                if (0 > devInfo->stage[stage].sharesGroups) {
                    grpResCount++; /* another group ID pool is needed */
                }
                if (0 > devInfo->stage[stage].sharesEntriesTc) {
                    entResCount++; /* another entry ID pool is needed */
                }
                if ((0 > devInfo->stage[stage].sharesEntriesDe) &&
                    (0 < devInfo->stage[stage].maxEntriesDe)) {
                    entDeResCount++; /* another dir ext ent ID pool needed */
                }
                entCount = 0;
                grpCount = 0;
                entDeCount = 0;
                /* compute limit for possibly shared hardware entry IDs */
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesEntriesTc) {
                    entCount += devInfo->stage[offset].maxEntriesInternalTcam;
                    entCount += devInfo->stage[offset].maxEntriesExternalTcam;
                }
                if (!entCount) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d stage %u claims to support"
                                          " zero entries\n"),
                               unit,
                               stage));
                }
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesEntriesTc) {
                    tempUnit->stageD[stage].entryTcSh1 = offset;
                    tempUnit->stageD[offset].hwEntryLimit = entCount;
                }
                /* compute limit for possibly shared hardware group IDs */
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesGroups) {
                    grpCount += devInfo->stage[offset].maxGroups;
                }
                if (!grpCount) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d stage %u claims to support"
                                          " zero groups\n"),
                               unit,
                               stage));
                }
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesGroups) {
                    tempUnit->stageD[stage].groupSh1 = offset;
                    tempUnit->stageD[offset].hwGroupLimit = grpCount;
                }
                /* compute limit for possibly shared HW dir ext ent IDs */
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesEntriesDe) {
                    entDeCount += devInfo->stage[offset].maxEntriesDe;
                }
                /* it is not an error for a stage to not support dir ext */
                for (offset = stage;
                     0 <= offset;
                     offset = devInfo->stage[offset].sharesEntriesDe) {
                    tempUnit->stageD[stage].entryDeSh1 = offset;
                    tempUnit->stageD[offset].hwEntryDeLimit = entDeCount;
                }
            } /* if (BCM_E_NONE == result) */
        } /* for (index = 0; index < devInfo->stages; index++) */
    } /* if (BCM_E_NONE == result) */
    if (BCM_E_NONE == result) {
        /*
         *  Set up boundaries and build lists for resources that need to be
         *  kept in lists.
         */
        for (stage = 0; stage < devInfo->stages; stage++) {
            tempUnit->stageD[stage].groupHead = tempUnit->groupLimit;
            tempUnit->stageD[stage].groupTail = tempUnit->groupLimit;
        }
        tempUnit->rangeInUse = (SHR_BITDCL**)(&(tempUnit->entryDe[entriesDe]));
        if (rangeQualTypes) {
            tempUnit->rangeInUse[0] = (SHR_BITDCL*)(&(tempUnit->rangeInUse[rangeQualTypes]));
            for (index = 1; index < rangeQualTypes; index++) {
                tempUnit->rangeInUse[index] = &(tempUnit->rangeInUse[index - 1][_SHR_BITDCLSIZE(_BCM_DPP_RANGE_MAX_COUNT)]);
            }
        }
        tempUnit->groupD[0].groupPrev = groups;
        tempUnit->groupD[0].stage = devInfo->stages;
        for (index = 1; index < groups; index++) {
            tempUnit->groupD[index - 1].groupNext = index;
            tempUnit->groupD[index].groupPrev = index - 1;
            tempUnit->groupD[index].stage = devInfo->stages;
        }
        tempUnit->groupD[groups - 1].groupNext = groups;

        tempUnit->entryTc[0].entryCmn.entryPrev = entriesIntTcam;
        tempUnit->entryTc[0].entryCmn.entryGroup = tempUnit->groupLimit;
        for (index = 1; index < entriesIntTcam; index++) {
            tempUnit->entryTc[index - 1].entryCmn.entryNext = index;
            tempUnit->entryTc[index].entryCmn.entryPrev = index - 1;
            tempUnit->entryTc[index].entryCmn.entryGroup = tempUnit->groupLimit;
        }
        tempUnit->entryTc[entriesIntTcam - 1].entryCmn.entryNext = entriesIntTcam;

        tempUnit->entryExtTc[0].entryCmn.entryPrev = entriesExtTcam;
        tempUnit->entryExtTc[0].entryCmn.entryGroup = tempUnit->groupLimit;
        for (index = 1; index < entriesExtTcam; index++) {
            tempUnit->entryExtTc[index - 1].entryCmn.entryNext = index;
            tempUnit->entryExtTc[index].entryCmn.entryPrev = index - 1;
            tempUnit->entryExtTc[index].entryCmn.entryGroup = tempUnit->groupLimit;
        }
        tempUnit->entryExtTc[entriesExtTcam - 1].entryCmn.entryNext = entriesExtTcam;

        tempUnit->entryDe[0].entryCmn.entryPrev = entriesDe;
        tempUnit->entryDe[0].entryCmn.entryGroup = tempUnit->groupLimit;
        for (index = 1; index < entriesDe; index++) {
            tempUnit->entryDe[index - 1].entryCmn.entryNext = index;
            tempUnit->entryDe[index].entryCmn.entryPrev = index - 1;
            tempUnit->entryDe[index].entryCmn.entryGroup = tempUnit->groupLimit;
        }
        tempUnit->entryDe[entriesDe - 1].entryCmn.entryNext = entriesDe;
        for (index = 0; index < SOC_PPD_NOF_FP_QUAL_TYPES; index++) {
            tempUnit->ppdQual[index] = bcmFieldQualifyCount;
        }
        if (tempUnit->groupLimit != groups) {
            result = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unexpected difference between computed"
                                  " maximum group counts: %d versus %d\n"),
                       tempUnit->groupLimit,
                       groups));
        }
        if (tempUnit->entryTcLimit != entriesIntTcam) {
            result = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unexpected difference between computed"
                                  " maximum entry counts: internal-%d, external-%d, versus %d\n"),
                       tempUnit->entryTcLimit,
                       tempUnit->entryExtTcLimit,
                       entriesIntTcam));
        }
        if (tempUnit->entryExtTcLimit != entriesExtTcam) {
            result = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unexpected difference between computed"
                                  " maximum entry counts: internal-%d, external-%d, versus %d\n"),
                       tempUnit->entryTcLimit,
                       tempUnit->entryExtTcLimit,
                       entriesExtTcam));
        }
    }
    if (BCM_E_NONE == result) {
        /* create resource management for the hardware group and entry IDs */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d will require %d resource pools: %d"
                              " for groups, %d for entries, %d for direct"
                              " extraction entries; it will also"
                              " require %d resource types, %d per stage"
                              " over %d stages\n"),
                   unit,
                   grpResCount + entResCount + entDeResCount,
                   grpResCount,
                   entResCount,
                   entDeResCount,
                   devInfo->stages * _BCM_DPP_FIELD_RESOURCES_PER_STAGE,
                   _BCM_DPP_FIELD_RESOURCES_PER_STAGE,
                   devInfo->stages));
        result = shr_mres_create(&(tempUnit->hwResIds),
                                 devInfo->stages * _BCM_DPP_FIELD_RESOURCES_PER_STAGE,
                                 entResCount + grpResCount + entDeResCount);
        if (BCM_E_NONE != result) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unable to create hardware"
                                  " ID resource management: %d (%s)\n"),
                       unit,
                       result,
                       _SHR_ERRMSG(result)));
        }
    }
    /* set up group ID resources */
    for (stage = 0, offset = 0, resType = 0;
         (BCM_E_NONE == result) && (stage < devInfo->stages);
         stage++) {
        /*
         *  Hardware group ID pools are allocated as needed.
         */
        if (0 > devInfo->stage[stage].sharesGroups) {
            /* this stage does not share with prior stage; need new pool */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW group ID pool %d",
                         offset);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       offset));
            result = shr_mres_pool_set(tempUnit->hwResIds,
                                       offset /* pool ID */,
                                       SHR_RES_ALLOCATOR_BITMAP,
                                       0 /* minimum ID */,
                                       tempUnit->stageD[stage].hwGroupLimit,
                                       NULL /* extras */,
                                       &(name[0]));
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d unable to create group ID"
                                      " resource pool %d: %d (%s)\n"),
                           unit,
                           offset,
                           result,
                           _SHR_ERRMSG(result)));
                break;
            }
            /* also need new type since this is per stage */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW group ID, stage %u %s",
                         stage,
                         tempUnit->stageD[stage].devInfo->stageName);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       resType));
            result = shr_mres_type_set(tempUnit->hwResIds,
                                       resType,
                                       offset /* pool ID */,
                                       1 /* element size */,
                                       &(name[0]));
            offset++;
        } else {
            /* shares with a prior stage, so just set up new type */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW group ID, stage %u %s",
                         stage,
                         tempUnit->stageD[stage].devInfo->stageName);
            result = shr_mres_type_get(tempUnit->hwResIds,
                                       tempUnit->stageD[devInfo->stage[stage].sharesGroups].groupRes,
                                       &adjust,
                                       NULL,
                                       NULL);
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d unable to get stage %d group ID"
                                      " pool information: %d (%s)\n"),
                           unit,
                           devInfo->stage[stage].sharesGroups,
                           result,
                           _SHR_ERRMSG(result)));
                break;
            }
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       resType));
            result = shr_mres_type_set(tempUnit->hwResIds,
                                       resType,
                                       adjust /* pool ID */,
                                       1 /* element size */,
                                       &(name[0]));
        }
        tempUnit->stageD[stage].groupRes = resType;
        resType++;
        if (BCM_E_NONE != result) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unable to create group ID resource"
                                  " type %u: %d (%s)\n"),
                       unit,
                       stage,
                       result,
                       _SHR_ERRMSG(result)));
        }
    } /* for (stage = 0; stage < unitData->stageLimit; stage++) */
    /* set up entry ID resources -- entry pools follow group pools */
    for (stage = 0, found = offset;
         (BCM_E_NONE == result) && (stage < devInfo->stages);
         stage++) {
        /*
         *  Hardware entry ID pools are allocated as needed, following the
         *  hardware group ID pools.
         */
        if (0 > devInfo->stage[stage].sharesEntriesTc) {
            /* this stage does not share with prior stage; need new pool */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW entry ID pool %d",
                         offset - found);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       offset));
            result = shr_mres_pool_set(tempUnit->hwResIds,
                                       offset /* pool ID */,
                                       SHR_RES_ALLOCATOR_IDXRES,
                                       0 /* minimum ID */,
                                       tempUnit->stageD[stage].hwEntryLimit,
                                       NULL /* extras */,
                                       &(name[0]));
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d unable to create entry ID"
                                      " resource pool %d: %d (%s)\n"),
                           unit,
                           offset,
                           result,
                           _SHR_ERRMSG(result)));
                break;
            }
            /* also need new type since this is per stage */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW entry ID, stage %u %s",
                         stage,
                         tempUnit->stageD[stage].devInfo->stageName);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       resType));
            result = shr_mres_type_set(tempUnit->hwResIds,
                                       resType,
                                       offset /* pool ID */,
                                       1 /* element size */,
                                       &(name[0]));
            offset++;
        } else {
            /* shares with a prior stage, so just set up new type */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW entry ID, stage %u %s",
                         stage,
                         tempUnit->stageD[stage].devInfo->stageName);
            result = shr_mres_type_get(tempUnit->hwResIds,
                                       tempUnit->stageD[devInfo->stage[stage].sharesEntriesTc].entryRes,
                                       &adjust,
                                       NULL,
                                       NULL);
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d unable to get stage %d entry ID"
                                      " pool information: %d (%s)\n"),
                           unit,
                           devInfo->stage[stage].sharesEntriesTc,
                           result,
                           _SHR_ERRMSG(result)));
                break;
            }
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       resType));
            result = shr_mres_type_set(tempUnit->hwResIds,
                                       resType,
                                       adjust /* pool ID */,
                                       1 /* element size */,
                                       &(name[0]));
        }
        tempUnit->stageD[stage].entryRes = resType;
        resType++;
        if (BCM_E_NONE != result) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unable to create entry ID resource"
                                  " type %u: %d (%s)\n"),
                       unit,
                       stage,
                       result,
                       _SHR_ERRMSG(result)));
        }
    } /* for (stage = 0; stage < unitData->stageLimit; stage++) */
    for (stage = 0, found = offset;
         (BCM_E_NONE == result) && (stage < devInfo->stages);
         stage++) {
        /*
         *  Hardware direct extraction entry ID pools are allocated as needed,
         *  following the hardware entry ID pools.
         */
        if (0 >= devInfo->stage[stage].maxEntriesDe) {
            /*
             *  This stage has no direct extraction entries; skip it.
             *
             *  However, the resource it *would have used* for direct
             *  extraction entries is still marked, so we have an extra layer
             *  of error checking: any attempt to use direct extraction entries
             *  that is not caught otherwise will fail to allocate one, rather
             *  then allocating some other resource mistakenly.
             */
            tempUnit->stageD[stage].entryDeRes = resType;
            resType++;
            continue;
        }
        if (0 > devInfo->stage[stage].sharesEntriesDe) {
            /* this stage does not share with prior stage; need new pool */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW dir ext ent ID pool %d",
                         offset - found);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       offset));
            result = shr_mres_pool_set(tempUnit->hwResIds,
                                       offset /* pool ID */,
                                       SHR_RES_ALLOCATOR_BITMAP,
                                       0 /* minimum ID */,
                                       tempUnit->stageD[stage].hwEntryDeLimit,
                                       NULL /* extras */,
                                       &(name[0]));
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d unable to create dir ext entry"
                                      " ID resource pool %d: %d (%s)\n"),
                           unit,
                           offset,
                           result,
                           _SHR_ERRMSG(result)));
                break;
            }
            /* also need new type since this is per stage */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW dir ext ent ID, stage %u %s",
                         stage,
                         tempUnit->stageD[stage].devInfo->stageName);
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       resType));
            result = shr_mres_type_set(tempUnit->hwResIds,
                                       resType,
                                       offset /* pool ID */,
                                       1 /* element size */,
                                       &(name[0]));
            offset++;
        } else {
            /* shares with a prior stage, so just set up new type */
            sal_snprintf(&(name[0]),
                         sizeof(name) - 1,
                         "HW dir ext ent ID, stage %u %s",
                         stage,
                         tempUnit->stageD[stage].devInfo->stageName);
            result = shr_mres_type_get(tempUnit->hwResIds,
                                       tempUnit->stageD[devInfo->stage[stage].sharesEntriesDe].entryDeRes,
                                       &adjust,
                                       NULL,
                                       NULL);
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d unable to get stage %d dir ext"
                                      " ent ID pool information: %d (%s)\n"),
                           unit,
                           devInfo->stage[stage].sharesEntriesDe,
                           result,
                           _SHR_ERRMSG(result)));
                break;
            }
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up unit %d %s, %d\n"),
                       unit,
                       name,
                       resType));
            result = shr_mres_type_set(tempUnit->hwResIds,
                                       resType,
                                       adjust /* pool ID */,
                                       1 /* element size */,
                                       &(name[0]));
        }
        tempUnit->stageD[stage].entryDeRes = resType;
        resType++;
        if (BCM_E_NONE != result) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unable to create dir ext entry ID"
                                  " resource type %u: %d (%s)\n"),
                       unit,
                       stage,
                       result,
                       _SHR_ERRMSG(result)));
        }
    } /* for (stage = 0; stage < unitData->stageLimit; stage++) */

#ifdef BCM_PETRAB_SUPPORT
    /* compensate for group use in IPv4 host extend (PetraB only) */
    if (SOC_IS_PETRAB(unit) &&
        (BCM_E_NONE == result) &&
        soc_pb_pp_sw_db_ipv4_host_extend_enable_get(tempUnit->unitHandle)) {
        for (stage = 0, found = FALSE;
             (BCM_E_NONE == result) && (stage < devInfo->stages);
             stage++) {
            if (SOC_PPC_FP_DATABASE_STAGE_INGRESS_PMF ==
                devInfo->stage[stage].hwStageId) {
                found = TRUE;
                /* reserve the highest group ID in matching stages */
                adjust = tempUnit->stageD[stage].hwGroupLimit - 1;
                result = shr_mres_alloc(tempUnit->hwResIds,
                                        tempUnit->stageD[stage].groupRes,
                                        SHR_RES_ALLOC_WITH_ID,
                                        1 /* count */,
                                        &adjust);
                if (BCM_E_EXISTS == result) {
                    /* okay, must have already done this on earlier stage */
                    result = BCM_E_NONE;
                }
                if (BCM_E_NONE == result) {
                    /* reserve the lowest entry ID in matching stages */
                    adjust = 0;
                    result = shr_mres_alloc(tempUnit->hwResIds,
                                            tempUnit->stageD[stage].entryDeRes,
                                            SHR_RES_ALLOC_WITH_ID,
                                            1 /* count */,
                                            &adjust);
                    if (BCM_E_EXISTS == result) {
                        /* okay, must have already done it on earlier stage */
                        result = BCM_E_NONE;
                    }
                }
            } /* if (ingress type stage) */
        } /* for (all stages in this device as long as no error) */
        if (found) {
            LOG_WARN(BSL_LS_BCM_FP,
                     (BSL_META_U(unit,
                                 "unit %d has IPv4 host extend enabled;"
                                 " this feature consumes field resources"
                                 " and is not tracked by the field APIs."
                                 "  It is possible that resources may be"
                                 " exhausted before detected by the field"
                                 " APIs.\n"),
                      unit));
        }
    } /* if (ipv4 host extend is enabled) */
#endif /* def BCM_PETRAB_SUPPORT */

    if(!SOC_WARM_BOOT(unit)) {
        /* set default cascaded key length */
        if (BCM_E_NONE == result) {
            SOC_PPD_FP_CONTROL_INDEX_clear(&control_ndx);
            SOC_PPD_FP_CONTROL_INFO_clear(&control_info);
            control_ndx.type = SOC_PPD_FP_CONTROL_TYPE_KEY_CHANGE_SIZE;
            control_ndx.val_ndx = 0;
            control_info.val[0] = 12;
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set cascaded key length %d\n"),
                       control_info.val[0]));
            ppdr = soc_ppd_fp_control_set(tempUnit->unitHandle,
                                          SOC_CORE_INVALID,
                                          &control_ndx,
                                          &control_info,
                                          &success);
            result = handle_sand_result(ppdr);
            if (BCM_E_NONE == result) {
                result = translate_sand_success_failure(success);
            }
            if (BCM_E_NONE == result) {
                tempUnit->cascadedKeyLen = control_info.val[0];
            }
        }
    }

    /* parse the bits per group mode table */
    for (index = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldGroupModeCount > devInfo->modeBits[index].mode);
         index++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "scanning unit %d group mode table at %d\n"),
                   unit,
                   index));
        /* validate the settings in the table */
        if (devInfo->modeBits[index].stage >= devInfo->stages) {
            result = BCM_E_CONFIG;

            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d mode bits tries to set bit width %d"
                                  " for mode %d (%s) in invalid stage %d\n"),
                       unit,
                       devInfo->modeBits[index].length,
                       devInfo->modeBits[index].mode,
                       _bcm_dpp_field_group_mode_name[devInfo->modeBits[index].mode],
                       devInfo->modeBits[index].stage));
        }
        if (devInfo->modeBits[index].length <= 0) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d mode bits tries to set invalid"
                                  " length %d for mode %d (%s) in stage %d"
                                  " (%s)\n"),
                       unit,
                       devInfo->modeBits[index].length,
                       devInfo->modeBits[index].mode,
                       _bcm_dpp_field_group_mode_name[devInfo->modeBits[index].mode],
                       devInfo->modeBits[index].stage,
                       devInfo->stage[devInfo->modeBits[index].stage].stageName));
        }
        if (bcmFieldGroupModeAuto == devInfo->modeBits[index].mode) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d mode bits tries to set width %d for"
                                  " mode %d (%s) in stage %d (%s), but this is"
                                  " done automatically\n"),
                       unit,
                       devInfo->modeBits[index].length,
                       devInfo->modeBits[index].mode,
                       _bcm_dpp_field_group_mode_name[devInfo->modeBits[index].mode],
                       devInfo->modeBits[index].stage,
                       devInfo->stage[devInfo->modeBits[index].stage].stageName));
        }
        if (tempUnit->stageD[devInfo->modeBits[index].stage].modeBits[devInfo->modeBits[index].mode]) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d mode bits tries to set data for"
                                  " mode %d (%s) in stage %d (%s) after it was"
                                  " already set\n"),
                       unit,
                       devInfo->modeBits[index].mode,
                       _bcm_dpp_field_group_mode_name[devInfo->modeBits[index].mode],
                       devInfo->modeBits[index].stage,
                       devInfo->stage[devInfo->modeBits[index].stage].stageName));
        }
        if (BCM_E_NONE == result) {
            tempUnit->stageD[devInfo->modeBits[index].stage].modeBits[devInfo->modeBits[index].mode] = &(devInfo->modeBits[index]);
        }
    } /* for (all entries in modeBits table) */
    if ((BCM_E_NONE == result) &&
        (devInfo->modeBits[index].mode > bcmFieldGroupModeCount)) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d mode bits contains entry setting stage"
                              " %d and invalid mode %d to width %d; is the end"
                              " of list entry correct?\n"),
                   unit,
                   devInfo->modeBits[index].stage,
                   devInfo->modeBits[index].mode,
                   devInfo->modeBits[index].length));
    }
    /* find the maximum number of bits for a group and keep as 'Auto' */
    for (stage = 0;
         (BCM_E_NONE == result) && (stage < devInfo->stages);
         stage++) {
        offset = 0;
        for (index = 0; index < bcmFieldGroupModeCount; index++) {
            if ((bcmFieldGroupModeAuto != index) &&
                tempUnit->stageD[stage].modeBits[index] &&
                (_BCM_DPP_FIELD_ENT_TYPE_IS_TCAM(tempUnit->stageD[stage].modeBits[index]->entryType)) &&
                (offset < tempUnit->stageD[stage].modeBits[index]->length)) {
                /* this is TCAM and not auto and longer than seen so far */
                offset = tempUnit->stageD[stage].modeBits[index]->length;
                tempUnit->stageD[stage].modeBits[bcmFieldGroupModeAuto] = tempUnit->stageD[stage].modeBits[index];
            }
        }
        if (0 == offset) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d stage %u includes no supported"
                                  " group modes\n"),
                       unit,
                       stage));
        }
    }
    /* make sure the stage maps point to end of table if not valid */
    for (stage = 0;
         (BCM_E_NONE == result) && (stage < devInfo->stages);
         stage++) {
        for (type = 0;
             type < (_BCM_DPP_FIELD_MAX_GROUP_TYPES + 1);
             type++) {
            tempUnit->stageD[stage].ltOffset[type] = devInfo->mappings;
        }
    }

    /* make sure the mapping table does not exceed expected parameters */
    for (index = 0;
         (BCM_E_NONE == result) && (index < devInfo->mappings);
         index++) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "scanning unit %d mapping table at %d\n"),
                   unit,
                   index));
        if (devInfo->stMapInfo[index].stmStage >= devInfo->stages) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d cell mapping contains entry"
                                  " referring to stage %d, but only %d"
                                  " valid stages\n"),
                       unit,
                       devInfo->stMapInfo[index].stmStage,
                       devInfo->stages));
        }
        if (0 == (devInfo->stMapInfo[index].stmFlags &
                  _BCM_DPP_FIELD_GROUP_PRESEL)) {
            /* only check this if not preselector definition */
            if (devInfo->types <= devInfo->stMapInfo[index].stmType) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d cell mapping contains entry"
                                      " referring to group type %d, but only"
                                      " %d are valid\n"),
                           unit,
                           devInfo->stMapInfo[index].stmType,
                           devInfo->types));
            }
        }
        if ((SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS < devInfo->stMapInfo[index].predefKey) ||
            (0 > devInfo->stMapInfo[index].predefKey)) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d cell mapping contains entry"
                                  " referring to predefined key %d, but"
                                  " only 0..%d valid\n"),
                       unit,
                       devInfo->stMapInfo[index].predefKey,
                       SOC_PPD_NOF_FP_PREDEFINED_ACL_KEYS));
        }
        if (0 == (devInfo->stMapInfo[index].stmFlags & _BCM_DPP_FIELD_GROUP_PRESEL)) {
            if (devInfo->mappings <=
                tempUnit->stageD[devInfo->stMapInfo[index].stmStage].ltOffset[devInfo->stMapInfo[index].stmType]) {
                tempUnit->stageD[devInfo->stMapInfo[index].stmStage].ltOffset[devInfo->stMapInfo[index].stmType] = index;
            } else {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d cell mapping contains entry %d"
                                      " referring to stage %d group type %d but"
                                      " entry %d is already used for that\n"),
                           unit,
                           index,
                           devInfo->stMapInfo[index].stmStage,
                           devInfo->stMapInfo[index].stmType,
                           tempUnit->stageD[devInfo->stMapInfo[index].stmStage].ltOffset[devInfo->stMapInfo[index].stmType]));
            }
        } else { /* if (mapping is not for preselectors) */
            if (devInfo->mappings <=
                tempUnit->stageD[devInfo->stMapInfo[index].stmStage].ltOffset[_BCM_DPP_FIELD_MAX_GROUP_TYPES]) {
                tempUnit->stageD[devInfo->stMapInfo[index].stmStage].ltOffset[_BCM_DPP_FIELD_MAX_GROUP_TYPES] = index;
            } else {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d cell mapping contains entry %d"
                                      " referring to stage %d preselector but"
                                      " entry %d is already used for that\n"),
                           unit,
                           index,
                           devInfo->stMapInfo[index].stmStage,
                           tempUnit->stageD[devInfo->stMapInfo[index].stmStage].ltOffset[_BCM_DPP_FIELD_MAX_GROUP_TYPES]));
            }
        } /* if (mapping is not for preselectors) */
    } /* for (index = 0; index < devInfo->mappings; index++) */

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        /* set bcmFieldQualifyL2Learn PPD qualifiers according to soc property */
        if((soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "l3_learn_force_in_fwd", 0)) || (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "IVL_inlif_profile", 0))) {
            for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
                if (devInfo->qualMap[index] == bcmFieldQualifyL2Learn) {
                    sal_memcpy(&devInfo->qualMap[index], 
                               &restricted_l2_learn_type_qual_info, 
                               sizeof(_bcm_arad_field_device_qual_info_layer_t));
                }
                index += sizeof(_bcm_arad_field_device_qual_info_layer_t)/sizeof(int32);  
            }
        }
        /* set forwardingType PPD qualifiers according to soc property */
        if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "fp_restricted_forwarding_type", 0)) {
            for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
                if (devInfo->qualMap[index] == bcmFieldQualifyForwardingType) {
                    sal_memcpy(&devInfo->qualMap[index], 
                               &restricted_forwarding_type_qual_info, 
                               sizeof(_bcm_arad_field_device_qual_info_layer_t));
                }
                index += sizeof(_bcm_arad_field_device_qual_info_layer_t)/sizeof(int32);  
            }
        }
        if ( soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, CF_IPV6_UC_WITH_RPF_2PASS_ENABLED, 0))
        {
            for (index = 0; devInfo->actMap[index] < bcmFieldActionCount; ) {
                if (devInfo->actMap[index] == bcmFieldActionForwardingTypeNew) {
                    sal_memcpy(&devInfo->actMap[index],
                               &restricted_action_type_act_info,
                               sizeof(_bcm_arad_field_device_action_info_layer_t));
                }
                index += sizeof(_bcm_arad_field_device_action_info_layer_t)/sizeof(int32);
            }
        }
    }

    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst1", 0)) {
        for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
            if (devInfo->qualMap[index] == bcmFieldQualifyClassId) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &classId_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            else if (devInfo->qualMap[index] == bcmFieldQualifyOuterVlanActionRange) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &OuterVlanActionRange_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            else if (devInfo->qualMap[index] == bcmFieldQualifyInnerVlanActionRange) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &InnerVlanActionRange_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_qual_info_layer_t)/sizeof(int32);  
        }
    }
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "vt_tst2", 0)) {
        for (index = 0; devInfo->qualMap[index] < bcmFieldQualifyCount; ) {
            if (devInfo->qualMap[index] == bcmFieldQualifyClassId) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &classId_as_vlan_domain_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }else if (devInfo->qualMap[index] == bcmFieldQualifyInnerVlanActionRange) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &InnerVlanActionRange_as_inner_vid_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }else if (devInfo->qualMap[index] == bcmFieldQualifyOuterVlanActionRange) {
                sal_memcpy(&devInfo->qualMap[index], 
                           &OuterVlanActionRange_as_outer_vid_qual_info, 
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }else if (devInfo->qualMap[index] == bcmFieldQualifyOuterVlanId) {
                sal_memcpy(&devInfo->qualMap[index],
                           &OuterVlanId_as_initial_vid_qual_info,
                           sizeof(_bcm_arad_field_device_qual_info_layer_t));
            }
            index += sizeof(_bcm_arad_field_device_qual_info_layer_t)/sizeof(int32);  
        }
    }

#endif /* def BCM_ARAD_SUPPORT */

    /* build the stage qualifier set bitmaps and reverse mapping */
    BCM_FIELD_QSET_INIT(rangeQual);
    for (index = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldQualifyCount > devInfo->qualMap[index]) &&
         (0 <= devInfo->qualMap[index]);
         /* increment is performed inline */) {
        /* consider this map layer */
        qual = devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_QUAL];
        tempUnit->qualMapCount++;
        /* ensure each qualifier is included only once */
        if (tempUnit->qualMaps[qual]) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set qualifier"
                                  " %d (%s) but it was already set\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual]));
        }
        /* keep track of this qualifier's description */
        tempUnit->qualMaps[qual] = &(devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_QUAL]);
        /* ensure this qualifier has a sensible number of significant bits */
        bcmQualSize = devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_LENGTH];
        if (bcmQualSize < -1) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set qualifier"
                                  " %d (%s) with an unexpected number of bits"
                                  " %d\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       bcmQualSize));
        }
        offset = devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_SHIFT];
        /* ensure this qualifier's shift distance is reasonable */
        if (offset > 255) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set qualifier"
                                  " %d (%s) with unexpectedly large right shift"
                                  " distance in excess of 255 bits (%d)\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       offset));
        }
        if (offset < -63) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set qualifier"
                                  " %d (%s) with a left shift distance in"
                                  " excess of 63 bits (%d); just skip initial"
                                  " chain members until shift distance is less"
                                  " than 64 bits\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       offset));
        }
        /* verify the qualifier's flags */
        flags = devInfo->qualMap[index + _BCM_DPP_FIELD_QUALMAP_OFFSET_FLAGS];
        if (TRUE == flags) /* this equality comparison is deliberate */ {
            /*
             *  Special case: since older versions of the tables used this
             *  element as a TRUE/FALSE value, we do not want to accidentally
             *  have an update use this element incorrectly.  While FALSE is
             *  okay (no flags set), TRUE should have been converted to a
             *  particular flag.
             *
             *  Note this is a deliberate and explicit equality comparison to
             *  TRUE, which is a specific value (almost universally it
             *  inovolves bit 0 being set, which is not a valid flag) rather
             *  than a 'not FALSE' type of comparison, which would usually
             *  trigger for any nonzero value.
             */
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps not current; flags"
                                  " value is using boolean TRUE value for"
                                  " qualifier %d (%s) where such should have"
                                  " been a specific flag\n"),
                       unit,
                       qual,
                       _bcm_dpp_field_qual_name[qual]));
        }
        if (flags & (~_BCM_DPP_QUAL_FLAGS_ALL_VALID_BITS)) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier maps try to set invalid"
                                  " flags %08X for qualifier %d (%s)\n"),
                       unit,
                       flags & (~_BCM_DPP_QUAL_FLAGS_ALL_VALID_BITS),
                       qual,
                       _bcm_dpp_field_qual_name[qual]));
        }
        if (flags & (_BCM_DPP_QUAL_RANGE_BITMAP | _BCM_DPP_QUAL_RANGE_INDEX)) {
            /* this is a range qualifier of some kind */
            BCM_FIELD_QSET_ADD(rangeQual, qual);
            if ((_BCM_DPP_QUAL_RANGE_BITMAP | _BCM_DPP_QUAL_RANGE_INDEX) ==
                (flags & (_BCM_DPP_QUAL_RANGE_BITMAP |
                          _BCM_DPP_QUAL_RANGE_INDEX))) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d qualifier %d (%s) claims to be"
                                      " both bitmap and index type range\n"),
                           unit,
                           qual,
                           _bcm_dpp_field_qual_name[qual]));
            }
        }
        /* display diagnostic indicating parsing progress */
        if (0 < bcmQualSize) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d scanning qualifier map table at"
                                  " %d, %d %s: %d bits, %d offset, flags"
                                  " %08X\n"),
                       unit,
                       index,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       bcmQualSize,
                       offset,
                       flags));
        } else if (0 == bcmQualSize) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d scanning qualifier map table at"
                                  " %d, %d %s: special/translated, flags"
                                  " %08X\n"),
                       unit,
                       index,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       flags));
        } else if (-1 == bcmQualSize) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d scanning qualifier map table at"
                                  " %d, %d %s: (variable) length from"
                                  " hardware, flags %08X\n"),
                       unit,
                       index,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       flags));
        } else {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d qualifier map table at %d, %d (%s)"
                                  " has invalid length setting %d\n"),
                       unit,
                       index,
                       qual,
                       _bcm_dpp_field_qual_name[qual],
                       bcmQualSize));
        }
        /* point to the PPD layer qualifier chains */
        index += _BCM_DPP_FIELD_QUALMAP_OFFSET_MAPS;
        /* ensure all of the maps for this qualifier look reasonable */
        for (offset = 0; offset < devInfo->mappings; offset++) {
            /* determine stage and type for each map */
            stage = devInfo->stMapInfo[offset].stmStage;
            if (devInfo->stMapInfo[offset].stmFlags & _BCM_DPP_FIELD_GROUP_PRESEL) {
                type = _BCM_DPP_FIELD_MAX_GROUP_TYPES;
            } else {
                type = devInfo->stMapInfo[offset].stmType;
            }
            /* make sure no doubled qualifiers except invalid */
            for (adjust = 0;
                 adjust < devInfo->qualChain;
                 adjust++) {
                for (found = adjust + 1;
                     found < devInfo->qualChain;
                     found++) {
                    if (_BCM_DPP_FIELD_PPD_QUAL_VALID(devInfo->qualMap[index + adjust]) &&
                        _BCM_DPP_FIELD_PPD_QUAL_VALID(devInfo->qualMap[index + found]) &&
                        (devInfo->qualMap[index + adjust] == devInfo->qualMap[index + found])) {
                        result = BCM_E_CONFIG;
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unit %d qualifier map table at"
                                              " %d, %s (%d): duplicated PPD"
                                              " layer qualifier %s (%d)\n"),
                                   unit,
                                   index + found,
                                   _bcm_dpp_field_qual_name[qual],
                                   qual,
                                   SOC_PPC_FP_QUAL_TYPE_to_string(devInfo->qualMap[index + found]),
                                   devInfo->qualMap[index + found]));
                    }
                }
            }
            /* check each possible map in the chain, build reverse map */
            for (adjust = 0, found = FALSE, ppdQualSize = 0;
                 adjust < devInfo->qualChain;
                 adjust++, index++) {
                /* ensure chain PPD qualifier is valid */
                if (((SOC_PPD_NOF_FP_QUAL_TYPES + 1) < devInfo->qualMap[index]) ||
                    (0 > devInfo->qualMap[index])) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d qualifier map for qual %d"
                                          " (%s) stage %u (%s) type %d (%s)"
                                          " chain %d tries to set invalid PPD"
                                          " qualifier %d (min 0, max %d)\n"),
                               unit,
                               qual,
                               _bcm_dpp_field_qual_name[qual],
                               stage,
                               devInfo->stage[stage].stageName,
                               type,
                               devInfo->typeNames[type],
                               adjust,
                               devInfo->qualMap[index],
                               SOC_PPD_NOF_FP_QUAL_TYPES + 1));
                }
                /* ensure chains are contiguously populated */
                if ((!found) && (0 != adjust) &&
                    (_BCM_DPP_FIELD_PPD_QUAL_VALID(devInfo->qualMap[index]))) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d qualifier map %d (%s) stage"
                                          " %u (%s) type %d (%s) has a gap"
                                          " before chain %d\n"),
                               unit,
                               qual,
                               _bcm_dpp_field_qual_name[qual],
                               stage,
                               devInfo->stage[stage].stageName,
                               type,
                               devInfo->typeNames[type],
                               adjust));
                }
                if ((BCM_E_NONE == result) &&
                    (SOC_PPD_NOF_FP_QUAL_TYPES != devInfo->qualMap[index]) &&
                    (SOC_PPD_FP_QUAL_IRPP_INVALID != devInfo->qualMap[index])) {
                    /* no error and not filler */
                    /* found a mapping or a flag for this qualifier */
                    found = TRUE;
                    /* add this qualifier to the unit's qset */
                    BCM_FIELD_QSET_ADD(tempUnit->unitQset, qual);
                    /* add this qualifier to the stage's qset */
                    BCM_FIELD_QSET_ADD(tempUnit->stageD[stage].stgQset, qual);
                    /* add this qualifier to type's qset in this stage */
                    BCM_FIELD_QSET_ADD(tempUnit->stageD[stage].qsetType[type],
                                       qual);
                    if (SOC_PPD_NOF_FP_QUAL_TYPES > devInfo->qualMap[index]) {
                        /* not a flag */
                        if (flags & _BCM_DPP_QUAL_REVERSE_LOOKUP) {
                            /* keep track for reverse mapping */
                            tempUnit->ppdQual[devInfo->qualMap[index]] = qual;
                            LOG_DEBUG(BSL_LS_BCM_FP,
                                      (BSL_META_U(unit,
                                                  "unit %d qualifier %s (%d)"
                                                  " is used for mapping"
                                                  " PPD qual %s (%d)\n"),
                                       unit,
                                       _bcm_dpp_field_qual_name[qual],
                                       qual,
                                       SOC_PPD_FP_QUAL_TYPE_to_string(devInfo->qualMap[index]),
                                       devInfo->qualMap[index]));
                        }

                        /* adjust PPD layer size */ 
                        result = _bcm_dpp_ppd_qual_bits(tempUnit,
                                                        tempUnit->devInfo->stMapInfo[offset].stmStage,
                                                        devInfo->qualMap[index],
                                                        &tempQualSize,
                                                        NULL,
                                                        NULL);
                        if (BCM_E_NONE == result) {
                            ppdQualSize += tempQualSize;
                        }
                    }
                } else {
                    found = FALSE;
                }
            } /* for (all chained qualifiers) */
            if (BCM_E_NONE == result) {
                if ((ppdQualSize) &&
                    (0 < bcmQualSize) &&
                    (bcmQualSize > ppdQualSize)) {
                    /*
                     *  PPD qualifier must at least cover the BCM qualifier.
                     *  There are some special cases where the qualifiers
                     *  require mapping or other extra treatment; the BCM size
                     *  is said to be zero for these and so they will not
                     *  trigger this.
                     */
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d qualifier map %d (%s) stage"
                                          " %u (%s) type %d (%s) PPD size %u"
                                          " does not match BCM size %u\n"),
                               unit,
                               qual,
                               _bcm_dpp_field_qual_name[qual],
                               stage,
                               devInfo->stage[stage].stageName,
                               type,
                               devInfo->typeNames[type],
                               ppdQualSize,
                               bcmQualSize));
                } else if (ppdQualSize) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d qualifier map %d (%s)"
                                          " stage %u (%s) type %d (%s) PPD"
                                          " size %u\n"),
                               unit,
                               qual,
                               _bcm_dpp_field_qual_name[qual],
                               stage,
                               devInfo->stage[stage].stageName,
                               type,
                               devInfo->typeNames[type],
                               ppdQualSize));
                }
            } /* if (BCM_E_NONE == result) */
        } /* for (offset = 0; offset < devInfo->mappings; offset++) */
    } /* for (all entries in elements table) */
    if ((0 > devInfo->qualMap[index]) ||
        (bcmFieldQualifyCount < devInfo->qualMap[index])) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d qualifier map at %d tries to define"
                              " invalid qualifier %d\n"),
                   unit,
                   index,
                   devInfo->qualMap[index]));
    }
    /* compute stage preselector PPD qualifier sets */
    for (index = 0;
         (BCM_E_NONE == result) &&
         (index < devInfo->stages);
         index++) {
        if (devInfo->stage[index].stageFlags &
            _BCM_DPP_FIELD_DEV_STAGE_USES_PRESELECTORS) {
            result = _bcm_dpp_field_quals_to_ppd(tempUnit,
                                                 index,
                                                 1 << _BCM_DPP_FIELD_MAX_GROUP_TYPES,
                                                 tempUnit->stageD[index].qsetType[_BCM_DPP_FIELD_MAX_GROUP_TYPES],
                                                 &(tempUnit->stageD[index].ppqset),
                                                 NULL,
                                                 NULL);
            if (BCM_E_NONE != result) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d unable to map stage %s (%d)"
                                      " preselector qualifier set to PPD:"
                                      " %d (%s)\n"),
                           unit,
                           devInfo->stage[index].stageName,
                           index,
                           result,
                           _SHR_ERRMSG(result)));
            }
        } /* if (this stage uses preselectors) */
    } /* for (all stages as long as no errors) */

    /* scan the range table */
    for (index = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldQualifyCount > devInfo->ranges[index].qualifier) &&
         (0 <= devInfo->ranges[index].qualifier);
         index++) {
        if (BCM_FIELD_QSET_TEST(rangeQual, devInfo->ranges[index].qualifier)) {
            if (0 == devInfo->ranges[index].rangeFlags) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " does not specify any range flags\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier));
            }
            if (devInfo->ranges[index].rangeFlags & BCM_FIELD_RANGE_INVERT) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " tries to use modifier flags %08X as"
                                      " part of its type flags\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier,
                           devInfo->ranges[index].rangeFlags & BCM_FIELD_RANGE_INVERT));
            }
            if (devInfo->ranges[index].rangeBase < 1) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " tries to start range IDs below 1\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier));
            }
            if (devInfo->ranges[index].count < 1) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " tries to specify fewer than 1 ranges"
                                      " of the type\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier));
            }
            if (devInfo->ranges[index].count > _BCM_DPP_RANGE_MAX_COUNT) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d range table at %d type %s (%d)"
                                      " specifies %d ranges, but the range"
                                      " module supports max %d of one type\n"),
                           unit,
                           index,
                           _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                           devInfo->ranges[index].qualifier,
                           devInfo->ranges[index].count,
                           _BCM_DPP_RANGE_MAX_COUNT));
            }
            for (offset = 0; offset < index; offset++) {
                if (((devInfo->ranges[index].rangeBase >=
                      devInfo->ranges[offset].rangeBase) &&
                     (devInfo->ranges[index].rangeBase <
                      (devInfo->ranges[offset].rangeBase +
                       devInfo->ranges[offset].count))) ||
                    (((devInfo->ranges[index].rangeBase +
                       devInfo->ranges[index].count) >
                      devInfo->ranges[offset].rangeBase) &&
                     ((devInfo->ranges[index].rangeBase +
                       devInfo->ranges[index].count) <=
                      (devInfo->ranges[offset].rangeBase +
                       devInfo->ranges[offset].count)))) {
                    /*
                     *  Basically, at least one of these conditions is true:
                     *
                     *    The base ID of this range is within the IDs that
                     *    are used by a range already configured
                     *
                     *    The last ID of this range is within the IDs that
                     *    are used by a range already configured
                     *
                     *  Either of these conditions is sufficient to know that
                     *  this range type's ID space overlaps some other range
                     *  type's ID space, and that's just not acceptable.
                     */
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d range table at %d type %s"
                                          " (%d) tries to define range type"
                                          " whose ID space overlaps existing"
                                          " range type %s %d at %d\n"),
                               unit,
                               index,
                               _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                               devInfo->ranges[index].qualifier,
                               _bcm_dpp_field_qual_name[devInfo->ranges[offset].qualifier],
                               devInfo->ranges[offset].qualifier,
                               offset));
                } /* if (range ID space overlaps) */
                if (devInfo->ranges[index].rangeFlags &
                    devInfo->ranges[offset].rangeFlags) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d range table at %d type %s"
                                          " (%d) range flags %08X overlap"
                                          " type %s (%d) at %d\n"),
                               unit,
                               index,
                               _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                               devInfo->ranges[index].qualifier,
                               devInfo->ranges[index].rangeFlags &
                               devInfo->ranges[offset].rangeFlags,
                               _bcm_dpp_field_qual_name[devInfo->ranges[offset].qualifier],
                               devInfo->ranges[offset].qualifier,
                               offset));
                }
            } /* for (offset = 0; offset < index; offset++) */
            BCM_FIELD_QSET_REMOVE(rangeQual, devInfo->ranges[index].qualifier);
        } else { /* if (SHR_BITGET(rangeQual, devInfo->ranges[index].qualifier)) */
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d range map at %d tries to define"
                                  " range type %s (%d) but it is either not a"
                                  " range type in the qualifier table or it"
                                  " has already been defined (earlier in the"
                                  " range table)\n"),
                       unit,
                       index,
                       _bcm_dpp_field_qual_name[devInfo->ranges[index].qualifier],
                       devInfo->ranges[index].qualifier));
        } /* if (SHR_BITGET(rangeQual, devInfo->ranges[index].qualifier)) */
    } /* for (range info table) */
    if ((0 > devInfo->ranges[index].qualifier) ||
        (bcmFieldQualifyCount < devInfo->ranges[index].qualifier)) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d range table at %d tries to define"
                              " invalid range qualifier %d\n"),
                   unit,
                   index,
                   devInfo->qualMap[index]));
    }
    for (qual = 0; bcmFieldQualifyCount > qual; qual++) {
        if (BCM_FIELD_QSET_TEST(rangeQual, qual)) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d range table does not include %s"
                                  " (%d), which was indicated to be a range"
                                  " in the qualifier table\n"),
                       unit,
                       _bcm_dpp_field_qual_name[qual],
                       qual));
        } /* if (BCM_FIELD_QSET_TEST(rangeQual, qual) */
    } /* for (qual = 0; bcmFieldQualifyCount > qual; qual++) */

    /* build the stage action bitmaps */
    for (index = 0;
         (BCM_E_NONE == result) &&
         (bcmFieldActionCount > devInfo->actMap[index]);
         /* increment is performed inline */) {
        /* consider this map layer */
        action = devInfo->actMap[index];
        tempUnit->actMapCount++;
        /* ensure each action is included only once */
        if (tempUnit->actMaps[action]) {
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d action maps try to set actionr"
                                  " %d (%s) but it was already set\n"),
                       unit,
                       action,
                       _bcm_dpp_field_action_name[action]));
        }
        /* keep track of this action's description */
        tempUnit->actMaps[action] = &(devInfo->actMap[index]);
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d scanning action map table at %d,"
                              " %d %s\n"),
                   unit,
                   index,
                   action,
                   _bcm_dpp_field_action_name[action]));
        index++;
        /* ensure all of the maps for this action look reasonable */
        for (stage = 0; stage < devInfo->stages; stage++) {
            /* check each possible map in the chain, build reverse map */
            for (adjust = 0, found = FALSE;
                 adjust < devInfo->actChain;
                 adjust++, index++) {
                /* ensure chain PPD action is valid */
                if ((SOC_PPD_NOF_FP_ACTION_TYPES < devInfo->actMap[index]) ||
                    (0 > devInfo->actMap[index])) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d action map for action %d"
                                          " (%s) stage %u (%s)"
                                          " chain %d tries to set invalid PPD"
                                          " action %d (min 0, max %d)\n"),
                               unit,
                               action,
                               _bcm_dpp_field_action_name[action],
                               stage,
                               devInfo->stage[stage].stageName,
                               adjust,
                               devInfo->actMap[index],
                               SOC_PPD_NOF_FP_QUAL_TYPES + 1));
                }
                /* ensure chains are contiguously populated */
                if ((!found) &&
                    (0 != adjust) &&
                    (_BCM_DPP_FIELD_PPD_ACTION_VALID(devInfo->actMap[index]))) {
                    result = BCM_E_CONFIG;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d action map %d (%s) stage"
                                          " %u (%s) has a gap"
                                          " before chain %d\n"),
                               unit,
                               action,
                               _bcm_dpp_field_action_name[action],
                               stage,
                               devInfo->stage[stage].stageName,
                               adjust));
                }
                if ((BCM_E_NONE == result) &&
                    (_BCM_DPP_FIELD_PPD_ACTION_VALID(devInfo->actMap[index]))) {
                    found = TRUE;
                    /* add this action to the unit's capabilities */
                    BCM_FIELD_ASET_ADD(tempUnit->unitAset,  action);
                    /* add this action to the stage's aset */
                    BCM_FIELD_ASET_ADD(tempUnit->stageD[stage].stgAset, action);
                    /* add this action to the type's aset in this stage */
                } else {
                    found = FALSE;
                }
            } /* for (all chained actions) */
        } /* for (offset = 0; offset < devInfo->mappings; offset++) */
    } /* for (all entries in elements table) */
    if (bcmFieldActionCount < devInfo->actMap[index]) {
        result = BCM_E_CONFIG;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d action map at %d tries to define"
                              " invalid action %d\n"),
                   unit,
                   index,
                   devInfo->actMap[index]));
    }
    /* init ranges (ranges only apply to ingress FP stage) */
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_range_init(tempUnit);
    }
    /* init preselectors */
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_presel_init(tempUnit);
    }

    
    /* init data qualifiers */
    if (BCM_E_NONE == result) {
        result = _bcm_petra_field_data_qualifier_init(tempUnit);
    }

    if(!SOC_WARM_BOOT(unit)) {
        for (index = 0;
             (index < 2) && (BCM_E_NONE == result);
             index++) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "set up egress DP indirection %d\n"), index));
            SOC_PPD_FP_CONTROL_INDEX_clear(&control_ndx);
            SOC_PPD_FP_CONTROL_INFO_clear(&control_info);
            control_ndx.type = SOC_PPD_FP_CONTROL_TYPE_EGRESS_DP;
            control_ndx.val_ndx = index;
            switch (index) {
            case 0: /* green */
                control_info.val[0] = 0;
                break;
            case 1: /* yellow */
                control_info.val[0] = 1;
                break;
            default:
                /* should never see this */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unexpected DP index %d setting egress DP\n"),
                           index));
                result = BCM_E_INTERNAL;
            }
            if (BCM_E_NONE == result) {
                ppdr = soc_ppd_fp_control_set(tempUnit->unitHandle,
                                              SOC_CORE_INVALID,
                                              &control_ndx,
                                              &control_info,
                                              &success);
                result = handle_sand_result(ppdr);
                if (BCM_E_NONE == result) {
                    result = translate_sand_success_failure(success);
                }
            } /* if (BCM_E_NONE == result) */
        } /* for each of the egress DP settings */
    }/* if !SOC_WARM_BOOT(unit) */
#ifdef BCM_WARM_BOOT_SUPPORT
    if (BCM_E_NONE == result) {
        /*
         *  This function will either set up warm boot support (when in cold
         *  boot mode) or it will load the warm boot data and then scan
         *  hardware to fill in the gaps (when in warm boot mode).
         */
        result = _bcm_dpp_wb_field_state_init(tempUnit);
    }
#endif /* def BCM_WARM_BOOT_SUPPORT */

    if (BCM_E_NONE == result) {
        /* all went well, expose the unit */
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d ready\n"), unit));
        _bcm_dpp_field_unit_info[unit] = tempUnit;
    } else { /* if (BCM_E_NONE == result) */
        /* something went wrong, dispose of resources */
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d init failed: %d (%s)\n"),
                   unit,
                   result,
                   _SHR_ERRMSG(result)));
        if (tempUnit) {
            if (tempUnit->hwResIds) {
                auxRes = shr_mres_destroy(tempUnit->hwResIds);
                BCMDNX_IF_ERR_EXIT(auxRes);
            }
            if (tempUnit->unitLock) {
                sal_mutex_destroy(tempUnit->unitLock);
            }
            BCM_FREE(tempUnit);
            tempUnit = NULL;
        }
    } /* if (BCM_E_NONE == result) */

    _bcm_dpp_field_group_vt_predefined_group_init(unit);

    _bcm_dpp_field_group_flp_predefined_group_init(unit);


    /* Release the global lock */
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "release global lock\n")));
    if (sal_mutex_give(_bcm_dpp_field_glob_lock)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unable to release global lock")));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);

exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_detach
 *   Purpose
 *      Shut down the field APIs.
 *   Parameters
 *      (in) int unit = the unit number
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_detach(int unit)
{
    int result;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d)\n"), unit));

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* check the global lock */
    if (!_bcm_dpp_field_glob_lock) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INIT,
                         (_BSL_BCM_MSG("no Soc_petra field units initialized")));
    }
    if (sal_mutex_take(_bcm_dpp_field_glob_lock, sal_mutex_FOREVER)) {
        /* unable to take the global lock */
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unable to take Soc_petra field global lock")));
    }
    if (!(_bcm_dpp_field_unit_info[unit])) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INIT,
                         (_BSL_BCM_MSG("not initialised")));
    }

    /* detach unit */
    result = _bcm_dpp_field_detach(unit);

    if (sal_mutex_give(_bcm_dpp_field_glob_lock)) {
        /* unable to release the global lock */
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("unable to release Soc_petra field"
                                   " global lock")));
    }

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d) = %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

#ifdef BROADCOM_DEBUG
/*
 *   Function
 *      bcm_petra_field_show
 *   Purpose
 *      Dump all field information for the unit
 *   Parameters
 *      (in) int unit = the unit number
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_show(int unit,
                     const char *pfx)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) enter\n"), unit));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_unit_dump(unitData,
                                      pfx?pfx:"",
                                      TRUE,
                                      TRUE,
                                      TRUE);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}
#endif /* def BROADCOM_DEBUG */

#ifdef BROADCOM_DEBUG
/*
 *   Function
 *      bcm_petra_field_entry_dump
 *   Purpose
 *      Dump information about the specified entry to debug output
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_entry_dump(int unit,
                           bcm_field_entry_t entry)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        result = _bcm_dpp_field_tcam_entry_dump(unitData,
                                                _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                "");
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        result = _bcm_dpp_field_dir_ext_entry_dump(unitData,
                                                   entry -
                                                   _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt),
                                                   "");
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),  unit,  entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}
#endif /* def BROADCOM_DEBUG */

#ifdef BROADCOM_DEBUG
/*
 *   Function
 *      bcm_petra_field_group_dump
 *   Purpose
 *      Dump information about the specified group to debug output
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_dump(int unit,
                           bcm_field_group_t group)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_dump(unitData, group, "", TRUE);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}
#endif /* def BROADCOM_DEBUG */

/*
 * Function:
 *      bcm_petra_field_group_traverse
 * Purpose:
 *      Traverse all the fp groups in the system, calling a specified
 *      callback for each one
 * Parameters:
 *      unit - (IN) Unit number.
 *      callback - (IN) A pointer to the callback function to call for each fp group
 *      user_data - (IN) Pointer to user data to supply in the callback
 * Returns:
 *      BCM_E_xxx
 * Notes:
 *      There probably should be an entry traverse...?
 */
int
bcm_petra_field_group_traverse(int unit,
                               bcm_field_group_traverse_cb callback,
                               void *user_data)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_stage_idx_t stage;
    _bcm_dpp_field_grp_idx_t group;
    _bcm_dpp_field_grp_idx_t next;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,*) enter\n"), unit));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!callback) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory pointer argument is NULL")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    for (stage = 0; stage < unitData->devInfo->stages; stage++) {
        next = unitData->stageD[stage].groupHead;
        while ((BCM_E_NONE == result) &&
               (next < unitData->groupLimit)) {
            group = next;
            next = unitData->groupD[group].groupNext;
            result = (*callback)(unit, group, user_data);
            if (BCM_E_NONE != result) {
                LOG_WARN(BSL_LS_BCM_FP,
                         (BSL_META_U(unit,
                                     "exiting unit %d group traverse because"
                                     " callback function returned %d (%s)\n"),
                          unit,
                          result,
                          _SHR_ERRMSG(result)));
            }
        } /* while (no error and not to end of stage group list) */
    } /* for (stage = 0; stage < unitData->devInfo->stages; stage++) */

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_create
 *   Purpose
 *      Create a new group that has the specified qualifier set and priority.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (out) _field_group_index *group = where to put the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_create(int unit,
                             bcm_field_qset_t qset,
                             int pri,
                             bcm_field_group_t *group)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_grp_idx_t next;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,*) enter\n"), unit, pri));
    _BCM_DPP_SWITCH_API_START(unit);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!group) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    /* just grab the next free one */
    next = unitData->groupFree;
    if (next < unitData->groupLimit) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d next free group is %d\n"),
                   unit,
                   next));
        result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                     next,
                                                     qset,
                                                     pri,
                                                     0, /* group_config_flags */
                                                     bcmFieldGroupModeAuto,
                                                     0);
        if (BCM_E_NONE == result) {
            *group = next;
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "no available groups on unit %d\n"), unit));
        result = BCM_E_FULL;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,&(%d)) return %d (%s)\n"),
               unit,
               pri,
               *group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_create_id
 *   Purpose
 *      Create a new group with the specified ID that has the specified
 *      qualifier set and priority.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_create_id(int unit,
                                bcm_field_qset_t qset,
                                int pri,
                                bcm_field_group_t group)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%d) enter\n"), unit, pri, group));
    _BCM_DPP_SWITCH_API_START(unit);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                 group,
                                                 qset,
                                                 pri,
                                                 0, /* group_config_flags */
                                                 bcmFieldGroupModeAuto,
                                                 0);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%d) return %d (%s)\n"),
               unit,
               pri,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_create_mode
 *   Purpose
 *      Create a new group spanning the specified width, that has the specified
 *      qualifier set and priority.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_mode_t mode = the mode (width) of the group
 *      (out) bcm_field_group_t *group = where to put the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_create_mode(int unit,
                                  bcm_field_qset_t qset,
                                  int pri,
                                  bcm_field_group_mode_t mode,
                                  bcm_field_group_t *group)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_grp_idx_t next;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%s,*) enter\n"),
               unit,
               pri,
               ((0 <= mode) && (bcmFieldGroupModeCount > mode))?_bcm_dpp_field_group_mode_name[mode]:"unknown"));
    _BCM_DPP_SWITCH_API_START(unit);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!group) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    /* just grab the next free one */
    next = unitData->groupFree;
    if (next < unitData->groupLimit) {
        LOG_DEBUG(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d next free group is %d\n"),
                   unit,
                   next));
        result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                     next,
                                                     qset,
                                                     pri,
                                                     0, /* group_config_flags */
                                                     mode,
                                                     0);
        if (BCM_E_NONE == result) {
            *group = next;
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "no available groups on unit %d\n"), unit));
        result = BCM_E_FULL;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%s,&(%d)) return %d (%s)\n"),
               unit,
               pri,
               ((0 <= mode) && (bcmFieldGroupModeCount > mode))?_bcm_dpp_field_group_mode_name[mode]:"unknown",
               *group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_create_mode_id
 *   Purpose
 *      Create a new group using the specified ID, spanning the specified
 *      width, that has the specified qualifier set and priority.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_mode_t mode = the mode (width) of the group
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_create_mode_id(int unit,
                                     bcm_field_qset_t qset,
                                     int pri,
                                     bcm_field_group_mode_t mode,
                                     bcm_field_group_t group)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%s,%d) enter\n"),
               unit,
               pri,
               ((0 <= mode) && (bcmFieldGroupModeCount > mode))?_bcm_dpp_field_group_mode_name[mode]:"unknown",
               group));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                 group,
                                                 qset,
                                                 pri,
                                                 0, /* group_config_flags */
                                                 mode,
                                                 0);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,%d,%s,%d) return %d (%s)\n"),
               unit,
               pri,
               ((0 <= mode) && (bcmFieldGroupModeCount > mode))?_bcm_dpp_field_group_mode_name[mode]:"unknown",
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_config_create
 *   Purpose
 *      Create a new group using a configuration structure to specify the
 *      parameters for the group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in/out) bcm_field_group_config_t = pointer to group config info
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 */
int
bcm_petra_field_group_config_create(int unit,
                                    bcm_field_group_config_t *group_config)
{
    _DPP_FIELD_COMMON_LOCALS;
    bcm_field_group_t group;
    bcm_field_group_mode_t mode;
    _bcm_dpp_field_group_t *groupInfo;
    _bcm_dpp_field_stage_t *stageInfo;
    int destroy = FALSE;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) enter\n"),
               unit));
    _BCM_DPP_SWITCH_API_START(unit);
    if (!group_config) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory IN/OUT argument must not"
                                   " be NULL")));
    }
    if (group_config->flags & (~(BCM_FIELD_GROUP_CREATE_WITH_ID |
                                 BCM_FIELD_GROUP_CREATE_WITH_MODE |
                                 BCM_FIELD_GROUP_CREATE_WITH_PRESELSET |
                                 BCM_FIELD_GROUP_CREATE_WITH_ASET |
                                 BCM_FIELD_GROUP_CREATE_SMALL |
                                 BCM_FIELD_GROUP_CREATE_LARGE |
                                 BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE |
                                 BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES | 
                                 BCM_FIELD_GROUP_CREATE_IS_EQUAL | 
                                 BCM_FIELD_GROUP_CREATE_SINGLE | 
                                 BCM_FIELD_GROUP_CREATE_HANDLE_ENTRIES_BY_KEY))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("unsupported flags %08X specified\n"),
                          group_config->flags &
                          (~(BCM_FIELD_GROUP_CREATE_WITH_ID |
                             BCM_FIELD_GROUP_CREATE_WITH_MODE |
                             BCM_FIELD_GROUP_CREATE_WITH_PRESELSET |
                             BCM_FIELD_GROUP_CREATE_WITH_ASET |
                             BCM_FIELD_GROUP_CREATE_SMALL |
                             BCM_FIELD_GROUP_CREATE_LARGE |
                             BCM_FIELD_GROUP_CREATE_INSERTION_ORDER_LOOSE |
                             BCM_FIELD_GROUP_CREATE_SPARSE_ENTRY_PRIORITIES | 
                             BCM_FIELD_GROUP_CREATE_IS_EQUAL | 
                             BCM_FIELD_GROUP_CREATE_SINGLE | 
                             BCM_FIELD_GROUP_CREATE_HANDLE_ENTRIES_BY_KEY))));
    }
    if (!SOC_IS_ARADPLUS(unit) && 
        (group_config->flags & BCM_FIELD_GROUP_CREATE_IS_EQUAL)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,
                         (_BSL_BCM_MSG("unsupported flags %08X specified\n"),
                          group_config->flags & BCM_FIELD_GROUP_CREATE_IS_EQUAL));
    }


    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);


    
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_ID) {
        group = group_config->group;
        if ((0 > group) || (unitData->groupLimit <= group)) {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d group %d is not valid\n"),
                       unit,
                       group));
        }
    } else { 
        group = unitData->groupFree;
        if (group < unitData->groupLimit) {
            LOG_DEBUG(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d next free group is %d\n"),
                       unit,
                       group));
        } else {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "no available groups on unit %d\n"), unit));
            result = BCM_E_FULL;
        }
    }
    if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_MODE) {
        /* this value will be checked by the group create function */
        mode = group_config->mode;
    } else {
        /* let the group create function decide (use auto mode) */
        mode = bcmFieldGroupModeAuto;
    }
    
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_group_create_mode_id(unitData,
                                                     group,
                                                     group_config->qset,
                                                     group_config->priority,
                                                     group_config->flags,
                                                     mode,
                                                     group_config->max_entry_priorities);
        if (BCM_E_NONE == result) {
            destroy = TRUE;
        }
    }
    if ((BCM_E_NONE == result) &&
        (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_PRESELSET)) {
        result = _bcm_dpp_field_group_presel_set(unitData,
                                                 group,
                                                 &(group_config->preselset));
    }
    if (BCM_E_NONE == result){
        groupInfo = &(unitData->groupD[group]);

        if (group_config->flags & BCM_FIELD_GROUP_CREATE_LARGE) {
            groupInfo->groupFlags |= _BCM_DPP_FIELD_GROUP_LARGE;
        }

        if (group_config->flags & BCM_FIELD_GROUP_CREATE_WITH_ASET) {
            result = _bcm_dpp_field_group_action_set(unitData,
                                                     group,
                                                     group_config->aset);
        }
        else if (groupInfo->groupFlags & _BCM_DPP_FIELD_GROUP_WITH_PRESEL) {
            /* use the Egress stage ASET */
            stageInfo = &(unitData->stageD[_BCM_DPP_FIELD_STAGE_INDEX_EGRESS]);
            result = _bcm_dpp_field_group_action_set(unitData,
                                                     group,
                                                     stageInfo->stgAset);
        }
    }
    if (BCM_E_NONE == result) {
        group_config->group = group;
    } else if (destroy) {
        /* something created but an error occurred afterward */
        destroy = _bcm_dpp_field_group_destroy(unitData, group);
        if (BCM_E_NONE != destroy) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unable to remove group %d after"
                                  " error %d (%s), group is partially"
                                  "constructed: %d (%s)\n"),
                       unit,
                       group,
                       result,
                       _SHR_ERRMSG(result),
                       destroy,
                       _SHR_ERRMSG(destroy)));
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_action_set
 *   Purpose
 *      Associate a set of actions with a group, to establish which actions can
 *      be used by entries in that group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) bcm_field_aset_t aset = action set to associate with group
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      It is only after this is done that we can create a group in PPD.
 *
 *      Since the group would have to be destroyed and recreated if this
 *      changes, we only support changing it on empty groups (no entries).
 *
 *      If the group is in hardware, this will destroy and recreate the group.
 *      If the group is not in hardware, this will try to create the group.
 */
int
bcm_petra_field_group_action_set(int unit,
                                 bcm_field_group_t group,
                                 bcm_field_aset_t aset)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, group));

    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_action_set(unitData, group, aset);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_action_get
 *   Purpose
 *      Get the set of actions associated with a group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (out) bcm_field_aset_t *aset = where to put the group's aset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_action_get(int unit,
                                 bcm_field_group_t group,
                                 bcm_field_aset_t *aset)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_group_t *groupData;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    groupData = &(unitData->groupD[group]);
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        sal_memcpy(aset, &(groupData->aset), sizeof(*aset));
        result = BCM_E_NONE;
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_install
 *   Purpose
 *      Insert all of a group's entries from the hardware.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This inserts and updates all of the groups entries to the hardware as
 *      appropriate.  No error is asserted for entries already in hardware,
 *      even if the entire group is already in hardware.
 */
int
bcm_petra_field_group_install(int unit,
                              bcm_field_group_t group)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, group));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_all_hw_set(unitData, group, TRUE);
    if (BCM_E_NONE == result) {
        /* the group no longer has changed entries (all committed now) */
        unitData->groupD[group].groupFlags &= (~_BCM_DPP_FIELD_GROUP_CHG_ENT);
#ifdef BCM_WARM_BOOT_SUPPORT
        _bcm_dpp_field_group_wb_save(unitData, group, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_remove
 *   Purpose
 *      Remove all of a group's entries from the hardware, but do not remove
 *      the entries from the software table.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This removes the group's entries from the hardware, marking them so,
 *      and commits the changes to the hardware.
 */
int
bcm_petra_field_group_remove(int unit,
                             bcm_field_group_t group)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, group));

    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_all_hw_set(unitData, group, FALSE);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_flush
 *   Purpose
 *      Remove all of a group's entries from the hardware, remove the group
 *      from the hardware, remove the group's entries from the software, and
 *      remove the group from the software.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This will destroy the field group and all its entries.  No mention is
 *      made that it affects ranges, so they aren't destroyed.  This also
 *      destroys the field group and its entries in hardware.
 */
int
bcm_petra_field_group_flush(int unit,
                            bcm_field_group_t group)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_field_group_destroy(unitData, group);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_set
 *   Purpose
 *      This changes the group's qualifier set so it is the specified set.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) bcm_field_qset_t qset = new qset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      For Dune device, if there are any entries, this will result in an
 *      error.  It can only be called as long as there are no entries.
 *
 *      If the group has been set up in hardware, this will destroy the group,
 *      and then create a new instance of it.  Since there are no entries, this
 *      does not result in any effect for traffic flow.  If the group is not
 *      yet in hardware this merely edits the group.
 */
int
bcm_petra_field_group_set(int unit,
                          bcm_field_group_t group,
                          bcm_field_qset_t qset)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_group_t newGroupData;
    _bcm_dpp_field_group_t *groupData;
    unsigned int index;
    unsigned int apiWidth;
    unsigned int hwWidth;
    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));

    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    groupData = &(unitData->groupD[group]);

    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d unavailable for groups that hanles entries by key "),unit,group));
    }
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        /* build a new group descriptor */
        sal_memcpy(&newGroupData, groupData, sizeof(newGroupData));
        result = _bcm_dpp_field_group_verify_qset(unitData,
                                                  group,
                                                  qset,
                                                  (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_AUTO_SZ)?bcmFieldGroupModeAuto:groupData->grpMode,
                                                  &(newGroupData.qset),
                                                  &(newGroupData.groupFlags),
                                                  &(newGroupData.stage),
                                                  &(newGroupData.groupTypes),
                                                  &(newGroupData.predefKey),
                                                  &apiWidth,
                                                  &hwWidth,
                                                  &(newGroupData.pqset));
        if (newGroupData.groupFlags & (~_BCM_DPP_FIELD_GROUP_TINFO)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d unexpected flags %08X set while"
                                  " verifying new group %d configuration\n"),
                       unit,
                       newGroupData.groupFlags & (~_BCM_DPP_FIELD_GROUP_TINFO),
                       group));
            result = BCM_E_INTERNAL;
        }
        if ((BCM_E_NONE == result) &&
            (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW)) {
            /*
             *  A change in stage or type may have occurred, since these can
             *  change according to the group's QSET.  We need to make sure the
             *  group's ASET is still valid and can be used with the updated
             *  stage and type.  Note we use the *original* ASET, not the
             *  computed one, since the computed one may contain actions
             *  implied by the actions in the original stage/type, and we do
             *  not want action creep to expand the ASET unexpectedly.
             */
            result = _bcm_dpp_field_group_verify_aset(unitData,
                                                      newGroupData.stage,
                                                      newGroupData.oaset,
                                                      &(newGroupData.aset),
                                                      &(newGroupData.paset));
        } /* if (no error and group is in hardware) */
        if (BCM_E_NONE == result) {
            /* get new mode if applicable */
            _bcm_dpp_field_group_mode_from_size(unitData,
                                                groupData->groupFlags,
                                                groupData->stage,
                                                hwWidth,
                                                &(newGroupData.grpMode));
            if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_HW) {
                /* it was in hardware, so update hardware */
                result = _bcm_dpp_field_group_hardware_install(unitData,
                                                               group,
                                                               &newGroupData);
            }
        }
        if (BCM_E_NONE == result) {
            /* update refcounts for programmable fields */
            for (index = 0; index < unitData->dqLimit; index++) {
                if (SHR_BITGET(newGroupData.qset.udf_map, index)) {
                    unitData->dataFieldRefs[index]++;
                }
                if (SHR_BITGET(groupData->qset.udf_map, index)) {
                    unitData->dataFieldRefs[index]--;
                }
            }
            /* update the group information */
            sal_memcpy(groupData, &(newGroupData), sizeof(*groupData));
#ifdef BCM_WARM_BOOT_SUPPORT
            _bcm_dpp_field_datafield_all_wb_save(unitData, NULL, NULL);
            _bcm_dpp_field_group_wb_save(unitData, group, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_get
 *   Purpose
 *      Gets the group's qualifier set.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (out) bcm_field_qset_t *qset = where to put the current qset
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_get(int unit,
                          bcm_field_group_t group,
                          bcm_field_qset_t *qset)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!qset) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("oblgatory out argument is NULL")));
    }
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (unitData->groupD[group].groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        sal_memcpy(qset,
                   &(unitData->groupD[group].qset),
                   sizeof(*qset));
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_destroy
 *   Purpose
 *      Destroys a group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      There must be no entries in this group when calling this function.
 */
int
bcm_petra_field_group_destroy(int unit,
                              bcm_field_group_t group)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if ((unitData->groupD[group].groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) &&
        (unitData->groupD[group].entryCount)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d has %d entries but must be"
                              " empty before it can be destroyed\n"),
                   unit,
                   group,
                   unitData->groupD[group].entryCount));
        result = BCM_E_CONFIG;
    } else {
        result = _bcm_dpp_field_group_destroy(unitData, group);
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_status_get
 *   Purpose
 *      Gets the group's status.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (out) bcm_field_group_status_t *status = where to put the status
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_status_get(int unit,
                                 bcm_field_group_t group,
                                 bcm_field_group_status_t *status)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t entry;
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_stage_t *stageData;
    _bcm_dpp_field_entry_type_t entryType;    

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!status) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("oblgatory out argument is NULL")));
    }
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (unitData->groupD[group].groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        groupData = &(unitData->groupD[group]);
        stageData = &(unitData->stageD[groupData->stage]);
        entryType = unitData->stageD[groupData->stage].modeBits[groupData->grpMode]->entryType;
        sal_memset(status, 0x00, sizeof(*status));
        status->prio_max = BCM_FIELD_ENTRY_PRIO_LOWEST;
        status->prio_min = BCM_FIELD_ENTRY_PRIO_HIGHEST;
        status->entry_count = unitData->groupD[group].entryCount;
        switch (entryType) {
        case _bcmDppFieldEntryTypeDirExt:
            /* capacity lookups always from first sharing member */
            status->entries_total = unitData->stageD[stageData->entryDeSh1].hwEntryDeLimit /
                                    stageData->modeBits[groupData->grpMode]->entryCount;
            status->entries_free = (unitData->stageD[stageData->entryDeSh1].hwEntryDeLimit -
                                    unitData->stageD[stageData->entryDeSh1].entryDeElems) /
                                   stageData->modeBits[groupData->grpMode]->entryCount;
            for (entry = unitData->groupD[group].entryHead;
                 entry < unitData->entryDeLimit;
                 entry = unitData->entryDe[entry].entryCmn.entryNext) {
                if (unitData->entryDe[entry].entryCmn.entryPriority > status->prio_max) {
                    status->prio_max = unitData->entryDe[entry].entryCmn.entryPriority;
                }
                if (unitData->entryDe[entry].entryCmn.entryPriority < status->prio_min) {
                    status->prio_min = unitData->entryDe[entry].entryCmn.entryPriority;
                }
            }
            break;
        default:
            /* default is TCAM */
            status->entries_total = unitData->stageD[stageData->entryTcSh1].hwEntryLimit /
                                    stageData->modeBits[groupData->grpMode]->entryCount;
            status->entries_free = (unitData->stageD[stageData->entryTcSh1].hwEntryLimit -
                                    unitData->stageD[stageData->entryTcSh1].entryElems) /
                                   stageData->modeBits[groupData->grpMode]->entryCount;
            for (entry = unitData->groupD[group].entryHead;
                 entry < _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType);
                 entry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry)) {
                if (_BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry) > status->prio_max) {
                    status->prio_max = _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
                }
                if (_BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry) < status->prio_min) {
                    status->prio_min = _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry);
                }
            }
        }
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_create
 *   Purpose
 *      Create an empty field entry based upon the specified grup
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group ID to use
 *      (out) bcm_field_entry_t *entry = where to put the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      'The field entry identifier is the priority of the entry in the group.'
 *      Yeah, right.  Where's that deed to the oceanfront property within easy
 *      walking distance of Des Moines?
 *
 *      Actually, the field entry identifier has nothing whatsoever to do with
 *      the priority, which is set separately.  Annoyingly, this function can
 *      only insert the entry into the group based upon a priority setting of
 *      BCM_FIELD_ENTRY_PRIO_DEFAULT, and it will be moved later if the user
 *      actually bothers to set the priority.
 */
int
bcm_petra_field_entry_create(int unit,
                             bcm_field_group_t group,
                             bcm_field_entry_t *entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_ent_idx_t next;
    _bcm_dpp_field_entry_type_t entryType;
    uint8 found;   
    uint32 soc_sand_rv; 
    uint32 entryUninstalledTcLimit;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,*) enter\n"), unit, group));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    if (!entry) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    /* just grab the next free one */
    groupData = &(unitData->groupD[group]);
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        if (groupData->handle_by_key_entry_id != _BCM_DPP_FIELD_GROUP_ENTRY_BY_KEY_EMPTY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("only one entry can be created for group that handled by key")));
        }
    }
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        entryType = unitData->stageD[groupData->stage].modeBits[groupData->grpMode]->entryType;
        switch (entryType) {
        case _bcmDppFieldEntryTypeDirExt:
            result = _bcm_dpp_field_dir_ext_entry_alloc(unitData,
                                                        group,
                                                        FALSE,
                                                        &next);
            if (BCM_E_NONE == result) {
                _bcm_dpp_field_dir_ext_entry_clear(unitData, next);
                result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                                   group,
                                                                   next);
            }
            if (BCM_E_NONE == result) {
                *entry = next + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
            }
            break;
        default:
            /* default is TCAM */
            next = _BCM_DPP_FIELD_TCAM_ENTRY_TC_FREE(entryType);
            {
                entryUninstalledTcLimit = (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) ?
                                            _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit) : SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
                if (unitData->entryUninstalledTcCount < entryUninstalledTcLimit) {
                    if (next < _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType)) {
                        LOG_DEBUG(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unit %d next free entry is %d\n"),
                                   unit,
                                   next));
                        if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                            if (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) {
                                /* External TCAM entry. Allocate an entry in the external TCAM info table. */
                                soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, unitData->extTcamBmp, &(unitData->entryExtTc[next].ext_info_idx), &found);
                                result = handle_sand_result(soc_sand_rv);
                                if (BCM_E_NONE == result) {
                                    if (!found) {
                                        LOG_ERROR(BSL_LS_BCM_FP,
                                                  (BSL_META_U(unit,
                                                              "unit %d reached max external TCAM entries before HW install\n"), unit));
                                        result = BCM_E_FULL;
                                    }
                                }
                            }
                        }
                        _bcm_dpp_field_tcam_entry_clear(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next);   
                        if(BCM_E_NONE == result){
                            result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                                                            group,
                                                                            next);
                        }
                    } else {
                        LOG_ERROR(BSL_LS_BCM_FP,
                                  (BSL_META_U(unit,
                                              "unit %d has no free entries\n"), unit));
                        result = BCM_E_FULL;
                    }
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has exceeded number of uninstalled TCAM entries\n"), unit));
                    result = BCM_E_FULL;
                }
                if (BCM_E_NONE == result) {
                    *entry = _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, next, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType));
                }
            }
        } /* switch (group entry type) */
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        groupData->handle_by_key_entry_id = (*entry);
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,&(%d)) return %d (%s)\n"),
               unit,
               group,
               *entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_create_id
 *   Purpose
 *      Create an empty field entry based upon the specified grup
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group ID to use
 *      (in) bcm_field_entry_t entry = the entry ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      'The field entry identifier is the priority of the entry in the group.'
 *      Yeah, right.  Where's that deed to the oceanfront property within easy
 *      walking distance of Des Moines?
 *
 *      Actually, the field entry identifier has nothing whatsoever to do with
 *      the priority, which is set separately.  Annoyingly, this function can
 *      only insert the entry into the group based upon a priority setting of
 *      BCM_FIELD_ENTRY_PRIO_DEFAULT, and it will be moved later if the user
 *      actually bothers to set the priority.
 */
int
bcm_petra_field_entry_create_id(int unit,
                                bcm_field_group_t group,
                                bcm_field_entry_t entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t next;
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_entry_type_t entryType;  
    uint8 found;   
    uint32 soc_sand_rv; 
    uint32 entryUninstalledTcLimit;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d) enter\n"), unit, group, entry));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    groupData = &(unitData->groupD[group]);
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        if (groupData->handle_by_key_entry_id != _BCM_DPP_FIELD_GROUP_ENTRY_BY_KEY_EMPTY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("only one entry can be created for group that handled by key")));
        }
    }
    entryType = unitData->stageD[groupData->stage].modeBits[groupData->grpMode]->entryType;
    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        if (_BCM_DPP_FIELD_ENT_TYPE_IS_TCAM(entryType)) {
            /* Check the entry-id is of same type than field group */
            if ((_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType) && _BCM_DPP_FIELD_ENT_IS_INTTCAM(unit, entry))
                || (_BCM_DPP_FIELD_ENT_TYPE_IS_INTTCAM(entryType) && _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry))) {
                result = BCM_E_CONFIG;
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d can not be used with"
                                      " group %d because group TCAM type is (0-int, 1-ext) "
                                      " %d whereas entry type (according to id) is"
                                      " (0-int, 1-ext) %d\n"),
                           unit,
                           entry,
                           group,
                           _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType),
                           _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)));
            }
            next = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry);
            if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next) &
                      _BCM_DPP_FIELD_ENTRY_IN_USE)) {
                entryUninstalledTcLimit = (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) ?
                                            _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit) : SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
                if (unitData->entryUninstalledTcCount < entryUninstalledTcLimit) {
                    _bcm_dpp_field_tcam_entry_clear(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next);                
                    if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                        if (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) {
                            /* External TCAM entry. Allocate an entry in the external TCAM info table. */
                            soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, unitData->extTcamBmp, &(unitData->entryExtTc[next].ext_info_idx), &found);
                            result = handle_sand_result(soc_sand_rv);
                            if (BCM_E_NONE == result) {
                                if (!found) {
                                    LOG_ERROR(BSL_LS_BCM_FP,
                                              (BSL_META_U(unit,
                                                          "unit %d reached max external TCAM entries before HW install\n"), unit));
                                    result = BCM_E_FULL;
                                }
                            }
                        }
                    }
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has exceeded number of uninstalled TCAM entries\n"), unit));
                    result = BCM_E_FULL;
                }
                if (BCM_E_NONE == result) {
                    result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                                                    group,
                                                                    next);
                }
            } else {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d is already in use\n"),
                           unit,
                           entry));
                result = BCM_E_EXISTS;
            }
        } else { /* if (group entry type is TCAM) */
            result = BCM_E_CONFIG;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d can not be used with"
                                  " group %d because group %d is direct"
                                  " extraction and entry %d is not\n"),
                       unit,
                       entry,
                       group,
                       group,
                       entry));
        } /* if (group entry type is TCAM) */
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry)) {
        next = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        result = _bcm_dpp_field_dir_ext_entry_alloc(unitData,
                                                    group,
                                                    TRUE,
                                                    &next);
        if (BCM_E_NONE == result) {
            _bcm_dpp_field_dir_ext_entry_clear(unitData, next);
            result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                               group,
                                                               next);
        }
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),  unit,  entry));
    }

    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        groupData->handle_by_key_entry_id = entry;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d) return %d (%s)\n"),
               unit,
               group,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function: bcm_petra_field_entry_multi_get
 *
 * Purpose:
 *     Gets an array of a group's entry IDs
 *
 * Parameters:
 *     unit -  (IN) BCM device number.
 *     group - (IN) Field group ID.
 *     entry_size - (IN) Maximum number of entries to return.  Set to 0
 *                       to get the number of entries available
 *     entry_array - (OUT) Pointer to a buffer to fill with the array of
 *                         entry IDs.  Ignored if entry_size is 0
 *     entry_count - (OUT) Returns the number of entries returned in the
 *                         array, or if entry_size was 0, the number of
 *                         entries available
 * Returns:
 *     BCM_E_INIT      - unit not initialized
 *     BCM_E_NOT_FOUND - Group ID not found in unit
 *     BCM_E_NONE      - Success
 */
int
bcm_petra_field_entry_multi_get(int unit,
                                bcm_field_group_t group,
                                int entry_size,
                                bcm_field_entry_t *entry_array,
                                int *entry_count)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t entry;
    _bcm_dpp_field_group_t *groupData;
    int index;
    _bcm_dpp_field_entry_type_t entryType;    

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, %d, *, *) enter\n"),
               unit,
               group,
               entry_size));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!entry_count) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("oblgatory out argument is NULL")));
    }
    if ((0 != entry_size) && (!entry_array)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "obligatory out argument is NULL\n")));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out argument is NULL")));
    }
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }    
    groupData = &(unitData->groupD[group]);
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d for this type of groups"),unit,group));
    }    
    _DPP_FIELD_UNIT_LOCK(unitData);
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        entryType = unitData->stageD[groupData->stage].modeBits[groupData->grpMode]->entryType;
        if (0 == entry_size) {
            *entry_count = groupData->entryCount;
        } else {
            switch (entryType) {
            case _bcmDppFieldEntryTypeDirExt:
                for (index = 0,
                     entry = groupData->entryHead;
                     (entry < unitData->entryDeLimit) &&
                     (index < entry_size);
                     index++,
                     entry = unitData->entryDe[entry].entryCmn.entryNext) {
                    entry_array[index] = entry +
                                         _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
                }
                break;
            default:
                /* default is TCAM */
                for (index = 0,
                     entry = groupData->entryHead;
                     (entry < _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType)) 
                      && (index < entry_size);
                     index++,
                     entry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), entry)) {
                    entry_array[index] = _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, entry, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)); 
                }
            }
            *entry_count = index;
        }
        result = BCM_E_NONE;
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_dpp_petra_field_entry_group(int unit,
                                       bcm_field_entry_t entry,
                                       _bcm_dpp_field_grp_idx_t *entryGroup)
{
    _bcm_dpp_field_info_t *unitData;
    _bcm_dpp_field_entry_common_t *entryCommon;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        *entryGroup = _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry) /*entry*/);
    } 
    else {
        if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry) &&
            ((unitData->entryTcLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam)) > _BCM_DPP_FIELD_PRESEL_FROM_ENTRY(entry))) {
            entryCommon = &(unitData->entryTc[_BCM_DPP_FIELD_PRESEL_FROM_ENTRY(entry) - _BCM_DPP_FIELD_ENT_BIAS(unit, InternalTcam)].entryCmn);
        } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
                   ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                      entry))  {
            entryCommon = &(unitData->entryDe[entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)].entryCmn);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d is not valid"),
                              unit,
                              entry));
        }

        *entryGroup = entryCommon->entryGroup;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_destroy
 *   Purpose
 *      Destroy a field entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID to destroy
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM spec says that this does not remove any associated entries from the
 *      hardware, but since we have no way to reset underlying driver, that is
 *      not safe; we therefore destroy hardware copy as well if it exists.
 */
int
bcm_petra_field_entry_destroy(int unit,
                              bcm_field_entry_t entry)
{
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_grp_idx_t entryGroup;
    bcm_field_presel_t presel;
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, entry));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    if ((_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)) && (soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE))) {
        presel = _BCM_DPP_FIELD_PRESEL_FROM_ENTRY(entry);
        result = _bcm_dpp_field_presel_destroy(unitData, presel);
    } else {
    /* Clean-up profile properties */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_petra_field_entry_group(unit, entry, &entryGroup));
    groupData = &(unitData->groupD[entryGroup]);
    
    if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
        groupData->handle_by_key_entry_id = _BCM_DPP_FIELD_GROUP_ENTRY_BY_KEY_EMPTY;
    } else {    

        if (BCM_FIELD_QSET_TEST(groupData->qset, bcmFieldQualifyAppType)) {
            /* If port profiles are defined - clear them */
            BCMDNX_IF_ERR_EXIT(
                _bcm_dpp_field_presel_port_profile_clear_type(unitData,
                                                              _bcmDppFieldProfileTypeFlpProgramProfile,
                                                              entry));
        }

        if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
            result = _bcm_dpp_field_tcam_entry_destroy(unitData,
                                                       _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                       _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry));
        } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
                   ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                    entry))  {
            result = _bcm_dpp_field_dir_ext_entry_destroy(unitData,
                                                          entry -
                                                          _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt));
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not valid\n"), unit, entry));
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
    }
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_destroy_all
 *   Purpose
 *      Destroy all field entries
 *   Parameters
 *      (in) int unit = the unit number
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM spec says that this does not remove any associated entries from the
 *      hardware, but since we have no way to reset underlying driver, that is
 *      not safe; we therefore destroy hardware copy as well if it exists.
 *
 *      This does not destroy the groups; only their entries.
 */
int
bcm_petra_field_entry_destroy_all(int unit)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_grp_idx_t currGroup;
    _bcm_dpp_field_grp_idx_t nextGroup;
    _bcm_dpp_field_ent_idx_t currEntry;
    _bcm_dpp_field_ent_idx_t nextEntry;
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_stage_idx_t stage;
    _bcm_dpp_field_entry_type_t entryType;    

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,*) enter\n"), unit));
    _BCM_DPP_SWITCH_API_START(unit);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    for (stage = 0;
         (BCM_E_NONE == result) &&
         (stage < unitData->devInfo->stages);
         stage++) {
        nextGroup = unitData->stageD[stage].groupHead;
        while ((BCM_E_NONE == result) &&
               (nextGroup < unitData->groupLimit)) {
            currGroup = nextGroup;
            groupData = &(unitData->groupD[currGroup]);
            nextGroup = groupData->groupNext;
            nextEntry = groupData->entryHead;
            entryType = unitData->stageD[groupData->stage].modeBits[groupData->grpMode]->entryType;
            switch (entryType) {
            case _bcmDppFieldEntryTypeDirExt:
                while ((BCM_E_NONE == result) &&
                       (nextEntry < unitData->entryDeLimit)) {
                    currEntry = nextEntry;
                    nextEntry = unitData->entryDe[currEntry].entryCmn.entryNext;
                    result = _bcm_dpp_field_dir_ext_entry_destroy(unitData,
                                                                  currEntry);
                }
                break;
            default:
                /* default is TCAM */
                while ((BCM_E_NONE == result) &&
                       (nextEntry < _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType))) {
                    currEntry = nextEntry;
                    nextEntry = _BCM_DPP_FIELD_TCAM_ENTRY_NEXT(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), currEntry);
                    result = _bcm_dpp_field_tcam_entry_destroy(unitData,
                                                               _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType),
                                                               currEntry);
                }
            } /* switch (group's entry type) */
        } /* while (no errors and more groups to scan) */
    } /* for (all stages as long as no errors) */
    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,*,*) return %d (%s)\n"),
               unit,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_copy
 *   Purpose
 *      Copy an existing field entry to another one
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t src_entry = the original entry ID
 *      (out) bcm_field_entry_t *dst_entry = where to put the copy entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      'The field entry identifier is the priority of the entry in the group.'
 *      Yeah, right.  Where's that deed to the oceanfront property within easy
 *      walking distance of Des Moines?
 *
 *      Actually, the field entry identifier has nothing whatsoever to do with
 *      the priority, which is set separately.  Annoyingly, this function will
 *      insert the entry into the group based upon a priority setting of
 *      BCM_FIELD_ENTRY_PRIO_DEFAULT, and it will be moved later if the user
 *      actually bothers to set the priority.
 *
 *      This can only copy the entry within its group, and the copy will be
 *      inserted as the last entry of the original entry's priority.  If the
 *      original entry is participating in counter sharing, so is the copy; if
 *      not, neither is the copy (but if the original had a counter allocated,
 *      so will the copy, though it will be a *different* counter).
 */
int
bcm_petra_field_entry_copy(int unit,
                           bcm_field_entry_t src_entry,
                           bcm_field_entry_t *dst_entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t next;
    _bcm_dpp_field_ent_idx_t curr;
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_entry_type_t entryType; 
    uint8 found;   
    uint32 soc_sand_rv; 
    uint32 entryUninstalledTcLimit;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,*) enter\n"), unit, src_entry));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!dst_entry) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory out arg must not be NULL")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, src_entry)) {
        curr = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, src_entry);
        groupData = &(unitData->groupD[_BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), curr)]);
        entryType = unitData->stageD[groupData->stage].modeBits[groupData->grpMode]->entryType;       
        if (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), curr) & _BCM_DPP_FIELD_ENTRY_IN_USE) {
            entryUninstalledTcLimit = (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) ?
                                        _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit) : SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
            if (unitData->entryUninstalledTcCount < entryUninstalledTcLimit) {
                next = _BCM_DPP_FIELD_TCAM_ENTRY_TC_FREE(entryType);
                if (next < _BCM_DPP_FIELD_TCAM_ENTRY_LIMIT(entryType)) {
                    LOG_DEBUG(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d next free entry is %d\n"),
                               unit,
                               next));
                    _bcm_dpp_field_tcam_entry_copy_id(unitData, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), next, curr);              
                    if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                        if (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType)) {
                            /* External TCAM entry. Allocate an entry in the external TCAM info table. */
                            soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, unitData->extTcamBmp, &(unitData->entryExtTc[next].ext_info_idx), &found);
                            result = handle_sand_result(soc_sand_rv);
                            if (BCM_E_NONE == result) {
                                if (!found) {
                                    LOG_ERROR(BSL_LS_BCM_FP,
                                              (BSL_META_U(unit,
                                                          "unit %d reached max external TCAM entries before HW install\n"), unit));
                                    result = BCM_E_FULL;
                                }
                                /* copy the src entry info to the dst entry info */
                                sal_memcpy(&(unitData->extTcamInfo[unitData->entryExtTc[next].ext_info_idx]),
                                           &(unitData->extTcamInfo[unitData->entryExtTc[curr].ext_info_idx]),
                                           sizeof(_bcm_dpp_field_entry_ext_info_t));
                            }
                        }
                    }
                    if (BCM_E_NONE == result) {
                        result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                      _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType), curr),
                                      next);
                    }
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has no free entries\n"), unit));
                    result = BCM_E_FULL;
                }
            } else {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d has exceeded number of uninstalled TCAM entries\n"), unit));
                result = BCM_E_FULL;
            }
            if (BCM_E_NONE == result) {
                *dst_entry = _BCM_DPP_FIELD_TCAM_GLOBAL_ID(unit, next, _BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(entryType));
            }
        } else { /* if (source entry is in use) */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       src_entry));
            result = BCM_E_NOT_FOUND;
        } /* if (source entry is in use) */
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= src_entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                src_entry)) {
        curr = src_entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        if (unitData->entryDe[curr].entryCmn.entryFlags & _BCM_DPP_FIELD_ENTRY_IN_USE) {
            result = _bcm_dpp_field_dir_ext_entry_alloc(unitData,
                                                        unitData->entryDe[curr].entryCmn.entryGroup,
                                                        FALSE,
                                                        &next);
            if (BCM_E_NONE == result) {
                _bcm_dpp_field_dir_ext_entry_copy_id(unitData, next, curr);
                result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                                   unitData->entryDe[curr].entryCmn.entryGroup,
                                                                   next);
            }
            if (BCM_E_NONE == result) {
                *dst_entry = next + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
            }
        } else { /* if (source entry is in use) */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       src_entry));
            result = BCM_E_NOT_FOUND;
        } /* if (source entry is in use) */
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit,
                   src_entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,&(%d)) return %d (%s)\n"),
               unit,
               src_entry,
               *dst_entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_copy_id
 *   Purpose
 *      Copy an existing field entry to a specific one
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t src_entry = the original entry ID
 *      (in) bcm_field_entry_t dst_entry = the copy entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      'The field entry identifier is the priority of the entry in the group.'
 *      Yeah, right.  Where's that deed to the oceanfront property within easy
 *      walking distance of Des Moines?
 *
 *      Actually, the field entry identifier has nothing whatsoever to do with
 *      the priority, which is set separately.  Annoyingly, this function will
 *      insert the entry into the group based upon a priority setting of
 *      BCM_FIELD_ENTRY_PRIO_DEFAULT, and it will be moved later if the user
 *      actually bothers to set the priority.
 *
 *      This can only copy the entry within its group, and the copy will be
 *      inserted as the last entry of the priority.  If the original entry is
 *      participating in counter sharing, so is the copy; if not, neither is
 *      the copy (but if the original had a counter allocated, so will the
 *      copy, though it will be a different counter).
 */
int
bcm_petra_field_entry_copy_id(int unit,
                              bcm_field_entry_t src_entry,
                              bcm_field_entry_t dst_entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t src;
    _bcm_dpp_field_ent_idx_t dst;
    uint8 found;   
    uint32 soc_sand_rv; 
    uint32 entryUninstalledTcLimit;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d) enter\n"), unit, src_entry, dst_entry));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, src_entry)) {
        if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, dst_entry)) {
            src = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, src_entry);
            dst = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, dst_entry);
            if (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), dst) & _BCM_DPP_FIELD_ENTRY_IN_USE) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d is already in use\n"),
                           unit,
                           dst_entry));
                result = BCM_E_EXISTS;
            }
            if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), src) &
                      _BCM_DPP_FIELD_ENTRY_IN_USE)) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d is not in use\n"),
                           unit,
                           src_entry));
                result = BCM_E_NOT_FOUND;
            }
            if (BCM_E_NONE == result) {
                entryUninstalledTcLimit = (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(src_entry)) ?
                                            _BCM_DPP_FIELD_NOF_PRE_INSTALL_EXT_TCAM_ENTRIES(unit) : SOC_DPP_DEFS_GET_NOF_ENTRY_IDS(unit);
                if (unitData->entryUninstalledTcCount < entryUninstalledTcLimit) {
                    _bcm_dpp_field_tcam_entry_copy_id(unitData, _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), dst, src);               
                    if (SOC_DPP_IS_ELK_ENABLE(unit)) {
                        if (_BCM_DPP_FIELD_ENT_TYPE_IS_EXTTCAM(src_entry)) {
                            /* External TCAM entry. Allocate an entry in the external TCAM info table. */
                            soc_sand_rv = soc_sand_occ_bm_alloc_next(unitData->unit, unitData->extTcamBmp, &(unitData->entryExtTc[dst].ext_info_idx), &found);
                            result = handle_sand_result(soc_sand_rv);
                            if (BCM_E_NONE == result) {
                                if (!found) {
                                    LOG_ERROR(BSL_LS_BCM_FP,
                                              (BSL_META_U(unit,
                                                          "unit %d reached max external TCAM entries before HW install\n"), unit));
                                    result = BCM_E_FULL;
                                }
                                /* copy the src entry info to the dst entry info */
                                sal_memcpy(&(unitData->extTcamInfo[unitData->entryExtTc[dst].ext_info_idx]),
                                           &(unitData->extTcamInfo[unitData->entryExtTc[src].ext_info_idx]),
                                           sizeof(_bcm_dpp_field_entry_ext_info_t));
                            }
                        }
                    }
                    if (BCM_E_NONE == result) {
                        result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                                                        _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, src_entry), src),
                                                                        dst_entry);
                    }
                } else {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d has exceeded number of uninstalled TCAM entries\n"), unit));
                    result = BCM_E_FULL;
                }
            }
        } else { /* if (dst_entry is a TCAM entry) */
            result = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is TCAM but entry %d is"
                                  " not TCAM\n"),
                       unit,
                       src_entry,
                       dst_entry));
        } /* if (dst_entry is a TCAM entry) */
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= src_entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                src_entry)) {
        if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= dst_entry) &&
            ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
             dst_entry)) {
            src = src_entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
            dst = dst_entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
            if (unitData->entryDe[src].entryCmn.entryFlags & _BCM_DPP_FIELD_ENTRY_IN_USE) {
                result = _bcm_dpp_field_dir_ext_entry_alloc(unitData,
                                                            unitData->entryDe[src].entryCmn.entryGroup,
                                                            TRUE,
                                                            &dst);
                if (BCM_E_NONE == result) {
                    _bcm_dpp_field_dir_ext_entry_copy_id(unitData, dst, src);
                    result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                                       unitData->entryDe[src].entryCmn.entryGroup,
                                                                       dst);
                }
            } else { /* if (source entry is in use) */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d is not in use\n"),
                           unit,
                           src_entry));
                result = BCM_E_NOT_FOUND;
            } /* if (source entry is in use) */
        } else { /* if (dst_entry is a DirExt entry) */
            result = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is Direct Extraction but"
                                  " entry %d is not Direct Extraction\n"),
                       unit,
                       src_entry,
                       dst_entry));
        } /* if (dst_entry is a DirExt entry) */
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),
                   unit,
                   src_entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d) return %d (%s)\n"),
               unit,
               src_entry,
               dst_entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_install
 *   Purpose
 *      Install a field entry to the hardware
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID to destroy
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This causes an error if the entry is already in hardware.
 *
 *      If the entry does not yet have a hardware priority (this is not a BCM
 *      layer priority) assigned, the entire group hardware priorities will be
 *      recalculated and new values assigned, and all entries in hardware
 *      already will be adjusted approprately.
 */
int
bcm_petra_field_entry_install(int unit,
                              bcm_field_entry_t entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    bcm_field_presel_t presel;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, entry));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);
    if ((_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)) && (soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE))) {
        presel = _BCM_DPP_FIELD_PRESEL_FROM_ENTRY(entry);
        result = _bcm_dpp_field_presel_install(unitData, presel);
    } else if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        /*
         * ARAD Only: 
         * The entry_install method determines the order of the entries in the 
         * HW in case of similar priorities. 
         * Since there is no priority management in the SW, if several entries 
         * are created and then installed in different order of their creation, 
         * then the installation order will be the one to determine which is first. 
         * Same goes for prio_set - if the same priority is configured for several 
         * entries, in an order that's different than the order of their creation, 
         * then the new order will be according to the prio_set order, and the 
         * order in the HW will be according to the order the entry_install 
         * was called. 
         */ 
        result = _bcm_dpp_field_tcam_entry_install(unitData,
                                                   _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                   _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry));
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        result = _bcm_dpp_field_dir_ext_entry_install(unitData,
                                                      entry -
                                                      _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt));
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_reinstall
 *   Purpose
 *      Reinstall a field entry to the hardware
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID to destroy
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This does the same thing as entry install.  Somewhere in the API docs
 *      it claims this behaves differently (this should fail if the entry is
 *      not installed; install should fail if the entry is already installed),
 *      but the DVAPI tests steadfastly insist that both install and reinstall
 *      can be used successfully in either situation.
 */
int
bcm_petra_field_entry_reinstall(int unit,
                                bcm_field_entry_t entry)
{
    int rv = BCM_E_NONE;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    rv = bcm_petra_field_entry_install(unit, entry);
    _BCM_DPP_SWITCH_API_END(unit);
    return rv;
}

/*
 *   Function
 *      bcm_petra_field_entry_remove
 *   Purpose
 *      Remove a field entry from the hardware
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID to destroy
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      The API doc indicates that this can only be used against an entry that
 *      is already in hardware, but the regression tests require that it work
 *      even if the entry isn't in hardware.
 */
int
bcm_petra_field_entry_remove(int unit,
                             bcm_field_entry_t entry)
{
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, entry));

    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API is not supported for External TCAM")));
    }
		if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        result = _bcm_dpp_field_tcam_entry_remove(unitData,
                                                  _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                  _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry));
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                 entry))  {
        result = _bcm_dpp_field_dir_ext_entry_remove(unitData,
                                                     entry -
                                                     _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt));
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_prio_get
 *   Purpose
 *      Get the priority of a specific entry (within its group)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (out) int *prio = where to put the entry's priority
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      The field entry identifier is NOT the priority of the entry in the
 *      group on in the system.
 *      Priority is signed; nonnegative numbers are priority order; negative
 *      numbers have special meanings.
 *      Overall sort is:
 *          highest >= numbered >= dontcare >= lowest
 */
int
bcm_petra_field_entry_prio_get(int unit,
                               bcm_field_entry_t entry,
                               int *prio)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t ent;
    uint32 flags;
    int entPrio;
    SOC_PPD_FP_ENTRY_INFO entInfo;
    uint8 found;
    uint32 soc_sand_rv;
    _bcm_dpp_field_group_t *groupData;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, entry));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!prio) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("oblgatory out argument is NULL")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        ent = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry);
        flags = _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
        groupData = &(unitData->groupD[_BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent)]);
        if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d entries by key doesn't have priority "),unit,
                                               _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent)));
        }
        /* if entry is in HW, get priority from SOC level. otherwise from SW state (also for Direct table entries in HW). */
        if ((flags & _BCM_DPP_FIELD_ENTRY_IN_HW) && (groupData->grpMode != bcmFieldGroupModeDirect)) {
            SOC_PPD_FP_ENTRY_INFO_clear(&entInfo);
            soc_sand_rv = soc_ppd_fp_entry_get(unitData->unitHandle,
                                               groupData->hwHandle,
                                               _BCM_DPP_FIELD_TCAM_ENTRY_HW_HANDLE(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent),
                                               &found,
                                               &entInfo);
            result = handle_sand_result(soc_sand_rv);
            if (BCM_E_NONE == result) {
                if (found) {
                    entPrio = BCM_FIELD_ENTRY_BCM_PRIO_TO_DPP_PRIO(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), entInfo.priority);
                }
                else {
                    result = BCM_E_NOT_FOUND;
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d entry %d not valid\n"), unit, entry));
                }
            }
        }
        else {
            entPrio = _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                 entry))  {
        ent = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        flags = unitData->entryDe[ent].entryCmn.entryFlags;
        entPrio = unitData->entryDe[ent].entryCmn.entryPriority;
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d not valid\n"), unit, entry));
    }
    if (BCM_E_NONE == result) {
        if (flags & _BCM_DPP_FIELD_ENTRY_IN_USE) {
            *prio = entPrio;
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d not in use\n"),
                       unit,
                       entry));
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, &(%d)) return %d (%s)\n"),
               unit,
               entry,
               *prio,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_prio_set
 *   Purpose
 *      Set the priority of a specific entry (within its group)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) int prio = the entry's new priority
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      The field entry identifier is NOT the priority of the entry in the
 *      group on in the system.
 *      Priority is signed; nonnegative numbers are priority order; negative
 *      numbers have special meanings. Overall sort is:
 *          highest >= numbered >= dontcare >= lowest
 *
 *      This will invalidate the hardware priority assigned to the entry (if
 *      one has been assigned already) and mark the group as containing 'new'
 *      entries, and so will eventually cause a phase change and refresh for
 *      the group.
 */
int
bcm_petra_field_entry_prio_set(int unit,
                                bcm_field_entry_t entry,
                                int prio)
{
    _DPP_FIELD_COMMON_LOCALS;
    _bcm_dpp_field_ent_idx_t ent;
    int *priority;
    int max_entry_priorities;
    _bcm_dpp_field_group_t *groupData;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, %d) enter\n"), unit, entry, prio));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (0 > prio) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("negative priority is not supported")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        ent = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry);        
        groupData = &(unitData->groupD[_BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent)]);
        if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_HANDLE_ENTRIES_BY_KEY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG_NO_UNIT("unit %d group %d entries by key doesn't have priority "),unit,
                                               _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent)));
        }
        max_entry_priorities = groupData->maxEntryPriorities;
        if (_BCM_DPP_FIELD_ENTRY_IN_USE & _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent)) {
            if (_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry) && (max_entry_priorities > 0)) {
                if (prio > max_entry_priorities) {
                    LOG_ERROR(BSL_LS_BCM_FP,
                              (BSL_META_U(unit,
                                          "unit %d entry %d priority is out of group's priority range\n"),
                               unit,
                               entry));
                    result = BCM_E_PARAM;
                }
            }
            if (result == BCM_E_NONE) {
                priority = _BCM_DPP_FIELD_TCAM_ENTRY_PRIORITY_PTR(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
                *priority = prio;
                result = _bcm_dpp_field_tcam_entry_add_to_group(unitData,
                                                                _BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent),
                                                                ent);
            }
        } else {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       entry));
            result = BCM_E_NOT_FOUND;
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        ent = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        if (_BCM_DPP_FIELD_ENTRY_IN_USE & unitData->entryDe[ent].entryCmn.entryFlags) {
            unitData->entryDe[ent].entryCmn.entryPriority = prio;
            result = _bcm_dpp_field_dir_ext_entry_add_to_group(unitData,
                                                               unitData->entryDe[ent].entryCmn.entryGroup,
                                                               ent);
        } else {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       entry));
            result = BCM_E_NOT_FOUND;
        }
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d not valid\n"), unit, entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, %d) return %d (%s)\n"),
               unit,
               entry,
               prio,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_add
 *   Purpose
 *      Add a specific action to a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to add
 *      (in) uint32 param0 = action parameter 0 (some actions)
 *      (in) uint32 param1 = action parameter 1 (some actions)
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      No hardware changes; only software state.
 */
int
bcm_petra_field_action_add(int unit,
                            bcm_field_entry_t entry,
                            bcm_field_action_t action,
                            uint32 param0,
                            uint32 param1)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d,%d) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               param0,
               param1));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        {
            result = _bcm_dpp_field_tcam_entry_action_set(unitData,
                                                          _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                          _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                          action,
                                                          param0,
                                                          param1);
        }
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d not valid for this function\n"),
                   unit,
                   entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d,%d) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               param0,
               param1,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_get
 *   Purpose
 *      Get a specific action from a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to get
 *      (out) uint32 *param0 = action parameter 0 (some actions)
 *      (out) uint32 *param1 = action parameter 1 (some actions)
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      No hardware changes; only software state.
 */
int
bcm_petra_field_action_get(int unit,
                            bcm_field_entry_t entry,
                            bcm_field_action_t action,
                            uint32 *param0,
                            uint32 *param1)
{
    _DPP_FIELD_COMMON_LOCALS;
    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),*%08X,%08X) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               PTR_TO_INT(param0),
               PTR_TO_INT(param1)));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((!param0) || (!param1)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory outbound argument is NULL")));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
            result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                          _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                          _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                          action,
                                                          param0,
                                                          param1);
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d not valid for this function\n"),
                       unit,
                       entry));
        }
    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),&(%d),&(%d)) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               *param0,
               *param1,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_remove
 *   Purpose
 *      Remove a specific action from a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to remove
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      No hardware changes; only software state.
 */
int
bcm_petra_field_action_remove(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_action_t action)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d)) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > action) || (bcmFieldActionCount <= action)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("action %d is not valid"), action));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        {
            result = _bcm_dpp_field_tcam_entry_action_clear(unitData,
                                                            _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                            _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                            action);
        }
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        result = _bcm_dpp_field_dir_ext_entry_action_clear(unitData,
                                                           entry -
                                                           _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt),
                                                           action);
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d)) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_delete
 *   Purpose
 *      Remove a specific action from a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_action_t action = the action to remove
 *      (in) param0 = parameter 0 for the action to remove
 *      (in) param1 = parameter 1 for the action to remove
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      It's an error (BCM_E_NOT_FOUND) to try to remove an action that exists
 *      byt whose param0,param1 is not equal to the specifications here.
 */
int
bcm_petra_field_action_delete(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_action_t action,
                               uint32 param0,
                               uint32 param1)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint32 lparam0;
    uint32 lparam1;

    BCMDNX_INIT_FUNC_DEFS;

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d,%d) enter\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               param0,
               param1));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > action) || (bcmFieldActionCount <= action)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("action %d is not valid"), action));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                      action,
                                                      &lparam0,
                                                      &lparam1);
        if (BCM_E_NONE == result) {
            if ((lparam0 == param0) && (lparam1 == param1)) {
                /* exact match found, remove it */
                result = _bcm_dpp_field_tcam_entry_action_clear(unitData,
                                                                _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                                _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                                action);
            } else { /* if ((lparam0 == param0) && (lparam1 == param1)) */
                /* at least one of param0, param1 is not as before */
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d has action %d (%s) but"
                                      " param0 %d(%08X) or param1 %d(%08X) was"
                                      " not same as specified param0 %d(%08X)"
                                      " or param1 %d(%08X\n"),
                           unit,
                           entry,
                           action,
                           ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
                           lparam0,
                           lparam0,
                           lparam1,
                           lparam1,
                           param0,
                           param0,
                           param1,
                           param1));
                result = BCM_E_PARAM; 
            } /* if ((lparam0 == param0) && (lparam1 == param1)) */
        } /* if (BCM_E_NONE == result) */
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%s(%d),%d,%d) return %d (%s)\n"),
               unit,
               entry,
               ((0 <= action) && (bcmFieldActionCount > action))?_bcm_dpp_field_action_name[action]:"???",
               action,
               param0,
               param1,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_action_remove_all
 *   Purpose
 *      Remove all actions from a specific entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      No hardware changes; only software state.
 */
int
bcm_petra_field_action_remove_all(int unit,
                                  bcm_field_entry_t entry)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, entry));

    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        result = _bcm_dpp_field_tcam_entry_clear_acts(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry));
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) > entry))  {
        result = _bcm_dpp_field_dir_ext_entry_clear_acts(unitData,
                                                         entry -
                                                         _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt));
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"), unit, entry));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_clear
 *   Purpose
 *      Clear all qualifiers for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_clear(int unit,
                              bcm_field_entry_t entry)
{
    uint32 *flags;
    _bcm_dpp_field_qual_t *quals;
    _bcm_dpp_field_ent_idx_t ent;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"), unit, entry));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry)) {
        ent = _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry);
        flags = _BCM_DPP_FIELD_TCAM_ENTRY_FLAGS_PTR(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
        quals = _BCM_DPP_FIELD_TCAM_ENTRY_QUALS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), ent);
    } else if ((_BCM_DPP_FIELD_ENT_BIAS(unit, DirExt) <= entry) &&
               ((unitData->entryDeLimit + _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt)) >
                entry))  {
        ent = entry - _BCM_DPP_FIELD_ENT_BIAS(unit, DirExt);
        flags = &(unitData->entryDe[ent].entryCmn.entryFlags);
        quals = &(unitData->entryDe[ent].entryCmn.entryQual[0]);
    } else {
        result = BCM_E_NOT_FOUND;
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not valid\n"),  unit,  entry));
    }
    if (BCM_E_NONE == result) {
        if ((*flags) & _BCM_DPP_FIELD_ENTRY_IN_USE) {
            _bcm_dpp_field_entry_clear_quals(unitData, quals);
            *flags |= (_BCM_DPP_FIELD_ENTRY_CHANGED);
        } else {
            result = BCM_E_NOT_FOUND;
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d is not in use\n"),
                       unit,
                       entry));
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcIp6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6(int unit,
                               bcm_field_entry_t entry,
                               bcm_ip6_t data,
                               bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t *data,
                                   bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstIp6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6(int unit,
                               bcm_field_entry_t entry,
                               bcm_ip6_t data,
                               bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t *data,
                                   bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6High
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcIp6High
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6High(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t data,
                                   bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6High_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip6_t *data,
                                       bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6High
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstIp6High
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6High(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t data,
                                   bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6High_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip6_t *data,
                                       bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6Low
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcIp6Low
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6Low(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_ip6_t data,
                                  bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6Low,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp6Low_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp6Low
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp6Low_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_ip6_t *data,
                                      bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifySrcIp6Low,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6Low
 * Purpose:
 *      Set match criteria for bcmFieldQualifyDstIp6Low
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6Low(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_ip6_t data,
                                  bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6Low,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp6Low_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp6Low
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp6Low_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_ip6_t *data,
                                      bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyDstIp6Low,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_SrcMac
 *   Purpose
 *      Set expected source MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_SrcMac(int unit,
                               bcm_field_entry_t entry,
                               bcm_mac_t data,
                               bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifySrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcMac_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_mac_t *data,
                                   bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifySrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_DstMac
 *   Purpose
 *      Set expected destination MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which destination MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_DstMac(int unit,
                               bcm_field_entry_t entry,
                               bcm_mac_t data,
                               bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMac_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_mac_t *data,
                                   bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_SrcIp
 *   Purpose
 *      Set expected source IPv4 address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_ip_t data = which source IPv4 address
 *      (in) bcm_ip_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_SrcIp(int unit,
                               bcm_field_entry_t entry,
                               bcm_ip_t data,
                               bcm_ip_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcIp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIp_get(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_ip_t *data,
                                  bcm_ip_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcIp,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_DstIp
 *   Purpose
 *      Set expected destination IPv4 address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_ip_t data = which destination IPv4 address
 *      (in) bcm_ip_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_DstIp(int unit,
                               bcm_field_entry_t entry,
                               bcm_ip_t data,
                               bcm_ip_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstIp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstIp_get(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_ip_t *data,
                                  bcm_ip_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstIp,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_gport_to_pp_port_tm_port_convert(int unit,
                                                bcm_port_t data,
                                                uint32 *pp_port,
                                                uint32 *tm_port)
{
    bcm_port_t port = -1;
	bcm_gport_t gport_mod_port = 0;
    bcm_module_t myModule;
    uint32 port_res;
    int core;
    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_SET(data)) {
        if (BCM_GPORT_IS_LOCAL(data)) {
            port = BCM_GPORT_LOCAL_GET(data);
        } else if (BCM_GPORT_IS_SYSTEM_PORT(data) || BCM_GPORT_IS_MODPORT(data)) {
			if (BCM_GPORT_IS_SYSTEM_PORT(data)) {
				BCMDNX_IF_ERR_EXIT_MSG(bcm_petra_stk_sysport_gport_get(unit, data, &gport_mod_port), 
									(_BSL_BCM_MSG("unable to get gport mod-port ID")));
			} else {
				gport_mod_port = data;
			}
            BCMDNX_IF_ERR_EXIT_MSG(bcm_petra_stk_my_modid_get(unit, &myModule), 
                                (_BSL_BCM_MSG("unable to get local module ID")));
            port = BCM_GPORT_MODPORT_PORT_GET(gport_mod_port);
            if (BCM_GPORT_MODPORT_MODID_GET(gport_mod_port) != myModule) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports local ports for"
                                           " InPort qualifier")));
            }
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only support MODPORT and LOCAL type"
                                       " GPORTS; %08X it not supported"),
                              port));
        }
    } else { /* if (BCM_GPORT_IS_SET(data)) */
        port = data;
    } /* if (BCM_GPORT_IS_SET(data)) */

    /* map local port to PP port */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port, &port_res, &core)));

    *pp_port = port_res;
    if (_BCM_DPP_NOF_LOCAL_PORTS(unit) <= *pp_port) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d port %d(%08X)"
                                           " is not a valid local"
                                           " port number"),
                          unit,
                          *pp_port,
                          *pp_port));
    } /* if (resulting port number is not valid) */


    /* map local port to TM port */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_tm_port_get, (unit, port, &port_res, &core)));

    *tm_port = port_res;
    if (_BCM_DPP_NOF_LOCAL_PORTS(unit) <= *tm_port) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d port %d(%08X)"
                                           " is not a valid local"
                                           " port number"),
                          unit,
                          *tm_port,
                          *tm_port));
    } /* if (resulting port number is not valid) */

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_qualify_pp_port_convert(int unit,
                               bcm_port_t data,
                               bcm_port_t mask,
                               uint64 *edata,
                               uint64 *emask)
{
    uint32 pp_port, tm_port;
    BCMDNX_INIT_FUNC_DEFS;

    if ((0 != mask) && ((~0) != mask)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                   " bits set or all bits clear clear)")));
    }

    BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_gport_to_pp_port_tm_port_convert(unit, data, &pp_port, &tm_port),
                        (_BSL_BCM_MSG("unable to get the TM or PP port with gport %d"), data));

    COMPILER_64_SET(*edata, 0, pp_port);
    if (0 == mask) {
        COMPILER_64_ZERO(*emask);
    } else {
#ifdef BCM_PETRAB_SUPPORT
        if (SOC_IS_PETRAB(unit)) {
            /* InPort encoded in 6 bits in Soc_petra-B */
            COMPILER_64_SET(*emask, 0, 0x3F);
        }
#endif /* def BCM_PETRAB_SUPPORT */
#ifdef BCM_ARAD_SUPPORT
        if (SOC_IS_ARAD(unit)) {
            /* InPort encoded in 8 bits in Arad */
            COMPILER_64_SET(*emask, 0, 0xFF);
        }
#endif /* BCM_ARAD_SUPPORT */
    }
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_dpp_field_qualify_fwd_decision_from_hw_convert(int unit,
                                                    uint8 is_for_destination,
                                                    uint32 data_in,
                                                    uint32 flags,
                                                    SOC_PPD_FRWRD_DECISION_INFO   *fwdDecision)
{
    BCMDNX_INIT_FUNC_DEFS;

    SOC_PPD_FRWRD_DECISION_INFO_clear(fwdDecision);

    /* Get the HW Destination from the Forward decision */
#ifdef BCM_PETRAB_SUPPORT
    if (SOC_IS_PETRAB(unit)) {
        uint32 ppdr;
        uint8 is_sa_drop;
        int result;
        /* Decode the Destination to flow */
        ppdr = soc_pb_pp_fwd_decision_in_buffer_parse(SOC_PB_PP_FRWRD_DECISION_APPLICATION_TYPE_MACT, /* Only for qualifiers, not for action */
                                                      (is_for_destination?data_in:0),
                                                      (is_for_destination?0:data_in),
                                                      fwdDecision,
                                                      &is_sa_drop);
        result = handle_sand_result(ppdr);
        if (BCM_E_NONE != result) {
            BCMDNX_ERR_EXIT_MSG(result, (_BSL_BCM_MSG("Incorrect decoding operation with PPD HW value %d\n"), data_in));
        }
    }
#endif /* BCM_PETRAB_SUPPORT */
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        uint32 ppdr;
        int result;
        /* Decode the Destination to flow */
        ppdr = arad_pp_fwd_decision_in_buffer_parse((unit),
                                                    0,
                                                    (is_for_destination?data_in:0),
                                                    (is_for_destination?0:data_in),
                                                    flags,
                                                    fwdDecision);

        result = handle_sand_result(ppdr);
        if (BCM_E_NONE != result) {
            BCMDNX_ERR_EXIT_MSG(result, (_BSL_BCM_MSG("Incorrect nickname during decoding operation with PPD HW value %d\n"), data_in));
        }
    }
#endif /* BCM_ARAD_SUPPORT */

    goto exit;

exit:
    BCMDNX_FUNC_RETURN;
}

/* Get the LAG default mask where the LAG member id is removed */
STATIC int
_bcm_dpp_field_qualify_lag_mask_get(int unit,
                                    uint32 *mask_requirement)
{
    BCMDNX_INIT_FUNC_DEFS;

    *mask_requirement = 0;
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        uint32 ppdr;
        int result;
        ARAD_PORT_LAG_MODE lag_mode;
        uint32  sys_lag_port_id_nof_bits;
        /* In case of Trunk-LAG, unmask the member-id part */
        /* Decode the Destination to flow */
        ppdr = arad_ports_lag_mode_get_unsafe((unit),
                                              &lag_mode,
                                              &sys_lag_port_id_nof_bits);

        result = handle_sand_result(ppdr);
        if (BCM_E_NONE != result) {
            BCMDNX_ERR_EXIT_MSG(result, (_BSL_BCM_MSG("Incorrect get of the LAG mode \n")));
        }
        /* LAG mask LSB is the LAG group, MSB is the encoding */
        *mask_requirement = 0xFFFF8000 | ((1 << sys_lag_port_id_nof_bits) - 1);
    }
#endif /* BCM_ARAD_SUPPORT */
    goto exit;

exit:
    BCMDNX_FUNC_RETURN;
}



int
_bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(int unit,
                                                              SOC_PPD_FRWRD_DECISION_INFO   *fwdDecision,
                                                              uint8 is_for_destination,
                                                              uint8 is_for_action,
                                                              uint64 *edata,
                                                              uint64 *emask)
{
    uint32 mask_requirement= ~0;
    uint32 mask_proposed;
    BCMDNX_INIT_FUNC_DEFS;

    /* Init the values */
    mask_proposed = COMPILER_64_LO(*emask);
    COMPILER_64_SET(*edata, 0, 0);
    COMPILER_64_SET(*emask, 0, 0);

    /* Get the HW Destination from the Forward decision */
#ifdef BCM_PETRAB_SUPPORT
    if (SOC_IS_PETRAB(unit)) {
        uint32 ppdr, dest_buf = 0, asd_buf = 0;
        SOC_PB_PP_FRWRD_DECISION_APPLICATION_TYPE app_type;
        int result;

        app_type = is_for_action? SOC_PB_PP_FRWRD_DECISION_APPLICATION_TYPE_PMF: SOC_PB_PP_FRWRD_DECISION_APPLICATION_TYPE_MACT;
        ppdr = soc_pb_pp_fwd_decision_in_buffer_build(
                    app_type,
                    fwdDecision,
                    0, /* is_sa_drop */
                    &dest_buf,
                    &asd_buf);
        result = handle_sand_result(ppdr);
        if (BCM_E_NONE != result) {
            BCMDNX_ERR_EXIT_MSG(result, (_BSL_BCM_MSG("Incorrect nickname during"
                                               " encoding operation\n")));
        }
        COMPILER_64_SET(*edata, 0, (is_for_destination? dest_buf: asd_buf));
        
        switch (fwdDecision->type) {
        case SOC_PPC_FRWRD_DECISION_TYPE_UC_FLOW:
            mask_requirement = ((~0) << 15);
            break;
        case SOC_PPC_FRWRD_DECISION_TYPE_MC:
            mask_requirement = ((~0) << 14);
            break;
        /* all remaining types must be exact match */
        default:
            mask_requirement = ~0;
        }
    }

#endif /* BCM_PETRAB_SUPPORT */
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        uint32 ppdr, dest_buf = 0, asd_buf = 0;
        int result;
        ppdr = arad_pp_fwd_decision_in_buffer_build((unit),
                                                    0,
                                                    fwdDecision,
                                                    &dest_buf,
                                                    &asd_buf);
        result = handle_sand_result(ppdr);
        if (BCM_E_NONE != result) {
            BCMDNX_ERR_EXIT_MSG(result, (_BSL_BCM_MSG("Incorrect nickname during"
                                               " encoding operation\n")));
        }
        COMPILER_64_SET(*edata, 0, (is_for_destination? dest_buf: asd_buf));
        
        switch (fwdDecision->type) {
        case SOC_PPC_FRWRD_DECISION_TYPE_UC_FLOW:
            mask_requirement = ((~0) << 15);
            break;
        case SOC_PPC_FRWRD_DECISION_TYPE_MC:
            mask_requirement = ((~0) << 14);
            break;
        case SOC_PPC_FRWRD_DECISION_TYPE_UC_LAG:
            BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_lag_mask_get(unit,&mask_requirement),
                                (_BSL_BCM_MSG("unable to get the lag data mask")));
            break;
        /* all remaining types must be exact match */
        default:
            mask_requirement = ~0;
        }
    }
#endif /* BCM_ARAD_SUPPORT */

    
    if (mask_proposed) {
        /* the mask is not all zeroes (so not match anything) */
        if ((mask_proposed & mask_requirement) != mask_requirement) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("unit %d forwarding decision %s (%d)"
                                       " requires mask (%08X) either be all"
                                       " zeroes or have bits %08X set"),
                              unit,
                              SOC_PPD_FRWRD_DECISION_TYPE_to_string(fwdDecision->type),
                              fwdDecision->type,
                              mask_proposed,
                              mask_requirement));
        } /* if ((mask_proposed && mask_requirement) != mask_requirement) */
        COMPILER_64_SET(*emask, 0, mask_proposed);
    } /* if (mask_proposed) */

exit:
    BCMDNX_FUNC_RETURN;
}



STATIC int
_bcm_dpp_field_qualify_gport_to_hw_destination_convert(int unit,
                                                       bcm_gport_t   data_port,
                                                       bcm_gport_t   mask_port,
                                                       uint64 *edata,
                                                       uint64 *emask)
{
    SOC_PPD_FRWRD_DECISION_INFO  fwdDecision;
    bcm_gport_t   mask_port_lcl = mask_port;
    uint32 mask_requirement;

    BCMDNX_INIT_FUNC_DEFS;

    /* Init the values */
    COMPILER_64_SET(*edata, 0, 0);
    COMPILER_64_SET(*emask, 0, 0);

    switch ((data_port >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK) {
    case _SHR_GPORT_TYPE_MCAST:
        if (~(mask_port | (_SHR_GPORT_MCAST_MASK <<
                           _SHR_GPORT_MCAST_SHIFT))) {
            /* mask bits are clear that are not in the variable space */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X mask must have all bits"
                                       " clear, or bits %08X must be set"),
                              data_port,
                              ~(_SHR_GPORT_MCAST_MASK <<
                                _SHR_GPORT_MCAST_SHIFT)));
        }
        break;
    case _SHR_GPORT_TYPE_SCHEDULER:
        if (~(mask_port | (_SHR_GPORT_SCHEDULER_MASK <<
                           _SHR_GPORT_SCHEDULER_SHIFT))) {
            /* mask bits are clear that are not in the variable space */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X mask must have all bits"
                                       " clear, or bits %08X must be set"),
                              data_port,
                              ~(_SHR_GPORT_SCHEDULER_MASK <<
                                _SHR_GPORT_SCHEDULER_SHIFT)));
        }
        break;
    case _SHR_GPORT_TYPE_UCAST_QUEUE_GROUP:
        if (~(mask_port | (_SHR_GPORT_UCAST_QUEUE_GROUP_QID_MASK <<
                           _SHR_GPORT_UCAST_QUEUE_GROUP_QID_SHIFT))) {
            /* mask bits are clear that are not in the variable space */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X mask must have all bits"
                                       " clear, or bits %08X must be set"),
                              data_port,
                              ~(_SHR_GPORT_UCAST_QUEUE_GROUP_QID_MASK <<
                                _SHR_GPORT_UCAST_QUEUE_GROUP_QID_SHIFT)));
        }
        break;
    case _SHR_GPORT_TYPE_TRUNK:
        if (~(mask_port | (_SHR_GPORT_TRUNK_MASK <<
                           _SHR_GPORT_TRUNK_SHIFT))) {
            /* mask bits are clear that are not in the variable space */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X mask must have all bits"
                                       " clear, or bits %08X must be set"),
                              data_port,
                              ~(_SHR_GPORT_TRUNK_MASK <<
                                _SHR_GPORT_TRUNK_SHIFT)));
        }
        /* Set the correct mask - mask the LAG-Member-Id part */
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_lag_mask_get(unit,&mask_requirement),
                            (_BSL_BCM_MSG("unable to get the lag data mask")));
        mask_port_lcl &= mask_requirement;
        break;
    default:
        /* other GPORT types must be exact match or ignore */
        if ((0 != mask_port)  && ((~0) != mask_port)) {
            /* neither ignore nor exact match */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("gport %08X only supports all or"
                                       " nothing mask (all bits set or all"
                                       " bits clear clear)"),
                              data_port));
        }
    } /* switch ((data_port >> _SHR_GPORT_TYPE_SHIFT) & _SHR_GPORT_TYPE_MASK) */

    /* now we know the mask is acceptable for the type of GPORT */
    /* The data port must be gport */
    if (BCM_GPORT_IS_SET(data_port) && mask_port_lcl) {
        /* Find the Forward destination */
        SOC_PPD_FRWRD_DECISION_INFO_clear(&fwdDecision);
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_gport_to_fwd_decision(unit,
                                                           data_port,
                                                           &fwdDecision),
                            (_BSL_BCM_MSG("unable to get the forward decision"
                                      " with gport %08X"),
                             data_port));
        /* propose using the caller's mask request */
        COMPILER_64_SET(*emask, 0, mask_port_lcl);
        /* Get the HW Destination from the Forward decision */
        BCMDNX_IF_ERR_EXIT_MSG(
            _bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(unit,
                                                                          &fwdDecision,
                                                                          TRUE, /* is_for_destination */
                                                                          FALSE, /* is_for_action */
                                                                          edata,
                                                                          emask),
            (_BSL_BCM_MSG("unable to get from the forward decision the HW data")));

    } /* if (BCM_GPORT_IS_SET(data_port)) */

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_qualify_gport_from_hw_destination_convert(int unit,
                                                         uint32 ppdHwDest,
                                                         bcm_gport_t   *gport)
{
    SOC_PPD_FRWRD_DECISION_INFO fwdDecision;

    BCMDNX_INIT_FUNC_DEFS;

    /* Init the values */
    *gport = 0;
    SOC_PPD_FRWRD_DECISION_INFO_clear(&fwdDecision);

    /* Decode the Destination to flow */
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_fwd_decision_from_hw_convert(unit,
                                                            TRUE, /* is_for_destination */
                                                            ppdHwDest,
                                                            ARAD_PP_FWD_DECISION_PARSE_DEST,
                                                            &fwdDecision));

    BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_gport_from_fwd_decision(unit, gport, &fwdDecision),
                        (_BSL_BCM_MSG("unable to get the gport from the forward decision with PPD HW value %d\n"), ppdHwDest));
    goto exit;

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_dpp_field_qualify_mod_port_to_gport_convert(int unit,
                                                 bcm_module_t data_modid,
                                                 bcm_module_t mask_modid,
                                                 bcm_port_t   data_port,
                                                 bcm_port_t   mask_port,
                                                 bcm_gport_t *data,
                                                 bcm_gport_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    *data = 0;
    *mask = 0;
    if (mask_port) {
        if (BCM_GPORT_IS_SET(data_port)) {
            /* GPORT conversion will verify mask later */
            *data = data_port;
            *mask = mask_port;
        } else { /* if (BCM_GPORT_IS_SET(data_port)) */
            /* mod,port -- verify mask now */
            if (((0 != mask_modid) && ((~0) != mask_modid))
                || ((0 != mask_port) && ((~0) != mask_port))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports all or nothing mask"
                                           " (all bits set or all bits clear)")));
            }
            /* now build GPORT for it */
            BCM_GPORT_MODPORT_SET(*data, data_modid, data_port);
            *mask = ~0;
        } /* if (BCM_GPORT_IS_SET(data_port)) */
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* Convert from gport of type LIF to LIF-Id */
int
_bcm_dpp_field_gport_to_lif_convert(int unit,
                                    bcm_gport_t  lif_gport,
                                    uint8       is_inlif,
                                    uint32      *lif)
{
    int global_out_lif_id, global_in_lif_id;
    int result;
    _bcm_dpp_gport_hw_resources gport_hw_resources;

    BCMDNX_INIT_FUNC_DEFS;

    result = _bcm_dpp_gport_to_hw_resources(unit, lif_gport, _BCM_DPP_GPORT_HW_RESOURCES_GLOBAL_LIF_INGRESS|_BCM_DPP_GPORT_HW_RESOURCES_GLOBAL_LIF_EGRESS, &gport_hw_resources);
    global_in_lif_id = gport_hw_resources.global_in_lif;
    global_out_lif_id = gport_hw_resources.global_out_lif;

    *lif = (is_inlif) ? global_in_lif_id : global_out_lif_id;

    if ((BCM_E_NONE != result) || (*lif == _BCM_GPORT_ENCAP_ID_LIF_INVALID)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unable to compute lif for unit"
                              " %d GPORT %08X: %d (%s)\n"),
                   unit,
                   lif_gport,
                   result,
                   _SHR_ERRMSG(result)));
        BCMDNX_IF_ERR_EXIT(result);
    }


exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InPort
 *   Purpose
 *      Set allowed ingress port for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_port_t data = allowed port
 *      (in) bcm_port_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Supports GPORTs of various types and will map back to phys port.
 */
int
bcm_petra_field_qualify_InPort(int unit,
                               bcm_field_entry_t entry,
                               bcm_port_t data,
                               bcm_port_t mask)
{
    uint64 edata;
    uint64 emask;
    uint32 pp_port;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 
    int    core, nof_cores;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);

        if(data < 0 || data >= max_port)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Port value is out of range, "
                                       "Value is %d range is [0,255]\n"), 
                              data));
        }
        if ((0 != mask) && ((~0) != mask)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                       " bits set or all bits clear)")));
        }
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, data, &pp_port, &core)));

        COMPILER_64_SET(emask,0, 0x7);
        SHR_BITSET(port_bitmap[core], data);

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeInPort,
															   nof_cores,
                                                               port_bitmap,    
                                                               &edata));
    }
    else {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_qualify_pp_port_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      This version always returns local port, not GPORT, even thoguh the set
 *      function allows certain GPORT types.
 */
int
bcm_petra_field_qualify_InPort_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_port_t *data,
                                   bcm_port_t *mask)
{
    uint32 tdata;
    uint32 tmask;
    bcm_port_t port;
    uint32 
        port_id;
    _bcm_dpp_core_ports_bitmap_t  port_bitmap[MAX_NUM_OF_CORES];
    int    nof_cores, core; 
    uint32 pp_port;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);
	uint32 is_valid;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInPort,
                                                            &tdata,
                                                            &tmask));
    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeInPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        port = max_port;
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

			if (is_valid) {

				BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

				if(SHR_BITGET(port_bitmap[core], port_id) > 0) {
					if(port != max_port) {
						BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                     (_BSL_BCM_MSG("Presel was defined"
                                               " for multiple ports")));
					}
					port = port_id;
				}
            }
        }
    }
    else {
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_pp_to_local_port_get, (unit, tdata, 0, &port)));
    }

    *data = port;
    if (tmask) {
        *mask = (~0);
    } else {
        *mask = 0;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6FlowLabel
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIp6FlowLabel
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6FlowLabel(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIp6FlowLabel,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6FlowLabel_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIp6FlowLabel
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6FlowLabel_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyIp6FlowLabel,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OuterVlan
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VLAN tag (16 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM API docs neglect to metion that this function applies to the entire
 *      tag, rather than just the VID.
 */
int
bcm_petra_field_qualify_OuterVlan(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_vlan_t data,
                                  bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOuterVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlan_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_vlan_t *data,
                                      bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOuterVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OuterVlanId
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VID (12 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_OuterVlanId(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_vlan_t data,
                                    bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOuterVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlanId_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_vlan_t *data,
                                        bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOuterVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OuterVlanPri
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which Pri (3 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_OuterVlanPri(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanPri,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOuterVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlanPri_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOuterVlanPri,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieldQualifyOuterVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlanCfi(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOuterVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterVlanCfi_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOuterVlanCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlan
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerVlan
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlan(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_vlan_t data,
                                  bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlan_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_vlan_t *data,
                                      bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanId(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_vlan_t data,
                                    bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanId_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_vlan_t *data,
                                        bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanPri
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanPri(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlanPri,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanPri_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerVlanPri,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanCfi(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlanCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerVlanCfi_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerVlanCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4SrcPort
 * Purpose:
 *      Set match criteria for bcmFieldQualifyL4SrcPort
 *                     qualifier to the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4SrcPort(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_l4_port_t data,
                                  bcm_l4_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL4SrcPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL4SrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4SrcPort_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_l4_port_t *data,
                                      bcm_l4_port_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL4SrcPort,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4DstPort
 * Purpose:
 *      Set match criteria for bcmFieldQualifyL4DstPort
 *                     qualifier to the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4DstPort(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_l4_port_t data,
                                  bcm_l4_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL4DstPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL4DstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4DstPort_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_l4_port_t *data,
                                      bcm_l4_port_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL4DstPort,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_EtherType
 *   Purpose
 *      Set expected ethernet type for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint16 data = which ethertype
 *      (in) uint16 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_EtherType(int unit,
                                  bcm_field_entry_t entry,
                                  uint16 data,
                                  uint16 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyEtherType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_EtherType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEtherType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EtherType_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint16 *data,
                                      uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyEtherType,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_IpProtocol
 *   Purpose
 *      Set expected IPv4 protocol type type for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint16 data = which ethertype
 *      (in) uint16 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_IpProtocol(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpProtocol,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpProtocol_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpProtocol,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Ip6NextHeader(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIp6NextHeader,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6NextHeader_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIp6NextHeader
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6NextHeader_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIp6NextHeader,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_DSCP
 *   Purpose
 *      Set expected IPv4 DSCP for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint8 data = which DSCP
 *      (in) uint8 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_DSCP(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDSCP,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DSCP_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DSCP_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 *data,
                                 uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyDSCP,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_Tos
 *   Purpose
 *      Set expected IPv4 ToS for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint8 data = which ToS
 *      (in) uint8 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_Tos(int unit,
                            bcm_field_entry_t entry,
                            uint8 data,
                            uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Tos_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTos
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Tos_get(int unit,
                                bcm_field_entry_t entry,
                                uint8 *data,
                                uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Ip6TrafficClass(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 data,
                                         uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIp6TrafficClass,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6TrafficClass_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIp6TrafficClass
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6TrafficClass_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data,
                                            uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIp6TrafficClass,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Ttl(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTtl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ttl_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTtl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ttl_get(int unit,
                                bcm_field_entry_t entry,
                                uint8 *data,
                                uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTtl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6HopLimit
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIp6HopLimit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6HopLimit(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIp6HopLimit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ip6HopLimit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIp6HopLimit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ip6HopLimit_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 *data,
                                        uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIp6HopLimit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_TcpControl
 *   Purpose
 *      Set expected TCP control flags for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint8 data = which TCP control bits
 *      (in) uint8 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Also implies TCP as protocol.
 */
int
bcm_petra_field_qualify_TcpControl(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTcpControl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TcpControl_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTcpControl
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TcpControl_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTcpControl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_dpp_petra_field_entry_group_flags(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *group_flags)
{
    _bcm_dpp_field_info_t *unitData;
    _bcm_dpp_field_group_t *groupData;
    _bcm_dpp_field_grp_idx_t entryGroup;
    bcm_field_stage_t stage;
    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)) {

        BCMDNX_IF_ERR_EXIT(bcm_petra_field_qualify_Stage_get(unit, entry, &stage));
        *group_flags |= (stage == bcmFieldStageEgress) ? _BCM_DPP_FIELD_GROUP_EGRESS : _BCM_DPP_FIELD_GROUP_INGRESS;
    }
    else 
    {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_petra_field_entry_group(unit, entry, &entryGroup));

        groupData = &(unitData->groupD[entryGroup]);

        *group_flags = groupData->groupFlags;
    }

exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_ForwardingType(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_field_ForwardingType_t data)
{
    uint64 edata;
    uint64 emask;
    SOC_TMC_PKT_FRWRD_TYPE ppdForwardingType;
    uint32 group_flags = 0;
    uint8 is_ingress;
    uint32 ppdOffsetExtData = 0, ppdOffsetExtMask = 0, ppdMask = 0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_ingress = (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS)?1:0;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_forwarding_type_bcm_to_ppd(data, &ppdForwardingType, &ppdMask));
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "fp_restricted_forwarding_type", 0) == 0) {
        if (is_ingress) {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_offset_ext_bcm_to_ppd(data, &ppdOffsetExtData, &ppdOffsetExtMask));
        }
    }
    else {
        /* No need to set the forwarding extension */
        ppdOffsetExtMask = 0;
    }
    COMPILER_64_SET(edata, 0, ppdForwardingType + (ppdOffsetExtData << 4));
    COMPILER_64_SET(emask, 0, ppdMask + (ppdOffsetExtMask << 4)); /* 4 bits signal */


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardingType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardingType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match forwarding type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingType_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_field_ForwardingType_t *type)
{
    int32 ppd;
    bcm_field_ForwardingType_t bcm;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyForwardingType,
                                                           &ppd,
                                                           &emask));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_forwarding_type_ppd_to_bcm((ppd & 0xF), (emask & 0xF), &bcm));
    *type = bcmFieldForwardingTypeAny;
    if ((emask & 0xF)) {
        if (bcm == bcmFieldForwardingTypeMpls) {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_offset_ext_ppd_to_bcm(((ppd >> 4) & 0x3), ((emask >> 4) & 0x3), &bcm));
        }
        *type = bcm;
    }


exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Vrf(int unit,
                            bcm_field_entry_t entry,
                            uint32 data,
                            uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVrf,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Vrf_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVrf
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Vrf_get(int unit,
                                bcm_field_entry_t entry,
                                uint32 *data,
                                uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyVrf,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanFormat
 * Purpose:
 *       Set match criteria for bcmFieldQualifyVlanFormat
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanFormat(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{
    uint64 edata;
    uint64 emask;
    uint8 is_egress;
    uint32 group_flags = 0;
    SOC_SAND_PP_ETHERNET_FRAME_VLAN_FORMAT ppdVlanFormat;

    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)?1:0;

    /* The value of  the 4-bit VLAN-Tag-format is controlled by user in API in advanced vlan-translation mode */
    if (is_egress || SOC_DPP_IS_VLAN_TRANSLATE_MODE_ADVANCED(unit)) {
        COMPILER_64_SET(edata, 0, data);
        COMPILER_64_SET(emask, 0, mask);
    } else {
        if ((0 != mask) && (0x15 != (mask & 0x15))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                       " bits set or all bits clear clear)")));
        }
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_vlan_format_bcm_to_ppd(data, &ppdVlanFormat));

        COMPILER_64_SET(edata, 0, ppdVlanFormat);
        if (mask) {
            COMPILER_64_SET(emask, ~0, ~0);
        } else {
            COMPILER_64_ZERO(emask);
        }
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVlanFormat,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanFormat_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyVlanFormat
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanFormat_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{
    int32 ppd;
    uint8 bcm;
    int32 emask;
    uint8 is_egress;
    uint32 group_flags = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyVlanFormat,
                                                           &ppd,
                                                           &emask));
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)?1:0;

    /* The value of  the 4-bit VLAN-Tag-format is controlled by user in API in advanced vlan-translation mode */
    if (is_egress || SOC_DPP_IS_VLAN_TRANSLATE_MODE_ADVANCED(unit)) {
        *data = ppd;
        *mask = emask;
    } else {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_vlan_format_ppd_to_bcm(ppd, &bcm));
        *data = bcm;
        *mask = emask? 0x15:0;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerSrcIp(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip_t data,
                                   bcm_ip_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerSrcIp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerSrcIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip_t *data,
                                       bcm_ip_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerSrcIp,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerDstIp(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip_t data,
                                   bcm_ip_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerDstIp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip_t *data,
                                       bcm_ip_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerDstIp,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerTos(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerTos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTos_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTos_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerTos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerDSCP(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerDSCP,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDSCP_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDSCP
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDSCP_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data,
                                      uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerDSCP,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerIpProtocol(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data,
                                        uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerIpProtocol,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIpProtocol_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerIpProtocol
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIpProtocol_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data,
                                            uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerIpProtocol,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IngressStpState(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data,
                                        uint8 mask)
{
    uint64 edata;
    uint64 emask;
    SOC_PPC_PORT_STP_STATE_FLD_VAL state;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if ((0 != mask) && (0x7 != (mask & 0x7))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                   " bits set or all bits clear clear)")));
    }
    if (mask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stp_state_bcm_to_ppd(data, &state));
        COMPILER_64_SET(edata, 0, state);
        COMPILER_64_SET(emask, ~0, ~0);
    } else {
        COMPILER_64_ZERO(edata);
        COMPILER_64_ZERO(emask);
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIngressStpState,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IngressStpState_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIngressStpState
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IngressStpState_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data,
                                            uint8 *mask)
{
    int32 ppd;
    bcm_stg_stp_t bcm;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIngressStpState,
                                                           &ppd,
                                                           &emask));
    if(emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stp_state_ppd_to_bcm(ppd, &bcm));
        *data = bcm;
        *mask = 0x7;
    } else {
        *data = 0;
        *mask = 0;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerL4SrcPort(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_l4_port_t data,
                                       bcm_l4_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerL4SrcPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerL4SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerL4SrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerL4SrcPort_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_l4_port_t *data,
                                           bcm_l4_port_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerL4SrcPort,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerL4DstPort(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_l4_port_t data,
                                       bcm_l4_port_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerL4DstPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerL4DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerL4DstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerL4DstPort_get(int unit,
                                           bcm_field_entry_t entry,
                                           bcm_l4_port_t *data,
                                           bcm_l4_port_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerL4DstPort,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Color
 * Purpose:
 *      Set match criteria for bcmFieldQualifyColor
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      color - (IN) Qualifier match color.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Color(int unit,
                              bcm_field_entry_t entry,
                              uint8 color)
{
    uint64 edata;
    uint64 emask;
    uint32 ppdCol;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_color_bcm_to_ppd(color, &ppdCol));
    COMPILER_64_SET(edata, 0, ppdCol);
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyColor,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Color_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyColor
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      color - (OUT) Qualifier match color.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Color_get(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 *color)
{
    int32 temp;
    int32 mask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyColor,
                                                           &temp,
                                                           &mask));
    if (mask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_color_ppd_to_bcm(temp,
                                                        &mask));
        *color = mask;
    }
    else {
        *color = -1;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IntPriority
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIntPriority
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IntPriority(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIntPriority,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IntPriority_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIntPriority
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IntPriority_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 *data,
                                        uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIntPriority,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingVlanId
 * Purpose:
 *      Set match criteria for bcmFieldQualifyForwardingVlanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingVlanId(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_vlan_t data,
                                         bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardingVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyForwardingVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingVlanId_get(int unit,
                                             bcm_field_entry_t entry,
                                             bcm_vlan_t *data,
                                             bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyForwardingVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/* 
 * Function:
 *      bcm_petra_field_qualify_ForwardHdrVlanId
 * Purpose:
 *      Set match criteria for bcmFieldQualifyForwardHdrVlanId
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardHdrVlanId(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_vlan_t data,
                                         bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardHdrVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardHdrVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyForwardHdrVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardHdrVlanId_get(int unit,
                                             bcm_field_entry_t entry,
                                             bcm_vlan_t *data,
                                             bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyForwardHdrVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Vpn
 * Purpose:
 *      Set match criteria for bcmFieldQualifyVpn
 *      qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Vpn(int unit,
                            bcm_field_entry_t entry,
                            bcm_vpn_t data,
                            bcm_vpn_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVpn,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Vpn_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyVpn
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Vpn_get(int unit,
                                bcm_field_entry_t entry,
                                bcm_vpn_t *data,
                                bcm_vpn_t *mask)
{
    int32 edata;
    int32 emask;
    int result;

    BCMDNX_INIT_FUNC_DEFS;

    result = _bcm_dpp_field_entry_qualify_int32_get(unit,
                                                    entry,
                                                    bcmFieldQualifyVpn,
                                                    &edata,
                                                    &emask);
    if (BCM_E_NONE == result) {
        *data = edata;
        *mask = emask;
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabel(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 data,
                                            uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabel,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabel_get(int unit,
                                                bcm_field_entry_t entry,
                                                uint32 *data,
                                                uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsForwardingLabel,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelTtl(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelTtl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelTtl_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsForwardingLabelTtl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelBos(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelBos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelBos_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsForwardingLabelBos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelExp(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelExp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsForwardingLabelExp_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsForwardingLabelExp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_create_id
 *   Purpose
 *      Create a statistics set with a specific ID
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group number
 *      (in) int nstat = number of statistics requested
 *      (in) bcm_field_stat_t *stat_arr = array of statistics requested
 *      (in) int stat_id = statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      See description of _bcm_petra_field_stat_create.
 */
int
bcm_petra_field_stat_create_id(int unit,
                               bcm_field_group_t group,
                               int nstat,
                               bcm_field_stat_t *stat_arr,
                               int stat_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stat_create(unit,
                                               TRUE,
                                               group,
                                               nstat,
                                               stat_arr,
                                               &stat_id));
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_create
 *   Purpose
 *      Create a statistics set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = the group number
 *      (in) int nstat = number of statistics requested
 *      (in) bcm_field_stat_t *stat_arr = array of statistics requested
 *      (out) int *stat_id = where to put statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      See description of _bcm_petra_field_stat_create.
 */
int
bcm_petra_field_stat_create(int unit,
                             bcm_field_group_t group,
                             int nstat,
                             bcm_field_stat_t *stat_arr,
                             int *stat_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_stat_create(unit,
                                               FALSE,
                                               group,
                                               nstat,
                                               stat_arr,
                                               stat_id));
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_destroy
 *   Purpose
 *      Destroy a statistics set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 */
int
bcm_petra_field_stat_destroy(int unit,
                             int stat_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X) enter\n"), unit, stat_id));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    result = _bcm_dpp_proc_cntr_from_stat(unitData, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);

    _DPP_FIELD_UNIT_LOCK(unitData);

    result = bcm_dpp_counter_free(unit, proc, cntr);
    if (BCM_E_NONE != result) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unable to free unit %d proc %u set %u:"
                              " %d (%s)\n"),
                   unit,
                   proc,
                   cntr,
                   result,
                   _SHR_ERRMSG(result)));
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X) return %d (%s)\n"),
               unit,
               stat_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_stat_attach
 *   Purpose
 *      Attach a statistics set to an entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry number
 *      (in) int stat_id = statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      A single statistics set can be attached to a number of entries, but all
 *      of them must be in the group for which the statistics set was created.
 *
 *      This only supports bcmFieldActionStat as the statistics action;
 *      application must use bcm_field_action_{set|get|delete|remove} to
 *      support more than one statistics action on an entry.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_stat_attach(int unit,
                                  bcm_field_entry_t entry,
                                  int stat_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint32 param0;
    uint32 param1;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%08X) enter\n"), unit, entry, stat_id));
    _BCM_DPP_SWITCH_API_START(unit);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!(_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d is not valid for this function"),
                          entry));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);

    if (SOC_IS_ARAD(unit))
    {
        _bcm_dpp_field_group_t *groupData = &(unitData->groupD[_BCM_DPP_FIELD_TCAM_ENTRY_GROUP(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry),
                                                                                                _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry))]);
        if (groupData->groupFlags & _BCM_DPP_FIELD_GROUP_EGRESS) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                             (_BSL_BCM_MSG("bcm_petra_field_entry_stat_attach "
                                       "is only supported for Ingress")));
        }
    }

    if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry))
               & _BCM_DPP_FIELD_ENTRY_IN_USE)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not in use\n"),
                   unit,
                   entry));
        result = BCM_E_NOT_FOUND;
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                      bcmFieldActionStat,
                                                      &param0,
                                                      &param1);
        if (BCM_E_NONE == result) {
            /* already has stat action */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d already has stats %08X;"
                                  " must remove existing stats before"
                                  " replacing\n"),
                       unit,
                       entry,
                       param0));
            result = BCM_E_EXISTS;
        } else if (BCM_E_NOT_FOUND == result) {
            /* does not have stat action, so this is the okay condition */
            result = BCM_E_NONE;
        }
        /* but anything else is an error and left untouched */
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_tcam_entry_action_set(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                      bcmFieldActionStat,
                                                      stat_id,
                                                      0);
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%08X) return %d (%s)\n"),
               unit,
               entry,
               stat_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_stat_detach
 *   Purpose
 *      Detach a statistics set from an entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry number
 *      (in) int stat_id = statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      A single statistics set can be attached to a number of entries, but all
 *      of them must be in the group for which the statistics set was created.
 *
 *      This only supports bcmFieldActionStat as the statistics action;
 *      application must use bcm_field_action_{set|get|delete|remove} to
 *      support more than one statistics action on an entry.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_stat_detach(int unit,
                                  bcm_field_entry_t entry,
                                  int stat_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint32 lparam0;
    uint32 lparam1;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%08X) enter\n"),
               unit,
               entry,
               stat_id));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!(_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d is not valid for this function"),
                          entry));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);

    /* get the action of this sort */
    result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                  _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                  _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                  bcmFieldActionStat,
                                                  &lparam0,
                                                  &lparam1);
    if (BCM_E_NONE == result) {
        /* there is a stat action */
        if (lparam0 == stat_id) {
            /* entry's stat is the one we want to detach */
            result = _bcm_dpp_field_tcam_entry_action_clear(unitData,
                                                            _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry), 
                                                            _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry),
                                                            bcmFieldActionStat);
        } else {
            /* entry's stat is not the one we want to detach */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d can not detach stat %08X"
                                  " because stat %08X is attached instead\n"),
                       unit,
                       entry,
                       stat_id,
                       lparam0));
            result = BCM_E_PARAM;
        }
    } else if (BCM_E_NOT_FOUND == result) {
        /* there is no stat action on this entry */
        result = BCM_E_EMPTY;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%08X) return %d (%s)\n"),
               unit,
               entry,
               stat_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_stat_get
 *   Purpose
 *      Get the statistics set that is attached to an entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry number
 *      (out) int *stat_id = where to put the statistics ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      This only supports bcmFieldActionStat as the statistics action;
 *      application must use bcm_field_action_{set|get|delete|remove} to
 *      support more than one statistics action on an entry.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_stat_get(int unit,
                               bcm_field_entry_t entry,
                               int *stat_id)
{
    int result;
    uint32 param0;
    uint32 param1;

    BCMDNX_INIT_FUNC_DEFS;
    result = bcm_petra_field_action_get(unit,
                                        entry,
                                        bcmFieldActionStat,
                                        &param0,
                                        &param1);
    if (BCM_E_NONE == result) {
        *stat_id = param0;
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_config_get
 *   Purpose
 *      Get the specific statistics supported by a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) int nstat = number of elements in stat_arr
 *      (out) bcm_field_stat_t *stat_arr = where to put list of stats
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Returns actual capabilities of stats on the counter processor for the
 *      specified stat_id, instead of tracking the 'requested' stats.
 */
int
bcm_petra_field_stat_config_get(int unit,
                                int stat_id,
                                int nstat,
                                bcm_field_stat_t *stat_arr)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    unsigned int count;
    unsigned int index;
    bcm_dpp_counter_set_t avail;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) enter\n"), unit, stat_id, nstat));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    result = _bcm_dpp_proc_cntr_from_stat(unitData, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);


    if (0 > nstat) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("umber of stats %d must be non-negative"),
                          nstat));
    }
    if (nstat && (!stat_arr)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT arg must not be NULL")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = bcm_dpp_counter_avail_get(unit, proc, &avail, NULL);
    if (BCM_E_NONE == result) {
        for (count = 0, index = 0;
             (index < bcm_dpp_counter_count) &&
             (count < nstat);
             index++) {
            if (SHR_BITGET(avail, index)) {
                if (BCM_E_NONE ==
                    _bcm_dpp_field_stat_unmap(index, &(stat_arr[count]))) {
                    count++;
                }
            }
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) return %d (%s)\n"),
               unit,
               stat_id,
               nstat,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_size
 *   Purpose
 *      Get the number of statistics in a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (out) int *stat_size = where to put number of supported stats
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Returns actual capabilities of stats on the counter processor for the
 *      specified stat_id, instead of tracking the 'requested' stats.
 */
int
bcm_petra_field_stat_size(int unit,
                          int stat_id,
                          int *stat_size)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    int count;
    unsigned int index;
    bcm_dpp_counter_set_t avail;
    bcm_field_stat_t stat;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,*) enter\n"), unit, stat_id));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!stat_size) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT arg must not be NULL")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);

    result = _bcm_dpp_proc_cntr_from_stat(unitData, stat_id, &proc, &cntr);

    result = bcm_dpp_counter_avail_get(unit, proc, &avail, NULL);
    if (BCM_E_NONE == result) {
        for (count = 0, index = 0;
             index < bcm_dpp_counter_count;
             index++) {
            if (SHR_BITGET(avail, index)) {
                if (BCM_E_NONE ==
                    _bcm_dpp_field_stat_unmap(index, &stat)) {
                    count++;
                }
            }
        }
    }
    if (BCM_E_NONE == result) {
        *stat_size = count;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,&(%d)) return %d (%s)\n"),
               unit,
               stat_id,
               *stat_size,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_get
 *   Purpose
 *      Read a specific statistic from a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (out) uint64 *value = where to put the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 */
int
bcm_petra_field_stat_get(int unit,
                         int stat_id,
                         bcm_field_stat_t stat,
                         uint64 *value)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%s,*) enter\n"),
               unit,
               stat_id,
               ((0 <= stat) && (stat < bcmFieldStatCount))?_bcm_dpp_field_stats_names[stat]:"???"));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!value) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT arg must not be NULL")));
    }
    result = _bcm_dpp_proc_cntr_from_stat(unitData, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);


    if ((0 > stat) || (bcmFieldStatCount <= stat)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid statistic %d"), stat));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_stat_access_single(unitData,
                                               stat_id,
                                               proc,
                                               cntr,
                                               stat,
                                               FALSE,
                                               value);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%s,&(%08X%08X)) return %d (%s)\n"),
               unit,
               stat_id,
               ((0 <= stat) && (stat < bcmFieldStatCount))?_bcm_dpp_field_stats_names[stat]:"???",
               COMPILER_64_HI(*value),
               COMPILER_64_LO(*value),
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
   BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_get32
 *   Purpose
 *      Read a specific statistic from a set (32b)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (out) uint32 *value = where to put the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 *
 *      Saturates the returned value if actual is too large.
 */
int
bcm_petra_field_stat_get32(int unit,
                           int stat_id,
                           bcm_field_stat_t stat,
                           uint32 *value)
{
    uint64 temp, temp1;
    int result;

    BCMDNX_INIT_FUNC_DEFS;
    result = bcm_petra_field_stat_get(unit, stat_id, stat, &temp);
    if (BCM_E_NONE == result) {
        COMPILER_64_SET(temp1, 0xFFFFFFFF, 0xFFFFFFFF);
        if (COMPILER_64_LT(temp , temp1)) {
            COMPILER_64_TO_32_LO(*value, temp);
        } else {
            *value = 0xFFFFFFFF;
        }
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_multi_get
 *   Purpose
 *      Read a number of statistics from a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) int nstat = number of statistics to get
 *      (in) bcm_field_stat_t *stat_Arr = which statistics to get
 *      (out) uint64 *value_arr = where to put the values
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 */
int
bcm_petra_field_stat_multi_get(int unit,
                               int stat_id,
                               int nstat,
                               /* const */ bcm_field_stat_t *stat_arr,
                               uint64 *value_arr)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    unsigned int index;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) enter\n"),
               unit,
               stat_id,
               nstat));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (0 > nstat) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("nstat must not be negative")));
    }
    if (nstat && (!stat_arr)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("stat_arr must not be NULL if nstat > 0")));
    }
    if (nstat && (!value_arr)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("value_arr must not be NULL if nstat > 0")));
    }
    result = _bcm_dpp_proc_cntr_from_stat(unitData, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);

    _DPP_FIELD_UNIT_LOCK(unitData);
    for (index = 0, result = BCM_E_NONE;
         (index < nstat) && (BCM_E_NONE == result);
         index++) {
        if ((0 > stat_arr[index]) ||
            (bcmFieldStatCount <= stat_arr[index])) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "invalid statistic %d\n"),
                       stat_arr[index]));
            result = BCM_E_PARAM;
        } else {
            result = _bcm_dpp_field_stat_access_single(unitData,
                                                       stat_id,
                                                       proc,
                                                       cntr,
                                                       stat_arr[index],
                                                       FALSE,
                                                       &(value_arr[index]));
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) return %d (%s)\n"),
               unit,
               stat_id,
               nstat,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_multi_get32
 *   Purpose
 *      Read a number of statistics from a set (32b)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) int nstat = number of statistics to get
 *      (in) bcm_field_stat_t *stat_Arr = which statistics to get
 *      (in) int nvalue = number of places for values
 *      (out) uint32 *value_arr = where to put the values
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 *
 *      Saturates the returned values if actual are too large.
 */
int
bcm_petra_field_stat_multi_get32(int unit,
                                  int stat_id,
                                  int nstat,
                                  bcm_field_stat_t *stat_arr,
                                  uint32 *value_arr)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    unsigned int index;
    uint64 temp, temp1;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) enter\n"),
               unit,
               stat_id,
               nstat));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (0 > nstat) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("nstat must not be negative")));
    }
    if (nstat && (!stat_arr)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("stat_arr must not be NULL if nstat > 0")));
    }
    if (!value_arr) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("value_arr must not be NULL")));
    }

    result = _bcm_dpp_proc_cntr_from_stat(unitData, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);


    _DPP_FIELD_UNIT_LOCK(unitData);
    for (index = 0, result = BCM_E_NONE;
         (index < nstat) && (BCM_E_NONE == result);
         index++) {
        if ((0 > stat_arr[index]) ||
            (bcmFieldStatCount <= stat_arr[index])) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "invalid statistic %d\n"),
                       stat_arr[index]));
            result = BCM_E_PARAM;
        } else {
            result = _bcm_dpp_field_stat_access_single(unitData,
                                                       stat_id,
                                                       proc,
                                                       cntr,
                                                       stat_arr[index],
                                                       FALSE,
                                                       &temp);
        }
        if (BCM_E_NONE == result) {
            COMPILER_64_SET(temp1,0xFFFFFFFF,0xFFFFFFFF);
            if (COMPILER_64_LT(temp ,temp1)) {
                COMPILER_64_TO_32_LO(value_arr[index], temp);
            } else {
                value_arr[index] = 0xFFFFFFFF;
            }
        }
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%d,*) return %d (%s)\n"),
               unit,
               stat_id,
               nstat,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_set
 *   Purpose
 *      Set a specific statistic in a set
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (in) uint64 value = the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 */
int
bcm_petra_field_stat_set(int unit,
                         int stat_id,
                         bcm_field_stat_t stat,
                         uint64 value)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%s,%08X%08X) enter\n"),
               unit,
               stat_id,
               ((0 <= stat) && (stat < bcmFieldStatCount))?_bcm_dpp_field_stats_names[stat]:"???",
               COMPILER_64_HI(value),
               COMPILER_64_LO(value)));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    result = _bcm_dpp_proc_cntr_from_stat(unitData, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);

    if ((0 > stat) || (bcmFieldStatCount <= stat)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid statistic %d"), stat));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = _bcm_dpp_field_stat_access_single(unitData,
                                               stat_id,
                                               proc,
                                               cntr,
                                               stat,
                                               TRUE,
                                               &value);

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%s,%08X%08X) return %d (%s)\n"),
               unit,
               stat_id,
               ((0 <= stat) && (stat < bcmFieldStatCount))?_bcm_dpp_field_stats_names[stat]:"???",
               COMPILER_64_HI(value),
               COMPILER_64_LO(value),
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_set32
 *   Purpose
 *      Set a specific statistic in a set (32b)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) bcm_field_stat_t stat = which statistic to get
 *      (in) uint32 value = the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Can access any statistic supported by the set, not just the one(s)
 *      requested when the set was created.
 *
 *      Upper 32b of the statistic will be zero after the write.
 */
int
bcm_petra_field_stat_set32(int unit,
                           int stat_id,
                           bcm_field_stat_t stat,
                           uint32 value)
{
    uint64 temp;

    BCMDNX_INIT_FUNC_DEFS;
    COMPILER_64_SET(temp, 0, value);
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(bcm_petra_field_stat_set(unit, stat_id, stat, temp));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_all_set
 *   Purpose
 *      Set all statistics in a set (to the same value)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) uint64 value = the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Note the 'get' version has something that individually retrieves the
 *      member statistics from a set, but this writes the same value to all.
 *
 *      This only sets values for 'native' statistics.  All statistics derived
 *      from the native statistics will have their relative derivations left
 *      unaffected (so, for example, if the hardware has native support for
 *      red and green and blue, and emulated support for all, the value will be
 *      written to each of red and green and blue, causing the emulated all
 *      counter to contain red+gree+blue, or 3 * the written value).
 *
 *      Probably this function has little real use outside of clearing, where
 *      zero is written to all counters.  In this special case, the native
 *      counters being cleared will also implicitly clear the emulated ones.
 */
int
bcm_petra_field_stat_all_set(int unit,
                             int stat_id,
                             uint64 value)
{
    _DPP_FIELD_COMMON_LOCALS;
    unsigned int proc;
    unsigned int cntr;
    unsigned int index;
    bcm_dpp_counter_set_t native;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%08X%08X) enter\n"),
               unit,
               stat_id,
               COMPILER_64_HI(value),
               COMPILER_64_LO(value)));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    result = _bcm_dpp_proc_cntr_from_stat(unitData, stat_id, &proc, &cntr);
    BCMDNX_IF_ERR_EXIT(result);

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = bcm_dpp_counter_avail_get(unit, proc, NULL, &native);
    for (index = 0;
         (BCM_E_NONE == result) && (index < bcm_dpp_counter_count);
         index++) {
        if (SHR_BITGET(native, index)) {
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
            if (unitData->unitFlags & _BCM_DPP_FIELD_UNIT_STAT_CACHED) {
                result = bcm_dpp_counter_set_cached(unit, proc, cntr, index, value);
            } else {
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
                result = bcm_dpp_counter_set(unit, proc, cntr, index, value);
#if _BCM_PETRA_ALLOW_CACHED_STAT_WRITE
            }
#endif /* _BCM_PETRA_ALLOW_CACHED_STAT_WRITE */
        } /* if (SHR_BITGET(native, index)) */
    } /* for (all counters as long as no error) */

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%08X,%08X%08X) return %d (%s)\n"),
               unit,
               stat_id,
               COMPILER_64_HI(value),
               COMPILER_64_LO(value),
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_stat_all_set32
 *   Purpose
 *      Set all statistics in a set (to the same 32b value)
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) int stat_id = the statistics ID
 *      (in) uint32 value = the value
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Note the 'get' version has something that individually retrieves the
 *      member statistics from a set, but this writes the same value to all.
 *
 *      This only sets values for 'native' statistics.  All statistics derived
 *      from the native statistics will have their relative derivations left
 *      unaffected (so, for example, if the hardware has native support for
 *      red and green and blue, and emulated support for all, the value will be
 *      written to each of red and green and blue, causing the emulated all
 *      counter to contain red+gree+blue, or 3 * the written value).
 *
 *      Probably this function has little real use outside of clearing, where
 *      zero is written to all counters.  In this special case, the native
 *      counters being cleared will also implicitly clear the emulated ones.
 */
int
bcm_petra_field_stat_all_set32(int unit,
                               int stat_id,
                               uint32 value)
{
    uint64 temp;

    BCMDNX_INIT_FUNC_DEFS;
    COMPILER_64_SET(temp, 0, value);
    BCMDNX_IF_ERR_EXIT(bcm_petra_field_stat_all_set(unit, stat_id, temp));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_policer_attach
 *   Purpose
 *      Attach a policer to a specified entry, at the given heirarchical level
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) int level = level (for heirarchical policing)
 *      (in) bcm_policer_t policer = which policer to attach to the entry
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Policers are managed through the bcm_policer_* APIs.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_policer_attach(int unit,
                                      bcm_field_entry_t entry_id,
                                      int level,
                                      bcm_policer_t policer_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint32 param0;
    uint32 param1;

    BCMDNX_INIT_FUNC_DEFS;
    _BCM_DPP_SWITCH_API_START(unit);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d,%08X) enter\n"),
               unit,
               entry_id,
               level,
               policer_id));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!(_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry_id))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d is not valid for this function"),
                          entry_id));
    }
    if ((0 > level) || (1 < level)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid policer level %d"),
                          level));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id)) 
              & _BCM_DPP_FIELD_ENTRY_IN_USE)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not in use\n"),
                   unit,
                   entry_id));
        result = BCM_E_NOT_FOUND;
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_tcam_entry_action_get(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), 
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id),
                                                      level?
                                                      bcmFieldActionPolicerLevel1:
                                                      bcmFieldActionPolicerLevel0,
                                                      &param0,
                                                      &param1);
        if (BCM_E_NONE == result) {
            /* already has stat action */
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d entry %d already has policer %08X"
                                  " at level %d; must remove existing policer"
                                  " before replacing\n"),
                       unit,
                       entry_id,
                       level,
                       param0));
            result = BCM_E_EXISTS;
        } else if (BCM_E_NOT_FOUND == result) {
            /* does not have stat action, so this is the okay condition */
            result = BCM_E_NONE;
        }
        /* but anything else is an error and left untouched */
    }
    if (BCM_E_NONE == result) {
        result = _bcm_dpp_field_tcam_entry_action_set(unitData,
                                                      _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), 
                                                      _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id),
                                                      level?
                                                      bcmFieldActionPolicerLevel1:
                                                      bcmFieldActionPolicerLevel0,
                                                      policer_id,
                                                      0);
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d,%d,%08X) return %d (%s)\n"),
               unit,
               entry_id,
               level,
               policer_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_policer_detach
 *   Purpose
 *      Remove the policer used by the specified entry at the given level
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) int level = level (for heirarchical policing)
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Policers are managed through the bcm_policer_* APIs.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_policer_detach(int unit,
                                      bcm_field_entry_t entry_id,
                                      int level)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    if ((0 > level) || (1 < level)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("level %d is not valid"),
                          level));
    }
    BCMDNX_IF_ERR_EXIT(bcm_petra_field_action_remove(unit,
                                                  entry_id,
                                                  level?
                                                  bcmFieldActionPolicerLevel1:
                                                  bcmFieldActionPolicerLevel0));
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_entry_policer_detach_all
 *   Purpose
 *      Remove all policers used by the specified entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Does not return an error if a level has no policer.
 *
 *      Policers are managed through the bcm_policer_* APIs.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_policer_detach_all(int unit,
                                          bcm_field_entry_t entry_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    int index;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) enter\n"),
               unit,
               entry_id));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!(_BCM_DPP_FIELD_ENT_IS_TCAM(unit, entry_id))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d is not valid for this function"),
                          entry_id));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (0 == (_BCM_DPP_FIELD_TCAM_ENTRY_FLAGS(_BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id)) &
              _BCM_DPP_FIELD_ENTRY_IN_USE)) {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d entry %d is not in use\n"),
                   unit,
                   entry_id));
        result = BCM_E_NOT_FOUND;
    } else { /* if (entry is not in use) */
        for (index = 0;
             (BCM_E_NONE == result) && (index < 2);
             index++) {
            result = _bcm_dpp_field_tcam_entry_action_clear(unitData,
                                                            _BCM_DPP_FIELD_ENT_IS_EXTTCAM(unit, entry_id), 
                                                            _BCM_DPP_FIELD_TCAM_LOCAL_ID(unit, entry_id),
                                                            index?
                                                            bcmFieldActionPolicerLevel1:
                                                            bcmFieldActionPolicerLevel0);
            if ((BCM_E_NOT_FOUND == result) ||
                (BCM_E_CONFIG == result) ||
                (BCM_E_UNAVAIL == result)) {
                /*
                 *  For BCM_E_NOT_FOUND, we know the entry exists but policer
                 *  action was not found, but this should not result in an error
                 *  from this function.
                 *
                 *  For BCM_E_CONFIG, this occurs if the group does not have
                 *  the policer specified in its ASET, so safe to say the entry
                 *  does not have this policer.
                 *
                 *  For BCM_E_UNAVAIL, this occurs if the unit does not support
                 *  this policer on this stage, so safe to say the entry does not
                 *  have this policer.
                 */
                result = BCM_E_NONE;
            }
        } /* for (all supported policer 'levels') */
    } /* if (entry is not in use) */

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%d) return %d (%s)\n"),
               unit,
               entry_id,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_policer_get
 *   Purpose
 *      Get the policer used by the specified entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (out) bcm_policer_t *policer = where to put the policer ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Policers are managed through the bcm_policer_* APIs.
 *
 *      Only supported for TCAM entries on DPP.
 */
int
bcm_petra_field_entry_policer_get(int unit,
                                   bcm_field_entry_t entry_id,
                                   int level,
                                   bcm_policer_t *policer_id)
{
    int result;
    uint32 param0;
    uint32 param1;

    BCMDNX_INIT_FUNC_DEFS;
    if ((0 > level) || (1 < level)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("level %d is not valid"),
                          level));
    }
    result = bcm_petra_field_action_get(unit,
                                        entry_id,
                                        level?
                                        bcmFieldActionPolicerLevel1:
                                        bcmFieldActionPolicerLevel0,
                                        &param0,
                                        &param1);
    if (BCM_E_NONE == result) {
        *policer_id = param0;
    }
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_control_get
 *   Purpose
 *      Get the value of a unit-wide field control.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_control_t control = the control to be read
 *      (out) uint32 *state = pointer to where to put the state
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_control_get(int unit,
                             bcm_field_control_t control,
                             uint32 *state)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,*) enter\n"),
               unit,
               ((0 <= control) && (bcmFieldControlCount > control))?_bcm_dpp_field_control_names[control]:"???"));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > control) || (bcmFieldControlCount <= control)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid field control %d"), control));
    }
    if (!state) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT arg must not be NULL")));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = BCM_E_NONE;
    switch (control) {
    case bcmFieldControlStatSyncEnable:
        /* allow control over whether using 'cached' or 'direct' stats */
        *state = !(unitData->unitFlags & _BCM_DPP_FIELD_UNIT_STAT_CACHED);
        break;
    case bcmFieldControlCascadedKeyWidth:
        /* just get the cached copy */
        *state = unitData->cascadedKeyLen;
        break;
    default:
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d unsupported field control %s\n"),
                   unit,
                   _bcm_dpp_field_control_names[control]));
        result = BCM_E_UNAVAIL;
    }
    _DPP_FIELD_UNIT_UNLOCK(unitData);

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,&(%08X)) return %d (%s)\n"),
               unit,
               ((0 <= control) && (bcmFieldControlCount > control))?_bcm_dpp_field_control_names[control]:"???",
               *state,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_control_set
 *   Purpose
 *      Set the status of the field APIs.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_control_t control = the control to be written
 *      (in) uint32 *state = new state
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_control_set(int unit,
                             bcm_field_control_t control,
                             uint32 state)
{
    _DPP_FIELD_COMMON_LOCALS;
    SOC_PPD_FP_CONTROL_INDEX control_ndx;
    SOC_PPD_FP_CONTROL_INFO control_info;
    uint32 soc_sand_rv;
    uint32 success;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,%08X) enter\n"),
               unit,
               ((0 <= control) && (bcmFieldControlCount > control))?_bcm_dpp_field_control_names[control]:"???",
               state));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > control) || (bcmFieldControlCount <= control)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("invalid field control %d"), control));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);
    result = BCM_E_NONE;
    switch (control) {
    case bcmFieldControlStatSyncEnable:
        /* allow control over whether using 'cached' or 'direct' stats */
        if (state) {
            unitData->unitFlags &= (~_BCM_DPP_FIELD_UNIT_STAT_CACHED);
        } else {
            unitData->unitFlags |= _BCM_DPP_FIELD_UNIT_STAT_CACHED;
        }
#ifdef BCM_WARM_BOOT_SUPPORT
        _bcm_dpp_field_unit_wb_save(unitData, NULL, NULL);
#endif /* def BCM_WARM_BOOT_SUPPORT */
        break;
    case bcmFieldControlCascadedKeyWidth:
        SOC_PPD_FP_CONTROL_INDEX_clear(&control_ndx);
        SOC_PPD_FP_CONTROL_INFO_clear(&control_info);
        control_ndx.type = SOC_PPD_FP_CONTROL_TYPE_KEY_CHANGE_SIZE;
        control_ndx.val_ndx = 0;
        control_info.val[0] = state;
        if ((0 >= state) || (unitData->devInfo->cascadeKeyLimit < state)) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d only supports %s values in the"
                                  " range 1..%u\n"),
                       unit,
                       _bcm_dpp_field_control_names[control],
                       unitData->devInfo->cascadeKeyLimit));
            result = BCM_E_PARAM;
        }
        if (unitData->groupCascaded) {
            LOG_ERROR(BSL_LS_BCM_FP,
                      (BSL_META_U(unit,
                                  "unit %d requires %s be set before any"
                                  " groups use the cascading features\n"),
                       unit,
                       _bcm_dpp_field_control_names[control]));
            result = BCM_E_CONFIG;
        }
        if (BCM_E_NONE == result) {
            soc_sand_rv = soc_ppd_fp_control_set(unitData->unitHandle,
                                                 SOC_CORE_INVALID,
                                                 &control_ndx,
                                                 &control_info,
                                                 &success);
            result = handle_sand_result(soc_sand_rv);
            if (BCM_E_NONE == result) {
                result = translate_sand_success_failure(success);
            }
            if (BCM_E_NONE == result) {
                unitData->cascadedKeyLen = state;
            }
        }
        break;
    
    case bcmFieldControlExternalUdfEnable:
    case bcmFieldControlIntraDoubleEnable:
        break;
    default:
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d unsupported field control %s\n"),
                   unit,
                   _bcm_dpp_field_control_names[control]));
        result = BCM_E_UNAVAIL;
    }
    _DPP_FIELD_UNIT_UNLOCK(unitData);

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d,%s,%08X) return %d (%s)\n"),
               unit,
               ((0 <= control) && (bcmFieldControlCount > control))?_bcm_dpp_field_control_names[control]:"???",
               state,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_stage_info_get
 * Purpose:
 *     Get field information 
 * Parameters:
 *      unit - (IN) Unit number.
 *      stage - (IN) field stage.
 *      info - (OUT) field information .
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_stage_info_get(
        int unit, 
        bcm_field_stage_t      stage,
        bcm_field_stage_info_t *info) 
{
    _DPP_FIELD_COMMON_LOCALS;
    int stage_idx;
    SOC_PPC_FP_DATABASE_STAGE soc_stage;
  
    BCMDNX_INIT_FUNC_DEFS;
    _BCM_DPP_SWITCH_API_START(unit);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, *) enter\n"), unit));
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(info);

    info->field_presel_advanced_mode = (soc_property_get(unit, spn_FIELD_PRESEL_MGMT_ADVANCED_MODE, FALSE) );

    for (stage_idx=0 ; stage_idx < bcmFieldStageCount ; stage_idx++) 
    {
        if (stage == unitData->stageD[stage_idx].devInfo->bcmStage )
        {
            break;
        }
    }
    soc_stage = unitData->stageD[stage_idx].devInfo->hwStageId;
    
    result = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_presel_max_id_get,(unit,soc_stage,&(info->field_presel_max_id)));
    BCMDNX_IF_ERR_EXIT(result);

exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_mode_get
 *   Purpose
 *      Get the mode (width) of a group.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (out) bcm_mode_t *mode = the mode (width) of the group
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_mode_get(int unit,
                               bcm_field_group_t group,
                               bcm_field_group_mode_t *mode)
{
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, *) enter\n"), unit, group));
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!mode) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("oblgatory out argument is NULL")));
    }
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (unitData->groupD[group].groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        *mode = unitData->groupD[group].grpMode;
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d, &(%s(%d))) return %d (%s)\n"),
               unit,
               group,
               _bcm_dpp_field_group_mode_name[*mode],
               *mode,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_compress
 *   Purpose
 *      Compress a group
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Does not really do anything.
 */
int
bcm_petra_field_group_compress(int unit, bcm_field_group_t group)
{
    uint32 soc_sand_rv;
    unsigned int soc_sand_dev_id;
    _DPP_FIELD_COMMON_LOCALS;

    BCMDNX_INIT_FUNC_DEFS;
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) enter\n"), unit, group));
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }
    _DPP_FIELD_UNIT_LOCK(unitData);

    if (unitData->groupD[group].groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) {
        soc_sand_dev_id = (unit);
        soc_sand_rv = soc_ppd_fp_database_compress(soc_sand_dev_id, unitData->groupD[group].hwHandle);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    } else {
        LOG_ERROR(BSL_LS_BCM_FP,
                  (BSL_META_U(unit,
                              "unit %d group %d is not in use\n"),
                   unit,
                   group));
        result = BCM_E_NOT_FOUND;
    }

    _DPP_FIELD_UNIT_UNLOCK(unitData);
    LOG_DEBUG(BSL_LS_BCM_FP,
              (BSL_META_U(unit,
                          "(%d, %d) return %d (%s)\n"),
               unit,
               group,
               result,
               _SHR_ERRMSG(result)));
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualifier_delete
 * Purpose:
 *      Remove match criteria from a field processor entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      qual_id - (IN) BCM field qualifier id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualifier_delete(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_field_qualify_t qual_id)
{
    _DPP_FIELD_COMMON_LOCALS;
    uint64 *edata;
    BCMDNX_INIT_FUNC_DEFS;
    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    edata = sal_alloc(sizeof(*edata) * unitData->devInfo->qualChain,
                      "qualifier delete buffer");
    if (!edata) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY,
                         (_BSL_BCM_MSG("unable to allocate %u bytes for"
                                   " qualifier delete buffer"),
                          (uint32)sizeof(*edata) * unitData->devInfo->qualChain));
    }
    sal_memset(edata,
               0x00,
               sizeof(*edata) * unitData->devInfo->qualChain);
    result = _bcm_dpp_field_entry_qualifier_general_set(unit,
                                                        entry,
                                                        qual_id,
                                                        unitData->devInfo->qualChain,
                                                        edata,
                                                        edata);
    sal_free(edata);
    BCMDNX_IF_ERR_EXIT(result);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_HeaderFormat(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_field_header_format_t header_format)
{
    uint64 edata;
    uint64 emask;
    SOC_TMC_PARSER_PKT_HDR_STK_TYPE data;
    uint32 ppdMask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormat_bcm_to_ppd(header_format,
                                                           &data,
                                                           &ppdMask));
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, ppdMask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyHeaderFormat,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_HeaderFormat_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_field_header_format_t *header_format)
{
    uint32 data;
    uint32 mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyHeaderFormat,
                                                            &data,
                                                            &mask));
    if (mask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormat_ppd_to_bcm(data,
                                                               mask,
                                                               header_format));
    }
    else {
        *header_format = bcmFieldHeaderFormatCount;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_HeaderFormatSet(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_field_header_format_set_t header_format_set)
{
    uint32 data;
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormatSet_bcm_to_ppd(&header_format_set,
                                                              &data));
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyHeaderFormatSet,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_HeaderFormatSet_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_field_header_format_set_t *header_format_set)
{
    uint32 data;
    uint32 mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyHeaderFormatSet,
                                                            &data,
                                                            &mask));

    
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_HeaderFormatSet_ppd_to_bcm(data,
                                                              header_format_set));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L3DestHostHit(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3DestHostHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestHostHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL3DestHostHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestHostHit_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL3DestHostHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_CascadedKeyValue(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 data,
                                         uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyCascadedKeyValue,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_CascadedKeyValue_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint32 *data,
                                             uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyCascadedKeyValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IsEqualValue(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIsEqualValue,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IsEqualValue_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIsEqualValue,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OutPort
 *   Purpose
 *      Set allowed egress port for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_port_t data = allowed port
 *      (in) bcm_port_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Supports GPORTs of various types and will map back to phys port.
 */
int
bcm_petra_field_qualify_OutPort(int unit,
                                bcm_field_entry_t entry,
                                bcm_port_t data,
                                bcm_port_t mask)
{
    uint64 edata;
    uint64 emask;
    _bcm_dpp_core_ports_bitmap_t  port_bitmap[MAX_NUM_OF_CORES];
    int    nof_cores, core; 
    uint32 pp_port;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);
	uint32 is_valid;

    BCMDNX_INIT_FUNC_DEFS;
    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);



    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);


        if(data < 0 || data >= max_port)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Port value is out of range, "
                                       "Value is %d range is [0,255]\n"), 
                              data));
        }
        if ((0 != mask) && ((~0) != mask)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                       " bits set or all bits clear)")));
        }


        COMPILER_64_SET(emask, 0, 0x7);
		BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, data, &is_valid));

		if (is_valid) {
			BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, data, &pp_port, &core)));
			SHR_BITSET(port_bitmap[core], data);
		} else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                             (_BSL_BCM_MSG("Port %d is not valid"),
                              data));
        }

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeOutPort,
                                                               nof_cores,
                                                               port_bitmap, 
                                                               &edata));
    }
    else {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_qualify_pp_port_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOutPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InPorts
 *   Purpose
 *      Set allowed ingress ports for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_pbmp_t data = allowed ports
 *      (in) bcm_pbmp_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InPorts(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_pbmp_t data,
                                 bcm_pbmp_t mask)
{
    uint64 edata;
    uint64 emask;

    uint32
        port_id,
        fld_val;
    uint32 pp_port;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 
    int    core, nof_cores;
    uint32 is_valid;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);
        
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        /*
         * Check all the ports are masked and copy their
         * membership in data to the array
         */
        for (port_id = 0; port_id < max_port ; port_id++) {
            if (!BCM_PBMP_MEMBER(mask, port_id)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports all masked (all"
                                           " bits set in mask)")));
            }

            /* Copy the port bit */
            fld_val = BCM_PBMP_MEMBER(data, port_id);

            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (fld_val) {
                if (is_valid) {
                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));
                    SHR_BITCOPY_RANGE(port_bitmap[core], pp_port, &fld_val, 0, 1);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Invalid port")));
                }
            }
        }

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeInPort,
                                                               nof_cores,
                                                               port_bitmap, 
                                                               &edata));
        COMPILER_64_SET(emask, 0, 0x7);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                   bcmFieldQualifyInPorts,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_OutPorts
 *   Purpose
 *      Set allowed egress ports for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_pbmp_t data = allowed ports
 *      (in) bcm_pbmp_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_OutPorts(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_pbmp_t data,
                                  bcm_pbmp_t mask)
{
    uint64 edata;
    uint64 emask;

    uint32
        port_id,
        fld_val;
    int core, nof_cores;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 

    uint32     pp_port;
    uint32     max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);
    uint32     is_valid;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        /*
         * Check all the ports are masked and copy their
         * membership in data to the array
         */
        for (port_id = 0; port_id < max_port; port_id++) {
            if (!BCM_PBMP_MEMBER(mask, port_id)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports all masked (all"
                                           " bits set in mask)")));
            }
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (is_valid) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

                /* Copy the port bit */
                fld_val = BCM_PBMP_MEMBER(data, port_id);
                SHR_BITCOPY_RANGE(port_bitmap[core], pp_port, &fld_val, 0, 1);
            }
        }

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeOutPort,
                                                               nof_cores,
                                                               port_bitmap, 
                                                               &edata));
        COMPILER_64_SET(emask, 0, 0x7);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                   bcmFieldQualifyOutPorts,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InPorts_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InPorts_get(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_pbmp_t *data,
                                     bcm_pbmp_t *mask)
{
    uint32 tdata;
    uint32 tmask;
    uint32 
        port_id, pp_port;
    _bcm_dpp_core_ports_bitmap_t  port_bitmap[MAX_NUM_OF_CORES];
    int                   core, nof_cores; 
    uint32                is_valid;
    uint32                max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);

    BCMDNX_INIT_FUNC_DEFS;

    _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifyInPorts,
                                                                &tdata,
                                                                &tmask));

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeInPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        BCM_PBMP_CLEAR(*data);
        BCM_PBMP_CLEAR(*mask);
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

			if (is_valid) {

				BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

				if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    BCM_PBMP_PORT_ADD(*data, port_id);
				}

			}
            /* Mask is expected to be all 1*/
            BCM_PBMP_PORT_ADD(*mask, port_id);

        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutPorts_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOutPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutPorts_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_pbmp_t *data,
                                      bcm_pbmp_t *mask)
{
    uint32 tdata;
    uint32 tmask;
    uint32 port_id, pp_port;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 
    int    core, nof_cores;
    uint32          max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);
    uint32          is_valid;

    BCMDNX_INIT_FUNC_DEFS;


    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifyOutPorts,
                                                                &tdata,
                                                                &tmask));

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeOutPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        BCM_PBMP_CLEAR(*data);
        BCM_PBMP_CLEAR(*mask);
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (is_valid) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

                if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    BCM_PBMP_PORT_ADD(*data, port_id);
                }
            }
            BCM_PBMP_PORT_ADD(*mask, port_id);
        }
    } 
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_Llc
 *   Purpose
 *      Set expected LLC header information for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_field_llc_header_t data = which LLC header information
 *      (in) bcm_field_llc_header_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_Llc(int unit,
                             bcm_field_entry_t entry,
                             bcm_field_llc_header_t data,
                             bcm_field_llc_header_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_ports_create_mode
 *   Purpose
 *      Create a new group spanning the specified width, that has the specified
 *      qualifier set and priority, and affects only the specified ports.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_pbmp_t port = the ports
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_mode_t mode = the mode (width) of the group
 *      (out) bcm_field_group_t *group = where to put the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 *      Can not specify a qualifier that another group in the same stage has.
 *      If no stage qualifier, it is assumed to be bcmFieldQualifyStageIngress.
 */
int
bcm_petra_field_group_ports_create_mode(int unit,
                                         bcm_pbmp_t pbmp,
                                         bcm_field_qset_t qset,
                                         int pri,
                                         bcm_field_group_mode_t mode,
                                         bcm_field_group_t *group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_ports_create_mode_id
 *   Purpose
 *      Create a new group using the specified ID, spanning the specified
 *      width, that has the specified qualifier set and priority, and affects
 *      only the specified ports.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_pbmp_t port = the ports
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_mode_t mode = the mode (width) of the group
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 *      Can not specify a qualifier that another group in the same stage has.
 *      If no stage qualifier, it is assumed to be bcmFieldQualifyStageIngress.
 */
int
bcm_petra_field_group_ports_create_mode_id(int unit,
                                            bcm_pbmp_t pbmp,
                                            bcm_field_qset_t qset,
                                            int pri,
                                            bcm_field_group_mode_t mode,
                                            bcm_field_group_t group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_enable_set
 *   Purpose
 *      This turns a group on or off.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) int enable = new enable state
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_enable_set(int unit,
                                  bcm_field_group_t group,
                                  int enable)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_enable_get
 *   Purpose
 *      This gets whether a group is on or off.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_group_t group = which group ID to use
 *      (in) int *enable = where to put current enable state
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_group_enable_get(int unit,
                                  bcm_field_group_t group,
                                  int *enable)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_resync
 *   Purpose
 *      Purge hardware of all field entries not replayed after 'warm boot'.
 *   Parameters
 *      (in) int unit = the unit number
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_resync(int unit)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOutPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *      This version always returns local port, not GPORT, even thoguh the set
 *      function allows certain GPORT types.
 */
int
bcm_petra_field_qualify_OutPort_get(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_port_t *data,
                                    bcm_port_t *mask)
{
    uint32 tdata;
    uint32 tmask;
    bcm_port_t port;
    uint32 
        port_id, pp_port;
    _bcm_dpp_core_ports_bitmap_t    port_bitmap[MAX_NUM_OF_CORES];
    int                     core, nof_cores;
    uint32 max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);
    uint32 is_valid;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOutPort,
                                                            &tdata,
                                                            &tmask));

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeOutPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        port = max_port;
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (is_valid) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

                if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    if(port != max_port) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                     (_BSL_BCM_MSG("Presel was defined"
                                               " for multiple ports")));
                    }
                    port = port_id;
                }
            }
        }
    }
    else {
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_pp_to_local_port_get, (unit, core, tdata, &port)));
    }

    *data = port;
    if (tmask) {
        *mask = (~0);
    } else {
        *mask = 0;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Drop(int unit,
                              bcm_field_entry_t entry,
                              uint8 data,
                              uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Limit to 19b at ingress */
    COMPILER_64_SET(edata, 0, (data? _BCM_DPP_FIELD_DROP_DEST(unit):0));
    COMPILER_64_SET(emask, 0, (mask? _BCM_DPP_FIELD_DROP_DEST(unit) /* all ones */ :0));

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDrop,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_SrcPort(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_module_t data_modid,
                                 bcm_module_t mask_modid,
                                 bcm_port_t   data_port,
                                 bcm_port_t   mask_port)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data, mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_mod_port_to_gport_convert(unit,
                                                         data_modid,
                                                         mask_modid,
                                                         data_port,
                                                         mask_port,
                                                         &data,
                                                         &mask));

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /* Limit to 16 bits since it is only Source-System-Port */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcTrunk(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_trunk_t data,
                                  bcm_trunk_t mask)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data_gport, mask_gport;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCM_GPORT_TRUNK_SET(data_gport, data);
    BCM_GPORT_TRUNK_SET(mask_gport, mask);
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data_gport,
                                                               mask_gport,
                                                               &edata,
                                                               &emask));

    /* Limit to 16 bits since it is only Source-System-Port */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcTrunk,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DstPort(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_module_t data_modid,
                                 bcm_module_t mask_modid,
                                 bcm_port_t   data_port,
                                 bcm_port_t   mask_port)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data, mask;
    uint32 group_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_mod_port_to_gport_convert(unit,
                                                         data_modid,
                                                         mask_modid,
                                                         data_port,
                                                         mask_port,
                                                         &data,
                                                         &mask));

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /* If Egress, limit to 16b - only System-Port */
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));

    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x7FFFF);
    if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
        /* Limit to 16 bits since it is only Source-System-Port */
        COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DstTrunk(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_trunk_t data,
                                  bcm_trunk_t mask)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data_gport, mask_gport;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCM_GPORT_TRUNK_SET(data_gport, data);
    BCM_GPORT_TRUNK_SET(mask_gport, mask);
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data_gport,
                                                               mask_gport,
                                                               &edata,
                                                               &emask));
    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x7FFFF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstTrunk,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_ExtensionHeaderSubCode(int unit,
                                                bcm_field_entry_t entry,
                                                uint8 i,uint8 j)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_ExtensionHeaderType(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data,uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExtensionHeaderType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_ExtensionHeader2Type(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 i,uint8 j)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp6
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerSrcIp6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp6(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_ip6_t data,
                                    bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerSrcIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp6
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerDstIp6
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp6(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_ip6_t data,
                                    bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerDstIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp6High
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerSrcIp6High
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp6High(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_ip6_t data,
                                        bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerSrcIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp6High
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInnerDstIp6High
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp6High(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_ip6_t data,
                                        bcm_ip6_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_set(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerDstIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerIpFrag(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_field_IpFrag_t frag_info)
{
    uint64 edata;
    uint64 emask;
    uint8 ip_fragmented;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_frag_bcm_to_ppd(unit,frag_info, &ip_fragmented));
    COMPILER_64_SET(edata, 0, ip_fragmented);

    /* All masked */
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerIpFrag,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTtl
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerTtl
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTtl(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerTtl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_EqualL4Port(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 flag)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DosAttack(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IpmcStarGroupHit(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 data,
                                          uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestRouteHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3DestRouteHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestRouteHit(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3DestRouteHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L3SrcHostHit(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L2CacheHit(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2StationMove
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2StationMove
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2StationMove(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2StationMove,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2DestHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2DestHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2DestHit(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2DestHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L2SrcStatic(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2SrcHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcHit(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2SrcHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_ForwardingVlanValid(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data,
                                             uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanTranslationHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyVlanTranslationHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanTranslationHit(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 data,
                                           uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVlanTranslationHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpInfo
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpInfo
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpInfo(int unit,
                               bcm_field_entry_t entry,
                               uint32 data,
                               uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    /* bit 0 for Version-Error, bit 1 for Checksum-error */
    if (mask & BCM_FIELD_IP_VERSION_ERR) {
        if (data & BCM_FIELD_IP_VERSION_ERR) {
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 0));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 0));
    }

    if (mask & BCM_FIELD_IP_CHECKSUM_OK) {
        if ((data & BCM_FIELD_IP_CHECKSUM_OK) == 0) {
            /* Check-error in HW, invert the bit meaning */
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 1));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 1));
    }


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpInfo,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketRes
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPacketRes
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketRes(int unit,
                                  bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    _bcm_dpp_field_info_t *unitData;
    uint64 edata; /* 0 - unknown, 1 - bpdu */
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    /* Init to zero */
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    /* The data values are not bitmap as expected - allow only full mask */
    if ((0 != mask) && (0x1F != (mask & 0x1F))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                   " bits set or all bits clear clear)")));
    }

    if (data == BCM_FIELD_PKT_RES_UNKNOWN) {
        COMPILER_64_SET(edata, 0, 1);
        COMPILER_64_SET(emask, 0, 1);
    }
    else if (data == BCM_FIELD_PKT_RES_BPDU) {
        COMPILER_64_SET(edata, 0, (1 << 1));
        COMPILER_64_SET(emask, 0, (1 << 1));
    }
    else if (mask == 0) {
        /* Nothing to do */
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports nothing or supported values masks ("
                                   "BCM_FIELD_PKT_RES_UNKNOWN, BCM_FIELD_PKT_RES_BPDU)")));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPacketRes,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpFlags
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpFlags
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpFlags(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpFlags,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_TcpSequenceZero(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 flag)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_TcpHeaderSize(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int bcm_petra_field_qualify_IpAuth(int unit,
                 bcm_field_entry_t entry ,
                 uint8 a,
                 uint8 b)
{
  BCMDNX_INIT_FUNC_DEFS;
  BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
  BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcIpEqualDstIp(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 flag)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_petra_field_qualify_IpType(int unit,
                                bcm_field_entry_t entry,
                                bcm_field_IpType_t type)
{
    uint64 edata;
    uint64 emask;
    SOC_PPD_FP_PARSED_ETHERTYPE ppdIpType;
    uint32 group_flags = 0;
    uint8 is_egress;
    unsigned int count = 1;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)?1:0;
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_type_bcm_to_ppd(type, is_egress, &ppdIpType));
    COMPILER_64_SET(edata, 0, ppdIpType);
    /* Fully masked - 4 bits */
    COMPILER_64_SET(emask, 0, 0xF);

    /* At egress, check if options */
    if ((type == bcmFieldIpTypeIpv4NoOpts)
        || (type == bcmFieldIpTypeIpv4WithOpts)) {
        COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (type == bcmFieldIpTypeIpv4WithOpts) << 4);
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 4));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpType,
                                                               count,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L2Format(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_L2Format_t type)
{
    uint64 edata;
    uint64 emask;
    SOC_PPD_FP_ETH_ENCAPSULATION ppdL2Format;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_l2_eth_format_bcm_to_ppd(type, &ppdL2Format));
    COMPILER_64_SET(edata, 0, ppdL2Format);
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2Format,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MHOpcode(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Decap(int unit,
                               bcm_field_entry_t entry,
                               bcm_field_decap_t decap)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_HiGig(int unit,
                               bcm_field_entry_t entry,
                               uint8 data,
                               uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstHiGig
 * Purpose:
 *      Qualify on HiGig destination packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstHiGig(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstHiGig_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstHiGig
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstHiGig_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassL2
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInterfaceClassL2
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassL2(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 data,
                                         uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInterfaceClassL2,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
 _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InterfaceClassL3(int unit, bcm_field_entry_t entry,
                                        uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInterfaceClassPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassPort(int unit,
                                           bcm_field_entry_t entry,
                                           uint32 data,
                                           uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInterfaceClassPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
 _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcClassL2(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcClassL3(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcClassField(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcClassField,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DstClassL2(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DstClassL3(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_DstClassField(int unit, bcm_field_entry_t entry,
                                  uint32 data, uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstClassField,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_IpProtocolCommon(int unit,
                                          bcm_field_entry_t entry,
                                          bcm_field_IpProtocolCommon_t protocol)
{
    uint64 edata;
    uint64 emask;
    SOC_PPD_FP_PARSED_IP_NEXT_PROTOCOL ppdIpNextProtocol;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_next_protocol_bcm_to_ppd(protocol, &ppdIpNextProtocol));
    COMPILER_64_SET(edata, 0, ppdIpNextProtocol);

    /* All masked */
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpProtocolCommon,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_Snap(int unit,
                              bcm_field_entry_t entry,
                              bcm_field_snap_header_t data,
                              bcm_field_snap_header_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTpid
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerTpid
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (IN) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTpid(int unit,
                                   bcm_field_entry_t entry,
                                   uint16 tpid)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, tpid);
    COMPILER_64_SET(emask, 0, 0xffff);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerTpid,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterTpid
 * Purpose:
 *       Set match criteria for bcmFieldQualifyOuterTpid
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (IN) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterTpid(int unit,
                                  bcm_field_entry_t entry,
                                  uint16 tpid)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, tpid);
    COMPILER_64_SET(emask, 0, 0xffff);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterTpid,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L3Routable(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IpFrag(int unit,
                                bcm_field_entry_t entry,
                                bcm_field_IpFrag_t frag_info)
{
    uint64 edata;
    uint64 emask;
    uint8 ip_fragmented;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_frag_bcm_to_ppd(unit,frag_info, &ip_fragmented));
    COMPILER_64_SET(edata, 0, ip_fragmented);

    /* All masked */
    COMPILER_64_SET(emask, ~0, ~0);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpFrag,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_L3Ingress
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3Ingress
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3Ingress(int unit,
                                  bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);

    
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3Ingress,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_L4Ports(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MirrorCopy
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMirrorCopy
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MirrorCopy(int unit,
                                   bcm_field_entry_t entry,
                                   uint8 data,
                                   uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, 1); /* 1 - encoding in FTMH.TM-Action-Type for Mirror */
    COMPILER_64_SET(emask, 0, (mask? 0x3: 0));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMirrorCopy,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminated
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTunnelTerminated
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminated(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 data,
                                         uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelTerminated,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsTerminated
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsTerminated
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsTerminated(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsTerminated,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_action_ports_add(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_action_t action,
                                  bcm_pbmp_t pbmp)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_action_ports_get(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_action_t action,
                                  bcm_pbmp_t *pbmp)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_group_priority_set(int unit, bcm_field_group_t group,
                                 int priority)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_group_priority_get(int unit, bcm_field_group_t group,
                                 int *priority)
{
    _bcm_dpp_field_info_t *unitData;
    _bcm_dpp_field_group_t *groupInfo;

    BCMDNX_INIT_FUNC_DEFS;

    _BCM_DPP_SWITCH_API_START(unit);

    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if ((0 > group) || (unitData->groupLimit <= group)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("group %d is not valid"), group));
    }

    _DPP_FIELD_UNIT_LOCK(unitData);

    groupInfo = &(unitData->groupD[group]);

    if ((groupInfo->groupFlags & _BCM_DPP_FIELD_GROUP_IN_USE) == 0) {
        _DPP_FIELD_UNIT_UNLOCK(unitData);
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("unit %d group %d doesn\'t exist"),
                          unit,
                          group));
    }

    *priority = groupInfo->priority;

    _DPP_FIELD_UNIT_UNLOCK(unitData);

exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_BigIcmpCheck(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 flag,
                                      uint32 size)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IcmpTypeCode(int unit,
                                      bcm_field_entry_t entry,
                                      uint16 data,
                                      uint16 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_IgmpTypeMaxRespTime(int unit,
                                             bcm_field_entry_t entry,
                                             uint16 data,
                                             uint16 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerIpType(int unit, bcm_field_entry_t entry,
                             bcm_field_IpType_t type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_InnerIpProtocolCommon(int unit, bcm_field_entry_t entry,
                                       bcm_field_IpProtocolCommon_t protocol)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIp6FlowLabel
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInnerIp6FlowLabel
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIp6FlowLabel(int unit,
                                          bcm_field_entry_t entry,
                                          uint32 data,
                                          uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerIp6FlowLabel,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstL3Egress
 * Purpose:
 *       Set match criteria for bcmFieldQualifyDstL3Egress
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      if_id - (IN) L3 forwarding object.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstL3Egress(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_if_t if_id)
{
    uint64 edata;
    uint64 emask;
    SOC_PPD_FEC_ID fec_id;
    SOC_PPD_FRWRD_DECISION_INFO   fwdDecision;
    uint32 soc_sand_rv;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, if_id);
    COMPILER_64_SET(emask, 0, ~0);

    SOC_PPD_FRWRD_DECISION_INFO_clear(&fwdDecision);

    /* Set the Forward decision */
    if(_BCM_PETRA_L3_ITF_IS_FEC(if_id)) {
        _bcm_l3_intf_to_fec(unit, if_id, &fec_id);
        SOC_PPD_FRWRD_DECISION_FEC_SET((unit), &fwdDecision, fec_id, soc_sand_rv);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d has an invalid Interface ID type, "
                                           "expected: FEC-Pointer\n"),
                          unit,
                          entry));
    }


    /* Get the HW Destination from the Forward decision */
    BCMDNX_IF_ERR_EXIT_MSG(
        _bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(unit,
                                                                      &fwdDecision,
                                                                      TRUE, /* is_for_destination */
                                                                      FALSE, /* is_for_action */
                                                                      &edata,
                                                                      &emask),
                        (_BSL_BCM_MSG("unable to get from the forward decision the HW data")));

    COMPILER_64_SET(emask, 0, 0x7FFFF);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstL3Egress,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMulticastGroup
 * Purpose:
 *       Set match criteria for bcmFieldQualifyDstMulticastGroup
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (IN) Multicast group id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMulticastGroup(int unit,
                                          bcm_field_entry_t entry,
                                          bcm_gport_t group)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t mask = ~0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               group,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x7FFFF);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstMulticastGroup,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_SrcMplsGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DstMplsGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_SrcMimGport(int unit,
                              bcm_field_entry_t entry,
                              bcm_gport_t mim_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DstMimGport(int unit,
                              bcm_field_entry_t entry,
                              bcm_gport_t mim_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_petra_field_qualify_SrcWlanGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t wlan_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_DstWlanGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t wlan_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_Loopback(int unit,
                               bcm_field_entry_t entry,
                               uint8 data,
                               uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_petra_field_qualify_LoopbackType(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_field_LoopbackType_t loopback_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_field_qualify_TunnelType(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_field_TunnelType_t tunnel_type)
{
    uint64 edata;
    uint64 emask;
    SOC_PPD_PKT_TERM_TYPE ppdTerminationType;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_termination_type_bcm_to_ppd(tunnel_type, &ppdTerminationType));

    COMPILER_64_SET(edata, 0, ppdTerminationType);
    COMPILER_64_SET(emask, ~0, ~0);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_petra_field_qualify_LoopbackType_get
 * Purpose:
 *      Get loopback type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      loopback_type - (OUT) Loopback type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LoopbackType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_LoopbackType_t *loopback_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelType_get
 * Purpose:
 *      Get tunnel type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      tunnel_type - (OUT) Tunnel type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_TunnelType_t *tunnel_type)
{
    int32 ppd;
    bcm_field_TunnelType_t bcm;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTunnelType,
                                                           &ppd,
                                                           &emask));
    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_termination_type_ppd_to_bcm(ppd, &bcm));
        *tunnel_type = bcm;
    }
    else {
        /* Special value for don't care */
        *tunnel_type = bcmFieldTunnelTypeAny;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstL3Egress_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyDstL3Egress
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      if_id - (OUT) L3 forwarding object.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstL3Egress_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_if_t *if_id)
{
    uint32 data_lcl;
    uint32 mask;
    SOC_PPD_FRWRD_DECISION_INFO   fwdDecision;
    BCMDNX_INIT_FUNC_DEFS;



    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstL3Egress,
                                                            &data_lcl,
                                                            &mask));

    *if_id = 0;
    if (mask) {
        /* Decode the Destination to FEC */
        BCMDNX_IF_ERR_EXIT_MSG(
            _bcm_dpp_field_qualify_fwd_decision_from_hw_convert(unit,
                                                                TRUE, /* is_for_destination */
                                                                data_lcl,
                                                                ARAD_PP_FWD_DECISION_PARSE_DEST,
                                                                &fwdDecision),
                            (_BSL_BCM_MSG("unable to get the Forward-Decision with HW Destination %d"), data_lcl));

        /* Set the Forward decision */
        if(fwdDecision.type == SOC_PPC_FRWRD_DECISION_TYPE_FEC) {
            _BCM_PETRA_L3_ITF_SET(*if_id, _BCM_PETRA_L3_ITF_FEC, fwdDecision.dest_id);
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d entry %d has an invalid Interface ID type, "
                                               "expected: FEC-Pointer\n"),
                              unit,
                              entry));
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMulticastGroup_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyDstMulticastGroup
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      group - (OUT) Multicast group id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMulticastGroup_get(int unit,
                                              bcm_field_entry_t entry,
                                              bcm_gport_t *group)
{
    uint32 data_lcl;
    uint32 mask;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstMulticastGroup,
                                                            &data_lcl,
                                                            &mask));
    *group = 0;

    if (mask) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        if (BCM_GPORT_IS_MCAST(gport)) {
            *group = gport;
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcMplsGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcMplsGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcMplsGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMplsGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstMplsGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mpls_port_id - (OUT) Mpls port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMplsGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcMimGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcMimGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcMimGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mim_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstMimGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstMimGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      mim_port_id - (OUT) Mim port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstMimGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *mim_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcWlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcWlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcWlanGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *wlan_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstWlanGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstWlanGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      wlan_port_id - (OUT) Wlan port id.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstWlanGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *wlan_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Loopback_get
 * Purpose:
 *      Get loopback field qualification from  a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data - (OUT) Data to qualify with.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Loopback_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Drop_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDrop
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Drop_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    uint32 tdata;
    uint32 tmask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDrop,
                                                            &tdata,
                                                            &tmask));

    *data = 0;
    *mask = 0;
    if (tmask == _BCM_DPP_FIELD_DROP_DEST(unit)) {
        *mask = 1;
        *data = (tdata == _BCM_DPP_FIELD_DROP_DEST(unit))? 1: 0;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_SrcPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data_modid - (OUT) Qualifier module id.
 *      mask_modid - (OUT) Qualifier module id mask.
 *      data_port - (OUT) Qualifier port id.
 *      mask_port - (OUT) Qualifier port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcPort_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_module_t *data_modid,
    bcm_module_t *mask_modid,
    bcm_port_t *data_port,
    bcm_port_t *mask_port)
{
    uint32 tdata;
    uint32 tmask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcPort,
                                                            &tdata,
                                                            &tmask));

    *data_modid = 0;
    *data_port = 0;
    *mask_modid = 0;
    *mask_port = 0;

    if (tmask) {
        if (SOC_IS_ARAD(unit)) {
            /* Insert the 19b encoding for the Source-Port */
            tdata |= (1 << 18);
        }
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, tdata, data_port),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), tdata));
        *mask_port = tmask;

        /* Take only the 16b of the Queue-ID */
        if (BCM_GPORT_IS_MODPORT(*data_port)) {
            *data_modid = BCM_GPORT_MODPORT_MODID_GET(*data_port);
            *data_port = BCM_GPORT_MODPORT_PORT_GET(*data_port);
            *mask_modid = (~0);
            *mask_port = (~0);
        }
    }


exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcTrunk_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcTrunk
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcTrunk_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_trunk_t *data,
    bcm_trunk_t *mask)
{
    uint32 data_lcl;
    uint32 mask_lcl;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcTrunk,
                                                            &data_lcl,
                                                            &mask_lcl));
    *data = 0;
    *mask = 0;

    if (mask_lcl) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        if (BCM_GPORT_IS_TRUNK(gport)) {
            *data = BCM_GPORT_TRUNK_GET(gport);
            *mask = (~0);
        }
    }


exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstPort_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstPort
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data_modid - (OUT) Qualifier module id.
 *      mask_modid - (OUT) Qualifier module id mask.
 *      data_port - (OUT) Qualifier port id.
 *      mask_port - (OUT) Qualifier port id mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstPort_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_module_t *data_modid,
    bcm_module_t *mask_modid,
    bcm_port_t *data_port,
    bcm_port_t *mask_port)
{
    uint32 tdata;
    uint32 tmask;
    uint32 group_flags = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstPort,
                                                            &tdata,
                                                            &tmask));

    *data_modid = 0;
    *data_port = 0;
    *mask_modid = 0;
    *mask_port = 0;

    if (tmask) {
        /* If Egress, limit to 16b - only System-Port */
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_petra_field_entry_group_flags(unit,
                                                   entry,
                                                   &group_flags));
        if (SOC_IS_ARAD(unit) && (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)) {
            /* Insert the 19b encoding */
            tdata |= (1 << 18);
        }

        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, tdata, data_port),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), tdata));
        *mask_port = tmask;

        /* Take only the 16b of the Queue-ID */
        if (BCM_GPORT_IS_MODPORT(*data_port)) {
            *data_modid = BCM_GPORT_MODPORT_MODID_GET(*data_port);
            *data_port = BCM_GPORT_MODPORT_PORT_GET(*data_port);
            *mask_modid = (~0);
            *mask_port = (~0);
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstTrunk_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstTrunk
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstTrunk_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_trunk_t *data,
    bcm_trunk_t *mask)
{
    uint32 data_lcl;
    uint32 mask_lcl;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstTrunk,
                                                            &data_lcl,
                                                            &mask_lcl));
    *data = 0;
    *mask = 0;

    if (mask_lcl) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        if (BCM_GPORT_IS_TRUNK(gport)) {
            *data = BCM_GPORT_TRUNK_GET(gport);
            *mask = (~0);
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_EqualL4Port_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyEqualL4Port
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      flag - (OUT) Qualifier flags.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EqualL4Port_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *flag)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpInfo_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpInfo
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpInfo_get(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 *data,
                                   uint32 *mask)
{
    uint32 edata, emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyIpInfo,
                                                            &edata,
                                                            &emask));

    *data = 0;
    *mask = 0;

    /* bit 0 for all filtering, bit 1 for exclude source only */
    if (emask & 0x1) {
        if (edata & 0x1) {
            *data += BCM_FIELD_IP_VERSION_ERR;
        }
        *mask += BCM_FIELD_IP_VERSION_ERR;
    }

    if (emask & (0x1 << 1)) {
        if ((edata & (0x1 << 1)) == 0) {
            /* Check-error in HW, invert the bit meaning */
            *data += BCM_FIELD_IP_CHECKSUM_OK;
        }
        *mask += BCM_FIELD_IP_CHECKSUM_OK;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketRes_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPacketRes
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketRes_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 *data,
                                      uint32 *mask)
{
    uint64 edata; /* 0 - unknown, 1 - bpdu */
    uint64 emask;
    _bcm_dpp_field_info_t *unitData;
    BCMDNX_INIT_FUNC_DEFS;


    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               bcmFieldQualifyPacketRes,
                                                               1, /* count*/
                                                               &edata,
                                                               &emask));
    *data = 0;
    *mask = 0;
    if (COMPILER_64_LO(emask) & 0x1) {
        *mask = 0x1F;
        *data = BCM_FIELD_PKT_RES_UNKNOWN;
    }
    else if (COMPILER_64_LO(emask) & (0x1 << 1)) {
        *mask = 0x1F;
        *data = BCM_FIELD_PKT_RES_BPDU;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpFlags_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpFlags
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpFlags_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpFlags,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TcpSequenceZero_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTcpSequenceZero
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      flag - (OUT) Qualifier match flags.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TcpSequenceZero_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *flag)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TcpHeaderSize_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTcpHeaderSize
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TcpHeaderSize_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcIpEqualDstIp_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcIpEqualDstIp
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      flag - (OUT) Qualifier match flags.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcIpEqualDstIp_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *flag)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIp6FlowLabel_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerIp6FlowLabel
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIp6FlowLabel_get(int unit,
                                              bcm_field_entry_t entry,
                                              uint32 *data,
                                              uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerIp6FlowLabel,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_petra_field_qualify_InnerIpType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerIpType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Inner ip header ip type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIpType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpType_t *type)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match ip type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpType_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpType_t *type)
{
    _bcm_dpp_field_info_t *unitData;
    int32 ppdIpType;
    int32 emask;
    uint8 is_egress;
    uint32 group_flags = 0;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    is_egress = (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS)?1:0;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpType,
                                                           &ppdIpType,
                                                           &emask));
    if (emask) {
        /* Only 4 bits for the enum */
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_type_ppd_to_bcm((ppdIpType & 0xF), is_egress, type));
        /* At egress, check if options */
        if (*type == bcmFieldIpTypeIpv4Any) {
            _DPP_FIELD_UNIT_CHECK(unit, unitData);
            if (emask >> 4) {
                if (ppdIpType >> 4) {
                    *type = bcmFieldIpTypeIpv4WithOpts;
                }
                else {
                    *type = bcmFieldIpTypeIpv4NoOpts;
                }
            }
        }
    }
    else {
        /* Not valid */
        *type = bcmFieldIpTypeCount;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2Format_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2Format
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      type - (OUT) Qualifier match l2 format.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2Format_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_L2Format_t *type)
{
    int32 ppd;
    bcm_field_L2Format_t bcm;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2Format,
                                                           &ppd,
                                                           &emask));

    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_l2_eth_format_ppd_to_bcm(ppd, &bcm));
        *type = bcm;
    }
    else {
        /* Not valid */
        *type = bcmFieldL2FormatCount;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MHOpcode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMHOpcode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MHOpcode_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_HiGig_get
 * Purpose:
 *      Qualify on HiGig packets.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_HiGig_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassPort_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInterfaceClassPort,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassL2_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassL2
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassL2_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint32 *data,
                                             uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInterfaceClassL2,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInterfaceClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassL3_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcClassL2_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcClassL3_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcClassField_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcClassField
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcClassField_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcClassField,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstClassL2_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstClassL2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstClassL2_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstClassL3_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstClassL3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstClassL3_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstClassField_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDstClassField
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstClassField_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyDstClassField,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_IpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpProtocolCommon
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      protocol - (OUT) Qualifier protocol encoding.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpProtocolCommon_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpProtocolCommon_t *protocol)
{
    int32 ppd;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpProtocolCommon,
                                                           &ppd,
                                                           &emask));

    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_next_protocol_ppd_to_bcm(ppd, protocol));
    }
    else {
        *protocol = bcmFieldIpProtocolCommonCount;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIpProtocolCommon_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerIpProtocolCommon
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      protocol - (OUT) Qualifier inner ip protocol encodnig.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIpProtocolCommon_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpProtocolCommon_t *protocol)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Snap_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySnap
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Snap_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_snap_header_t *data,
    bcm_field_snap_header_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Llc_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyLlc
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Llc_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_llc_header_t *data,
    bcm_field_llc_header_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTpid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerTpid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (OUT) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTpid_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *tpid)
{/* Created automatically by script */
    uint16 mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerTpid,
                                                            tpid,
                                                            &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OuterTpid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyOuterTpid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      tpid - (OUT) Qualifier tpid.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OuterTpid_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *tpid)
{/* Created automatically by script */
    uint16 mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOuterTpid,
                                                            tpid,
                                                            &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3Routable_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL3Routable
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3Routable_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpFrag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpFrag
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      frag_info - (OUT) Qualifier ip framentation encoding.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpFrag_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpFrag_t *frag_info)
{
    int32 ppd;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpFrag,
                                                           &ppd,
                                                           &emask));

    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_frag_ppd_to_bcm(unit, ppd, frag_info));
    }
    else {
        *frag_info = bcmFieldIpFragCount;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3Ingress_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3Ingress
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3Ingress_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 *data,
                                      uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL3Ingress,
                                                            data,
                                                            mask));
    

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ExtensionHeaderType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExtensionHeaderType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExtensionHeaderType_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExtensionHeaderType,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ExtensionHeaderSubCode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExtensionHeaderSubCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExtensionHeaderSubCode_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ExtensionHeader2Type_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExtensionHeaderType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExtensionHeader2Type_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L4Ports_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL4Ports
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L4Ports_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MirrorCopy_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMirrorCopy
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MirrorCopy_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 *data,
                                       uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMirrorCopy,
                                                           data,
                                                           mask));
    *data = (*mask)? 1: 0;
    *mask = (*mask)? 1: 0;
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminated_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTunnelTerminated
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminated_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 *data,
                                             uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTunnelTerminated,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsTerminated_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsTerminated
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsTerminated_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 *data,
                                           uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsTerminated,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp6_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerSrcIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp6_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t *data,
                                   bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerSrcIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp6_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDstIp6
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp6_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_ip6_t *data,
                                   bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerDstIp6,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerSrcIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcIp6High_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip6_t *data,
                                       bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerSrcIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstIp6High_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDstIp6High
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstIp6High_get(int unit,
                                       bcm_field_entry_t entry,
                                       bcm_ip6_t *data,
                                       bcm_ip6_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_ipv6addr_get(unit,
                                                              entry,
                                                              bcmFieldQualifyInnerDstIp6High,
                                                              data,
                                                              mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerTtl_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInnerTtl
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerTtl_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerTtl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerIpFrag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerIpFrag
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      frag_info - (OUT) Inner ip header fragmentation info.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerIpFrag_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_IpFrag_t *frag_info)
{
    int32 ppd;
    int32 emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyInnerIpFrag,
                                                           &ppd,
                                                           &emask));

    if (emask) {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_ip_frag_ppd_to_bcm(unit, ppd, frag_info));
    }
    else {
        *frag_info = bcmFieldIpFragCount;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DosAttack_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyDosAttack
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DosAttack_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcStarGroupHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpmcStarGroupHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcStarGroupHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestRouteHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3DestRouteHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestRouteHit_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 *data,
                                           uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL3DestRouteHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcHostHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL3SrcHostHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcHostHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2CacheHit_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2CacheHit
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2CacheHit_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2StationMove_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2StationMove
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2StationMove_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2StationMove,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2DestHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2DestHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2DestHit_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data,
                                      uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2DestHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcStatic_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyL2SrcStatic
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcStatic_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2SrcHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcHit_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2SrcHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingVlanValid_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardingVlanValid
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingVlanValid_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanTranslationHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyVlanTranslationHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanTranslationHit_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyVlanTranslationHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpAuth_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIpAuth
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpAuth_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BigIcmpCheck_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyBigIcmpCheck
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      flag - (OUT) Flag.
 *      size - (OUT) Size.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BigIcmpCheck_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *flag,
    uint32 *size)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IcmpTypeCode_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIcmpTypeCode
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IcmpTypeCode_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IgmpTypeMaxRespTime_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIgmpTypeMaxRespTime
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IgmpTypeMaxRespTime_get(
    int unit,
    bcm_field_entry_t entry,
    uint16 *data,
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedVlanFormat
 * Purpose:
 *      Set match criteria for bcmFieldQualifyTranslatedVlanFormat
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedVlanFormat(
    int unit,
    bcm_field_entry_t entry,
    uint8 data,
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FibreChanOuter
 * Purpose:
 *      Add Fibre Channel outer header type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FibreChanOuter(int unit,
                             bcm_field_entry_t entry,
                             bcm_field_FibreChan_t fibre_chan_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FibreChanInner
 * Purpose:
 *      Add Fibre Channel inner header type field qualification to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (IN) Data to qualify with.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FibreChanInner(int unit,
                             bcm_field_entry_t entry,
                             bcm_field_FibreChan_t fibre_chan_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VnTag
 * Purpose:
 *      Add NIV VN tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VnTag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_CnTag
 * Purpose:
 *      Add QCN CN tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_CnTag(int unit, bcm_field_entry_t entry,
                            uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FabricQueueTag
 * Purpose:
 *      Add Fabric Queue tag field qualification to a field entry.
 * Parameters:
 *      unit  - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      data  - (IN) Qualifier match data.
 *      mask  - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FabricQueueTag(int unit, bcm_field_entry_t entry,
                                     uint32 data, uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcModPortGport
 * Purpose:
 *       Set match criteria for bcmFieldQualifySrcModPortGport
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcModPortGport(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_gport_t data)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t mask = ~0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /* Limit to 16 bits since it is only Source-System-Port */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySrcModPortGport,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcModuleGport
 * Purpose:
 *      Set match criteria for bcmFieldQualifySrcModuleGport
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcModuleGport(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t data)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedVlanFormat_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTranslatedVlanFormat
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedVlanFormat_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *data,
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FibreChannOuter_get
 * Purpose:
 *      Get Fibre Channel outer header type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (OUT) Fibre Channel header type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FibreChanOuter_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_FibreChan_t *fibre_chan_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FibreChannInner_get
 * Purpose:
 *      Get Fibre Channel inner header type field qualification from a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry id.
 *      fibre_chan_type - (OUT) Fibre Channel header type.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FibreChanInner_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_FibreChan_t *fibre_chan_type)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VnTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyVnTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VnTag_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_CnTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyCnTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_CnTag_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FabricQueueTag_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyFabricQueueTag
 *      qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FabricQueueTag_get(
    int unit,
    bcm_field_entry_t entry,
    uint32 *data,
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcModPortGport_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifySrcModPortGport
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcModPortGport_get(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_gport_t *data)
{
    uint32 data_lcl;
    uint32 mask;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifySrcModPortGport,
                                                            &data_lcl,
                                                            &mask));
    *data = 0;

    if (mask) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        if (BCM_GPORT_IS_MODPORT(gport)) {
            *data = gport;
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SrcModuleGport_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifySrcModuleGport
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SrcModuleGport_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_gport_t *data)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_port_create_mode
 *   Purpose
 *      Create a new group that has the specified qualifier set and priority,
 *      and applies only to the specified port.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_port_t port = the port to which the group is to apply
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_field_group_mode_t mode = the group mode
 *      (out) bcm_field_group_t *group = where to put the group ID
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group (does
 *      this mean globally or within just the single stage?)
 *      Can not specify a qualifier that another group in the same stage has.
 *      If no stage qualifier, it is assumed to be ingress stage.
 *      Only supports mode bcmFieldGroupModeAuto.
 */
int
bcm_petra_field_group_port_create_mode(int unit,
                                        bcm_port_t port,
                                        bcm_field_qset_t qset,
                                        int pri,
                                        bcm_field_group_mode_t mode,
                                        bcm_field_group_t *group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_group_port_create_mode_id
 *   Purpose
 *      Create a new group with the specified ID that has the specified
 *      qualifier set and priority, and applies only to the specified port.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_port_t port = the port to which the group is to apply
 *      (in) bcm_field_qset_t qset = the qualifier set
 *      (in) int pri = the priority
 *      (in) bcm_field_group_mode_t mode = the group mode
 *      (in) bcm_field_group_t group = which group ID to use
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      Allocates first available group ID.
 *      Can not specify a priority already taken by an existing group.
 *      Can not specify a qualifier that another group in the same stage has.
 *      If no stage qualifier, it is assumed to be bcmFieldQualifyStageIngress.
 *      Only supports mode bcmFieldGroupModeAuto.
 */
int
bcm_petra_field_group_port_create_mode_id(int unit,
                                           bcm_port_t port,
                                           bcm_field_qset_t qset,
                                           int pri,
                                           bcm_field_group_mode_t mode,
                                           bcm_field_group_t group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/* Function: bcm_petra_field_group_wlan_create_mode
 *
 * Purpose:
 *     Create a wlan field group with a mode (single, double, etc.).
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_petra_field_group_wlan_create_mode(int unit, bcm_field_qset_t qset, int pri,
                                     bcm_field_group_mode_t mode,
                                     bcm_field_group_t *group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/* Function: bcm_petra_field_group_wlan_create_mode_id
 *
 * Purpose:
 *     Create a wlan field group with a mode (single, double, etc.).
 *
 * Parameters:
 *     unit - BCM device number.
 *     qset - Field qualifier set
 *     pri  - Priority within allowable range,
 *            or BCM_FIELD_GROUP_PRIO_ANY to automatically assign a
 *            priority; each priority value may be used only once
 *    mode  - Group mode (single, double, triple or Auto-wide)
 *    group - (OUT) field Group ID
 *
 * Returns:
 *     BCM_E_INIT      - BCM unit not initialized
 *     BCM_E_RESOURCE  - no select codes will satisfy qualifier set
 *     BCM_E_NONE      - Success
 */
int
bcm_petra_field_group_wlan_create_mode_id(int unit, bcm_field_qset_t qset, int pri,
                                        bcm_field_group_mode_t mode,
                                        bcm_field_group_t group)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_action_mac_add
 * Purpose:
 *      Add an action to a field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      action - (IN) Field action id.
 *      mac - (IN) Field action parameter.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_action_mac_add(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_mac_t mac)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_action_mac_get
 * Purpose:
 *      Retrieve the parameters for an action previously added to a
 *      field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) Field entry Id.
 *      action - (IN) Field action id.
 *      mac - (IN) Field action argument.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_action_mac_get(
    int unit,
    bcm_field_entry_t entry,
    bcm_field_action_t action,
    bcm_mac_t *mac)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FlowId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyFlowId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FlowId(int unit,
                               bcm_field_entry_t entry,
                               uint16 data,
                               uint16 mask)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t data_port, mask_port;

    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Get the encoding of Flow-Id 0*/
    BCM_GPORT_UNICAST_QUEUE_GROUP_SET(data_port, 0);
    mask_port = mask? (~0) : 0;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data_port,
                                                               mask_port,
                                                               &edata,
                                                               &emask));
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | data);
    /* Use the mask parameter for the 16 LSBs, emask for the rest */
    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, (COMPILER_64_LO(emask) & 0x60000) | mask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyFlowId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InVPort(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported - Use bcm_petra_field_qualify_InVPort32 instead of.\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutVPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyOutVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutVPort(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported - Use bcm_petra_field_qualify_OutVPort32 instead of.\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_FlowId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyFlowId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_FlowId_get(int unit,
                                   bcm_field_entry_t entry,
                                   uint16 *data,
                                   uint16 *mask)
{
    uint32 edata, emask;
    bcm_gport_t   gport;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyFlowId,
                                                            &edata,
                                                            &emask));
    *data = 0;
    *mask = 0;
    if (emask) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, edata, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), edata));

        /* Take only the 16b of the Queue-ID */
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
            *data = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport) & 0xFFFF;
            *mask = emask & 0xFFFF;
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InVPort_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported - Use bcm_petra_field_qualify_InVPort32_get instead of.\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutVPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOutVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutVPort_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported - Use bcm_petra_field_qualify_OutVPort32_get instead of.\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTunnelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelId(int unit,
                                 bcm_field_entry_t entry,
                                 uint32 data,
                                 uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTunnelId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelId_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 *data,
                                     uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTunnelId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_petra_field_qualify_MplsForwardingLabelAction32
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelAction
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsForwardingLabelAction32(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint32 data,
                                                   uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelAction,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsForwardingLabelAction32_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsForwardingLabelAction
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsForwardingLabelAction32_get(int unit,
                                                       bcm_field_entry_t entry,
                                                       uint32 *data,
                                                       uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsForwardingLabelAction,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsForwardingLabelId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsForwardingLabelId(int unit,
                                              bcm_field_entry_t entry,
                                              uint32 data,
                                              uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsForwardingLabelId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsForwardingLabelId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsForwardingLabelId_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  uint32 *data,
                                                  uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsForwardingLabelId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_SrcGport
 * Purpose:
 *     Add Source ModPort or MPLS/MiM/WLAN port qualification to a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (IN) Source Generic Logical port or virtual port id.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_petra_field_qualify_SrcGport(int unit,
                               bcm_field_entry_t entry,
                               bcm_gport_t mpls_port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_qualify_SrcGport_get
 * Purpose:
 *     Get Source ModPort or MPLS/MiM/WLAN gport value from a
 *     field entry.
 * Parameters:
 *     unit     - (IN) BCM device number
 *     entry    - (IN) Field Entry id.
 *     port_id  - (OUT) ModPort Gport or MPLS/MiM/WLAN Gport ID.
 * Returns:
 *      BCM_E_XXX
 */
int
bcm_petra_field_qualify_SrcGport_get(int unit,
                                   bcm_field_entry_t entry,
                                   bcm_gport_t *port_id)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *     bcm_petra_field_entry_operation
 * Purpose:
 *     Perform entry backup, restore and backup copy free operations
 * Parameters:
 *     unit       - (IN) BCM device number.
 *     entry_oper - (IN) Pointer to field entry operation structure
 * Returns:
 *     BCM_E_XXX
 */
int
bcm_petra_field_entry_operation(int unit, bcm_field_entry_oper_t *entry_oper)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PolicerIntPrio
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPolicerIntPrio
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PolicerIntPrio(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPolicerIntPrio,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PolicerIntPrio_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPolicerIntPrio
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PolicerIntPrio_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 *data,
                                           uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyPolicerIntPrio,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ptch
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPtch
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ptch(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPtch,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Ptch_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPtch
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Ptch_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 *data,
                                 uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyPtch,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2Learn
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2Learn
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2Learn(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 group_flags = 0;
    uint8 l2_learn_allowed = 0; /* Different values according to the stage */
    int L2LearnMode = 0;

    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));

    if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
        /* Only egress learning */
        l2_learn_allowed = 0x1;
    }
    else if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
        /* At ingress, retrieve if ingress or egress learning */
        BCMDNX_IF_ERR_EXIT(bcm_switch_control_get(unit, bcmSwitchL2LearnMode, &L2LearnMode)); 
        L2LearnMode &= ~BCM_L2_LEARN_DISABLE;
        if ((L2LearnMode == BCM_L2_INGRESS_CENT)
            || (L2LearnMode == BCM_L2_INGRESS_DIST)) {
            /* Ingress learning, bit 0 up, bit 1 down */
            l2_learn_allowed = 0x1;
        }
        else if ((L2LearnMode == BCM_L2_EGRESS_DIST)
                 || (L2LearnMode == BCM_L2_EGRESS_CENT)
                 || (L2LearnMode == BCM_L2_EGRESS_INDEPENDENT)) {
            /* Egress learning, bit 1 up, bit 0 down */
            l2_learn_allowed = 0x1 << 1;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG("The L2 learning mode get returned incoherent value %d \n"),
                              L2LearnMode));
        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                          group_flags));
    }

    if (mask) {
        COMPILER_64_SET(emask, 0, l2_learn_allowed);
        COMPILER_64_SET(edata, 0, (data? l2_learn_allowed:0));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2Learn,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2Learn_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2Learn
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2Learn_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{
    uint8 data_lcl;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL2Learn,
                                                           &data_lcl,
                                                           mask));
    *data = 0;
    if (*mask) {
        /* Data can be either 0x1 or 0x0 whether it was enable at some stage */
        *data = (data_lcl)? 0x1 : 0x0;
        *mask = 0x1;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PortOrientation
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPortOrientation
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PortOrientation(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 data,
                                        uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    if (mask) {
        /* 0 for network-oriented, 1 for hub-oriented */
        COMPILER_64_SET(edata, 0, (data == bcmFieldOrientationNetwork));
        COMPILER_64_SET(emask, 0, 1);
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPortOrientation,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PortOrientation_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPortOrientation
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PortOrientation_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint8 *data,
                                            uint8 *mask)
{
    uint8 edata, emask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyPortOrientation,
                                                           &edata,
                                                           &emask));
    if (emask) {
        *mask = 0x1;
        *data = (edata)?bcmFieldOrientationNetwork:bcmFieldOrientationAccess;
    }
    else {
        *mask = 0;
        *data = 0;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsBos
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsBos
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsBos(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsBos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsBos_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsBos
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsBos_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsBos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Dhcp
 * Purpose:
 *       Set match criteria for bcmFieldQualifyDhcp
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Dhcp(int unit,
                             bcm_field_entry_t entry,
                             uint8 data,
                             uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDhcp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Dhcp_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyDhcp
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_Dhcp_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 *data,
                                 uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyDhcp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_EcnValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyEcnValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EcnValue(int unit,
                                 bcm_field_entry_t entry,
                                 uint8 data,
                                 uint8 mask)
{
    uint64 edata;
    uint64 emask;
    uint8 is_cni, ecn_capable;
    uint32 group_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if ((0 != mask) && (0x3 != (mask & 0x3))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("only supports all or nothing mask (all"
                                   " bits set or all bits clear clear)")));
    }

    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    /*
     * ECN values: 0 - not supported, 1/2 - not congested, 3 - congested
     */
    if (mask) {
        is_cni = (data == 0x3);
        ecn_capable = (data)?0x1:0x0;
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_petra_field_entry_group_flags(unit,
                                                   entry,
                                                   &group_flags));

        if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
            /* At ingress: bit 0 for ECN-Capable, bit 1 for CNI */
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (ecn_capable << 0));
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (is_cni << 1));
            COMPILER_64_SET(emask, 0, 0x3);
        }
        else if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
            /* At egress: bit 0 for CNI */
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (is_cni << 0));
            COMPILER_64_SET(emask, 0, 0x1);
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                              group_flags));
        }
    }


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyEcnValue,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_EcnValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyEcnValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EcnValue_get(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 *data,
                                     uint8 *mask)
{
    uint8 edata;
    uint8 emask;
    uint32 group_flags = 0;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyEcnValue,
                                                           &edata,
                                                           &emask));

    *data = 0;
    *mask = 0;

    /*
     * ECN values: 0 - not supported, 1/2 - not congested, 3 - congested
     */
    if (emask) {
        *mask = 0x3;
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_petra_field_entry_group_flags(unit,
                                                   entry,
                                                   &group_flags));

        if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
            /* At ingress: bit 0 for ECN-Capable, bit 1 for CNI */
            if ((edata & 0x1) == 0) {
                *data = 0;
            }
            else if (edata & (0x1 << 1)) {
                *data = 3;
            }
            else {
                *data = 1;
            }
        }
        else if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
            /* When no congestion (no CNI), not clear how to interpret the data value whether ECN-Capable */
            *data = (edata & 0x1)?3:1;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                             (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                              group_flags));
        }
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpTunnelHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpTunnelHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpTunnelHit(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpTunnelHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpTunnelHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpTunnelHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpTunnelHit_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 *data,
                                        uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpTunnelHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcRouteHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3SrcRouteHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcRouteHit(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3SrcRouteHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcRouteHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3SrcRouteHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcRouteHit_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyL3SrcRouteHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcHit
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpmcHit
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcHit(int unit,
                                bcm_field_entry_t entry,
                                uint8 data,
                                uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpmcHit,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcHit_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpmcHit
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcHit_get(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 *data,
                                    uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIpmcHit,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SnoopCopy
 * Purpose:
 *       Set match criteria for bcmFieldQualifySnoopCopy
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SnoopCopy(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, 2); /* 2 - encoding in FTMH.TM-Action-Type for Snoop */
    COMPILER_64_SET(emask, 0, (mask? 0x3: 0));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifySnoopCopy,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_SnoopCopy_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifySnoopCopy
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_SnoopCopy_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data,
                                      uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifySnoopCopy,
                                                           data,
                                                           mask));
    *data = (*mask)? 1: 0;
    *mask = (*mask)? 1: 0;
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardCopy
 * Purpose:
 *       Set match criteria for bcmFieldQualifyForwardCopy
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardCopy(int unit,
                                    bcm_field_entry_t entry,
                                    uint8 data,
                                    uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, 0); /* 0 - encoding in FTMH.TM-Action-Type for Forwarding */
    COMPILER_64_SET(emask, 0, (mask? 0x3: 0));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardCopy,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardCopy_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyForwardCopy
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardCopy_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint8 *data,
                                        uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyForwardCopy,
                                                           data,
                                                           mask));
    *data = (*mask)? 1: 0;
    *mask = (*mask)? 1: 0;

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BypassFilter
 * Purpose:
 *       Set match criteria for bcmFieldQualifyBypassFilter
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassFilter(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyBypassFilter,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BypassFilter_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyBypassFilter
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassFilter_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyBypassFilter,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ReplicantAny
 * Purpose:
 *       Set match criteria for bcmFieldQualifyReplicantAny
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ReplicantAny(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyReplicantAny,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ReplicantAny_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyReplicantAny
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ReplicantAny_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyReplicantAny,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ReplicantFirst
 * Purpose:
 *       Set match criteria for bcmFieldQualifyReplicantFirst
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ReplicantFirst(int unit,
                                       bcm_field_entry_t entry,
                                       uint8 data,
                                       uint8 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyReplicantFirst,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ReplicantFirst_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyReplicantFirst
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ReplicantFirst_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint8 *data,
                                           uint8 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyReplicantFirst,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassVPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInterfaceClassVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassVPort(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 data,
                                            uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 mapped_data = 0;
    uint32 mapped_mask = 0;
    uint32 soc_sand_rv;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    /* Set the free bits in inlif profile to given values */
    soc_sand_rv = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_occ_mgmt_app_set,(unit, SOC_OCC_MGMT_TYPE_INLIF, SOC_OCC_MGMT_APP_USER, data, &mapped_data));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

    soc_sand_rv = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_occ_mgmt_app_set,(unit, SOC_OCC_MGMT_TYPE_INLIF, SOC_OCC_MGMT_APP_USER, mask, &mapped_mask));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

    COMPILER_64_SET(edata, 0, mapped_data);
    COMPILER_64_SET(emask, 0, mapped_mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInterfaceClassVPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassVPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassVPort_get(int unit,
                                                bcm_field_entry_t entry,
                                                uint32 *data,
                                                uint32 *mask)
{
    uint32 mapped_data;
    uint32 mapped_mask;
    uint32 soc_sand_rv;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInterfaceClassVPort,
                                                            &mapped_data,
                                                            &mapped_mask));

    /* Set the free bits in inlif profile to given values */
    soc_sand_rv = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_occ_mgmt_app_get,(unit, SOC_OCC_MGMT_TYPE_INLIF, SOC_OCC_MGMT_APP_USER, &mapped_data, data));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

    soc_sand_rv = MBCM_PP_DRIVER_CALL(unit,mbcm_pp_occ_mgmt_app_get,(unit, SOC_OCC_MGMT_TYPE_INLIF, SOC_OCC_MGMT_APP_USER, &mapped_mask, mask));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ISid
 * Purpose:
 *       Set match criteria for bcmFieldQualifyISid
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ISid(int unit,
                             bcm_field_entry_t entry,
                             uint32 data,
                             uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, ~0);

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && mask) {
        SOC_PPD_FRWRD_DECISION_INFO fwdDecision;

        /* Build the EEI encoding: Trill unicast nickname */
        SOC_PPD_FRWRD_DECISION_INFO_clear(&fwdDecision);
        fwdDecision.type = SOC_PPD_FRWRD_DECISION_TYPE_UC_FLOW;
        fwdDecision.dest_id = 0;
        fwdDecision.additional_info.outlif.type = SOC_PPD_OUTLIF_ENCODE_TYPE_NONE;
        fwdDecision.additional_info.eei.type = SOC_PPD_EEI_TYPE_MIM;
        fwdDecision.additional_info.eei.val.isid = data;

        /* Encode the Nickname into EEI */
        /* Get the HW Destination from the Forward decision */
        BCMDNX_IF_ERR_EXIT_MSG(
            _bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(unit,
                                                                          &fwdDecision,
                                                                          FALSE, /* is_for_destination */
                                                                          FALSE, /* is_for_action */
                                                                          &edata,
                                                                          &emask),
                            (_BSL_BCM_MSG("unable to get from the forward decision the HW data")));
        /* All the MSBs are significant, only the 16 LSBs can be masked */
        COMPILER_64_SET(emask, 0, (0xFF << 16) | mask);
    }
#endif /* BCM_ARAD_SUPPORT */


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyISid,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ISid_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyISid
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ISid_get(int unit,
                                 bcm_field_entry_t entry,
                                 uint32 *data,
                                 uint32 *mask)
{
    uint32 edata, emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyISid,
                                                            &edata,
                                                            &emask));

    *data = 0;
    *mask = 0;

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && emask) {
        SOC_PPD_FRWRD_DECISION_INFO fwdDecision;

        /* Decode the EEI to nickname */
        SOC_PPD_FRWRD_DECISION_INFO_clear(&fwdDecision);
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_field_qualify_fwd_decision_from_hw_convert(unit,
                                                                FALSE, /* is_for_destination */
                                                                edata,
                                                                ARAD_PP_FWD_DECISION_PARSE_DEST | ARAD_PP_FWD_DECISION_PARSE_EEI | ARAD_PP_FWD_DECISION_PARSE_EEI_MIM,
                                                                &fwdDecision));

        if (fwdDecision.additional_info.eei.type == SOC_PPD_EEI_TYPE_MIM) {
            *data = fwdDecision.additional_info.eei.val.isid;
            /* Return only the Nickname mask */
            *mask = emask & ((1 << 16) - 1);
        }
    }
#endif /* BCM_ARAD_SUPPORT */

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TrillEgressRbridge
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTrillEgressRbridge
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrillEgressRbridge(int unit,
                                           bcm_field_entry_t entry,
                                           uint32 data,
                                           uint32 mask)
{
    uint64 edata;
    uint64 emask;

    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, ~0);


#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && mask) {
        SOC_PPD_FRWRD_DECISION_INFO fwdDecision;

        /* Build the EEI encoding: Trill unicast nickname */
        SOC_PPD_FRWRD_DECISION_INFO_clear(&fwdDecision);
        fwdDecision.type = SOC_PPD_FRWRD_DECISION_TYPE_UC_FLOW;
        fwdDecision.dest_id = 0;
        fwdDecision.additional_info.outlif.type = SOC_PPD_OUTLIF_ENCODE_TYPE_NONE;
        fwdDecision.additional_info.eei.type = SOC_PPD_EEI_TYPE_TRILL;
        fwdDecision.additional_info.eei.val.trill_dest.is_multicast = 0;
        fwdDecision.additional_info.eei.val.trill_dest.dest_nick = data;

        /* Encode the Nickname into EEI */
        /* Get the HW Destination from the Forward decision */
        BCMDNX_IF_ERR_EXIT_MSG(
            _bcm_dpp_field_qualify_fwd_decision_to_hw_destination_convert(unit,
                                                                          &fwdDecision,
                                                                          FALSE, /* is_for_destination */
                                                                          FALSE, /* is_for_action */
                                                                          &edata,
                                                                          &emask),
                            (_BSL_BCM_MSG("unable to get from the forward decision the HW data")));
        /* All the 8 MSBs are significant, only the 16 LSBs can be masked */
        COMPILER_64_SET(emask, 0, (0xFF << ARAD_PP_ASD_NOF_BITS_TRILL_NICK) | mask);
    }
#endif /* BCM_ARAD_SUPPORT */

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTrillEgressRbridge,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TrillEgressRbridge_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTrillEgressRbridge
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrillEgressRbridge_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    uint32 edata, emask;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTrillEgressRbridge,
                                                            &edata,
                                                            &emask));

    *data = 0;
    *mask = 0;

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && emask) {
        SOC_PPD_FRWRD_DECISION_INFO fwdDecision;

        /* Decode the EEI to nickname */
        SOC_PPD_FRWRD_DECISION_INFO_clear(&fwdDecision);
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_field_qualify_fwd_decision_from_hw_convert(unit,
                                                                FALSE, /* is_for_destination */
                                                                edata,
                                                                ARAD_PP_FWD_DECISION_PARSE_DEST | ARAD_PP_FWD_DECISION_PARSE_EEI,
                                                                &fwdDecision));

        if (fwdDecision.additional_info.eei.type == SOC_PPD_EEI_TYPE_TRILL) {
            *data = fwdDecision.additional_info.eei.val.trill_dest.dest_nick;
            /* Return only the Nickname mask */
            *mask = emask & ((1 << ARAD_PP_ASD_NOF_BITS_TRILL_NICK) - 1);
        }

    }
#endif /* BCM_ARAD_SUPPORT */


exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketTerminatedBytes
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPacketTerminatedBytes
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketTerminatedBytes(int unit,
                                              bcm_field_entry_t entry,
                                              uint32 data,
                                              uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPacketTerminatedBytes,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketTerminatedBytes_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPacketTerminatedBytes
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketTerminatedBytes_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  uint32 *data,
                                                  uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyPacketTerminatedBytes,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TrunkHashResult
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTrunkHashResult
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrunkHashResult(int unit,
                                        bcm_field_entry_t entry,
                                        uint32 data,
                                        uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTrunkHashResult,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TrunkHashResult_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTrunkHashResult
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrunkHashResult_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 *data,
                                            uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTrunkHashResult,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketSize
 * Purpose:
 *       Set match criteria for bcmFieldQualifyPacketSize
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketSize(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyPacketSize,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_PacketSize_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyPacketSize
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_PacketSize_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint32 *data,
                                            uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyPacketSize,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassProcessingPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInterfaceClassProcessingPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassProcessingPort(int unit,
                                                     bcm_field_entry_t entry,
                                                     uint64 data,
                                                     uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInterfaceClassProcessingPort,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceClassProcessingPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInterfaceClassProcessingPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceClassProcessingPort_get(int unit,
                                                         bcm_field_entry_t entry,
                                                         uint64 *data,
                                                         uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInterfaceClassProcessingPort,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanTranslationValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyVlanTranslationValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanTranslationValue(int unit,
                                             bcm_field_entry_t entry,
                                             uint64 data,
                                             uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyVlanTranslationValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_VlanTranslationValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyVlanTranslationValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_VlanTranslationValue_get(int unit,
                                                 bcm_field_entry_t entry,
                                                 uint64 *data,
                                                 uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyVlanTranslationValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminatedValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTunnelTerminatedValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminatedValue(int unit,
                                              bcm_field_entry_t entry,
                                              uint64 data,
                                              uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTunnelTerminatedValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TunnelTerminatedValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTunnelTerminatedValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TunnelTerminatedValue_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  uint64 *data,
                                                  uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTunnelTerminatedValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsTerminatedValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsTerminatedValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsTerminatedValue(int unit,
                                            bcm_field_entry_t entry,
                                            uint64 data,
                                            uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsTerminatedValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsTerminatedValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsTerminatedValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsTerminatedValue_get(int unit,
                                                bcm_field_entry_t entry,
                                                uint64 *data,
                                                uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsTerminatedValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpTunnelValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpTunnelValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpTunnelValue(int unit,
                                      bcm_field_entry_t entry,
                                      uint64 data,
                                      uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpTunnelValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpTunnelValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpTunnelValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpTunnelValue_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint64 *data,
                                          uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyIpTunnelValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2DestValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2DestValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2DestValue(int unit,
                                    bcm_field_entry_t entry,
                                    uint64 data,
                                    uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2DestValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2DestValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2DestValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2DestValue_get(int unit,
                                        bcm_field_entry_t entry,
                                        uint64 *data,
                                        uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL2DestValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL2SrcValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcValue(int unit,
                                   bcm_field_entry_t entry,
                                   uint64 data,
                                   uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL2SrcValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L2SrcValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL2SrcValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L2SrcValue_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint64 *data,
                                       uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL2SrcValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestRouteValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3DestRouteValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestRouteValue(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 data,
                                         uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3DestRouteValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3DestRouteValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3DestRouteValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3DestRouteValue_get(int unit,
                                             bcm_field_entry_t entry,
                                             uint64 *data,
                                             uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL3DestRouteValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcRouteValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyL3SrcRouteValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcRouteValue(int unit,
                                        bcm_field_entry_t entry,
                                        uint64 data,
                                        uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyL3SrcRouteValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_L3SrcRouteValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyL3SrcRouteValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_L3SrcRouteValue_get(int unit,
                                            bcm_field_entry_t entry,
                                            uint64 *data,
                                            uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyL3SrcRouteValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcValue
 * Purpose:
 *       Set match criteria for bcmFieldQualifyIpmcValue
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcValue(int unit,
                                  bcm_field_entry_t entry,
                                  uint64 data,
                                  uint64 mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIpmcValue,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_IpmcValue_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyIpmcValue
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcValue_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint64 *data,
                                      uint64 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyIpmcValue,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstRpfGport
 * Purpose:
 *       Set match criteria for bcmFieldQualifyDstRpfGport
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstRpfGport(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_gport_t data)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t mask = ~0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));
    /* Limit to 19b at ingress */
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x7FFFF);

    /* Indicate this port is valid */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0x80000);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0x80000);


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstRpfGport,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_DstRpfGport_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyDstRpfGport
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_DstRpfGport_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_gport_t *data)
{
    uint64 data_lcl, mask;
    _bcm_dpp_field_info_t *unitData;

    BCMDNX_INIT_FUNC_DEFS;

    _DPP_FIELD_UNIT_CHECK(unit, unitData);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_get(unit,
                                                               entry,
                                                               bcmFieldQualifyDstRpfGport,
                                                               1, /* count*/
                                                               &data_lcl,
                                                               &mask));
    *data = 0;
    if ((COMPILER_64_LO(mask) & 0x80000) & (COMPILER_64_LO(data_lcl) & 0x80000)) {
        /* RPF destination valid */
        if (COMPILER_64_LO(mask)) {
            BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, COMPILER_64_LO(data_lcl) & 0x7FFFF, data),
                                (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), COMPILER_64_LO(data_lcl)));
        }

    }


exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_RxTrapCode
 * Purpose:
 *       Set match criteria for bcmFieldQualifyRxTrapCode
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapCode(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_rx_trap_t data)
{
    uint64 edata;
    uint64 emask;
    uint32 hwTrapId = ~0; /* invalid by default */
    uint32 hwTrapMask[1] = {0xFF}; /* single trap by default */
    int soc_ppd_trap_id;
    uint32 group_flags = 0;
    unsigned int soc_sand_dev_id;
    uint32 soc_sand_rv;
    uint32 soc_ppd_trap_bitmap_id;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Do not support User-define traps, since the ID is unknown */
    if (data == bcmRxTrapUserDefine) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_BADID, (_BSL_BCM_MSG_NO_UNIT("the BCM Trap type User-define is not supported since its ID is unknown")));
    }

    /*
     * Get the conversion from BCM trap type to the PPD trap id
     * Then from the PPD Trap Id to HW Trap Id
     */

    /* 
     * Special case for L2CP virtual traps: can be Reserve-Multicast 
     * (8 traps) or programmable-traps (4 traps). 
     * Since the ID is not input of the function, mask all the relevant 
     * traps using the TCAM mask. 
     * Give a SOC property to indicate which one to mask. 
     */
    if (data == bcmRxTrapL2Cache) {
        if (soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "trap_l2_cache_field_reserve_mc_hit", 0)) {
            soc_ppd_trap_id = SOC_PPD_TRAP_CODE_RESERVED_MC_0;
            SHR_BITCLR_RANGE(hwTrapMask, 0, 3); /* 8 traps */
        }
        else {
            soc_ppd_trap_id = SOC_PPD_TRAP_CODE_PROG_TRAP_0;
            /* 
             * There are 4 programmable traps, but they are not aligned to 0x4 to allow a decent masking 
             * Thus, mask only on the 2 first  programmable traps. 
             */ 
            SHR_BITCLR_RANGE(hwTrapMask, 0, 1); 
        }
    }
    else {
        /* BCM to PPD trap */
        _bcm_dpp_rx_ppd_trap_get(unit, data, &soc_ppd_trap_id);
    }

    /*
     * Different mapping between Ingress and Egress
     */
    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));
    if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
        /* At egress, get the action profile ID */
        soc_sand_dev_id = (unit);
        /* since soc_ppd_trap_to_eg_action_map_get expects the trap bitmap value, we convert the egress ppd trap id to it's bitmap value */
        soc_ppd_trap_bitmap_id = _bcm_dpp_rx_trap_id_to_egress(soc_ppd_trap_id);
        soc_sand_rv = soc_ppd_trap_to_eg_action_map_get(soc_sand_dev_id, soc_ppd_trap_bitmap_id, &hwTrapId);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
        
        if (hwTrapId == ARAD_PP_TRAP_EG_NO_ACTION) {
            /* Error - trap not configured */
           BCMDNX_ERR_EXIT_MSG(BCM_E_BADID,
                          ( _BSL_BCM_MSG_NO_UNIT("unable to get a valid egress action profile form the PPD trap Code")));

        }
        hwTrapId = (1<<3)|(hwTrapId); /*{ Action-Profile-Index (1b), Action-Profile-Valid (3b) }*/
        hwTrapMask[0] = 0xF; /* 4 bits for { Action-Profile-Index (1b), Action-Profile-Valid (3b) }*/
    }
    if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_trap_ppd_to_hw(unit, soc_ppd_trap_id, &hwTrapId),
                                (_BSL_BCM_MSG_NO_UNIT("unable to get from the HW Trap Id for PPD trap Id %d (%s)"),
                                 soc_ppd_trap_id,
                                 SOC_PPD_TRAP_CODE_to_string(soc_ppd_trap_id)));
    }
    COMPILER_64_SET(edata, 0, hwTrapId);
    COMPILER_64_SET(emask, 0, *hwTrapMask);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyRxTrapCode,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_RxTrapCode_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyRxTrapCode
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapCode_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_rx_trap_t *data)
{
    uint32 hwTrap;
    uint32 mask;
    uint8 found;
    uint32 ppdTrapCode = 0;
    uint32 group_flags = 0;
    unsigned int soc_sand_dev_id;
    uint32 soc_sand_rv;
    uint32 hwTrapId = ~0;
    SOC_PPC_TRAP_EG_TYPE ppdTrapCode_next;
    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyRxTrapCode,
                                                            &hwTrap,
                                                            &mask));
    *data = bcmRxTrapCount;

    if (mask) {
        /*
         * Get the conversion to BCM trap type from the PPD trap id
         * after to the PPD Trap Id from HW Trap Id
         */
        /*
         * Different mapping between Ingress and Egress
         */
        BCMDNX_IF_ERR_EXIT(
            _bcm_dpp_petra_field_entry_group_flags(unit,
                                                   entry,
                                                   &group_flags));
        if (group_flags & _BCM_DPP_FIELD_GROUP_EGRESS) {
            /* At egress, get the action profile ID */
            soc_sand_dev_id = (unit);
            hwTrap = hwTrap & 0x7; /*  The 4th bit is the valid bit : { Action-Profile-Index (1b), Action-Profile-Valid (3b) } */
            for (ppdTrapCode = 0; ppdTrapCode < SOC_PPC_TRAP_EG_TYPE_HIGHEST_ARAD ;) {
                soc_sand_rv = soc_ppd_trap_to_eg_action_map_get(soc_sand_dev_id, ppdTrapCode, &hwTrapId);
                BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
                if (hwTrapId == hwTrap) {
                    break;
                }

                /* increase statement */
                 BCMDNX_IF_ERR_EXIT(_bcm_dpp_rx_get_next_eg_soc_ppc_trap((SOC_PPC_TRAP_EG_TYPE)ppdTrapCode,&ppdTrapCode_next));
                 ppdTrapCode = ppdTrapCode_next;
 
            }
            if (hwTrapId != hwTrap) {
                LOG_ERROR(BSL_LS_BCM_FP,
                          (BSL_META_U(unit,
                                      "unit %d entry %d has a HW Trap ID %d not valid\n"),  unit,  entry, hwTrap));
            }
        }

        /* converting the ppdTrapCode to it's egress trap id */
        ppdTrapCode = _BCM_TRAP_EG_TYPE_TO_ID(ppdTrapCode);

        if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) {
            BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_trap_ppd_from_hw(unit, hwTrap, &ppdTrapCode),
                                (_BSL_BCM_MSG_NO_UNIT("unable to get from the HW Trap Id %d the PPD trap Id"),
                                 hwTrap));
        }
        _bcm_dpp_rx_trap_type_get(unit, ppdTrapCode, &found, data);
        if (!found) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_BADID,
                             (_BSL_BCM_MSG_NO_UNIT("unable to get from the PPD trap Code %d (%s) the BCM Trap type"),
                             ppdTrapCode,
                              SOC_PPD_TRAP_CODE_to_string(ppdTrapCode)));
        }
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_LearnSrcMac
 *   Purpose
 *      Set learnt MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_LearnSrcMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyLearnSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_LearnSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyLearnSrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnSrcMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyLearnSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_ForwardHdrSrcMac
 * Purpose:
 *      Set match criteria for bcmFieldQualifyForwardHdrSrcMac
 *              qualifier in the field entry.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_ForwardHdrSrcMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyForwardHdrSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardHdrSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardHdrSrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardHdrSrcMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyForwardHdrSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_ForwardHdrDstMac
 * Purpose:
 *      Set match criteria for bcmFieldQualifyForwardHdrDstMac
 *              qualifier in the field entry.
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_ForwardHdrDstMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyForwardHdrDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}
/*
 * Function:
 *      bcm_petra_field_qualify_ForwardHdrDstMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyForwardHdrDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardHdrDstMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyForwardHdrDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}
/*
 *   Function
 *      bcm_petra_field_qualify_LearnVlan
 *   Purpose
 *      Set learnt VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VLAN tag (16 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM API docs neglect to metion that this function applies to the entire
 *      tag, rather than just the VID.
 */
int
bcm_petra_field_qualify_LearnVlan(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_vlan_t data,
                                  bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyLearnVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_LearnVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyLearnVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnVlan_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_vlan_t *data,
                                      bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyLearnVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_LearnSrcPort
 * Purpose:
 *       Set match criteria for bcmFieldQualifyLearnSrcPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnSrcPort(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_gport_t data)
{
    uint64 edata;
    uint64 emask;
    bcm_gport_t mask = ~0;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_field_qualify_gport_to_hw_destination_convert(unit,
                                                               data,
                                                               mask,
                                                               &edata,
                                                               &emask));

    /*
     * Limit to 16 bits since it is only Source-System-Port
     * In Jericho, the learn-data has the Arad encoding. Thus edata[18:16] is not correct
     * However, only the 16b of the Source-System-Port are qualified and these bits are not used.
     */
    COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) & 0xFFFF);
    COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) & 0xFFFF);


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyLearnSrcPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_LearnSrcPort_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyLearnSrcPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match gport.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnSrcPort_get(int unit,
                                         bcm_field_entry_t entry,
                                         bcm_gport_t *data)
{
    uint32 data_lcl;
    uint32 mask;
    bcm_gport_t gport;

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyLearnSrcPort,
                                                            &data_lcl,
                                                            &mask));
    *data = 0;

    if (mask) {
#ifdef BCM_ARAD_SUPPORT
        /* Add to data_lcl DSPA encoding per device [18:16]. Under ARAD_SUPPORT*/
        if (SOC_IS_JERICHO(unit))
            data_lcl += ARAD_PP_DEST_ENCODED_PREFIX_TYPE_0001 << 16;
        else
            data_lcl += ARAD_PP_DEST_ENCODED_PREFIX_TYPE_0100 << 16;
#endif

        BCMDNX_IF_ERR_EXIT_MSG(_bcm_dpp_field_qualify_gport_from_hw_destination_convert(unit, data_lcl, &gport),
                            (_BSL_BCM_MSG("unable to get the gport with HW Destination %d"), data_lcl));

        *data = gport;
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BypassFilter32
 * Purpose:
 *       Set match criteria for bcmFieldQualifyBypassFilter
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassFilter32(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 data,
                                       uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    COMPILER_64_SET(edata, 0, 0);
    COMPILER_64_SET(emask, 0, 0);

    /* bit 0 for bypass all, bit 1 for exclude source only */
    if ((mask & BCM_FIELD_FILTER_ALL) == BCM_FIELD_FILTER_ALL) {
        if ((data & BCM_FIELD_FILTER_ALL) == BCM_FIELD_FILTER_ALL) {
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 0));
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 1));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 0));
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 1));
    }
    if ((mask & BCM_FIELD_FILTER_BYPASS_ALL) == BCM_FIELD_FILTER_BYPASS_ALL) {
        if ((data & BCM_FIELD_FILTER_BYPASS_ALL) == BCM_FIELD_FILTER_BYPASS_ALL) {
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 0));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 0));
    }
    if ((mask & BCM_FIELD_FILTER_SA_DISABLED) == BCM_FIELD_FILTER_SA_DISABLED) {
        if ((data & BCM_FIELD_FILTER_SA_DISABLED) == BCM_FIELD_FILTER_SA_DISABLED) {
            COMPILER_64_SET(edata, 0, COMPILER_64_LO(edata) | (0x1 << 1));
        }
        COMPILER_64_SET(emask, 0, COMPILER_64_LO(emask) | (0x1 << 1));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyBypassFilter,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_BypassFilter32_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyBypassFilter
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassFilter32_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint32 *data,
                                           uint32 *mask)
{
    uint8 edata, emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyBypassFilter,
                                                           &edata,
                                                           &emask));
    *data = 0;
    *mask = 0;

    /* bit 0 for bypass all , bit 1 for exclude source only */
    if (emask & 0x1) {
        if (edata & 0x1) {
            *data += BCM_FIELD_FILTER_BYPASS_ALL;
        }
        *mask += BCM_FIELD_FILTER_BYPASS_ALL;
    }

    if (emask & (0x1 << 1)) {
        if (edata & (0x1 << 1)) {
            *data += BCM_FIELD_FILTER_SA_DISABLED;
        }
        *mask += BCM_FIELD_FILTER_SA_DISABLED;
    }

    if ((emask & 0x1) && (emask & (0x1 << 1))) {
        if ((edata & 0x1) && (edata & (0x1 << 1))) {
            *data += BCM_FIELD_FILTER_ALL;
        }
        *mask += BCM_FIELD_FILTER_ALL;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPort32
 * Purpose:
 *       Set match criteria for bcmFieldQualifyInVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InVPort32(int unit,
                                  bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 lif;
    int result;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Verify if data is in a gport form */
    if (BCM_GPORT_IS_SET(data)) {
        result = _bcm_dpp_field_gport_to_lif_convert(unit,
                                                     data,
                                                     TRUE,
                                                     &lif);
        BCMDNX_IF_ERR_EXIT(result);
        COMPILER_64_SET(edata, 0, lif);
    }
    else {
        COMPILER_64_SET(edata, 0, data);
    }
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInVPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutVPort32
 * Purpose:
 *       Set match criteria for bcmFieldQualifyOutVPort
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutVPort32(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 lif;
    int result;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Verify if data is in a gport form */
    if (BCM_GPORT_IS_SET(data)) {
        result = _bcm_dpp_field_gport_to_lif_convert(unit,
                                                     data,
                                                     FALSE,
                                                     &lif);
        BCMDNX_IF_ERR_EXIT(result);
        COMPILER_64_SET(edata, 0, lif);
    }
    else {
        COMPILER_64_SET(edata, 0, data);
    }

    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOutVPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPort32_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyInVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InVPort32_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint32 *data,
                                      uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInVPort,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_OutVPort32_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyOutVPort
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OutVPort32_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOutVPort,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_RxTrapData
 * Purpose:
 *       Set match criteria for bcmFieldQualifyRxTrapData
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapData(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyRxTrapData,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_RxTrapData_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyRxTrapData
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapData_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyRxTrapData,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InnerDstMac
 *   Purpose
 *      Set expected inner destination MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which inner destination MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InnerDstMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyInnerDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerDstMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerDstMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerDstMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyInnerDstMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InnerSrcMac
 *   Purpose
 *      Set expected inner source MAC address for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_mac_t data = which inner source MAC address
 *      (in) bcm_mac_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InnerSrcMac(int unit,
                                    bcm_field_entry_t entry,
                                    bcm_mac_t data,
                                    bcm_mac_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_set(unit,
                                                             entry,
                                                             bcmFieldQualifyInnerSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerSrcMac_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerSrcMac
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerSrcMac_get(int unit,
                                        bcm_field_entry_t entry,
                                        bcm_mac_t *data,
                                        bcm_mac_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_macaddr_get(unit,
                                                             entry,
                                                             bcmFieldQualifyInnerSrcMac,
                                                             data,
                                                             mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_InnerEtherType
 *   Purpose
 *      Set expected inner ethernet type for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) uint16 data = which ethertype
 *      (in) uint16 mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InnerEtherType(int unit,
                                       bcm_field_entry_t entry,
                                       uint16 data,
                                       uint16 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerEtherType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InnerEtherType_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInnerEtherType
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InnerEtherType_get(int unit,
                                           bcm_field_entry_t entry,
                                           uint16 *data,
                                           uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerEtherType,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel1,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Ttl(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1Ttl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Ttl_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel1Ttl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Bos(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1Bos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Bos_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel1Bos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Exp(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1Exp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel1Exp_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel1Exp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel1Id
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel1Id(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel1Id,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel1Id_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsLabel1Id
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel1Id_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel1Id,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel2,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Ttl(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2Ttl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Ttl_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel2Ttl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Bos(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2Bos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Bos_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel2Bos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Exp(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2Exp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel2Exp_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel2Exp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel2Id
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel2Id(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel2Id,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel2Id_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsLabel2Id
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel2Id_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel2Id,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3(int unit,
                                   bcm_field_entry_t entry,
                                   uint32 data,
                                   uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3_get(int unit,
                                       bcm_field_entry_t entry,
                                       uint32 *data,
                                       uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel3,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Ttl(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3Ttl,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Ttl_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel3Ttl,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Bos(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3Bos,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Bos_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel3Bos,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Exp(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 data,
                                      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3Exp,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_field_qualify_MplsLabel3Exp_get(int unit,
                                          bcm_field_entry_t entry,
                                          uint8 *data,
                                          uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsLabel3Exp,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel3Id
 * Purpose:
 *       Set match criteria for bcmFieldQualifyMplsForwardingLabelId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel3Id(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsLabel3Id,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MplsLabel3Id_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyMplsLabel3Id
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsLabel3Id_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyMplsLabel3Id,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Stage
 * Purpose:
 *       Set match criteria for bcmFieldQualifyStage
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *   Internally, the stage value is the index of the proper stage.  It is
 *   converted to the PPD value when committed to the PPD; it is converted to
 *   the BCM value on read from BCM layer.
 */
int
bcm_petra_field_qualify_Stage(int unit,
                              bcm_field_entry_t entry,
                              bcm_field_stage_t data)
{
    _bcm_dpp_field_info_t *unitData;
    uint64 edata;
    uint64 emask;
    unsigned int stage;
    BCMDNX_INIT_FUNC_DEFS;


    _BCM_DPP_SWITCH_API_START(unit);
    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    /* look for a stage that meets the caller's criterion */
    for (stage = 0;
         stage < unitData->devInfo->stages;
         stage++) {
        if (data == unitData->stageD[stage].devInfo->bcmStage) {
            /* found the stage the caller wants */
            break;
        }
    }
    if (stage < unitData->devInfo->stages) {
        /* found the expected stage; use it */
        COMPILER_64_SET(edata, 0, stage);
        COMPILER_64_SET(emask, ~0, ~0);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                   bcmFieldQualifyStage,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    } else { /* if (stage < unitData->devInfo->stages) */
        /* was unable to find a matching stage */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("stage %s (%d) is not supported"),
                          ((0 < data) && (bcmFieldStageCount > data))?_bcm_dpp_field_stage_name[data]:"-",
                          data));
    } /* if (stage < unitData->devInfo->stages) */
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_Stage_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyStage
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 *   Internally, the stage value is the index of the proper stage.  It is
 *   converted to the PPD value when committed to the PPD; it is converted to
 *   the BCM value on read from BCM layer.
 */
int
bcm_petra_field_qualify_Stage_get(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_stage_t *stage)
{
    _bcm_dpp_field_info_t *unitData;
    uint32 edata;
    uint32 emask;
    BCMDNX_INIT_FUNC_DEFS;


    _DPP_FIELD_UNIT_CHECK(unit, unitData);
    if (!stage) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("obligatory OUT argument must not be NULL")));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyStage,
                                                            &edata,
                                                            &emask));
    if (!emask) {
        /* the stage qualifier is only valid if it matters, else claim none */
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                         (_BSL_BCM_MSG("entry %d does not have %s (%d) qualifier"),
                          entry,
                          _bcm_dpp_field_qual_name[bcmFieldQualifyStage],
                          bcmFieldQualifyStage));
    }
    if (unitData->devInfo->stages <= edata) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                         (_BSL_BCM_MSG("entry %d stage value incnsistent: %d but"
                                   " max internally allowed value is %d"),
                          entry,
                          edata,
                          unitData->devInfo->stages));
    }
    *stage = unitData->stageD[edata].devInfo->bcmStage;
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpSenderIp4
 * Purpose:
 *       Set match criteria for bcmFieldQualifyArpSenderIp4
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpSenderIp4(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyArpSenderIp4,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpSenderIp4_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyArpSenderIp4
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpSenderIp4_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyArpSenderIp4,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpTargetIp4
 * Purpose:
 *       Set match criteria for bcmFieldQualifyArpTargetIp4
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpTargetIp4(int unit,
                                     bcm_field_entry_t entry,
                                     uint32 data,
                                     uint32 mask)
{/* Created automatically by script */
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyArpTargetIp4,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpTargetIp4_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyArpTargetIp4
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpTargetIp4_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint32 *data,
                                         uint32 *mask)
{/* Created automatically by script */
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyArpTargetIp4,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpOpcode
 * Purpose:
 *       Set match criteria for bcmFieldQualifyArpOpcode
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpOpcode(int unit,
                                  bcm_field_entry_t entry,
                                  bcm_field_ArpOpcode_t data)
{
    uint64 edata;
    uint64 emask;
    uint32 ppdData, mask = (1 << 16) - 1;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_arp_opcode_bcm_to_ppd(data, &ppdData));
    COMPILER_64_SET(edata, 0, ppdData);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyArpOpcode,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ArpOpcode_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyArpOpcode
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ArpOpcode_get(int unit,
                                      bcm_field_entry_t entry,
                                      bcm_field_ArpOpcode_t *data)
{
    uint32 emask, edata;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyArpOpcode,
                                                            &edata,
                                                            &emask));
    *data = bcmFieldArpOpcodeCount;
    if (emask) {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_arp_opcode_ppd_to_bcm(edata, data));
    }
    
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_TranslatedOuterVlan
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VLAN tag (16 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 *      BCM API docs neglect to metion that this function applies to the entire
 *      tag, rather than just the VID.
 */
int
bcm_petra_field_qualify_TranslatedOuterVlan(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_vlan_t data,
                                            bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedOuterVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTranslatedOuterVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlan_get(int unit,
                                                bcm_field_entry_t entry,
                                                bcm_vlan_t *data,
                                                bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTranslatedOuterVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 *   Function
 *      bcm_petra_field_qualify_TranslatedOuterVlanId
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which VID (12 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanId(int unit,
                                              bcm_field_entry_t entry,
                                              bcm_vlan_t data,
                                              bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedOuterVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedOuterVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanId_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  bcm_vlan_t *data,
                                                  bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTranslatedOuterVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


int bcm_petra_field_qualify_OuterVlanPriCfi(
      int unit,
      bcm_field_entry_t entry,
      uint8 data,
      uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanPriCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_field_qualify_OuterVlanPriCfi_get(
      int unit,
      bcm_field_entry_t entry,
      uint8 *data,
      uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOuterVlanPriCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 *   Function
 *      bcm_petra_field_qualify_TranslatedOuterVlanPri
 *   Purpose
 *      Set expected outer VLAN for this entry
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_vlan_t data = which Pri (3 bits)
 *      (in) bcm_vlan_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanPri(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedOuterVlanPri,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedOuterVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanPri_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTranslatedOuterVlanPri,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTranslatedOuterVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanCfi(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedOuterVlanCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedOuterVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedOuterVlanCfi_get
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedOuterVlanCfi_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTranslatedOuterVlanCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlan
 * Purpose:
 *      Set match criteria for bcmFieldQualifyTranslatedInnerVlan
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlan(int unit,
                                            bcm_field_entry_t entry,
                                            bcm_vlan_t data,
                                            bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedInnerVlan,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlan_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyTranslatedInnerVlan
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlan_get(int unit,
                                                bcm_field_entry_t entry,
                                                bcm_vlan_t *data,
                                                bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTranslatedInnerVlan,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanId
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTranslatedInnerVlanId
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanId(int unit,
                                              bcm_field_entry_t entry,
                                              bcm_vlan_t data,
                                              bcm_vlan_t mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedInnerVlanId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanId_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedInnerVlanId
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanId_get(int unit,
                                                  bcm_field_entry_t entry,
                                                  bcm_vlan_t *data,
                                                  bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyTranslatedInnerVlanId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanPri
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTranslatedInnerVlanPri
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanPri(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedInnerVlanPri,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanPri_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedInnerVlanPri
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanPri_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTranslatedInnerVlanPri,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanCfi
 * Purpose:
 *       Set match criteria for bcmFieldQualifyTranslatedInnerVlanCfi
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanCfi(int unit,
                                               bcm_field_entry_t entry,
                                               uint8 data,
                                               uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyTranslatedInnerVlanCfi,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_TranslatedInnerVlanCfi_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyTranslatedInnerVlanCfi
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TranslatedInnerVlanCfi_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   uint8 *data,
                                                   uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyTranslatedInnerVlanCfi,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingHeaderOffset
 * Purpose:
 *       Set match criteria for bcmFieldQualifyForwardingHeaderOffset
 *                       qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      base_header - (IN) Qualifier base header.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingHeaderOffset(int unit,
                                               bcm_field_entry_t entry,
                                               bcm_field_data_offset_base_t base_header,
                                               uint32 data,
                                               uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 data_u32[2] = {0, 0};
    uint32 mask_u32[2] = {0, 0};
    uint32 ppd_base_header, ppd_base_header_mask = (~0);
    unsigned int count = 1;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    /* Get the correct ppd base header */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_base_header_bcm_to_ppd(base_header, &ppd_base_header));
    SHR_BITCOPY_RANGE(data_u32, (8*6) /* Size of the Offset-headers */, &ppd_base_header, 0, 3 /* copy 3 bits */);
    SHR_BITCOPY_RANGE(mask_u32, (8*6) /* Size of the Offset-headers */, &ppd_base_header_mask, 0, 3 /* copy 3 bits */);
    /* Set the correct offset accordingly */
    SHR_BITCOPY_RANGE(data_u32, (8 * ppd_base_header), &data, 0, 7 /* copy 7 bits */);
    SHR_BITCOPY_RANGE(mask_u32, (8 * ppd_base_header), &mask, 0, 7 /* copy 7 bits */);

    /* Set the 64b values */
    COMPILER_64_SET(edata, data_u32[1], data_u32[0]);
    COMPILER_64_SET(emask, mask_u32[1], mask_u32[0]);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyForwardingHeaderOffset,
                                                               count,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_ForwardingHeaderOffset_get
 * Purpose:
 *       Get match criteria for bcmFieldQualifyForwardingHeaderOffset
 *                       qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      base_header - (OUT) Qualifier base header.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ForwardingHeaderOffset_get(int unit,
                                                   bcm_field_entry_t entry,
                                                   bcm_field_data_offset_base_t *base_header,
                                                   uint32 *data,
                                                   uint32 *mask)
{
    uint64 edata, emask;
    uint32 ppd_base_header = 0, ppd_base_header_mask = 0;
    uint32 data_u32[2] = {0, 0};
    uint32 mask_u32[2] = {0, 0};

    BCMDNX_INIT_FUNC_DEFS;


    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyForwardingHeaderOffset,
                                                            &edata,
                                                            &emask));
    data_u32[0] = COMPILER_64_LO(edata);
    data_u32[1] = COMPILER_64_HI(edata);
    mask_u32[0] = COMPILER_64_LO(emask);
    mask_u32[1] = COMPILER_64_HI(emask);
    /* Get the header-offset mask */
    SHR_BITCOPY_RANGE(&ppd_base_header_mask, 0, mask_u32, (8*6) /* Size of the Offset-headers */, 3 /* copy 3 bits */);
    SHR_BITCOPY_RANGE(&ppd_base_header, 0, data_u32, (8*6) /* Size of the Offset-headers */, 3 /* copy 3 bits */);

    *data = 0;
    *mask = 0;
    if (ppd_base_header_mask) {
        /* Get the Base-header */
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_base_header_ppd_to_bcm(ppd_base_header, base_header));

        /* Get the data and value */
        SHR_BITCOPY_RANGE(data, 0, data_u32, (8 * ppd_base_header), 7 /* copy 7 bits */);
        SHR_BITCOPY_RANGE(mask, 0, mask_u32, (8 * ppd_base_header), 7 /* copy 7 bits */);
    }
    else {
        /* Not valid */
        *base_header = bcmFieldDataOffsetBaseCount;
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IngressVPortBridgeDisable
 * Purpose:
 *      Set match criteria for bcmFieldQualifyIngressVPortBridgeDisable
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IngressVPortBridgeDisable(int unit,
                                              bcm_field_entry_t entry,
                                              uint8 data,
                                              uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyIngressVPortBridgeDisable,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IngressVPortBridgeDisable
 * Purpose:
 *      Get match criteria for bcmFieldQualifyIngressVPortBridgeDisable
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IngressVPortBridgeDisable_get(int unit,
                                      bcm_field_entry_t entry,
                                      uint8 *data,
                                      uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyIngressVPortBridgeDisable,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit0
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit0
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit0(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit0,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit0
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit0
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit0_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit0,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalHit1
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit1
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit1(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit1,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit1
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit1
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit1_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit1,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalHit2
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit2
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit2(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit2,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit2
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit2_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit2,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalHit3
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalHit3
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit3(int unit,
                                     bcm_field_entry_t entry,
                                     uint8 data,
                                     uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalHit3,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalHit3
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalHit3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalHit3_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyExternalHit3,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_ExternalValue0
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue0
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue0(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue0,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue0
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue0
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue0_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue0,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalValue1
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue1
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue1(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue1,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue1
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue1
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue1_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue1,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalValue2
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue2
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue2(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue2,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue2
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue2
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue2_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue2,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_ExternalValue3
 * Purpose:
 *      Set match criteria for bcmFieldQualifyExternalValue3
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (IN) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue3(int unit,
                                     bcm_field_entry_t entry,
                                     uint64 data,
                                     uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyExternalValue3,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ExternalValue3
 * Purpose:
 *      Get match criteria for bcmFieldQualifyExternalValue3
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_ExternalValue3_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint64 *data,
                                         uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyExternalValue3,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/* 
 * Special case of profile management: 
 * due to missing AppType-bitmap qualifier, the user can:
 *  1. Set the AppType of each entry
 *  2. Adding an AppType to an entry, if the entry is the single instance having this profile
 *  and this AppType is not used by another entry
 *  3. A second entry should be able to get the same profile than an existing entry
 * The sequence is:
 *  1. If the entry has a non-zero profile,
 *  - if the AppType is already part of the bitmap, do nothing and exit.
 *  - look at the refCount it is the single entry with this profile, destroy this profile and create a new one.
 *  - otherwise return error
 *  2. If the entry has a profile 0 (non allocated), and it is the first time this AppType is used,
 *  add the AppType with creation of a new profile, similarly to bcmFieldQualifyInPort
 *  3. If the entry has a profile 0 (non allocated), and it is not the first time this AppType is used,
 *  attach this entry to the profile of this AppType. Automatically, all the AppTypes of these profiles are attached
 *  to the entry. It is the user's responsiblity to track the profiles
 */
/* bcm_field_qualify_AppType */
int bcm_petra_field_qualify_AppType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_AppType_t type)
{
    uint64 edata;
    uint64 emask;
    _bcm_dpp_core_ports_bitmap_t flp_pgm_id_bitmap[MAX_NUM_OF_CORES]; /* Sufficient for the number of FLP programs */
    uint32 ppd_flp_program, profile_idx;
    uint32 tdata;
    _bcm_dpp_field_info_t *tempData = _bcm_dpp_field_unit_info[unit];
    _bcm_dpp_field_profile_type_t profile_type = _bcmDppFieldProfileTypeFlpProgramProfile;
    uint64 profile;
    int  nof_cores, core;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, flp_pgm_id_bitmap );

    /* Convert AppType to HW number */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_app_type_bcm_to_ppd(unit, type, &ppd_flp_program));

    /* Retrieve the FLP-Program-bitmap of this entry */
    /* Get the current profile */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_entry_profile_get(tempData, profile_type, entry, &profile));

    tdata = COMPILER_64_LO(profile);
    if (COMPILER_64_IS_ZERO(profile)) {
        for(profile_idx = 1; profile_idx < _BCM_DPP_PRESEL_NOF_PORT_PROFILES; profile_idx++) 
        {
            BCMDNX_IF_ERR_EXIT(
                _bcm_dpp_field_presel_port_profile_get(unit,
                                                       profile_type,
                                                       profile_idx,
                                                       &nof_cores,
                                                       flp_pgm_id_bitmap));
            /* All cores configured identically, Look at first one*/
            if (SHR_BITGET(flp_pgm_id_bitmap[0], ppd_flp_program)) {
                /* Existing profile found */
                break;
            }
            /* If not found, zero the bitmap */
            _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, flp_pgm_id_bitmap );

        }
    }
    else {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               profile_type,
                                                               tdata,
                                                               &nof_cores,
                                                               flp_pgm_id_bitmap));
        if (SHR_BITGET(flp_pgm_id_bitmap[0], ppd_flp_program)) {
            /* Do nothing and exit */
            goto exit;
        }
        else if (tempData->preselProfileRefs[profile_type][tdata] == 1) {
            /* Clear the entry profile */
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_clear_type(tempData, profile_type, entry));
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG_NO_UNIT("unit %d does not support different set of profiles"
                                               "for qualifier %d (%s)\n"),
                              unit,
                              bcmFieldQualifyAppType,
                              _bcm_dpp_field_qual_name[bcmFieldQualifyAppType]));

        }
    }

    /* Set the bitmap with the new type, update all cores.*/
    for (core=0; core<nof_cores; core++) {
        SHR_BITSET(flp_pgm_id_bitmap[core], ppd_flp_program);
    }

    /* Set the new HW profile */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                           _bcmDppFieldProfileTypeFlpProgramProfile,
                                                           nof_cores,
                                                           flp_pgm_id_bitmap, 
                                                           &edata));
    COMPILER_64_SET(emask,0, 0x7);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyAppType,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/* 
 * Special case of profile management: 
 * due to missing AppType-bitmap qualifier, the user can get only 
 * a single AppType of the bitmap 
 */ 
/* 
 * Get match criteria for bcmFieldQualifyAppType
 *                qualifier from the field entry.
 */
int bcm_petra_field_qualify_AppType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_AppType_t *type)
{
    uint32 tdata;
    uint32 tmask;
    uint32 
        flp_pgm_id;
    int nof_cores;

    _bcm_dpp_core_ports_bitmap_t  flp_pgm_id_bitmap[MAX_NUM_OF_CORES];

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyAppType,
                                                            &tdata,
                                                            &tmask));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                           _bcmDppFieldProfileTypeFlpProgramProfile,
                                                           tdata,
                                                           &nof_cores, 
                                                           flp_pgm_id_bitmap));

    for (flp_pgm_id = 0; flp_pgm_id < SOC_DPP_DEFS_GET(unit, nof_flp_programs); flp_pgm_id++) {
        
        if(SHR_BITGET(flp_pgm_id_bitmap[0], flp_pgm_id)) {
            break;
        }
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_app_type_ppd_to_bcm(unit, flp_pgm_id, type));

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_MirrorEgressDisabled
 * Purpose:
 *      Set match criteria for bcmFieldQualifyMirrorEgressDisabled
 *                     qualifier in the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MirrorEgressDisabled(int unit,
                                             bcm_field_entry_t entry,
                                             uint8 data,
                                             uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMirrorEgressDisabled,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_EMirrorEgressDisabled_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyMirrorEgressDisabled
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MirrorEgressDisabled_get(int unit,
                                         bcm_field_entry_t entry,
                                         uint8 *data,
                                         uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMirrorEgressDisabled,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_BypassSrcMacFilter
 * Purpose:
 *      Set match criteria for BypassSrcMacFilter qualifier
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_BypassSrcMacFilter(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyBypassSrcMacFilter,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_BypassSrcMacFilter
 * Purpose:
 *      Get match criteria for BypassSrcMacFilter qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_BypassSrcMacFilter_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyBypassSrcMacFilter,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_RxTrapCodeForSnoop
 * Purpose:
 *      Set match criteria for RxTrapCodeForSnoop qualifier
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapCodeForSnoop(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyRxTrapCodeForSnoop,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_RxTrapCodeForSnoop_get
 * Purpose:
 *      Get match criteria for RxTrapCodeForSnoop qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_RxTrapCodeForSnoop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyRxTrapCodeForSnoop,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IpmcStarGroupValue
 * Purpose:
 *      Set match criteria for IpmcStarGroupValue qualifier
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_IpmcStarGroupValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_IpmcStarGroupValue not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_IpmcStarGroupValue_get
 * Purpose:
 *      Get match criteria for IpmcStarGroupValue qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_IpmcStarGroupValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_IpmcStarGroupValue_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_NativeVSwitch
 * Purpose:
 *      Set match criteria for NativeVSwitch qualifier
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_NativeVSwitch(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_NativeVSwitch not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_NativeVSwitch_get
 * Purpose:
 *      Get match criteria for NativeVSwitch qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_NativeVSwitch_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_NativeVSwitch_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_NativeVSwitchValid
 * Purpose:
 *      Set match criteria for NativeVSwitchValid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_NativeVSwitchValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_NativeVSwitchValid not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_NativeVSwitchValid_get
 * Purpose:
 *      Get match criteria for NativeVSwitchValid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
 
int 
bcm_petra_field_qualify_NativeVSwitchValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_NativeVSwitchValid_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillIVersion
 * Purpose:
 *      Set match criteria for TrillIVersion qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillIVersion(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillIVersion not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillIVersion_get
 * Purpose:
 *      Get match criteria for TrillIVersion qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillIVersion_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillIVersion_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillIngressRbridge
 * Purpose:
 *      Set match criteria for TrillIngressRbridge qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillIngressRbridge(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillIVersion_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillIngressRbridge_get
 * Purpose:
 *      Get match criteria for TrillIngressRbridge qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillIngressRbridge_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillIVersion_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_TrillMultiDestination
 * Purpose:
 *      Set match criteria for TrillMultiDestination qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillMultiDestination(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillMultiDestination not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillMultiDestination_get
 * Purpose:
 *      Get match criteria for TrillMultiDestination qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_TrillMultiDestination_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillMultiDestination_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillMultiDestination
 * Purpose:
 *      Set match criteria for TrillMultiDestination qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillOpLength(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillOpLength not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_TrillOpLength_get
 * Purpose:
 *      Get match criteria for TrillOpLength qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillOpLength_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillOpLength not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillHopCount
 * Purpose:
 *      Set match criteria for TrillHopCount qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillHopCount(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillOpLength not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillHopCount_get
 * Purpose:
 *      Get match criteria for TrillHopCount qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillHopCount_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillHopCount_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillPayload
 * Purpose:
 *      Set match criteria for TrillPayload qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillPayload(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillPayload not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_TrillPayload_get
 * Purpose:
 *      Get match criteria for TrillPayload qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_TrillPayload_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_TrillPayload_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MplsForwardingLabelPayload
 * Purpose:
 *      Set match criteria for MplsForwardingLabelPayload qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MplsForwardingLabelPayload(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MplsForwardingLabelPayload not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Function:
 *      bcm_field_qualify_MplsForwardingLabelPayload_get
 * Purpose:
 *      Get match criteria for MplsForwardingLabelPayload qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MplsForwardingLabelPayload_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MplsForwardingLabelPayload_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Function:
 *      bcm_field_qualify_IncomingIpIfClass
 * Purpose:
 *      Set match criteria for IncomingIpIfClass qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_petra_field_qualify_IncomingIpIfClass(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_IncomingIpIfClass not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Function:
 *      bcm_field_qualify_IncomingIpIfClass_get
 * Purpose:
 *      Get match criteria for IncomingIpIfClass qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_IncomingIpIfClass_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_IncomingIpIfClass_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Function:
 *      bcm_field_qualify_L2GreProtocolType
 * Purpose:
 *      Set match criteria for L2GreProtocolType qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreProtocolType(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreProtocolType not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreProtocolType_get
 * Purpose:
 *      Get match criteria for L2GreProtocolType qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreProtocolType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreProtocolType_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreVsid
 * Purpose:
 *      Set match criteria for L2GreVsid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreVsid(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreVsid not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreVsid_get
 * Purpose:
 *      Get match criteria for L2GreVsid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreVsid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreVsid_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreFlowId
 * Purpose:
 *      Set match criteria for L2GreFlowId qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreFlowId(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreFlowId not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_L2GreFlowId_get
 * Purpose:
 *      Get match criteria for L2GreFlowId qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_L2GreFlowId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_L2GreFlowId_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MimVlanPri
 * Purpose:
 *      Set match criteria for MimVlanPri qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MimVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MimVlanPri not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MimVlanPri_get
 * Purpose:
 *      Get match criteria for MimVlanPri qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MimVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MimVlanPri_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MimVlanCfi
 * Purpose:
 *      Set match criteria for MimVlanCfi qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MimVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MimVlanCfi not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_MimVlanCfi_get
 * Purpose:
 *      Get match criteria for MimVlanCfi qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_MimVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_MimVlanCfi_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_Fhei
 * Purpose:
 *      Set match criteria for Fhei qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_Fhei(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyFhei,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_Fhei_get
 * Purpose:
 *      Get match criteria for Fhei qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_Fhei_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyFhei,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_FheiSize
 * Purpose:
 *      Set match criteria for FheiSize qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_FheiSize(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if (!(_BCM_DPP_FIELD_FHEI_SIZE_VALID(data)))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Fhei Size not valid")));
    }
    if (data == _BCM_DPP_FIELD_FHEI_SIZE_0_BYTES)
    {
        COMPILER_64_SET(edata, 0, 0);
    }
    else 
    {
        COMPILER_64_SET(edata, 0, ((data == _BCM_DPP_FIELD_FHEI_SIZE_3_BYTES)? 1: ((data == _BCM_DPP_FIELD_FHEI_SIZE_5_BYTES)? 2: 3)));
    }

    if ((0 != mask)  && ((~0) != mask)) {
        /* neither ignore nor exact match */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                         (_BSL_BCM_MSG("FHEI size %d only supports all or"
                                   " nothing mask (all bits set or all"
                                   " bits clear clear)"),
                          data));
    }

    if (0 != mask)
    {
       COMPILER_64_SET(emask, 0, 0x3);
    }
    else 
    {
       COMPILER_64_SET(emask, 0, 0);
    }

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyFheiSize,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_FheiSize_get
 * Purpose:
 *      Get match criteria for FheiSize qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_FheiSize_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    uint32 soc_data;
    uint32 soc_mask;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyFheiSize,
                                                            &soc_data,
                                                            &soc_mask));
    if ( soc_data == 0) 
    {
       *data =  _BCM_DPP_FIELD_FHEI_SIZE_0_BYTES ;
    }
    else 
    {
       *data = ((soc_data == 1)? _BCM_DPP_FIELD_FHEI_SIZE_3_BYTES: ((soc_data == 2)? _BCM_DPP_FIELD_FHEI_SIZE_5_BYTES: _BCM_DPP_FIELD_FHEI_SIZE_8_BYTES));
    }
    *mask = (soc_mask == 0) ? 0: (~0) ; 
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_OuterVlanActionRange
 * Purpose:
 *      Set match criteria for OuterVlanActionRange qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_OuterVlanActionRange (
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOuterVlanActionRange,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;

}
/*
 * Function:
 *      bcm_field_qualify_OuterVlanActionRange_get
 * Purpose:
 * Get match criteria for OuterVlanActionRange qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_OuterVlanActionRange_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyOuterVlanActionRange,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_InnerVlanActionRange
 * Purpose:
 *      Set match criteria for InnerVlanActionRange qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_InnerVlanActionRange (
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInnerVlanActionRange,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;

}
/*
 * Function:
 *      bcm_field_qualify_InnerVlanActionRange_get
 * Purpose:
 * Get match criteria for InnerVlanActionRange qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_InnerVlanActionRange_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInnerVlanActionRange,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_ClassId
 * Purpose:
 *      Set match criteria for ClassId qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_ClassId (
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{

    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyClassId,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;

}
/*
 * Function:
 *      bcm_field_qualify_ClassId_get
 * Purpose:
 * Get match criteria for ClassId qualifier. 
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_ClassId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                            entry,
                                                            bcmFieldQualifyClassId,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_LearnInVPort
 * Purpose:
 *      Set match criteria for LearnInVPort qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_LearnInVPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;


    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);



    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyLearnInVPort,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_LearnInVPort_get
 * Purpose:
 *      Get match criteria for LearnInVPort qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_LearnInVPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyLearnInVPort,
                                                            data,
                                                            mask));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_petra_field_qualify_LearnExtension
 * Purpose:
 *      Set enable  criteria for LearnExtension qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      enable - (IN) Qualifier enable status data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnExtension(
    int unit,
    bcm_field_entry_t entry,
    uint8 enable)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, enable);
    COMPILER_64_SET(emask, 0, 0xFF);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyLearnExtension,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;

}
/*
 * Function:
 *      bcm_petra_field_qualify_LearnExtension_get
 * Purpose:
 *      Get enable criteria for LearnExtension qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      enable - (OUT) Qualifier enable status data.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_LearnExtension_get(
    int unit,
    bcm_field_entry_t entry,
    uint8 *enable)
{
    int32 data;
    int32 mask;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_int32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyLearnExtension,
                                                           &data,
                                                           &mask));

    *enable = data;

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_StackingRoute
 * Purpose:
 *      Set match criteria for StackingRoute qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_StackingRoute(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyStackingRoute,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_StackingRoute_get
 * Purpose:
 *      Get match criteria for StackingRoute qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_StackingRoute_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyStackingRoute ,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_DstSysPortExt
 * Purpose:
 *      Set match criteria for DstSysPortExt qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_DstSysPortExt(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyDstSysPortExt,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_DstSysPortExt_get
 * Purpose:
 *      Get match criteria for DstSysPortExt qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_DstSysPortExt_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint16_get(unit,
                                                           entry,
                                                           bcmFieldQualifyDstSysPortExt ,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_RxTrapCode32
 * Purpose:
 *      Set match criteria for RxTrapCode qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapCode32(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    uint64 edata;
    uint64 emask;
    uint32 group_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));

    if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) 
    {
        COMPILER_64_SET(edata, 0, data);
        COMPILER_64_SET(emask, 0, mask);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                   bcmFieldQualifyRxTrapCode,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                 (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                  group_flags));
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_RxTrapCode32_get
 * Purpose:
 *      Get match criteria for RxTrapCode qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapCode32_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    uint32 group_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(
        _bcm_dpp_petra_field_entry_group_flags(unit,
                                               entry,
                                               &group_flags));

    if (group_flags & _BCM_DPP_FIELD_GROUP_INGRESS) 
    {
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                            entry,
                                                            bcmFieldQualifyRxTrapCode,
                                                            data,
                                                            mask));
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                 (_BSL_BCM_MSG("Non-supported Field group stage with Field group flags %d \n"),
                  group_flags));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_RxTrapStrength
 * Purpose:
 *      Set match criteria for RxTrapStrength qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapStrength(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_RxTrapStrength not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_field_qualify_RxTrapStrength_get
 * Purpose:
 *      Get match criteria for RxTrapStrength qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int 
bcm_petra_field_qualify_RxTrapStrength_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcm_field_qualify_RxTrapStrength_get not supported\n\r")));
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamInLifIdValid
 * Purpose:
 *      Set match criteria for OamInLifIdValid qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */




int
bcm_petra_field_qualify_OamInLifIdValid(int unit,
                                         bcm_field_entry_t entry,
                                             uint8 data,
                                            uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamInLifIdValid,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamInLifIdValid_get
* Purpose:
* Get match criteria for OamInLifIdValid qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamInLifIdValid_get(int unit,
                                             bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamInLifIdValid,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamInLifId
 * Purpose:
 *      Set match criteria for OamInLifId qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamInLifId(int unit,
                                    bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamInLifId ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamInLifId_get
* Purpose:
* Get match criteria for OamInLifId qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamInLifId_get(int unit,
                                        bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyOamInLifId,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_OamUpMep
 * Purpose:
 *      Set match criteria for OamUpMep qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamUpMep(int unit,
                                  bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamUpMep,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}



/*
* Function:
* bcm_field_qualify_OamUpMep_get
* Purpose:
* Get match criteria for OamUpMep qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamUpMep_get(int unit,
                                      bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamUpMep,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamSubtype
 * Purpose:
 *      Set match criteria for OamSubtype qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamSubtype(int unit,
                                    bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamSubtype ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamSubtype_get
* Purpose:
* Get match criteria for OamSubtype qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/


int
bcm_petra_field_qualify_OamSubtype_get(int unit,
                                        bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                          bcmFieldQualifyOamSubtype ,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamHeaderOffset
 * Purpose:
 *      Set match criteria for OamHeaderOffset qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamHeaderOffset(int unit,
                                         bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamHeaderOffset,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamHeaderOffset_get
* Purpose:
* Get match criteria for OamHeaderOffset qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/


int
bcm_petra_field_qualify_OamHeaderOffset_get(int unit,
                                             bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamHeaderOffset,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamStampOffset
 * Purpose:
 *      Set match criteria for OamStampOffset qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamStampOffset(int unit,
                                    bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamStampOffset,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
* Function:
* bcm_field_qualify_OamStampOffset_get
* Purpose:
* Get match criteria for OamStampOffset qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/


int
bcm_petra_field_qualify_OamStampOffset_get(int unit,
                                            bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamStampOffset,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamMepId
 * Purpose:
 *      Set match criteria for OamMepId qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamMepId(int unit,
                                  bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamMepId ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamMepId_get
* Purpose:
* Get match criteria for OamMepId qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamMepId_get(int unit,
                                      bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamMepId ,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_OamMeterDisable
 * Purpose:
 *      Set match criteria for OamMeterDisable qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamMeterDisable(int unit,
                                         bcm_field_entry_t entry,
                                  uint8 data,
                                  uint8 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamMeterDisable,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamMeterDisable_get
* Purpose:
* Get match criteria for OamMeterDisable qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamMeterDisable_get(int unit,
                                             bcm_field_entry_t entry,
                                               uint8 *data,
                                               uint8 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint8_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamMeterDisable,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_OamTsSystemHeader
 * Purpose:
 *      Set match criteria for OamTsSystemHeader qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamTsSystemHeader(int unit,
                                  bcm_field_entry_t entry,
                                  uint64 data,
                                  uint64 mask)
{

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamTsSystemHeader,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
* Function:
* bcm_field_qualify_OamTsSystemHeader_get
* Purpose:
* Get match criteria for OamTsSystemHeader qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/


int
bcm_petra_field_qualify_OamTsSystemHeader_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint64 *data,
                                               uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamTsSystemHeader,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_EthernetOamHeaderBits0_31
 * Purpose:
 *      Set match criteria for EthernetOamHeaderBits0_31 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EthernetOamHeaderBits0_31(int unit,
                                     bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyEthernetOamHeaderBits0_31 ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_EthernetOamHeaderBits0_31_get
* Purpose:
* Get match criteria for EthernetOamHeaderBits0_31 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_EthernetOamHeaderBits0_31_get(int unit,
                                              bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyEthernetOamHeaderBits0_31,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_EthernetOamHeaderBits32_63
 * Purpose:
 *      Set match criteria for EthernetOamHeaderBits32_63 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_EthernetOamHeaderBits32_63(int unit,
                                     bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyEthernetOamHeaderBits32_63 ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
* Function:
* bcm_field_qualify_EthernetOamHeaderBits32_63_get
* Purpose:
* Get match criteria for EthernetOamHeaderBits32_63 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_EthernetOamHeaderBits32_63_get(int unit,
                                            bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyEthernetOamHeaderBits32_63,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_MplsOamHeaderBits0_31
 * Purpose:
 *      Set match criteria for MplsOamHeaderBits0_31 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsOamHeaderBits0_31(int unit,
                                   bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsOamHeaderBits0_31 ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_MplsOamHeaderBits0_31_get
* Purpose:
* Get match criteria for MplsOamHeaderBits0_31 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_MplsOamHeaderBits0_31_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyMplsOamHeaderBits0_31,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_MplsOamHeaderBits32_63
 * Purpose:
 *      Set match criteria for MplsOamHeaderBits32_63 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsOamHeaderBits32_63(int unit,
                                 bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsOamHeaderBits32_63 ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_MplsOamHeaderBits32_63_get
* Purpose:
* Get match criteria for MplsOamHeaderBits32_63 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_MplsOamHeaderBits32_63_get(int unit,
                                                bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                             bcmFieldQualifyMplsOamHeaderBits32_63,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_MplsOamACH
 * Purpose:
 *      Set match criteria for MplsOamACH qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_MplsOamACH(int unit,
                                 bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyMplsOamACH ,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_MplsOamACH_get
* Purpose:
* Get match criteria for MplsOamACH qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_MplsOamACH_get(int unit,
                                        bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyMplsOamACH,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 * Function:
 *      bcm_field_qualify_OamHeaderBits0_31
 * Purpose:
 *      Set match criteria for OamHeaderBits0_31 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamHeaderBits0_31(int unit,
                                   bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamHeaderBits0_31,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/*
* Function:
* bcm_field_qualify_OamHeaderBits0_31_get
* Purpose:
* Get match criteria for OamHeaderBits0_31 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamHeaderBits0_31_get(int unit,
                                               bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                           bcmFieldQualifyOamHeaderBits0_31,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


/*
 * Function:
 *      bcm_field_qualify_OamHeaderBits32_63
 * Purpose:
 *      Set match criteria for OamHeaderBits32_63 qualifier.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (IN) Qualifier match data.
 *      mask - (In) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_OamHeaderBits32_63(int unit,
                                    bcm_field_entry_t entry,
                                  uint32 data,
                                  uint32 mask)
{
    uint64 edata;
    uint64 emask;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    COMPILER_64_SET(edata, 0, data);
    COMPILER_64_SET(emask, 0, mask);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyOamHeaderBits32_63,
                                                               1 /* count */,
                                                               &edata,
                                                               &emask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}



/*
* Function:
* bcm_field_qualify_OamHeaderBits32_63_get
* Purpose:
* Get match criteria for OamHeaderBits32_63 qualifier.
* Parameters:
* unit - (IN) Unit number.
* entry - (IN) BCM field entry id.
 * data - (OUT) Qualifier match data.
* mask - (OUT) Qualifier match mask.
* Returns:
* BCM_E_XXX
* Notes:
*/

int
bcm_petra_field_qualify_OamHeaderBits32_63_get(int unit,
                                                bcm_field_entry_t entry,
                                               uint32 *data,
                                               uint32 *mask)
{
      BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                           entry,
                                                            bcmFieldQualifyOamHeaderBits32_63,
                                                           data,
                                                           mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}



/*
 *   Function
 *      bcm_petra_field_qualify_InterfaceInPorts
 *   
 *   Parameters
 *      (in) int unit = the unit number
 *      (in) bcm_field_entry_t entry = the entry ID
 *      (in) bcm_pbmp_t data = allowed ports
 *      (in) bcm_pbmp_t mask = which bits of data are significant
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int
bcm_petra_field_qualify_InterfaceInPorts(int unit,
                                 bcm_field_entry_t entry,
                                 bcm_pbmp_t data,
                                 bcm_pbmp_t mask)
{

   uint64 edata;
    uint64 emask;

    uint32
        port_id,
        fld_val;
    uint32 pp_port;
    _bcm_dpp_core_ports_bitmap_t port_bitmap[MAX_NUM_OF_CORES]; 
    int    core, nof_cores;
    uint32 is_valid;
    uint32 max_port =  _BCM_DPP_NOF_LOCAL_PORTS(unit);
        
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    nof_cores = SOC_DPP_DEFS_GET(unit, nof_cores);
    _bcm_dpp_clear_core_ports(nof_cores, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        /*
         * Check all the ports are masked and copy their
         * membership in data to the array
         */
        for (port_id = 0; port_id < max_port ; port_id++) {
            if (!BCM_PBMP_MEMBER(mask, port_id)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                                 (_BSL_BCM_MSG("only supports all masked (all"
                                           " bits set in mask)")));
            }

            /* Copy the port bit */
            fld_val = BCM_PBMP_MEMBER(data, port_id);

            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

            if (fld_val) {
                if (is_valid) {
                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));
                    SHR_BITCOPY_RANGE(port_bitmap[core], pp_port, &fld_val, 0, 1);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Invalid port")));
                }
            }
        }

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_set(unit,
                                                               _bcmDppFieldProfileTypeInterfaceInPort,
                                                               nof_cores,
                                                               port_bitmap, 
                                                               &edata));
        COMPILER_64_SET(emask, 0, 0x7);
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                                   entry,
                                                                  bcmFieldQualifyInterfaceInPorts,
                                                                   1 /* count */,
                                                                   &edata,
                                                                   &emask));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }

exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;

}


/*
 * Function:
 *      bcm_petra_field_qualify_InterfaceInPorts_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInterfaceInPorts
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int
bcm_petra_field_qualify_InterfaceInPorts_get(int unit,
                                     bcm_field_entry_t entry,
                                     bcm_pbmp_t *data,
                                     bcm_pbmp_t *mask)
{
    
    uint32 tdata;
    uint32 tmask;
    uint32 
        port_id, pp_port;
    _bcm_dpp_core_ports_bitmap_t  port_bitmap[MAX_NUM_OF_CORES];
    int                   core, nof_cores; 
    uint32                is_valid;
    uint32                max_port = _BCM_DPP_NOF_LOCAL_PORTS(unit);

    BCMDNX_INIT_FUNC_DEFS;

    _bcm_dpp_clear_core_ports(MAX_NUM_OF_CORES, port_bitmap);

    if (_BCM_DPP_FIELD_ENTRY_IS_PRESEL(entry)){
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint32_get(unit,
                                                                entry,
                                                                bcmFieldQualifyInterfaceInPorts,
                                                                &tdata,
                                                                &tmask));

        BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_presel_port_profile_get(unit,
                                                               _bcmDppFieldProfileTypeInterfaceInPort,
                                                               tdata,
                                                               &nof_cores,
                                                               port_bitmap));
        BCM_PBMP_CLEAR(*data);
        BCM_PBMP_CLEAR(*mask);
        for (port_id = 0; port_id < max_port; port_id++) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_valid_port_get(unit, port_id, &is_valid));

			if (is_valid) {

				BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, port_id, &pp_port, &core)));

				if(SHR_BITGET(port_bitmap[core], pp_port) > 0) {
                    BCM_PBMP_PORT_ADD(*data, port_id);
				}

			}
            /* Mask is expected to be all 1*/
            BCM_PBMP_PORT_ADD(*mask, port_id);

        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("not supported")));
    }
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;

}

/*
 *   Function
 *      bcm_petra_field_qualify_InVPortWide
 * Purpose:
 *      Set match criteria for bcmFieldQualifyInVPortWide
 *                     qualifier from the field entry.  
 *   Parameters
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 *   Returns
 *      int (implied cast from bcm_error_t)
 *                    BCM_E_NONE if successful
 *                    BCM_E_* appropriately if not
 *   Notes
 */
int bcm_petra_field_qualify_InVPortWide(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualifier_general_set(unit,
                                                               entry,
                                                               bcmFieldQualifyInVPortWide,
                                                               1 /* count */,
                                                               &data,
                                                               &mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Function:
 *      bcm_petra_field_qualify_InVPortWide_get
 * Purpose:
 *      Get match criteria for bcmFieldQualifyInVPortWide
 *                     qualifier from the field entry.
 * Parameters:
 *      unit - (IN) Unit number.
 *      entry - (IN) BCM field entry id.
 *      data - (OUT) Qualifier match data.
 *      mask - (OUT) Qualifier match mask.
 * Returns:
 *      BCM_E_XXX
 * Notes:
 */
int bcm_petra_field_qualify_InVPortWide_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_field_entry_qualify_uint64_get(unit,
                                                            entry,
                                                            bcmFieldQualifyInVPortWide,
                                                            data,
                                                            mask));
exit:
#if (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT))
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
#endif /* (defined(BCM_DPP_SUPPORT) && defined(BCM_WARM_BOOT_SUPPORT)) */
    BCMDNX_FUNC_RETURN;
}


