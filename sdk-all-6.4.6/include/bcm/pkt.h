/*
 * $Id: $
 * 
 * $Copyright: Copyright 2015 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_PKT_H__
#define __BCM_PKT_H__

#include <shared/rx.h>
#include <bcm/types.h>
#include <bcm/vlan.h>

/* Default TX and RX DMA channels for the BCM layer. */
#define BCM_TX_CHAN_DFLT        0          
#define BCM_RX_CHAN_DFLT        1          

/* Minimum packet allocation:  MAC addresses, VLAN tag, CRC. */
#define BCM_PKT_ALLOC_MIN       (12 + 4 + 4) 

/* 
 * IEEE header:  MAC addresses + VLAN tag; does not include type/len
 * field.
 */
#define BCM_IEEE_HDR_BYTES      (12 + 4)   

/* 
 * The packet structure. The packet layout is as follows:
 * 
 *   DMAC + SMAC     12 bytes
 *   VLAN tag         4 bytes (may be filled in by SW on BCM5670/75)
 *   payload          N bytes
 *   CRC              4 bytes
 *   pad              M bytes
 *   SL tag           4 bytes (may be unused)
 *   HiGig Header    12 bytes (may be unused)
 * 
 * The rule is: alloc_len = 12 + 4 + N + 4 + M + 4 + 12 (all of above).
 * payload_len (below) is N.
 * 
 * Note that the payload may grow until M == 0; the CRC moves. The SL and
 * HiGig headers will not move.
 * 
 * The "IEEE packet" is everything from the DMAC through the CRC
 * (inclusive), not including SL tag or HiGig header.
 * 
 * Scatter/gather is used to put the data into the right positions on
 * transmit and receive. The SL/HiGig headers are parsed on RX into data
 * members in the packet structure. On TX, bcm_tx will send the packet
 * according to the unit type. It will not check or affect any fields
 * except maybe the CRC. Other routines will be provided to ensure the
 * HiGig and SL tags are properly set up from the data in the packet
 * structure.
 */
typedef struct bcm_pkt_s bcm_pkt_t;

/* bcm_pkt_cb_f */
typedef void (*bcm_pkt_cb_f)(
    int unit, 
    bcm_pkt_t *pkt, 
    void *cookie);

/* BCM packet gather block type. */
typedef struct bcm_pkt_blk_s {
    uint8 *data; 
    int len; 
} bcm_pkt_blk_t;

/* Set of 'reasons' (see bcmRxReason*) why a packet came to the CPU. */
typedef _shr_rx_reasons_t bcm_rx_reasons_t;

/* Stacking header packet forwarding options. */
typedef enum bcm_pkt_stk_forward_e {
    BCM_PKT_STK_FORWARD_CPU = 0,        /* Stacking header packet forwarding
                                           option: to Host CPU. */
    BCM_PKT_STK_FORWARD_L2_UNICAST = 1, /* Stacking header packet forwarding
                                           option: Unicast L2. */
    BCM_PKT_STK_FORWARD_L3_UNICAST = 2, /* Stacking header packet forwarding
                                           option: Unicast L3. */
    BCM_PKT_STK_FORWARD_L2_MULTICAST = 3, /* Stacking header packet forwarding
                                           option: Multicast L2. */
    BCM_PKT_STK_FORWARD_L2_MULTICAST_UNKNOWN = 4, /* Stacking header packet forwarding
                                           option: Unknown Multicast L2. */
    BCM_PKT_STK_FORWARD_L3_MULTICAST = 5, /* Stacking header packet forwarding
                                           option: Multicast L3. */
    BCM_PKT_STK_FORWARD_L3_MULTICAST_UNKNOWN = 6, /* Stacking header packet forwarding
                                           option: Unknown Multicast L3. */
    BCM_PKT_STK_FORWARD_L2_UNICAST_UNKNOWN = 7, /* Stacking header packet forwarding
                                           option: Unknown Unicast L2. */
    BCM_PKT_STK_FORWARD_BROADCAST = 8,  /* Stacking header packet forwarding
                                           option: Broadcast. */
    BCM_PKT_STK_FORWARD_MPLS = 9,       /* Stacking header packet forwarding
                                           option: MPLS. */
    BCM_PKT_STK_FORWARD_TRILL = 10,     /* Stacking header packet forwarding
                                           option: TRILL. */
    BCM_PKT_STK_FORWARD_FCOE = 11,      /* Stacking header packet forwarding
                                           option: FCoE. */
    BCM_PKT_STK_FORWARD_SNOOP = 12,     /* Stacking header packet forwarding
                                           option: Snoop. */
    BCM_PKT_STK_FORWARD_TRAFFIC_MANAGEMENT = 13, /* Stacking header packet forwarding
                                           option: Traffic Management. */
    BCM_PKT_STK_FORWARD_COUNT = 14      /* Must be last. */
} bcm_pkt_stk_forward_t;

/* Decap Tunnel Types */
typedef enum bcm_rx_decap_tunnel_e {
    bcmRxDecapNone = _SHR_RX_DECAP_NONE, /* No tunnel Decap */
    bcmRxDecapAccessSVP = _SHR_RX_DECAP_ACCESS_SVP, /* Packet ingress on Access SVP (No
                                           decap) */
    bcmRxDecapMIM = _SHR_RX_DECAP_MIM,  /* Decap Mac-in-Mac tunnel */
    bcmRxDecapL2GRE = _SHR_RX_DECAP_L2GRE, /* Decap L2GRE tunnel */
    bcmRxDecapVXLAN = _SHR_RX_DECAP_VXLAN, /* Decap VXLAN tunnel */
    bcmRxDecapAMT = _SHR_RX_DECAP_AMT,  /* Decap AMT tunnel */
    bcmRxDecapIP = _SHR_RX_DECAP_IP,    /* Decap IP tunnel */
    bcmRxDecapTRILL = _SHR_RX_DECAP_TRILL, /* Decap TRILL tunnel */
    bcmRxDecapL2MPLS1LABEL = _SHR_RX_DECAP_L2MPLS_1LABEL, /* Decap MPLS 1 Label, L2 payload, no
                                           Control Word */
    bcmRxDecapL2MPLS2LABEL = _SHR_RX_DECAP_L2MPLS_2LABEL, /* Decap MPLS 2 Label, L2 payload, no
                                           Control Word */
    bcmRxDecapL2MPLS1LABELCW = _SHR_RX_DECAP_L2MPLS_1LABELCW, /* Decap MPLS 1 Label, L2 payload,
                                           Control Word present */
    bcmRxDecapL2MPLS2LABELCW = _SHR_RX_DECAP_L2MPLS_2LABELCW, /* Decap MPLS 2 Label, L2 payload,
                                           Control Word present */
    bcmRxDecapL3MPLS1LABEL = _SHR_RX_DECAP_L3MPLS_1LABEL, /* Decap MPLS 1 Label, L3 payload, no
                                           Control Word present */
    bcmRxDecapL3MPLS2LABEL = _SHR_RX_DECAP_L3MPLS_2LABEL, /* Decap MPLS 2 Label, L3 payload, no
                                           Control Word present */
    bcmRxDecapL3MPLS1LABELCW = _SHR_RX_DECAP_L3MPLS_1LABELCW, /* Decap MPLS 1 Label, L3 payload,
                                           Control Word present */
    bcmRxDecapL3MPLS2LABELCW = _SHR_RX_DECAP_L3MPLS_2LABELCW, /* Decap MPLS 2 Label, L3 payload,
                                           Control Word present */
    bcmRxDecapWTP2AC = _SHR_RX_DECAP_WTP2AC, /* Decap WTP2AC Tunnel */
    bcmRxDecapAC2AC = _SHR_RX_DECAP_AC2AC, /* Decap AC2AC Tunnel */
    bcmRxDecapCount = _SHR_RX_DECAP_COUNT /* Decap Tunnel Max */
} bcm_rx_decap_tunnel_t;

/* OAM DM timestamp options. */
typedef enum bcm_pkt_timestamp_mode_e {
    BCM_PKT_TIMESTAMP_MODE_NONE = 0,    /* No Timestamp */
    BCM_PKT_TIMESTAMP_MODE_PTP = 1,     /* Timestamp mode - PTP. */
    BCM_PKT_TIMESTAMP_MODE_NTP = 2,     /* Timestamp mode - NTP. */
    BCM_PKT_TIMESTAMP_MODE_NUM = 3      /* Max value - Not to be used */
} bcm_pkt_timestamp_mode_t;

/* OAM LM counter options. */
typedef enum bcm_pkt_oam_lm_counter_mode_e {
    BCM_PKT_OAM_LM_COUNTER_MODE_NONE = 0, /* No LM counter operation */
    BCM_PKT_OAM_LM_COUNTER_MODE_INCREMENT = 1, /* Increment LM counter. */
    BCM_PKT_OAM_LM_COUNTER_MODE_SAMPLE = 2, /* Sample LM counter. */
    BCM_PKT_OAM_LM_COUNTER_MODE_NUM = 3 /* Max value - Not to be used */
} bcm_pkt_oam_lm_counter_mode_t;

/* OAM Pkt Type */
typedef enum bcm_pkt_rx_oam_type_e {
    bcmPktRxOamTypeNone = 0,            /* Not OAM pkt */
    bcmPktRxOamTypeBfdOam = 1,          /* BFD OAM packet */
    bcmPktRxOamTypeEthOamCcm = 2,       /* Ethernet OAM CCM packet */
    bcmPktRxOamTypeEthOamLm = 3,        /* Ethernet OAM LM packet */
    bcmPktRxOamTypeEthOamDm = 4,        /* Ethernet OAM DM packet */
    bcmPktRxOamTypeEthOamOther = 5,     /* Ethernet OAM other opcode packet */
    bcmPktRxOamTypeBhhOamCcm = 6,       /* BHH OAM CCM packet */
    bcmPktRxOamTypeBhhOamLm = 7,        /* BHH OAM LM packet */
    bcmPktRxOamTypeBhhOamDm = 8,        /* BHH OAM DM packet */
    bcmPktRxOamTypeBhhOamOther = 9,     /* BHH OAM other opcode packet */
    bcmPktRxOamTypeRfc6374Dlm = 10,     /* MPLS LM/DM  DLM packet */
    bcmPktRxOamTypeRfc6374Dm = 11,      /* MPLS LM/DM  DM packet */
    bcmPktRxOamTypeRfc6374DlmPlusDm = 12, /* MPLS LM/DM  DLM + DM packet */
    bcmPktRxOamTypeRfc6374Ilm = 13,     /* MPLS LM/DM  ILM packet */
    bcmPktRxOamTypeRfc6374IlmPlusDm = 14, /* MPLS LM/DM  ILM + DM packet */
    bcmPktRxOamTypeSat = 15,            /* Service Activation Test */
    bcmPktRxOamTypeOtherAch = 16,       /* OAM packets with other ACH types */
    bcmPktRxOamTypeCount = 17           /* Max value - Not to be used */
} bcm_pkt_rx_oam_type_t;

/* OAM counter object ID */
typedef enum bcm_pkt_oam_counter_object_e {
    bcmOamCounterObjectNone = 0,        /* Invalid counter object */
    bcmOamCounterObjectEndpointId = 1,  /* OAM counter object id */
    bcmOamCounterObjectFlexStatId = 2   /* OAM counter flex stats ID */
} bcm_pkt_oam_counter_object_t;

/* OAM counter */
typedef struct bcm_pkt_oam_counter_s {
    bcm_pkt_oam_counter_object_t counter_object; /* OAM counter object type */
    uint32 counter_object_id;           /* Counter Object Id */
    uint32 counter_offset;              /* Offset from start of counter group */
    bcm_pkt_oam_lm_counter_mode_t counter_mode; /* Counter mode during Tx */
    uint32 counter_value_upper;         /* Upper 32 bit of OAM LM Counter in Rx
                                           Pkt */
    uint32 counter_value_lower;         /* Lower 32 bit of OAM LM Counter in Rx
                                           Pkt */
    uint32 oam_lm_byte_count_offset;    /* Offset to start byte counting */
} bcm_pkt_oam_counter_t;

/* OAM counter max object */
#define BCM_PKT_OAM_COUNTER_MAX 3          

/* Rx path definitions */
#define BCM_RX_PATH_SWITCHED    (1 << 0)   
#define BCM_RX_PATH_COPY_TO_CPU (1 << 1)   
#define BCM_RX_PATH_MIRRORED    (1 << 2)   

/* DNX internal header stack array size */
#define BCM_PKT_NOF_DNX_HEADERS 9          

/* Pkt DNX types. */
typedef enum bcm_pkt_dnx_type_e {
    bcmPktDnxTypePtch1 = 0, /* PTCH-1 Header. */
    bcmPktDnxTypePtch2 = 1, /* PTCH-2 Header. */
    bcmPktDnxTypeItmh = 2,  /* ITMH Header. */
    bcmPktDnxTypeFtmh = 3,  /* FMTH Header. */
    bcmPktDnxTypePph = 4,   /* PPH Header. */
    bcmPktDnxTypeOtsh = 5,  /* OAM-TS Header (OTSH). */
    bcmPktDnxTypeOtmh = 6,  /* OTMH Header. */
    bcmPktDnxTypeRaw = 7    /* Raw Header. */
} bcm_pkt_dnx_type_t;

/* PTCH1 */
typedef struct bcm_pkt_dnx_ptch1_s {
    bcm_gport_t src_gport;      /* PTCH-1.Source-System-Port. */
    uint32 opaque_attr;         /* PTCH-1.Opaque-PT-Attributes. */
    uint8 is_port_header_type;  /* If set, the next header type is set according
                                   to the Source-local Port. Otherwise, the next
                                   header must be ITMH
                                   (PTCH-1.Parser-Program-Control). */
} bcm_pkt_dnx_ptch1_t;

/* PTCH2 */
typedef struct bcm_pkt_dnx_ptch2_s {
    bcm_gport_t src_local_port; /* Source-local-port (PTCH-2.PP-SSP). */
    uint32 opaque_attr;         /* PTCH-2.Opaque-PT-Attributes. */
    uint8 is_port_header_type;  /* If set, the next header type is set according
                                   to the Source-local-Port. Otherwise, the next
                                   header must be ITMH
                                   (PTCH-2.Parser-Program-Control) */
} bcm_pkt_dnx_ptch2_t;

/* itmh dest type. */
typedef enum bcm_pkt_dnx_itmh_dest_type_e {
    bcmPktDnxItmhDestTypeMulticast = 0, /* ITMH destination type is multicast. */
    bcmPktDnxItmhDestTypeFlow = 1,      /* ITMH destination type is flow. */
    bcmPktDnxItmhDestTypeIngressShapingFlow = 2, /* ITMH destination type is ingress
                                           shaping flow. */
    bcmPktDnxItmhDestTypeVport = 3,     /* ITMH destination type is out lif. */
    bcmPktDnxItmhDestTypeSystemPort = 4 /* ITMH destination type is system port. */
} bcm_pkt_dnx_itmh_dest_type_t;

/* Itmh destination. */
typedef struct bcm_pkt_dnx_itmh_dest_s {
    bcm_pkt_dnx_itmh_dest_type_t dest_type; /* Destination type */
    bcm_pkt_dnx_itmh_dest_type_t dest_extension_type; /* Destination Extension type */
    bcm_gport_t destination;            /* Destination Gport */
    bcm_multicast_t multicast_id;       /* Destination multicast */
    bcm_gport_t destination_ext;        /* Destination-Extension Gport */
} bcm_pkt_dnx_itmh_dest_t;

/* Itmh */
typedef struct bcm_pkt_dnx_itmh_s {
    uint8 inbound_mirror_disable;   /* If set, disable inbound mirroring
                                       (ITMH.IN_MIRR_DISABLE) */
    uint32 snoop_cmnd;              /* snoop command (ITMH.SNOOP_CMD) */
    uint32 prio;                    /* Traffic Class (ITMH.FWD_TRAFFIC_CLASS) */
    bcm_color_t color;              /* Color (aka Drop precedence, ITMH.FWD_DP) */
    bcm_pkt_dnx_itmh_dest_t dest;   /* Destination information */
} bcm_pkt_dnx_itmh_t;

/* ftmh action type. */
typedef enum bcm_pkt_dnx_ftmh_action_type_e {
    bcmPktDnxFtmhActionTypeForward = 0, /* TM action is forward */
    bcmPktDnxFtmhActionTypeSnoop = 1,   /* TM action is snoop */
    bcmPktDnxFtmhActionTypeInboundMirror = 2, /* TM action is inbound mirror. */
    bcmPktDnxFtmhActionTypeOutboundMirror = 3 /* TM action is outbound mirror. */
} bcm_pkt_dnx_ftmh_action_type_t;

/* ftmh lb extension. */
typedef struct bcm_pkt_dnx_ftmh_lb_extension_s {
    uint8 valid;    /* Set if the extension is present */
    uint32 lb_key;  /* Load Balancing Key (FTMH.LB-Key) */
} bcm_pkt_dnx_ftmh_lb_extension_t;

/* ftmh dest extension. */
typedef struct bcm_pkt_dnx_ftmh_dest_extension_s {
    uint8 valid;                /* Set if the extension is present */
    bcm_gport_t dst_sysport;    /* Destination System Port
                                   (FTMH.Destination-Sys-Port)) */
} bcm_pkt_dnx_ftmh_dest_extension_t;

/* ftmh stack extension. */
typedef struct bcm_pkt_dnx_ftmh_stack_extension_s {
    uint8 valid;                    /* Set if the extension is present */
    uint32 stack_route_history_bmp; /* Route bitmap to prevent loops in stacking
                                       system
                                       (FTMH.Stacking-Route-History-Bitmap) */
} bcm_pkt_dnx_ftmh_stack_extension_t;

/* ftmh */
typedef struct bcm_pkt_dnx_ftmh_s {
    uint32 packet_size;                 /* Packet size in bytes
                                           (FTMH.Packet-Size) */
    uint32 prio;                        /* Traffic class (FTMH.Traffic-Class) */
    bcm_gport_t src_sysport;            /* Source System port
                                           (FTMH.Source-System-Port-Aggr) */
    bcm_gport_t dst_port;               /* Destination local port (FTMH.PP_DSP) */
    bcm_color_t ftmh_dp;                /* Drop precedence (FTMH.DP) */
    bcm_pkt_dnx_ftmh_action_type_t action_type; /* Action type (FTMH.TM-Action-Type) */
    uint8 out_mirror_disable;           /* Disable Outbound mirroring
                                           (FTMH.Out-Mirror-Disable) */
    uint8 is_mc_traffic;                /* Indicate if the traffic is multicast
                                           (FTMH.TM-Action-Is-Multicast) */
    bcm_multicast_t multicast_id;       /* Multicast ID (FTMH.Multicast-ID).
                                           Valid only if is_mc_traffic is set */
    bcm_gport_t out_vport;              /* Virtual port (FTMH.Out-LIF). Valid
                                           only if is_mc_traffic is unset */
    uint32 cni;                         /* Congestion indication (FTMH.CNI) */
    bcm_pkt_dnx_ftmh_lb_extension_t lb_ext; /* FTMH Load Balancing Key extension */
    bcm_pkt_dnx_ftmh_dest_extension_t dest_ext; /* FTMH Destination System Port
                                           Extension */
    bcm_pkt_dnx_ftmh_stack_extension_t stack_ext; /* FTMH Stacking extension
                                           (Stacking-Route-History-Bitmap) */
} bcm_pkt_dnx_ftmh_t;

/* pph eei extension */
typedef struct bcm_pkt_dnx_pph_eei_extension_s {
    uint8 valid;    /* Set if the extension is present */
    uint8 is_mim;   /* Set if the packet is MAC-in-MAC (PPH.EEI.MIM-P2P-VSI) */
    uint32 i_sid;   /* I-SID (PPH.EEI.I-SID) */
    uint32 command; /* Command (PPH.EEI.Command) */
    uint32 data;    /* Data (PPH.EEI.Data) */
} bcm_pkt_dnx_pph_eei_extension_t;

/* pph learn extension */
typedef struct bcm_pkt_dnx_pph_learn_extension_s {
    uint8 valid;                        /* Set if the extension is present */
    bcm_port_t phy_gport;               /* Learn Destination port
                                           (PPH.Learn.Learn-Destination) */
    uint8 is_eei_valid;                 /* Set if the EEI info is valid */
    bcm_pkt_dnx_pph_eei_extension_t eei; /* EEI information (PPH.Learn.Learn-ASD) */
    uint8 is_encap_id_valid;            /* Set if the encap-id is valid */
    int encap_id;                       /* Encap-Id (PPH.Learn.Learn-ASD). Valid
                                           if is_encap_id_valid is set */
    uint64 raw_data;                    /* Learn-extension raw data (PPH.Learn) */
} bcm_pkt_dnx_pph_learn_extension_t;

/* pph fhei type */
typedef enum bcm_pkt_dnx_pph_fhei_type_e {
    bcmPktDnxPphFheiTypeBridge = 0, /* PPH FHEI Bridge */
    bcmPktDnxPphFheiTypeTrap = 1,   /* PPH FHEI Trap */
    bcmPktDnxPphFheiTypeIp = 2,     /* PPH FHEI Ip */
    bcmPktDnxPphFheiTypeMpls = 3,   /* PPH FHEI Mpls */
    bcmPktDnxPphFheiTypeTrill = 4   /* PPH FHEI Trill */
} bcm_pkt_dnx_pph_fhei_type_t;

/* pph fhei bridge extension */
typedef struct bcm_pkt_dnx_pph_fhei_bridge_extension_s {
    uint8 ive_cmd;      /* Ingress-VLAN-Edit-Command
                           (FHEI.Bridge.Ingress-VLAN-Edit-Command) */
    uint8 pcp1;         /* PCP-1 (FHEI.Bridge.Edit-PCP1) */
    uint8 dei1;         /* DEI-1 (FHEI.Bridge.Edit-DEI1) */
    bcm_vlan_t vlan1;   /* VLAN-ID 1 (FHEI.Bridge.Edit-VID1) */
    uint8 pcp2;         /* PCP-2 (FHEI.Bridge.Edit-PCP2) */
    uint8 dei2;         /* DEI-2 (FHEI.Bridge.Edit-DEI2) */
    bcm_vlan_t vlan2;   /* VLAN-ID 2 (FHEI.Bridge.Edit-VID2) */
} bcm_pkt_dnx_pph_fhei_bridge_extension_t;

/* pph fhei trap extension */
typedef struct bcm_pkt_dnx_pph_fhei_trap_extension_s {
    uint32 trap_qualifier;  /* Trap Qualifier(FHEI.Trap.CPU-Trap-Code-Qualifier) */
    bcm_gport_t trap_id;    /* Trap ID (FHEI.Trap.CPU-Trap-Code) */
} bcm_pkt_dnx_pph_fhei_trap_extension_t;

/* pph fhei ip extension */
typedef struct bcm_pkt_dnx_pph_fhei_ip_extension_s {
    uint32 ive_cmd; /* Ingress-VLAN-Edit-Command
                       (FHEI.IP.Ingress-VLAN-Edit-Command) */
    uint8 pri;      /* Priority (FHEI.IP.In-DSCP/In-TC) */
    uint8 in_ttl;   /* Time To Live (FHEI.IP.In-TTL) */
} bcm_pkt_dnx_pph_fhei_ip_extension_t;

/* pph fhei mpls extension */
typedef struct bcm_pkt_dnx_pph_fhei_mpls_extension_s {
    uint32 tpid_profile;                /* TPID profile (FHEI.MPLS.TPID-Profile) */
    uint32 label;                       /* MPLS label (FHEI.MPLS.Label) */
    bcm_forwarding_type_t upper_layer_protocol; /* Protocol after MPLS
                                           (FHEI.MPLS.Upper-Layer-Protocol) */
    uint8 is_pipe_model;                /* If set, the model is pipe. Otherwise,
                                           it is uniform. (FHEI.MPLS.Model) */
    uint32 cw;                          /* Control Word (FHEI.MPLS.Control-Word) */
    uint32 label_cmd;                   /* MPLS Label Command
                                           (FHEI.MPLS.MPLS-Label-Command) */
    uint8 in_exp;                       /* n-EXP (FHEI.MPLS.In-EXP) */
    uint8 in_ttl;                       /* In-TTL (FHEI.MPLS.In-TTL) */
} bcm_pkt_dnx_pph_fhei_mpls_extension_t;

/* pph fhei trill extension */
typedef struct bcm_pkt_dnx_pph_fhei_trill_extension_s {
    uint8 in_ttl;   /* FHEI TRILL(In-TTL) */
} bcm_pkt_dnx_pph_fhei_trill_extension_t;

/* pph fhei extension */
typedef struct bcm_pkt_dnx_pph_fhei_extension_s {
    bcm_pkt_dnx_pph_fhei_type_t fhei_type; /* FHEI Type. */
    bcm_pkt_dnx_pph_fhei_bridge_extension_t bridge; /* FHEI bridge Extension (PPH.FHEI
                                           bridge Extension) */
    bcm_pkt_dnx_pph_fhei_trap_extension_t trap; /* FHEI trap Extension (PPH.FHEI trap
                                           Extension) */
    bcm_pkt_dnx_pph_fhei_ip_extension_t ip; /* FHEI IP Extension (PPH.FHEI IP
                                           Extension) */
    bcm_pkt_dnx_pph_fhei_mpls_extension_t mpls; /* FHEI MPLS Extension (PPH.FHEI MPLS
                                           Extension) */
    bcm_pkt_dnx_pph_fhei_trill_extension_t trill; /* FHEI trill Extension (PPH.FHEI trill
                                           Extension) */
} bcm_pkt_dnx_pph_fhei_extension_t;

/* pph fhei extension */
typedef struct bcm_pkt_dnx_pph_s {
    uint32 fhei_size;                   /* If present, FHEI extension size in
                                           bytes (PPH.FHEI-Size). */
    bcm_forwarding_type_t forwarding_type; /* Forwarding header type
                                           (PPH.Forwarding-Code)) */
    uint32 forwarding_header_offset;    /* Distance in bytes from the end of DNX
                                           internal headers to the for-warding
                                           header (PPH.Forwarding-Header-Offset) */
    uint32 bypass_filter;               /* If set, filtering is bypassed
                                           (PPH.Packet-Is-Control)) */
    uint32 snoop_cmnd;                  /* Snoop command (bits 3:2)
                                           (PPH.Snoop-Cpu-Code) */
    uint32 vport_orientation;           /* VPort orientation
                                           (PPH.In-LIF-Orientation */
    uint8 unknown_address;              /* Unknown Address (PPH.Unknown-Address) */
    uint8 learn_allowed;                /* If set, learning is allowed
                                           (PPH.Learn-Allowed) */
    uint32 vswitch;                     /* Packet VSI (PPH.VSI-VRF). Set if
                                           packet is not IP routed. */
    uint32 vrf;                         /* Packet VRF (PPH.VSI-VRF). Set if
                                           packet is IP routed. */
    bcm_gport_t in_vport;               /* In-VPort (PPH.In-LIF /In-RIF). */
    bcm_pkt_dnx_pph_fhei_extension_t fhei; /* FHEI Extension (PPH.FHEI-Extension). */
    bcm_pkt_dnx_pph_eei_extension_t eei; /* EEI Extension (PPH.EEI-Extension). */
    bcm_pkt_dnx_pph_learn_extension_t learn; /* Learn-Extension
                                           (PPH.Learn-Extension)). */
} bcm_pkt_dnx_pph_t;

/* otsh type */
typedef enum bcm_pkt_dnx_otsh_type_e {
    bcmPktDnxOtshTypeOam = 0,       /* OAM-TS type is OAM */
    bcmPktDnxOtshTypeL588v2 = 1,    /* OAM-TS type is 1588v2 */
    bcmPktDnxOtshTypeLatency = 2    /* OAM-TS type is packet latency */
} bcm_pkt_dnx_otsh_type_t;

/* otsh oam sutype */
typedef enum bcm_pkt_dnx_otsh_oam_subtype_e {
    bcmPktDnxOtshOamSubtypeNone = 0,    /* None */
    bcmPktDnxOtshOamSubtypeLm = 1,      /* Loss Measurement (LM) */
    bcmPktDnxOtshOamSubtypeDm1588 = 2,  /* Delay Measurement (DM) - 1588 ToD */
    bcmPktDnxOtshOamSubtypeDmNtp = 3,   /* Delay Measurement (DM) - NTP ToD */
    bcmPktDnxOtshOamSubtypeOamDefault = 4, /* Default OAM type */
    bcmPktDnxOtshOamSubtypeLoopback = 5, /* Loopback */
    bcmPktDnxOtshOamSubtypeEcn = 7      /* ECN */
} bcm_pkt_dnx_otsh_oam_subtype_t;

/* otsh */
typedef struct bcm_pkt_dnx_otsh_s {
    bcm_pkt_dnx_otsh_type_t otsh_type;  /* OAM-TS(Type). */
    bcm_pkt_dnx_otsh_oam_subtype_t oam_sub_type; /* OAM-TS(OAM-Sub-Type). Applies only
                                           when otsh_type is oam. */
    uint32 oam_up_mep;                  /* OAM-TS(MEP-Type). Applies only when
                                           otsh_type is oam. */
    uint32 tp_cmd;                      /* OAM-TS(TP-Cmd). Applies only when
                                           otsh_type is 1588. */
    uint8 ts_encap;                     /* OAM-TS(TS-Encaps). Applies only when
                                           otsh_type is 1588. */
    uint64 oam_ts_data;                 /* OAM-TS(OAM-TS-Data) */
    uint32 latency_flow_ID;             /* Latency flow ID generated by the PMF. */
    uint32 offset;                      /* OAM-TS(offset). Applies only when
                                           otsh_type is oam.. */
} bcm_pkt_dnx_otsh_t;

/* otmh src sysport extension */
typedef struct bcm_pkt_dnx_otmh_src_sysport_extension_s {
    uint8 valid;                /* Set if the extension is present */
    bcm_gport_t src_sysport;    /* Source System Port (OTMH.Source-System-Port) */
} bcm_pkt_dnx_otmh_src_sysport_extension_t;

/* otmh vport extension */
typedef struct bcm_pkt_dnx_otmh_vport_extension_s {
    uint8 valid;            /* Set if the extension is present */
    bcm_gport_t out_vport;  /* Virtual port (OTMH.Out-LIF/CUD) */
} bcm_pkt_dnx_otmh_vport_extension_t;

/* otmh */
typedef struct bcm_pkt_dnx_otmh_s {
    bcm_pkt_dnx_ftmh_action_type_t action_type; /* Action type (OTMH.TM-Action-Type) */
    bcm_color_t ftmh_dp;                /* Drop precedence (OTMH.DP) */
    uint8 is_mc_traffic;                /* AIndicate if the traffic is multicast
                                           (OTMH.System-Multicast) */
    uint32 prio;                        /* Traffic class (OTMH.Traffic-Class) */
    bcm_gport_t dst_port;               /* Destination local port
                                           (OTMH.Destination-Port) */
    bcm_pkt_dnx_otmh_src_sysport_extension_t src_sysport_ext; /* OTMH Source System Port Extension */
    bcm_pkt_dnx_otmh_vport_extension_t out_vport_ext; /* OTMH Source System Port Extension */
} bcm_pkt_dnx_otmh_t;

/* DNX internal header stack array size */
#define BCM_PKT_DNX_RAW_SIZE_MAX    20         

/* raw */
typedef struct bcm_pkt_dnx_raw_s {
    uint8 data[BCM_PKT_DNX_RAW_SIZE_MAX]; /* RAW Data */
    int len;                            /* Length of RAW Data */
} bcm_pkt_dnx_raw_t;

/* dnx packet */
typedef struct bcm_pkt_dnx_s {
    bcm_pkt_dnx_type_t type;    /* DNX Header type */
    bcm_pkt_dnx_ptch1_t ptch1;  /* PTCH-1 Header */
    bcm_pkt_dnx_ptch2_t ptch2;  /* PTCH-2 Header */
    bcm_pkt_dnx_itmh_t itmh;    /* ITMH Header */
    bcm_pkt_dnx_ftmh_t ftmh;    /* FTMH Header */
    bcm_pkt_dnx_pph_t pph;      /* PPH Header */
    bcm_pkt_dnx_otsh_t otsh;    /* OAM-TS Header (OTSH) */
    bcm_pkt_dnx_otmh_t otmh;    /* OTMH Header */
    bcm_pkt_dnx_raw_t raw;      /* Raw Header */
} bcm_pkt_dnx_t;

/* Initialize a BCM packet structure. */
struct bcm_pkt_s { 
    bcm_pkt_blk_t *pkt_data;            /* Pointer to array of data blocks. */
    uint8 blk_count;                    /* Number of blocks in data array. */
    uint8 unit;                         /* Unit number. */
    uint8 cos;                          /* The local COS queue to use. */
    uint8 prio_int;                     /* Internal priority of the packet. */
    bcm_vlan_t vlan;                    /* 802.1q VID or VSI or VPN. */
    uint8 vlan_pri;                     /* Vlan tag priority . */
    uint8 vlan_cfi;                     /* Vlan tag CFI bit. */
    bcm_vlan_t inner_vlan;              /* Inner VID or VSI or VPN. */
    uint8 inner_vlan_pri;               /* Inner vlan tag priority . */
    uint8 inner_vlan_cfi;               /* Inner vlan tag CFI bit. */
    bcm_color_t color;                  /* Packet color. */
    int8 src_port;                      /* Source port used in header/tag. */
    bcm_trunk_t src_trunk;              /* Source trunk group ID used in
                                           header/tag, -1 if src_port set . */
    uint16 src_mod;                     /* Source module ID used in header/tag. */
    uint8 dest_port;                    /* Destination port used in header/tag. */
    uint16 dest_mod;                    /* Destination module ID used in
                                           header/tag. */
    uint8 opcode;                       /* BCM_HG_OPCODE_xxx. */
    bcm_gport_t dst_gport;              /* Destination virtual port */
    bcm_gport_t src_gport;              /* Source virtual port */
    bcm_multicast_t multicast_group;    /* Destination multicast group. */
    uint32 stk_flags;                   /* Stacking header flags. */
    bcm_pkt_stk_forward_t stk_forward;  /* Stacking header forwarding opcode. */
    uint32 stk_classification_tag;      /* Stacking header classification tag. */
    uint32 stk_pkt_prio;                /* Stacking header new packet priority. */
    uint32 stk_dscp;                    /* Stacking header new DSCP. */
    uint32 stk_load_balancing_number;   /* Stacking header load balancing
                                           number. */
    bcm_if_t stk_encap_id;              /* Stacking header encapsulation ID for
                                           remote packet replication. */
    uint16 pkt_len;                     /* Packet length according to flags. */
    uint16 tot_len;                     /* Packet length as transmitted or
                                           received. */
    bcm_pbmp_t tx_pbmp;                 /* Target ports. */
    bcm_pbmp_t tx_upbmp;                /* Untagged target ports. */
    bcm_pbmp_t tx_l3pbmp;               /* L3 ports. */
    bcm_port_t pkt_trace_src_port;      /* pkt_trace_src_port */
    uint8 pfm;                          /* BCM_PORT_PFM_xxx flags. */
    uint32 rx_reason;                   /* Opcode from packet. */
    bcm_rx_reasons_t rx_reasons;        /* Set of packet "reasons". */
    uint32 rx_path;                     /* Rx path of packet. */
    uint8 rx_unit;                      /* Local rx unit. */
    uint8 rx_port;                      /* Local rx port; not in HG hdr. */
    uint8 rx_cpu_cos;                   /* CPU may get pkt on diff cos. */
    uint8 rx_untagged;                  /* The packet was untagged on ingress. */
    uint32 rx_classification_tag;       /* Classification tag. */
    uint32 rx_matched;                  /* Field processor matched rule. */
    bcm_if_t rx_l3_intf;                /* L3 egress object interface ID. */
    bcm_vlan_action_t rx_outer_tag_action; /* Outer-tag action applied to packet. */
    bcm_vlan_action_t rx_inner_tag_action; /* Inner-tag action applied to packet. */
    uint32 rx_timestamp;                /* Time stamp of time sync protocol
                                           packets. */
    uint32 rx_timestamp_upper;          /* Upper 32-bit of 64-bit timestamp of
                                           OAM DM. */
    uint32 timestamp_flags;             /* Timestamp flags. */
    void *cookie;                       /* User data for callback. */
    void *cookie2;                      /* Additional user data for callback. */
    bcm_pkt_cb_f call_back;             /* Callback function. */
    uint32 flags;                       /* BCM_PKT_F_xxx flags. */
    void *next;                         /* When linked into lists. */
    int8 dma_channel;                   /* DMA channel used; may be -1. */
    bcm_pkt_blk_t _pkt_data;            /* For single block packets (internal). */
    bcm_pkt_t *_last_pkt;               /* To link to end of linked lists
                                           (internal). */
    void *_dv;                          /* DV controlling this packet
                                           (internal). */
    int8 _idx;                          /* Packet's index in the DV for RX
                                           (internal). */
    bcm_pkt_t *_next;                   /* For BCM layer linked lists
                                           (internal). */
    void *alloc_ptr;                    /* Pointer for deallocation (internal). */
    void *trans_ptr;                    /* Transport pointer associated with
                                           packet (internal). */
    uint8 _higig[16];                   /* HiGig header value (network byte
                                           order). */
    uint8 _pb_hdr[12];                  /* Pipe Bypass Header (network byte
                                           order). */
    uint8 _sltag[4];                    /* SL tag value (network byte order). */
    uint8 _vtag[4];                     /* VLAN tag if not in packet (network
                                           byte order). */
    uint8 _sbx_rh[16];                  /* SBX Route Header & Shim. */
    uint8 _sbx_hdr_len;                 /* Length of SBX header(s). */
    uint8 _dpp_hdr[10];                 /* DPP header contents */
    int _dpp_hdr_type;                  /* DPP header and extensions type */
    int flow_id;                        /* Internal flow id. */
    uint32 filter_enable;               /* filters to be enabled. */
    bcm_pbmp_t _dv_tx_pbmp;             /* Actual pbmp assigned to tx
                                           descriptor(internal). */
    bcm_pbmp_t _dv_tx_upbmp;            /* Actual upbmp assigned to tx
                                           descriptor(internal). */
    uint32 flags2;                      /* BCM_PKT_F2_xxx flags. */
    uint8 oam_replacement_type;         /* OAM replacement type used in SOBMH
                                           header. */
    uint8 oam_replacement_offset;       /* OAM replacement offset used in SOBMH
                                           header. */
    uint16 oam_lm_counter_index;        /* OAM LM counter index used in SOBMH
                                           header. */
    uint32 rx_trap_data;                /* Additional trap information */
    void *_dcb;                         /* Pointer for dcb. */
    uint16 oam_lm_counter_index_2;      /* OAM Second LM counter index used in
                                           SOBMH header. */
    uint16 ma_ptr;                      /* OAM MA Pointer value. For BCM5645x,
                                           this corresponds to endpoint group
                                           index */
    bcm_pkt_timestamp_mode_t timestamp_mode; /* OAM DM timestamp mode */
    bcm_pkt_oam_lm_counter_mode_t counter_mode_1; /* OAM LM counter-1 mode */
    bcm_pkt_oam_lm_counter_mode_t counter_mode_2; /* OAM LM counter-2 mode */
    uint8 timestamp_offset;             /* Offset to place the timestamp in the
                                           packet. */
    bcm_rx_decap_tunnel_t rx_decap_tunnel; /* Tunnel Decap during packet rx */
    bcm_gport_t src_vport;              /* Source VPort (In-LIF) */
    bcm_gport_t dst_vport;              /* Destination VPort (Out-LIF) */
    uint32 fwd_hdr_offset;              /* Distance (in bytes) to forwarding
                                           header from start of packet */
    int snoop_cmnd;                     /* Snoop command */
    bcm_gport_t stk_dst_gport;          /* Stacking destination port */
    uint32 stk_route_tm_domains;        /* Bitmap of the traversed TM domains */
    uint32 oam_hdr_offset;              /* Distance (in bytes) to OAM header
                                           from start of packet */
    uint8 oam_lm_replacement_offset;    /* Replacement offset for LM counter in
                                           Bytes */
    bcm_pkt_rx_oam_type_t rx_oam_pkt_type; /* OAM Pkt Type. */
    bcm_pkt_oam_counter_t oam_counter[BCM_PKT_OAM_COUNTER_MAX]; /* OAM counter array. */
    uint32 oam_counter_size;            /* Size of Counter array */
    uint8 _olp_hdr[20];                 /* OLP Header (network byte order). */
    bcm_pkt_dnx_t dnx_header_stack[BCM_PKT_NOF_DNX_HEADERS]; /* DNX Header stack */
    uint8 dnx_header_count;             /* Number of DNX headers */
};

/* HiGig opcodes. */
#define BCM_HG_OPCODE_CPU       0x00       /* CPU Frame. */
#define BCM_HG_OPCODE_UC        0x01       /* Unicast Frame. */
#define BCM_HG_OPCODE_BC        0x02       /* Broadcast or DLF frame. */
#define BCM_HG_OPCODE_MC        0x03       /* Multicast Frame. */
#define BCM_HG_OPCODE_IPMC      0x04       /* IP Multicast Frame. */

/* Generic packet opcodes. */
#define BCM_PKT_OPCODE_CPU      0x00       /* CPU Frame. */
#define BCM_PKT_OPCODE_UC       0x01       /* Unicast Frame. */
#define BCM_PKT_OPCODE_BC       0x02       /* Broadcast or DLF frame. */
#define BCM_PKT_OPCODE_MC       0x03       /* Multicast Frame. */
#define BCM_PKT_OPCODE_IPMC     0x04       /* IP Multicast Frame. */

/* Packet flags. */
#define BCM_PKT_F_HGHDR             0x1        /* HiGig header is active
                                                  (internal). */
#define BCM_PKT_F_SLTAG             0x2        /* SL tag is active. */
#define BCM_PKT_F_NO_VTAG           0x4        /* Packet does not contain VLAN
                                                  tag. */
#define BCM_PKT_F_TX_UNTAG          0x8        /* TX packet untagged (internal). */
#define BCM_TX_CRC_FLD              0xf0       /* CRC information */
#define BCM_TX_CRC_ALLOC            0x10       /* Allocate buffer for CRC. */
#define BCM_TX_CRC_REGEN            0x20       /* Regenerate CRC. */
#define BCM_TX_CRC_APPEND           (BCM_TX_CRC_ALLOC + BCM_TX_CRC_REGEN) 
#define BCM_TX_CRC_FORCE_ERROR      0x40       /* Force CRC error. */
#define BCM_TX_NO_PAD               0x100      /* Do not pad runt packets. */
#define BCM_TX_FAST_PATH            0x200      /* Fast path TX. */
#define BCM_TX_PURGE                0x400      /* XGS3 Set PURGE bit in DCB
                                                  (internal). */
#define BCM_TX_LINKDOWN_TRANSMIT    0x800      /* Transmit on link down ports */
#define BCM_TX_RELIABLE             0x1000     /* Relay (tunnel) packet
                                                  reliably. */
#define BCM_TX_BEST_EFFORT          0x2000     /* Use best effort to relay
                                                  packet. */
#define BCM_TX_LOOPBACK             0x4000     /* Loopback is indicated. */
#define BCM_TX_SBX_READY            0x8000     /* SBX Route header in _sbx_rh. */
#define BCM_TX_PKT_PROP_ANY         0xf0000    /* All packet property fields. */
#define BCM_TX_SRC_MOD              0x10000    /* Use the src_mod field from
                                                  packet. */
#define BCM_TX_SRC_PORT             0x20000    /* Use the src_port field from
                                                  packet. */
#define BCM_TX_PRIO_INT             0x40000    /* Use the prio_int field from
                                                  packet. */
#define BCM_TX_PFM                  0x80000    /* Use PFM field from packet. */
#define BCM_TX_ETHER                0x100000   /* Fully mapped packet TX. */
#define BCM_TX_HG_READY             0x200000   /* HiGig header in _higig. */
#define BCM_TX_TIME_STAMP_REPORT    0x400000   /* Request transmit time stamp. */
#define BCM_RX_LEARN_DISABLED       0x800000   /* Packet's SA is not learned. */
#define BCM_RX_CRC_STRIP            0x1000000  /* Do not include the CRC in the
                                                  length of the packet. */
#define BCM_RX_TUNNELLED            0x2000000  /* Packet was tunnelled. */
#define BCM_RX_MIRRORED             0x4000000  /* Packet was mirrored. */
#define BCM_RX_TRUNCATED            0x8000000  /* Packet was truncated. */
#define BCM_PKT_F_TIMESYNC          0x10000000 /* Packet is for Time Sync
                                                  protocol. */
#define BCM_PKT_F_TRUNK             0x20000000 /* Trunk port. */
#define BCM_PKT_F_TEST              0x40000000 /* Set the Test bit. */
#define BCM_PKT_F_ROUTED            0x80000000 /* L3 switched packet. */

/* Packet flags2. */
#define BCM_PKT_F2_REPLACEMENT_TYPE         0x1        /* OAM replacement type. */
#define BCM_PKT_F2_REPLACEMENT_OFFSET       0x2        /* OAM replacement
                                                          offset. */
#define BCM_PKT_F2_LM_COUNTER_INDEX         0x4        /* OAM LM counter index. */
#define BCM_PKT_F2_TIMESTAMP_MODE           0x8        /* OAM DM time stamp type
                                                          - see
                                                          bcm_pkt_timestamp_mode_t
                                                          element, No-op by
                                                          default */
#define BCM_PKT_F2_SAMPLE_RDI               0x10       /* OAM - Sample RDI bit. */
#define BCM_PKT_F2_MA_PTR                   0x20       /* OAM - MA Pointer . */
#define BCM_PKT_F2_MEP_TYPE_UPMEP           0x40       /* OAM - MEP type -
                                                          UP/DOWN */
#define BCM_PKT_F2_LM_COUNTER_INDEX_2       0x80       /* OAM -Second LM counter
                                                          index. */
#define BCM_PKT_F2_COUNTER_MODE_1           0x100      /* OAM - Counter 1 mode -
                                                          Use specified counter
                                                          actions, no-op by
                                                          default */
#define BCM_PKT_F2_COUNTER_MODE_2           0x200      /* OAM - Counter 2 mode -
                                                          Use specified counter
                                                          actions, no-op by
                                                          default */
#define BCM_PKT_F2_SNOOPED                  0x400      /* Packet was snooped */
#define BCM_PKT_F2_UNKNOWN_DEST             0x800      /* packet has unknown
                                                          destination */
#define BCM_PKT_F2_RX_PORT                  0x1000     /* indicate that
                                                          bcm_pkt_s.rx_port is
                                                          used as a source port
                                                          for the
                                                          masquerade/visibility
                                                          feature */
#define BCM_PKT_F2_VISIBILITY_PKT           0x2000     /* indication that this
                                                          is a visibility
                                                          packet(internal) */
#define BCM_PKT_F2_OAM_TX                   0x4000     /* Indicates OAM Packet
                                                          Tx */
#define BCM_PKT_F2_OLP_READY                0x8000     /* Indicates OLP already
                                                          constructed in field
                                                          _olp_hdr */
#define BCM_PKT_F2_LM_REPLACEMENT_OFFSET    0x10000    /* OAM LM replacement
                                                          offset */

/* Flags for rx_untagged field in bcm_pkt_t structure. */
#define BCM_PKT_OUTER_UNTAGGED  0x1        /* Packet received without outer vlan
                                              tag. */
#define BCM_PKT_INNER_UNTAGGED  0x2        /* Packet received without inner vlan
                                              tag. */

/* TimeSync Packet Flags. */
#define BCM_TX_TIMESYNC_ONE_STEP            0x1        /* One step timestamp. */
#define BCM_TX_TIMESYNC_ONE_STEP_INGRESS_SIGN 0x2        /* Ingress timestamp sign
                                                          bit. */
#define BCM_TX_TIMESYNC_ONE_STEP_HDR_START_OFFSET 0x4        /* One step timestamp
                                                          header offset. */
#define BCM_TX_TIMESYNC_ONE_STEP_REGEN_UDP_CHKSUM 0x8        /* One step timestamp
                                                          header offset. */

/* Stacking Packet flags. */
#define BCM_PKT_STK_F_MIRROR                0x1        /* Mirror packet. */
#define BCM_PKT_STK_F_DO_NOT_MODIFY         0x2        /* Do not alter packet on
                                                          egress device. */
#define BCM_PKT_STK_F_TRUNK_FAILOVER        0x4        /* Packet is redirected
                                                          due to trunk failover. */
#define BCM_PKT_STK_F_SRC_PORT              0x8        /* Source GPORT provided. */
#define BCM_PKT_STK_F_DST_PORT              0x10       /* Destination GPORT
                                                          provided. */
#define BCM_PKT_STK_F_DEFERRED_DROP         0x20       /* Drop in egress device. */
#define BCM_PKT_STK_F_DEFERRED_CHANGE_PKT_PRIO 0x40       /* Update packet priority
                                                          to stk_pkt_prio in
                                                          egress device. */
#define BCM_PKT_STK_F_DEFERRED_CHANGE_DSCP  0x80       /* Update DSCP to
                                                          stk_dscp in egress
                                                          device. */
#define BCM_PKT_STK_F_CLASSIFICATION_TAG    0x100      /* stk_classification_tag
                                                          field is valid. */
#define BCM_PKT_STK_F_VLAN_TRANSLATE_NONE   0x200      /* No VLAN translation
                                                          performed. */
#define BCM_PKT_STK_F_VLAN_TRANSLATE_UNCHANGED 0x400      /* VLAN translation did
                                                          not change packet. */
#define BCM_PKT_STK_F_VLAN_TRANSLATE_CHANGED 0x800      /* VLAN translation
                                                          changed packet. */
#define BCM_PKT_STK_F_DO_NOT_LEARN          0x1000     /* Packet should not be
                                                          learned on egress
                                                          device. */
#define BCM_PKT_STK_F_PRESERVE_DSCP         0x2000     /* Egress device should
                                                          not change DSCP. */
#define BCM_PKT_STK_F_PRESERVE_PKT_PRIO     0x4000     /* Egress device should
                                                          not change packet
                                                          priority. */
#define BCM_PKT_STK_F_TX_TAG                0x8000     /* The VLAN tag should be
                                                          included in the packet
                                                          data (internal). */
#define BCM_PKT_STK_F_ENCAP_ID              0x10000    /* The stk_encap_id value
                                                          is provided. */
#define BCM_PKT_STK_F_FAILOVER              0x20000    /* Use the protection
                                                          nexthop instead of the
                                                          default nexthop. */

/* internal packet trace flags */
#define BCM_PKT_TRACE_LEARN     0x1        /* learning ensable on internal trace
                                              packet */
#define BCM_PKT_TRACE_NO_IFP    0x2        /* disable ingress field processor
                                              lookup on internal trace packet */
#define BCM_PKT_TRACE_FORWARD   0x4        /* forward internal trace packet to
                                              egress */

/* Filter types. */
#define BCM_PKT_FILTER_LAG          0x1        /* LAG filter. */
#define BCM_PKT_FILTER_TAGGED       0x2        /* Tag filter. */
#define BCM_PKT_FILTER_PORT_MASK    0x4        /* Port mask filter. */
#define BCM_PKT_FILTER_STP          0x8        /* STP filter. */
#define BCM_PKT_FILTER_EAP          0x10       /* EAP filter. */
#define BCM_PKT_FILTER_INGRESS_VLAN 0x20       /* Ingress Vlan filter. */
#define BCM_PKT_FILTER_EGRESS_VLAN  0x40       /* Egress Vlan filter. */
#define BCM_PKT_FILTER_SA           0x80       /* Source address filter. */

/* CPU to CPU tunnel modes. */
typedef enum bcm_cpu_tunnel_mode_e {
    BCM_CPU_TUNNEL_NONE = 0,            /* Do not tunnel. */
    BCM_CPU_TUNNEL_PACKET_RELIABLE = 1, /* Use reliable transport. */
    BCM_CPU_TUNNEL_PACKET_BEST_EFFORT = 2, /* Use best effort transport. */
    BCM_CPU_TUNNEL_PACKET = 3           /* Use default mode. */
} bcm_cpu_tunnel_mode_t;

/* CPU to CPU tunnel flags. */
#define BCM_CPU_TUNNEL_F_UNTAGGED       0x1        /* Untagged packet. */
#define BCM_CPU_TUNNEL_F_L3             0x2        /* L3 packet. */
#define BCM_CPU_TUNNEL_F_PBMP           0x4        /* Use port bitmap, not just
                                                      port. */
#define BCM_CPU_TUNNEL_F_RELIABLE       0x8        /* Use reliable transport. */
#define BCM_CPU_TUNNEL_F_BEST_EFFORT    0x10       /* Use best effort transport. */
#define BCM_CPU_TUNNEL_F_ALL_UNTAGGED   0x20       /* Use with port bitmap. */

/* Backward compatibility. */
#define bcm_tunnel_mode_t       bcm_cpu_tunnel_mode_t 

/* Backward compatibility. */
#define BCM_TUNNEL_NONE             BCM_CPU_TUNNEL_NONE 
#define BCM_TUNNEL_PACKET_RELIABLE  BCM_CPU_TUNNEL_PACKET_RELIABLE 
#define BCM_TUNNEL_PACKET_NO_ACK    BCM_CPU_TUNNEL_PACKET_BEST_EFFORT 
#define BCM_TUNNEL_PACKET           BCM_CPU_TUNNEL_PACKET 

/* Backward compatibility. */
#define BCM_TUNNEL_F_UNTAGGED       BCM_CPU_TUNNEL_F_UNTAGGED 
#define BCM_TUNNEL_F_L3             BCM_CPU_TUNNEL_F_L3 
#define BCM_TUNNEL_F_PBMP           BCM_CPU_TUNNEL_F_PBMP 
#define BCM_TUNNEL_F_RELIABLE       BCM_CPU_TUNNEL_F_RELIABLE 
#define BCM_TUNNEL_F_BEST_EFFORT    BCM_CPU_TUNNEL_F_BEST_EFFORT 
#define BCM_TUNNEL_F_ALL_UNTAGGED   BCM_CPU_TUNNEL_F_ALL_UNTAGGED 

/* Set up a single buffer packet. */
#define BCM_PKT_ONE_BUF_SETUP(pkt, buf, _len)  \
    do { \
        (pkt)->_pkt_data.data = (buf); \
        (pkt)->_pkt_data.len = (_len); \
        (pkt)->pkt_data = &(pkt)->_pkt_data; \
        (pkt)->blk_count = 1; \
    } while (0) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_TX_LEN_SET(pkt, _len)  \
    (pkt)->_pkt_data.len = (_len) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define _BCM_HTONS_CVT_SET(pkt, val, posn)  \
    do { \
         uint16 _tmp; \
         _tmp = bcm_htons(val); \
         sal_memcpy((pkt)->_pkt_data.data + (posn), &_tmp, 2); \
    } while (0) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_DMAC_SET(pkt, mac)  \
    sal_memcpy((pkt)->_pkt_data.data, (mac), 6) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_SMAC_SET(pkt, mac)  \
    sal_memcpy((pkt)->_pkt_data.data + 6, (mac), 6) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_TPID_SET(pkt, tpid)  \
    _BCM_HTONS_CVT_SET(pkt, tpid, 12) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_UNTAGGED_LEN_SET(pkt, len)  \
    _BCM_HTONS_CVT_SET(pkt, len, 12) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_VTAG_CONTROL_SET(pkt, vtag)  \
    _BCM_HTONS_CVT_SET(pkt, vtag, 14) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_TAGGED_LEN_SET(pkt, len)  \
    _BCM_HTONS_CVT_SET(pkt, len, 16) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_SNAP_DSAP_SET(pkt, dsap)  \
    (pkt)->_pkt_data.data[18] = (dsap) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_SNAP_SSAP_SET(pkt, ssap)  \
    (pkt)->_pkt_data.data[19] = (ssap) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_SNAP_CONTROL_SET(pkt, ctl)  \
    (pkt)->_pkt_data.data[20] = (ctl) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_SNAP_ORG_SET(pkt, b1, b2, b3)  \
     do { \
        (pkt)->_pkt_data.data[21] = (b1); \
        (pkt)->_pkt_data.data[22] = (b2); \
        (pkt)->_pkt_data.data[23] = (b3); \
    } while (0) 

/* Helper macro for single buffer Ethernet packet (not HiGig). */
#define BCM_PKT_HDR_SNAP_ETYPE_SET(pkt, etype)  \
    _BCM_HTONS_CVT_SET(pkt, etype, 24) 

/* Set a single port for a packet for TX. */
#define BCM_PKT_PORT_SET(pkt, _port, _untagged, _l3)  \
    do { \
        BCM_PBMP_PORT_SET((pkt)->tx_pbmp, _port); \
        if ((_untagged) != FALSE) { \
            BCM_PBMP_PORT_SET((pkt)->tx_upbmp, _port); \
        } else { \
            BCM_PBMP_CLEAR((pkt)->tx_upbmp); \
        } \
        if ((_l3) != FALSE) { \
            BCM_PBMP_PORT_SET((pkt)->tx_l3pbmp, _port); \
        } else { \
            BCM_PBMP_CLEAR((pkt)->tx_l3pbmp); \
        } \
    } while (0) 

/* Check if HiGig header is active in the packet. */
#define BCM_PKT_HAS_HGHDR(pkt)  \
    (((pkt)->flags & BCM_PKT_F_HGHDR) != 0) 

#define BCM_PKT_HAS_SBX_RH(pkt)  \
    ((pkt)->_sbx_hdr_len > 0) 

/* Check if SL tag is active in the packet. */
#define BCM_PKT_HAS_SLTAG(pkt)  \
    (((pkt)->flags & BCM_PKT_F_SLTAG) != 0) 

/* Check if VLAN tag is not present in packet. */
#define BCM_PKT_NO_VLAN_TAG(pkt)  \
    (((pkt)->flags & BCM_PKT_F_NO_VTAG) != 0) 

/* Do not include CRC in length on RX. */
#define BCM_PKT_RX_CRC_STRIP(pkt)  \
    ((pkt)->flags & BCM_RX_CRC_STRIP) 

/* Strip VLAN tag on RX; do not include in length. */
#define BCM_PKT_RX_VLAN_TAG_STRIP(pkt)  \
    BCM_PKT_NO_VLAN_TAG(pkt) 

#define BCM_TX_PKT_PROP_ANY_TST(pkt)  \
    (((pkt)->flags & BCM_TX_PKT_PROP_ANY) != 0) 

#define BCM_PKT_TX_ETHER(pkt)   \
    (((pkt)->flags & BCM_TX_ETHER) != 0) 

#define BCM_PKT_TX_HG_READY(pkt)  \
    (((pkt)->flags & BCM_TX_HG_READY) != 0) 

/* 
 * Check if fabric mapped, which means that the packet is sent
 * from the CPU through the HiGig ingress pipeline.
 */
#define BCM_PKT_TX_FABRIC_MAPPED(pkt)  \
            ((((pkt)->flags & BCM_TX_ETHER ) !=0 ) && \
             (((pkt)->flags & (BCM_TX_PKT_PROP_ANY | BCM_TX_HG_READY) ) !=0 )) 

/* Pointer to beginning of IEEE packet. */
#define BCM_PKT_IEEE(pkt)       \
    ((uint8*)((pkt)->pkt_data[0].data)) 

/* Length of IEEE packet including MAC addresses and CRC. */
#define BCM_PKT_IEEE_LEN(pkt)   \
    ((pkt)->pkt_len) 

/* Pointer to destination MAC address. */
#define BCM_PKT_DMAC(pkt)       \
    BCM_PKT_IEEE(pkt) 

/* Pointer to VLAN tag (all 4 bytes). */
#define BCM_PKT_VLAN_PTR(pkt)   \
   (((pkt)->flags & BCM_PKT_F_NO_VTAG) ? (pkt)->_vtag : \
    ((BCM_PKT_DMAC(pkt) + 2*sizeof(bcm_mac_t)))) 

/* The protocol (eg 0x8100) bytes. */
#define BCM_PKT_TAG_PROTOCOL(pkt)  \
    ((uint16) ((BCM_PKT_VLAN_PTR(pkt)[0] << 8) | (BCM_PKT_VLAN_PTR(pkt)[1]))) 

/* The VLAN control tag. */
#define BCM_PKT_VLAN_CONTROL(pkt)  \
    ((uint16) ((BCM_PKT_VLAN_PTR(pkt)[2] << 8) | (BCM_PKT_VLAN_PTR(pkt)[3]))) 

/* The ID from the VLAN control tag. */
#define BCM_PKT_VLAN_ID(pkt)    \
    BCM_VLAN_CTRL_ID(BCM_PKT_VLAN_CONTROL(pkt)) 

/* The priority from the VLAN control tag. */
#define BCM_PKT_VLAN_PRI(pkt)   \
    BCM_VLAN_CTRL_PRIO(BCM_PKT_VLAN_CONTROL(pkt)) 

/* The CFI from the VLAN control tag. */
#define BCM_PKT_VLAN_CFI(pkt)   \
     BCM_VLAN_CTRL_CFI(BCM_PKT_VLAN_CONTROL(pkt)) 

/* Pointer to packet's HiGig header. */
#define BCM_PKT_HG_HDR(pkt)     \
    ((pkt)->_higig) 

/* Pointer to packet's SL tag. */
#define BCM_PKT_SL_TAG(pkt)     \
    ((pkt)->_sltag) 

/* Pointer to packet's Pipeline Bypass header. */
#define BCM_PKT_PB_HDR(pkt)     \
    ((pkt)->_pb_hdr) 

#define BCM_PKT_NO_VTAG_REQUIRE(pkt)  \
    ((pkt)->flags |= BCM_PKT_F_NO_VTAG) 

#define BCM_PKT_HGHDR_CLR(pkt)  \
    ((pkt)->flags &= (~BCM_PKT_F_HGHDR)) 

#define BCM_PKT_HGHDR_REQUIRE(pkt)  \
    ((pkt)->flags |= BCM_PKT_F_HGHDR) 

#define BCM_PKT_SLTAG_REQUIRE(pkt)  \
    ((pkt)->flags |= BCM_PKT_F_SLTAG) 

/* How many bytes in the data blocks. */
#define BCM_PKT_BLK_BYTES_CALC(pkt, bytes)  \
    do { \
        int i; \
        (bytes) = 0; \
        for (i = 0; i < (pkt)->blk_count; i++) { \
            (bytes) += (pkt)->pkt_data[i].len; \
        } \
    } while (0) 

/* Packet length calculated based on flags. */
#define BCM_PKT_TX_LEN(pkt, bytes)  \
    do { \
        BCM_PKT_BLK_BYTES_CALC(pkt, bytes); \
        if (BCM_PKT_HAS_HGHDR(pkt)) (bytes) += 12; \
        if (BCM_PKT_HAS_SLTAG(pkt)) (bytes) += 4; \
        if ((pkt)->flags & BCM_PKT_F_NO_VTAG) (bytes) += 4; \
    } while (0) 

/* Packet length including SL, HiGig, VLAN tags. */
#define BCM_PKT_RX_TOT_LEN(pkt, bytes)  \
    (bytes) = (pkt)->tot_len 

/* 
 * BCM packet allocation function.
 * 
 * If unit is specified, the flags should be set up according to the unit
 * as best as possible.
 * 
 * If len > 0, then a packet buffer should be allocated and the packet
 * will be setup up for a single data block. If len <= 0, no packet
 * allocation will be made.
 */
typedef int (*bcm_pkt_alloc_f)(
    int unit, 
    int len, 
    bcm_pkt_t **pkt_buf);

/* BCM packet free function. */
typedef int (*bcm_pkt_free_f)(
    int unit, 
    bcm_pkt_t *pkt);

/* Map target ports according to VLAN and L2 tables. */
typedef int (*bcm_pkt_l2_map_f)(
    int unit, 
    bcm_pkt_t *pkt, 
    bcm_mac_t dest_mac, 
    int vid);

/* Initialize and set up a bcm_pkt_t structure. */
extern int bcm_pkt_clear(
    int unit, 
    bcm_pkt_t *pkt, 
    bcm_pkt_blk_t *blks, 
    int blk_count, 
    uint32 flags, 
    bcm_pkt_t **pkt_buf);

/* Initialize packet flags based on the type of device. */
extern int bcm_pkt_flags_init(
    int unit, 
    bcm_pkt_t *pkt, 
    uint32 init_flags);

/* Set up the length and flags for a bcm_pkt_t structure. */
extern int bcm_pkt_flags_len_setup(
    int unit, 
    bcm_pkt_t *pkt, 
    int alloc_bytes, 
    int payload_len, 
    uint32 flags);

/* Copy data into the data blocks of a packet structure. */
extern int bcm_pkt_memcpy(
    bcm_pkt_t *pkt, 
    int dest_byte, 
    uint8 *src, 
    int len);

/* Calculate a byte offset in the data buffer for a packet. */
extern int bcm_pkt_byte_index(
    bcm_pkt_t *pkt, 
    int n, 
    int *len, 
    int *blk_idx, 
    uint8 **location);

/* Allocate a packet structure and packet data. */
extern int bcm_pkt_alloc(
    int unit, 
    int size, 
    uint32 flags, 
    bcm_pkt_t **pkt_buf);

/* Deallocate a packet structure and packet data. */
extern int bcm_pkt_free(
    int unit, 
    bcm_pkt_t *pkt);

/* Allocate or deallocate an array of packets. */
extern int bcm_pkt_blk_alloc(
    int unit, 
    int count, 
    int size, 
    uint32 flags, 
    bcm_pkt_t ***packet_array);

/* Allocate or deallocate an array of packets. */
extern int bcm_pkt_blk_free(
    int unit, 
    bcm_pkt_t **pkt, 
    int count);

/* Allocate or deallocate a packet structure using =bcm_rx_alloc. */
extern int bcm_pkt_rx_alloc(
    int unit, 
    int len, 
    bcm_pkt_t **pkt_buf);

/* Allocate or deallocate a packet structure using =bcm_rx_alloc. */
extern int bcm_pkt_rx_free(
    int unit, 
    bcm_pkt_t *pkt);

/* Initialize a BCM packet structure. */
extern void bcm_pkt_t_init(
    bcm_pkt_t *pkt);

/* Initialize a BCM packet block structure. */
extern void bcm_pkt_blk_t_init(
    bcm_pkt_blk_t *pkt_blk);

/* Initialize a BCM RX reasons structure. */
extern void bcm_rx_reasons_t_init(
    bcm_rx_reasons_t *reasons);

#endif /* __BCM_PKT_H__ */
