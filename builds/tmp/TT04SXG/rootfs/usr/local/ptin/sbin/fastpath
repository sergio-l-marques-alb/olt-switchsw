#!/bin/sh

thisapp=$0
mode="run"
app_name=switchdrvr
app_path=/usr/local/ptin/sbin/$app_name
cli=/usr/local/ptin/sbin/fp.cli
proc_txt=/usr/local/ptin/log/fastpath/proc.txt
ntry=0
sspi=/usr/local/ptin/bin/sspi

insert_modules()
{
    echo "Creating character device..."
    #if [ ! -c /dev/linux-kernel-bde ]; then
    #  mknod /dev/linux-kernel-bde c 127 0
    #fi
    if [ ! -c /dev/linux-user-bde ]; then
      mknod /dev/linux-user-bde c 126 0
    fi

    echo "Inserting modules..."
    insmod /usr/local/ptin/sbin/linux-kernel-bde.ko dmasize=16M debug=1
    insmod /usr/local/ptin/sbin/linux-user-bde.ko

    sleep 1
    echo "Modules successfully inserted!"
}

wait4cxp()
{
    echo "Waiting for HW to be successfully configured..."
    while [ 1 ]
    do
        reg=`$sspi 5 1 0 1f | awk -F' ' '{print $5}' | awk -F'=' '{print $2}'`

        if [ $reg == "0x00" ]; then
            sleep 1;
        elif [ $reg == "0x01" ]; then
            echo "Hardware is configured! Ready to launch Fastpath..."
            break;
        else
            echo "Register 0x1f have an unexpected value..."
            break;
        fi
    done
}

signalcxp()
{
    echo "Signaling fwctrl that switchdrvr is ready..."
    $sspi 5 0 0x02 1f
}

startup()
{
    mkdir -p /var/log/switchdrvr

    # Insert modules
    insert_modules;

    # Launch app
    echo "Starting switchdrvr..."
    $app_path 0>/dev/null &

    # Wait 200 seconds for FP to boot up
    echo "Waiting for switchdrvr to be ready..."
    $cli ping 10 20

    # Redirect output to the default pipes
#    exec 1>&- 2>&-

    let "ntry=ntry+1"
}

# If no options, define default mode
if [ ! -z $1 ]; then
    mode=$1
fi

# Option: stop
if [ $mode = "stop" ]; then

    # Kill fastpath script process
    ps > proc.tmp
    pid_proc=`cat proc.tmp | grep $thisapp" boot" | awk '{print $1}'`
    if [ ! -z $pid_proc ]; then
        kill $pid_proc
    fi
    rm proc.tmp

    # Now, kill the switchdrvr application
    killall $app_name
    killall tail

# Option: boot
elif [ $mode = "boot" ]; then
    # Check if file exists
    if [ ! -e $app_path ]; then
        echo "File $app_path does not exist!"
        echo "Aborting FastPath launch!"
        exit 1;
    fi
    
    # Wait for CXP to boot up and configure the hardware
    wait4cxp;

    # Query application to determine if it is running or not
    echo "Giving some time before starting switchdrvr..."
    $cli ping 6 4 > /dev/null
    # Start application
    if [ $? -lt 0 -o $? -gt 1 ]; then
        echo "Going to start application"
        startup;
	signalcxp;   # Signal CXP FW that Fastpath is launched
    fi

    # Working loop...
    while [ 1 ]
    do
        # Query application to determine if it is running or not
        $cli ping 10 12 > /dev/null
        if [ $? -lt 0 -o $? -gt 1 ]; then
            echo "Transferring LOGs to Matrix board..."
            echo "Fastpath watchdog fired after 10x12 seconds of inactivity!" > /var/log/system_error_info.log
            /bin/sh /usr/local/ptin/scripts/transfer_logs.sh
            echo "FASTPATH NOT RESPONDING: rebooting" 
            /sbin/reboot
            exit;
        else
            sleep 30
        fi
    done

# No option (normal launch)
else
    # Check if file exists
    if [ ! -e $app_path ]; then
        echo "File $app_path does not exist!"
        echo "Aborting FastPath launch!"
        exit 1;
    fi
    
    # Check if app or script is already running
    ps > $proc_txt
    nproc1=$(cat $proc_txt | grep -c $app_name)
    nproc2=$(cat $proc_txt | grep -c $thisapp" boot")

    if [ $nproc1 != 0 ]; then
        echo "$app_name is already running! ($nproc)"
        exit 1
    elif [ $nproc2 != 0 ]; then
        echo "There is already a deamon responsible to startup $app_name ($nproc2)"
        exit 1
    fi

    # Launch app
    echo "Starting switchdrvr..."
    $app_path 0>/dev/null &
fi
