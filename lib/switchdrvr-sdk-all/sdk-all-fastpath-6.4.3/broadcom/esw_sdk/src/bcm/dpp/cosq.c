/*
 * $Id: cosq.c,v 1.433 Broadcom SDK $
 *
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Soc_petra-B COSQ
 */
#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_BCM_COSQ

#include <shared/bsl.h>
#include <bcm/debug.h>
#include <bcm/error.h>
#include <bcm_int/common/debug.h>
#include <bcm/cosq.h>
#include <shared/gport.h>
#include <bcm_int/api_xlate_port.h>
#include <bcm_int/petra_dispatch.h>
#include <bcm_int/dpp/utils.h>
#include <bcm_int/dpp/error.h>
#include <bcm_int/dpp/gport_mgmt.h>
#include <bcm_int/dpp/utils.h>
#include <bcm_int/dpp/error.h>
#include <bcm_int/dpp/port.h>
#include <bcm_int/dpp/cosq.h>
#include <bcm_int/dpp/switch.h>
#include <bcm_int/dpp/wb_db_cosq.h>
#include <bcm_int/control.h>
#include <bcm_int/dpp/alloc_mngr.h>
#include <bcm_int/dpp/alloc_mngr_cosq.h>
#include <bcm_int/dpp/fabric.h>
#include <bcm_int/dpp/stack.h>
#include <bcm_int/dpp/counters.h>


#include <soc/dcmn/error.h>
#include <soc/dcmn/dcmn_wb.h>
#include <soc/dpp/dpp_config_defs.h>
#include <soc/dpp/dpp_config_imp_defs.h>
#include <soc/dpp/mbcm.h>
#include <soc/dpp/drv.h>
#include <soc/dpp/port_map.h>
#include <soc/dpp/TMC/tmc_api_ingress_packet_queuing.h>
#include <soc/dpp/TMC/tmc_api_ingress_scheduler.h>
#include <soc/dpp/TMC/tmc_api_ingress_traffic_mgmt.h>
#include <soc/dpp/TMC/tmc_api_egr_queuing.h>
#include <soc/dpp/TMC/tmc_api_ofp_rates.h>
#include <soc/dpp/TMC/tmc_api_multicast_fabric.h>
#include <soc/dpp/TMC/tmc_api_flow_control.h>
#include <soc/dpp/TMC/tmc_api_ingress_scheduler.h>
#include <soc/dpp/Petra/petra_api_flow_control.h>
#include <soc/dpp/SAND/Utils/sand_framework.h>
#include <soc/dpp/debug.h>


#ifdef  BCM_PETRAB_SUPPORT
    #include <soc/dpp/Petra/petra_scheduler_elements.h>
    #include <soc/dpp/Petra/petra_egr_queuing.h>
#endif

#ifdef  BCM_ARAD_SUPPORT
    #include <soc/dpp/ARAD/arad_api_ofp_rates.h>
    #include <soc/dpp/ARAD/arad_scheduler_elements.h>
    #include <soc/dpp/ARAD/arad_api_mgmt.h>
    #include <soc/dpp/ARAD/arad_sw_db.h>
    #include <soc/dpp/ARAD/arad_nif.h>
    #include <soc/dpp/ARAD/arad_ingress_scheduler.h>
    #include <soc/dpp/ARAD/arad_api_ingress_scheduler.h>
    #include <soc/dpp/ARAD/arad_api_cnm.h>
    #include <soc/dpp/ARAD/arad_api_flow_control.h>
    #include <soc/dpp/ARAD/arad_egr_queuing.h>
    #include <soc/dpp/ARAD/arad_api_ingress_packet_queuing.h>
    #include <soc/dpp/port_sw_db.h>
#endif


/* 
 * local defines
 */

/*Used to handle delay tolarence MACRO to user q type translation*/
#define DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) (SOC_IS_JERICHO(unit) ? SOC_TMC_ITM_NOF_QT_STATIC : 0)
#define DPP_COSQ_USER_Q_TYPE_NOF_DYNANIC(unit) (ARAD_SW_DB_NOF_LEGAL_DYNAMIC_QUEUE_TYPES(unit))
/*Relevant only for Jericho*/
#define DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type) \
            (hw_q_type = (user_q_type >= SOC_TMC_ITM_PREDEFIEND_OFFSET) ? (user_q_type - SOC_TMC_ITM_PREDEFIEND_OFFSET) : user_q_type)

#define DPP_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX     (SOC_TMC_EGR_OFP_SCH_WFQ_WEIGHT_MAX)
#define DPP_COSQ_E2E_OFP_SCH_WFQ_WEIGHT_MAX     (1023)

#define DPP_COSQ_EGR_OFP_SCH_SP_LOW             (BCM_COSQ_SP1)
#define DPP_COSQ_EGR_OFP_SCH_SP_HIGH            (BCM_COSQ_SP0)

/* COSQ max num for PB */
#define DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit)  (SOC_DPP_CONFIG(unit)->tm.max_egr_q_prio-1)
#define DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)  (cosq >= 0 && cosq <= DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit))

/* Egress thresh limitations */
#define DPP_COSQ_PB_EGR_THRESH_MNT_NOF_BITS     (5)
#define DPP_COSQ_PB_EGR_THRESH_EXP_NOF_BITS     (4)
#define DPP_COSQ_PB_EGR_THRESH_NOF_BITS         (DPP_COSQ_PB_EGR_THRESH_MNT_NOF_BITS + DPP_COSQ_PB_EGR_THRESH_EXP_NOF_BITS)


/* COSQ max dp */
#define DPP_COSQ_EGR_DP_NUM_MAX                 (DPP_DEVICE_COSQ_EGR_NOF_DP-1)

/* FMQ limitations */
#define DPP_COSQ_PACKET_NOF_TC                  (8)
#define DPP_COSQ_FMQ_MAX_CLS_TC                 (SOC_TMC_MULT_FABRIC_CLS_MAX)
#define DPP_COSQ_FMQ_MAX_BURST_LIMIT            (63)
#define DPP_COSQ_FMQ_MAX_BE_WEIGHT              (15)
#define DPP_COSQ_FMQ_NOF_BE                     (SOC_TMC_MULT_FABRIC_NOF_BE_CLASSES)

#define DPP_COSQ_PB_EGR_OFP_SCH_MODE_HP_OVER_LP_FAIR (0)

/* Bandwidth limits */
#define DPP_COSQ_EGR_OFP_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)   (SOC_IS_ARAD(unit) ? SOC_TMC_IF_MAX_RATE_KBPS_ARAD:SOC_TMC_IF_MAX_RATE_KBPS_PETRA)
#define DPP_COSQ_EGR_SCH_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)   (SOC_IS_ARAD(unit) ? SOC_TMC_SCH_MAX_RATE_KBPS_ARAD:SOC_TMC_SCH_MAX_RATE_KBPS_PETRA)

#define DPP_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT (SOC_TMC_OFP_RATES_BURST_LIMIT_MAX)

#define DPP_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT (SOC_TMC_OFP_RATES_SCH_BURST_LIMIT_MAX)
#define DPP_COSQ_PB_E2E_ERP_RATE                 (10*1000*1000)
#define DPP_COSQ_PB_E2E_OLP_RATE                 (10*1000*1000)
#define DPP_COSQ_PB_E2E_OAMP_RATE                (10*1000*1000)

/* DRM factor bandwidth */
#define DPP_COSQ_DRM_FACTOR_BANDWIDTH            (72)
#define DPP_COSQ_SCH_MAX_RATE_MBPS_PER_DEVICE(unit) (SOC_IS_ARAD(unit) ? SOC_TMC_SCH_MAX_RATE_MBPS_ARAD:SOC_TMC_SCH_MAX_RATE_MBPS_PETRA)


#define DPP_COSQ_TCG_NOF_PRIORITIES_SUPPORT      (SOC_TMC_TCG_NOF_PRIORITIES_SUPPORT)

/* Default profile for Ingress TC mapping */
#define DPP_COSQ_INGRESS_TC_MAPPING_DEFAULT_PROFILE (0)

/* Default profiles for multisets */
#define DPP_COSQ_PB_ING_RATE_CLS_DEFAULT_PROFILE    (0)
#define DPP_COSQ_PB_ING_SYSTEM_RED_DP_PR_DEFAULT_PROFILE (0)
#define DPP_COSQ_PB_VSQ_RATE_CLS_DEFAULT_PROFILE    (0)
#define DPP_COSQ_PB_ING_QUEUE_MAX_SIZE_DEFAULT_VAL  (1048576)
#define DPP_COSQ_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL  (1048576)
#define DPP_COSQ_PB_ING_WRED_EXP_WQ_DEFAULT_VAL  (2)
#define DPP_COSQ_PB_ING_DISCOUNT_CLS_DEFAULT_PROFILE (0)
#define DPP_COSQ_PB_ING_DISCOUNT_DEFAULT_VALUE      (14)

#define DPP_COSQ_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE         (0)

/* Tail drop info definiations */

/* WRED info limitations */
#define DPP_COSQ_PB_WRED_WQ_MAX                     (31) /*SOC_PETRA_ITM_WQ_MAX*/

/* Discard info limitation */
#define BCM_DPP_COSQ_DISCARD_FROP_PROB              (100)
#define BCM_DPP_COSQ_DISCARD_SYSTEM_RED_FROP_PROB   (0xffff)

/* 256 MB */
#define DPP_COSQ_PB_WRED_MIN_AVRG_TH_MAX            (0XFFFFFFF)
#define DPP_COSQ_PB_WRED_MAX_AVRG_TH_MAX            (0XFFFFFFF)

/* minumum FSM mutiplier size, under which the mecahnism is disabled */
#define DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MIN_SIZE (1 << 5)
/* maximum FSM mutiplier size, over which the multiplier will still be the maximum */
#define DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE (1 << 12)

/* credit discount limitations */
#define DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL             (127)
#define DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL             (-127)

/* credit egress dicsount limitations */
#define DPP_COSQ_EGRESS_CR_DISCOUNT_MIN_VAL         (-64)
#define DPP_COSQ_EGRESS_CR_DISCOUNT_MAX_VAL         (64)

/* Cosq maximum connection class */
#define DPP_COSQ_VSQ_NOF_CONNECTION_CLASS           (32)
/* Cosq maximum VSQ pointer */
#define DPP_COSQ_VSQ_NOF_PP_POINTERS                (256)

#define DPP_COSQ_ARAD_MAX_QUEUE_PD_THRESH           (4095)
#define DPP_COSQ_ARAD_MAX_SP_PD_THRESH              (13000)

#ifdef BCM_ARAD_SUPPORT
#define DPP_COSQ_ARAD_CNM_MAX_CP_QUEUES             (8*1024)
#endif

/* Soc_petra-B comptaible mode. In case E2E gport is being retrieved always refer it as the first base_queue (cosq =0) */
#define DPP_COSQ_PB_DEFAULT_PORT_TC          (0)

#define SOC_SAND_TRUE  1
#define SOC_SAND_FALSE 0
/* Set all HR modes as request depend on Port-TC */
#define DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,mode) \
{ \
    if (SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) { \
        int tc; \
        for (tc = 0; tc < SOC_TMC_NOF_TRAFFIC_CLASSES; tc++) \
        { \
          port_info.hr_modes[tc] = mode; \
        }\
    } else { \
        port_info.hr_mode = mode; \
    } \
}

/* DROP Hyst threshold set */
#define DPP_COSQ_THRESHOLD_HYST_SET(unit,hyst,flags,value) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        hyst.set = value; \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        hyst.clear = value; \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* DROP Hyst threshold get */
#define DPP_COSQ_THRESHOLD_HYST_GET(unit,value,flags,hyst) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        value = hyst.set; \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        value = hyst.clear; \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* FC Hyst threshold set */
#define DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,hyst,cosq,flags,value) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            hyst.hp.set = value; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            hyst.lp.set = value; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            hyst.hp.clear = value; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            hyst.lp.clear = value; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* FC Hyst threshold get */
#define DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,value,cosq,flags,hyst) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            value = hyst.hp.set; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            value = hyst.lp.set; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            value = hyst.hp.set; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            value = hyst.lp.set; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}

/* Add Addmistion tests to argument */
#define DPP_COSQ_ADMISSION_TEST_ADD(arg,admission_tests) \
{ \
    arg |= (admission_tests.ctgry_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CT:0; \
    arg |= (admission_tests.ctgry_trffc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CTTC:0; \
    arg |= (admission_tests.ctgry2_3_cnctn_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CTCC:0; \
    arg |= (admission_tests.sttstcs_tag_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_ST:0; \
    arg |= (admission_tests.llfc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_LLFC:0; \
    arg |= (admission_tests.pfc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_PFC:0; \
}

/* Offsets for VSQ group IDS CBFC,LLFC*/
#define BCM_DPP_VSQ_ID_CBFC8_PETRA(soc_pb_internal_id,traffic_class) \
          (100 + ((soc_pb_internal_id / 8) << 3) + traffic_class)

#define BCM_DPP_VSQ_ID_LLFC_PETRA(soc_pb_internal_id) \
          (100 + ((soc_pb_internal_id) << 1))

#define BCM_DPP_VSQ_ID_CBFC_ARAD(arad_internal_id,traffic_class) \
          (388 + ((arad_internal_id * SOC_TMC_NOF_TRAFFIC_CLASSES) + traffic_class))

#define BCM_DPP_VSQ_ID_LLFC_ARAD(arad_internal_id) \
          (356 + (arad_internal_id))

#define BCM_DPP_COSQ_PORT_ID_TO_INTERFACE_ID(port_id) \
          (port_id - BCM_DPP_PORT_INTERFACE_START)


#define DPP_COSQ_COUNTERS_MAX_STATS               (20)
#define DPP_COSQ_COUNTERS_MAX_SETS                (SOC_TMC_NOF_TRAFFIC_CLASSES * SOC_TMC_NOF_DROP_PRECEDENCE * 2)
 

/* a drop precedence value indicating to some APIs to use ECN configuration instead of a drop precedence */
#define BCM_DPP_ECN_DP SOC_TMC_NOF_DROP_PRECEDENCE

/* 
 * Data structures
 */
typedef enum
{
    /* 
     * sch_drop_words_consumed
     */
    BCM_DPP_COSQ_THRESH_SCH_DROP_WORDS = 0,
    /* 
     * unsch_drop_words_consumed
     */
    BCM_DPP_COSQ_THRESH_UNSCH_DROP_WORDS,
    /* 
     * sch_drop_pkts_consumed
     */
    BCM_DPP_COSQ_THRESH_SCH_DROP_PKTS,
    /* 
     * unsch_drop_pkts_consumed
     */
    BCM_DPP_COSQ_THRESH_UNSCH_DROP_PKTS,
    /* 
     * sch_fc_words_consumed
     */
    BCM_DPP_COSQ_THRESH_SCH_FC_WORDS

} bcm_dpp_cosq_thresh_field_t;

/* 
 * Profile type for ingress queue
 */
typedef enum
{
    /* 
     * Rate class profile
     */
    BCM_DPP_COSQ_RATE_CLS = 0,
    /* 
     * Discount class profile
     */
    BCM_DPP_COSQ_DISCOUNT_CLS = 1,
    /* 
     * VSQ connection class
     */
    BCM_DPP_COSQ_VSQ_CC = 2,
    /* 
     * VSQ traffic class
     */
    BCM_DPP_COSQ_VSQ_TC = 3,
    /* 
     * Queue signature
     */
    BCM_DPP_COSQ_QUEUE_SIGNATURE = 4,
    /* 
     * Last entry 
     */
    BCM_DPP_COSQ_NOF_CLSSES

} bcm_dpp_cosq_queue_profile_type_t;

/* Must match order in bcm_dpp_cosq_hdlist_type_t */
static char * _dpp_list_hd_type_str[] = 
{
    "voq group state",
    "connector group state",
    "scheduler state",
    "flow state",
    "not valid"
};

/*Used to verifying validity of rate class input for queue creating*/
typedef struct bcm_dpp_cosq_queue_attributes_verify_s {
    int rate_class_nof_additions[DPP_DEVICE_COSQ_MAX_COS];
    int delay_tolerance_nof_additions[DPP_DEVICE_COSQ_MAX_COS];
    bcm_cosq_queue_attributes_t queue_attributes[DPP_DEVICE_COSQ_MAX_COS];
    int nof_delay_tolerance;
    int nof_rate_class;
    int32 reservation_change;
} bcm_dpp_cosq_queue_attributes_verify_t;


/*
 * local functions
 */
STATIC int
_bcm_petra_cosq_gport_ucast_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);

STATIC int
_bcm_petra_cosq_gport_e2e_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight);


STATIC int
_bcm_petra_cosq_gport_e2e_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight);

STATIC int
_bcm_petra_cosq_gport_ucast_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);
STATIC int
_bcm_petra_cosq_gport_egress_scheduler_port_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);
STATIC int
_bcm_petra_cosq_gport_egress_scheduler_port_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_egress_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

STATIC int
_bcm_petra_cosq_gport_egress_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);
STATIC int
_bcm_petra_cosq_gport_egress_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);
STATIC int
_bcm_petra_cosq_gport_fmq_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight);
STATIC int
_bcm_petra_cosq_gport_fmq_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight);
STATIC int
_bcm_petra_cosq_gport_egress_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_flow_bandwidth_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         uint32 kbits_sec_min,
                                         uint32 kbits_sec_max,
                                         uint32 flags);

STATIC int
_bcm_petra_cosq_gport_flow_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_sched_set(int unit,
                                                       bcm_gport_t gport,
                                                       int mode,
                                                       int weight);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_set(int unit,
                                                       bcm_gport_t gport,
                                                       int mode,
                                                       int weight);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight);

STATIC int
 _bcm_petra_cosq_gport_e2e_port_bandwidth_set(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 kbits_sec_min,
                                              uint32 kbits_sec_max,
                                              uint32 flags);
STATIC int
 _bcm_petra_cosq_gport_e2e_port_bandwidth_get(int unit,
                          bcm_gport_t gport,
                          bcm_cos_queue_t cosq,
                          uint32 *kbits_sec_min,
                          uint32 *kbits_sec_max,
                          uint32 *flags);

STATIC int
 _bcm_petra_cosq_gport_e2e_interface_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags);
STATIC int
 _bcm_petra_cosq_gport_e2e_interface_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 kbits_sec_min,
                                                          uint32 kbits_sec_max,
                                                          uint32 flags);
STATIC int
_bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 *kbits_sec_min,
                                                          uint32 *kbits_sec_max,
                                                          uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_set(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 kbits_sec_min,
                                                               uint32 kbits_sec_max,
                                                               uint32 flags);
STATIC int
_bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_get(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 *kbits_sec_min,
                                                               uint32 *kbits_sec_max,
                                                               uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

STATIC int
_bcm_petra_cosq_gport_egress_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_fmq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags);
STATIC int
_bcm_petra_cosq_gport_fmq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_isq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags);
STATIC int
_bcm_petra_cosq_gport_isq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags);
STATIC int 
_bcm_petra_egress_queue_from_cosq(int unit,
                                  int *queue_id,
                                  int cosq);
STATIC int
_bcm_dpp_cosq_egress_cosq_inband_fc_priority_get(int unit,
                           int cosq,
                           int *priority);
STATIC int
_bcm_dpp_cosq_internal_priority_get(int unit,
                                    int cosq,
                                    int *priority);
STATIC int
_bcm_petra_cosq_gport_egress_thresh_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_egress_thresh_profile_set(int unit,
                                          int port,
                                          int profile);
STATIC int
_bcm_petra_cosq_egress_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_pb_cosq_egress_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_arad_cosq_egress_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_profile);
#ifdef BCM_ARAD_SUPPORT
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_set(int unit,
                                          SOC_TMC_INTERFACE_ID if_ndx,
                                          int profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_set(int unit,
                                          SOC_TMC_INTERFACE_ID if_ndx,
                                          int profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile);
#endif
STATIC int
_bcm_petra_cosq_ocb_threshold_to_rate_class(int unit, 
                                            bcm_cosq_threshold_t *threshold,
                                            bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_cls);
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       int pool,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       int pool,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_global_fc_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_global_fc_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mci_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mci_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_chnif_fc_threshold_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_chnif_fc_threshold_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
#ifdef BCM_ARAD_SUPPORT                
STATIC int
_bcm_petra_cosq_gport_interface_egress_fc_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_interface_egress_fc_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
#endif /* BCM_ARAD_SUPPORT */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_all_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp0_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp0_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp1_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp1_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_all_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp0_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp0_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp1_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp1_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_get(int unit,
                                                            bcm_gport_t gport,
                                                            bcm_cos_queue_t cosq,
                                                            bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_queue_mapping_hw_set(int unit,
                                                  int profile,
                                                  int core,
                                                  CONST bcm_dpp_cosq_egress_queue_mapping_info_t* mapping_info);
STATIC int
_bcm_petra_cosq_gport_egress_queue_map_get(int unit,
                                           bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t *offset);
STATIC int
_bcm_petra_cosq_gport_egress_queue_map_set(int unit,
                                          bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t offset);

STATIC int
_bcm_petra_cosq_gport_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
STATIC int
_bcm_petra_cosq_gport_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
STATIC int
_bcm_petra_cosq_device_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
STATIC int
_bcm_petra_cosq_device_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
STATIC int
_bcm_petra_cosq_fmq_mapping_set(int unit, 
                                     bcm_port_t port,
                                     bcm_cos_t priority, 
                                     bcm_cos_queue_t cosq);
STATIC int
_bcm_petra_cosq_fmq_mapping_get(int unit,
                                bcm_port_t port,
                                bcm_cos_t priority,
                                bcm_cos_queue_t *cosq);
STATIC int
_bcm_petra_cosq_control_flow_get(int unit,
                                  bcm_gport_t port,
                                  bcm_cos_queue_t cosq,
                                  bcm_cosq_control_t type,
                                  int *arg);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg);

STATIC int
_bcm_petra_cosq_control_e2e_port_tc_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg);
STATIC int
_bcm_petra_cosq_control_e2e_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg);

STATIC int
_bcm_petra_cosq_control_egress_port_tc_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg);
STATIC int
_bcm_petra_cosq_control_egress_port_tcg_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg);
STATIC int
_bcm_petra_cosq_control_e2e_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
STATIC int
_bcm_petra_cosq_control_egress_port_tc_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg);
STATIC int
_bcm_petra_cosq_control_egress_port_tcg_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg);
STATIC int
_bcm_petra_cosq_control_e2e_port_tc_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg);
STATIC int
_bcm_petra_cosq_control_e2e_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg);
STATIC int
_bcm_petra_cosq_control_flow_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg);
STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg);
STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg);
STATIC int
_bcm_petra_cosq_control_device_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);

STATIC int
_bcm_petra_cosq_control_e2e_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_egress_port_scheduler_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
STATIC int
_bcm_petra_cosq_control_egress_port_scheduler_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_egress_interface_scheduler_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
STATIC int
_bcm_petra_cosq_control_egress_interface_scheduler_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_fmq_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);


STATIC int
_bcm_petra_cosq_control_fmq_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_device_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_egress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg);
STATIC int
_bcm_petra_cosq_control_egress_queue_get(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int *arg);
STATIC int
_bcm_petra_cosq_control_ingress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg);
STATIC int
_bcm_petra_cosq_control_ingress_queue_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg);
STATIC int
_bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(int unit,
                                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_old,
                                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_new,
                                                               int nof_queues_mapped, 
                                                               int32 *reservation_change);
#ifdef BCM_ARAD_SUPPORT
STATIC int
_bcm_petra_cosq_gport_ingress_queue_mapping_profile_set(int unit,
                                                        int core,
                                                        int qid,
                                                        int rate_class);
#endif /*BCM_ARAD_SUPPORT*/
STATIC int
_bcm_petra_cosq_voq_class_mapping_set(int unit,
                                      int core,
                                      int voq,
                                      bcm_dpp_cosq_queue_profile_type_t profile_type,
                                      int profile);
STATIC int
_bcm_petra_cosq_voq_class_mapping_get(int unit,
                                      int core,
                                      int voq,
                                      bcm_dpp_cosq_queue_profile_type_t profile_type,
                                      int* profile);
STATIC int
_bcm_petra_cosq_voq_rate_class_hw_get(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info);
STATIC int
_bcm_petra_cosq_voq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *exact_rate_class_info);

STATIC int
_bcm_petra_cosq_sys_red_dp_pr_hw_set(int unit,
                                     int dp_pr,
                                     bcm_dpp_cosq_ingress_system_red_dp_pr_info_t *rate_sys_red_dp_pr_info);

STATIC int
_bcm_petra_cosq_gport_gport_size_to_rate_class(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t* gport_size,
                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                               int set_alpha, 
                                               int min_supported);
STATIC int
_bcm_petra_cosq_gport_rate_class_to_gport_size(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t *gport_size,
                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class);
STATIC int
_bcm_petra_cosq_gport_voq_color_size_verify(int unit, 
                                            bcm_color_t color,
                                            uint32      flags,
                                            bcm_cosq_gport_size_t* gport_size,
                                            int*        set_alpha, 
                                            int*        min_supported);
#ifdef BCM_ARAD_SUPPORT
STATIC int
_bcm_petra_cosq_gport_rate_class_color_size_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_color_t color,
                                                uint32 flags,
                                                bcm_cosq_gport_size_t *gport_size);

STATIC int
_bcm_petra_cosq_gport_rate_class_color_size_get(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_color_t color,
                                                    uint32 flags,
                                                    bcm_cosq_gport_size_t *gport_size);
#endif /*BCM_ARAD_SUPPORT*/
STATIC int
_bcm_petra_cosq_gport_voq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
STATIC int
_bcm_petra_cosq_gport_voq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);

STATIC int
_bcm_petra_cosq_gport_discard_to_rate_class_data(int unit, 
                                                 bcm_cosq_gport_discard_t *discard,
                                                 bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class);
STATIC int
_bcm_petra_cosq_gport_rate_class_data_to_discard(int unit, 
                                                 bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                                 bcm_cosq_gport_discard_t *discard);
#ifdef BCM_ARAD_SUPPORT
STATIC int
_bcm_petra_cosq_gport_rate_class_discard_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_gport_rate_class_discard_get(int unit, 
                                             bcm_gport_t gport, 
                                             bcm_cosq_gport_discard_t *discard);
#endif /*BCM_ARAD_SUPPORT*/
STATIC int
_bcm_petra_cosq_gport_voq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_gport_voq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_sched_gport_add(int unit,
                                bcm_gport_t port,
                                int numq,
                                uint32 flags,
                                bcm_gport_t *gport);

STATIC int
_bcm_petra_cosq_connector_gport_add(int unit,
                                    bcm_gport_t port,
                                    int numq,
                                    uint32 flags,
                                    bcm_gport_t *gport);
STATIC int
_bcm_petra_cosq_mcast_gport_add(int unit,
                                bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                                bcm_gport_t *gport);
STATIC int
_bcm_petra_cosq_ucast_gport_add(int unit, 
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport);

STATIC int
_bcm_petra_cosq_connector_gport_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_gport_t *physical_port,
                                    int *num_cos_levels,
                                    uint32 *flags);

STATIC int
_bcm_petra_cosq_sched_gport_get(int unit,
                                bcm_gport_t gport,
                                bcm_gport_t *physical_port,
                                int *num_cos_levels,
                                uint32 *flags);

STATIC int
_bcm_petra_cosq_e2e_gport_get(int unit,
                              bcm_gport_t gport,
                              bcm_gport_t *physical_port,
                              int *num_cos_levels,
                              uint32 *flags);

STATIC int
_bcm_petra_cosq_ucast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags);

STATIC int
_bcm_petra_cosq_mcast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags);

STATIC int
_bcm_petra_cosq_delay_tolerance_to_user_q_type(
    int unit,
    int delay_tolerance_level,
    SOC_TMC_ITM_QT_NDX *user_q_type);
STATIC int
_bcm_petra_cosq_user_q_type_to_delay_tolerance(
    int unit,
    SOC_TMC_ITM_QT_NDX user_q_type,
    int *delay_tolerance_level);

int static
_bcm_petra_cosq_sched_connector_gport_detach(int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq);

STATIC int
_bcm_petra_cosq_sched_gport_delete(int unit, bcm_gport_t gport);

STATIC int
_bcm_petra_cosq_connector_gport_delete(int unit, bcm_gport_t gport);

STATIC int
_bcm_petra_cosq_mcast_gport_delete(int unit, bcm_gport_t gport);

STATIC int
_bcm_petra_cosq_ucast_gport_delete(int unit, bcm_gport_t gport);

STATIC int
_bcm_petra_cosq_ofp_sch_mode_set(int unit,
                                 int sch_mode);
STATIC int
_bcm_petra_cosq_fap_port_get(int unit,
                            bcm_gport_t gport,
                            uint32 *p_fap_port,
                            int *core);

int
bcm_petra_tm_port_get(int unit, int p_fap_port, bcm_port_t* port);

int
bcm_petra_cosq_user_port_get(int unit, bcm_gport_t gport, bcm_port_t *user_port);

STATIC int
_bcm_petra_cosq_cal_reception_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count              /* INOUT */
                                           );

STATIC int
_bcm_petra_cosq_noncal_reception_fc_path_get(int unit,
                                             bcm_cosq_fc_direction_type_t fc_direction,
                                             bcm_cosq_fc_endpoint_t *source,
                                             int max_target,
                                             bcm_cosq_fc_endpoint_t *target, /* OUT */
                                             int *target_count               /* OUT */
                                             );

int
bcm_petra_cosq_fc_port_info_get(int             unit,
                                bcm_gport_t     gport,
                                int            *is_fc_calender,
                                int            *is_fc_inband,
                                uint32         *fc_calender_port,
                                uint32         *nif_id);

int
bcm_petra_cosq_port_info_get(int             unit,
                             bcm_gport_t     gport,
                             int            *is_channelization_ability,
                             int            *no_classes,
                             uint32         *nif_id,
                             int            *no_queues);

int
bcm_petra_cosq_port_nif_get(int              unit,
                             bcm_gport_t     gport,
                             uint32         *nif_id);

int
bcm_petra_cosq_nif_to_gport_get(int              unit,
                                uint32          nif_id,
                                bcm_gport_t     *gport);

STATIC int
_bcm_petra_cosq_sched_init(int unit);

STATIC int
_bcm_petra_cosq_sched_cl_verfiy_flags_mode_get(int unit, int flags, int *cl_mode, int *enhanced_mode, int *weight_mode);

STATIC int
_bcm_petra_sched_cl_profile_get(int unit, int mode, int enhanced_mode, int weight_mode, int validate_only, int *cid);

/* VSQ local functions  { */
STATIC int 
_bcm_petra_cosq_voq_discard_retreive_dps(int unit,
                                         uint32 flags,
                                         int *dps,
                                         int *nof_dps);
STATIC int
_bcm_petra_cosq_gport_discard_verify(int unit,
                                     bcm_cosq_gport_discard_t *discard,
                                     int is_vsq);
STATIC int
_bcm_petra_cosq_vsq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_vsq_rate_class_info_t *rate_class_info,
                                      bcm_dpp_cosq_vsq_rate_class_info_t *exact_rate_class_info);
STATIC int
_bcm_petra_cosq_vsq_rate_class_exchange_set(int unit,
                                            SOC_TMC_ITM_VSQ_NDX vsq_id,
                                            bcm_dpp_cosq_vsq_rate_class_info_t *data_rate_class);
STATIC int 
_bcm_petra_cosq_vsq_id_range_verify(int unit,
                                    int queue_id,
                                    int vsq_category,
                                    int *is_match);

STATIC int 
_bcm_petra_cosq_gport_vsq_get_group_type(int unit,
                                         bcm_cosq_vsq_info_t* vsq_info,
                                         bcm_dpp_cosq_vsq_type_t *vsq_group_type);

STATIC int
_bcm_petra_cosq_vsq_local_port_from_gport(int unit,
                                          bcm_gport_t src_port,
                                          int *local_port);
STATIC int 
_bcm_petra_cosq_gport_vsq_gport_set(int unit,
                                    bcm_cosq_vsq_info_t* vsq_info,
                                    bcm_dpp_cosq_vsq_type_t vsq_group_type,                                    
                                    bcm_gport_t *vsq_gport);

STATIC int 
_bcm_petra_cosq_vsq_info_verify(int unit,
                                bcm_cosq_vsq_info_t *vsq_info);
STATIC int
_bcm_petra_cosq_gport_vsq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_gport_vsq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_gport_vsq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
STATIC int
_bcm_petra_cosq_gport_vsq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
STATIC int
_bcm_petra_cosq_vsq_gl_drop_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_vsq_gl_drop_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_vsq_gl_fc_threshold_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold);
STATIC int
_bcm_petra_cosq_vsq_gl_fc_threshold_get(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold);
/* VSQ local functions  } */

STATIC int
_bcm_petra_cosq_fc_path_add_remove(int unit,
                                   int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);

STATIC int
_bcm_petra_cosq_generation_fc_path_add(int unit,
                                       int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);
STATIC int
_bcm_petra_cosq_reception_fc_path_add(int unit,
                                      int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);
STATIC int
_bcm_petra_cosq_generation_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count);
STATIC int
_bcm_petra_cosq_reception_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count);

STATIC int
_bcm_petra_cosq_fc_init(int unit);


/*
 * Support Functions - Flow 
 */
int
_bcm_petra_se_flow_id_get(int unit, int flow_id, SOC_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow);

STATIC int
_bcm_petra_nbr_flow_quartets_for_queue_quartet(int unit, int is_interdigitated, int is_composite,
                                                                       int *nbr_flow_quartets);

STATIC int
_bcm_petra_cosq_mode_get(int unit, SOC_TMC_SCH_FLOW *flow_config, int is_sf2, int *mode);

STATIC int
_bcm_petra_cosq_credit_class_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, int mode, bcm_dpp_cosq_class_info_t *info);

STATIC int
_bcm_petra_cosq_sched_enhanced_mode_get(int unit, SOC_TMC_SCH_SE_INFO *sch_info, int *is_enhanced, int *enhanced_mode);

STATIC int
_bcm_petra_cosq_cl_sched_weight_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info, bcm_dpp_cosq_class_info_t *info, int *weight);

STATIC int
_bcm_petra_cosq_credit_class_weight_validate(int unit, int weight, bcm_dpp_cosq_class_info_t *info, int *updated_type);

STATIC int
_bcm_petra_cosq_gport_validate_info_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int flags, bcm_dpp_cosq_gport_info_t *info);

STATIC int
_bcm_petra_cosq_bcm_cosq_to_tcg(int unit,int cosq,SOC_TMC_TCG_NDX *tcg);
STATIC int
_bcm_petra_cosq_port_tcg_validate(int unit, bcm_gport_t gport, SOC_TMC_TCG_NDX tcg);

STATIC int
_bcm_petra_cosq_port_priority_validate(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq);

STATIC int
_bcm_petra_cosq_validate_connector_id(int unit, int is_non_contiguous, int is_composite, int num_cos, int flow_id);

STATIC int
_bcm_petra_cosq_parent_gport_to_resource_gport(int unit, bcm_gport_t sched_port, bcm_gport_t *parent_port);

STATIC int
_bcm_petra_cosq_ingress_tc_mapping_set(int unit, bcm_port_t port, bcm_cos_t priority, bcm_cos_queue_t cosq);

STATIC int 
_bcm_petra_cosq_ingress_tc_mapping_hw_set(int unit, int profile, int is_flow, SOC_TMC_ITM_TC_MAPPING *tc_mapping);

STATIC int
_bcm_petra_cosq_ingress_tc_mapping_get(int unit, bcm_port_t port, bcm_cos_t priority, bcm_cos_queue_t *cosq);

STATIC int 
_bcm_petra_cosq_stk_sysport_set(int unit, int core, int sysport, int *stk_exist);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_get(int unit, bcm_gport_t gport, uint32 *min, uint32 *max, uint32 *flags);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_get(int unit, bcm_gport_t gport, uint32 *min, uint32 *max, uint32 *flags);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_set(int unit, bcm_gport_t gport, uint32 min, uint32 max, uint32 flags);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_set(int unit, bcm_gport_t gport, uint32 min, uint32 max, uint32 flags);

int
_bcm_arad_cosq_control_congestion_queue_range_set(int unit, bcm_cosq_control_t type, int arg);

int
_bcm_arad_cosq_control_congestion_queue_range_get(int unit, bcm_cosq_control_t type, int *arg);


#ifdef BCM_ARAD_SUPPORT
STATIC int 
_bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(int unit, int generic_bm_id, SOC_TMC_FC_PFC_GENERIC_BITMAP *bitmap);

int 
bcm_arad_cosq_qcn_config_set(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config);

int 
bcm_arad_cosq_qcn_config_get(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config);

int
_bcm_arad_cosq_update_reserved_pd_threshold_all_sps(int unit);

STATIC int _bcm_arad_cosq_cnm_queue_profile_hw_set(int unit, int profile_id, SOC_TMC_CNM_CP_PROFILE_INFO *profile_info);
STATIC int _bcm_arad_cosq_cnm_queue_profile_hw_get(int unit, int profile_id, SOC_TMC_CNM_CP_PROFILE_INFO *profile_info);

#endif /* BCM_ARAD_SUPPORT */
STATIC int
_bcm_petra_cosq_port2se_id(int unit, int fap_port, bcm_cos_t priority, SOC_TMC_SCH_SE_ID *se_id);

STATIC int
_bcm_petra_cosq_se_id2port(int unit, SOC_TMC_SCH_SE_ID se_id, int *fap_port, bcm_cos_t *priority);

STATIC int
_bcm_petra_cosq_vsq_info_get(int unit, bcm_gport_t vsq, bcm_cosq_vsq_info_t *vsq_info);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg);

#ifdef  BCM_ARAD_SUPPORT

STATIC int
_bcm_petra_cosq_cal_reception_pfc_set(int unit, 
                                      int is_for_delete,
                                      bcm_cosq_fc_endpoint_t *target, 
                                      SOC_TMC_FC_REC_CALENDAR *cal_buff, 
                                      int cal_index, 
                                      uint32 *target_id, 
                                      SOC_TMC_FC_REC_CAL_DEST *cal_dest, 
                                      int *update_entry);

#endif

/*
 * element (data structure) allocation
 */
/* static */ bcm_dpp_cosq_list_hd_t * _bcm_petra_cosq_listhd_alloc(int unit);

STATIC int _bcm_petra_cosq_listhd_init(int unit, 
                                       bcm_dpp_cosq_list_hd_t *hd,
                                       int num_elements_per_blk,
                                       int element_size,
                                       int index_divisor,
                                       bcm_dpp_cosq_hdlist_type_t type);

STATIC int _bcm_petra_cosq_element_free(int unit, bcm_dpp_cosq_list_hd_t *hd, int element_index);


#ifdef BCM_WARM_BOOT_SUPPORT
STATIC int bcm_petra_cosq_restore_fmq_hr_state(int unit);
#endif /* BCM_WARM_BOOT_SUPPORT */



CONST STATIC dpp_am_cosq_resource_info_t dpp_am_cosq_resource_info =
{
    _bcm_petra_flow_region_config,
    _bcm_petra_queue_region_config
};

bcm_dpp_cosq_config_t _dpp_cosq_config[BCM_MAX_NUM_UNITS];

/*
 * utility functions
 */
/* 
 * Purpose:
 * Convert from BCM SP modes to petra EGR OFP interface prio modes
 */
STATIC int
_bcm_petra_cosq_mode_sp_to_egr_ofp_interface_prio(int unit, int mode,
                                            SOC_TMC_EGR_OFP_INTERFACE_PRIO *nif_priority)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if (SOC_IS_PETRAB(unit))
    {
      switch(mode) {
          case BCM_COSQ_SP0:
              *nif_priority = SOC_TMC_EGR_OFP_INTERFACE_PRIO_HIGH;
              break;
          case BCM_COSQ_SP1:
              *nif_priority = SOC_TMC_EGR_OFP_INTERFACE_PRIO_MID;
              break;
          case BCM_COSQ_SP2:
              *nif_priority = SOC_TMC_EGR_OFP_INTERFACE_PRIO_LOW;
              break;
          default:
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid mode %d"), unit ,mode));
      }
    }
#ifdef BCM_ARAD_SUPPORT                
    if (SOC_IS_ARAD(unit))
    {
      switch(mode) {
          case BCM_COSQ_SP0:
              *nif_priority = SOC_TMC_EGR_OFP_INTERFACE_PRIO_HIGH;
              break;
          case BCM_COSQ_SP1:
              *nif_priority = SOC_TMC_EGR_OFP_INTERFACE_PRIO_LOW;
              break;          
          default:
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid mode %d"), unit ,mode));
      }
    }
#endif /* BCM_ARAD_SUPPORT */

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Convert BCM VSQ TYPES to TMC VSQ TYPES
 */
STATIC int
_bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(bcm_dpp_cosq_vsq_type_t vsq_type,
                                             SOC_TMC_ITM_VSQ_GROUP *soc_tmcvsq_type)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch(vsq_type) {
        case BCM_DPP_COSQ_VSQ_TYPE_CTGRY:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_CTGRY;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_CTCC:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_CTGRY_2_3_CNCTN_CLS;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_CTTC:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_CTGRY_TRAFFIC_CLS;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_PP:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_STTSTCS_TAG;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_LLFC:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_LLFC;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_PFC:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_PFC;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG_STR("cosq type %d is not matched to tmc vsq group type\n"), vsq_type));  
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Convert TMC VSQ TYPES to BCM VSQ TYPES
 */
STATIC int
_bcm_petra_cosq_tmc_vsq_type_to_bcm_vsq_type(SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type,
                                             bcm_dpp_cosq_vsq_type_t *vsq_type)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch(soc_tmcvsq_type) {
        case SOC_TMC_ITM_VSQ_GROUP_CTGRY:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_CTGRY;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_CTGRY_2_3_CNCTN_CLS:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_CTCC;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_CTGRY_TRAFFIC_CLS:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_CTTC;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_STTSTCS_TAG:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_PP;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_LLFC:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_LLFC;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_PFC:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_PFC;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG_STR("cosq tmc type %d is not matched to bcm vsq group type\n"), soc_tmcvsq_type));
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Purpose:
 * Convert between modes to petra EGR OFP sch mode
 */
STATIC int
_bcm_petra_cosq_bcm_sch_mode_to_egr_ofp_sch_mode(int mode,
                                                SOC_TMC_EGR_OFP_SCH_MODE *sch_mode)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch(mode) {
        case DPP_COSQ_PB_EGR_OFP_SCH_MODE_HP_OVER_LP_FAIR:
            *sch_mode = SOC_TMC_EGR_HP_OVER_LP_FAIR;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG_NO_UNIT("invalid mode %d"),mode));
    }   
         
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Convert from BCM cosq to petra EGR Q Prio
 */
STATIC int
_bcm_petra_cosq_bcm_cosq_to_egr_q_prio(int unit,
                                      int cosq,
                                      SOC_TMC_EGR_Q_PRIO *prio)
{
    BCMDNX_INIT_FUNC_DEFS;
    if(SOC_IS_PETRAB(unit)) {
        switch(cosq) {
            case BCM_COSQ_LOW_PRIORITY:
            case 1:
                *prio = SOC_TMC_EGR_Q_PRIO_LOW;
                break;
            case BCM_COSQ_HIGH_PRIORITY:
            case 0:
                *prio = SOC_TMC_EGR_Q_PRIO_HIGH;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d: invalid cosq %d"), unit, cosq));
        }
        BCM_EXIT;
    }
    if(SOC_IS_ARAD(unit)) {
        switch(cosq) {
            case BCM_COSQ_HIGH_PRIORITY:
            case 0:
                *prio = SOC_TMC_EGR_Q_PRIO_0;
                break;
            case BCM_COSQ_LOW_PRIORITY:
            case 1:
                *prio = SOC_TMC_EGR_Q_PRIO_1;
                break;
            case 2:
                *prio = SOC_TMC_EGR_Q_PRIO_2;
                break;
            case 3:
                *prio = SOC_TMC_EGR_Q_PRIO_3;
                break;
            case 4:
                *prio = SOC_TMC_EGR_Q_PRIO_4;
                break;
            case 5:
                *prio = SOC_TMC_EGR_Q_PRIO_5;
                break;
            case 6:
                *prio = SOC_TMC_EGR_Q_PRIO_6;
                break;
            case 7:
                *prio = SOC_TMC_EGR_Q_PRIO_7;
                break;
            case -1:
                *prio = SOC_TMC_EGR_Q_PRIO_ALL;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d: invalid cosq %d"), unit, cosq));
        }
        BCM_EXIT;
    }
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d: is invalid"), unit));  
exit:
    BCMDNX_FUNC_RETURN;
}
                      
STATIC int
_bcm_petra_cosq_port2se_id(int unit, 
                           int fap_port, 
                           bcm_cos_t priority, 
                           SOC_TMC_SCH_SE_ID *se_id)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 soc_sand_rc = 0;
    
    int core = 0 ;

    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        /* Priority must be default */
        if (priority != DPP_COSQ_PB_DEFAULT_PORT_TC) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, priortiy given is out of range, should be set to 0 or -1 %d"), unit, priority));
        }
        *se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_port2se_id,(fap_port)));     
    } else {      
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority, se_id)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority, soc_sand_rc, rc));
        }      
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_se_id2port(int unit, 
                           SOC_TMC_SCH_SE_ID se_id,
                           int *fap_port, 
                           bcm_cos_t *priority)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 soc_sand_rc = 0, port_id = 0, tc = 0;

    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        *fap_port = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2port_id,(se_id)));     
        *priority = DPP_COSQ_PB_DEFAULT_PORT_TC;
    }  else {      
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_se2port_tc_id,(unit, se_id, &port_id, &tc)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in getting port, tc from HR scheduler element %d, soc_sand error 0x%x, rc error 0x%x"), unit, se_id, soc_sand_rc, rc));
        }      
        *fap_port = port_id;
        *priority = tc;
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC unsigned int
_bcm_cosq_bit_count_get(uint32 value);

int
bcm_petra_cosq_internal_ports_init(int unit)
{
    bcm_error_t rc = BCM_E_NONE;
    int internal_ports_max = DPP_COSQ_SCH_MAX_PORT_ID(unit);
    int internal_ports_count, internal_ports_count_sum;
    bcm_gport_t *internal_gport = NULL;    
    uint32 soc_sand_rc;
    uint32 fap_port;
    SOC_TMC_SCH_PORT_INFO port_info;
    SOC_TMC_INTERFACE_ID if_ids[3];
    uint32 internal_rates[3];
    bcm_gport_t internal_gport_sum[3];
    int internal_port_i;
    int core;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_SCH_PORT_INFO_clear(&port_info);
    /* Set default port information */
    port_info.enable = TRUE;    
    DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
    if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
    }

    BCMDNX_ALLOC(internal_gport, sizeof(bcm_gport_t) * internal_ports_max, "internal port gport handle memory");
    if (internal_gport == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate internal port gport handle memory"), unit));
    }

    /*
     * Get OLP/OAMP/ERP ports, and fill interface + rate per type
    */
    internal_ports_count_sum = 0;

    rc = bcm_petra_port_internal_get(unit, BCM_PORT_INTERNAL_OLP,internal_ports_max, &internal_gport[0], &internal_ports_count);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get Gport OLP/ERP/OAMP port error(0x%x)\n"),rc));       
        goto err;
    } 
    if (internal_ports_count) {
        if_ids[internal_ports_count_sum] = SOC_TMC_IF_ID_OLP;
        internal_rates[internal_ports_count_sum] = DPP_COSQ_PB_E2E_OLP_RATE;
        internal_gport_sum[internal_ports_count_sum] = internal_gport[0];
        ++internal_ports_count_sum;
    }

    rc = bcm_petra_port_internal_get(unit, BCM_PORT_INTERNAL_EGRESS_REPLICATION,internal_ports_max, &internal_gport[0], &internal_ports_count);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get Gport OLP/ERP/OAMP port error(0x%x)\n"),rc));       
        goto err;
    } 
    if (internal_ports_count) {
        if_ids[internal_ports_count_sum] = SOC_TMC_IF_ID_ERP;
        internal_rates[internal_ports_count_sum] = DPP_COSQ_PB_E2E_ERP_RATE;
        internal_gport_sum[internal_ports_count_sum] = internal_gport[0];
        ++internal_ports_count_sum;
    }

    rc = bcm_petra_port_internal_get(unit, BCM_PORT_INTERNAL_OAMP,internal_ports_max, &internal_gport[0], &internal_ports_count);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get Gport OLP/ERP/OAMP port error(0x%x)\n"),rc));       
        goto err;
    } 
    if (internal_ports_count) {
        if_ids[internal_ports_count_sum] = SOC_TMC_IF_ID_OAMP;
        internal_rates[internal_ports_count_sum] = DPP_COSQ_PB_E2E_OAMP_RATE;
        internal_gport_sum[internal_ports_count_sum] = internal_gport[0];
        ++internal_ports_count_sum;
    }

    /* Configure OLP/OAMP/ERP if valid */
    for (internal_port_i = 0; internal_port_i < internal_ports_count_sum; internal_port_i++) {
        rc = _bcm_petra_cosq_fap_port_get(unit, internal_gport_sum[internal_port_i], &fap_port, &core);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get OFP OLP/OAMP port gport: 0x%x, error(0x%x)\n"), internal_port_i, rc));                   
            goto err;
        }
                          
        if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), fap_port));
            goto err;
        }
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_device_if_weight_idx_set,(unit, if_ids[internal_port_i], 1)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), 
                                  unit, fap_port, soc_sand_rc, rc));
            goto err;
        }
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_if_shaper_rate_set, (unit, core, fap_port, internal_rates[internal_port_i])));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), 
                                  unit, fap_port, soc_sand_rc, rc));
            goto err;
        }
        
        port_info.max_expected_rate = internal_rates[internal_port_i]/1000;;
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            goto err;
        }
    }
err:
    if (internal_gport != NULL) {
        BCM_FREE(internal_gport);
    }
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(int unit)
{

    int rc = BCM_E_NONE;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    uint32 rate_class_index;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED)
    {
        /*enable new mode*/
        BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_set(unit, ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED));

        /*set all rate classes to default sttings*/
        for (rate_class_index = 0; rate_class_index < SOC_TMC_ITM_NOF_RATE_CLASSES; rate_class_index++) 
        {
            rc = _bcm_petra_cosq_voq_rate_class_default_set(unit, rate_class_index, &rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }

    } else if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        /*if we enabled simple mode we cnnot use the advanced mapping mode.*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue-to-rate class mapping mode is configured to be simple: advanced mapping cnnot be used")));
    } /*if we allready enabled advanced mode: do nothing.*/
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_queue_rate_cls_mapping_mode_simple_enable(int unit)
{

    int rc = BCM_E_NONE;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info;
    int is_allocated, 
        rate_class,
        ref_count;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED) {
        /*enable new mode*/
        BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_set(unit, ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE));

        /*init alloc mngr*/
        for (rate_class = 0; rate_class < SOC_TMC_ITM_RATE_CLASS_MAX; rate_class++) {
            /*Get ref count from SW state*/
            BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_get(unit, (uint32)rate_class, (uint32*)&ref_count));
            if (ref_count != 0) {
                /*Get HW configuration*/
                rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &rate_class_info);
                BCMDNX_IF_ERR_EXIT(rc);
                rc = _bcm_dpp_am_template_queue_rate_cls_allocate_group(unit,
                                                                        SHR_TEMPLATE_MANAGE_SET_WITH_ID,
                                                                        &rate_class_info,
                                                                        ref_count,
                                                                        &is_allocated,
                                                                        &rate_class);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    } else if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED) {
        /*if we enabled simple mode we cnnot use the advanced mapping mode.*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue-to-rate class mapping mode is configured to be advanced: simple mapping cnnot be used")));
    } /*if we allready sime advanced mode: do nothing.*/
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Ideally for code maintenance and readability code path could be the same across
 * coldboot and warmboot. This requires that that at the low level driver all
 * configuration (write accesses) be blocked. The low level driver should allow read
 * accesses (coreesponding write accesses e.g. reading indirect registers/memory).
 *
 * Since this is currently not implemented (i.e blocking all configuration changes)
 * specific coldboot/warmboot checks are added in the init phase.
 *
 * NOTE:
 *      mode of restoring state via replay of commands is not suppoted. Thus it is not
 *      mandatory for the low level driver to block writes during init phase.
 */
int
bcm_petra_cosq_init(int unit)
{
    bcm_error_t rc = BCM_E_NONE;
    int reserved_flow_id;
    int egr_sch_mode;
    int idx, idx1, discount_data = 0;
    uint32 profile, tm_port;
    bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info = NULL;
    bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *uc_thresh_info = NULL;
    bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *mc_thresh_info = NULL;
    bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info = NULL, *exact_rate_class_info = NULL;
    bcm_dpp_cosq_ingress_system_red_dp_pr_info_t *sys_red_dp_pr_info = NULL;
    bcm_dpp_cosq_vsq_rate_class_info_t *vsq_rate_class_info = NULL, *vsq_exact_rate_class_info = NULL;
    SOC_TMC_ITM_VSQ_TAIL_DROP_INFO vsq_max_size_default_info;
    SOC_TMC_ITM_CR_DISCOUNT_INFO discount_info;
    SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO egr_discount_info;
    SOC_TMC_ITM_TC_MAPPING tc_mapping;
    SOC_TMC_SCH_PORT_INFO port_info;
    bcm_port_t port_i;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_TAIL_DROP_INFO tail_drop_info;
    SOC_TMC_ITM_TAIL_DROP_INFO tail_drop_info_exact;
    int hr_fc_default_template, hr_fc_default_template_data;
    bcm_gport_t gport;
    bcm_dpp_cosq_config_t   *cosq_config;
    bcm_cosq_delay_tolerance_t delay_tolerance;
    uint8 src_modid = 0;
    int is_coldboot = TRUE;
    uint32 rci_i, link_rate=0, link_rate_tmp, links_num_i, fap_port;
    int speed, core;
    SOC_TMC_SCH_DEVICE_RATE_ENTRY dev_rate ;
    pbmp_t ports_map;
#ifdef BCM_ARAD_SUPPORT
    ARAD_CNM_CP_OPTIONS cnm_options;  
    ARAD_CNM_CP_INFO cp_info;
    ARAD_CNM_Q_MAPPING_INFO cnm_mapping_info;
    int soc_sand_dev_id;
#endif

    BCMDNX_INIT_FUNC_DEFS;
#if defined(BCM_ARAD_SUPPORT)
    soc_sand_dev_id = (unit);
#endif
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    cosq_config = &_dpp_cosq_config[unit];
    if (!SOC_IS_JERICHO(unit)) { 

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        is_coldboot = FALSE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /* Allocation */
    BCMDNX_ALLOC(thresh_info, sizeof(bcm_dpp_cosq_egress_thresh_key_info_t), "egress thresh key info handle memory");
    if (thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);        
    }
    BCMDNX_ALLOC(uc_thresh_info, sizeof(bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t), "egress intf uc thresh key info handle memory");
    if (uc_thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress intf uc thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(mc_thresh_info, sizeof(bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t), "egress intf mc thresh key info handle memory");
    if (mc_thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress intf mc thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(rate_class_info, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t), "cosq ingress rate class info handle memory");
    if (rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress rate class info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(exact_rate_class_info, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t), "cosq ingress rate class info exact handle memory");
    if (exact_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress rate class info exact handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(sys_red_dp_pr_info, sizeof(bcm_dpp_cosq_ingress_system_red_dp_pr_info_t), "system RED drop prob info handle memory");
    if (sys_red_dp_pr_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress system RED drop prob info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(vsq_rate_class_info, sizeof(bcm_dpp_cosq_vsq_rate_class_info_t), "vsq rate class info handle memory");
    if (vsq_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate vsq rate class info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(vsq_exact_rate_class_info, sizeof(bcm_dpp_cosq_vsq_rate_class_info_t), "vsq rate class info exact handle memory");
    if (vsq_exact_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate vsq rate class info exact handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }

    sal_memset(thresh_info,0x0,sizeof(bcm_dpp_cosq_egress_thresh_key_info_t));
    sal_memset(uc_thresh_info,0x0,sizeof(bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t));
    sal_memset(mc_thresh_info,0x0,sizeof(bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t));
    sal_memset(rate_class_info,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(sys_red_dp_pr_info,0x0,sizeof(bcm_dpp_cosq_ingress_system_red_dp_pr_info_t));
    sal_memset(vsq_rate_class_info,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
    sal_memset(vsq_exact_rate_class_info,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
    SOC_TMC_ITM_CR_DISCOUNT_INFO_clear(&discount_info);  
    SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&egr_discount_info);  
    SOC_TMC_ITM_TC_MAPPING_clear(&tc_mapping);

    if (is_coldboot) {
        if (SOC_IS_PETRAB(unit))
        {
            /* Set global OFP schedule mode to be of mode A (HP over LP fair) */
            egr_sch_mode = DPP_COSQ_PB_EGR_OFP_SCH_MODE_HP_OVER_LP_FAIR;
            rc = _bcm_petra_cosq_ofp_sch_mode_set(unit,egr_sch_mode);
            BCMDNX_IF_ERR_EXIT(rc);  
        
        }
        
        /* A.M initliaztion */
        /* Thresh type: Derive infromation from dune init, and set into A.M. */
        profile = SOC_DPP_DEFS_GET(unit, cosq_egr_default_thresh_type);
        rc = _bcm_petra_cosq_egress_thresh_entry_get(unit,profile,thresh_info);
        BCMDNX_IF_ERR_EXIT(rc);
    
        rc = soc_port_sw_db_valid_ports_get(unit, 0, &ports_map);
        SOC_PBMP_ITER(ports_map, idx) {
            rc = _bcm_petra_cosq_egress_thresh_profile_set(unit,idx,profile);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
        rc = _bcm_petra_cosq_egress_thresh_profile_data_set(unit,profile,thresh_info);
        BCMDNX_IF_ERR_EXIT(rc);
        
        /* state restored during warmboot */
        rc = _bcm_dpp_am_template_cosq_egr_thresh_init(unit,profile,thresh_info);
        BCMDNX_IF_ERR_EXIT(rc);           
    
#ifdef  BCM_ARAD_SUPPORT
        if(SOC_IS_ARAD(unit)){
            /* Set Egress Interface Unicast Thresh class info */
            profile = DPP_COSQ_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE;    

            /* state restored during warmboot */
            rc = _bcm_petra_cosq_egress_fc_interface_uc_thresh_entry_get(unit, profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dpp_am_template_cosq_egr_interface_unicast_thresh_init(unit, profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_data_set(unit, profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            /* Set Egress Interface Multicast Thresh class info */
            profile = DPP_COSQ_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE;    

            /* state restored during warmboot */
            rc = _bcm_petra_cosq_egress_fc_interface_mc_thresh_entry_get(unit, profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dpp_am_template_cosq_egr_interface_multicast_thresh_init(unit, profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_data_set(unit, profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
#endif /* BCM_ARAD_SUPPORT */

        /* Set Ingress rate class info, WRED already disabled by zeroing the structure */
        profile = DPP_COSQ_PB_ING_RATE_CLS_DEFAULT_PROFILE;

        /* state restored during warmboot */
        rc = _bcm_petra_cosq_voq_rate_class_default_set(unit,profile,exact_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);

/*if not Arad - init allocation manager regularly.*/
#ifdef BCM_ARAD_SUPPORT
        if (!SOC_IS_ARAD(unit))
#endif
        {
            rc = _bcm_dpp_am_template_queue_rate_cls_init(unit,profile,exact_rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* System RED */ 
        profile = DPP_COSQ_PB_ING_SYSTEM_RED_DP_PR_DEFAULT_PROFILE;
        _bcm_petra_cosq_sys_red_dp_pr_hw_set(unit, profile, sys_red_dp_pr_info);
        rc = _bcm_dpp_am_template_system_red_dp_pr_init(unit, profile, sys_red_dp_pr_info);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Set VSQ rate class info */
        profile = DPP_COSQ_PB_VSQ_RATE_CLS_DEFAULT_PROFILE;    
        /*set default Tail Drop values to maximum alowed by hardware, assum that the length of IQM_VQPR_MA-E is identical*/
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_tail_drop_default_get,(unit,&vsq_max_size_default_info)));
        SOC_SAND_IF_ERR_EXIT(soc_sand_rc);
        for (idx = 0 ; idx < DPP_DEVICE_COSQ_VSQ_NOF_CATEGORY_MAX ; idx++) 
        {
            for (idx1 = 0 ; idx1 < DPP_DEVICE_COSQ_ING_NOF_DP ; idx1++) 
            {
                vsq_rate_class_info->queue_max_size[idx][idx1] = vsq_max_size_default_info.max_inst_q_size;
                vsq_rate_class_info->queue_max_size_bds[idx][idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
            }
        }

        /* state restored during warmboot */
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit,profile,vsq_rate_class_info,vsq_exact_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_dpp_am_template_vsq_rate_cls_init(unit,profile,vsq_exact_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);


        /* Set Ingress discount class info */   
        profile = DPP_COSQ_PB_ING_DISCOUNT_CLS_DEFAULT_PROFILE;
        discount_info.discount = DPP_COSQ_PB_ING_DISCOUNT_DEFAULT_VALUE;

        /* state restored during warmboot */
        rc = _bcm_dpp_am_template_queue_discount_cls_init(unit,profile,&discount_info);
        BCMDNX_IF_ERR_EXIT(rc);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_discount_set,(unit,profile,&discount_info)));
        SOC_SAND_IF_ERR_EXIT(soc_sand_rc);  

        discount_data = DPP_COSQ_EG_DISCOUNT_DEFAULT_VALUE;
        egr_discount_info.mc_credit_discount = discount_data;
        egr_discount_info.uc_credit_discount = discount_data;

        /* First, Initialize all ports */
        BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
        BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
        BCM_PBMP_ITER(ports_map, port_i) {
          rc = soc_port_sw_db_local_to_tm_port_get(unit,port_i, &tm_port, &core);
          BCMDNX_IF_ERR_EXIT(rc);
          /* state restored during warmboot */
          rc = _bcm_dpp_am_template_egress_port_discount_cls_init(unit,core,tm_port,&egr_discount_info);
          BCMDNX_IF_ERR_EXIT(rc);
        }
    
        if(!SOC_IS_PETRAB(unit))
        {
          /* Set Ingress UC/FLOW TC Mapping profile */
          profile = DPP_COSQ_INGRESS_TC_MAPPING_DEFAULT_PROFILE;

          for(idx = 0 ; idx < SOC_TMC_NOF_TRAFFIC_CLASSES; idx++)
          {
            /* Default: Map each incoming TC to itself */ 
            tc_mapping.new_tc[idx] = idx;
          }

          rc = _bcm_dpp_am_template_ingress_flow_tc_mapping_init(unit,profile,&tc_mapping);
          BCMDNX_IF_ERR_EXIT(rc);
          rc = _bcm_dpp_am_template_ingress_uc_tc_mapping_init(unit,profile,&tc_mapping);
          BCMDNX_IF_ERR_EXIT(rc);

          _bcm_petra_cosq_ingress_tc_mapping_hw_set(unit, profile, 0, &tc_mapping);
          _bcm_petra_cosq_ingress_tc_mapping_hw_set(unit, profile, 1, &tc_mapping);
        }
    }

    } 

    /* number of elements per block, set to total # flows for now */
    /* allocate in 1k blocks at later date.                       */
    rc = _bcm_petra_cosq_listhd_init(unit,
                                     &_dpp_cosq_config[unit].flow_hd,
                                     DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit), 
                                     sizeof(bcm_dpp_cosq_flow_config_t),
                                     1, /* no divisor */
                                     dpp_cosq_hdlist_flow);


    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, cosq flow state init failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* number of elements per block, set to total # voq groups for now */
    /* allocate in 1k blocks at later date.                            */
    rc = _bcm_petra_cosq_listhd_init(unit,
                                     &_dpp_cosq_config[unit].voq_hd,
                                     DPP_DEVICE_PETRA_VOQ_HD_SIZE(unit), 
                                     sizeof(bcm_dpp_cosq_voq_config_t),
                                     DPP_DEVICE_PETRA_COSQ_QUEUE_QUARTET_DIVISOR,
                                     dpp_cosq_hdlist_voq_group);

    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, cosq voq state init failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    rc = _bcm_petra_cosq_listhd_init(unit,
                                     &_dpp_cosq_config[unit].connector_hd,
                                     DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit), 
                                     sizeof(bcm_dpp_cosq_connector_config_t),
                                     DPP_DEVICE_PETRA_COSQ_QUEUE_QUARTET_DIVISOR,
                                     dpp_cosq_hdlist_connector_group);


    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, cosq connector state init failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* allocate SE data structures */
    rc = _bcm_petra_cosq_listhd_init(unit,
                                     &_dpp_cosq_config[unit].se_hd,
                                     SOC_DPP_CONFIG(unit)->tm.max_ses, 
                                     sizeof(bcm_dpp_cosq_se_config_t),
                                     1,
                                     dpp_cosq_hdlist_se);


    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, cosq connector state init failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* initialize cosq module resource manager */
    rc = bcm_dpp_am_cosq_init(unit, &dpp_am_cosq_resource_info);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, resource manager init failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
   if (is_coldboot) {
        SOC_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        SOC_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info_exact);
        tail_drop_info.max_inst_q_size = 1024*1024;
        tail_drop_info.max_inst_q_size_bds = 1024*1024;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_tail_drop_set,(unit, 0, 0, &tail_drop_info, &tail_drop_info_exact)));
        SOC_SAND_IF_ERR_EXIT(soc_sand_rc);
        
        /* set standard credit request profiles */
        if (SOC_IS_PETRAB(unit)) { /* For Petra */

            /* Default config tuned for 1024B credit worth */
            /* Normal delay tolerance */
            rc = bcm_petra_cosq_delay_tolerance_level_get(unit, BCM_COSQ_DELAY_TOLERANCE_NORMAL,
                                                &delay_tolerance);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failed in delay tolerance level get init, error 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        
            delay_tolerance.credit_request_hungry_multiplier                        =   2048;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             =   1536; 
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              =   3072;
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                =  -1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             =   3072;

            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           =   0;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            =   0;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           =  16384;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            =  16384;

            delay_tolerance.credit_request_satisfied_empty_queue_exceed_thresh      =      1;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh =   2048;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             =      0;

            delay_tolerance.credit_request_watchdog_status_msg_gen                  =    100;
            delay_tolerance.credit_request_watchdog_delete_queue_thresh             =    150;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;       

            /* Example, set normal delay tolerance on for level 14 */
            rc = bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_NORMAL,
                                                &delay_tolerance);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failed in delay tolerance level set init, error 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            /* Set default delay tolerance values for low-latency/smaller ports queues */
#define SWP_P_INGR_CR_REQ_SLOW_DISABLE    (-30000)
            delay_tolerance.credit_request_hungry_multiplier                        =  2048;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             =  SWP_P_INGR_CR_REQ_SLOW_DISABLE; 
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              =  -2000;
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                =  -2000;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             =  SWP_P_INGR_CR_REQ_SLOW_DISABLE;

            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           =  4000;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            =  2000;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           =  16000;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            =  16000;

            delay_tolerance.credit_request_satisfied_empty_queue_exceed_thresh      =  1;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh =  5000;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             =  4000;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;       

            /* Example, set normal delay tolerance on for level 14 */
            rc = bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_LOW_DELAY,
                                                &delay_tolerance);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failed in delay tolerance level set init, error 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

        } else { /* non Petra */

            if(SOC_IS_ARAD(unit)) {
                /* If credit watchdog configuration is not set, set or restore it from hardware */
                if (IS_CREDIT_WATCHDOG_UNINITIALIZED(unit)) {
                    SOC_TMC_ITM_CR_WD_INFO crwd_info;
                    SOC_TMC_ITM_CR_WD_INFO_clear(&crwd_info);
                    crwd_info.top_queue = crwd_info.bottom_queue = ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
                    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_set, (unit, &crwd_info, &crwd_info)));
                }
            }
        
            if (is_coldboot) { /* In cold boot, configure the predefined credit request profiles */

                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_get(unit, BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED, &delay_tolerance));
                delay_tolerance.credit_request_hungry_multiplier = 2048; /* VERIFY */
                delay_tolerance.credit_request_satisfied_empty_queue_exceed_thresh = 1; /* VERIFY */
                /* The following two threshold will later also be set to the default by entering the credit watchdog mode. */
                delay_tolerance.credit_request_watchdog_status_msg_gen = IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit) ?
                  0 : SOC_TMC_ITM_CREDIT_WATCHDOG_NORMAL_STATUS_MSG_THRESHOLD;
                   
                delay_tolerance.credit_request_watchdog_delete_queue_thresh = SOC_TMC_ITM_CREDIT_WATCHDOG_NORMAL_DELETE_THRESHOLD;

                /* credit request profile (delay tolerance) for (any) 1Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -1024;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -1024;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -1024;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 25 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 25 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 1024;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 2 * 1024;
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_1G, &delay_tolerance));

                /* credit request profile (delay tolerance) for slow enabled 10Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 38 * 1024 / 10;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 38 * 1024 / 10;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 38 * 1024 / 10;
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 38 * 1024 / 10;
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 38 * 1024 / 10;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024 / 10;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024 / 10;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED, &delay_tolerance));

                /* credit request profile (delay tolerance) for delay sensitive 10Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -38 * 1024 / 10;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -38 * 1024 / 10;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -38 * 1024 / 10;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 25 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 25 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024 / 10;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024 / 10;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 38 * 1024 / 10;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 76 * 1024 / 10;
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_10G_LOW_DELAY, &delay_tolerance));

                /* credit request profile (delay tolerance) for slow enabled 40Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 15 * 1024;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 15 * 1024;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 15 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 15 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 15 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 15 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 15 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_40G_SLOW_ENABLED, &delay_tolerance));

                /* credit request profile (delay tolerance) for delay sensitive 40Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -15 * 1024;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -15 * 1024;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -15 * 1024;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 30 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 30 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 15 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 15 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 15 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 30 * 1024;
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_40G_LOW_DELAY, &delay_tolerance));

                /* credit request profile (delay tolerance) for slow enabled 100Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 38 * 1024;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 38 * 1024;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 38 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 38 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 38 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_100G_SLOW_ENABLED, &delay_tolerance));

                /* credit request profile (delay tolerance) for delay sensitive 100Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -38 * 1024;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -38 * 1024;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -38 * 1024;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -100 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 90 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 90 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 38 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 76 * 1024;
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_100G_LOW_DELAY, &delay_tolerance));

                /* credit request profile (delay tolerance) for slow enabled 200Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 76 * 1024;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 76 * 1024;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 76 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 76 * 1024;
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 76 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 76 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 76 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_200G_SLOW_ENABLED, &delay_tolerance));

                /* credit request profile (delay tolerance) for delay sensitive 200Gb ports */
                delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -76 * 1024;
                delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -76 * 1024;
                delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -76 * 1024;
                delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -114688; /* max absolute value supported */
                delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 122880; /* max supported value */
                delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 122880;
                delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 76 * 1024;
                delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 76 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 76 * 1024;
                delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 122880; /* using backoff value, higher is not allowed */
                delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY, &delay_tolerance));
            }

        }

    }
    if (!SOC_IS_JERICHO(unit)) { 
        if (is_coldboot && !SOC_IS_PETRAB(unit)) {
            BCM_DPP_ASSYMETRIC_CORES_ITER(BCM_CORE_ALL, core) {
                /* Set VSQ category mode to be none by default */
                cosq_config->ingress[core].vsq_category_mode = bcmFabricVsqCatagoryModeNone;
            }
            rc = bcm_petra_fabric_control_set(unit,bcmFabricVsqCategory,bcmFabricVsqCatagoryModeNone);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failed in vsq mode none settings, error 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, 0, FALSE, FALSE, FALSE, FALSE, 
                                            DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, &src_modid, &reserved_flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to reserve connector resources, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, connector resources. reserved start region 0x%x\n"), unit, reserved_flow_id));
    
    if (is_coldboot) {
        SOC_TMC_SCH_PORT_INFO_clear(&port_info);
        /* Set default port information */
        port_info.enable = TRUE;
        DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
          port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }

        BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
        BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
        BCM_PBMP_ITER(ports_map, port_i) {
            BCM_COSQ_GPORT_E2E_PORT_SET(gport, port_i); /* Not necessary */
            rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_i, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Invalid fap port %d\n"), fap_port));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
            if(SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

    if (is_coldboot) {
        rc = bcm_petra_cosq_internal_ports_init(unit);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed in internal port initialization 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* update flow control template information */
    if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        hr_fc_default_template = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3 - 1;
        hr_fc_default_template_data = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        cosq_config->hr_fc_default_template = hr_fc_default_template;
        cosq_config->hr_fc_default_template_data = hr_fc_default_template_data;

        LOG_VERBOSE(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "Setting up FC Template %d, Value %d"), hr_fc_default_template, hr_fc_default_template_data));

        if (is_coldboot) {
            /* state restored during warmboot */
            rc = _bcm_dpp_am_template_cosq_port_hr_fc_init(unit, hr_fc_default_template, &hr_fc_default_template_data);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failed in update of flow control HR temlates, error 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

    SOC_DPP_ALLOW_WARMBOOT_WRITE(_bcm_petra_cosq_sched_init(unit), rc);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed in sched init, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }


    if (is_coldboot) {
        /* Set default DRM (device rate memory) */
        SOC_TMC_SCH_DEVICE_RATE_ENTRY_clear(&dev_rate);

        /* Currently link_rate is triggered by maximal speed rate */
        link_rate = 0;


        if (SOC_IS_ARAD(unit)) {
            PBMP_SFI_ITER(unit, port_i) {
              rc = bcm_petra_port_speed_get(unit, port_i, &speed);
              BCMDNX_IF_ERR_EXIT(rc);

              link_rate_tmp = (speed * DPP_COSQ_DRM_FACTOR_BANDWIDTH) / 100;
              link_rate = (link_rate > link_rate_tmp) ? link_rate:link_rate_tmp;
        }
    } else {
        /* Soc_petra-B */
        speed = 6500;
        link_rate = (speed * DPP_COSQ_DRM_FACTOR_BANDWIDTH) / 100;
    }
   
    for(rci_i = 0; rci_i < SOC_DPP_DEFS_GET(unit, nof_rci_levels) ; ++rci_i)
    {
      PBMP_SFI_ITER(unit, port_i)
      {
        links_num_i = SOC_DPP_FABRIC_PORT_TO_LINK(unit, port_i);
        dev_rate.rci_level = rci_i;
        dev_rate.num_active_links = links_num_i;
        dev_rate.rate = ((links_num_i * link_rate) / (rci_i + 1)) ;


            /*
             *  0 links means local route
             *  RCI 0 - if the number of active links is small,
             *  and the links are indeed in-use, the RCI will rise above 0.
             *  Otherwise - we don't limit the scheduler rate.
             */
            if(
                (links_num_i == 0) ||
                (dev_rate.rate > DPP_COSQ_SCH_MAX_RATE_MBPS_PER_DEVICE(unit)) ||
                (dev_rate.rci_level == 0)
              )
            {
              dev_rate.rate = DPP_COSQ_SCH_MAX_RATE_MBPS_PER_DEVICE(unit);
            }

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_device_rate_entry_set,(unit, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate)));
            if(SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting mbcm_dpp_sch_device_rate_entry_set rci_level %d, num_active_links %d, soc_sand error 0x%x, error 0x%x\n"), unit, dev_rate.rci_level, 
                                      dev_rate.num_active_links, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }        
          }
      }
    }
      

#ifdef BCM_ARAD_SUPPORT
    if (!SOC_WARM_BOOT(unit)) {
        /* CNM Init */
        if (SOC_IS_ARAD(unit)) {

            SOC_TMC_CNM_CPQ_INFO cpq_info;
            SOC_TMC_CNM_CP_PROFILE_INFO profile_info;

            soc_sand_rc = arad_cnm_cp_get(soc_sand_dev_id, &cp_info);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error (%d) in getting CNM mode\n"), unit, soc_sand_rc));
              BCMDNX_IF_ERR_EXIT(rc);
            }

            switch(SOC_DPP_CONFIG(unit)->tm.cnm_mode)
            {
            case 0:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_DUNE_PP;
            break;
            case 1:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_EXT_PP;
            break;
            case 2:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_SAMPLING;
            break;
            case 3:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_HIGIG;
            break;
            default:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_DUNE_PP;
            }

            soc_sand_rc = arad_cnm_cp_set(soc_sand_dev_id, &cp_info);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error (%d) in setting CNM mode (%d) \n"), unit, soc_sand_rc, SOC_DPP_CONFIG(unit)->tm.cnm_mode));
              BCMDNX_IF_ERR_EXIT(rc);
            }

            soc_sand_rc = arad_cnm_queue_mapping_get(soc_sand_dev_id, &cnm_mapping_info);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error (%d) in getting CNM VOQ mapping mode\n"), unit, soc_sand_rc));
              BCMDNX_IF_ERR_EXIT(rc);
            }

            switch(SOC_DPP_CONFIG(unit)->tm.cnm_voq_mapping_mode)
            {
            case 0:
            cnm_mapping_info.q_set = SOC_TMC_CNM_Q_SET_8_CPS;
            break;
            case 1:
            cnm_mapping_info.q_set = SOC_TMC_CNM_Q_SET_4_CPS;
            cnm_mapping_info.odd_queues_select = 1;
            break;
            case 2:
            cnm_mapping_info.q_set = SOC_TMC_CNM_Q_SET_4_CPS;
            cnm_mapping_info.odd_queues_select = 0;
            break;
            default:
            cnm_mapping_info.q_set = SOC_TMC_CNM_Q_SET_8_CPS;
            }

            soc_sand_rc = arad_cnm_queue_mapping_set(soc_sand_dev_id, &cnm_mapping_info);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error (%d) in setting CNM VOQ mapping mode (%d) \n"), unit, soc_sand_rc, SOC_DPP_CONFIG(unit)->tm.cnm_voq_mapping_mode));
              BCMDNX_IF_ERR_EXIT(rc);
            }

            SOC_TMC_CNM_CP_PROFILE_INFO_clear(&profile_info);
            SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);
            soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, 0, &cpq_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
            rc = _bcm_arad_cosq_cnm_queue_profile_hw_get(unit, cpq_info.profile, &profile_info);
            BCMDNX_IF_ERR_EXIT(rc);
            rc = _bcm_dpp_am_template_pool_cnm_queue_init(unit, &profile_info, cpq_info.profile);
            BCMDNX_IF_ERR_EXIT(rc);

            soc_sand_rc = arad_cnm_cp_options_get(soc_sand_dev_id, &cnm_options);   
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error (%d) in getting CNM options\n"), unit, soc_sand_rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            cnm_options.gen_if_no_pph=0;
            cnm_options.gen_if_no_cn_tag=0;
            cnm_options.add_cn_tag=0;

#if defined(BCM_88650_B0)
            if(SOC_IS_ARAD_B0_AND_ABOVE(unit))
            {
                  /* Handle CNM Fixes for Arad B0 */
                  cnm_options.disable_fabric_crc_calculation = 0;
                  cnm_options.disable_crc_removal = 0;
                  cnm_options.enable_cnm_ocb = 0;
            }
#endif

            soc_sand_rc = arad_cnm_cp_options_set(soc_sand_dev_id, &cnm_options);        
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error (%d) in setting CNM options\n"), unit, soc_sand_rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }
#endif

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_state_init(unit, &_dpp_cosq_config[unit]);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed warmboot init, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
#endif /* BCM_WARM_BOOT_SUPPORT */
    
    }
    if (SOC_IS_JERICHO(unit)) { 
      


      rc = bcm_dpp_am_cosq_scheduler_allocate(unit, 0, FALSE, FALSE, FALSE, FALSE, 
                                              DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, &src_modid, &reserved_flow_id);
      if (rc != BCM_E_NONE) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, failed to reserve connector resources, error 0x%x\n"), unit, rc));
          BCMDNX_IF_ERR_EXIT(rc);
      }
      LOG_VERBOSE(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, connector resources. reserved start region 0x%x\n"), unit, reserved_flow_id));
      if (is_coldboot) {
          SOC_TMC_SCH_PORT_INFO_clear(&port_info);
          /* Set default port information */
          port_info.enable = TRUE;
          DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
          if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
          }
          BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
          BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
          BCM_PBMP_ITER(ports_map, port_i) {
              BCM_COSQ_GPORT_E2E_PORT_SET(gport, port_i); /* Not necessary */
              rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core);
              if (rc != BCM_E_NONE) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_i, rc));
                  BCMDNX_IF_ERR_EXIT(rc);
              }
              if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "Invalid fap port %d\n"), fap_port));
                  BCMDNX_IF_ERR_EXIT(rc);
              }
              soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
              if(SOC_SAND_FAILURE(soc_sand_rc)) {
                  rc = translate_sand_success_failure(soc_sand_rc);
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, error in setting scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
                  BCMDNX_IF_ERR_EXIT(rc);
              }
          }
      }


      if (is_coldboot) {
        /* Set default DRM (device rate memory) */
        SOC_TMC_SCH_DEVICE_RATE_ENTRY_clear(&dev_rate);
  
        /* Currently link_rate is triggered by maximal speed rate */
        link_rate = 0;

        if (SOC_IS_ARAD(unit)) {
          PBMP_SFI_ITER(unit, port_i) {
            rc = bcm_petra_port_speed_get(unit, port_i, &speed);
            BCMDNX_IF_ERR_EXIT(rc);
  
            link_rate_tmp = (speed * DPP_COSQ_DRM_FACTOR_BANDWIDTH) / 100;
            link_rate = (link_rate > link_rate_tmp) ? link_rate:link_rate_tmp;
          }
        } else {
          /* Soc_petra-B */
          speed = 6500;
          link_rate = (speed * DPP_COSQ_DRM_FACTOR_BANDWIDTH) / 100;
        }
     
        for(rci_i = 0; rci_i < SOC_DPP_DEFS_GET(unit, nof_rci_levels) ; ++rci_i)
        {
          PBMP_SFI_ITER(unit, port_i)
          {
            links_num_i = SOC_DPP_FABRIC_PORT_TO_LINK(unit, port_i);
            dev_rate.rci_level = rci_i;
            dev_rate.num_active_links = links_num_i;
            dev_rate.rate = ((links_num_i * link_rate) / (rci_i + 1)) ;

            /*
             *  0 links means local route
             *  RCI 0 - if the number of active links is small,
             *  and the links are indeed in-use, the RCI will rise above 0.
             *  Otherwise - we don't limit the scheduler rate.
             */
            if (
              (links_num_i == 0) ||
              (dev_rate.rate > DPP_COSQ_SCH_MAX_RATE_MBPS_PER_DEVICE(unit)) ||
              (dev_rate.rci_level == 0)
            )
            {
              dev_rate.rate = DPP_COSQ_SCH_MAX_RATE_MBPS_PER_DEVICE(unit);
            }
  
            soc_sand_rc =
              (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_device_rate_entry_set,
                (unit, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate)));
            if(SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(
                BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                  "unit %d, error in setting mbcm_dpp_sch_device_rate_entry_set rci_level %d, num_active_links %d, soc_sand error 0x%x, error 0x%x\n"), unit, dev_rate.rci_level, 
                  dev_rate.num_active_links, soc_sand_rc, rc));
              BCMDNX_IF_ERR_EXIT(rc);
            }        
          }
        }
      }
    }

    if (is_coldboot) {
        rc = _bcm_petra_cosq_fc_init(unit);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed fc init, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

exit:
  if (thresh_info != NULL) {
     BCM_FREE(thresh_info);
  }
  if (uc_thresh_info != NULL) {
     BCM_FREE(uc_thresh_info);
  }
  if (mc_thresh_info != NULL) {
     BCM_FREE(mc_thresh_info);
  }
  if (rate_class_info != NULL) {
     BCM_FREE(rate_class_info);
  }
  if (exact_rate_class_info != NULL) {
     BCM_FREE(exact_rate_class_info);
  }
  if (sys_red_dp_pr_info != NULL) {
     BCM_FREE(sys_red_dp_pr_info);
  }
  if (vsq_rate_class_info != NULL) {
     BCM_FREE(vsq_rate_class_info);
  }
  if (vsq_exact_rate_class_info != NULL) {
     BCM_FREE(vsq_exact_rate_class_info);
  }
  _BCM_DPP_SWITCH_API_END(unit);
  BCMDNX_FUNC_RETURN;
}

/*
*  Tear down local state and related
*/
int
bcm_petra_cosq_detach(int unit)
{
    bcm_dpp_cosq_blk_info_t *curr;
    bcm_dpp_cosq_blk_info_t *prev;
    int result = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* walk the voq list and free the elements */
    for (curr = _dpp_cosq_config[unit].voq_hd.blk; curr; ) {
        prev = curr;
        curr = prev->next_blk;
        if (prev->data) {
            BCM_FREE(prev->data);
        }
        BCM_FREE(prev);
    }
    _dpp_cosq_config[unit].voq_hd.blk = NULL;
    /* walk the connector list and free the elements */
    for (curr = _dpp_cosq_config[unit].connector_hd.blk; curr; ) {
        prev = curr;
        curr = prev->next_blk;
        if (prev->data) {
            BCM_FREE(prev->data);
        }
        BCM_FREE(prev);
    }
    _dpp_cosq_config[unit].connector_hd.blk = NULL;
    /* walk the se list and free the elements */
    for (curr = _dpp_cosq_config[unit].se_hd.blk; curr; ) {
        prev = curr;
        curr = prev->next_blk;
        if (prev->data) {
            BCM_FREE(prev->data);
        }
        BCM_FREE(prev);
    }
    _dpp_cosq_config[unit].se_hd.blk = NULL;
    /* walk the flow list and free the elements */
    for (curr = _dpp_cosq_config[unit].flow_hd.blk; curr; ) {
        prev = curr;
        curr = prev->next_blk;
        if (prev->data) {
            BCM_FREE(prev->data);
        }
        BCM_FREE(prev);
    }
    _dpp_cosq_config[unit].flow_hd.blk = NULL;

#ifdef BCM_WARM_BOOT_SUPPORT
    /* tear down warm boot state */
    result = _bcm_dpp_wb_cosq_state_deinit(unit);
#endif /* def BCM_WARM_BOOT_SUPPORT */

    BCMDNX_IF_ERR_EXIT(result);
    result = bcm_dpp_am_cosq_deinit(unit);
    BCMDNX_IF_ERR_EXIT(result);

exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Set the common status message time in the common status message time mode.
 * Need to set the scan time, if to send a message after 1/2 scans.
 * Need to update the delete times of all the progiles.
 */
STATIC int
_bcm_arad_reconfigure_common_fsm_mode(int unit, int fsm_time_us)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (!IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can set common status message time only in common status message mode")));
    }
    switch (fsm_time_us) {
      case 0:
      case ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS     / 1000: /*  125 */
      case 2 * ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /*  250 */
      case 4 * ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /*  500 */
      case 8 * ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /* 1000 */
      case ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS     / 1000: /* 2000 */
      case 2 * ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS / 1000: /* 4000 */
        break;
      default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG(
          "Invalid common status message time %d, must be one of 0, 125, 250, 500, 1000, 2000, 4000"),
          fsm_time_us));
    }
    
    /* do all the work */
    BCMDNX_IF_ERR_EXIT(_bcm_petra_fabric_credit_watchdog_range_set(unit, bcmFabricWatchdogQueueEnable,
      BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE, fsm_time_us));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the common status message time in us of the common status message time mode.
 */
STATIC int
_bcm_arad_common_fsm_mode_get_time(int unit, int *fsm_time_us)
{
    SOC_TMC_ITM_CR_WD_INFO crwd_info;
    BCMDNX_INIT_FUNC_DEFS;
    if (!IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can get common status message time only in common status message mode")));
    } else if (fsm_time_us == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("received null pointer")));
    }

    /* get the number of scans till a message is generated */
    SOC_TMC_ITM_CR_WD_INFO_clear(&crwd_info);
    crwd_info.top_queue = crwd_info.bottom_queue = crwd_info.max_flow_msg_gen_rate_nano =
      crwd_info.min_scan_cycle_period_micro = ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_set, (unit, &crwd_info, &crwd_info)));

    *fsm_time_us = (SOC_DPP_CONFIG(unit)->arad->exact_credit_watchdog_scan_time_nano / 1000) * crwd_info.min_scan_cycle_period_micro;
    if (SOC_DPP_CONFIG(unit)->arad->exact_credit_watchdog_scan_time_nano % 1000) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Can not get exact common status message time. It looks close to %d"),
          *fsm_time_us));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*Used to handle delay tolarence MACRO to user q type translation*/
STATIC int
_bcm_petra_cosq_delay_tolerance_to_user_q_type(
    int unit,
    int delay_tolerance_level,
    SOC_TMC_ITM_QT_NDX *user_q_type){
    BCMDNX_INIT_FUNC_DEFS;
    if (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) {
        *user_q_type = delay_tolerance_level - BCM_COSQ_DELAY_TOLERANCE_NORMAL;
        if (!SOC_IS_PETRAB(unit) && (delay_tolerance_level < BCM_COSQ_DELAY_TOLERANCE_02 || delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15)) {
            *user_q_type += SOC_TMC_ITM_PREDEFIEND_OFFSET;
        } else {
            *user_q_type += DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit);
        }
    } else if (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23) {
        *user_q_type = delay_tolerance_level + DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) - (BCM_COSQ_DELAY_TOLERANCE_NORMAL + (BCM_COSQ_DELAY_TOLERANCE_16 - (BCM_COSQ_DELAY_TOLERANCE_15 + 1)));
    } else if (!SOC_IS_PETRAB(unit) && delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) {
        *user_q_type = delay_tolerance_level + (SOC_TMC_ITM_PREDEFIEND_OFFSET - BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED);
    } else {
        *user_q_type = SOC_TMC_ITM_QT_NDX_INVALID;
    }
    BCMDNX_FUNC_RETURN;
}

/*Used to handle user q type translation to delay tolarence MACRO*/
STATIC int
_bcm_petra_cosq_user_q_type_to_delay_tolerance(
    int unit,
    SOC_TMC_ITM_QT_NDX user_q_type,
    int *delay_tolerance_level){
    BCMDNX_INIT_FUNC_DEFS;
    if (user_q_type >= SOC_TMC_ITM_PREDEFIEND_OFFSET) {
        if (user_q_type == SOC_TMC_ITM_PREDEFIEND_OFFSET + BCM_COSQ_DELAY_TOLERANCE_15 - BCM_COSQ_DELAY_TOLERANCE_NORMAL) {
            *delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_15;
        } else {
            *delay_tolerance_level = user_q_type + (BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED - SOC_TMC_ITM_PREDEFIEND_OFFSET);
        }
    } else {
        if (user_q_type - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) < DPP_COSQ_USER_Q_TYPE_NOF_DYNANIC(unit) &&
            user_q_type - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) >= SOC_TMC_ITM_QT_PUSH_Q_NDX) {
            *delay_tolerance_level = (user_q_type - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit)) + (BCM_COSQ_DELAY_TOLERANCE_NORMAL + (BCM_COSQ_DELAY_TOLERANCE_16 - (BCM_COSQ_DELAY_TOLERANCE_15 + 1)));
        } else if (user_q_type - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) < SOC_TMC_ITM_QT_PUSH_Q_NDX){
            *delay_tolerance_level = user_q_type + BCM_COSQ_DELAY_TOLERANCE_NORMAL - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("User Q type is not legal")));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_delay_tolerance_level_get(int unit,
                                         int delay_tolerance_level,
                                         bcm_cosq_delay_tolerance_t *delay_tolerance)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_ITM_QT_NDX dt_level;
    SOC_TMC_ITM_CR_REQUEST_INFO cr_req_info;


    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if (delay_tolerance == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointers not being passed")));
    }
    /* consistency checks */
    if (!((delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) ||
         (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23)      ||
         (!SOC_IS_PETRAB(unit) && delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
         (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid delay_tolerance_level %d"), unit, delay_tolerance_level));
    }

    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)) {
        /* Get the common status message time in the common status message time mode */
        BCMDNX_IF_ERR_EXIT(_bcm_arad_common_fsm_mode_get_time(unit, &delay_tolerance->credit_request_watchdog_status_msg_gen));
        BCM_EXIT;
    }
    rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, delay_tolerance_level, &dt_level);
    BCMDNX_IF_ERR_EXIT(rc);

    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15 && !SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("BCM_COSQ_DELAY_TOLERANCE_15 is reserved for push queues")));
    }

    SOC_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_request_get,(unit, dt_level, &cr_req_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    if (cr_req_info.wd_th.cr_wd_dlt_q_th == SOC_TMC_ITM_CR_WD_Q_TH_OPERATION_FAILED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Could not get the user defined delay tolerance level (queue type) since it was not set")));
    }
    
    delay_tolerance->credit_request_watchdog_status_msg_gen =
                     cr_req_info.wd_th.cr_wd_stts_msg_gen;
    delay_tolerance->credit_request_watchdog_delete_queue_thresh =
                     cr_req_info.wd_th.cr_wd_dlt_q_th;
    delay_tolerance->credit_request_hungry_off_to_slow_thresh =
                     cr_req_info.hungry_th.off_to_slow_th;
    delay_tolerance->credit_request_hungry_off_to_normal_thresh =
                     cr_req_info.hungry_th.off_to_normal_th;
    delay_tolerance->credit_request_hungry_slow_to_normal_thresh =
                     cr_req_info.hungry_th.slow_to_normal_th;
    delay_tolerance->credit_request_hungry_normal_to_slow_thresh =
                     cr_req_info.hungry_th.normal_to_slow_th;

    delay_tolerance->credit_request_hungry_multiplier =
             cr_req_info.hungry_th.multiplier;

    delay_tolerance->credit_request_satisfied_backoff_enter_thresh =
                     cr_req_info.satisfied_th.backoff_th.backoff_enter_th;
    delay_tolerance->credit_request_satisfied_backoff_exit_thresh =
                     cr_req_info.satisfied_th.backoff_th.backoff_exit_th;
    delay_tolerance->credit_request_satisfied_backlog_enter_thresh =
                     cr_req_info.satisfied_th.backlog_th.backlog_enter_th;
    delay_tolerance->credit_request_satisfied_backlog_exit_thresh =
                     cr_req_info.satisfied_th.backlog_th.backlog_exit_th;
    delay_tolerance->credit_request_satisfied_empty_queue_thresh =
                     cr_req_info.satisfied_th.empty_queues.satisfied_empty_q_th;
    delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh =
                     cr_req_info.satisfied_th.empty_queues.max_credit_balance_empty_q;
    delay_tolerance->credit_request_satisfied_empty_queue_exceed_thresh =
                     cr_req_info.satisfied_th.empty_queues.exceed_max_empty_q;
    delay_tolerance->flags = (SOC_IS_ARADPLUS(unit) && cr_req_info.is_remote_credit_value) ?
                     BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE : 0;
    if (cr_req_info.is_low_latency && !SOC_IS_PETRAB(unit)) {
        delay_tolerance->flags |= BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY;
    }
    if (SOC_IS_JERICHO(unit)) {
        int slow_level;
        delay_tolerance->flags |= (cr_req_info.is_ocb_only) ? BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY : 0;
        delay_tolerance->flags |= (cr_req_info.is_high_priority) ? BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY : 0;
        for (slow_level = 0; slow_level < BCM_COSQ_DELAY_TOLERANCE_SLOW_LEVELS; slow_level++) {
            delay_tolerance->slow_level_thresh_down[slow_level] = cr_req_info.slow_level_thresholds.slow_level_thresh_down[slow_level];
            delay_tolerance->slow_level_thresh_up[slow_level] = cr_req_info.slow_level_thresholds.slow_level_thresh_up[slow_level];
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_delay_tolerance_level_set(int unit,
                                         int delay_tolerance_level, 
                                         bcm_cosq_delay_tolerance_t *delay_tolerance)
{
    uint32 soc_sand_rc;    
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_QT_NDX dt_level;
    SOC_TMC_ITM_CR_REQUEST_INFO cr_req_info, cr_req_exact_info;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if (delay_tolerance == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointers not being passed")));
    }
    /* consistency checks */
    if (!((delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) ||
         (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23)      ||
         (!SOC_IS_PETRAB(unit) && delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
         (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid delay_tolerance_level %d"), unit, delay_tolerance_level));
    }
    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15 && !SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("BCM_COSQ_DELAY_TOLERANCE_15 is reserved for push queues")));
    }

    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)) {
        /* Set the common status message time in the common status message time mode */
        BCMDNX_IF_ERR_EXIT(_bcm_arad_reconfigure_common_fsm_mode(unit, delay_tolerance->credit_request_watchdog_status_msg_gen));
        BCM_EXIT;
    }
    rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, delay_tolerance_level, &dt_level);
    BCMDNX_IF_ERR_EXIT(rc);

    if (SOC_IS_ARAD(unit) && delay_tolerance->credit_request_watchdog_delete_queue_thresh &&
        IS_CREDIT_WATCHDOG_FAST_STATUS_MESSAGE_MODE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("delete queue thresholds (aging) are not supported in aggressive status message credit watchdog mode")));
    } else if (SOC_IS_ARAD(unit) && IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit)) {
        if (delay_tolerance->credit_request_watchdog_status_msg_gen) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("status message generation thresholds are not supported per delay tolerance level in common status message credit watchdog mode\n"
                             "They are set for all the chip using BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG")));
        } else if (delay_tolerance->credit_request_watchdog_delete_queue_thresh &&
                   (delay_tolerance->credit_request_watchdog_delete_queue_thresh > 7680 ||
                    delay_tolerance->credit_request_watchdog_delete_queue_thresh < 2)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("A delete queue (aging) threshold should be between 2ms and 7680ms, or 0 for no deletion")));
        } /* we permit 7.68s since with shortest scan (125us) the max scans till delete (15*2^12) give 7.68s */
    }
    if (delay_tolerance->flags) {
        uint32 unsupported_flags = delay_tolerance->flags & ~(BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE | BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY | BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY);
        if (unsupported_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("None supported flags 0x%x were specified"),
              (unsigned)unsupported_flags));
        } if ((delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE) && !SOC_IS_ARADPLUS(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE flag is not supported on this device")));
        } else if ((delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY) && SOC_IS_PETRAB(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY flag is not supported on this device")));
        }
    }

    SOC_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
    SOC_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_exact_info);


    if (SOC_IS_PETRAB(unit)) {
        /* retrieve current information in case we do not set all of it */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_request_get,(unit, dt_level, &cr_req_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    } else { /* perform sanity tests on thresholds */

        if (delay_tolerance->credit_request_hungry_slow_to_normal_thresh < 
            delay_tolerance->credit_request_hungry_normal_to_slow_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: SlowToNormal (which is %d) must be equal or higher than NormalToSlow (which is %d), otherwise could result endless toggle between states.\n"),
                                 delay_tolerance->credit_request_hungry_slow_to_normal_thresh,
                      delay_tolerance->credit_request_hungry_normal_to_slow_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backoff_enter_thresh <
            delay_tolerance->credit_request_satisfied_backoff_exit_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackOffEnter (which is %d) must be equal or higher than BackOffExit (which is %d), otherwise could result endless toggle between Backoff states.\n"),
                                 delay_tolerance->credit_request_satisfied_backoff_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backoff_exit_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backlog_enter_thresh <
            delay_tolerance->credit_request_satisfied_backlog_exit_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackLogEnter (which is %d) must be equal or higher than BackLogExit (which is %d), otherwise could result endless toggle between BackLog states.\n"),
                                 delay_tolerance->credit_request_satisfied_backlog_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backlog_exit_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backoff_enter_thresh <
            delay_tolerance->credit_request_satisfied_backlog_enter_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackOffEnter (which is %d) should be equal or higher than BackLogEnter (which is %d)\n"),
                                 delay_tolerance->credit_request_satisfied_backoff_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backlog_enter_thresh));
        }
     
        if (delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh >
            delay_tolerance->credit_request_satisfied_backoff_exit_thresh) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (
              _BSL_BCM_MSG("EmptyQueueMaxBalance (which is %d) must be equal or lower than backOffExit (which is %d), otherwise could result queue stuck in Off state."),
              delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh,
              delay_tolerance->credit_request_satisfied_backoff_exit_thresh));
        }
        /* Finish of non Petra code performing sanity tests on thresholds */
        cr_req_info.is_low_latency = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY ? TRUE : FALSE;
    }

    if (SOC_IS_JERICHO(unit)) {
        int slow_level;
        cr_req_info.is_ocb_only = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY ? 1 : 0;
        cr_req_info.is_high_priority = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY ? 1 : 0;
        for (slow_level = 0; slow_level < BCM_COSQ_DELAY_TOLERANCE_SLOW_LEVELS; slow_level++) {
            cr_req_info.slow_level_thresholds.slow_level_thresh_down[slow_level] = delay_tolerance->slow_level_thresh_down[slow_level];
            cr_req_info.slow_level_thresholds.slow_level_thresh_up[slow_level] = delay_tolerance->slow_level_thresh_up[slow_level];
        }
    }


    /* update configuration */
    cr_req_info.wd_th.cr_wd_stts_msg_gen =
                     delay_tolerance->credit_request_watchdog_status_msg_gen;
    cr_req_info.wd_th.cr_wd_dlt_q_th =
                     delay_tolerance->credit_request_watchdog_delete_queue_thresh;
    cr_req_info.hungry_th.off_to_slow_th =
                     delay_tolerance->credit_request_hungry_off_to_slow_thresh;
    cr_req_info.hungry_th.off_to_normal_th =
                     delay_tolerance->credit_request_hungry_off_to_normal_thresh;
    cr_req_info.hungry_th.slow_to_normal_th =
                     delay_tolerance->credit_request_hungry_slow_to_normal_thresh;
    cr_req_info.hungry_th.normal_to_slow_th =
                     delay_tolerance->credit_request_hungry_normal_to_slow_thresh;

    /* handle values out of the possible range */
    cr_req_info.hungry_th.multiplier =
                     delay_tolerance->credit_request_hungry_multiplier < DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MIN_SIZE ? 0 : (
                     delay_tolerance->credit_request_hungry_multiplier < DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE ?
                     delay_tolerance->credit_request_hungry_multiplier : DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE );

    cr_req_info.satisfied_th.backoff_th.backoff_enter_th =
                     delay_tolerance->credit_request_satisfied_backoff_enter_thresh;
    cr_req_info.satisfied_th.backoff_th.backoff_exit_th =
                     delay_tolerance->credit_request_satisfied_backoff_exit_thresh;
    cr_req_info.satisfied_th.backlog_th.backlog_enter_th =
                     delay_tolerance->credit_request_satisfied_backlog_enter_thresh;
    cr_req_info.satisfied_th.backlog_th.backlog_exit_th =
                     delay_tolerance->credit_request_satisfied_backlog_exit_thresh;
    cr_req_info.satisfied_th.empty_queues.satisfied_empty_q_th =
                     delay_tolerance->credit_request_satisfied_empty_queue_thresh;
    cr_req_info.satisfied_th.empty_queues.max_credit_balance_empty_q =
                     delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh;
    cr_req_info.satisfied_th.empty_queues.exceed_max_empty_q =
                     delay_tolerance->credit_request_satisfied_empty_queue_exceed_thresh;
    cr_req_info.is_remote_credit_value = (delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE) ? TRUE : FALSE;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_request_set,(unit, dt_level, &cr_req_info, &cr_req_exact_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    if (cr_req_exact_info.wd_th.cr_wd_dlt_q_th == SOC_TMC_ITM_CR_WD_Q_TH_OPERATION_FAILED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FULL, (_BSL_BCM_MSG("Could not allocate the user defined delay tolerance level (queue type) since the available ones are exhausted")));
    }

exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_resource_gport_port_get(int unit, 
                                       bcm_gport_t gport, 
                                       bcm_port_t *port)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_gport_t port_gport = 0;
    int se_id, flow_id, dummy_tc;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport, &port_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!BCM_GPORT_IS_SCHEDULER(port_gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("gport given is not scheduler gport")));
    }

    flow_id = BCM_GPORT_SCHEDULER_GET(port_gport);

    /* Convert scheduler to port id */
    se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,( flow_id)));
    rc = _bcm_petra_cosq_se_id2port(unit,se_id, port, &dummy_tc);                       
    if (rc != BCM_E_NONE || *port == DPP_COSQ_SCH_PORT_ID_INVALID(unit)) {
        rc = BCM_E_PARAM;
       LOG_ERROR(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit %d, Invalid se 0x%x specified - does not correspond to port\n"), unit, se_id));
        BCMDNX_IF_ERR_EXIT(rc);
    }


exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_sched_set(int unit,
                               bcm_gport_t gport,
                               bcm_cos_queue_t cosq,
                               int mode,
                               int weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* queues */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport) ) {
        rc = _bcm_petra_cosq_gport_ucast_queue_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Egress transmit scheduler */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_petra_cosq_gport_egress_scheduler_port_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Egress UC / MC Queue - same function handle */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_egress_queue_sched_set(unit, gport, cosq, mode, weight);
    }
 
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
        rc = _bcm_petra_cosq_gport_fmq_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_sched_set(unit, gport, mode, weight);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_set(unit, gport, mode, weight);
    }    
    /* E2E hierarchy */
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) || (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) || (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ||
                                                    (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ) {
        rc = _bcm_petra_cosq_gport_e2e_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Port TC / Port TCG */
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tc_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tcg_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_e2e_port_tc_sched_set(unit, gport, cosq, mode, weight);
    }    
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_e2e_port_tcg_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_INGRESS(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_set, 
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_ingress)); 
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_EGRESS(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_egress));
    } 
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_all));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_egress_core_fifo_local_ucast));
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("gport type not supported")));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_sched_get(int unit,
                               bcm_gport_t gport,
                               bcm_cos_queue_t cosq,
                               int *mode,
                               int *weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* queues */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport) ) {
        rc = _bcm_petra_cosq_gport_ucast_queue_sched_get(unit, gport, cosq, mode, weight);
    }

    /* Egress transmit scheduler */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_petra_cosq_gport_egress_scheduler_port_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Egress UC / MC Queue - same function handle */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_egress_queue_sched_get(unit, gport, cosq, mode, weight);
    }
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
        rc = _bcm_petra_cosq_gport_fmq_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_sched_get(unit, gport, mode, weight);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_get(unit, gport, mode, weight);
    }    
    /* E2E hierarchy */
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) || (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) || (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ||
                                                    (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ) {
        rc = _bcm_petra_cosq_gport_e2e_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Port TC / Port TCG */
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        rc = _bcm_petra_cosq_gport_egress_port_tc_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        rc = _bcm_petra_cosq_gport_egress_port_tcg_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        rc = _bcm_petra_cosq_gport_e2e_port_tc_sched_get(unit, gport, cosq, mode, weight);
    }    
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        rc = _bcm_petra_cosq_gport_e2e_port_tcg_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_INGRESS(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_ingress));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_EGRESS(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_egress));
    } 
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_all));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_egress_core_fifo_local_ucast));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x)"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int         resource_type_flag;
    uint32      resource_count;
    bcm_cosq_ingress_queue_bundle_gport_config_t config;
    int cosq;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* basic consistency checks */
    resource_type_flag = (flags &
                           (BCM_COSQ_GPORT_SCHEDULER | BCM_COSQ_GPORT_VOQ_CONNECTOR |
                            BCM_COSQ_GPORT_VSQ | BCM_COSQ_GPORT_MCAST_QUEUE_GROUP |
                            BCM_COSQ_GPORT_ISQ | BCM_COSQ_GPORT_UCAST_QUEUE_GROUP));

    resource_count = _bcm_cosq_bit_count_get(resource_type_flag);
    if (resource_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid resource flags 0x%x - only one resource can be allocated, number resources specified %d"), unit, resource_type_flag, resource_count));
    }
    
    /* check for scheduler resource allocation */
    if (flags & BCM_COSQ_GPORT_SCHEDULER) {
        rc = _bcm_petra_cosq_sched_gport_add(unit, port, numq, flags, gport);
    }

    /* check for connector resource allocation */
    else if (flags & BCM_COSQ_GPORT_VOQ_CONNECTOR) {
        rc = _bcm_petra_cosq_connector_gport_add(unit, port, numq, flags, gport);
    }  
    /* check for multicast resource allocation */
    else if (flags & BCM_COSQ_GPORT_MCAST_QUEUE_GROUP) {
        config.flags = flags;
        config.port = port;
        config.local_core_id = BCM_CORE_ALL;
        config.numq = numq;
        for (cosq = 0 ; cosq < BCM_COS_COUNT; cosq++) {
            /*setting all of the rate classes zero*/
            config.queue_atrributes[cosq].delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED;
            /*setting all of the credit request profiles to zero*/
            config.queue_atrributes[cosq].rate_class = 0;
        }
        rc = _bcm_petra_cosq_mcast_gport_add(unit, &config, gport);
    }
    /* unicast or ISQ resources */
    else if ((flags & BCM_COSQ_GPORT_UCAST_QUEUE_GROUP) || 
         (flags & BCM_COSQ_GPORT_ISQ)) {
        config.flags = flags;
        config.port = port;
        config.local_core_id = BCM_CORE_ALL;
        config.numq = numq;       
        for (cosq = 0 ; cosq < BCM_COS_COUNT; cosq++) {
            /*setting all of the rate classes zero*/
            config.queue_atrributes[cosq].delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED;
            /*setting all of the credit request profiles to default 10 slow enabled mode*/
            config.queue_atrributes[cosq].rate_class = 0;
        }
        rc = _bcm_petra_cosq_ucast_gport_add(unit, &config, gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, add not support for gport(0x%x)"), unit, *gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_get(int unit,
                         bcm_gport_t gport,
                         bcm_gport_t *physical_port,
                         int *num_cos_levels,
                         uint32 *flags)
{
    bcm_error_t   rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    /* consistency cheks */
    if (flags == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flags, must be 0"), unit));
    }

    if (flags != NULL) {
        (*flags) = 0;
    }
    if (num_cos_levels != NULL) {
       (*num_cos_levels) = 0;
    }
    if (physical_port != NULL) {
       (*physical_port) = 0;
    } else {
    /* Not all calls use physical_port,
     * but since that may change, better to 
     * expect it as a valid parameter
     */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, physical port must be valid parameter - not NULL"), unit));
    }

    BCMDNX_NULL_CHECK(num_cos_levels);
    
    if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        rc = _bcm_petra_cosq_connector_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if (BCM_GPORT_IS_SCHEDULER(gport)) {
        rc = _bcm_petra_cosq_sched_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        rc = _bcm_petra_cosq_e2e_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) || 
         (BCM_COSQ_GPORT_IS_ISQ(gport))) {
        rc = _bcm_petra_cosq_ucast_gport_get(unit, gport, physical_port, (uint32*)num_cos_levels, flags);
    }
    else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        rc = _bcm_petra_cosq_mcast_gport_get(unit, gport, physical_port, (uint32*)num_cos_levels, flags);
    }
    else {
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_delete(int unit,
                            bcm_gport_t gport)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* consistency checks */
    if (BCM_GPORT_IS_SCHEDULER(gport)) {
        rc = _bcm_petra_cosq_sched_gport_delete(unit, gport);
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        rc = _bcm_petra_cosq_connector_gport_delete(unit, gport);
    }
    else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        rc = _bcm_petra_cosq_mcast_gport_delete(unit, gport);
    }
    else if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) || 
         (BCM_COSQ_GPORT_IS_ISQ(gport))) {
        rc = _bcm_petra_cosq_ucast_gport_delete(unit, gport);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, delete not support for gport(0x%x)"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}
int bcm_petra_cosq_gport_traverse(int unit,
                                  bcm_cosq_gport_traverse_cb cb,
                                  void *user_data)
{
    bcm_error_t rc = BCM_E_NONE;
    int voq = 0, nbr_cos = 0;
    bcm_dpp_cosq_voq_config_t *voq_config;
    bcm_gport_t gport = 0;
    int is_multicast=FALSE, is_isq=FALSE, is_unicast=FALSE;
    int queue_type = 0;
    int flow_id = 0;
    int se_id,
        se_id_start,
        se_id_end,
        se_id_type,
        se_type_iter,
        se_id_loop_start[3] = {DPP_DEVICE_COSQ_CL_SE_ID_MIN_ARAD, DPP_DEVICE_COSQ_FQ_SE_ID_MIN_ARAD, DPP_DEVICE_COSQ_HR_SE_ID_MIN_ARAD},
        se_id_loop_end[3] = {DPP_DEVICE_COSQ_CL_SE_ID_MAX_ARAD, DPP_DEVICE_COSQ_FQ_SE_ID_MAX_ARAD, DPP_DEVICE_COSQ_HR_SE_ID_MAX_ARAD},
        se_ids_types[3] = {DPP_DEVICE_COSQ_CL_MASK, DPP_DEVICE_COSQ_FQ_MASK, DPP_DEVICE_COSQ_HR_MASK};
    bcm_dpp_cosq_connector_config_t *conn_config;
    bcm_dpp_cosq_se_config_t *se_config;
    int core = 0;

    BCMDNX_INIT_FUNC_DEFS;

    /* walk through all the queues in the system, create gport and call
     * callback function for each unicast or multicast gport, passing 
     * user data to cb function
     */
    
    BCM_DPP_ASSYMETRIC_CORES_ITER(BCM_CORE_ALL, core) {
        for (voq=4;
             voq <  DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit); 
             voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {
            voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                             &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core, voq));
            if (voq_config ==  NULL) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Unit(%d) voq(%d) state not available\n"), unit, voq));
                rc = BCM_E_RESOURCE;
                BCMDNX_IF_ERR_EXIT(rc);
            }
            nbr_cos = voq_config->num_cos;

            /* Queue not in use, go to the next */
            if (nbr_cos == 0) {
                continue;
            }

            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit(%d) voq base(%d) num_cos(%d)\n"), 
                                  unit, voq, nbr_cos));


            rc = _bcm_petra_cosq_qid_type_get(unit, core, voq, &gport, &is_multicast,
                                              &is_unicast, &is_isq, &queue_type);

            if (BCM_FAILURE(rc)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, add not support for gport(0x%x)\n"), unit, gport));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            if (is_unicast) {
                BCM_GPORT_UNICAST_QUEUE_GROUP_SET(gport, voq);
            } 
            else if (is_multicast) {
                BCM_GPORT_MCAST_QUEUE_GROUP_SET(gport, voq);
            }
            else if (is_isq) {
                BCM_COSQ_GPORT_ISQ_SET(gport, voq);
            }
            rc = cb(unit, 0/*port*/, nbr_cos, 0/*flags*/, gport, user_data);

            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    for (flow_id=0;
         flow_id < DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit); 
         flow_id += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        conn_config = (bcm_dpp_cosq_connector_config_t*)_bcm_petra_cosq_element_get(unit,
                                               &(_dpp_cosq_config[unit].connector_hd), flow_id);
        if (conn_config == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) gport travers internal state retrieval error\n"), unit, flow_id));
        }
        nbr_cos = conn_config->num_cos;


        /* Queue not in use, go to the next */
        if (nbr_cos == 0) {
            continue;
        }

        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) connector flow(%d) num_cos(%d)\n"), 
                              unit, flow_id, nbr_cos));


        BCM_COSQ_GPORT_VOQ_CONNECTOR_SET(gport, flow_id);

        rc = cb(unit, 0/*port*/, nbr_cos, 0/*flags*/, gport, user_data);

        BCMDNX_IF_ERR_EXIT(rc);
    }
    for (se_type_iter = 0 ; se_type_iter < 3 ; ++se_type_iter) {

        se_id_start = se_id_loop_start[se_type_iter];
        se_id_end = se_id_loop_end[se_type_iter];
        se_id_type = se_ids_types[se_type_iter];

        for (se_id = se_id_start ; se_id <= se_id_end ;  ++se_id) {

            se_config = (bcm_dpp_cosq_se_config_t*)_bcm_petra_cosq_element_get(unit,
                                             &(_dpp_cosq_config[unit].se_hd), se_id);

            if (se_config ==  NULL) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,(_BSL_BCM_MSG_STR("Unit(%d) se(%d) state not available\n"), unit, se_id));
            }

            /* se not in use, go to the next */
            if (se_config->ref_cnt == 0) {
                continue;
            }

            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit(%d) se base(%d) num_ref(%d)\n"), 
                                  unit, se_id, se_config->ref_cnt));

            flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
            if (flow_id == DPP_DEVICE_COSQ_SCH_FLOW_ID_INVALID_ARAD) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,(_BSL_BCM_MSG_STR("unit %d, illegal se %d\n"), unit, se_id));
            }

            BCM_GPORT_SCHEDULER_SET(gport,flow_id);

            rc = cb(unit, 0/*port*/, 1, se_id_type/*flags*/, gport, user_data);

            BCMDNX_IF_ERR_EXIT(rc);

        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_priority_get(int unit, 
                                int start_queue,
                                int end_queue,
                                int *pri_profile_id)
{
    uint32 region = 0, last_region, start_region = 0;
    uint32 first_profile_id = 0, profile_id = 0;
    uint32 soc_sand_rc;
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_* is not supported in Jericho")));
    }

    if (pri_profile_id == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile_id valid pointer required")));        
    }
    if (start_queue > end_queue) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) must be less than end queue(%d)"), 
                       unit, start_queue, end_queue));
    }
    if (((end_queue+1)%DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0) || 
        (start_queue%DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) and end queue(%d)+1 must be multiple of 64"), 
                       unit, start_queue, end_queue));
    }
    
    start_region = start_queue/DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    last_region = start_region + (end_queue - start_queue)/DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    for (region = start_region;
         region <= last_region;
         region++) {
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_select_get,(unit, region, &profile_id)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_select_get region %d, profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, region, 
                                  profile_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        
        if (region == start_region) {
            first_profile_id = profile_id;
        }
        if (first_profile_id != profile_id) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("template queue range mismatch region(%d)=(%d) doesn't match start (%d)=(%d)"), 
                                        region, profile_id, start_region, first_profile_id));
        }
    }
    *pri_profile_id = profile_id;
    
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_priority_set(int unit,
                                int start_queue,
                                int end_queue,
                                int pri_profile_id)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 region = 0, last_region = 0;
    uint32 soc_sand_rc;
    uint32 start_region;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_* is not supported in Jericho")));
    }

    if (pri_profile_id > DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, maximum profile exceeded (3) number resources specified (%d)\nmaximum profile exceeded"), 
                       unit, pri_profile_id));

    }
    if (start_queue > end_queue) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) must be less than end queue(%d)\nstart queue exceeds end queue"), 
                       unit, start_queue, end_queue));
    }
    if (((end_queue+1)%DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0) || 
        (start_queue%DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) and end queue(%d)+1 must be multiple of 64\nparameter error"), 
                       unit, start_queue, end_queue));
    }

    start_region = start_queue/DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    last_region = start_region + (end_queue - start_queue)/DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;

    for (region = start_region;
         region <= last_region; 
         region++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_select_set,(unit, region, pri_profile_id)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_select_set region %d, profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, region, 
                                  pri_profile_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_priority_profile_get(int unit,
                                        int pri_profile_id,
                                        int *count,
                                        bcm_cosq_gport_priority_profile_t *pri_profile)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_PRIORITY_MAP_TMPLT prm_info;
    uint32 soc_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_profile_* is not supported in Jericho")));
    }

    SOC_TMC_ITM_PRIORITY_MAP_TMPLT_clear(&prm_info);

    if (pri_profile_id > DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, maximum profile exceeded (3) number resources specified (%d)\n"), 
                              unit, pri_profile_id));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("maximum profile exceeded")));

    }
    if (pri_profile == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, parameter pri_profile pointer error\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile error")));

    }
    *count = DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_get,(unit, pri_profile_id, &prm_info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_get  profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    pri_profile->pri[0] = prm_info.map[0];
    pri_profile->pri[1] = prm_info.map[1];

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_priority_profile_set(int unit,
                                        int pri_profile_id,
                                        int count,
                                        bcm_cosq_gport_priority_profile_t *pri_profile)

{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_PRIORITY_MAP_TMPLT prm_info;
    uint32 soc_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    SOC_TMC_ITM_PRIORITY_MAP_TMPLT_clear(&prm_info);

    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_profile_* is not supported in Jericho")));
    }

    if (pri_profile_id > DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, maximum profile exceeded (3) number resources specified (%d)\n"), 
                              unit, pri_profile_id));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("maximum profile exceeded")));

    }
    if (pri_profile == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, parameter pri_profile pointer error\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile error")));

    }
    if (count != DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, count(%d) must be (%d) queues per template\n"), 
                              unit, count, BCM_COSQ_PRIORITY_PROFILE_MAX_SIZE));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("count error")));

    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_get,(unit, pri_profile_id, &prm_info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_get  profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    

    prm_info.map[0] = pri_profile->pri[0];
    prm_info.map[1] = pri_profile->pri[1];

    soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_set,(unit, pri_profile_id, &prm_info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_set  profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose: Commit in HW rate class information 
 */
STATIC int
_bcm_petra_cosq_vsq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_vsq_rate_class_info_t *rate_class_info,
                                      bcm_dpp_cosq_vsq_rate_class_info_t *exact_rate_class_info)
{
    uint32                soc_sand_rc = 0;    
    int dp_index, vsq_category_index;
    SOC_TMC_ITM_WRED_QT_DP_INFO wred_info, exact_wred_info;
    SOC_TMC_ITM_VSQ_TAIL_DROP_INFO tail_drop_info, exact_tail_drop_info;
    SOC_TMC_ITM_VSQ_WRED_GEN_INFO wred_gen_info;
    SOC_TMC_ITM_VSQ_FC_INFO fc_info, exact_fc_info;
    soc_dpp_config_t *dpp = SOC_DPP_CONFIG(unit);

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(rate_class_info);    
    
    SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&exact_wred_info);
    SOC_TMC_ITM_VSQ_TAIL_DROP_INFO_clear(&exact_tail_drop_info);
    SOC_TMC_ITM_VSQ_FC_INFO_clear(&exact_fc_info);


    for (vsq_category_index = 0; vsq_category_index < DPP_DEVICE_COSQ_VSQ_NOF_CATEGORY(unit); vsq_category_index++) {
        for (dp_index = 0; dp_index < DPP_DEVICE_COSQ_ING_NOF_DP; dp_index++) {
            SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
            SOC_TMC_ITM_VSQ_TAIL_DROP_INFO_clear(&tail_drop_info);
            SOC_TMC_ITM_VSQ_WRED_GEN_INFO_clear(&wred_gen_info);
            
            /* WRED */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_wred_get,(unit,vsq_category_index, rate_class,dp_index,&wred_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_wred_gen_get,(unit,vsq_category_index, rate_class,&wred_gen_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
            wred_info.max_avrg_th = rate_class_info->wred_max_avrg_th[vsq_category_index][dp_index];
            wred_info.min_avrg_th = rate_class_info->wred_min_avrg_th[vsq_category_index][dp_index];
            wred_info.max_probability = rate_class_info->wred_max_probability[vsq_category_index][dp_index];
            if (rate_class_info->wred_enable[vsq_category_index][dp_index]) {
                wred_gen_info.wred_en = 1;
            }
            wred_info.ignore_packet_size = (dpp->tm.wred_packet_size == 0) ? 1:0;
            wred_info.max_packet_size = dpp->tm.wred_packet_size;
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_wred_set,(unit,vsq_category_index, rate_class,dp_index,&wred_info,&exact_wred_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_wred_gen_set,(unit,vsq_category_index, rate_class,&wred_gen_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
            /* Set exact rate class information according to exact wred information */
            exact_rate_class_info->wred_min_avrg_th[vsq_category_index][dp_index] = exact_wred_info.min_avrg_th;
            exact_rate_class_info->wred_max_avrg_th[vsq_category_index][dp_index] = exact_wred_info.max_avrg_th;
            exact_rate_class_info->wred_max_probability[vsq_category_index][dp_index] = exact_wred_info.max_probability;
            exact_rate_class_info->wred_enable[vsq_category_index][dp_index] = wred_gen_info.wred_en;       
            exact_rate_class_info->wred_ignore_packet_size[vsq_category_index][dp_index] = wred_info.max_packet_size;

            /* Tail drop */                                
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_tail_drop_get,(unit,vsq_category_index, rate_class,dp_index,&tail_drop_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
            tail_drop_info.max_inst_q_size = rate_class_info->queue_max_size[vsq_category_index][dp_index];
            tail_drop_info.max_inst_q_size_bds = rate_class_info->queue_max_size_bds[vsq_category_index][dp_index];
    
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_tail_drop_set,(unit,vsq_category_index, rate_class,dp_index,&tail_drop_info,&exact_tail_drop_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            exact_rate_class_info->queue_max_size[vsq_category_index][dp_index] = exact_tail_drop_info.max_inst_q_size;   
            exact_rate_class_info->queue_max_size_bds[vsq_category_index][dp_index] = exact_tail_drop_info.max_inst_q_size_bds;   


        }

        SOC_TMC_ITM_VSQ_FC_INFO_clear(&fc_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_fc_get,(unit, vsq_category_index, rate_class, &fc_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        fc_info.q_size_fc.set = rate_class_info->fc_queue_size[vsq_category_index].set;
        fc_info.q_size_fc.clear = rate_class_info->fc_queue_size[vsq_category_index].clear;
        fc_info.bd_size_fc.set = rate_class_info->fc_bd_size[vsq_category_index].set;
        fc_info.bd_size_fc.clear = rate_class_info->fc_bd_size[vsq_category_index].clear;

        /* Set information */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_fc_set,(unit, vsq_category_index, rate_class, &fc_info,&exact_fc_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        exact_rate_class_info->fc_queue_size[vsq_category_index].set = exact_fc_info.q_size_fc.set;
        exact_rate_class_info->fc_queue_size[vsq_category_index].clear = exact_fc_info.q_size_fc.clear;
        exact_rate_class_info->fc_bd_size[vsq_category_index].set = exact_fc_info.bd_size_fc.set;
        exact_rate_class_info->fc_bd_size[vsq_category_index].clear = exact_fc_info.bd_size_fc.clear;  
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_category_get(int unit,
                                 int queue_id,
                                 int *vsq_category)
{
    uint32 soc_sand_rc;
    SOC_TMC_ITM_CATEGORY_RNGS info;
    int queue_category = 0;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_CATEGORY_RNGS_clear(&info);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_category_rngs_get,(unit, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (queue_id <= info.vsq_ctgry0_end) {
        queue_category = 0;
    } else if (queue_id <= info.vsq_ctgry1_end) {
        queue_category = 1;
    } else if (queue_id <= info.vsq_ctgry2_end) {
        queue_category = 2;
    } else {
        queue_category = 3;
    }
    *vsq_category = queue_category;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_vsq_id_range_verify(int unit,
                                    int queue_id,
                                    int vsq_category,
                                    int *is_match)
{
    bcm_error_t rv;
    int queue_category = 0;
    BCMDNX_INIT_FUNC_DEFS;
    
    *is_match = 0;

    rv = _bcm_petra_cosq_vsq_category_get(unit, queue_id, &queue_category);
    BCMDNX_IF_ERR_EXIT(rv);

    if (queue_category == vsq_category) {
        *is_match = 1;
    } 

    BCMDNX_IF_ERR_EXIT(rv);        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_add(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_type, vsq_type_info, queue_id;
    int vsq_category = 0, vsq_connection_cls = -1, vsq_traffic_cls = -1;    
    int is_match;
    int core = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Validate parameters */
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq gport type 0x%x "), unit, vsq));        
    }

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(queue)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq gport type 0x%x "), unit, queue));        
    }

    if (cosq < 0 || cosq > DPP_DEVICE_COSQ_ING_NOF_TC) {    
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }    

    queue_id = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(queue)+cosq;
    vsq_type = BCM_COSQ_GPORT_VSQ_TYPE_GET(vsq);

    if (!(vsq_type & (BCM_COSQ_VSQ_CTCC | BCM_COSQ_VSQ_CTTC))) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, type is %d: no members adding for this type of vsq "), unit, vsq,vsq_type));
    }

       

    vsq_type_info = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GET(vsq);
    if (vsq_type & BCM_COSQ_VSQ_CTCC) {
        vsq_category = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPC_CATEGORY_GET(vsq_type_info);
        vsq_connection_cls = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPC_CONNECTION_GET(vsq_type_info);
        
    }
    if (vsq_type & BCM_COSQ_VSQ_CTTC) {
        vsq_category = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_CATEGORY_GET(vsq_type_info);
        vsq_traffic_cls = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(vsq_type_info);        
    }
    
    rc = _bcm_petra_cosq_vsq_id_range_verify(unit,queue_id,vsq_category,&is_match);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_match) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, voq 0x%x: no match between voq queue category and vsq gport category "), unit, vsq,queue));
    }   

    /* Set new mapping */
    if (vsq_connection_cls != -1) {
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,queue_id,BCM_DPP_COSQ_VSQ_CC,vsq_connection_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (vsq_traffic_cls != -1) {
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,queue_id,BCM_DPP_COSQ_VSQ_TC,vsq_traffic_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_delete(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_type, vsq_type_info, queue_id;
    int vsq_category = 0, vsq_connection_cls = 0, vsq_traffic_cls = 0; 
    int is_match;  
    int core = BCM_CORE_ALL;

    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Validate parameters */
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq gport type 0x%x "), unit, vsq));        
    }

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(queue)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq gport type 0x%x "), unit, queue));        
    }

    if (cosq < 0 || cosq > DPP_DEVICE_COSQ_ING_NOF_TC) {    
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }    

    queue_id = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(queue)+cosq;
    vsq_type = BCM_COSQ_GPORT_VSQ_TYPE_GET(vsq);

    if (!(vsq_type & (BCM_COSQ_VSQ_CTCC | BCM_COSQ_VSQ_CTTC))) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, type is %d: no members adding for this type of vsq "), unit, vsq,vsq_type));
    }

       

    vsq_type_info = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GET(vsq);
    if (vsq_type & BCM_COSQ_VSQ_CTCC) {
        vsq_category = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPC_CATEGORY_GET(vsq_type_info);
        vsq_connection_cls = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPC_CONNECTION_GET(vsq_type_info);        
    }
    if (vsq_type & BCM_COSQ_VSQ_CTTC) {
        vsq_category = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_CATEGORY_GET(vsq_type_info);
        vsq_traffic_cls = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(vsq_type_info);            
    }
    
    rc = _bcm_petra_cosq_vsq_id_range_verify(unit,queue_id,vsq_category,&is_match);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_match) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, voq 0x%x: no match between voq queue category and vsq gport category "), unit, vsq,queue));
    }   

    /* 1. Set new mapping to new default profile (0) */
    if (vsq_type & BCM_COSQ_VSQ_CTTC) {
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,queue_id,BCM_DPP_COSQ_VSQ_CC,vsq_connection_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (vsq_type & BCM_COSQ_VSQ_CTTC) {
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,queue_id,BCM_DPP_COSQ_VSQ_TC,vsq_traffic_cls);    
        BCMDNX_IF_ERR_EXIT(rc);
    }
  
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_delete_all(
    int unit, 
    bcm_gport_t vsq)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_get(
    int unit, 
    bcm_gport_t vsq, 
    int queue_max, 
    bcm_gport_t *queue_array, 
    bcm_cos_queue_t *cosq_array, 
    int *queue_count)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_vsq_get_group_type(int unit,
                                         bcm_cosq_vsq_info_t* vsq_info,
                                         bcm_dpp_cosq_vsq_type_t *vsq_group_type)                                 
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (vsq_info->flags & BCM_COSQ_VSQ_GL) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_GLOBAL;
    }

    if (vsq_info->flags & BCM_COSQ_VSQ_CT) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTGRY;        
    }
    
    if (vsq_info->flags & BCM_COSQ_VSQ_CTTC) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTTC;
    }
    
    if (vsq_info->flags & BCM_COSQ_VSQ_CTCC) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTCC;
    }

    if (vsq_info->flags & BCM_COSQ_VSQ_PP) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_PP;
    }

    if (vsq_info->flags & BCM_COSQ_VSQ_PFC) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_PFC;
    }

    if (vsq_info->flags & BCM_COSQ_VSQ_LLFC) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_LLFC;
    }

    BCMDNX_IF_ERR_EXIT(rc);        

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Retreive VSQ information from VSQ GPORT. 
 * When vsq_group_type is of tmc type returns the inner vsq index in tmc type.
 */
int
_bcm_petra_cosq_gport_vsq_gport_get(int unit,
                                    bcm_gport_t vsq_gport,                                    
                                    bcm_dpp_cosq_vsq_type_t *vsq_group_type,
                                    int *vsq_index)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 vsq_type_info;
    int vsq_type;
    int src_port = 0;
    int traffic_class = 0;
    int interface_id = 0, internal_id = 0;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_LAST_ARAD;
    uint32 soc_sand_rc;  
    uint32 index = 0;  

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(vsq_group_type);
    BCMDNX_NULL_CHECK(vsq_index); 

    vsq_type = BCM_COSQ_GPORT_VSQ_TYPE_GET(vsq_gport);
    vsq_type_info = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GET(vsq_gport);

    if (vsq_type & (BCM_COSQ_VSQ_GL)) {
      *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_GLOBAL;
    } else if (vsq_type & (BCM_COSQ_VSQ_CT)) {
      *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTGRY;
      *vsq_index = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPA_CATEGORY_GET(vsq_type_info);
    } else if (vsq_type & (BCM_COSQ_VSQ_CTTC)) {
      *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTTC;
      *vsq_index = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_CATEGORY_GET(vsq_type_info) * DPP_COSQ_PACKET_NOF_TC + 
          BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(vsq_type_info);
    } else if (vsq_type & (BCM_COSQ_VSQ_CTCC)) {
      *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTCC;
      *vsq_index = (BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPC_CATEGORY_GET(vsq_type_info) - 2) * DPP_COSQ_VSQ_NOF_CONNECTION_CLASS +
          BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPC_CONNECTION_GET(vsq_type_info);  
    } else if (vsq_type & (BCM_COSQ_VSQ_PP)) {
      *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_PP;
      *vsq_index = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPD_STATISTICS_TAG_GET(vsq_type_info);
    } else if (vsq_type & (BCM_COSQ_VSQ_PFC | BCM_COSQ_VSQ_LLFC)) {
      if (vsq_type & BCM_COSQ_VSQ_PFC) {
        /* Retreive Class based and Src port */
        src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_SRC_PORT_GET(vsq_type_info);
        /* Class based = Traffic class in PB */
        traffic_class = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_TC_GET(vsq_type_info);
      } else {   
        /* LLFC */
        src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPF_SRC_PORT_GET(vsq_type_info);
      }

      /* Get internal interface id (0..63) */
      rc = bcm_petra_fap_port_parent_nif_get(unit,src_port,&interface_id);
      BCMDNX_IF_ERR_EXIT(rc);

#ifdef  BCM_PETRAB_SUPPORT
      if (SOC_IS_PETRAB(unit)) {        
        internal_id = soc_pb_nif2intern_id(interface_id);
      }
#endif /* BCM_PETRAB_SUPPORT */
#ifdef  BCM_ARAD_SUPPORT
      if (SOC_IS_ARAD(unit)) {


        
        internal_id = arad_nif2intern_id(unit, interface_id);        
      } 
#endif  /* BCM_ARAD_SUPPORT */
      
      /* Conclude VSQ Group ID */
      if (SOC_IS_PETRAB(unit)) {
        if (vsq_type & BCM_COSQ_VSQ_PFC) {
          
          vsq_id = BCM_DPP_VSQ_ID_CBFC8_PETRA(internal_id,traffic_class);        
        } else {
          /* LLFC */
          vsq_id = BCM_DPP_VSQ_ID_LLFC_PETRA(internal_id);
        }
      } 
      if (SOC_IS_ARAD(unit)) {
        if (vsq_type & BCM_COSQ_VSQ_PFC) {
          vsq_id = BCM_DPP_VSQ_ID_CBFC_ARAD(internal_id,traffic_class);
        } else {
          /* LLFC */
          vsq_id = BCM_DPP_VSQ_ID_LLFC_ARAD(internal_id);
        }      
      }       

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_global2group,( vsq_id, &soc_tmcvsq_type, &index)));
      if (SOC_SAND_FAILURE(soc_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in vsq id retreive %d, vsq gport 0x%x"), unit, vsq_id, vsq_gport));
      }

      *vsq_index = (int)index;
      
      rc = _bcm_petra_cosq_tmc_vsq_type_to_bcm_vsq_type(soc_tmcvsq_type,vsq_group_type);
      BCMDNX_IF_ERR_EXIT(rc);

    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq 0x%x type %d "), unit, vsq_gport,vsq_type));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_vsq_gport_set(int unit,
                                    bcm_cosq_vsq_info_t* vsq_info,
                                    bcm_dpp_cosq_vsq_type_t vsq_group_type,                                    
                                    bcm_gport_t *vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_type;
    int local_port;

    BCMDNX_INIT_FUNC_DEFS;
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PFC || vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_LLFC)
    {
      /* Retreive local port from source port */
      rc = _bcm_petra_cosq_vsq_local_port_from_gport(unit,vsq_info->src_port, &local_port);
      BCMDNX_IF_ERR_EXIT(rc);      
    }

    switch (vsq_group_type) {
      case BCM_DPP_COSQ_VSQ_TYPE_GLOBAL:
          BCM_COSQ_GPORT_VSQ_SET(*vsq_gport,BCM_COSQ_VSQ_GL,0);
          break;
      case BCM_DPP_COSQ_VSQ_TYPE_CTGRY:
          BCM_COSQ_VSQ_TYPE_INFO_GROUPA_SET(vsq_type,vsq_info->ct_id);
          BCM_COSQ_GPORT_VSQ_SET(*vsq_gport,BCM_COSQ_VSQ_CT,vsq_type);
          break;
      case BCM_DPP_COSQ_VSQ_TYPE_CTTC:
          BCM_COSQ_VSQ_TYPE_INFO_GROUPB_SET(vsq_type,vsq_info->ct_id,vsq_info->traffic_class);
          BCM_COSQ_GPORT_VSQ_SET(*vsq_gport,BCM_COSQ_VSQ_CTTC,vsq_type);
          break;
      case BCM_DPP_COSQ_VSQ_TYPE_CTCC:
          BCM_COSQ_VSQ_TYPE_INFO_GROUPC_SET(vsq_type,vsq_info->ct_id,vsq_info->cc_id);
          BCM_COSQ_GPORT_VSQ_SET(*vsq_gport,BCM_COSQ_VSQ_CTCC,vsq_type);
          break;
      case BCM_DPP_COSQ_VSQ_TYPE_PP:
          BCM_COSQ_VSQ_TYPE_INFO_GROUPD_SET(vsq_type,vsq_info->pp_vsq_id);
          BCM_COSQ_GPORT_VSQ_SET(*vsq_gport,BCM_COSQ_VSQ_PP,vsq_type);
          break;
      case BCM_DPP_COSQ_VSQ_TYPE_PFC:
          BCM_COSQ_VSQ_TYPE_INFO_GROUPE_SET(vsq_type,local_port,vsq_info->traffic_class);
          BCM_COSQ_GPORT_VSQ_SET(*vsq_gport,BCM_COSQ_VSQ_PFC,vsq_type);
          break;
      case BCM_DPP_COSQ_VSQ_TYPE_LLFC:
          BCM_COSQ_VSQ_TYPE_INFO_GROUPF_SET(vsq_type,local_port);
          BCM_COSQ_GPORT_VSQ_SET(*vsq_gport,BCM_COSQ_VSQ_LLFC,vsq_type);
          break;
      default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d "), unit, vsq_group_type));        
    }        

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_local_port_from_gport(int unit,
                                          bcm_gport_t src_port,
                                          int *local_port)
{
  bcm_error_t rv = BCM_E_NONE;

  BCMDNX_INIT_FUNC_DEFS;   
  rv = bcm_petra_cosq_user_port_get(unit, src_port, local_port);
  BCMDNX_IF_ERR_EXIT(rv);


exit:
BCMDNX_FUNC_RETURN;
}



STATIC int 
_bcm_petra_cosq_vsq_info_verify(int unit,
                                bcm_cosq_vsq_info_t *vsq_info)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* consistency checks */
    /* Validate category range */
    if ((vsq_info->flags & (BCM_COSQ_VSQ_CT | BCM_COSQ_VSQ_CTTC | BCM_COSQ_VSQ_CTCC)) 
        && (vsq_info->ct_id < 0 || vsq_info->ct_id > (SOC_TMC_ITM_VSQ_GROUPA_SZE-1))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ct_id range %d "), unit, vsq_info->ct_id));        
    }

    /* Validate traffic class range */
    if ((vsq_info->flags & (BCM_COSQ_VSQ_CTTC | BCM_COSQ_VSQ_PFC)) 
        && (vsq_info->traffic_class < 0 || vsq_info->traffic_class > (DPP_DEVICE_COSQ_ING_NOF_TC-1))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid traffic class range %d "), unit, vsq_info->traffic_class));        
    }

    /* Validate connection class range */
    if ((vsq_info->flags & (BCM_COSQ_VSQ_CTCC)) 
        && (vsq_info->ct_id < 2 || vsq_info->ct_id > 3 || vsq_info->cc_id > (DPP_COSQ_VSQ_NOF_CONNECTION_CLASS-1))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Category id or Connection class. CT %d, CC %d, CTCC expect category of 2-3 "), unit, vsq_info->ct_id, vsq_info->cc_id));        
    }

    /* Validate source  ports range */
    if ((vsq_info->flags & (BCM_COSQ_VSQ_PFC | BCM_COSQ_VSQ_LLFC))) {
        int local_port;

        rc = _bcm_petra_cosq_vsq_local_port_from_gport(unit,vsq_info->src_port, &local_port);
        BCMDNX_IF_ERR_EXIT(rc);

        if (local_port < 0 || local_port > (_BCM_PETRA_NOF_TM_PORTS(unit)-1)) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Source port. Source port %x "), unit, vsq_info->src_port));        
        }
    }

    /* Validate PP range */
    if ((vsq_info->flags & (BCM_COSQ_VSQ_PP))
        && (vsq_info->pp_vsq_id < 0 || vsq_info->pp_vsq_id > (DPP_COSQ_VSQ_NOF_PP_POINTERS-1))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid pp vsq id %d "), unit, vsq_info->pp_vsq_id));        
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_vsq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    int index, nof_drop_prec;  
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0; 
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_group;
    
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));    

    
    
    /* Validate Params */
    rc = _bcm_petra_cosq_gport_discard_verify(unit, discard, 1);
    BCMDNX_IF_ERR_EXIT(rc);

    if (cosq != 0 && cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
    }

    /* Retreive VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit,gport,&vsq_group_type,&vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_group);
    BCMDNX_IF_ERR_EXIT(rc);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_group2global,( soc_tmcvsq_group, vsq_index, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    

    /* Wred settings is defined by Rate Class profile */
    /* Get Rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change Rate class configuration according to discard structure */
    rc = _bcm_petra_cosq_voq_discard_retreive_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec == 0) {
        /* Nothing to change, just exit */
        BCM_EXIT;
    }

    /* Note: Wred enable is global per rate class, thus if at least one dp is enable, all dps are enable. */
    for (index = 0; index < nof_drop_prec; index++) {
        data_rate_class.wred_enable[soc_tmcvsq_group][drop_prec[index]] = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? SOC_SAND_TRUE:SOC_SAND_FALSE;
        data_rate_class.wred_min_avrg_th[soc_tmcvsq_group][drop_prec[index]] = discard->min_thresh;
        data_rate_class.wred_max_avrg_th[soc_tmcvsq_group][drop_prec[index]] = discard->max_thresh;
        data_rate_class.wred_max_probability[soc_tmcvsq_group][drop_prec[index]] = discard->drop_probability;
    }

    /* WRED exp wq parameter is same for all dps and ECN */
    /*data_rate_class.wred_exp_wq = discard->gain;*/

    /* Settings WRED parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Note: This process might lead to a false confirm, when configuration is not exact
       and there are not enough profiles that are free. This can be resolved if all configurations
       are exact */
     

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_petra_cosq_vsq_rate_class_exchange_set(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Retreive WRED configuration
 */
STATIC int
_bcm_petra_cosq_gport_vsq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;    
    int nof_drop_prec;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    uint32 relevant_flags;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];
    int dp_index;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = 0; 
    int vsq_index;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));    

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }

    if (cosq != 0 && cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
    }
   
    /* Retreive VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit,gport,&vsq_group_type,&vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_group2global,( soc_tmcvsq_type, vsq_index, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                              BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK);

    if (!relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x"), unit, discard->flags));
    }

    relevant_flags = discard->flags & (BCM_COSQ_DISCARD_BYTES);

    if (!relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no discard type 0x%x"), unit, discard->flags));
    }

    rc = _bcm_petra_cosq_voq_discard_retreive_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec != 1) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color"), unit, discard->flags));
    }

    dp_index = drop_prec[0];

    /* Wred settings is defined by Rate Class profile */
    /* Get Rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    discard->drop_probability = data_rate_class.wred_max_probability[soc_tmcvsq_type][dp_index];
    /*discard->gain = data_rate_class.wred_exp_wq;*/
    discard->min_thresh = data_rate_class.wred_min_avrg_th[soc_tmcvsq_type][dp_index];
    discard->max_thresh = data_rate_class.wred_max_avrg_th[soc_tmcvsq_type][dp_index];
    if (data_rate_class.wred_enable[soc_tmcvsq_type][dp_index] == SOC_SAND_TRUE) {
        discard->flags |= BCM_COSQ_DISCARD_ENABLE;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_gport_vsq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 relevant_flags, tail_drop_types_flags;   
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    int index, tail_drop_count;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = 0;
    int vsq_index;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));

    BCMDNX_NULL_CHECK(gport_size);

        
    
    /* Validate params */
    tail_drop_types_flags = (flags &
                           (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC));

    tail_drop_count = _bcm_cosq_bit_count_get(tail_drop_types_flags);
    if (tail_drop_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid tail drop flags 0x%x - only one drop can be allocated, number resources specified %d"), unit, tail_drop_types_flags, tail_drop_count));
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }    

    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && ((color < 0) || (color >= DPP_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    if (cosq != 0 && cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
    }

    /* Retreive VSQ ID */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit,gport,&vsq_group_type,&vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_group2global,( soc_tmcvsq_type, vsq_index, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    /* Get old rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change related information */
    if (flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND) {
        /* Set all dp information */
        for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
            if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
                data_rate_class.queue_max_size[soc_tmcvsq_type][index] = gport_size->size_max;
            } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                data_rate_class.queue_max_size_bds[soc_tmcvsq_type][index] = gport_size->size_max;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
            }
        }
    } else {
        /* Set sepcific dp */
        if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
           data_rate_class.queue_max_size[soc_tmcvsq_type][color] = gport_size->size_max;
        } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
            data_rate_class.queue_max_size_bds[soc_tmcvsq_type][color] = gport_size->size_max;
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
        }        
    }

    /* Settings Tail drop parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Note: This process might lead to a false confirm, when configuration is not exact
       and there are not enough profiles that are free. This can be resolved if all configurations
       are exact */

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_petra_cosq_vsq_rate_class_exchange_set(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_gport_vsq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 relevant_flags, tail_drop_types_flags;    
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;    
    int tail_drop_count;   
    uint32 soc_sand_rc; 
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = 0;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    int vsq_index;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    
    

    /* Validate params */
    tail_drop_types_flags = (flags &
                           (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC));

    tail_drop_count = _bcm_cosq_bit_count_get(tail_drop_types_flags);
    if (tail_drop_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid tail drop flags 0x%x - only one drop can be allocated, number resources specified %d"), unit, tail_drop_types_flags, tail_drop_count));
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && ((color < 0) || (color >= DPP_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    if (cosq != 0 && cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
    }

    /* Retreive VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit,gport,&vsq_group_type,&vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_group2global,( soc_tmcvsq_type, vsq_index, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Get old rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    if (flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND) {
        color = 0;
    }

    if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
        gport_size->size_max = data_rate_class.queue_max_size[soc_tmcvsq_type][color];
    } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
        gport_size->size_max = data_rate_class.queue_max_size_bds[soc_tmcvsq_type][color];
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n . Missing size flag"), unit, flags));
    }
    
    gport_size->size_min = 0;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_drop_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_DROP_TH drop_info,exact_drop_info;
    uint32 relevant_flags, threshold_type_flags, soc_sand_rc;
    int threshold_count;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    /* Validate threshold types */
    if (!(threshold->type == bcmCosqThresholdDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
          || threshold->type == bcmCosqThresholdFullDbuffs
          || threshold->type == bcmCosqThresholdMiniDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdBytes)) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    /* The BCM_COSQ_THRESHOLD_OCB flag is used to configure One Way Bypass thresholds.
       This feature is supported only from aradplus */
#ifdef BCM_ARAD_SUPPORT 
    if(SOC_IS_ARAD_B1_AND_BELOW(unit)){
        if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, using flag BCM_COSQ_THRESHOLD_OCB is supported only for aradplus and above\n"), unit));
        }
    }
#endif

    /* Validate flags */
    relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_UNICAST |
                              BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | BCM_COSQ_THRESHOLD_DROP | BCM_COSQ_THRESHOLD_OCB);
    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    threshold_type_flags = (threshold->flags & 
                           (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR));

    threshold_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (threshold_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - only one flag between set, clear can be on"), unit, threshold->flags));
    }

    /* Validate param */
    if (threshold->dp < 0 || threshold->dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    SOC_TMC_ITM_GLOB_RCS_DROP_TH_clear(&drop_info);

    /* Retreive information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_drop_get,(unit,&drop_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
         
    if ((threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && threshold->type == bcmCosqThresholdDbuffs) {
        /* Set unicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.unicast[threshold->dp],threshold->flags,threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdFullDbuffs) {
        /* Set full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.full_mc[threshold->dp],threshold->flags,threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdMiniDbuffs) {
        /* Set mini multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.mini_mc[threshold->dp],threshold->flags,threshold->value);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBufferDescriptors) {
        /* Set bds thresholds */
        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.bds[threshold->dp],threshold->flags,threshold->value);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
        /* Set bdbs thresholds */
        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.bdbs[threshold->dp],threshold->flags,threshold->value);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBytes) {
        /* Set bdbs thresholds */
        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.mem_excess[threshold->dp],threshold->flags,threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set OCB unicast dbuffs thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_uc[threshold->dp], threshold->flags, threshold->value);
    }

    else if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) 
        && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set OCB full multicast dbuffs thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_mc[threshold->dp], threshold->flags, threshold->value);
    }

    /* Set information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_drop_set,(unit,&drop_info,&exact_drop_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_drop_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_DROP_TH drop_info;
    uint32 relevant_flags, threshold_type_flags, soc_sand_rc;
    int threshold_count;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    /* Validate threshold types */
    if (!(threshold->type == bcmCosqThresholdDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
          || threshold->type == bcmCosqThresholdFullDbuffs
          || threshold->type == bcmCosqThresholdMiniDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdBytes)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    /* Validate flags */
    relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_UNICAST |
                              BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | BCM_COSQ_THRESHOLD_DROP | BCM_COSQ_THRESHOLD_OCB);
    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    threshold_type_flags = (threshold->flags & 
                           (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR));

    threshold_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (threshold_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - only one flag between set, clear can be on"), unit, threshold->flags));
    }

    /* Validate param */
    if (threshold->dp < 0 || threshold->dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    SOC_TMC_ITM_GLOB_RCS_DROP_TH_clear(&drop_info);

    /* Retreive information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_drop_get,(unit,&drop_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
         
    if ((threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && threshold->type == bcmCosqThresholdDbuffs) {
        /* Get unicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.unicast[threshold->dp]);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdFullDbuffs) {
        /* Get full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.full_mc[threshold->dp]);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdMiniDbuffs) {
        /* Get mini multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.mini_mc[threshold->dp]);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBufferDescriptors) {
        /* Get bds thresholds */
        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.bds[threshold->dp]);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
        /* Get bdbs thresholds */
        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.bdbs[threshold->dp]);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBytes) {
        /* Get bdbs thresholds */
        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.mem_excess[threshold->dp]);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdDbuffs) 
        && (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)) { 
        /* Set OCB unicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_HYST_GET(unit, threshold->value, threshold->flags, drop_info.ocb_uc[threshold->dp]);
    }

    else if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdDbuffs)
        && (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST)) { 
        /* Set OCB full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_HYST_GET(unit, threshold->value, threshold->flags, drop_info.ocb_mc[threshold->dp]);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* Verify params given to APIs configuring scheduled voq ocb thresholds (per port)
*/
STATIC int
_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint8 is_set,
                                                    bcm_cosq_threshold_t *threshold)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    if (!(threshold->type == bcmCosqThresholdBytes
        || threshold->type == bcmCosqThresholdDbuffs)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_OCB | BCM_COSQ_THRESHOLD_UNICAST))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }
    if (is_set){
        if ((threshold->flags & BCM_COSQ_THRESHOLD_SET) &&
            (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Both of the flags SET and CLEAR are set"), unit));
        }
    }
    if (!(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    /*verify vsq_category if it is specified directly*/
    if (threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC){
        if (threshold->tc < 0 || threshold->tc > DPP_DEVICE_COSQ_ING_NOF_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid tc parameter %d"), threshold->flags ));
        }
    } 
    /*verify tc if it is specified directly*/
    if (threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY){
        if (threshold->vsq_category < 0 || threshold->vsq_category >= DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid vsq_category parameter %d"), threshold->vsq_category));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_ARAD_SUPPORT
/*
* Purpose: 
* Set scheduled voq ocb thresholds (per rate class)
*/
STATIC int
_bcm_petra_cosq_rate_class_ocb_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int rate_class;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls, exact_data_rate_cls;
    BCMDNX_INIT_FUNC_DEFS;
    if (!(BCM_GPORT_IS_PROFILE(gport))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API, gport %d"), unit, gport));
    }   
    rate_class = BCM_GPORT_PROFILE_GET(gport);
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    rc = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rc);
   
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    BCMDNX_NULL_CHECK(threshold);

    rc =_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,TRUE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Old data get */
    rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    /*set relevant data int the rate class data*/
    rc = _bcm_petra_cosq_ocb_threshold_to_rate_class(unit, threshold, &data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    /*2. configure HW*/
    rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit,rate_class,&data_rate_cls,&exact_data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);        


    /* 
     * Note: No SW Update of ocb voq eligible 
     * This udate is done by passing a queue gport type with flags BCM_COSQ_THRESHOLD_IGNORE_VALUE, since we must know what qid should be configured                                                                                                                                                                             );
     * soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[threshold->tc][threshold->vsq_category].voq_eligible)));
     * BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
     */
exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* ignore value only of a voq (per port)
*/
STATIC int
_bcm_petra_cosq_voq_ocb_threshold_ignore_value_set(int unit,
                                                   int qid,
                                                   int tc,
                                                   int vsq_category) 
{
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls;
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    /*verify tc and vaq_category if they are specified directly*/
    if (tc < 0 || tc >= DPP_DEVICE_COSQ_ING_NOF_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid tc parameter %d"), tc));
    }
    if (vsq_category < 0 || vsq_category >= DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid vsq_category parameter %d"), vsq_category));
    }
    rc = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit,qid,&data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[tc][vsq_category].voq_eligible)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}
#endif /*BCM_ARAD_SUPPORT*/

/*
* Purpose: 
* Set scheduled voq ocb thresholds (per port)
*/
STATIC int
_bcm_petra_cosq_voq_ocb_threshold_set(int unit,
                                      bcm_gport_t gport,
                                      bcm_cos_queue_t cosq,
                                      bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_voq_config_t *voq_config;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls, exact_data_rate_cls;
    int is_allocated, is_last;
    int new_rate_cls, old_rate_cls;
    int base_queue, qid;
    int tc, vsq_category;
    uint32 soc_sand_rc;
    int core = BCM_CORE_ALL; 
#ifdef BCM_ARAD_SUPPORT
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
#endif /*BCM_ARAD_SUPPORT*/
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_get(unit, &queue_to_rate_class_mapping_is_simple));
        if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED) {
            BCM_SAND_IF_ERR_EXIT(_bcm_petra_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));
        }
    }
#endif /*BCM_ARAD_SUPPORT*/

    if (!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }
    base_queue = BCM_GPORT_UCAST_QUEUE_GROUP_QID_GET(gport);
    /* Verify */
    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                                         &(_dpp_cosq_config[unit].voq_hd),
                                                                         DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue));
    if (voq_config ==  NULL) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error"),
                     unit, base_queue));
    }
    if ((cosq < 0) || (cosq >= voq_config->num_cos)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
    }
    qid = base_queue + cosq;

#ifdef BCM_ARAD_SUPPORT
    if ((SOC_IS_ARAD(unit)) && (threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC)) {
        tc = threshold->tc;
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        tc = cosq;
        threshold->tc = tc;
    }

#ifdef BCM_ARAD_SUPPORT
    if ((SOC_IS_ARAD(unit)) && (threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY)) {
        vsq_category = threshold->vsq_category;
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        /* get vsq category */
        rc = _bcm_petra_cosq_vsq_category_get(unit, qid, &vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
        threshold->vsq_category = vsq_category;
    }

#ifdef BCM_ARAD_SUPPORT
    if ((SOC_IS_ARAD(unit)) && queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED) {
        rc = _bcm_petra_cosq_voq_ocb_threshold_ignore_value_set(unit, qid, tc, vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        /* SW Update */
        /* Old data get */
        rc = _bcm_dpp_am_template_queue_rate_cls_data_get(unit,qid,&data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

        /*if !queue_to_rate_class_mapping_is_simple only configure ocb_voq_eligible_dynamic_set ignoring threshold->value, else reconfigure the OCB using threshold->value*/
        rc =_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,TRUE,threshold);
        BCMDNX_IF_ERR_EXIT(rc);


        /*set relevant data int the rate class data*/
        rc = _bcm_petra_cosq_ocb_threshold_to_rate_class(unit, threshold, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Update information in SW */
        rc = _bcm_dpp_am_template_queue_rate_cls_exchange(unit,qid,&data_rate_cls,&old_rate_cls,&is_last,&new_rate_cls,&is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Commit Changes in HW according to given thresholds */
        if (is_allocated) {
            rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit,new_rate_cls,&data_rate_cls,&exact_data_rate_cls);
            BCMDNX_IF_ERR_EXIT(rc);        
        }
        /* Set new mapping */
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,qid,BCM_DPP_COSQ_RATE_CLS,new_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

#ifdef BCM_WARM_BOOT_SUPPORT
        rc = _bcm_dpp_wb_cosq_update_ingr_rate_class_data(unit, 0, old_rate_cls, new_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[tc][vsq_category].voq_eligible)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);       
    }
exit:
    BCMDNX_FUNC_RETURN;
}
#ifdef BCM_ARAD_SUPPORT
/*
* Purpose: 
* Get scheduled voq rate class ocb thresholds (per port)
*/
STATIC int
_bcm_petra_cosq_rate_class_ocb_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int rate_class;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls;
    int tc;
    int vsq_category;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    if (!(BCM_GPORT_IS_PROFILE(gport))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API, gport %d"), unit, gport));
    }   
    rate_class = BCM_GPORT_PROFILE_GET(gport);
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    rc =_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,FALSE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    /* data get */
    rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    tc = threshold->tc;
    vsq_category = threshold->vsq_category;

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_words[0]
                 * DPP_DEVICE_PETRA_COSQ_OCB_16BYTES_RESOLUTION;
            break;     
        case bcmCosqThresholdDbuffs:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_buffers[0];
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if(data_rate_cls.ocb_info[tc][vsq_category].voq_eligible == TRUE)
    {
        threshold->flags |= BCM_COSQ_THRESHOLD_SET;
    } else {
        threshold->flags |= BCM_COSQ_THRESHOLD_CLEAR;
    }

exit:
    BCMDNX_FUNC_RETURN;
}
#endif /*BCM_ARAD_SUPPORT*/
/*
* Purpose: 
* Get scheduled voq ocb thresholds (per port)
*/
STATIC int
_bcm_petra_cosq_voq_ocb_threshold_get(int unit,
                                      bcm_gport_t gport,
                                      bcm_cos_queue_t cosq,
                                      bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls;
    int base_queue, qid;
    int tc;
    int vsq_category;
#ifdef BCM_ARAD_SUPPORT
    int rate_class;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int core = BCM_CORE_ALL;
#endif /*BCM_ARAD_SUPPORT*/
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_get(unit, &queue_to_rate_class_mapping_is_simple));
    }
#endif /*BCM_ARAD_SUPPORT*/

    /* Verify */
    if (!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    rc =_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,FALSE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
    qid = base_queue + cosq;

#ifdef BCM_ARAD_SUPPORT
    if ((SOC_IS_ARAD(unit)) && (threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC)) {
        tc = threshold->tc;
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        tc = cosq;
    }

#ifdef BCM_ARAD_SUPPORT
    if ((SOC_IS_ARAD(unit)) && (threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY)) {
        vsq_category = threshold->vsq_category;
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        /* get vsq category */
        rc = _bcm_petra_cosq_vsq_category_get(unit, qid, &vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
    }
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && queue_to_rate_class_mapping_is_simple != ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        rc = _bcm_petra_cosq_voq_class_mapping_get(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, &rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        /* data get */
        rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        /* data get */
        rc = _bcm_dpp_am_template_queue_rate_cls_data_get(unit,qid,&data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_words[0]
                 * DPP_DEVICE_PETRA_COSQ_OCB_16BYTES_RESOLUTION;
            break;     
        case bcmCosqThresholdDbuffs:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_buffers[0];
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if(data_rate_cls.ocb_info[tc][vsq_category].voq_eligible == TRUE)
    {
        threshold->flags |= BCM_COSQ_THRESHOLD_SET;
    } else {
        threshold->flags |= BCM_COSQ_THRESHOLD_CLEAR;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * VSQ rate class exchange set commit includes allocation management and HW.
 */
STATIC int
_bcm_petra_cosq_vsq_rate_class_exchange_set(int unit,
                                            SOC_TMC_ITM_VSQ_NDX vsq_id,
                                            bcm_dpp_cosq_vsq_rate_class_info_t *data_rate_class)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    bcm_dpp_cosq_vsq_rate_class_info_t exact_data_rate_class, cleared_data_rate;
    int new_rate_class,is_allocated,old_rate_class,is_last;   
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_LAST_ARAD;    
    uint32 vsq_index = 0;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
    sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));    

    /* Convert global2group */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_global2group,( vsq_id, &soc_tmcvsq_type, &vsq_index)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Update information in SW */
    rc = _bcm_dpp_am_template_vsq_rate_cls_exchange(unit,vsq_id,data_rate_class,&old_rate_class,&is_last,&new_rate_class,&is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Commit Changes in HW according to given thresholds */
    if (is_allocated) {
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit,new_rate_class,data_rate_class,&exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);        
    } else {
        sal_memcpy(&exact_data_rate_class, data_rate_class, sizeof(exact_data_rate_class));
    }

    /* Set new mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_qt_rt_cls_set,(unit, soc_tmcvsq_type, vsq_index, new_rate_class)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* last profile data */
    if (is_last && new_rate_class != old_rate_class) {
        /* clear profile data */
        sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit,old_rate_class,&cleared_data_rate,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_vsq_rate_class_data(unit, 0, old_rate_class, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    /* Step 2: Allocate according to exact */
    /* Update information in SW according to exact thresholds */
    /* We have enough profiles here since or data was not exact and we allocated already new profile */
    /* or data was exact thus info is same */
    rc = _bcm_dpp_am_template_vsq_rate_cls_exchange(unit,vsq_id,&exact_data_rate_class,&old_rate_class,&is_last,&new_rate_class,&is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_allocated) {
        /* Set new profile data */
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit,new_rate_class,&exact_data_rate_class,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);        
    }
    
    /* Set new mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_qt_rt_cls_set,(unit, soc_tmcvsq_type, vsq_index, new_rate_class)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* last profile data */
    if (is_last && new_rate_class != old_rate_class) {
        /* clear profile data */
        sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit,old_rate_class,&cleared_data_rate,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }    

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_vsq_rate_class_data(unit, 0, old_rate_class, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_vsq_fc_threshold_set(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq,
                                     uint32 flags,
                                     bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_VSQ_FC_INFO fc_info,exact_fc_info;
    uint32 threshold_type_flags, soc_sand_rc;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0; 
    int flag_count;   

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_VSQ_FC_INFO_clear(&fc_info);
    SOC_TMC_ITM_VSQ_FC_INFO_clear(&exact_fc_info);

    /* basic consistency checks */
    threshold_type_flags = (flags);

    flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (flag_count != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - none flags should be set"), unit, threshold_type_flags));
    }

    /* Validate params */
    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be only 0"), unit,cosq));
    }

    /* Conver to VSQ type & VSQ ID */
    /* retreive vsq index */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, gport, &vsq_group_type,
                                             &vsq_index);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x"), unit, gport, rc));
    }

    /* Retreive VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit,gport,&vsq_group_type,&vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);    

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_group2global,( soc_tmcvsq_type, vsq_index, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    

    /* Get Rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
         
    /* Set unicast dbuffs thresholds */
    data_rate_class.fc_queue_size[soc_tmcvsq_type].set = pfc_threshold->xoff_threshold;
    data_rate_class.fc_queue_size[soc_tmcvsq_type].clear = pfc_threshold->xon_threshold;

    /* Set bdbs thresholds */
    data_rate_class.fc_bd_size[soc_tmcvsq_type].set = pfc_threshold->xoff_threshold_bd;
    data_rate_class.fc_bd_size[soc_tmcvsq_type].clear = pfc_threshold->xon_threshold_bd;

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_petra_cosq_vsq_rate_class_exchange_set(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_fc_threshold_get(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq,
                                     uint32 flags,
                                     bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 threshold_type_flags, soc_sand_rc;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;     
    int flag_count;       

    BCMDNX_INIT_FUNC_DEFS;
    /* basic consistency checks */
    threshold_type_flags = (flags);

    flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (flag_count != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - none flags should be set"), unit, threshold_type_flags));
    }

    /* Validate params */
    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be only 0"), unit,cosq));
    }

    /* Conver to VSQ type & VSQ ID */
    /* retreive vsq index */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, gport, &vsq_group_type,
                                             &vsq_index);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x"), unit, gport, rc));
    }

    /* Retreive VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit,gport,&vsq_group_type,&vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);    

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_group2global,( soc_tmcvsq_type, vsq_index, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    

    /* Get Rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit,vsq_id,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
         
    /* Get unicast dbuffs thresholds */
    pfc_threshold->xoff_threshold = data_rate_class.fc_queue_size[soc_tmcvsq_type].set;
    pfc_threshold->xon_threshold = data_rate_class.fc_queue_size[soc_tmcvsq_type].clear;

    /* Get bds thresholds */
    pfc_threshold->xoff_threshold_bd = data_rate_class.fc_bd_size[soc_tmcvsq_type].set;
    pfc_threshold->xon_threshold_bd = data_rate_class.fc_bd_size[soc_tmcvsq_type].clear;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_vsq_gl_fc_threshold_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_FC_TH fc_info,exact_fc_info;
    uint32 relevant_flags, threshold_type_flags, soc_sand_rc;
    int flag_count;       

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);
    SOC_TMC_ITM_GLOB_RCS_FC_TH_clear(&exact_fc_info);

    /* Validate flags */
    relevant_flags = flags & (BCM_COSQ_THRESHOLD_UNICAST |
                              BCM_COSQ_THRESHOLD_MULTICAST);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* basic consistency checks */
    threshold_type_flags = (flags & 
                           (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_MULTICAST));

    flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (flag_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag can be set"), unit, threshold_type_flags));
    }

    /* Validate params */
    if (cosq != BCM_COSQ_HIGH_PRIORITY && cosq != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }
        
    /* Retreive information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_get,(unit,&fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
         
    if ((flags & BCM_COSQ_THRESHOLD_UNICAST)) {
        /* Set unicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.unicast,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold );
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.unicast,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold );
    }

    if ((flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        /* Set full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.full_mc,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold );
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.full_mc,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold );
    }

    /* Set bdbs thresholds */
    DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.bdbs,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold_bd);
    DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.bdbs,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold_bd);

    /* Set information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_set,(unit,&fc_info,&exact_fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_fc_threshold_get(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_FC_TH fc_info;
    uint32 relevant_flags, soc_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(pfc_threshold);

    /* Validate flags */
    relevant_flags = flags & (BCM_COSQ_THRESHOLD_UNICAST |
                              BCM_COSQ_THRESHOLD_MULTICAST);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* Validate params */
    if (cosq != BCM_COSQ_HIGH_PRIORITY && cosq != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }
        
    SOC_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);

    /* Retreive information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_get,(unit,&fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
         
    if ((flags & BCM_COSQ_THRESHOLD_UNICAST)) {
        /* Get unicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.unicast);
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.unicast);
    }

    if ((flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        /* Get full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.full_mc);
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.full_mc);
    }

    /* Get bdbs thresholds */
    DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold_bd,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.bdbs);
    DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold_bd,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.bdbs);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int bcm_petra_cosq_gport_vsq_create(
    int unit, 
    bcm_cosq_vsq_info_t *vsq_info, 
    bcm_gport_t *vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_count, vsq_type_flags;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;    


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    BCMDNX_NULL_CHECK(vsq_info);
    BCMDNX_NULL_CHECK(vsq_gport);

    /* basic consistency checks */
    vsq_type_flags = (vsq_info->flags & 
                           (BCM_COSQ_VSQ_GL | BCM_COSQ_VSQ_CT |
                            BCM_COSQ_VSQ_CTTC | BCM_COSQ_VSQ_CTCC |
                            BCM_COSQ_VSQ_PP | BCM_COSQ_VSQ_LLFC | BCM_COSQ_VSQ_PFC));

    vsq_count = _bcm_cosq_bit_count_get(vsq_type_flags);
    if (vsq_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq flags 0x%x - only one vsq can be allocated, number resources specified %d"), unit, vsq_type_flags, vsq_count));
    }

    if (vsq_count == 0) {
        /* No information required */
        BCM_EXIT;
    }

    /* Validate VSQ Info */
    rc = _bcm_petra_cosq_vsq_info_verify(unit,vsq_info);
    BCMDNX_IF_ERR_EXIT(rc);
        
    /* Retreive VSQ group */
    rc = _bcm_petra_cosq_gport_vsq_get_group_type(unit,vsq_info,&vsq_group_type);
    BCMDNX_IF_ERR_EXIT(rc);

#ifdef  BCM_PETRAB_SUPPORT
    if (SOC_IS_PETRAB(unit)) {        

        uint8 enable;  
        uint32 soc_sand_rc;      

        unit =  (unit);

        /* VSQ PFC: On Creating new VSQ PFC, make sure VSQ PFC binding is enabled. */
        if (
            (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PFC || vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_LLFC))
        {          
          soc_sand_rc = soc_pb_fc_vsq_by_incoming_nif_get(unit,&enable);
          BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
          if (enable == FALSE)
          {
            soc_sand_rc = soc_pb_fc_vsq_by_incoming_nif_set(unit,TRUE);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
          }
        }
    }
#endif /* BCM_PETRAB_SUPPORT */

    

    /* Set VSQ gport */
    rc = _bcm_petra_cosq_gport_vsq_gport_set(unit,vsq_info,vsq_group_type,vsq_gport);
    BCMDNX_IF_ERR_EXIT(rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_destroy(
    int unit, 
    bcm_gport_t vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    bcm_dpp_cosq_vsq_rate_class_info_t vsq_rate_class_info,exact_vsq_rate_class_info;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0; 
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    int new_rate_class,is_allocated,old_rate_class,is_last;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    
     
    /* 1. Remove WRED and tail drop settings */
    sal_memset(&vsq_rate_class_info,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));

    if (!BCM_COSQ_GPORT_IS_VSQ(vsq_gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport type")));
    }

    /* Retreive VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit,vsq_gport,&vsq_group_type,&vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);
        
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTCC || vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTTC
        || vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTGRY || vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PP)         
    {
          rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
          BCMDNX_IF_ERR_EXIT(rc);

          soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_group2global,( soc_tmcvsq_type, vsq_index, &vsq_id)));
          BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
  
          rc = _bcm_dpp_am_template_vsq_rate_cls_exchange(unit,vsq_id,&vsq_rate_class_info,&old_rate_class,&is_last,&new_rate_class,&is_allocated);
          BCMDNX_IF_ERR_EXIT(rc);
  
          if (is_allocated) {
              /* Set new profile data */
              rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit,new_rate_class,&vsq_rate_class_info,&exact_vsq_rate_class_info);
              BCMDNX_IF_ERR_EXIT(rc);        
          }
  
          /* Set new mapping */
          soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_qt_rt_cls_set,(unit, soc_tmcvsq_type, vsq_index, new_rate_class)));
          BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
  
          if (is_last && new_rate_class != old_rate_class) {
              /* clear profile data */
              sal_memset(&vsq_rate_class_info,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
              rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit,old_rate_class,&vsq_rate_class_info,&exact_vsq_rate_class_info);
              BCMDNX_IF_ERR_EXIT(rc);        
          }

#ifdef BCM_WARM_BOOT_SUPPORT
          rc = _bcm_dpp_wb_cosq_update_vsq_rate_class_data(unit, 0, old_rate_class, new_rate_class);
          BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    }    
       
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Following are the symantics of this call
 *    - sched_port => parent element
 *    - input_port => child element
 *    - cosq       => child element cosq
 */
int
bcm_petra_cosq_gport_attach(int unit,
                            bcm_gport_t sched_port,
                            bcm_gport_t input_port,
                            bcm_cos_queue_t cosq)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t        child_info, parent_info;
    int                              child_mode = 0, flow_id_index;
    bcm_dpp_cosq_class_info_t        info;
    int                              weight = 0, updated_type;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    SOC_TMC_SCH_FLOW                     exact_flow_config;
    uint32                           soc_sand_rc;    
    bcm_gport_t                      parent_port;
    bcm_dpp_cosq_flow_config_t      *flow_state_config;
    int                              is_parent_reserved_res = FALSE;
    int                              parent_se_port, dummy_tc;
    bcm_dpp_cosq_se_config_t        *se_state_config = NULL;
    bcm_dpp_cosq_config_t           *cosq_config;

    
    BCMDNX_INIT_FUNC_DEFS;
    _BCM_DPP_SWITCH_API_START(unit);

    cosq_config = &_dpp_cosq_config[unit];    
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    parent_info.flow_config = NULL;
    parent_info.se_config = NULL;
    child_info.flow_config = NULL;
    child_info.se_config = NULL;
    BCMDNX_ALLOC(parent_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(child_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(child_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (parent_info.flow_config == NULL) || (parent_info.se_config == NULL) ||
             (child_info.flow_config == NULL) || (child_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, sched_port, &parent_port);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* 
     * Note: API does not support parent of type Port-TC. User that wants
     * to attach Port-TC object. Call first handle_get and receieve scheduler gport.
     */
    if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(parent_port)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, API does not support Port-TC obejects gport: 0x%x \n"), unit, parent_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* Validate parent and child elements are not exact. In that case we cant attach parent to input when parent = input */
    if (parent_port == input_port) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, attach cant be done when parent 0x%x equals input port 0x%x\n"), unit, parent_port,input_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* validate parent element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, parent_port, -1, dpp_device_cosq_gport_parent_element, &parent_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* validate child element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, input_port, cosq, dpp_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* make sure the parent is a SE */
    if ( !(parent_info.is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, sched_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if parent scheduler element is a reserved resource       */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    if (parent_info.is_se) {
        rc = _bcm_petra_cosq_se_id2port(unit,parent_info.se_id,&parent_se_port, &dummy_tc);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving port id from SE %d, error 0x%x\n"), unit, parent_info.se_id, rc));
            goto err;
        }
    }
    if ( (parent_info.is_se) &&
                        ( (parent_se_port != DPP_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (parent_info.se_id == cosq_config->default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }

    if (is_parent_reserved_res == FALSE) {
        se_state_config = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_get(unit,
                                         &(cosq_config->se_hd), (parent_info.se_config)->id);
        if (se_state_config ==  NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) parent SE(%d) state not available\n"),
                                  unit, (parent_info.se_config)->id));
            rc = BCM_E_RESOURCE;
            goto err;
        }
    }

   flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_get(unit,
                                             &(_dpp_cosq_config[unit].flow_hd),
                                             child_info.actual_flow_id);
    
    if (flow_state_config ==  NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) flow_id(%d) sched set flow internal state retrieve error\n"),
                              unit, child_info.flow_id));
        BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
    }
    child_mode = flow_state_config->mode;


    /* get parent element information for child hookup corresponding to child scheduling mode */
    rc = _bcm_petra_cosq_credit_class_info_get(unit, parent_info.se_config, child_mode, &info);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving parent info corresponding to child element scheduling mode, error 0x%x\n"), unit, rc));
        goto err;
    }

    /* retrieve child element weight */
    weight = flow_state_config->weight;
   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "Unit(%d) flow_id(%d), Weight(%d)\n"),
                         unit, child_info.actual_flow_id, weight));
    
    weight = (info.weight_mode == SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW) ? weight :
                       ((info.weight_mode == SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST) ? 0 : weight);

    rc = _bcm_petra_cosq_credit_class_weight_validate(unit, weight, &info, &updated_type);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in adjusting flow type for weight/weight mode, error 0x%x\n"), unit, rc));
        goto err;
    }

    /* hookup hierarchy */
    flow_id_index = (child_info.is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info.flow_config->sub_flow[flow_id_index].credit_source);

    cs_info->se_type = parent_info.se_config->type;
    cs_info->id = parent_info.se_config->id;
    switch (cs_info->se_type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            cs_info->se_info.hr.sp_class = updated_type;
            cs_info->se_info.hr.weight = weight;
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:
            cs_info->se_info.cl.sp_class = updated_type;
            cs_info->se_info.cl.weight = weight;
            break;

        default:
            break;
    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, child_info.flow_id, child_info.flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, child_info.flow_id, soc_sand_rc, rc));
         goto err;
    }

    if(!child_info.is_connector) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_group_set,(unit, child_info.se_id, child_info.se_config, child_info.flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting se %d group, soc_sand error 0x%x, error 0x%x\n"), unit, child_info.se_id, soc_sand_rc, rc));
             goto err;
        }
    }

    /* increment reference count of parent */
    if (is_parent_reserved_res == FALSE) {
        se_state_config->ref_cnt++;
#ifdef BCM_WARM_BOOT_SUPPORT 
        rc = _bcm_dpp_wb_cosq_update_se_state(unit, parent_info.se_id, se_state_config->ref_cnt);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed update of seId(%d) ref , error 0x%x\n"), unit, parent_info.se_id, rc));
        }
#endif /* BCM_WARM_BOOT_SUPPORT */
    }

   BCM_FREE(parent_info.flow_config);
   BCM_FREE(parent_info.se_config);
   BCM_FREE(child_info.flow_config);
   BCM_FREE(child_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (parent_info.flow_config != NULL) 
       BCM_FREE(parent_info.flow_config);
    if (parent_info.se_config != NULL)
       BCM_FREE(parent_info.se_config);
    if (child_info.flow_config != NULL)
       BCM_FREE(child_info.flow_config);
    if (child_info.se_config != NULL)
       BCM_FREE(child_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_detach(int unit,
                            bcm_gport_t sched_port,
                            bcm_gport_t input_port,
                            bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    /* consistency checks */
    if (!(BCM_COSQ_GPORT_IS_E2E_PORT(sched_port) || BCM_GPORT_IS_SCHEDULER(sched_port) ||
          BCM_COSQ_GPORT_IS_SCHED_CIR(sched_port) || BCM_COSQ_GPORT_IS_SCHED_PIR(sched_port))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected parent gport type, 0x%x"), sched_port));
    }

    if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(input_port) ||
          BCM_COSQ_GPORT_IS_COMPOSITE_SF2(input_port) || BCM_GPORT_IS_SCHEDULER(input_port) ||
          BCM_COSQ_GPORT_IS_SCHED_CIR(input_port) || BCM_COSQ_GPORT_IS_SCHED_PIR(input_port))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected child gport type, 0x%x"), input_port));
    }


    rc = _bcm_petra_cosq_sched_connector_gport_detach(unit, sched_port, input_port, cosq);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_parent_get(int unit,
                                    bcm_gport_t child_port,
                                    bcm_cos_queue_t cos,
                                    bcm_gport_t *parent_port)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t        child_info, parent_info;
    int                              flow_id_index;
    int                              flow_id, base_flow_id;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE   *cs_info;
    SOC_TMC_SCH_SE_ID                    se_id;
    bcm_dpp_cosq_se_config_t         *se_state_config;
    bcm_dpp_cosq_config_t            *cosq_config;
    int                              is_parent_reserved_res = FALSE;
    int                              parent_se_port, tc;
    bcm_gport_t                      parent_tmp, fap_port;
    
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&child_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));
    sal_memset(&parent_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    child_info.flow_config = NULL;
    child_info.se_config = NULL;
    parent_info.flow_config = NULL;
    parent_info.se_config = NULL;

    cosq_config = &_dpp_cosq_config[unit];
    
    BCMDNX_ALLOC(child_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(child_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(parent_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (parent_info.flow_config == NULL) || (parent_info.se_config == NULL) ||
             (child_info.flow_config == NULL) || (child_info.se_config == NULL)) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* validate child element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, child_port, cos, dpp_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* Retrevie hierarchy parent */
    flow_id_index = (child_info.is_sf2 == TRUE) ? 1 : 0;  
    cs_info = &(child_info.flow_config->sub_flow[flow_id_index].credit_source);

    se_id = cs_info->id;
    flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));

    /* Verify parent */
    se_state_config = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_get(unit,
                                         &(cosq_config->se_hd), se_id);
    if (se_state_config ==  NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) parent SE(%d) state not available\n"),
                              unit, se_id));
        rc = BCM_E_RESOURCE;
        goto err;
    }

    /* Retreive scheduler information */
    BCM_GPORT_SCHEDULER_SET(parent_tmp,flow_id);

    rc = _bcm_petra_cosq_gport_validate_info_get(unit, parent_tmp, 0, dpp_device_cosq_gport_sched_nocirpir_ds_element, &parent_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* Get port id in case SE is parent */
    rc = _bcm_petra_cosq_se_id2port(unit, se_id, &parent_se_port, &tc);
    if (rc != BCM_E_NONE) {
      LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, Error retreving port id from SE %d\n"), unit,se_id));          
      goto err;
    } 

    /* Validate SE is parent */
    if ( ( (parent_se_port != DPP_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (se_id == cosq_config->default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }

    /* In case SE is not parent: validate someone is referenced to it */
    if ((!is_parent_reserved_res) && se_state_config->ref_cnt <= DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Parent SE(%d) reference count is 0\n"),
                              unit, se_id));
        rc = BCM_E_INTERNAL;
        goto err;
    }

    /* Default se is not attached to anyone */
    if (cs_info->id == cosq_config->default_se) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) not attached\n"), unit, cs_info->id));
        rc = BCM_E_PARAM;
        goto err;
    }


    /* In case SE is parent return different gport */
    if (!is_parent_reserved_res) {
        /* Validated parent scheduler. Set parent gport */
        flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
        if (parent_info.is_dual == FALSE) {
            /* Non dual, just set scheduler gport */
            BCM_GPORT_SCHEDULER_SET((*parent_port), flow_id);
        } else {
            /* return base flow id with either CIR gport (CL) or PIR gport (FQ) */
            base_flow_id = (flow_id - (flow_id & 0x3)); 
            if ( (parent_info.se_config->type == SOC_TMC_SCH_SE_TYPE_FQ) ||
                   (parent_info.se_config->type == SOC_TMC_SCH_SE_TYPE_HR) ) {
                BCM_COSQ_GPORT_SCHED_PIR_SET((*parent_port), base_flow_id);
            } else if (parent_info.se_config->type == SOC_TMC_SCH_SE_TYPE_CL) {
                BCM_COSQ_GPORT_SCHED_CIR_SET((*parent_port),base_flow_id);
            }
        }
    } else {
        /* Set parent gport to be Port gport */
        if (tc == DPP_COSQ_PB_DEFAULT_PORT_TC) {
            /* In case of TC = 0 or Petra-B compatible TC returns E2E */
            rc = bcm_petra_tm_port_get(unit, parent_se_port, &fap_port);
            if (rc != BCM_E_NONE) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, Error retreving port id from SE %d\n"), unit,parent_se_port));          
              goto err;
            }
            BCM_COSQ_GPORT_E2E_PORT_SET(*parent_port, fap_port);
        } else {
            /* In case of Port-TC return SCHEDULER gport */
            flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
            BCM_GPORT_SCHEDULER_SET((*parent_port), flow_id);  
        }
    }   

    BCM_FREE(child_info.flow_config);
    BCM_FREE(child_info.se_config);
    BCM_FREE(parent_info.flow_config);
    BCM_FREE(parent_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (child_info.flow_config != NULL)
       BCM_FREE(child_info.flow_config);
    if (child_info.se_config != NULL)
       BCM_FREE(child_info.se_config);
    if (parent_info.flow_config != NULL)
       BCM_FREE(parent_info.flow_config);
    if (parent_info.se_config != NULL)
       BCM_FREE(parent_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_link_fc_shaper_verify(int unit,
                                   bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (cosq != 0)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid cosq parameter 0x%x\n"), unit, cosq));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
 

int
_bcm_petra_link_fc_shaper_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    uint32 soc_sand_rc;
    bcm_error_t rc = BCM_E_NONE;
    uint32 link_ndx;
    SOC_TMC_FABRIC_FC_SHAPER info;
    SOC_TMC_FABRIC_FC_SHAPER_MODE_INFO shaper;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_FABRIC_FC_SHAPER_MODE_INFO_clear(&shaper); 
    SOC_TMC_FABRIC_FC_SHAPER_clear(&info);
    
    link_ndx = SOC_DPP_FABRIC_PORT_TO_LINK(unit, gport);

    _bcm_petra_link_fc_shaper_verify(unit, cosq);  
    BCMDNX_IF_ERR_EXIT(rc);        

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_shaper_get,(unit, link_ndx, &shaper, &info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get link %d flow control shaper parameters, soc_sand error 0x%x\n"), unit, link_ndx, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }  
        
    if (*flags & BCM_COSQ_BW_LLFC)
    {
        /* LLFC shaper */
        if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_BYTES_MODE) {
            *kbits_sec_max = info.fc_shaper.bytes;
            *kbits_sec_min = 0;
        }    
        /* Currently cell mode is not supported */
        if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_CELLS_MODE) {
            *kbits_sec_max = info.fc_shaper.cells;
            *kbits_sec_min = 0;            
        }
    }
    else
    {
        /* Data shaper */
        if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_BYTES_MODE) {
            *kbits_sec_max = info.data_shaper.bytes;
            *kbits_sec_min = 0;
        }
        /* Currently cell mode is not supported */
        if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_CELLS_MODE) {
            *kbits_sec_max = info.data_shaper.cells;
            *kbits_sec_min = 0;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_link_fc_shaper_add(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 kbits_sec_min,
                                   uint32 kbits_sec_max,
                                   uint32 flags)
{
    uint32 soc_sand_rc;
    bcm_error_t rc = BCM_E_NONE;
    uint32 link_ndx;
    SOC_TMC_FABRIC_FC_SHAPER info;
    SOC_TMC_FABRIC_FC_SHAPER exact_info;
    SOC_TMC_FABRIC_FC_SHAPER_MODE_INFO shaper;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_FABRIC_FC_SHAPER_MODE_INFO_clear(&shaper);
    SOC_TMC_FABRIC_FC_SHAPER_clear(&info);
    SOC_TMC_FABRIC_FC_SHAPER_clear(&exact_info);

    link_ndx = SOC_DPP_FABRIC_PORT_TO_LINK(unit, gport);

    _bcm_petra_link_fc_shaper_verify(unit, cosq);
    BCMDNX_IF_ERR_EXIT(rc);        

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_shaper_get,(unit, link_ndx, &shaper, &info)));
    
    if(SOC_SAND_FAILURE(soc_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get link %d flow control shaper parameters, soc_sand error 0x%x\n"), unit, link_ndx, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }    

    if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_BYTES_MODE) 
    {
        if (flags & BCM_COSQ_BW_LLFC) 
        {
            info.fc_shaper.bytes = kbits_sec_max;
        } 
        else 
        {
            info.data_shaper.bytes = kbits_sec_max;
        }
    }
    /* Currently shaper cell mode is not supported */
    if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_CELLS_MODE) 
    {        
        if (flags & BCM_COSQ_BW_LLFC) 
        {
            info.fc_shaper.cells = kbits_sec_max;
        } 
        else
        {
            info.data_shaper.cells = kbits_sec_max;
        }
    }
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_shaper_set,(unit, link_ndx, &shaper, &info, &exact_info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
       LOG_ERROR(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit %d, failed to set link %d flow control shaper parameters, soc_sand error 0x%x\n"), unit, link_ndx, soc_sand_rc));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_egress_port_scheduler_pps_to_kbps(int unit, int core, uint32 pps, uint32 *kbps)
{
    uint32 num_of_bytes_per_packet;

    BCMDNX_INIT_FUNC_DEFS;

    /* get num of bytes per packet */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_packet_mode_packet_size_get,(unit, core, &num_of_bytes_per_packet)));

    *kbps = pps*num_of_bytes_per_packet*8/1000;

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_egress_port_scheduler_kbps_to_pps(int unit, int core, uint32 kbps, uint32 *pps)
{
    uint32 num_of_bytes_per_packet;

    BCMDNX_INIT_FUNC_DEFS;

    /* get num of bytes per packet */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_packet_mode_packet_size_get,(unit, core, &num_of_bytes_per_packet)));

    *pps = (kbps*1000)/(8*num_of_bytes_per_packet);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_bandwidth_set(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 kbits_sec_min,
                                   uint32 kbits_sec_max,
                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_port_t port;
    bcm_gport_t parent_port;
        
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit); 

    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport, &parent_port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* link shaper configuration */
    if (!BCM_GPORT_IS_SET(gport) && SOC_PORT_VALID(unit, gport) && IS_SFI_PORT(unit,gport)) {       
        rc =  _bcm_petra_link_fc_shaper_add(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        BCMDNX_IF_ERR_EXIT(rc);
    } 
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(parent_port) 
        || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(parent_port)
        || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(parent_port)) {
        rc = _bcm_petra_cosq_gport_fmq_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    } 
    else if (BCM_COSQ_GPORT_IS_ISQ_ROOT(gport)) {
      rc = _bcm_petra_cosq_gport_isq_bandwidth_set(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }    
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_set(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_set(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    /* E2E scheduler */
    else if ((BCM_GPORT_IS_SCHEDULER(parent_port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(parent_port))) {   
        rc = _bcm_petra_cosq_gport_flow_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(parent_port)) {

        port = BCM_COSQ_GPORT_E2E_PORT_GET(parent_port);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            rc = _bcm_petra_cosq_gport_e2e_interface_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            rc = _bcm_petra_cosq_gport_e2e_port_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(parent_port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_e2e_port_tc_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(parent_port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }

    /* Egress transmit scheduler */

    else if (BCM_GPORT_IS_LOCAL(parent_port) || BCM_GPORT_IS_MODPORT(parent_port)) {
        if (BCM_GPORT_IS_LOCAL(parent_port)) {
            port = BCM_GPORT_LOCAL_GET(parent_port);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(parent_port);
        }        


        if (BCM_DPP_PORT_IS_INTERFACE(port)) {        
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            /* Egress scheduler port */
            rc = _bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);           
        }
    } 
    else if (BCM_COSQ_GPORT_IS_PORT_TC(parent_port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tc_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(parent_port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tcg_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }

    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, gport(0x%08x) not supported \n"), unit, gport));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int port = 0;
    bcm_gport_t res_gport;
    

    BCMDNX_INIT_FUNC_DEFS;

    /* determine if gport refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport, &res_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Link shaper configuration */
    if (!BCM_GPORT_IS_SET(gport) && SOC_PORT_VALID(unit, gport) && IS_SFI_PORT(unit,gport)) {
        rc =  _bcm_petra_link_fc_shaper_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        BCMDNX_IF_ERR_EXIT(rc);
    }  

    /* Egress transmit scheduler */
    else if (BCM_GPORT_IS_LOCAL(res_gport) ||
         BCM_GPORT_IS_MODPORT(res_gport)) {

        if (BCM_GPORT_IS_LOCAL(res_gport)) {
            port = BCM_GPORT_LOCAL_GET(res_gport);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(res_gport);
        }        
        
        if (BCM_DPP_PORT_IS_INTERFACE(port)) {  
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            /* Egress scheduler port */
            rc = _bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }   

    else if (BCM_COSQ_GPORT_IS_PORT_TC(res_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tc_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(res_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tcg_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
        rc = _bcm_petra_cosq_gport_fmq_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    } 
    else if (BCM_COSQ_GPORT_IS_ISQ_ROOT(gport)) {
        rc = _bcm_petra_cosq_gport_isq_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    
    /* Ingress Scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_get(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_get(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }

    /* E2E scheduler */
    else if ( (BCM_GPORT_IS_SCHEDULER(res_gport)) ||
              (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_PIR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(res_gport)) ) {
            rc = _bcm_petra_cosq_gport_flow_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(res_gport)) {

        port = BCM_COSQ_GPORT_E2E_PORT_GET(res_gport);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            rc = _bcm_petra_cosq_gport_e2e_interface_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            rc = _bcm_petra_cosq_gport_e2e_port_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(res_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_e2e_port_tc_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(res_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, gport(0x%08x) not supported \n"), unit, gport));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_size_set(int unit,
                        bcm_gport_t gport,
                        bcm_cos_queue_t cosq,
                        uint32 bytes_min,
                        uint32 bytes_max)
{
    bcm_error_t rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_size_get(int unit,
                        bcm_gport_t gport,
                        bcm_cos_queue_t cosq,
                        uint32 *bytes_min,
                        uint32 *bytes_max)
{
    bcm_error_t rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_color_size_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    bcm_color_t color,
                                    uint32 flags,
                                    bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport)) {
            rc = _bcm_petra_cosq_gport_voq_color_size_get(unit, gport, cosq, color, flags, gport_size);
    }   
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
            rc = _bcm_petra_cosq_gport_vsq_color_size_get(unit, gport, cosq, color, flags, gport_size);
    }
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && BCM_GPORT_IS_PROFILE(gport)) {
            rc = _bcm_petra_cosq_gport_rate_class_color_size_get(unit,gport,color,flags,gport_size);
    }
#endif /*BCM_ARAD_SUPPORT*/
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_color_size_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    bcm_color_t color,
                                    uint32 flags,
                                    bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport)) {
            rc = _bcm_petra_cosq_gport_voq_color_size_set(unit, gport, cosq, color, flags, gport_size);
    }
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
            rc = _bcm_petra_cosq_gport_vsq_color_size_set(unit, gport, cosq, color, flags, gport_size);
    } 
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && BCM_GPORT_IS_PROFILE(gport)) {
        rc = _bcm_petra_cosq_gport_rate_class_color_size_set(unit,gport,color,flags,gport_size);
    }
#endif /*BCM_ARAD_SUPPORT*/
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_PORT;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) ) {
        rc = _bcm_petra_cosq_gport_voq_discard_set(unit, gport, cosq, discard);
    }
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        rc = _bcm_petra_cosq_gport_vsq_discard_set(unit, gport, cosq, discard);
    }
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && BCM_GPORT_IS_PROFILE(gport)) { 
        rc = _bcm_petra_cosq_gport_rate_class_discard_set(unit, gport, discard);
    }
#endif /*BCM_ARAD_SUPPORT*/
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_PORT;

    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        rc = _bcm_petra_cosq_gport_voq_discard_get(unit, gport, cosq, discard);
    }

    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        rc = _bcm_petra_cosq_gport_vsq_discard_get(unit, gport, cosq, discard);
    } 
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit) && BCM_GPORT_IS_PROFILE(gport)) { 
        rc = _bcm_petra_cosq_gport_rate_class_discard_get(unit, gport, discard);
    }
#endif /*BCM_ARAD_SUPPORT*/
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_threshold_set(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

#ifdef BCM_ARAD_SUPPORT 
    uint8   traffic_en = 0;
    uint32  soc_sand_rc = SOC_SAND_OK;
#endif
    bcm_port_t port = 0;
    uint32 nif_id;
    SOC_TMC_FC_PORT_FIFO_TH fc_fifo_th;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    BCMDNX_NULL_CHECK(threshold);
    /* Ingress tresholds */
    if (threshold-> flags & BCM_COSQ_THRESHOLD_INGRESS) {
        if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
            int vsq_type;
            
            vsq_type = BCM_COSQ_GPORT_VSQ_TYPE_GET(gport);
            if (vsq_type ==  BCM_COSQ_VSQ_GL) {
                if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flag BCM_COSQ_THRESHOLD_NOT_COMMIT is not supported. flags 0x%x"), unit,threshold->flags));
                }
                        
                /* Drop Threshold set */
                if (threshold->flags & BCM_COSQ_THRESHOLD_DROP) { 
                    /* VSQ gl tail drop thresholds */
                    rc = _bcm_petra_cosq_vsq_gl_drop_threshold_set(unit, gport, cosq, threshold);    
                    BCMDNX_IF_ERR_EXIT(rc);                
                }

                /* Flow control set */
                if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {                    
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported global flow control. use pfc config set instead 0x%x"), unit,gport));
                }
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported vsq gport type 0x%x"), unit,vsq_type));
            }        
        } else if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)){
            if((!SOC_IS_PETRAB(unit)) && (threshold->flags & (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_OCB))){
                rc = _bcm_petra_cosq_voq_ocb_threshold_set(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);
            }
#ifdef BCM_ARAD_SUPPORT
        } else if (SOC_IS_ARAD(unit) && BCM_GPORT_IS_PROFILE(gport)) { 
            rc = _bcm_petra_cosq_rate_class_ocb_threshold_set(unit,gport,cosq,threshold);
            BCMDNX_IF_ERR_EXIT(rc);
#endif /*BCM_ARAD_SUPPORT*/
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport for ingress thresholds 0x%x"), unit,gport));
        }
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Egress configuration */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_EGRESS) {
        
        if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid flags %d"), unit ,threshold->flags));
        }

#ifdef BCM_ARAD_SUPPORT 
        if(SOC_IS_ARAD(unit))
        {
          /* Traffic Enabled Restriction */
          if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors ||
             threshold->type == bcmCosqThresholdAvailableDataBuffers)
          {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_enable_traffic_get,(unit, &traffic_en)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            if(traffic_en == TRUE)
            {
              /* Check the override flag for allowing modifications during traffic */
              if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "allow_modifications_during_traffic", 0) == 0)
              {
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, changing thresholds of %d is not allowed while traffic is enabled"), 
                                                  unit ,threshold->type));
              }
            }
          }
        }
#endif

        /* Drop Threshold set */
        if (threshold->flags & BCM_COSQ_THRESHOLD_DROP) { 
            /* null gport equals 0 */
            if (gport == 0) {
                if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
                    if(cosq != -1 ) {
                        /* Device wide flow control sheduled threshold */
                        rc = _bcm_petra_cosq_gport_egress_device_uc_tc_drop_threshold_set(unit, gport, cosq, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        if(!SOC_IS_PETRAB(unit)) {
                            rc = _bcm_petra_cosq_gport_egress_device_uc_drop_threshold_set(unit, gport, cosq, threshold);
                            BCMDNX_IF_ERR_EXIT(rc);
                        }
                        else
                        {
                            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d are Unsupported for Petra-B"), unit ,gport, threshold->flags));
                        }
                    }
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
                    if(cosq != -1){
                        /* Device wide flow control mci threshold */
                        rc = _bcm_petra_cosq_gport_egress_device_mc_tc_drop_threshold_set(unit, gport, cosq, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        if(!SOC_IS_PETRAB(unit)) {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_drop_threshold_set(unit, gport, cosq, threshold);
                            BCMDNX_IF_ERR_EXIT(rc);
                        }
                        else
                        {
                            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x),flags %d, flag multicast and cosq == -1 setting is not supported for Petra-B"), unit ,gport, threshold->flags));
                        }
                    }
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) {
                    if(!SOC_IS_PETRAB(unit)) {
                        if(cosq == -1 ) {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_sp0_drop_threshold_set(unit, gport, cosq, threshold);
                        }
                        else
                        {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_sp0_tc_drop_threshold_set(unit, gport, cosq, threshold);
                        }
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x),flags %d, SP0-1 is not supported for Petra-B"), unit ,gport, threshold->flags));
                    }
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1) {
                    if(!SOC_IS_PETRAB(unit)) {
                        if(cosq == -1) {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_sp1_drop_threshold_set(unit, gport, cosq, threshold);
                        }
                        else
                        {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_sp1_tc_drop_threshold_set(unit, gport, cosq, threshold);
                        }
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x),flags %d, SP0-1 is not supported for Petra-B"), unit ,gport, threshold->flags));
                    }
                }
                else 
                { /* i.e. set all */
                    if(cosq == -1  && !SOC_IS_PETRAB(unit)) {
                        rc = _bcm_petra_cosq_gport_egress_device_all_drop_threshold_set(unit, gport, cosq, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d are not supported for Petra-B"), unit ,gport, threshold->flags));
                    }
                } 
            /* Egress UC Queue drop thresholds */
            } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                rc = _bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_set(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);
            /* Egress MC Queue drop thresholds*/
            } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
                rc = _bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_set(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);
            } else {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_DROP \n"), unit));
            }
        }
    
        BCMDNX_IF_ERR_EXIT(rc);
    
        /* Flow control set */
        if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
            /* Egress device wide flow control */
            /* null gport equals 0 */
            if (gport == 0) {
                if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
                    /* Device wide flow control sheduled threshold */
                    rc = _bcm_petra_cosq_gport_egress_device_uc_fc_threshold_set(unit, gport, cosq, threshold);
                    BCMDNX_IF_ERR_EXIT(rc);
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
                    if (SOC_IS_PETRAB(unit)){
                        /* Device wide flow control mci threshold */
                        
                        rc = _bcm_petra_cosq_gport_egress_device_mci_threshold_set(unit, gport, cosq, threshold);
                    }
                    else{
                        /* Device wide flow control unscheduled threshold */
                        rc = _bcm_petra_cosq_gport_egress_device_mc_fc_threshold_set(unit, gport, cosq, threshold);
                    }
                    BCMDNX_IF_ERR_EXIT(rc);
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0){
                    /* Device wide flow control unscheduled threshold per service pool */
                    if(!SOC_IS_PETRAB(unit)) {
                        rc = _bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_set(unit, gport, cosq, 0, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d, SP0-1 is not supported for PetraB"), unit ,gport, threshold->flags));
                    }
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1){
                    /* Device wide flow control unscheduled threshold per service pool */
                    if(!SOC_IS_PETRAB(unit)){
                        rc = _bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_set(unit, gport, cosq, 1, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d, SP0-1 is not supported for PetraB"), unit ,gport, threshold->flags));
                    }
                }
                else {
                    /* Device wide flow control global threshold */
                    rc = _bcm_petra_cosq_gport_egress_device_global_fc_threshold_set(unit, gport, cosq, threshold);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
            /* Egress scheduler port, channelized issues: */
            else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
                if(SOC_IS_PETRAB(unit)) {
                    rc = _bcm_petra_cosq_gport_egress_chnif_fc_threshold_set(unit, gport, cosq, threshold);
                }
#ifdef BCM_ARAD_SUPPORT
                else
                {
                    bcm_port_t gport_lcl;
                    if (BCM_GPORT_IS_LOCAL(gport)) {
                        gport_lcl = BCM_GPORT_LOCAL_GET(gport);
                    } else {
                        gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
                    }        
                    if (BCM_DPP_PORT_IS_INTERFACE(gport_lcl)) {
                        bcm_gport_t interface_id = BCM_DPP_COSQ_PORT_ID_TO_INTERFACE_ID(gport_lcl);
                        /* Egress scheduler interface */
                        rc = _bcm_petra_cosq_gport_interface_egress_fc_threshold_set(unit, interface_id, cosq, threshold);
                    }
                    else
                    {
                        /* Egress scheduler port */
                    }
                }
#endif /* BCM_ARAD_SUPPORT */
                BCMDNX_IF_ERR_EXIT(rc);
            }
            /* Egress UC Queue fc thresholds */
            else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                rc = _bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_set(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            else {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_FLOW_CONTROL \n"), unit));
            }
        }
        BCMDNX_IF_ERR_EXIT(rc);  
    } else if (threshold->flags & BCM_COSQ_THRESHOLD_COLOR_SYSTEM_RED) {
        SOC_TMC_ITM_SYS_RED_GLOB_RCS_INFO info;

        SOC_TMC_ITM_SYS_RED_GLOB_RCS_INFO_clear(&info);

        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_glob_rcs_get,(unit, &info)));

        /* Set system RED Dbuff Thresholds/Values */
        if (threshold->type == bcmCosqThresholdDbuffs) {
            if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
                info.thresholds.unicast_rng_ths[0] = threshold->value;
                info.values.unicast_rng_vals[0]    = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
                info.thresholds.unicast_rng_ths[1] = threshold->value;
                info.values.unicast_rng_vals[1]    = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
                info.thresholds.unicast_rng_ths[2] = threshold->value;
                info.values.unicast_rng_vals[2]    = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
                info.values.unicast_rng_vals[3]    = threshold->dp;
            } else {
                /* Must use one of these flags */
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
            }
        } else if (threshold->type == bcmCosqThresholdFullDbuffs) {
            if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
                info.thresholds.multicast_rng_ths[0] = threshold->value;
                info.values.multicast_rng_vals[0]    = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
                info.thresholds.multicast_rng_ths[1] = threshold->value;
                info.values.multicast_rng_vals[1]    = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
                info.thresholds.multicast_rng_ths[2] = threshold->value;
                info.values.multicast_rng_vals[2]    = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
                info.values.multicast_rng_vals[3]    = threshold->dp;
            } else {
                /* Must use one of these flags */
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
            }
        } else if (threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
                info.thresholds.bds_rng_ths[0] = threshold->value;
                info.values.bds_rang_vals[0]   = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
                info.thresholds.bds_rng_ths[1] = threshold->value;
                info.values.bds_rang_vals[1]   = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
                info.thresholds.bds_rng_ths[2] = threshold->value;
                info.values.bds_rang_vals[2]   = threshold->dp;
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
                info.values.bds_rang_vals[3]   = threshold->dp;
            } else {
                /* Must use one of these flags */
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
            }
        } else {
            /* Must use one of these threshold type  */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter\n"), unit));
        } 

        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_glob_rcs_set,(unit, &info)));      
    } else if (threshold->flags & BCM_COSQ_THRESHOLD_RCI) {
        if (threshold->type == bcmCosqThresholdPackets) {
            if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_rci_threshold_set, 
                                          (unit, gport, threshold->value, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
            }
            else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_rci_threshold_set, 
                                          (unit, gport, threshold->value, soc_dpp_cosq_gport_egress_core_fifo_local_ucast));
            }
            else {
                /* Must use one of these gport types  */
                BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
            }
        }
    } else if (threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP)) {
        if (threshold->type == bcmCosqThresholdPackets) {
            soc_cosq_threshold_t soc_threshold;
            soc_threshold.value = threshold->value;
            soc_threshold.dp = threshold->dp;
            if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_set,
                                          (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
            }
            else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_set, 
                                          (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
            }
            else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_set, 
                                          (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
            }
            else {
                /* Must use one of these gport types  */
                BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
            }
        }
    } 
    else if (threshold->flags & (BCM_COSQ_THRESHOLD_ETH_PORT_LLFC | BCM_COSQ_THRESHOLD_ETH_PORT_PFC)) {
        if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
            if (BCM_GPORT_IS_LOCAL(gport)) {
                port = BCM_GPORT_LOCAL_GET(gport);
            } else {
                port = BCM_GPORT_MODPORT_PORT_GET(gport);
            }
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport(0x%x) for BCM_COSQ_THRESHOLD_ETH_PORT_LLFC/PFC"), unit, port));
        }

        rc = bcm_petra_cosq_port_nif_get(unit, port, &nif_id);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error retreiving nif_id for gport (0x%x)\n"), unit, port));
        }

        if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
        }

        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_port_fifo_threshold_get,(unit, nif_id, &fc_fifo_th)));

        if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) {
            /* set RX PORT FIFO Link Level Flow Control geneeration thresholds */
            if (threshold->flags & BCM_COSQ_THRESHOLD_SET) { 
                fc_fifo_th.llfc.set = threshold->value;
            }
            if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
                fc_fifo_th.llfc.clear = threshold->value;
            }
        }

        if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC) {
            /* set RX PORT FIFO Priority Flow Control geneeration thresholds */
            if (threshold->flags & BCM_COSQ_THRESHOLD_SET) { 
                fc_fifo_th.pfc.set = threshold->value;
            }
            if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
                fc_fifo_th.pfc.clear = threshold->value;
            }
        }


        /* Set information */
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_port_fifo_threshold_set, (unit, nif_id, &fc_fifo_th)));
    }
	else 
    {/* i.e. invalid parameter*/
        rc = BCM_E_PARAM;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_threshold_get(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_port_t port = 0;
    uint32 nif_id;
    SOC_TMC_FC_PORT_FIFO_TH fc_fifo_th;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    
    if (threshold-> flags & BCM_COSQ_THRESHOLD_INGRESS) {
        if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
            int vsq_type;
            
            vsq_type = BCM_COSQ_GPORT_VSQ_TYPE_GET(gport);
            if (vsq_type == BCM_COSQ_VSQ_GL) {
                if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported flags 0x%x"), unit,threshold->flags));
                }
                        
                /* Drop Threshold get */
                if (threshold->flags & BCM_COSQ_THRESHOLD_DROP) { 
                    /* VSQ gl tail drop thresholds */
                    rc = _bcm_petra_cosq_vsq_gl_drop_threshold_get(unit, gport, cosq, threshold);    
                    BCMDNX_IF_ERR_EXIT(rc);                
                }

                /* Flow control get */
                if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {                    
                    /* vsq gl flow control thresholds */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported thresholds sequence for gport 0x%x flags 0x%x, call pfc config API instead "), unit,gport,threshold->flags));
                }
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported vsq gport type 0x%x"), unit,gport));
            }        
        } else if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)){
            if((!SOC_IS_PETRAB(unit)) && (threshold->flags & (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_OCB))){
                rc = _bcm_petra_cosq_voq_ocb_threshold_get(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);
            } 
#ifdef BCM_ARAD_SUPPORT
        } else if (SOC_IS_ARAD(unit) && BCM_GPORT_IS_PROFILE(gport)) {
                rc = _bcm_petra_cosq_rate_class_ocb_threshold_get(unit,gport,cosq,threshold);
                BCMDNX_IF_ERR_EXIT(rc);
#endif /*BCM_ARAD_SUPPORT*/
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport for ingress thresholds 0x%x"), unit,gport));
        }
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Egress configuration */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_EGRESS) {
        /* Drop Threshold set */
        if (threshold->flags & BCM_COSQ_THRESHOLD_DROP) {             
            if (gport == 0) {
                if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
                    if(cosq != -1) {
                        /* Device wide flow control sheduled threshold */
                        rc = _bcm_petra_cosq_gport_egress_device_uc_tc_drop_threshold_get(unit, gport, cosq, threshold);
                    }
                    else
                    {
                        if(!SOC_IS_PETRAB(unit)) {
                            rc = _bcm_petra_cosq_gport_egress_device_uc_drop_threshold_get(unit, gport, cosq, threshold);
                            BCMDNX_IF_ERR_EXIT(rc);
                        }
                        else
                        {
                            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d , unicast flag set and cosq == -1 is not supported for Petra-B"), unit ,gport, threshold->flags));
                        }
                    }
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
                    if(cosq != -1) {
                        /* Device wide flow control mci threshold */
                        rc = _bcm_petra_cosq_gport_egress_device_mc_tc_drop_threshold_get(unit, gport, cosq, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        if(!SOC_IS_PETRAB(unit)) {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_drop_threshold_get(unit, gport, cosq, threshold);
                            BCMDNX_IF_ERR_EXIT(rc);
                        }
                        else
                        {
                            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d, multicast flag set and cosq == -1 is not supported for Petra-B"), unit ,gport, threshold->flags));
                        }
                    }
                } else if(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0){ 
                    if(!SOC_IS_PETRAB(unit)) {
                        if(cosq == -1 ) {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_sp0_drop_threshold_get(unit, gport, cosq, threshold);
                        }
                        else
                        {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_sp0_tc_drop_threshold_get(unit, gport, cosq, threshold);
                        }
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d are Unsupported for Petra-B"), unit ,gport, threshold->flags));
                    }
                } else if(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1){ 
                    if(!SOC_IS_PETRAB(unit)) {
                        if(cosq == -1 ) {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_sp1_drop_threshold_get(unit, gport, cosq, threshold);
                        }
                        else
                        {
                            rc = _bcm_petra_cosq_gport_egress_device_mc_sp1_tc_drop_threshold_get(unit, gport, cosq, threshold);
                        }
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d are Unsupported for Petra-B"), unit ,gport, threshold->flags));
                    }
                }
                else
                {/* i.e all*/ 
                    if(cosq == -1 && !SOC_IS_PETRAB(unit)) {
                        rc = _bcm_petra_cosq_gport_egress_device_all_drop_threshold_get(unit, gport, cosq, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d are Unsupported for Petra-B"), unit ,gport, threshold->flags));
                    }
                } 
            /* Egress UC Queue drop thresholds */
            } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                rc = _bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_get(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);            
            /* Egress MC Queue drop thresholds*/
            } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
                rc = _bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_get(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);
            } else {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_DROP \n"), unit));
            }
        }
    
        BCMDNX_IF_ERR_EXIT(rc);
    
        /* Flow control set */
        if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
            /* Egress device wide flow control */
            /* gport 0 equals gport null */
            if (gport == 0) {
                if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
                    /* Device wide flow control sheduled threshold */
                    rc = _bcm_petra_cosq_gport_egress_device_uc_fc_threshold_get(unit, gport, cosq, threshold);
                    BCMDNX_IF_ERR_EXIT(rc);
                } 
                else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
                    if (SOC_IS_PETRAB(unit)){
                        /* Device wide flow control mci threshold */
                        
                        rc = _bcm_petra_cosq_gport_egress_device_mci_threshold_get(unit, gport, cosq, threshold);
                    }
                    else
                    {
                        /* Device wide flow control unscheduled threshold */
                        rc = _bcm_petra_cosq_gport_egress_device_mc_fc_threshold_get(unit, gport, cosq, threshold);
                    }
                    BCMDNX_IF_ERR_EXIT(rc);
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0){
                    if(!SOC_IS_PETRAB(unit)) {
                        /* Device wide flow control unscheduled threshold per service pool */
                        rc = _bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_get(unit, gport, cosq, 0, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d are Unsupported for Petra-B"), unit ,gport, threshold->flags));
                    }
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1){
                    if(!SOC_IS_PETRAB(unit)) {
                        /* Device wide flow control unscheduled threshold per service pool */
                        rc = _bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_get(unit, gport, cosq, 1, threshold);
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    else
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport (0x%x) ,flags %d are Unsupported for Petra-B"), unit ,gport, threshold->flags));
                    }
                }       
                else {
                    /* Device wide flow control global threshold */
                    rc = _bcm_petra_cosq_gport_egress_device_global_fc_threshold_get(unit, gport, cosq, threshold);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
            /* Egress scheduler port, channelized issues */
            else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
                if(SOC_IS_PETRAB(unit)) {
                    rc = _bcm_petra_cosq_gport_egress_chnif_fc_threshold_get(unit, gport, cosq, threshold);
                }
#ifdef BCM_ARAD_SUPPORT
                else
                {
                    bcm_port_t gport_lcl;
                    if (BCM_GPORT_IS_LOCAL(gport)) {
                        gport_lcl = BCM_GPORT_LOCAL_GET(gport);
                    } else {
                        gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
                    }        
                    if (BCM_DPP_PORT_IS_INTERFACE(gport_lcl)) {
                        /* Egress scheduler interface */
                        bcm_gport_t interface_id = BCM_DPP_COSQ_PORT_ID_TO_INTERFACE_ID(gport_lcl);
                        rc = _bcm_petra_cosq_gport_interface_egress_fc_threshold_get(unit, interface_id, cosq, threshold);
                    }
                    else
                    {
                        /* Egress scheduler port */
                    }
                }
#endif /* BCM_ARAD_SUPPORT */
                BCMDNX_IF_ERR_EXIT(rc);
            }
            /* Egress UC Queue fc thresholds */
            else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                rc = _bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_get(unit, gport, cosq, threshold);
            }
            else {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_FLOW_CONTROL \n"), unit));
            }
        }  
        BCMDNX_IF_ERR_EXIT(rc);
    } else if (threshold->flags & BCM_COSQ_THRESHOLD_COLOR_SYSTEM_RED) {
        SOC_TMC_ITM_SYS_RED_GLOB_RCS_INFO info;

        SOC_TMC_ITM_SYS_RED_GLOB_RCS_INFO_clear(&info);

        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_glob_rcs_get,(unit, &info)));

        /* Set system RED Dbuff Thresholds/Values */
        if (threshold->type == bcmCosqThresholdDbuffs) {
            if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
                threshold->value = info.thresholds.unicast_rng_ths[0];
                threshold->dp    = info.values.unicast_rng_vals[0];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
                threshold->value = info.thresholds.unicast_rng_ths[1];
                threshold->dp    = info.values.unicast_rng_vals[1];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
                threshold->value = info.thresholds.unicast_rng_ths[2];
                threshold->dp    = info.values.unicast_rng_vals[2];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
                threshold->dp    = info.values.unicast_rng_vals[3];
            } else {
                /* Must use one of these flags */
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
            }
        } else if (threshold->type == bcmCosqThresholdFullDbuffs) {
            if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
                threshold->value = info.thresholds.multicast_rng_ths[0];
                threshold->dp    = info.values.multicast_rng_vals[0];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
                threshold->value = info.thresholds.multicast_rng_ths[1];
                threshold->dp    = info.values.multicast_rng_vals[1];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
                threshold->value = info.thresholds.multicast_rng_ths[2];
                threshold->dp    = info.values.multicast_rng_vals[2];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
                threshold->dp    = info.values.multicast_rng_vals[3];
            } else {
                /* Must use one of these flags */
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
            }
        } else if (threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {

            if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
                threshold->value = info.thresholds.bds_rng_ths[0];
                threshold->dp    = info.values.bds_rang_vals[0];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
                threshold->value = info.thresholds.bds_rng_ths[1];
                threshold->dp    = info.values.bds_rang_vals[1];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
                threshold->value = info.thresholds.bds_rng_ths[2];
                threshold->dp    = info.values.bds_rang_vals[2];
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
                threshold->dp    = info.values.bds_rang_vals[3];
            } else {
                /* Must use one of these flags */
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
            }
        } else {
            /* Must use one of these threshold type  */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter\n"), unit));
        }
    } else if (threshold->flags & BCM_COSQ_THRESHOLD_RCI) {
        if (threshold->type == bcmCosqThresholdPackets) {
            if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_rci_threshold_get, 
                                          (unit, gport, &(threshold->value), soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
            }
            else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_rci_threshold_get, 
                                          (unit, gport, &(threshold->value), soc_dpp_cosq_gport_egress_core_fifo_local_ucast));
            }
            else {
                /* Must use one of these gport types  */
                BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
            }
        }
    } else if (threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP)) {
        if (threshold->type == bcmCosqThresholdPackets) {
            soc_cosq_threshold_t soc_threshold;
            sal_memset(&soc_threshold, 0x0, sizeof(soc_threshold));
            soc_threshold.dp = threshold->dp;
            if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_get, 
                                          (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
            }
            else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_get, 
                                          (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
            }
            else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(gport)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_get, 
                                          (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
            }
            else {
                /* Must use one of these gport types  */
                BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
            }
            threshold->value = soc_threshold.value;
        }
    }
    else if (threshold->flags & (BCM_COSQ_THRESHOLD_ETH_PORT_LLFC | BCM_COSQ_THRESHOLD_ETH_PORT_PFC)) {
        if ((threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) && (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x) : BCM_COSQ_THRESHOLD_ETH_PORT_LLFC and BCM_COSQ_THRESHOLD_ETH_PORT_PFC cannot be used together\n"), 
                unit, threshold->flags));
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_SET) && (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x) : BCM_COSQ_THRESHOLD_SET and BCM_COSQ_THRESHOLD_CLEAR cannot be used together\n"), 
                unit, threshold->flags));
        }

        if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
        }

        if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
            if (BCM_GPORT_IS_LOCAL(gport)) {
                port = BCM_GPORT_LOCAL_GET(gport);
            } else {
                port = BCM_GPORT_MODPORT_PORT_GET(gport);
            }
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport(0x%x) for BCM_COSQ_THRESHOLD_ETH_PORT_LLFC/PFC"), unit, gport));
        }

        rc = bcm_petra_cosq_port_nif_get(unit, port, &nif_id);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error retreiving nif_id for gport (0x%x)\n"), unit, port));
        }

        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_port_fifo_threshold_get,(unit, nif_id, &fc_fifo_th)));

        if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) {
            /* get RX PORT FIFO Link Level Flow Control geneeration thresholds */
            if (threshold->flags & BCM_COSQ_THRESHOLD_SET) {
                threshold->value = fc_fifo_th.llfc.set;
            }
            
            if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
                threshold->value = fc_fifo_th.llfc.clear;
            }
        }

        if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC) {
            /* get RX PORT FIFO Priority Flow Control geneeration thresholds */
            if (threshold->flags & BCM_COSQ_THRESHOLD_SET) {
                threshold->value = fc_fifo_th.pfc.set;
            }
            
            if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
                threshold->value = fc_fifo_th.pfc.clear;
            }
        }
    }
    else
    {/*i.e. invalid parameter*/
        rc = BCM_E_PARAM;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_egress_map_set(int unit,
                              bcm_gport_t gport,
                              bcm_cos_t ingress_pri,
                              bcm_color_t ingress_dp,
                              bcm_cos_queue_t offset)
{
    bcm_error_t rc;
    BCMDNX_INIT_FUNC_DEFS;


    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_egress_queue_map_set(unit, gport, ingress_pri, ingress_dp, offset);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG( BCM_E_PORT, (_BSL_BCM_MSG("Unsupported gport type parameter 0x%x"), gport));
    }

    

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_egress_map_get(int unit,
                              bcm_gport_t gport,
                              bcm_cos_t ingress_pri,
                              bcm_color_t ingress_dp,
                              bcm_cos_queue_t *offset)
{
    bcm_error_t rc;
    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_egress_queue_map_get(unit, gport, ingress_pri, ingress_dp, offset);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG( BCM_E_PORT, (_BSL_BCM_MSG("Unsupported gport type parameter 0x%x"), gport));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_egress_multicast_config_set(int unit, 
                                           bcm_gport_t gport, 
                                           bcm_cos_t ingress_pri, 
                                           bcm_color_t ingress_dp, 
                                           uint32 flags, 
                                           bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    uint8   traffic_en = 0;
    uint32  soc_sand_rc = SOC_SAND_OK;

    BCMDNX_INIT_FUNC_DEFS;

    /* Traffic Enabled Restriction */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_enable_traffic_get,(unit, &traffic_en)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if(traffic_en == TRUE)
    {
        /* Check the override flag for allowing modifications during traffic */
        if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "allow_modifications_during_traffic", 0) == 0)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, changing MC TC mapping is not allowed while traffic is enabled"), unit));
        }
    }

    if(gport == 0 && (flags & BCM_COSQ_MULTICAST_UNSCHEDULED )) {
        rc = _bcm_petra_cosq_device_egress_multicast_config_set(unit, gport, ingress_pri, ingress_dp, flags, config); 
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if ((BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) && (flags & BCM_COSQ_MULTICAST_SCHEDULED )) {
        rc = _bcm_petra_cosq_gport_egress_multicast_config_set(unit, gport, ingress_pri, ingress_dp, flags, config);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port parameter")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_egress_multicast_config_get(int unit, 
                                           bcm_gport_t gport, 
                                           bcm_cos_t ingress_pri, 
                                           bcm_color_t ingress_dp, 
                                           uint32 flags, 
                                           bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if(gport == 0 && (flags & BCM_COSQ_MULTICAST_UNSCHEDULED )) {
        if(!SOC_IS_PETRAB(unit)) {
            rc = _bcm_petra_cosq_device_egress_multicast_config_get(unit, gport, ingress_pri, ingress_dp, flags, config); 
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_petra_cosq_gport_egress_multicast_config_get(unit, gport, ingress_pri, ingress_dp, flags, config);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port parameter")));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_connection_set(int unit,
                                    bcm_cosq_gport_connection_t *gport_connect)
{
    bcm_error_t rc = BCM_E_NONE;
    int is_ingress = FALSE, is_egress = FALSE, is_remove = FALSE;
    int my_modid;
    int nbr_cos, nbr_quads, cur_quad;
    int base_qid, base_cid, queue_region, flow_id, flow_region, is_odd_even;
    uint8 is_non_contiguous, is_composite;
    SOC_TMC_IPQ_QUARTET_MAP_INFO queue_map_info;
    SOC_TMC_SCH_FLOW sch_flow;
    SOC_TMC_SCH_QUARTET_MAPPING_INFO quartet_flow_info;
    uint32 soc_sand_rc;
    int nbr_flow_quartets;
    bcm_dpp_cosq_voq_config_t *voq_config;
    bcm_dpp_cosq_connector_config_t *connector_config;
    int updated_base_cid;
    int core = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

   /*
    * To be on the safe side.
    */
   connector_config = NULL ;

    

    /* consistency checks */
    if (gport_connect == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport_connect parameter needs to be specified"), unit));
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "  DBG, flags (0x%x), remoteModid (%d)\n"), gport_connect->flags, gport_connect->remote_modid));

    if (gport_connect->flags & ~(BCM_COSQ_GPORT_CONNECTION_INGRESS | BCM_COSQ_GPORT_CONNECTION_EGRESS | BCM_COSQ_GPORT_CONNECTION_INVALID)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, gport_connect->flags));
    }

    is_ingress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INGRESS) ? TRUE : FALSE;
    is_egress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_EGRESS) ? TRUE : FALSE;
    is_remove = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INVALID) ? TRUE : FALSE; 

    if ( (is_ingress == FALSE) && (is_egress == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flags parameter(0x%x) need to specify ingresss/egress"), unit, gport_connect->flags));
    }

    if ( (is_ingress == TRUE) && (is_egress == TRUE) ) {
        rc = bcm_petra_stk_my_modid_get(unit, &my_modid);
        if (rc) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "my modid invalid bcm_petra_stk_my_modid_get() rc=%s\n"), bcm_errmsg(rc)));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        if (gport_connect->remote_modid != my_modid) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, modid specified (%d) needs to be the local modid when ingress & egress are specified"), unit, gport_connect->remote_modid));
        }
    }

    if ( !(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq) ||
       BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq) ||
       BCM_COSQ_GPORT_IS_ISQ(gport_connect->voq)) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ucast/mcast/isq gport 0x%x"), unit, gport_connect->voq));
    }
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq)) {
        base_qid =  BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_connect->voq);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_GET(gport_connect->voq);
    } else {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport_connect->voq);
    }

    if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_connect->voq_connector)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid connector gport 0x%x"), unit, gport_connect->voq_connector));
    }
    base_cid = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport_connect->voq_connector);

    if (is_ingress == TRUE) {
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                         &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid));
        if (voq_config == NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) voq(%d) internal state get error\n"), unit, base_qid));
            BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
        }
        nbr_cos = voq_config->num_cos;
    }
    else { /* is_egress */
        connector_config = (bcm_dpp_cosq_connector_config_t*)_bcm_petra_cosq_element_get(unit,
                             &(_dpp_cosq_config[unit].connector_hd), base_cid);
        if (connector_config == NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) cid(%d) internal state get error\n"), unit, base_cid));
            BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
        }
        nbr_cos = connector_config->num_cos;
    }

    if (nbr_cos > 8) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) cid(%d) internal state get error\n"), unit, base_cid));
        BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
    }
 
    nbr_quads = BCM_DEVICE_PETRA_COSQ_QUEUE_QUAD_GET(nbr_cos);    

   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "  DBG, Base_CID (0x%x)\n"), base_cid));

    if (is_ingress) {

        /* determine queue region mode */
        queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_qid);
        rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
        BCMDNX_IF_ERR_EXIT(rc);

        SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_queue_to_flow_mapping_get,(unit, core,SOC_TMC_IPQ_Q_TO_QRTT_ID(base_qid), &queue_map_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        is_composite = queue_map_info.is_composite;


        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "  DBG, isNonContiguous %s, isComposite %s, nbrQuads(%d)\n"), 
                              ((is_non_contiguous) ? "True" : "False"), ((is_composite) ? "True" : "False"), nbr_quads));

    
        updated_base_cid = base_cid;

        for (cur_quad = 0; cur_quad < nbr_quads; cur_quad++) {
            _bcm_petra_flow_id_get(unit, updated_base_cid, cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET,
                               is_non_contiguous, is_composite, is_remove, &flow_id);

            queue_map_info.flow_quartet_index = SOC_TMC_SCH_FLOW_TO_QRTT_ID(flow_id);

            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "  DBG, qQuartet %d, QueueMap (fQuartet %d, isComposite %d)\n"), 
                                  SOC_TMC_IPQ_Q_TO_QRTT_ID((base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET))),
                       queue_map_info.flow_quartet_index, queue_map_info.is_composite));
            queue_map_info.is_modport = 1; /* In direct mapping mode, we should use the retrieved modport and not the sysport. Does not affect indirect mode. */

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_set,
                (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID((base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET))), &queue_map_info)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET), soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }

    if (is_egress) {

        flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_cid);
        rc = _bcm_petra_flow_region_config_get(unit, flow_region, &is_non_contiguous, &is_odd_even);
        BCMDNX_IF_ERR_EXIT(rc);

        SOC_TMC_SCH_FLOW_clear(&sch_flow);
        SOC_TMC_SCH_QUARTET_MAPPING_INFO_clear(&quartet_flow_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, base_cid, &sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving sch flow (%d), soc_sand error 0x%x, error 0x%x\n"), unit, base_cid, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        if ( (sch_flow.sub_flow[0].is_valid == FALSE) && (sch_flow.sub_flow[1].is_valid == FALSE) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, ino sub flow enabled for sch flow (%d), soc_sand error 0x%x, error 0x%x"), unit, base_cid, soc_sand_rc, rc));
        } 

        is_composite = ((sch_flow.sub_flow[0].is_valid == TRUE) && (sch_flow.sub_flow[1].is_valid == TRUE)) ? TRUE : FALSE;

        _bcm_petra_nbr_flow_quartets_for_queue_quartet(unit, is_non_contiguous, is_composite,
                                                                            &nbr_flow_quartets);
        for (cur_quad = 0; cur_quad < nbr_quads; cur_quad++) {
            int local_cid, local_cid_quartet ;
            int other_cid, other_cid_quartet ;
            bcm_dpp_cosq_connector_config_t *local_connector_config;
            bcm_dpp_cosq_connector_config_t *other_connector_config;

            quartet_flow_info.base_q_qrtt_id = SOC_TMC_IPQ_Q_TO_QRTT_ID(base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET));
            quartet_flow_info.is_composite = is_composite;
            if (is_remove) {
                quartet_flow_info.fip_id = SOC_TMC_MAX_FAP_ID; /* set to invalid modid */
            } else {
                quartet_flow_info.fip_id = gport_connect->remote_modid; 
            }


            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "  DBG, fQuartet %d, nbrQuartets %d, FlowMap (qQuartet %d, isComposite %d, remoteModid %d)\n"), 
                                  SOC_TMC_SCH_FLOW_TO_QRTT_ID(base_cid) + (cur_quad * nbr_flow_quartets), nbr_flow_quartets,
                       
                       quartet_flow_info.base_q_qrtt_id, quartet_flow_info.is_composite, quartet_flow_info.fip_id));

            local_cid = base_cid + SOC_TMC_SCH_QRTT_TO_FLOW_ID(cur_quad * nbr_flow_quartets) ;
            local_connector_config =
                (bcm_dpp_cosq_connector_config_t *)
                    _bcm_petra_cosq_element_get(unit,&(_dpp_cosq_config[unit].connector_hd),local_cid) ;
            if (local_connector_config == NULL) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                  "Unit(%d) cid(%d) internal state get error\n"), unit, local_cid));
                BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
            }
            /*
             * Mark 'other' quartet as valid or not. See remark on 'other_quartet_is_valid'
             * element in SOC_TMC_SCH_QUARTET_MAPPING_INFO.
             */
            local_cid_quartet = SOC_TMC_SCH_FLOW_TO_QRTT_ID(local_cid) ;
            if (local_cid_quartet % 2) {
                /*
                 * Odd cid quartet. Other should be the even one.
                 */
                other_cid_quartet = local_cid_quartet - 1 ;
            } else {
                /*
                 * Even cid quartet. Other should be the odd one.
                 */
                other_cid_quartet = local_cid_quartet + 1 ;
            }
            other_cid = SOC_TMC_SCH_QRTT_TO_FLOW_ID(other_cid_quartet) ;
            quartet_flow_info.other_quartet_is_valid = 0 ;
            other_connector_config =
                (bcm_dpp_cosq_connector_config_t *)
                    _bcm_petra_cosq_element_get(unit,&(_dpp_cosq_config[unit].connector_hd),other_cid) ;
            if (other_connector_config) {
                if (other_connector_config->flags & CONNECTION_IS_VALID_MASK) {
                    quartet_flow_info.other_quartet_is_valid = 1 ; ;
                }
            }
            /*
             * Mark connectors group as invalid to start with. Update to 'valid'
             * when operation succeeds.
             */
            local_connector_config->flags &= ~CONNECTION_IS_VALID_MASK ;
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_flow_to_queue_mapping_set,
                         (unit, SOC_TMC_SCH_FLOW_TO_QRTT_ID(base_cid) + (cur_quad * nbr_flow_quartets),
                         nbr_flow_quartets, &quartet_flow_info)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET), soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
            /*
             * Mapping was completed successfully. Mark connectors group as valid
             * by reloading 'num_cos' by its original value.
             */
            if (!is_remove) {
                local_connector_config->flags |= CONNECTION_IS_VALID_MASK ;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_connection_get(int unit,
                              bcm_cosq_gport_connection_t *gport_connect)
{
    bcm_error_t                       rc = BCM_E_NONE;
    uint32                            soc_sand_rc;
    int                               flag_count;       
    int                               is_ingress, is_egress;
    int                               base_qid=0, base_cid=0;
    bcm_dpp_cosq_voq_config_t        *voq_config;
    SOC_TMC_IPQ_QUARTET_MAP_INFO          queue_map_info;
    bcm_gport_t                       modport_gport, sysport_gport;
    bcm_dpp_cosq_connector_config_t  *connector_config;
    SOC_TMC_SCH_QUARTET_MAPPING_INFO      quartet_flow_info;
    SOC_SAND_U32_RANGE                    queue_range;
    int                               is_multicast = FALSE, is_unicast = FALSE;
    int                               is_isq = FALSE;
    SOC_TMC_ITM_INGRESS_SHAPE_INFO      isp_info;
    int core = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* consistency checks */
    if (gport_connect == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport_connect"), unit));
    }
 
    flag_count = _bcm_cosq_bit_count_get(gport_connect->flags);
    if (flag_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag settting valid"), unit, gport_connect->flags));
    }
    if ((gport_connect->flags &
            (BCM_COSQ_GPORT_CONNECTION_INGRESS | BCM_COSQ_GPORT_CONNECTION_EGRESS)) == 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag settting valid"), unit, gport_connect->flags));
    }

    is_ingress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INGRESS) ? TRUE : FALSE;
    is_egress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_EGRESS) ? TRUE : FALSE;
   
    if (is_ingress) {
        unsigned indirect_mode = 1;
#ifdef BCM_ARAD_SUPPORT
        if (SOC_IS_ARAD(unit) && ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
            indirect_mode = 0;
        }
#endif
        if ( !(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq) ||
                         BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)
                          || BCM_COSQ_GPORT_IS_ISQ(gport_connect->voq))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ucast/mcast gport 0x%x"), unit, gport_connect->voq));
        }

        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq)) {
            base_qid =  BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_connect->voq);
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)) {
            base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_GET(gport_connect->voq);
        } else {
            base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport_connect->voq);
        }

        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                         &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid));
        if (voq_config == NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) voq(%d) internal state get error\n"), unit, base_qid));
            rc = BCM_E_RESOURCE;
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_qid), &queue_map_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in getting queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        BCM_COSQ_GPORT_VOQ_CONNECTOR_SET(gport_connect->voq_connector, SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue_map_info.flow_quartet_index));
        if (indirect_mode) {
            BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, queue_map_info.system_physical_port);

            rc = bcm_petra_stk_sysport_gport_get(unit, sysport_gport, &modport_gport);
            BCMDNX_IF_ERR_EXIT(rc);

            gport_connect->remote_modid = BCM_GPORT_MODPORT_MODID_GET(modport_gport);
        } else { /* direct mapping mode */
            gport_connect->remote_modid = queue_map_info.fap_id;
        }
    }

    if (is_egress) {
        if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_connect->voq_connector)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq connector 0x%x"), unit, gport_connect->voq_connector));
        }
        base_cid = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport_connect->voq_connector);

        connector_config = (bcm_dpp_cosq_connector_config_t*)_bcm_petra_cosq_element_get(unit,
                             &(_dpp_cosq_config[unit].connector_hd), base_cid);
        if (connector_config == NULL) {
            BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
        }

        SOC_TMC_SCH_QUARTET_MAPPING_INFO_clear(&quartet_flow_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_flow_to_queue_mapping_get,
            (unit, SOC_TMC_SCH_FLOW_TO_QRTT_ID(base_cid), &quartet_flow_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in getting queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        base_qid = SOC_TMC_IPQ_QRTT_TO_Q_ID(quartet_flow_info.base_q_qrtt_id);

        /* Get multicast queue id range */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_enhanced_get,(unit, &queue_range)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        if ( (base_qid >= queue_range.start) && (base_qid <= queue_range.end) ) {
            is_multicast = TRUE;
        }
        else {
            /* Get ISQ queue range */
            SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, &isp_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            if ((base_qid >= isp_info.q_range.q_num_low) && (base_qid<=isp_info.q_range.q_num_high)) {
                is_isq = TRUE;
            } else {
                is_unicast = TRUE;
            }
        }

        if (is_multicast) {
            BCM_GPORT_MCAST_QUEUE_GROUP_SET(gport_connect->voq, base_qid);
        }
        if (is_unicast) {
            BCM_GPORT_UNICAST_QUEUE_GROUP_SET(gport_connect->voq, base_qid);
        }
        if (is_isq) {
            BCM_COSQ_GPORT_ISQ_SET(gport_connect->voq, base_qid);
        }

        gport_connect->remote_modid = quartet_flow_info.fip_id;
    
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_port_mapping_set(int unit, 
                                bcm_port_t port,
                                bcm_cos_t priority, 
                                bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* FMQ mapping */
    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
            rc = _bcm_petra_cosq_fmq_mapping_set(unit, port, priority, cosq);
#ifndef BCM_WARM_BOOT_SUPPORT /* With this flag the check has been already done */
    } else if(unit >= SOC_MAX_NUM_DEVICES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid soc unit")));
#endif
    } else if (
      !SOC_IS_PETRAB(unit) &&
      (BCM_GPORT_IS_SYSTEM_PORT(port) || 
       BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) || 
       BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) || 
       BCM_COSQ_GPORT_IS_ISQ(port))){

      rc = _bcm_petra_cosq_ingress_tc_mapping_set(unit,port,priority,cosq);
    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Invalid Port")));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_port_mapping_get(int unit,
                                bcm_port_t port,
                                bcm_cos_t priority,
                                bcm_cos_queue_t *cosq)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    /* FMQ mappin */
    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        rc = _bcm_petra_cosq_fmq_mapping_get(unit, port, priority, cosq);
    } else if(unit >= SOC_MAX_NUM_DEVICES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid soc unit")));
    } else if(!SOC_IS_PETRAB(unit) && 
              (BCM_GPORT_IS_SYSTEM_PORT(port) || 
               BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) || 
               BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) || 
               BCM_COSQ_GPORT_IS_ISQ(port))){
      rc = _bcm_petra_cosq_ingress_tc_mapping_get(unit,port,priority,cosq);
    }
    else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid port (0x%x) "), unit, port));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_mapping_set(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Validate */
    if (priority < 0 || priority >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d parameter, range 0-7"), unit, priority));
    }

    if (cosq < 0 || cosq > DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }

    /* Global mapping between PP TC and Ingress TC */
    /* By default: mapping is 1:1 */

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_traffic_class_map_set,(unit,priority,cosq)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_mapping_get(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_IPQ_TR_CLS ipq_tr_cls = 0;
        
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(cosq);    

    /* Validate */
    if (priority < 0 || priority >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d parameter, range 0-7"), unit, priority));
    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_traffic_class_map_get,(unit,priority,&ipq_tr_cls)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *cosq = ipq_tr_cls;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_stat_config_set(int unit,
                               bcm_gport_t gport,
                               bcm_gport_t lgl_gport,
                               bcm_cos_queue_t cosq,
                               uint32 flags,
                               bcm_cosq_gport_stat_profile_t profile)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_stat_config_get(int unit,
                               bcm_gport_t gport,
                               bcm_gport_t lgl_gport,
                               bcm_cos_queue_t cosq,
                               uint32 flags,
                               bcm_cosq_gport_stat_profile_t *profile)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_statistic_set(int unit,
                             bcm_gport_t gport,
                             bcm_gport_t lgl_gport,
                             bcm_cos_queue_t cosq,
                             uint32 flags,
                             bcm_cosq_gport_stats_t stat,
                             uint64 value)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_statistic_get(int unit,
                             bcm_gport_t gport,
                             bcm_gport_t lgl_gport,
                             bcm_cos_queue_t cosq,
                             uint32 flags,
                             bcm_cosq_gport_stats_t stat,
                             uint64 *value)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_cosq_gport_statistic_multi_set(int unit,
                                   bcm_gport_t gport,
                                   bcm_gport_t lgl_gport,
                                   bcm_cos_queue_t cosq,
                                   int stat_count,
                                   bcm_cosq_gport_stats_t *stats_array,
                                   uint64 value)
{
    bcm_error_t rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_control_range_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    bcm_cosq_control_range_type_t type, 
    bcm_cosq_range_t *range)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_petra_cosq_control_range_set(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    bcm_cosq_control_range_type_t type, 
    bcm_cosq_range_t *range)
{
    return BCM_E_UNAVAIL;
}

int
bcm_petra_cosq_control_set(int unit,
                           bcm_gport_t port,
                           bcm_cos_queue_t cosq,
                           bcm_cosq_control_t type,
                           int arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    int port_index;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    

    /* device wide settings */ 
    if (port == 0) {
        rc = _bcm_petra_cosq_control_device_set(unit, port, cosq, type, arg);
    }

    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
        rc = _bcm_petra_cosq_control_fmq_set(unit, port, cosq, type, arg);
    }

    /* E2E scheduler */
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(port)) {
        rc = _bcm_petra_cosq_control_e2e_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_e2e_port_tc_set(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_e2e_port_tcg_set(unit, port, cosq, type, arg);
    }
    /* Egress transmit scheduler */
    /* Egress scheduler port */
    else if (BCM_GPORT_IS_LOCAL(port)) {
        port_index = BCM_GPORT_LOCAL_GET(port);

        if (BCM_DPP_PORT_IS_INTERFACE(port_index)) {  
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_control_egress_interface_scheduler_set(unit, port, cosq, type, arg);
        } else {
            /* Egress scheduler port */
            rc = _bcm_petra_cosq_control_egress_port_scheduler_set(unit, port, cosq, type, arg);
        }        
    }
    /* Egress Queues */
    else if ((BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port)) ||
             (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port))) {
        rc = _bcm_petra_cosq_control_egress_queue_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_PORT_TC(port)) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_egress_port_tc_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_PORT_TCG(port)) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_egress_port_tcg_set(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_TDM(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_tdm));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
    }
    /* Ingress Queues */
    else if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) ||
             BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) ||
             BCM_COSQ_GPORT_IS_ISQ(port)) {
        rc = _bcm_petra_cosq_control_ingress_queue_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_GPORT_IS_SCHEDULER(port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port))) {
 
        rc = _bcm_petra_cosq_control_flow_set(unit, port, cosq, type, arg);
    } 
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d,port(0x%08x) not supported \n"), unit, port));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_control_get(int unit,
                     bcm_gport_t port,
                     bcm_cos_queue_t cosq,
                     bcm_cosq_control_t type,
                     int *arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    int port_index;


    BCMDNX_INIT_FUNC_DEFS;
    

    /* device wide settings */ 
    if (port == 0) {
        rc = _bcm_petra_cosq_control_device_get(unit, port, cosq, type, arg);
    }

    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
        rc = _bcm_petra_cosq_control_fmq_get(unit,port,cosq,type,arg);
    } 
   
    /* E2E scheduler */
    else if ((BCM_GPORT_IS_SCHEDULER(port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port))) {
 
        rc = _bcm_petra_cosq_control_flow_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(port)) {
        rc = _bcm_petra_cosq_control_e2e_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_e2e_port_tc_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_e2e_port_tcg_get(unit, port, cosq, type, arg);
    }
    /* Egress transmit scheduelr */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(port)) {
        port_index = BCM_GPORT_LOCAL_GET(port);

        if (BCM_DPP_PORT_IS_INTERFACE(port_index)) {
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_control_egress_interface_scheduler_get(unit, port, cosq, type, arg);
        }
        else {
            rc = _bcm_petra_cosq_control_egress_port_scheduler_get(unit, port, cosq, type, arg);
        }
    } 
    else if (BCM_COSQ_GPORT_IS_PORT_TC(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_egress_port_tc_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_egress_port_tcg_get(unit, port, cosq, type, arg);
    }
    /* Egress Queues */
    else if ((BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port)) ||
             (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port)))
    {
        rc = _bcm_petra_cosq_control_egress_queue_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_TDM(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_tdm));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
    }
    /* Ingress queues */
    else if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) ||
             BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) ||
             BCM_COSQ_GPORT_IS_ISQ(port)) {
        rc = _bcm_petra_cosq_control_ingress_queue_get(unit, port, cosq, type, arg);
    } 
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, port(0x%08x) not supported \n"), unit, port));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_petra_cosq_gport_handle_get(int unit,
                                bcm_cosq_gport_type_t gport_type,
                                bcm_cosq_gport_info_t *gport_info)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_cosq_gport_info_core_t gport_core_info;

    BCMDNX_INIT_FUNC_DEFS;
    
    if (gport_info == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("gport info needs specified, cannot be NULL")));
    }

    switch (gport_type) {
        case bcmCosqGportTypeE2EPort:
            
            BCM_COSQ_GPORT_E2E_PORT_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeUnicastEgress:
            
            BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeMulticastEgress:
            
            BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeCompositeFlow2:
            if (!(BCM_GPORT_IS_SCHEDULER(gport_info->in_gport) || 
                    BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_info->in_gport))) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler/VoQ Connector gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }

            BCM_COSQ_GPORT_COMPOSITE_SF2_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeSchedCIR:
            if (!BCM_GPORT_IS_SCHEDULER(gport_info->in_gport)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }

            BCM_COSQ_GPORT_SCHED_CIR_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeSchedPIR:
            if (!BCM_GPORT_IS_SCHEDULER(gport_info->in_gport)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }
            BCM_COSQ_GPORT_SCHED_PIR_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;
          case bcmCosqGportTypeLocalPort:
            {
              int my_modid;

              rc = bcm_petra_stk_my_modid_get(unit, &my_modid);
              BCMDNX_IF_ERR_EXIT(rc);

              if (BCM_GPORT_IS_LOCAL(gport_info->in_gport)) {
                  gport_info->out_gport = gport_info->in_gport;                
              }
              else if (BCM_GPORT_IS_MODPORT(gport_info->in_gport)) {
                  {
                      
                      if (my_modid != BCM_GPORT_MODPORT_MODID_GET(gport_info->in_gport)) {
                          LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                                "Gport (0x%x) of incorrect mod_id, Expect mod_id = my_modid\n"), gport_info->in_gport));
                          rc = BCM_E_PARAM;
                          break;
                      }
      
                      BCM_GPORT_LOCAL_SET(gport_info->out_gport,BCM_GPORT_MODPORT_PORT_GET(gport_info->in_gport));
                  }
              }
              else if (BCM_GPORT_IS_SYSTEM_PORT(gport_info->in_gport)) {
                  {
                      bcm_gport_t modport_gport;

                      rc = bcm_petra_stk_sysport_gport_get(unit,gport_info->in_gport,&modport_gport);
                      BCMDNX_IF_ERR_EXIT(rc);

                      if (my_modid != BCM_GPORT_MODPORT_MODID_GET(modport_gport)) {
                          LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                                "Gport (0x%x) of incorrect mod_id, Expect mod_id = my_modid\n"), gport_info->in_gport));
                          rc = BCM_E_PARAM;
                          break;
                      }
                      
                      /* Returns modport gport, translate it as local gport */
                      BCM_GPORT_LOCAL_SET(gport_info->out_gport,BCM_GPORT_MODPORT_PORT_GET(modport_gport));
                  }                
              }
              else if (SOC_PORT_VALID(unit,gport_info->in_gport)) {
                  
                  /* Assuming other type its only port */
                  BCM_GPORT_LOCAL_SET(gport_info->out_gport,gport_info->in_gport);                
              } else {
                  rc = BCM_E_PORT;           
              }
            }
            break;            
        case bcmCosqGportTypeLocalPortTC: 
        case bcmCosqGportTypeLocalPortTCG:
        case bcmCosqGportTypeE2EPortTC: 
        case bcmCosqGportTypeE2EPortTCG:
          {
              bcm_gport_t local_port = -1;
              bcm_port_t temp_port;
              int my_modid;

              rc = bcm_petra_stk_my_modid_get(unit, &my_modid);
              BCMDNX_IF_ERR_EXIT(rc);

              /* Supported only in case of not Port-TC enable */
              if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "Gport (0x%x) Port-TC is not supported for this device \n"), gport_info->in_gport));
                  rc = BCM_E_UNAVAIL;
                  break;
              }
              rc = BCM_E_NONE;   
              if (BCM_GPORT_IS_LOCAL(gport_info->in_gport)) {
                  local_port = gport_info->in_gport;                
              }
              else if (BCM_GPORT_IS_MODPORT(gport_info->in_gport)) {
                  {
                      if (my_modid != BCM_GPORT_MODPORT_MODID_GET(gport_info->in_gport)) {
                          LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                                "Gport (0x%x) of incorrect mod_id, Expect mod_id = my_modid\n"), gport_info->in_gport));
                          rc = BCM_E_PARAM;
                          break;
                      }
      
                      BCM_GPORT_LOCAL_SET(local_port,BCM_GPORT_MODPORT_PORT_GET(gport_info->in_gport));
                  }
              }
              else if (BCM_GPORT_IS_SYSTEM_PORT(gport_info->in_gport)) {
                  {
                      bcm_gport_t modport_gport;

                      rc = bcm_petra_stk_sysport_gport_get(unit,gport_info->in_gport,&modport_gport);
                      BCMDNX_IF_ERR_EXIT(rc);
                      
                      if (my_modid != BCM_GPORT_MODPORT_MODID_GET(modport_gport)) {
                          LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                                "Gport (0x%x) of incorrect mod_id, Expect mod_id = my_modid\n"), modport_gport));
                          rc = BCM_E_PARAM;
                          break;
                      }

                      /* Returns modport gport, translate it as local gport */
                      BCM_GPORT_LOCAL_SET(local_port,BCM_GPORT_MODPORT_PORT_GET(modport_gport));
                  }                
              }
              else if (SOC_PORT_VALID(unit,gport_info->in_gport)) {
                  
                  /* Assuming other type its only port */
                  BCM_GPORT_LOCAL_SET(local_port,gport_info->in_gport);                
                  
              } else {
                  rc = BCM_E_PORT;           
              }
              if (rc == BCM_E_NONE) {              
                temp_port = BCM_GPORT_LOCAL_GET(local_port);
                switch (gport_type)
                {
                case bcmCosqGportTypeLocalPortTC: 
                  BCM_COSQ_GPORT_PORT_TC_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeLocalPortTCG:
                  BCM_COSQ_GPORT_PORT_TCG_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeE2EPortTC: 
                  BCM_COSQ_GPORT_E2E_PORT_TC_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeE2EPortTCG:
                  BCM_COSQ_GPORT_E2E_PORT_TCG_SET(gport_info->out_gport,temp_port);
                  break;
                /* must have default. Otherwise, compilation error */
                /* coverity[dead_error_begin : FALSE] */
                default:
                  rc = BCM_E_INTERNAL;      
                  break;
                }
              }
          }
            break;
        case bcmCosqGportTypeGlobalFmqRoot:
            BCM_COSQ_GPORT_FMQ_ROOT_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqGuaranteed:
            BCM_COSQ_GPORT_FMQ_GUARANTEED_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffortAggregate:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT_AGR_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort0:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT0_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort1:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT1_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort2:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT2_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqClass1:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 1);
            break;
        case bcmCosqGportTypeGlobalFmqClass2:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 2);
            break;
        case bcmCosqGportTypeGlobalFmqClass3:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 3);
            break;
        case bcmCosqGportTypeGlobalFmqClass4:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 4);
            break;
        case bcmCosqGportTypeGlobalIsqRoot:
            BCM_COSQ_GPORT_ISQ_ROOT_SET(gport_info->out_gport);
            break;
    case bcmCosqGportTypeGlobalFabricMeshLocal:
        case bcmCosqGportTypeGlobalFabricMeshDev0:
        case bcmCosqGportTypeGlobalFabricMeshDev1:
        case bcmCosqGportTypeGlobalFabricMeshDev2:
        case bcmCosqGportTypeGlobalFabricMeshDev3:
        case bcmCosqGportTypeGlobalFabricMeshDev4:
        case bcmCosqGportTypeGlobalFabricMeshDev5:
        case bcmCosqGportTypeGlobalFabricMeshDev6:
        case bcmCosqGportTypeGlobalFabricMeshDev7:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocal:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalLow:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalHigh:
        case bcmCosqGportTypeGlobalFabricClosFabric:
        case bcmCosqGportTypeGlobalFabricClosFabricHigh:
        case bcmCosqGportTypeGlobalFabricClosFabricLow:
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricHigh:
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricLow:
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteed:
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffort:
        {
            gport_core_info.gport_type = gport_type;
            gport_core_info.flags = 0;
            gport_core_info.cosq = 0;
            gport_core_info.in_gport = 0;
            rc = bcm_petra_cosq_gport_handle_core_get(unit, BCM_CORE_ALL, &gport_core_info, &gport_info->out_gport);
            BCMDNX_IF_ERR_EXIT(rc);            
            break;
        }
        case bcmCosqGportTypeSched:
            {
              uint32 fap_port;
              bcm_cos_t priority;
              SOC_TMC_SCH_SE_ID se_id;
              int flow_id, core;
              bcm_gport_t port_gport;

              rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport_info->in_gport, &port_gport);
              BCMDNX_IF_ERR_EXIT(rc);

              if (BCM_GPORT_IS_SCHEDULER(port_gport)) {
                  /* Nothing to do */
                  gport_info->out_gport = port_gport;
                  break;
              }

              /* API is releavant for port TC or other Port physical gports */              
              rc = _bcm_petra_cosq_fap_port_get(unit, port_gport, &fap_port, &core);
              if (rc != BCM_E_NONE) {
                   LOG_ERROR(BSL_LS_BCM_COSQ,
                             (BSL_META_U(unit,
                                         "failed to get fap port for gport: 0x%x, error(0x%x)\n"), gport_info->in_gport, rc));
                  BCMDNX_IF_ERR_EXIT(rc);
              }
              if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
                  BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid fap port %d,  for gport (0x%x)"), unit, fap_port, gport_info->in_gport));
              }

              if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport) || BCM_COSQ_GPORT_IS_PORT_TC(port_gport)) {
                  /* Port-TC */
                  /* validate priority */
                  rc = _bcm_petra_cosq_port_priority_validate(unit,gport_info->in_gport,gport_info->cosq);
                  if (rc != BCM_E_NONE) {
                      LOG_ERROR(BSL_LS_BCM_COSQ,
                                (BSL_META_U(unit,
                                            "verify for gport: 0x%x cosq %d failed, error(0x%x)\n"), gport_info->in_gport, gport_info->cosq, rc));
                      BCMDNX_IF_ERR_EXIT(rc);
                  }
                  priority = gport_info->cosq;
              } else {
                  priority = DPP_COSQ_PB_DEFAULT_PORT_TC;
              }
              
              rc = _bcm_petra_cosq_port2se_id(unit,fap_port,priority,&se_id);            
              if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                  BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
              }
              flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
              BCM_GPORT_SCHEDULER_SET(gport_info->out_gport,flow_id);
            }
            break;
        case bcmCosqGportTypeFabricPipe:
            BCM_COSQ_GPORT_FABRIC_PIPE_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        case bcmCosqGportTypeFabricPipeEgress:
            BCM_COSQ_GPORT_FABRIC_PIPE_EGRESS_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        case bcmCosqGportTypeFabricPipeIngress:
            BCM_COSQ_GPORT_FABRIC_PIPE_INGRESS_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        default :
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid Handle type (%d) requested\n"), gport_type));
            rc = BCM_E_PARAM;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_handle_core_get( 
    int unit, 
    int core, 
    bcm_cosq_gport_info_core_t *gport_info, 
    bcm_gport_t *out_gport)
{

    int my_modid;

    BCMDNX_INIT_FUNC_DEFS;

    switch (gport_info->gport_type) 
    {
        /* mesh scheme */
        case bcmCosqGportTypeGlobalFabricMeshLocal:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL_SET(*out_gport);
            break;
    case bcmCosqGportTypeGlobalFabricMeshDev0:
            BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid)); 
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                if (my_modid == 0) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            /* dest dev 0 should address current fap id */
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, my_modid);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 1) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 1);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 2) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 2);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 3) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 3);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev4:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 4) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 4);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev5:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 5) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 5);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev6:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 6) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 6);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev7:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 7) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 7);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonLocal0:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonLocal1:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev1:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev2:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV2_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev3:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV3_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonMc:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_MC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcOcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcOcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcMixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcMixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMc:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMesh:
            BCM_COSQ_GPORT_FABRIC_MESH_SCOPE_SET(*out_gport);
            break;

        /*close scheme */
        case bcmCosqGportTypeGlobalFabricClosUnicastLocal:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabricHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabricLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteed:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffort:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BESTEFFORT_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonLocal0:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonLocal1:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonUnicastFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_UNICAST_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonMulticastFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_MULTICAST_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0OcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0OcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0MixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0MixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1OcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1MixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1MixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricOcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricOcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricMixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricMixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteedOcb:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_OCB_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffortOcb:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BEST_EFFORT_OCB_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteedMix:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_MIX_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffortMix:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BEST_EFFORT_MIX_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0High:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0Low:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1High:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1Low:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosOcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosMixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosOcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosMixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClos:
            BCM_COSQ_GPORT_FABRIC_CLOS_SCOPE_SET(*out_gport);
            break;
        case bcmCosqGportTypeFabricRxUnicast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_UCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxMulticast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_MCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxTdm:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_TDM_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalUnicast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_UCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalMulticast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_MCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalTdm:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_TDM_SET(*out_gport, core);
            break;

        default:
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
            break;
    }

    /* set core */
    if (BCM_GPORT_IS_FABRIC_MESH(*out_gport) || BCM_GPORT_IS_FABRIC_CLOS(*out_gport))
    {
        BCM_DPP_SCHEDULER_ONLY_CORE_SET(*out_gport, core);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fc_path_add(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Common implementation with the remove function */
    rc = _bcm_petra_cosq_fc_path_add_remove(unit,
                                            FALSE /* is_for_delete */,
                                            fc_direction,
                                            source,
                                            target);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;

    /* Input Validation */
    if (source == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, flow control source not specified\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("flow control source not specified")));
    }
    if (target == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, flow control target is NULL\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("flow control target is NULL")));
    }

    /* Different functions for Generation/Reception */
    if (fc_direction == bcmCosqFlowControlGeneration) {
        rc = _bcm_petra_cosq_generation_fc_path_get(unit, fc_direction, source, target_max, target, target_count);
    }
    else if (fc_direction == bcmCosqFlowControlReception) {
        rc = _bcm_petra_cosq_reception_fc_path_get(unit, fc_direction, source, target_max, target, target_count);
    }
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, invalid flow control direction %d\n"), unit, fc_direction));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("invalid flow control direction")));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* Common implementation with the remove function */
    rc = _bcm_petra_cosq_fc_path_add_remove(unit,
                                            TRUE /* is_for_delete */,
                                            fc_direction,
                                            source,
                                            target);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_pfc_config_set(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              uint32 flags,
                              bcm_cosq_pfc_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    if (config == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid config parameter %p"), unit, config));
    }
    
    /* PFC FC settings include the following:
     * 1. Global thresholds (VSQ global) 
     * 2. PFC VSQ FC thresholds (VSQ PFC)
     * 3. LLFC VSQ FC thresholds (VSQ LLFC)                              
     */
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        int vsq_type;

        vsq_type = BCM_COSQ_GPORT_VSQ_TYPE_GET(gport);
        if (vsq_type ==  BCM_COSQ_VSQ_GL) {
           rc = _bcm_petra_cosq_vsq_gl_fc_threshold_set(unit, gport, cosq, flags, config);
        } else {
           rc = _bcm_petra_cosq_vsq_fc_threshold_set(unit, gport, cosq, flags, config);
        } 
    } else {
      /* not supported gport */
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport 0x%x not supported gport"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_pfc_config_get(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              uint32 flags,
                              bcm_cosq_pfc_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        int vsq_type;

        vsq_type = BCM_COSQ_GPORT_VSQ_TYPE_GET(gport);
        /* 1. vsq gl flow control thresholds */
        if (vsq_type ==  BCM_COSQ_VSQ_GL) {
           rc = _bcm_petra_cosq_vsq_gl_fc_threshold_get(unit, gport, cosq, flags, config);
        } else if (vsq_type == BCM_COSQ_VSQ_PFC || vsq_type == BCM_COSQ_VSQ_LLFC) {
           rc = _bcm_petra_cosq_vsq_fc_threshold_get(unit, gport, cosq, flags, config); 
        } else {
          /* not supported gport */
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport 0x%x not supported gport"), unit, gport));
        }
    } else {
      /* not supported gport */
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport 0x%x not supported gport"), unit, gport));
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int 
bcm_petra_cosq_qcn_config_set(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit))
    {
      rc = bcm_arad_cosq_qcn_config_set(unit, port, cosq, flags, config);
      BCMDNX_IF_ERR_EXIT(rc);
    }
#else
    rc = BCM_E_UNAVAIL;
#endif

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_qcn_config_get(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit))
    {
      rc = bcm_arad_cosq_qcn_config_get(unit, port, cosq, flags, config);
      BCMDNX_IF_ERR_EXIT(rc);
    }
#else
    rc = BCM_E_UNAVAIL;
#endif   

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


#ifdef BCM_ARAD_SUPPORT

int 
bcm_arad_cosq_qcn_config_set(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    int base_qid, qid, cpq_index, cnm_queue_base;
    uint32 soc_sand_rc = 0, soc_sand_dev_id; 
    int new_mapping_profile_id, is_allocated;
    int i, valid_samples;
    SOC_TMC_CNM_CPQ_INFO cpq_info;
    SOC_TMC_CNM_CP_PROFILE_INFO profile_info;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);
    SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);
    SOC_TMC_CNM_CP_PROFILE_INFO_clear(&profile_info);

    /* Validation */
    if(!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)))
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("QCN settings only apply to GPORT of type UNICAST_QUEUE (VOQ)")));
    }
    if(config == NULL)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("QCN config structure is NULL")));
    }

    /* Calcule CPQ index out of VOQ index and CPQ base queue */
    base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    qid = base_qid + cosq;

    rc = _bcm_petra_cosq_control_device_get(unit, 0, 0, bcmCosqControlCongestionManagedQueueMin, &cnm_queue_base);
    BCMDNX_IF_ERR_EXIT(rc);

    cpq_index = qid - cnm_queue_base;

    /* Translate the config into DPP structure */
    profile_info.q_eq = config->size;
    profile_info.cpw_power = config->weight;
    profile_info.max_neg_fb_value = config->max_feedback;
    profile_info.quant_div = config->quantization;
    profile_info.is_sampling_th_random = config->randomize_sample_threshold;
    valid_samples = SOC_SAND_MIN(config->nbr_samples, BCM_COS_COUNT);
    for(i = 0; i < valid_samples; i++)
    {
      profile_info.sampling_base[i] = config->sample_bytes[i];
    }

    /* Get current profile id */
    soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, cpq_index, &cpq_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Exchange profile info */
    rc = _bcm_dpp_am_template_pool_cnm_queue_profile_exchange(unit, cpq_info.profile, &profile_info, &new_mapping_profile_id, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Update HW if needed */
    if(is_allocated)
    {
        rc = _bcm_arad_cosq_cnm_queue_profile_hw_set(unit, new_mapping_profile_id, &profile_info);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Update the profile id of the CPQ */
    cpq_info.profile = new_mapping_profile_id;
    soc_sand_rc = arad_cnm_cpq_set(soc_sand_dev_id, cpq_index, &cpq_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
   BCMDNX_FUNC_RETURN;
}

int 
bcm_arad_cosq_qcn_config_get(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    int base_qid, qid, cpq_index, cnm_queue_base;
    uint32 soc_sand_rc = 0, soc_sand_dev_id; 
    int i;
    SOC_TMC_CNM_CPQ_INFO cpq_info;
    SOC_TMC_CNM_CP_PROFILE_INFO profile_info;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);
    SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);
    SOC_TMC_CNM_CP_PROFILE_INFO_clear(&profile_info);

    /* Validation */
    if(!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)))
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("QCN settings only apply to GPORT of type UNICAST_QUEUE (VOQ)")));
    }
    if(config == NULL)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("QCN config structure is NULL")));
    }

    /* Calcule CPQ index out of VOQ index and CPQ base queue */
    base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    qid = base_qid + cosq;

    rc = _bcm_petra_cosq_control_device_get(unit, 0, 0, bcmCosqControlCongestionManagedQueueMin, &cnm_queue_base);
    BCMDNX_IF_ERR_EXIT(rc);

    cpq_index = qid - cnm_queue_base;

    /* Get current profile id */
    soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, cpq_index, &cpq_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Get profile info */
    soc_sand_rc = arad_cnm_cp_profile_get(soc_sand_dev_id, cpq_info.profile, &profile_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Translate the DPP structure into config */
    config->size = profile_info.q_eq;
    config->weight = profile_info.cpw_power;
    config->max_feedback = profile_info.max_neg_fb_value;
    config->quantization = profile_info.quant_div;
    config->randomize_sample_threshold = profile_info.is_sampling_th_random;
    config->nbr_samples = BCM_COS_COUNT;
    for(i = 0; i < BCM_COS_COUNT; i++)
    {
      config->sample_bytes[i] = profile_info.sampling_base[i];
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
   BCMDNX_FUNC_RETURN;}

STATIC int _bcm_arad_cosq_cnm_queue_profile_hw_set(int unit, int profile_id, SOC_TMC_CNM_CP_PROFILE_INFO *profile_info)
{
    uint32 soc_sand_rc = 0, soc_sand_dev_id; 

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);

    soc_sand_rc = arad_cnm_cp_profile_set(soc_sand_dev_id, profile_id, profile_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int _bcm_arad_cosq_cnm_queue_profile_hw_get(int unit, int profile_id, SOC_TMC_CNM_CP_PROFILE_INFO *profile_info)
{
    uint32 soc_sand_rc = 0, soc_sand_dev_id; 

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);

    soc_sand_rc = arad_cnm_cp_profile_get(soc_sand_dev_id, profile_id, profile_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;

}
#endif /* BCM_ARAD_SUPPORT */

#ifdef BCM_ARAD_SUPPORT

int
_bcm_petra_cosq_fc_port_threshold_init(int unit, soc_port_t port, int *mc_reserved_pds)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_thresh_key_info_t thresh_key;
    int                     is_allocated, is_last;
    int                     template, old_template, tc;  
    int                     threshold_port, threshold_queue, drop_dbs_th, drop_pds_th, drop_pds_th_tc, port_mc_drop_pds, port_mc_drop_dbs;
    uint32                  nof_priorities, num_of_channels, port_rate;
    int                     interface_id;
    ARAD_NIF_TYPE           interface_type;

    BCMDNX_INIT_FUNC_DEFS;

    rc = bcm_petra_fap_port_parent_nif_get(unit,port,&interface_id);
    BCMDNX_IF_ERR_EXIT(rc);

    interface_type = arad_nif_id2type(interface_id);
    if (interface_type == ARAD_NIF_TYPE_NONE) {
        *mc_reserved_pds = 0;
        return BCM_E_NONE;
    }

    /* IF rate mbps */
    rc = soc_port_sw_db_interface_rate_get(unit, port, &port_rate);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
    BCMDNX_IF_ERR_EXIT(rc);

    SOCDNX_IF_ERR_EXIT(soc_port_sw_db_num_of_channels_get(unit, port, &num_of_channels));

    *mc_reserved_pds = 40; /* Default value - just in case */

    if(port_rate <= 2500) { /* 1G */
      threshold_port = 31;
      port_mc_drop_pds = 135;
      port_mc_drop_dbs = 1350;
      threshold_queue = 31;
      *mc_reserved_pds = 40;
    } else if(port_rate <= 12500) { /* 10G */
      threshold_port = 250;
      port_mc_drop_pds = 1083;
      port_mc_drop_dbs = 10830;
      switch(nof_priorities)
      {
      case 1:
        threshold_queue = 250;
        break;
      case 2:
        threshold_queue = 125;
        *mc_reserved_pds = 160;
        break;
      case 8:
      default:
        threshold_queue = 83;
        *mc_reserved_pds = 40;
      }
    } else if(port_rate <= 48000) { /* 40G */
      threshold_port = 1000;
      port_mc_drop_pds = 4050;
      port_mc_drop_dbs = 43330;
      switch(nof_priorities)
      {
      case 1:
        threshold_queue = 1000;
        break;
      case 2:
        threshold_queue = 500;
        *mc_reserved_pds = 640;
        break;
      case 8:
      default:
        threshold_queue = 333;
        *mc_reserved_pds = 160;
      }
    } else if(port_rate <= 120000) { /* 100G , 120G */
      threshold_port = 2500;
      port_mc_drop_pds = 10830;
      port_mc_drop_dbs = 108300;
      switch(nof_priorities)
      {
      case 1:
        threshold_queue = 2500;
        break;
      case 2:
        threshold_queue = 1250;
        *mc_reserved_pds = 1600;
        break;
      case 8:
      default:
        threshold_queue = 833;
        *mc_reserved_pds = 400;
      }
    } else { /* 200G , 240G */
      threshold_port = 5000;
      port_mc_drop_pds = 21660;
      port_mc_drop_dbs = 216600;
      switch(nof_priorities)
      {
      case 1:
        threshold_queue = 5000;
        break;
      case 2:
        threshold_queue = 2500;
        *mc_reserved_pds = 3200;
        break;
      case 8:
      default:
        threshold_queue = 1250;
        *mc_reserved_pds = 800;
      }
    }

    *mc_reserved_pds = *mc_reserved_pds / num_of_channels;
    drop_pds_th = 6000;
    drop_dbs_th = 6000;
    drop_pds_th_tc = 4000;

    if(nof_priorities == 0)
    {
      rc = BCM_E_INTERNAL;
      BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Old data get */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_data_get(unit,port,&thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    /* PORT */
    thresh_key.port_fc_packet_descriptors = threshold_port;
    thresh_key.port_fc_data_buffers = threshold_port;
    thresh_key.unsch_drop_packet_descriptors = port_mc_drop_pds;
    thresh_key.unsch_drop_data_buffers = port_mc_drop_dbs;

    /* PORT UC DROP (Device)  */
    thresh_key.sch_drop_packet_descriptors = drop_pds_th;
    thresh_key.sch_drop_data_buffers = drop_dbs_th;

    /* QUEUE */
    for(tc = 0; tc < nof_priorities; tc++)
    {
      thresh_key.sch_fc_data_buffers_tc[tc] = threshold_queue;
      thresh_key.sch_drop_data_buffers_tc[tc] = drop_dbs_th;
      thresh_key.sch_drop_packet_descriptors_tc[tc] = drop_pds_th_tc;
    }

    /* MC per TC/DP */
    if(port_mc_drop_pds > DPP_COSQ_ARAD_MAX_QUEUE_PD_THRESH)
    {
      /* This value is now used for queue thresholds */
      port_mc_drop_pds = 4050;
      
      for(tc = 0; tc < nof_priorities; tc++) {
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][0] = port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][1] = port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][2] = port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][3] = port_mc_drop_pds / 10;

        thresh_key.unsch_drop_data_buffers_tc_dp[tc][0] = port_mc_drop_dbs;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][1] = port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][2] = port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][3] = port_mc_drop_dbs / 10;
      }
    }
    else
    {
      for(tc = 0; tc < nof_priorities; tc++) {
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][0] = port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][1] = port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][2] = port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][3] = port_mc_drop_pds / 10;
    
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][0] = port_mc_drop_dbs;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][1] = port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][2] = port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][3] = port_mc_drop_dbs / 10;
      }
    }

    /* Reserved MC PDs */
    for (tc = 0; tc < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); tc++) {
        thresh_key.unsch_drop_packet_descriptors_available_tc[tc] = *mc_reserved_pds;
    }

    /* Set new object */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_exchange(unit,port,&thresh_key,&old_template,&is_last,&template,&is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (old_template != template) {
        /* Set new profile */
        rc = _bcm_petra_cosq_egress_thresh_profile_set(unit,port,template);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_allocated) {
        /* Set new data for a specific profile */
        rc = _bcm_arad_cosq_egress_thresh_profile_data_set(unit,template,&thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
  BCMDNX_FUNC_RETURN;
}

#endif
/*
 * initialization corresponding to the configuration indicated via SOC properties
 * All consistency checks and ressetting the configuration to be consistent has been
 * already done during soc_init(). Reference drv.c. Thus no consistency checks are
 * done during bcm_petra_init()/cosq_init().
 */
STATIC int
_bcm_petra_cosq_fc_init(int unit)
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              rv;
    SOC_TMC_FC_CAL_IF_INFO        cal_if_info;
    SOC_TMC_FC_REC_CALENDAR      *cal_buff = NULL;
    SOC_TMC_FC_CAL_MODE           cal_mode_ndx = 0;
    SOC_TMC_FC_DIRECTION       direction_ndx;
    SOC_TMC_FC_GEN_CALENDAR      *gen_cal_buff = NULL;
    int                      oob_if, ilkn_if, llfc_ilkn_if, core;
    uint32                   soc_sand_rc = SOC_SAND_OK, dev_id, flags;
    bcm_dpp_cosq_config_t   *cosq_config;
    int                      cal_index /*rx_cal_len, tx_cal_len*/;
    bcm_dpp_cosq_rx_cal_t   *rx_cal;
    bcm_dpp_cosq_tx_cal_t   *tx_cal;
    int                      is_coldboot = TRUE;
    SOC_TMC_FC_ILKN_LLFC_INFO     llfc_info;
    pbmp_t                  ports_map;
    soc_port_t              port_i;
    int                     fc_mode;
    int                     interface_id;
#ifdef BCM_PETRAB_SUPPORT
    SOC_PB_NIF_TYPE         pb_nif_type;
#endif
#ifdef BCM_ARAD_SUPPORT
    ARAD_NIF_TYPE           interface_type;
    uint32                  nof_priorities;
    int                     tc, dp;
    int                     any_port_with_1_priority = 0;
    int                     total_mc_reserved_pds_sp0, total_mc_reserved_pds_sp1, mc_reserved_pds;
    SOC_TMC_EGR_QUEUING_DEV_TH  *dev_thresh = NULL;
    ARAD_EGR_FC_DEVICE_THRESH dev_fc_thresh, dev_fc_thresh_exact;
    ARAD_EGR_FC_OFP_THRESH  fc_mc_thresh, exact_fc_mc_thresh;
    bcm_cosq_egress_multicast_config_t sp_config;
    int                     nof_tc_to_sp0;
#endif
#if defined(BCM_ARAD_SUPPORT)
    ARAD_FC_ILKN_RETRANSMIT_CAL_CFG ilkn_rt_cal;
#endif
    SOC_TMC_FC_PFC_GENERIC_BITMAP generic_bm;

    uint32 profile;
    bcm_dpp_cosq_egress_queue_mapping_info_t *mapping_info = NULL;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    cosq_config = &_dpp_cosq_config[unit];    
    dev_id =  (unit);

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        is_coldboot = FALSE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_ALLOC(mapping_info, sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t), "egress queue mapping info handle memory");
    if (mapping_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress queue mapping info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    sal_memset(mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));

    if(!SOC_IS_JERICHO(unit)) { 

    BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_REC_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    BCMDNX_ALLOC(gen_cal_buff, (sizeof(SOC_TMC_FC_GEN_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "gen fc calender");
    if (gen_cal_buff == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate memory\n"), unit));
        goto err;
    }

    /* By default all zeros */
    SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
    
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_fc_generic_pfc_mapping_init(unit, SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps), &generic_bm));

    /* process OOB configuration */
    for (oob_if = 0; oob_if < SOC_DPP_CONFIG(unit)->tm.max_oob_ports; oob_if++) {
        if (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] == SOC_DPP_FC_CAL_MODE_DISABLE) {
            continue;
        }

        SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);

        if ( (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DPP_FC_CAL_MODE_RX_ENABLE) ||
          (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DPP_FC_CAL_MODE_TX_ENABLE) ) {
            cal_mode_ndx = (SOC_DPP_CONFIG(unit)->tm.fc_oob_type[oob_if] ==
              SOC_TMC_FC_CAL_TYPE_ILKN) ? SOC_TMC_FC_CAL_MODE_ILKN_OOB : SOC_TMC_FC_CAL_MODE_SPI_OOB;
            cal_if_info.enable = TRUE;           
        }


        /* OOB interfaces can only be uni-directional */
        if (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DPP_FC_CAL_MODE_RX_ENABLE) {

            rx_cal = &cosq_config->oob_cal[oob_if].rx;
            rx_cal->valid = TRUE;
            rx_cal->intf = oob_if;
            rx_cal->cal_mode_ndx = cal_mode_ndx;

#ifdef BCM_PETRAB_SUPPORT
          if(SOC_IS_PETRAB(unit)) {

            cal_if_info.cal_len = SOC_DPP_CONFIG(unit)->tm.fc_oob_calender_length[oob_if][SOC_TMC_CONNECTION_DIRECTION_RX];

            for (cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++) {
                SOC_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
                (cal_buff + cal_index)->destination = SOC_TMC_FC_REC_CAL_DEST_NONE;
                (cal_buff + cal_index)->id = 0;
            }
            
            cal_if_info.cal_reps = SOC_DPP_CONFIG(unit)->tm.fc_oob_calender_rep_count[oob_if][SOC_TMC_CONNECTION_DIRECTION_RX];

            if (is_coldboot) {
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_set,(unit, cal_mode_ndx, oob_if, &cal_if_info, cal_buff)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in OOB calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, oob_if, soc_sand_rc, rc));
                    goto err;
                }
            }
          }
#endif   
        }

        if (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DPP_FC_CAL_MODE_TX_ENABLE) {

          tx_cal = &cosq_config->oob_cal[oob_if].tx;
          tx_cal->valid = TRUE;
          tx_cal->intf = oob_if;
          tx_cal->cal_mode_ndx = cal_mode_ndx;

#ifdef BCM_PETRAB_SUPPORT
          if(SOC_IS_PETRAB(unit)) {

            cal_if_info.cal_len = SOC_DPP_CONFIG(unit)->tm.fc_oob_calender_length[oob_if][SOC_TMC_CONNECTION_DIRECTION_TX];

            for (cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++) {
                SOC_TMC_FC_GEN_CALENDAR_clear((gen_cal_buff + cal_index));
                (gen_cal_buff + cal_index)->source = SOC_TMC_FC_GEN_CAL_SRC_NONE;         
                (gen_cal_buff + cal_index)->id = 0;
            }

            cal_if_info.cal_reps = SOC_DPP_CONFIG(unit)->tm.fc_oob_calender_rep_count[oob_if][SOC_TMC_CONNECTION_DIRECTION_TX];

            if (is_coldboot) {
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_set,(unit, cal_mode_ndx, oob_if, &cal_if_info, gen_cal_buff)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in Gen OOB calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, oob_if, soc_sand_rc, rc));
                    goto err;
                }
            }
          }
#endif
        }

    }

    /* process Inband configuration */
    BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
    BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
    BCM_PBMP_ITER(ports_map, port_i) {

        /* skip stat ports */
        rv = soc_port_sw_db_flags_get(unit, port_i, &flags);
        BCMDNX_IF_ERR_EXIT(rv);
        if (SOC_PORT_IS_STAT_INTERFACE(flags)) {
            continue;
        }

    rc = bcm_petra_fap_port_parent_nif_get(unit, port_i, &interface_id); 
    if(rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error (%d) in getting parent nif for port %d\n"), unit, rc, port_i));
      goto err;
    }
#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit))
    {
        interface_type = arad_nif_id2type(interface_id);
        if (interface_type != ARAD_NIF_TYPE_XAUI && interface_type != ARAD_NIF_TYPE_RXAUI &&
            interface_type != ARAD_NIF_TYPE_10GBASE_R && interface_type != ARAD_NIF_TYPE_40G_XLGE &&
            interface_type != ARAD_NIF_TYPE_100G_CGE) {
          continue;
        }
    }
#endif
#ifdef BCM_PETRAB_SUPPORT
      if(SOC_IS_PETRAB(unit))
      {
        pb_nif_type = soc_pb_nif_id2type(interface_id);
        if (pb_nif_type != SOC_PB_NIF_TYPE_XAUI && pb_nif_type != SOC_PB_NIF_TYPE_RXAUI) {
          continue;
        }
      }
#endif

      fc_mode = SOC_DPP_CONFIG(unit)->tm.fc_inband_mode[port_i][SOC_TMC_CONNECTION_DIRECTION_RX];
      /* 0=DISABLE (TX default), 1=LLFC (RX default), 2=PFC, 3=SAFC */
      switch(fc_mode)
      {
      case 0:
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlLLFCReceive, 0);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        break;
      case 1:
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlLLFCReceive, 1);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        break;
      case 2:
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlPFCReceive, 1);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        break;
      case 3:
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlSAFCReceive, 1);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        break;
      default:
        break;
      }

      fc_mode = SOC_DPP_CONFIG(unit)->tm.fc_inband_mode[port_i][SOC_TMC_CONNECTION_DIRECTION_TX];
      /* 0=DISABLE (TX default), 1=LLFC (RX default), 2=PFC, 3=SAFC */
      switch(fc_mode)
      {
      case 0:
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlLLFCTransmit, 0);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        break;
      case 1:
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlLLFCTransmit, 1);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        break;
      case 2:
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlPFCTransmit, 1);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlPFCRefreshTime, -1);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        break;
      case 3:
        rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlSAFCTransmit, 1);
        if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
            goto err;
        }
        break;
      default:
        break;
      }
    }


    for (ilkn_if = 0; ilkn_if < SOC_DPP_CONFIG(unit)->tm.max_interlaken_ports; ilkn_if++) {
        /*
        if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] == SOC_DPP_FC_CAL_MODE_DISABLE) {
            continue;
        }
        */

        SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);

        if ( (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] &
                                                     SOC_DPP_FC_CAL_MODE_RX_ENABLE) ||
             (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] &
                                                     SOC_DPP_FC_CAL_MODE_TX_ENABLE) ) {
            cal_mode_ndx = SOC_TMC_FC_CAL_MODE_ILKN_INBND;

            cal_if_info.enable = TRUE;
        }

        /* inband interfaces can be bi-directional */
        if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DPP_FC_CAL_MODE_RX_ENABLE) {
            cal_if_info.cal_len = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_length[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_RX];

            for (cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++) {
                SOC_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
                (cal_buff + cal_index)->destination = SOC_TMC_FC_REC_CAL_DEST_NONE;
                (cal_buff + cal_index)->id = 0;
            }

            cal_if_info.cal_reps = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_rep_count[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_RX];

            if (is_coldboot) {
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_set,(unit, cal_mode_ndx, ilkn_if, &cal_if_info, cal_buff)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in Inband(Rx) calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, soc_sand_rc, rc));
                    goto err;
                }
            }

            rx_cal = &cosq_config->inband_cal[ilkn_if].rx;
            rx_cal->valid = TRUE;
            rx_cal->intf = ilkn_if;
            rx_cal->cal_mode_ndx = cal_mode_ndx;
        }


        /* inband-llfc configuration */
        SOC_TMC_FC_ILKN_LLFC_INFO_clear(&llfc_info);
        direction_ndx = SOC_TMC_FC_DIRECTION_REC;
        if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[ilkn_if] != SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE_DISABLE) {
            llfc_info.cal_channel = (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[ilkn_if] == SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE1) ?
                           SOC_TMC_FC_ILKN_CAL_LLFC_CH_0 : SOC_TMC_FC_ILKN_CAL_LLFC_CH_16N;
            llfc_info.multi_use_mask = 0;
        }
        else if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_llfc_mub_enable_mask[ilkn_if] != SOC_DPP_FC_INBAND_INTLKN_LLFC_MUB_DISABLE) {
            llfc_info.cal_channel = SOC_TMC_FC_ILKN_CAL_LLFC_NONE;
            llfc_info.multi_use_mask = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_llfc_mub_enable_mask[ilkn_if];
        }
        else {
            llfc_info.cal_channel = SOC_TMC_FC_ILKN_CAL_LLFC_NONE;
            llfc_info.multi_use_mask = 0;
        }

        llfc_ilkn_if = (ilkn_if == 0) ? SOC_TMC_NIF_ID_ILKN_0 : SOC_TMC_NIF_ID_ILKN_1;
        if (is_coldboot) {
#ifdef BCM_ARAD_SUPPORT
              if ((SOC_IS_ARAD(unit)) && (!SOC_IS_ARDON(unit))) {
                soc_sand_rc = arad_fc_ilkn_llfc_set(dev_id, llfc_ilkn_if, direction_ndx, &llfc_info);
              }
#endif
#ifdef BCM_PETRAB_SUPPORT
              if (SOC_IS_PETRAB(unit)) {
                soc_sand_rc = soc_pb_fc_ilkn_llfc_set(dev_id, llfc_ilkn_if, direction_ndx, &llfc_info);
              }
#endif            
              if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in Interlaken(Rx) llfc (%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, soc_sand_rc, rc));
                goto err;
            }
        }

        direction_ndx = SOC_TMC_FC_DIRECTION_GEN;
        if (is_coldboot) {
#ifdef BCM_ARAD_SUPPORT
              if ((SOC_IS_ARAD(unit)) && (!SOC_IS_ARDON(unit))) {
                soc_sand_rc = arad_fc_ilkn_llfc_set(dev_id, llfc_ilkn_if, direction_ndx, &llfc_info);
              }
#endif
#ifdef BCM_PETRAB_SUPPORT
              if (SOC_IS_PETRAB(unit)) {
                soc_sand_rc = soc_pb_fc_ilkn_llfc_set(dev_id, llfc_ilkn_if, direction_ndx, &llfc_info);
              }
#endif 
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in Interlaken(Tx) llfc (%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, soc_sand_rc, rc));
                goto err;
            }
        }

        if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DPP_FC_CAL_MODE_TX_ENABLE) {
            cal_if_info.cal_len = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_length[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_TX];

            for (cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++) {
                SOC_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
#ifdef BCM_ARAD_SUPPORT
                if(SOC_IS_ARAD(unit)){
                    (gen_cal_buff + cal_index)->source = SOC_TMC_FC_GEN_CAL_SRC_CONST;
                }
#endif /* BCM_ARAD_SUPPORT */
#ifdef BCM_PETRAB_SUPPORT
                if(SOC_IS_PETRAB(unit)){
                    (gen_cal_buff + cal_index)->source = SOC_PB_FC_GEN_CAL_SRC_NONE;
                }
#endif /* BCM_PETRAB_SUPPORT */
                (gen_cal_buff + cal_index)->id = 0;
            }

            cal_if_info.cal_reps = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_rep_count[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_TX];

            if (is_coldboot) {
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_set,(unit, cal_mode_ndx, ilkn_if, &cal_if_info, gen_cal_buff)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in Inband(Tx) calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, soc_sand_rc, rc));
                    goto err;
                }
            }

            tx_cal = &cosq_config->inband_cal[ilkn_if].tx;
            tx_cal->valid = TRUE;
            tx_cal->intf = ilkn_if;
            tx_cal->cal_mode_ndx = cal_mode_ndx;
        }
    }

#if defined(BCM_ARAD_SUPPORT)
    if(SOC_IS_ARAD_B0_AND_ABOVE(unit))
    {
      /* Handle ILKN Retransmit calendars for Arad B0 */
      for (ilkn_if = 0; ilkn_if < SOC_DPP_CONFIG(unit)->tm.max_interlaken_ports; ilkn_if++) {
        ARAD_FC_ILKN_RETRANSMIT_CAL_CFG_clear(&ilkn_rt_cal);
        switch(SOC_DPP_CONFIG(unit)->tm.fc_ilkn_rt_calendar_mode[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_RX])
        {
        case 0:
          ilkn_rt_cal.enable = 0;
          break;
        case 1:
          /* The RX calendar is hard coded in the HW */
          /* It needs 1 entry to support Retransmit on one interfaces */
          ilkn_rt_cal.enable = 1;
          ilkn_rt_cal.length = 1;
          break;
        case 2:
          /* The RX calendar is hard coded in the HW */
          /* It needs 3 entries to support Retransmit for both interfaces */
          ilkn_rt_cal.enable = 1;
          ilkn_rt_cal.length = 3; 
          break;
        default:
          ilkn_rt_cal.enable = 0;
          break;
        }
        soc_sand_rc = arad_fc_ilkn_retransmit_cal_set(dev_id, (ilkn_if == 0 ? ARAD_NIF_ILKN_ID_A : ARAD_NIF_ILKN_ID_B), ARAD_FC_DIRECTION_REC, &ilkn_rt_cal);        
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in ILKN Retransmit RX calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, soc_sand_rc, rc));
            goto err;
        }

        ARAD_FC_ILKN_RETRANSMIT_CAL_CFG_clear(&ilkn_rt_cal);
        switch(SOC_DPP_CONFIG(unit)->tm.fc_ilkn_rt_calendar_mode[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_TX])
        {
        case 0:
          ilkn_rt_cal.enable = 0;
          break;
        case 1:
          /* The TX calendar is hard coded in the SW */
          /* It needs 1 entry to support Retransmit on one interfaces */
          ilkn_rt_cal.enable = 1;
          ilkn_rt_cal.length = 1;
          break;
        case 2:
          /* The TX calendar is hard coded in the SW */
          /* It needs 2 entries to support Retransmit for both interfaces */
          ilkn_rt_cal.enable = 1;
          ilkn_rt_cal.length = 2; 
          break;
        default:
          ilkn_rt_cal.enable = 0;
          break;
        }
        soc_sand_rc = arad_fc_ilkn_retransmit_cal_set(dev_id, (ilkn_if == 0 ? ARAD_NIF_ILKN_ID_A : ARAD_NIF_ILKN_ID_B), ARAD_FC_DIRECTION_GEN, &ilkn_rt_cal);        
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in ILKN Retransmit TX calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, soc_sand_rc, rc));
            goto err;
        }
      }
    }
#endif

        if (SOC_IS_ARDON(unit)) {
            rc = arad_fc_init_shr_mapping(unit);
            BCMDNX_IF_ERR_EXIT(rc);
        }

      soc_sand_rc = arad_fc_init_pfc_mapping(unit);
      if (SOC_SAND_FAILURE(soc_sand_rc)) {
          rc = translate_sand_success_failure(soc_sand_rc);
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Failed to set PFC/TC mapping, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
          goto err;
      }

      } 

    profile = DPP_COSQ_PB_EGR_QUEUE_DEFAULT_PROFILE_MAP;

    /* Set default configuration */
    SOC_DPP_CORES_ITER(BCM_CORE_ALL, core) {
        rc = _bcm_petra_cosq_gport_egress_queue_mapping_hw_get(unit, profile, core, mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);

        /* state restored during warmboot */
        rc = _bcm_dpp_am_template_egress_queue_mapping_init(unit, profile, core, mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);
    }

      total_mc_reserved_pds_sp0 = 0;
      total_mc_reserved_pds_sp1 = 0;

      /* EGQ Threshold Settings */
      
      BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
      BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));

      BCM_PBMP_ITER(ports_map, port_i) {
          rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
          if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in getting port nof_priorities %d\n"), unit, rc, port_i));
            goto err;
        }

          if(nof_priorities == 1) {
              any_port_with_1_priority = 1;
              break;
          }
      }

      BCM_PBMP_ITER(ports_map, port_i) {

         /* init tc/dp map table */
         rc = _bcm_petra_cosq_gport_egress_map_init(unit, port_i);
         BCMDNX_IF_ERR_EXIT(rc);

         if(SOC_IS_JERICHO(unit)) {
             continue; 
         }

         /* set fc port thresholds */
         rc = _bcm_petra_cosq_fc_port_threshold_init(unit, port_i, &mc_reserved_pds);
         if(rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error (%d) in getting port rate %d\n"), unit, rc, port_i));
            goto err;
        }

         rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
        if(rc != BCM_E_NONE) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, error (%d) in getting parent nif for port %d\n"), unit, rc, port_i));
          goto err;
        }

         if (SOC_IS_ARDON(unit)) {
              total_mc_reserved_pds_sp0 += (mc_reserved_pds * nof_priorities);
         } else {
              if(any_port_with_1_priority == 1 || SOC_DPP_CONFIG(unit)->arad->init.dynamic_port_enable) {
                   total_mc_reserved_pds_sp0 += (mc_reserved_pds * nof_priorities);
              } else {
                   total_mc_reserved_pds_sp0 += ((mc_reserved_pds * nof_priorities) / 2);
                   total_mc_reserved_pds_sp1 += ((mc_reserved_pds * nof_priorities) / 2);
              }
         }
      }

      if(SOC_IS_JERICHO(unit)) {
          BCM_EXIT; 
      }

      /* Global Drop Thresholds */
      BCMDNX_ALLOC(dev_thresh, sizeof(SOC_TMC_EGR_QUEUING_DEV_TH), "_bcm_petra_cosq_fc_init.dev_thresh");
      if (dev_thresh == NULL) {        
          BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
      }
      SOC_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh);

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, dev_thresh)));
      if (SOC_SAND_FAILURE(soc_sand_rc)) {
          rc = translate_sand_success_failure(soc_sand_rc);
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
          goto err;
      }

      if (SOC_IS_ARDON(unit)) {
          dev_thresh->global.uc.descriptors = 6000;
          dev_thresh->global.mc.descriptors = 10000;
          dev_thresh->global.total.descriptors = 16000;
          dev_thresh->pool[0].mc.descriptors = 10000;
          dev_thresh->pool[1].mc.descriptors = 10000;
          
          dev_thresh->global.uc.buffers = 6000;
          dev_thresh->global.mc.buffers = 3000;
          dev_thresh->global.total.buffers = 6000;
          dev_thresh->pool[0].mc.buffers = 3000;
          dev_thresh->pool[1].mc.buffers = 3000;
          
          dev_thresh->pool[0].reserved.buffers = 400;
          dev_thresh->pool[1].reserved.buffers = 0;
      } else {
          dev_thresh->global.uc.descriptors = 12000;
          dev_thresh->global.mc.descriptors = 25500;
          dev_thresh->global.total.descriptors = 32000;
          dev_thresh->pool[0].mc.descriptors = 13000;
          dev_thresh->pool[1].mc.descriptors = 13000;
          
          dev_thresh->global.uc.buffers = 12000;
          dev_thresh->global.mc.buffers = 5800;
          dev_thresh->global.total.buffers = 12000;
          dev_thresh->pool[0].mc.buffers = 3000;
          dev_thresh->pool[1].mc.buffers = 3000;
          
          dev_thresh->pool[0].reserved.buffers = 600;
          dev_thresh->pool[1].reserved.buffers = 600;
      }

      if(total_mc_reserved_pds_sp0 > DPP_COSQ_ARAD_MAX_SP_PD_THRESH || total_mc_reserved_pds_sp1 > DPP_COSQ_ARAD_MAX_SP_PD_THRESH) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Allocated more Reserved Packet Descriptors than allowed by the device.")));
      }

      dev_thresh->pool[0].reserved.descriptors = total_mc_reserved_pds_sp0;
      dev_thresh->pool[1].reserved.descriptors = total_mc_reserved_pds_sp1;


      if (SOC_IS_ARDON(unit)) {
          if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
          {
            /* Discrete Partition */
                dev_thresh->pool_tc[0][0].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][1].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][2].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][3].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][5].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][6].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][7].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][0].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][1].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][2].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][3].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][5].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][6].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][7].mc.descriptors = 6500;

                dev_thresh->pool_tc[0][0].mc.buffers = 1500;
                dev_thresh->pool_tc[0][1].mc.buffers = 1500;
                dev_thresh->pool_tc[0][2].mc.buffers = 1500;
                dev_thresh->pool_tc[0][3].mc.buffers = 1500;
                dev_thresh->pool_tc[0][4].mc.buffers = 1500;
                dev_thresh->pool_tc[0][5].mc.buffers = 1500;
                dev_thresh->pool_tc[0][6].mc.buffers = 1500;
                dev_thresh->pool_tc[0][7].mc.buffers = 1500;
                dev_thresh->pool_tc[1][0].mc.buffers = 1500;
                dev_thresh->pool_tc[1][1].mc.buffers = 1500;
                dev_thresh->pool_tc[1][2].mc.buffers = 1500;
                dev_thresh->pool_tc[1][3].mc.buffers = 1500;
                dev_thresh->pool_tc[1][4].mc.buffers = 1500;
                dev_thresh->pool_tc[1][5].mc.buffers = 1500;
                dev_thresh->pool_tc[1][6].mc.buffers = 1500;
                dev_thresh->pool_tc[1][7].mc.buffers = 1500;

                dev_thresh->pool_tc[0][0].reserved.buffers = 50;
                dev_thresh->pool_tc[0][1].reserved.buffers = 50;
                dev_thresh->pool_tc[0][2].reserved.buffers = 50;
                dev_thresh->pool_tc[0][3].reserved.buffers = 50;
                dev_thresh->pool_tc[0][4].reserved.buffers = 50;
                dev_thresh->pool_tc[0][5].reserved.buffers = 50;
                dev_thresh->pool_tc[0][6].reserved.buffers = 50;
                dev_thresh->pool_tc[0][7].reserved.buffers = 50;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = 0;
                dev_thresh->pool_tc[1][5].reserved.buffers = 0;
                dev_thresh->pool_tc[1][6].reserved.buffers = 0;
                dev_thresh->pool_tc[1][7].reserved.buffers = 0;

          } else {

                /* Strict Priority */
                dev_thresh->pool_tc[0][0].mc.descriptors = 13000;
                dev_thresh->pool_tc[0][1].mc.descriptors = 10400;
                dev_thresh->pool_tc[0][2].mc.descriptors = 9100;
                dev_thresh->pool_tc[0][3].mc.descriptors = 7800;
                dev_thresh->pool_tc[0][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][5].mc.descriptors = 5200;
                dev_thresh->pool_tc[0][6].mc.descriptors = 3900;
                dev_thresh->pool_tc[0][7].mc.descriptors = 13000;
                dev_thresh->pool_tc[1][0].mc.descriptors = 13000;
                dev_thresh->pool_tc[1][1].mc.descriptors = 10400;
                dev_thresh->pool_tc[1][2].mc.descriptors = 9100;
                dev_thresh->pool_tc[1][3].mc.descriptors = 7800;
                dev_thresh->pool_tc[1][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][5].mc.descriptors = 5200;
                dev_thresh->pool_tc[1][6].mc.descriptors = 3900;
                dev_thresh->pool_tc[1][7].mc.descriptors = 13000;

                dev_thresh->pool_tc[0][0].mc.buffers = 3000;
                dev_thresh->pool_tc[0][1].mc.buffers = 2400;
                dev_thresh->pool_tc[0][2].mc.buffers = 2100;
                dev_thresh->pool_tc[0][3].mc.buffers = 1800;
                dev_thresh->pool_tc[0][4].mc.buffers = 1500;
                dev_thresh->pool_tc[0][5].mc.buffers = 1200;
                dev_thresh->pool_tc[0][6].mc.buffers = 900;
                dev_thresh->pool_tc[0][7].mc.buffers = 600;
                dev_thresh->pool_tc[1][0].mc.buffers = 3000;
                dev_thresh->pool_tc[1][1].mc.buffers = 2400;
                dev_thresh->pool_tc[1][2].mc.buffers = 2100;
                dev_thresh->pool_tc[1][3].mc.buffers = 1800;
                dev_thresh->pool_tc[1][4].mc.buffers = 1500;
                dev_thresh->pool_tc[1][5].mc.buffers = 1200;
                dev_thresh->pool_tc[1][6].mc.buffers = 900;
                dev_thresh->pool_tc[1][7].mc.buffers = 600;

                dev_thresh->pool_tc[0][0].reserved.buffers = 50;
                dev_thresh->pool_tc[0][1].reserved.buffers = 50;
                dev_thresh->pool_tc[0][2].reserved.buffers = 50;
                dev_thresh->pool_tc[0][3].reserved.buffers = 50;
                dev_thresh->pool_tc[0][4].reserved.buffers = 50;
                dev_thresh->pool_tc[0][5].reserved.buffers = 50;
                dev_thresh->pool_tc[0][6].reserved.buffers = 50;
                dev_thresh->pool_tc[0][7].reserved.buffers = 50;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = 0;
                dev_thresh->pool_tc[1][5].reserved.buffers = 0;
                dev_thresh->pool_tc[1][6].reserved.buffers = 0;
                dev_thresh->pool_tc[1][7].reserved.buffers = 0;
          }
      } else {
          if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
          {
            /* Discrete Partition */
                dev_thresh->pool_tc[0][0].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][1].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][2].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][3].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][4].mc.descriptors = any_port_with_1_priority ? 6500:0 ;
                dev_thresh->pool_tc[0][5].mc.descriptors = any_port_with_1_priority ? 6500:0 ;
                dev_thresh->pool_tc[0][6].mc.descriptors = any_port_with_1_priority ? 6500:0 ;
                dev_thresh->pool_tc[0][7].mc.descriptors = any_port_with_1_priority ? 6500:0 ;
                dev_thresh->pool_tc[1][0].mc.descriptors = 0;
                dev_thresh->pool_tc[1][1].mc.descriptors = 0;
                dev_thresh->pool_tc[1][2].mc.descriptors = 0;
                dev_thresh->pool_tc[1][3].mc.descriptors = 0;
                dev_thresh->pool_tc[1][4].mc.descriptors = any_port_with_1_priority ? 0:6500;
                dev_thresh->pool_tc[1][5].mc.descriptors = any_port_with_1_priority ? 0:6500;
                dev_thresh->pool_tc[1][6].mc.descriptors = any_port_with_1_priority ? 0:6500;
                dev_thresh->pool_tc[1][7].mc.descriptors = any_port_with_1_priority ? 0:6500;

                dev_thresh->pool_tc[0][0].mc.buffers = 1500;
                dev_thresh->pool_tc[0][1].mc.buffers = 1500;
                dev_thresh->pool_tc[0][2].mc.buffers = 1500;
                dev_thresh->pool_tc[0][3].mc.buffers = 1500;
                dev_thresh->pool_tc[0][4].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[0][5].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[0][6].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[0][7].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[1][0].mc.buffers = 0;
                dev_thresh->pool_tc[1][1].mc.buffers = 0;
                dev_thresh->pool_tc[1][2].mc.buffers = 0;
                dev_thresh->pool_tc[1][3].mc.buffers = 0;
                dev_thresh->pool_tc[1][4].mc.buffers = any_port_with_1_priority ? 0:1500;
                dev_thresh->pool_tc[1][5].mc.buffers = any_port_with_1_priority ? 0:1500;
                dev_thresh->pool_tc[1][6].mc.buffers = any_port_with_1_priority ? 0:1500;
                dev_thresh->pool_tc[1][7].mc.buffers = any_port_with_1_priority ? 0:1500;

                dev_thresh->pool_tc[0][0].reserved.buffers = 150;
                dev_thresh->pool_tc[0][1].reserved.buffers = 150;
                dev_thresh->pool_tc[0][2].reserved.buffers = 150;
                dev_thresh->pool_tc[0][3].reserved.buffers = 150;
                dev_thresh->pool_tc[0][4].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][5].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][6].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][7].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][5].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][6].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][7].reserved.buffers = any_port_with_1_priority ? 0:150;

          } else {

                /* Strict Priority - if 1 priority, then set thresholds in spaces of 12.5%, otherwise - 25% */
                dev_thresh->pool_tc[0][0].mc.descriptors = 13000;
                dev_thresh->pool_tc[0][1].mc.descriptors = any_port_with_1_priority ? 11375:9750;
                dev_thresh->pool_tc[0][2].mc.descriptors = any_port_with_1_priority ? 9750:6500;
                dev_thresh->pool_tc[0][3].mc.descriptors = any_port_with_1_priority ? 8125:3250;
                dev_thresh->pool_tc[0][4].mc.descriptors = any_port_with_1_priority ? 6500:0;
                dev_thresh->pool_tc[0][5].mc.descriptors = any_port_with_1_priority ? 4875:0;
                dev_thresh->pool_tc[0][6].mc.descriptors = any_port_with_1_priority ? 3250:0;
                dev_thresh->pool_tc[0][7].mc.descriptors = any_port_with_1_priority ? 1625:0;
                dev_thresh->pool_tc[1][0].mc.descriptors = 0;
                dev_thresh->pool_tc[1][1].mc.descriptors = 0;
                dev_thresh->pool_tc[1][2].mc.descriptors = 0;
                dev_thresh->pool_tc[1][3].mc.descriptors = 0;
                dev_thresh->pool_tc[1][4].mc.descriptors = any_port_with_1_priority ? 0:13000;
                dev_thresh->pool_tc[1][5].mc.descriptors = any_port_with_1_priority ? 0:9750;
                dev_thresh->pool_tc[1][6].mc.descriptors = any_port_with_1_priority ? 0:6500;
                dev_thresh->pool_tc[1][7].mc.descriptors = any_port_with_1_priority ? 0:3250;

                dev_thresh->pool_tc[0][0].mc.buffers = 3000;
                dev_thresh->pool_tc[0][1].mc.buffers = any_port_with_1_priority ? 2625:2250;
                dev_thresh->pool_tc[0][2].mc.buffers = any_port_with_1_priority ? 2250:1500;
                dev_thresh->pool_tc[0][3].mc.buffers = any_port_with_1_priority ? 1875:750;
                dev_thresh->pool_tc[0][4].mc.buffers = any_port_with_1_priority ? 1500:0;
                dev_thresh->pool_tc[0][5].mc.buffers = any_port_with_1_priority ? 1125:0;
                dev_thresh->pool_tc[0][6].mc.buffers = any_port_with_1_priority ? 750:0;
                dev_thresh->pool_tc[0][7].mc.buffers = any_port_with_1_priority ? 375:0;
                dev_thresh->pool_tc[1][0].mc.buffers = 0;
                dev_thresh->pool_tc[1][1].mc.buffers = 0;
                dev_thresh->pool_tc[1][2].mc.buffers = 0;
                dev_thresh->pool_tc[1][3].mc.buffers = 0;
                dev_thresh->pool_tc[1][4].mc.buffers = any_port_with_1_priority ? 0:3000;
                dev_thresh->pool_tc[1][5].mc.buffers = any_port_with_1_priority ? 0:2250;
                dev_thresh->pool_tc[1][6].mc.buffers = any_port_with_1_priority ? 0:1500;
                dev_thresh->pool_tc[1][7].mc.buffers = any_port_with_1_priority ? 0:750;

                dev_thresh->pool_tc[0][0].reserved.buffers = 150;
                dev_thresh->pool_tc[0][1].reserved.buffers = 150;
                dev_thresh->pool_tc[0][2].reserved.buffers = 150;
                dev_thresh->pool_tc[0][3].reserved.buffers = 150;
                dev_thresh->pool_tc[0][4].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][5].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][6].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][7].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][5].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][6].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][7].reserved.buffers = any_port_with_1_priority ? 0:150;
          }
      }
      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, dev_thresh)));
      if (SOC_SAND_FAILURE(soc_sand_rc)) {
          rc = translate_sand_success_failure(soc_sand_rc);
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
          goto err;
      }

      /* Global FC Thresholds */
      arad_ARAD_EGR_FC_DEVICE_THRESH_clear(&dev_fc_thresh);
      arad_ARAD_EGR_FC_DEVICE_THRESH_clear(&dev_fc_thresh_exact);

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit, &dev_fc_thresh)));
      if (SOC_SAND_FAILURE(soc_sand_rc)) {
          rc = translate_sand_success_failure(soc_sand_rc);
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
          goto err;
      }
     
      if (SOC_IS_ARDON(unit)) {
          dev_fc_thresh.scheduled.buffers = 3200;
          dev_fc_thresh.scheduled.descriptors = 3200;
          dev_fc_thresh.global.descriptors = 15700;
          dev_fc_thresh.global.buffers = 5800;
          dev_fc_thresh.unscheduled.descriptors = 9500;
          dev_fc_thresh.unscheduled.buffers = 2700;
          dev_fc_thresh.unscheduled_pool[0].descriptors = 9500;
          dev_fc_thresh.unscheduled_pool[1].descriptors = 9500;
          dev_fc_thresh.unscheduled_pool[0].buffers = 2700;
          dev_fc_thresh.unscheduled_pool[1].buffers = 2700;
      }else {
          dev_fc_thresh.scheduled.buffers = 6100;
          dev_fc_thresh.scheduled.descriptors = 6100;
          dev_fc_thresh.global.descriptors = 31500;
          dev_fc_thresh.global.buffers = 11800;
          dev_fc_thresh.unscheduled.descriptors = 25000;
          dev_fc_thresh.unscheduled.buffers = 5500;
          dev_fc_thresh.unscheduled_pool[0].descriptors = 12500;
          dev_fc_thresh.unscheduled_pool[1].descriptors = 12500;
          dev_fc_thresh.unscheduled_pool[0].buffers = 2750;
          dev_fc_thresh.unscheduled_pool[1].buffers = 2750;
      }
    
      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_set,(unit, &dev_fc_thresh, &dev_fc_thresh_exact)));
      if (SOC_SAND_FAILURE(soc_sand_rc)) {
          rc = translate_sand_success_failure(soc_sand_rc);
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
          goto err;
      }

      /* Global MC FC Thresholds */
      arad_ARAD_EGR_FC_OFP_THRESH_clear(&fc_mc_thresh);
      arad_ARAD_EGR_FC_OFP_THRESH_clear(&exact_fc_mc_thresh);
      for(tc = 0; tc < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); tc++)
      {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit,ARAD_EGR_Q_PRIO_ALL,tc,&fc_mc_thresh)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
            goto err;
        }
        
        if (SOC_IS_ARDON(unit)) {
            if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE) {
                /* Discrete Partition */
                fc_mc_thresh.mc.descriptors = 6250;
                fc_mc_thresh.mc.buffers = 1375;
            } else {
                /* Strict Priority */
                switch(tc) {
                case 0:
                    fc_mc_thresh.mc.descriptors = 12500;
                    fc_mc_thresh.mc.buffers = 2750;
                    break;
                case 1:
                    fc_mc_thresh.mc.descriptors = 10000;
                    fc_mc_thresh.mc.buffers = 2200;
                    break;
                case 2:
                    fc_mc_thresh.mc.descriptors = 8750;
                    fc_mc_thresh.mc.buffers = 1925;
                    break;
                case 3:
                    fc_mc_thresh.mc.descriptors = 7500;
                    fc_mc_thresh.mc.buffers = 1650;
                    break;
                case 4:
                    fc_mc_thresh.mc.descriptors = 6250;
                    fc_mc_thresh.mc.buffers = 1375;
                    break;
                case 5:
                    fc_mc_thresh.mc.descriptors = 5000;
                    fc_mc_thresh.mc.buffers = 1100;
                    break;
                case 6:
                    fc_mc_thresh.mc.descriptors = 3750;
                    fc_mc_thresh.mc.buffers = 825;
                    break;
                case 7:
                    fc_mc_thresh.mc.descriptors = 12500;
                    fc_mc_thresh.mc.buffers = 2750;
                    break;
                }
            }
        } else {
            if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
            {
              /* Discrete Partition */
              fc_mc_thresh.mc.descriptors = 6250;
              fc_mc_thresh.mc.buffers = 1375;
            } else {
              /* Strict Priority */
              switch(tc)
              {
              case 0:
              case 4:
                fc_mc_thresh.mc.descriptors = 12500;
                fc_mc_thresh.mc.buffers = 2750;
                break;
              case 1:
              case 5:
                fc_mc_thresh.mc.descriptors = 9375;
                fc_mc_thresh.mc.buffers = 2062;
                break;
              case 2:
              case 6:
                fc_mc_thresh.mc.descriptors = 6250;
                fc_mc_thresh.mc.buffers = 1375;
                break;
              case 3:
              case 7:
                fc_mc_thresh.mc.descriptors = 3125;
                fc_mc_thresh.mc.buffers = 687;
                break;
              } 
            }
        }
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_set,(unit,ARAD_EGR_Q_PRIO_ALL,tc,&fc_mc_thresh,&exact_fc_mc_thresh)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
            goto err;
        }
      }

      /* MC TC to SP Mapping */
      if (SOC_IS_ARDON(unit)) {
      /* TC0-TC7 to SP0 */
          nof_tc_to_sp0 = 8;
      } else {
          /* TC0-TC3 to SP0 */
          nof_tc_to_sp0 = 4;
      }
      sp_config.unscheduled_se = 1;   /* Pool eligibility */
      sp_config.unscheduled_sp = bcmCosqEgressMulticastServicePool0;   /* Pool ID */
      for(tc = 0; tc < nof_tc_to_sp0 ; tc++)
      {
        sp_config.priority = tc;         /* TC group */
        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++)
        {
          rc = bcm_petra_cosq_gport_egress_multicast_config_set(unit, 0, tc, dp, BCM_COSQ_MULTICAST_UNSCHEDULED, &sp_config);
          BCMDNX_IF_ERR_EXIT(rc);
        }
      }

       /* TC4-TC7 to SP0\SP1 */
      sp_config.unscheduled_se = 1;   /* Pool eligibility */
      sp_config.unscheduled_sp = ((any_port_with_1_priority == 1 || SOC_DPP_CONFIG(unit)->arad->init.dynamic_port_enable == 1) ? bcmCosqEgressMulticastServicePool0 : bcmCosqEgressMulticastServicePool1);   /* Pool ID */
      for(tc = nof_tc_to_sp0; tc < 8; tc++)
      {
        sp_config.priority = tc;         /* TC group */
        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++)
        {
          rc = bcm_petra_cosq_gport_egress_multicast_config_set(unit, 0, tc, dp, BCM_COSQ_MULTICAST_UNSCHEDULED, &sp_config);
          BCMDNX_IF_ERR_EXIT(rc);
        }
      }
     
      /* Enable device-level flow control */
      rc = bcm_petra_cosq_control_set(unit, 0, 0, bcmCosqControlFlowControlEnable, 1);
      if(rc != BCM_E_NONE) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, error(%d) in enabling device-level flow control\n"), unit, rc));
          goto err;
      }

    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    if (gen_cal_buff != NULL) {
       BCM_FREE(gen_cal_buff);
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    if (gen_cal_buff != NULL) {
       BCM_FREE(gen_cal_buff);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCM_FREE(dev_thresh);
    BCM_FREE(cal_buff);
    BCM_FREE(gen_cal_buff);
    BCM_FREE(mapping_info);

    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_ARAD_SUPPORT

int
_bcm_arad_cosq_get_queue_mc_sp(int unit, int local_port_id, int cosq, int* sp)
{
    uint32  soc_sand_rc = SOC_SAND_OK;
    int tc_ndx, dp_ndx, found, rv;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;
    ARAD_EGR_QUEUING_MC_COS_MAP mc_tc_map;
    int profile = 0;
    uint32 tm_port;
    int core;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if(sp == NULL)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("SP cannot be NULL")));
    }
    *sp = -1;

    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_tm_port_get(unit, local_port_id, &tm_port, &core));

    /* PORT --> PROFILE */
    rv = (MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_profile_map_get,(unit, core, tm_port, (uint32*)&profile)));
    BCMDNX_IF_ERR_EXIT(rv);
   
    found = FALSE;
    for(tc_ndx = 0; tc_ndx < DPP_DEVICE_COSQ_EGR_NOF_TC; tc_ndx++) {
      for(dp_ndx = 0; dp_ndx < DPP_DEVICE_COSQ_EGR_NOF_DP; dp_ndx++) {
        /* PROFILE/QUEUE --> TC/DP */
        rv = (MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_prio_get,(unit,core,ARAD_EGR_MCAST_TO_UNSCHED,tc_ndx,dp_ndx,profile,&egr_prio)));
        BCMDNX_IF_ERR_EXIT(rv);

        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        if(cosq == egr_prio.tc) { 
          /* TC/DP --> MC SP */
          soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_cos_map_get,(unit, tc_ndx, dp_ndx, &mc_tc_map)));
          BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
          
          if(found == TRUE)
          {
            if(*sp != mc_tc_map.pool_id)
            {
              BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Egress queue (Port %d TC %d) cannot be mapped to use more than one service pool"), local_port_id, cosq));
            }
          }
          else
          {
            /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
            /* coverity[uninit_use:FALSE] */
            *sp = mc_tc_map.pool_id;
          }

          found = TRUE;
        }
      }
    }

    if(!found){
      /* Couldnt find service pool mapping */
      *sp = -1;
    }

exit:
    BCMDNX_FUNC_RETURN;  
}

int
_bcm_arad_cosq_update_reserved_pd_threshold_all_sps(int unit)
{
    int     rc = BCM_E_NONE;
    int     total_pd_sp0 = 0, total_pd_sp1 = 0;
    SOC_TMC_EGR_QUEUING_DEV_TH  *dev_thresh = NULL;
    uint32  soc_sand_rc = SOC_SAND_OK;
    bcm_dpp_cosq_egress_thresh_key_info_t thresh_key;
    int pool_id = 0, tc;
    bcm_port_t               port_i = 0;
    soc_port_if_t interface;  
    uint32  nof_priorities;
    pbmp_t ports_bm;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if (!SOC_IS_ARAD(unit)) return BCM_E_NONE;

    BCMDNX_ALLOC(dev_thresh, sizeof(SOC_TMC_EGR_QUEUING_DEV_TH), "_bcm_arad_cosq_update_reserved_pd_threshold_all_sps.dev_thresh");
    if (dev_thresh == NULL) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
    }
    SOC_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Recalculate both Service Pools values */
    rc = soc_port_sw_db_valid_ports_get(unit, 0, &ports_bm);
    BCMDNX_IF_ERR_EXIT(rc);

    PBMP_ITER(ports_bm, port_i)
    {  
      /* skip ERP, OAMP, OLP, and non real ports (NOCXN)*/
      BCMDNX_IF_ERR_EXIT(soc_port_sw_db_interface_type_get(unit, port_i, &interface));
      if((interface == SOC_PORT_IF_ERP) || (interface == SOC_PORT_IF_OAMP) || (interface == SOC_PORT_IF_OLP) || (interface == SOC_PORT_IF_NOCXN) || (port_i >= SOC_TMC_NOF_FAP_PORTS_MAX)){
        continue;
      }
     
      rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
      BCMDNX_IF_ERR_EXIT(rc);

      for (tc = 0; tc < nof_priorities; tc++) 
      {
        /* Validate that only one SP is used */
        /* Return the used SP ID */
        rc = _bcm_arad_cosq_get_queue_mc_sp(unit, port_i, tc, &pool_id);
        BCMDNX_IF_ERR_EXIT(rc);

        if(pool_id == -1) continue;

        /* PORT --> RESERVED MC PD */
        rc = _bcm_dpp_am_template_cosq_egr_thresh_data_get(unit,port_i,&thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);

        if(thresh_key.unsch_drop_packet_descriptors_available_tc[tc] > DPP_COSQ_ARAD_MAX_QUEUE_PD_THRESH)
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Egress queue (Port %d TC %d) reserved PD value (%d) is above max (%d)"), 
                                            port_i, tc, thresh_key.unsch_drop_packet_descriptors_available_tc[tc], DPP_COSQ_ARAD_MAX_QUEUE_PD_THRESH));
        }

        if(pool_id == 0) {
          total_pd_sp0 += thresh_key.unsch_drop_packet_descriptors_available_tc[tc];
        }
        else if(pool_id == 1) {
          total_pd_sp1 += thresh_key.unsch_drop_packet_descriptors_available_tc[tc];
        }
      }
    } /* End of BCM_PBMP_ITER */

    if(total_pd_sp0 > DPP_COSQ_ARAD_MAX_SP_PD_THRESH)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 0 max reserved PD value (%d) is above max (%d)"),
                                        total_pd_sp0, DPP_COSQ_ARAD_MAX_SP_PD_THRESH));
    }
    if(total_pd_sp1 > DPP_COSQ_ARAD_MAX_SP_PD_THRESH) 
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 1 max reserved PD value (%d) is above max (%d)"),
                                        total_pd_sp0, DPP_COSQ_ARAD_MAX_SP_PD_THRESH));
    }

    /* Update the total with the new value */  
    if(dev_thresh->pool[0].reserved.descriptors != total_pd_sp0)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 0 max reserved PD value (%d) is different than sum of queues thresholds (%d)"),
                                        dev_thresh->pool[0].reserved.descriptors, total_pd_sp0));
    }
    if(dev_thresh->pool[1].reserved.descriptors != total_pd_sp1)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 1 max reserved PD value (%d) is different than sum of queues thresholds (%d)"),
                                        dev_thresh->pool[1].reserved.descriptors, total_pd_sp1));
    }
    
exit:
    BCM_FREE(dev_thresh);
    BCMDNX_FUNC_RETURN;
}

#endif



int
_bcm_petra_cosq_qid_type_get(int unit, int core, int base_qid, int *gport,
                             int *is_multicast, int *is_unicast, int *is_isq, int *queue_type)
{
    int                 rc = BCM_E_NONE;
    int                 soc_sand_rc;
    SOC_SAND_U32_RANGE      queue_range;
    SOC_TMC_ITM_INGRESS_SHAPE_INFO isp_info;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_multicast != NULL) {
        (*is_multicast) = FALSE;
    }
    if (is_unicast != NULL) {
        (*is_unicast) = FALSE;
    }
    if (is_isq != NULL) {
        (*is_isq) = FALSE;
    }

    if (queue_type != NULL) {
        (*queue_type) = 0;
    }

    /* Get multicast queue id range */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_enhanced_get,(unit, &queue_range)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    if ( (base_qid >= queue_range.start) && (base_qid <= queue_range.end) ) {
        BCM_GPORT_MCAST_QUEUE_GROUP_SET((*gport), base_qid);
        if (is_multicast != NULL) {
            (*is_multicast) = TRUE;
        }
        if (queue_type != NULL) {
            (*queue_type) = DPP_DEVICE_COSQ_QUEUE_REGION_MULTICAST;
        }
    }
    else {
        /* Get ISQ queue range */
        SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, &isp_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if ((base_qid >= isp_info.q_range.q_num_low) && (base_qid<=isp_info.q_range.q_num_high)) {
            BCM_COSQ_GPORT_ISQ_SET((*gport), base_qid);
            if (is_isq != NULL) {
                (*is_isq) = TRUE;
            }
            if (queue_type != NULL) {
                (*queue_type) = DPP_DEVICE_COSQ_QUEUE_REGION_ISQ;
            }
        } 
        else {
            BCM_GPORT_UNICAST_QUEUE_GROUP_SET((*gport), base_qid);
            if (is_unicast != NULL) {
                (*is_unicast) = TRUE;
            }
            if (queue_type != NULL) {
                (*queue_type) = DPP_DEVICE_COSQ_QUEUE_REGION_UNICAST;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * local Functions
 */
STATIC int
_bcm_petra_cosq_gport_ucast_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_QUEUE_INFO queue_info;    
    SOC_TMC_ITM_QT_NDX sched_mode;
    uint32 base_queue, queue;
    bcm_dpp_cosq_voq_config_t *voq_config;
    int core = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_ITM_QUEUE_INFO_clear(&queue_info);

    /* consistency checks */
    rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, mode, &sched_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    if (sched_mode == SOC_TMC_ITM_QT_NDX_INVALID){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid mode %d"), unit, mode));
    }

    if (weight != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid weight %d"), unit, weight));
    }

    /* Validate Queue */
    base_queue = BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) ? BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport) :
      (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) ? BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport) :
       BCM_COSQ_GPORT_ISQ_QID_GET(gport));

    /* consistency check to determine if {gport, cosq} is valid */    
    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_alloc(unit, &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue));
    if (voq_config ==  NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) voq(%d) gport add voq group internal state allocation error\n"), unit, base_queue));
        rc = BCM_E_RESOURCE;
        BCMDNX_IF_ERR_EXIT(rc);     
    }
    if (voq_config->num_cos == 0) {
        /* Not initalized VOQ */
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Invalid VOQ 0x%x parameter\n"),
                              unit, gport));
        rc = BCM_E_NOT_FOUND;
        BCMDNX_IF_ERR_EXIT(rc);     
    }
    if (cosq < 0 || cosq >= voq_config->num_cos) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "Unit(%d) Invalid cosq %d parameter\n"),
                                unit, cosq));
          rc = BCM_E_PARAM;
          BCMDNX_IF_ERR_EXIT(rc);     
    }
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARADPLUS(unit)) { /* check if the base queue is mapped to a module using the same credit module as the requested profile */
        uint32 credit_value_type = ARAD_PLUS_FAP_CREDIT_VALUE_LOCAL, found_type;
        int perform_check = 1;
        if (!BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) { /* FMQs who use local credit */
            /* find the credit value used according to the fap mapped to the queue */
            SOC_TMC_IPQ_QUARTET_MAP_INFO queue_map_info;
            uint32 fap_id;
            int local_fap_id;

            SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
                (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_queue), &queue_map_info)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                perform_check = 0;
            } else {
                if (ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
                    fap_id = queue_map_info.fap_id;
                } else { /* direct mapping mode */
                    bcm_gport_t sysport_gport, modport_gport;
                    BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, queue_map_info.system_physical_port);
                    BCMDNX_IF_ERR_EXIT(bcm_petra_stk_sysport_gport_get(unit, sysport_gport, &modport_gport));
                    fap_id = BCM_GPORT_MODPORT_MODID_GET(modport_gport);
                }
                /* We found the mapped FAP ID, now find the credit value type from it, if it is not the local fap */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &local_fap_id));
                if (local_fap_id != fap_id) {
                    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_module_to_credit_worth_map_get, (unit, fap_id, &credit_value_type)));
                }
            }
            if (perform_check) {
                SOC_TMC_ITM_CR_REQUEST_INFO cr_req_info;
                SOC_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
                BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_request_get, (unit, sched_mode, &cr_req_info)));
                found_type = cr_req_info.is_remote_credit_value ? ARAD_PLUS_FAP_CREDIT_VALUE_REMOTE : ARAD_PLUS_FAP_CREDIT_VALUE_LOCAL;
                if (credit_value_type != found_type) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The credit size of the selected profile is not of the type expected for unit %u mapped to the queue: %s."
                      "\nThe credit size of a unit can be set using bcm_cosq_credit_size_set()"),
                      (unsigned)fap_id, credit_value_type == ARAD_PLUS_FAP_CREDIT_VALUE_LOCAL ? "local" : "remote"));
                } 
            }
        }
    }
#endif /* BCM_ARAD_SUPPORT */
    queue = base_queue + cosq;

    /* retrieve current configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, queue, &queue_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* update configuration */
    queue_info.cr_req_type_ndx = sched_mode;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_set,(unit, core, queue, &queue_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_e2e_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 soc_sand_rc;
    bcm_dpp_cosq_gport_info_t child_info;
    int flow_id_index;
    bcm_dpp_cosq_class_info_t info;
    int updated_type;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info;
    SOC_TMC_SCH_FLOW exact_flow_config;
    SOC_TMC_SCH_SE_INFO *parent_se = NULL;
    SOC_TMC_SCH_FLOW *parent_flow_config = NULL;
    bcm_dpp_cosq_config_t   *cosq_config;
    bcm_dpp_cosq_flow_config_t *flow_state_config;



    BCMDNX_INIT_FUNC_DEFS;
    /* Consitency checks */
    

    cosq_config = &_dpp_cosq_config[unit];    
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    sal_memset(&child_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    child_info.flow_config = NULL;
    child_info.se_config = NULL;

    BCMDNX_ALLOC(child_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(child_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(parent_flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_se, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (parent_flow_config == NULL) ||(parent_se == NULL) || 
         (child_info.flow_config == NULL) || (child_info.se_config == NULL) ) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    SOC_TMC_SCH_SE_INFO_clear(parent_se);
    SOC_TMC_SCH_SE_INFO_clear(child_info.se_config);
    SOC_TMC_SCH_FLOW_clear(parent_flow_config);
    SOC_TMC_SCH_FLOW_clear(child_info.flow_config);

    /* validate child element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, gport, cosq, dpp_device_cosq_gport_child_element, &child_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* validate hookup */
    /* get parent element scheduling mode */
    flow_id_index = (child_info.is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info.flow_config->sub_flow[flow_id_index].credit_source);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, cs_info->id, parent_se, parent_flow_config)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_get(unit,
                                                     &(_dpp_cosq_config[unit].flow_hd),
                                                     child_info.actual_flow_id);
    
    if (flow_state_config ==  NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) gport add flow internal state allocation error"), unit, child_info.actual_flow_id));
    }
    flow_state_config->weight = weight;
    flow_state_config->mode = mode;

   if (cs_info->id != cosq_config->default_se) {

       /* get parent element information for child hookup corresponding to child scheduling mode */
       rc = _bcm_petra_cosq_credit_class_info_get(unit, parent_se, mode, &info);
       if (rc != BCM_E_NONE) {
           BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving parent info corresponding to child element scheduling mode, error 0x%x"), unit, rc));
       }

       rc = _bcm_petra_cosq_credit_class_weight_validate(unit, weight, &info, &updated_type);
       if (rc != BCM_E_NONE) {
           BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in adjusting flow type for weight/weight mode, error 0x%x"), unit, rc));
       }
       
       /* hookup hierarchy */
       cs_info->se_type = parent_se->type;
       cs_info->id = parent_se->id;
       switch (cs_info->se_type) {
       case SOC_TMC_SCH_SE_TYPE_HR:
           cs_info->se_info.hr.sp_class = updated_type;
           cs_info->se_info.hr.weight = weight;
           break;
           
       case SOC_TMC_SCH_SE_TYPE_CL:
            cs_info->se_info.cl.sp_class = updated_type;
            cs_info->se_info.cl.weight = weight;
            break;
            
       default:
           break;
       }
   }
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, child_info.flow_id, child_info.flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up flow %d\n"), unit, child_info.flow_id));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_flow_state(unit, child_info.actual_flow_id);
#endif /* BCM_WARM_BOOT_SUPPORT */


    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(parent_flow_config);
    BCM_FREE(parent_se);
    BCM_FREE(child_info.flow_config);
    BCM_FREE(child_info.se_config);
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_e2e_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight)
{
    bcm_error_t                      rc = BCM_E_NONE;    
    uint32                           soc_sand_rc;
    bcm_dpp_cosq_gport_info_t        gport_info;
    bcm_dpp_cosq_config_t           *cosq_config;
    SOC_TMC_SCH_SE_INFO                 *parent_se = NULL;
    SOC_TMC_SCH_FLOW                    *parent_flow_config = NULL;
    int                              flow_id_index, gport_mode;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    bcm_dpp_cosq_class_info_t        info;
    bcm_dpp_cosq_flow_config_t      *flow_state_config;


    BCMDNX_INIT_FUNC_DEFS;
    /* Consitency checks */
    cosq_config = &_dpp_cosq_config[unit];    

    sal_memset(&gport_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    gport_info.flow_config = NULL;
    gport_info.se_config = NULL;

    BCMDNX_ALLOC(gport_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(gport_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(parent_flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_se, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (parent_flow_config == NULL) ||(parent_se == NULL) || 
         (gport_info.flow_config == NULL) || (gport_info.se_config == NULL) ) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    SOC_TMC_SCH_SE_INFO_clear(parent_se);
    SOC_TMC_SCH_SE_INFO_clear(gport_info.se_config);
    SOC_TMC_SCH_FLOW_clear(parent_flow_config);
    SOC_TMC_SCH_FLOW_clear(gport_info.flow_config);

    /* validate child element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, gport, cosq, dpp_device_cosq_gport_child_element, &gport_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* get child element scheduling mode */
    rc = _bcm_petra_cosq_mode_get(unit, gport_info.flow_config, gport_info.is_sf2, &gport_mode);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retrieving child element scheduling mode, error 0x%x"), unit, rc));
    }

    (*mode) = gport_mode;

    /* retreive weight */
    /* get parent element scheduling mode */
    flow_id_index = (gport_info.is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(gport_info.flow_config->sub_flow[flow_id_index].credit_source);

    if (cs_info->id == cosq_config->default_se) {
        /* retreive element weight from state */
        flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_get(unit,
                                 &(_dpp_cosq_config[unit].flow_hd), gport_info.actual_flow_id);

        if (flow_state_config == NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) flow_id(%d) sched set flow internal state retrieve error\n"), unit, gport_info.flow_id));
            BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
        }
        (*weight) = flow_state_config->weight;
        (*mode)   = flow_state_config->mode;
    }
    else {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, cs_info->id, parent_se, parent_flow_config)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        /* get parent element information for child hookup corresponding to child scheduling mode */
        rc = _bcm_petra_cosq_credit_class_info_get(unit, parent_se, gport_mode, &info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retrieving parent info corresponding to child element scheduling mode, error 0x%x"), unit, rc));
        }

        /* determine parent weight mode */
        if (info.weight_mode == SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST) {
            (*weight) = 0;
        }
        else if (info.weight_mode == SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW) {
            switch (cs_info->se_type) {
                case SOC_TMC_SCH_SE_TYPE_HR:
                    (*weight) = cs_info->se_info.hr.weight;
                    break;

                case SOC_TMC_SCH_SE_TYPE_CL:
                    (*weight) = cs_info->se_info.cl.weight;
                    break;

                default:
                    (*weight) = 0;
                    break;
            }
        }
        else if (info.weight_mode == SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) {
            rc = _bcm_petra_cosq_cl_sched_weight_get(unit, cs_info, &info, weight);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (info.weight_mode == SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) {
            rc = _bcm_petra_cosq_cl_sched_weight_get(unit, cs_info, &info, weight);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(parent_flow_config);
    BCM_FREE(parent_se);
    BCM_FREE(gport_info.flow_config);
    BCM_FREE(gport_info.se_config);
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_ucast_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_QUEUE_INFO queue_info;    
    uint32 base_queue, queue;
    bcm_dpp_cosq_voq_config_t *voq_config;
    int core = BCM_CORE_ALL;


    BCMDNX_INIT_FUNC_DEFS;
    /* consistency checks */
    if (mode == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointer(mode) not being passed")));
    }
    SOC_TMC_ITM_QUEUE_INFO_clear(&queue_info);

    /* consistency check to determine if {gport, cosq} is valid */  
    base_queue = BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) ? BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport) :
      (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) ? BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport) :
       BCM_COSQ_GPORT_ISQ_QID_GET(gport));

    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_alloc(unit, &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue));
    if (voq_config ==  NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) voq(%d) gport add voq group internal state allocation error\n"), unit, base_queue));
        rc = BCM_E_RESOURCE;
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (voq_config->num_cos == 0) {
        /* Not initalized VOQ */
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Invalid VOQ 0x%x parameter\n"),
                              unit, gport));
        rc = BCM_E_NOT_FOUND;
        BCMDNX_IF_ERR_EXIT(rc);     
    }

    if (cosq < 0 || cosq >= voq_config->num_cos) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "Unit(%d) Invalid cosq %d parameter\n"),
                                unit, cosq));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);     
    }    

    if (weight != NULL) {
        (*weight) = 0;
    }    
    
    queue = base_queue + cosq;

    /* retreive current configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, queue, &queue_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_DPP_UNIT_CHECK(unit);
    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */

    rc = _bcm_petra_cosq_user_q_type_to_delay_tolerance(unit, queue_info.cr_req_type_ndx, mode);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Schedule mode for Channelized NIF port and CPU interface. 
 * Choose Strict priority to Connect to. SP range: H/L and  
 * Medium (PB only)
 */
STATIC int
_bcm_petra_cosq_gport_egress_scheduler_port_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port, rate;    
    int core;
    SOC_TMC_EGR_OFP_SCH_INFO info;    

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* clear */
    SOC_TMC_EGR_OFP_SCH_INFO_clear(&info);

    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }
      
    /* valid */
    if (!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP2)) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range is SP0-SP2")));
    }

    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Set egress ofp scheduler info */
    rc = _bcm_petra_cosq_mode_sp_to_egr_ofp_interface_prio(unit, mode,&(info.nif_priority));
    BCMDNX_IF_ERR_EXIT(rc);
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_set,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* update port sw rate to mark calendar as modified */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_single_port_rate_sw_get,(unit, core, tm_port, &rate)));  
    BCM_SAND_IF_ERR_EXIT(bcm_petra_cosq_gport_bandwidth_set(unit, gport, 0, 0, rate, BCM_COSQ_BW_NOT_COMMIT));

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Schedule mode for Channelized NIF port and CPU interface. 
 * Get the strict priority that the port is connected to. 
 * SP range: H/L and Medium (PB only)
 */
STATIC int
_bcm_petra_cosq_gport_egress_scheduler_port_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;
    int core, is_high_priority;
    SOC_TMC_EGR_OFP_SCH_INFO info;       

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
    
    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }

    /* clear */
    SOC_TMC_EGR_OFP_SCH_INFO_clear(&info);
      
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_is_high_priority_port_get,(unit, core, tm_port, &is_high_priority)));

    if (is_high_priority) {
        *mode = BCM_COSQ_SP0;
    } else {
        *mode = BCM_COSQ_SP1;
    }

    *weight = -1;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Fill in the structure of wfq scheduler given
 * bcm mode (SP) and weight
 */
STATIC int
_bcm_petra_cosq_egress_fill_ofp_wfq_sch_from_mode_weight(uint8 is_ucast_egress_queue,
                                                        int mode,
                                                        int weight,
                                                        SOC_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    BCMDNX_NULL_CHECK(sch_wfq_p);

    if (mode != -1) {
        /* SP */
        /* 0 - indicate SP High */
        /* > 0 - indicate lower priority */
        if (is_ucast_egress_queue == SOC_SAND_TRUE) {
            sch_wfq_p->sched_weight = (mode == DPP_COSQ_EGR_OFP_SCH_SP_HIGH) ? 0:1;
            sch_wfq_p->unsched_weight = (mode == DPP_COSQ_EGR_OFP_SCH_SP_HIGH) ? 1:0;
        } else {
            sch_wfq_p->sched_weight = (mode == DPP_COSQ_EGR_OFP_SCH_SP_HIGH) ? 1:0;  
            sch_wfq_p->unsched_weight = (mode == DPP_COSQ_EGR_OFP_SCH_SP_HIGH) ? 0:1;  
        }
    } else {
        /* Take weight into consideration */
        if (is_ucast_egress_queue == SOC_SAND_TRUE) {
            sch_wfq_p->sched_weight = weight;
        } else {
            sch_wfq_p->unsched_weight = weight;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Fill in the bcm mode (SP) and weight from structure of wfq scheduler
 * 
 */
STATIC int
_bcm_petra_cosq_egress_fill_mode_weight_from_ofp_wfq_sch(uint8 is_ucast_egress_queue,
                                                        SOC_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p,
                                                        int *mode,
                                                        int *weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    BCMDNX_NULL_CHECK(sch_wfq_p);
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);

    if (is_ucast_egress_queue == SOC_SAND_TRUE) {
        if (sch_wfq_p->sched_weight == 0) {
            *mode = DPP_COSQ_EGR_OFP_SCH_SP_HIGH;
            *weight = -1;
        } else {
            if (sch_wfq_p->unsched_weight == 0) {
                *mode = DPP_COSQ_EGR_OFP_SCH_SP_LOW;
                *weight = -1;
            } else {
                /* Take weight into consideration */
                *mode = -1;
                *weight = sch_wfq_p->sched_weight;
            }
        }
    } else {
        if (sch_wfq_p->unsched_weight == 0) {
            *mode = DPP_COSQ_EGR_OFP_SCH_SP_HIGH;
            *weight = -1;
        } else {
            if (sch_wfq_p->sched_weight == 0) {
                *mode = DPP_COSQ_EGR_OFP_SCH_SP_LOW;
                *weight = -1;
            } else {
                /* Take weight into consideration */
                *mode = -1;
                *weight = sch_wfq_p->unsched_weight;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Attach Port-Priority of a given port priority TC-X to the TCG-Y
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_QUEUING_TCG_INFO info;
    SOC_TMC_EGR_Q_PRIO prio;
    SOC_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);


    if ((!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP7)) &&
        (!(mode >= SOC_TMC_TCG_MIN && mode <= SOC_TMC_TCG_MAX))) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range must be tcg_ndx (0-7) or SP0-SP7")));
    }
   
    tcg = (mode >= BCM_COSQ_SP0) ? (mode-BCM_COSQ_SP0):mode;
    /* Clear */
    SOC_TMC_EGR_QUEUING_TCG_INFO_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_ofp_tcg_get,(unit,core,tm_port,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.tcg_ndx[prio] = tcg;
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_ofp_tcg_set,(unit,core,tm_port,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get TCG-Y Port-Priority of a given port priority TC-X.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_sched_get(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int *mode,
                                               int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_QUEUING_TCG_INFO info;
    SOC_TMC_EGR_Q_PRIO prio;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);


    /* Clear */
    SOC_TMC_EGR_QUEUING_TCG_INFO_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_ofp_tcg_get,(unit,core,tm_port,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *mode = info.tcg_ndx[prio] + BCM_COSQ_SP0;
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Attach Port-Priority of a given port priority (HR) TC-X to the TCG-Y
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, ofp_ndx;    
    int core;
    SOC_TMC_SCH_PORT_INFO info;
    SOC_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);


    if ((!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP7)) &&
        (!(mode >= SOC_TMC_TCG_MIN && mode <= SOC_TMC_TCG_MAX))) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range must be tcg_ndx (0-7) or SP0-SP7")));
    }
   
    tcg = (mode >= BCM_COSQ_SP0) ? (mode-BCM_COSQ_SP0):mode;

    /* Clear */
    SOC_TMC_SCH_PORT_INFO_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_get,(unit,core,ofp_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.tcg_ndx[cosq] = tcg;
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit,core,ofp_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get TCG-Y Port-Priority of a given port priority TC-X.
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, ofp_ndx;    
    int core;
    SOC_TMC_SCH_PORT_INFO info;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Clear */
    SOC_TMC_SCH_PORT_INFO_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_get,(unit,core,ofp_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *mode = info.tcg_ndx[cosq] + BCM_COSQ_SP0;
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_egress_fill_tcg_weight_from_mode_weight(int unit,
                                                        int mode,
                                                        int weight,
                                                        uint32* tcg_weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (mode == BCM_COSQ_SP0) {
      *tcg_weight = 0; /* SP */
    } else if (mode == -1) {
      /* Take weight into consideration */
      *tcg_weight = weight;
    } else if (mode == BCM_COSQ_NONE) {
      *tcg_weight = -1;
    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - invalid mode given. mode: %d, weight: %d"), mode, weight));
    }
    

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose: 
 * Set EIR Weight for Egress Port TCG
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_sched_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int mode,
                                                int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, ofp_ndx;    
    int core;
    SOC_TMC_SCH_TCG_WEIGHT info;
    SOC_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */
    if (!((mode == -1) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or NONE ")));
    }

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 0 && ((weight) <= (DPP_COSQ_E2E_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
   
    /* Clear */
    SOC_TMC_SCH_TCG_WEIGHT_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tcg_weight_get,(unit,ofp_ndx,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.tcg_weight_valid = (mode == BCM_COSQ_NONE) ? FALSE:TRUE;
    if (info.tcg_weight_valid) {
      info.tcg_weight = weight;
    }
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tcg_weight_set,(unit,ofp_ndx,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get EIR Weight for Egress Port TCG.
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_sched_get(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int *mode,
                                                int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, ofp_ndx;    
    int core;
    SOC_TMC_SCH_TCG_WEIGHT info;
    SOC_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Clear */
    SOC_TMC_SCH_TCG_WEIGHT_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tcg_weight_get,(unit,ofp_ndx,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *mode = (info.tcg_weight_valid) ? -1:BCM_COSQ_NONE;
    if (info.tcg_weight_valid) {
      *weight = info.tcg_weight;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set EIR Weight for Egress Port TCG
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_sched_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int mode,
                                                int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_TCG_SCH_WFQ info;
    SOC_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */
    if (!((mode == -1) || (mode == BCM_COSQ_SP0) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or BCM_COSQ_SP0 or NONE ")));
    }
    if (!((mode == -1) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or NONE ")));
    }

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 0 && ((weight) <= (DPP_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
   
    /* Clear */
    SOC_TMC_EGR_TCG_SCH_WFQ_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_tcg_weight_get,(unit,core,tm_port,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.tcg_weight_valid  = (mode == BCM_COSQ_NONE) ? FALSE:TRUE;
    
    rc = _bcm_petra_cosq_egress_fill_tcg_weight_from_mode_weight(unit,mode,weight,&info.tcg_weight);
    BCMDNX_IF_ERR_EXIT(rc);
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_tcg_weight_set,(unit,core,tm_port,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get EIR Weight for Egress Port TCG.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_sched_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             int *mode,
                                             int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_TCG_SCH_WFQ info;
    SOC_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    
    BCMDNX_NULL_CHECK(weight);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Clear */
    SOC_TMC_EGR_TCG_SCH_WFQ_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_tcg_weight_get,(unit,core,tm_port,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *mode = info.tcg_weight_valid ? -1:BCM_COSQ_NONE;
    if (info.tcg_weight_valid) {
      *weight = info.tcg_weight;
    }
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global schedule mode for all OTM ports in the device 
 */
STATIC int
_bcm_petra_cosq_ofp_sch_mode_set(int unit,
                                 int mode)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_EGR_OFP_SCH_MODE sch_mode;    

    BCMDNX_INIT_FUNC_DEFS;
    /* Set Global Schedule mode */
    rc = _bcm_petra_cosq_bcm_sch_mode_to_egr_ofp_sch_mode(mode,&sch_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Set configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_sch_mode_set,(unit, &sch_mode)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose:
 * Schedule mode in OTM port scheduler. 
 * UC and MC Egress queues are handled here.
 * Configure the SP to connect to and the weighted distribution 
 * between the other queue on the same priority. 
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_OFP_SCH_INFO info;
    SOC_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p;    
    uint8 is_ucast_egress_queue;
    int queue_id;
    int max_cosq_num;        

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
        
    /* clear */
    SOC_TMC_EGR_OFP_SCH_INFO_clear(&info);
          
    max_cosq_num = DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);

    if (!((mode == -1) || (mode >= BCM_COSQ_SP0 && mode <= BCM_COSQ_SP1))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or BCM_COSQ_SP0-1 ")));
    }

    rc = _bcm_petra_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!((queue_id >= 0 && queue_id <= max_cosq_num))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid queue_id parameter %d, max_cosq_num for this ofp: %d"), queue_id,max_cosq_num));
    }    

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 1 && ((weight) <= (DPP_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
        
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    sch_wfq_p = &(info.ofp_wfq_q_pair[queue_id]);

    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        /* UC Egress queue fill */
        is_ucast_egress_queue = SOC_SAND_TRUE;       
    } else {
        /* MC Egress queue fill */
        is_ucast_egress_queue = SOC_SAND_FALSE;
    }

    /* Fill WFQ SCH structure */
    rc = _bcm_petra_cosq_egress_fill_ofp_wfq_sch_from_mode_weight(is_ucast_egress_queue,mode,weight,sch_wfq_p);
    BCMDNX_IF_ERR_EXIT(rc);
            
    /* Set configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_set,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : Set weight, sp between FMQ class
 */
STATIC int
_bcm_petra_cosq_gport_fmq_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    int index;
    SOC_TMC_MULT_FABRIC_INFO info, exact_info;            

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (mode == -1 && (weight < 0 || weight > DPP_COSQ_FMQ_MAX_BE_WEIGHT)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
    }
      
    /* clear */
    SOC_TMC_MULT_FABRIC_INFO_clear(&info);
    SOC_TMC_MULT_FABRIC_INFO_clear(&exact_info);
          
    /* Get configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (mode != -1) {
        /* Mode is not disable, Mode is SP only. i.e. MC2 > MC1 > MC0 */
        info.best_effort.wfq_enable = SOC_SAND_FALSE;
        for (index = 0; index < DPP_COSQ_FMQ_NOF_BE; index++) {
            info.best_effort.be_sch_port[index].weight = 0;
        }
    } else {
        /* Set weight configuration */
        info.best_effort.wfq_enable = SOC_SAND_TRUE;

        if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)) {
            info.best_effort.be_sch_port[0].weight = weight;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)) {
            info.best_effort.be_sch_port[1].weight = weight;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
            info.best_effort.be_sch_port[2].weight = weight;
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport given (0x%08x) "), gport));
        }
    }

    /* Set configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_set,(unit, &info,&exact_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : Retreive weight, sp between FMQ class
 */
STATIC int
_bcm_petra_cosq_gport_fmq_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_MULT_FABRIC_INFO info;            

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);
      
    /* clear */
    SOC_TMC_MULT_FABRIC_INFO_clear(&info);
          
    /* Get configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (!(info.best_effort.wfq_enable)) {
        /* Mode is not disable, Mode is SP only. i.e. MC2 > MC1 > MC0 */
        *mode = 0;
        *weight = -1;
    } else {
        *mode = -1;

        /* weight configuration */
        if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)) {
            *weight = info.best_effort.be_sch_port[0].weight;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)) {
            *weight = info.best_effort.be_sch_port[1].weight;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
            *weight = info.best_effort.be_sch_port[2].weight;
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport given (0x%08x) "), gport));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Schedule mode in OTM port scheduler. 
 * UC and MC Egress queues are handled here.
 * Get the SP that the port connect to and the weighted distribution 
 * between the other queue on the same priority. 
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p;    
    SOC_TMC_EGR_OFP_SCH_INFO info;
    uint8 is_ucast_egress_queue;
    int max_cosq_num, queue_id;        

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);
    BCM_DPP_UNIT_CHECK(unit);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* clear */
    SOC_TMC_EGR_OFP_SCH_INFO_clear(&info);

    max_cosq_num = DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);
    
    rc = _bcm_petra_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!((queue_id >= 0 && queue_id <= max_cosq_num))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid queue_id parameter %d, queue_id can be in range of 0-1 or High/Low priorities"), queue_id));
    }

    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Fill mode, weight */
    sch_wfq_p = &(info.ofp_wfq_q_pair[queue_id]);


    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        /* UC Egress queue fill */
        is_ucast_egress_queue = SOC_SAND_TRUE;       
    } else {
        /* MC Egress queue fill */
        is_ucast_egress_queue = SOC_SAND_FALSE;
    }

    rc = _bcm_petra_cosq_egress_fill_mode_weight_from_ofp_wfq_sch(is_ucast_egress_queue,sch_wfq_p,mode,weight);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure OFP shaping rate, set single port rate.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 kbits_sec_min,
                                                          uint32 kbits_sec_max,
                                                          uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32          tm_port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    soc_port_t      port;
    int core;          

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);    
    
    /* Verify */
    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_shaper_mode_get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (kbits_sec_max > DPP_COSQ_EGR_OFP_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_single_port_rate_sw_set,(unit, core, tm_port, kbits_sec_max));   
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(flags & BCM_COSQ_BW_NOT_COMMIT)) {
        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_single_port_rate_hw_set,(unit, core, tm_port));   
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* currently only BCM_COSQ_BW_NOT_COMMIT flag is supported */
    if ((flags & ~(BCM_COSQ_BW_NOT_COMMIT)) != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: ?%d\nFlags must be set to 0"), flags)); 
    }

exit:
BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get OFP shaping rate, get single port rate.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 *kbits_sec_min,
                                                          uint32 *kbits_sec_max,
                                                          uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;  
    uint32 tm_port;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;

    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);
    BCM_DPP_UNIT_CHECK(unit);

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_single_port_rate_hw_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_shaper_mode_get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    *kbits_sec_min = 0;
    *flags = 0;

    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure Port-TC (q-pair) shaping rate, set single port rate.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    SOC_TMC_EGR_Q_PRIO prio;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);
                
    /* Validate gport */
    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc); 

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_shaper_mode_get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    if (kbits_sec_max > DPP_COSQ_EGR_OFP_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }       

    /* Set configuration */
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_rate_sw_set,(unit, core, tm_port ,prio, kbits_sec_max));                   
    BCMDNX_IF_ERR_EXIT(rc);    
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_rate_hw_set,(unit));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TC (q-pair) shaping rate
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port; 
    int core; 
    SOC_TMC_EGR_Q_PRIO prio;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);
                
    /* Validate gport */
    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_rate_hw_get,(unit, core, tm_port ,prio, kbits_sec_max));                 
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_shaper_mode_get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }        

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure Port-TC (HR) shaping rate, set single port rate.
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 ofp_ndx;  
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tc"), unit, gport));
    }
          
    /* Validate gport */
    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (kbits_sec_max > DPP_COSQ_EGR_SCH_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Set configuration */    
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_port_priority_rate_set,(unit, core, ofp_ndx ,cosq, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TC (HR) shaping rate
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_bandwidth_get(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                uint32 *kbits_sec_min,
                                                uint32 *kbits_sec_max,
                                                uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 ofp_ndx;  
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tc"), unit, gport));
    }
          
    /* Validate gport */
    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_port_priority_rate_get,(unit, core, ofp_ndx , cosq, kbits_sec_max));                  
    BCMDNX_IF_ERR_EXIT(rc);    

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_bcm_cosq_to_tcg(int unit,
                                int cosq,
                                SOC_TMC_TCG_NDX *tcg)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (cosq < SOC_TMC_TCG_MIN || cosq > SOC_TMC_TCG_MAX) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq));
    }
    *tcg = cosq;
    
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure TCG shaping rate
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    SOC_TMC_TCG_NDX tcg;
    int core;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);    

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_shaper_mode_get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (kbits_sec_max > DPP_COSQ_EGR_OFP_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    /* Set configuration */    
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_rate_sw_set,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);   
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_rate_hw_set,(unit));
    BCMDNX_IF_ERR_EXIT(rc);   

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TCG shapring rate
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port; 
    int core; 
    SOC_TMC_TCG_NDX tcg;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);    

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_rate_hw_get,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_shaper_mode_get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }            

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure TCG shaping rate - E2E
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 ofp_ndx;  
    SOC_TMC_TCG_NDX tcg;
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tcg"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (kbits_sec_max > DPP_COSQ_EGR_SCH_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Set configuration */    
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_tcg_rate_set,(unit, ofp_ndx ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get E2E Port-TCG shapring rate
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 ofp_ndx;  
    int core;
    SOC_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only E2E port tcg"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_tcg_rate_get,(unit, ofp_ndx ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;
    
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure OFP shaping rate, set configuration per interface.
 */
STATIC int
_bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_set(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 kbits_sec_min,
                                                               uint32 kbits_sec_max,
                                                               uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"),flags));
    }

    
    /*        Now it is done by translate ofp to mal */
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_interface_shaper_set,(unit, core, tm_port, SOC_TMC_OFP_SHPR_UPDATE_MODE_OVERRIDE,kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get configuration of OFP shaping rate, get configuration per interface.
 */
STATIC int
_bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_get(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 *kbits_sec_min,
                                                               uint32 *kbits_sec_max,
                                                               uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    
    /*        Now it is done by translate ofp to mal */
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of interface gport"), cosq));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_interface_shaper_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_fmq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_MULT_FABRIC_INFO info, exact_info;    

    BCMDNX_INIT_FUNC_DEFS;
    /* Clear */
    SOC_TMC_MULT_FABRIC_INFO_clear(&info);
    SOC_TMC_MULT_FABRIC_INFO_clear(&exact_info);
    
    /* Validate */
    if (!(BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport))) {

        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit(%d) invalid gport type (0x%08x)"), unit, gport));
    }
    if (cosq != 0 ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
    }
    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid minimum kbits per second parameter %d\n"), unit, kbits_sec_min));
    }
    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter %d\n"), unit, flags));
    }
    /* Get existing configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport)) {
        info.max_rate = kbits_sec_max;
    } else if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)) {
        info.guaranteed.gr_shaper.rate = kbits_sec_max;
    } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
        info.best_effort.be_shaper.rate = kbits_sec_max;
    }
    
    /* Set configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_set,(unit,&info,&exact_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_gport_fmq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_MULT_FABRIC_INFO info;    

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);

    /* Clear */
    SOC_TMC_MULT_FABRIC_INFO_clear(&info);
    
    /* Validate */
    if (!(BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport))) {

        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit(%d) invalid gport type (0x%08x)"), unit, gport));
    }
    if (cosq != 0 ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
    }
    /* Get existing configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *kbits_sec_min = 0;

    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport)) {
        *kbits_sec_max = info.max_rate;
    } else if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)) {
        *kbits_sec_max = info.guaranteed.gr_shaper.rate;
    } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
        *kbits_sec_max = info.best_effort.be_shaper.rate;
    }      

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_isq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags)
{
    SOC_TMC_ITM_INGRESS_SHAPE_INFO isp_info;
    uint32 soc_sand_rc;
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
 
    /* Set ISQ range in hardware */
    SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, &isp_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    isp_info.rate = kbits_sec_max;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_set,(unit, &isp_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
 exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_isq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_ITM_INGRESS_SHAPE_INFO isp_info;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);
 
    /* Set ISQ range in hardware */
    SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, &isp_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *kbits_sec_max = isp_info.rate;
    *kbits_sec_min = 0;
    *flags = 0;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;

}

STATIC int
_bcm_petra_cosq_gport_flow_bandwidth_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         uint32 kbits_sec_min,
                                         uint32 kbits_sec_max,
                                         uint32 flags)
{
    bcm_error_t               rc = BCM_E_NONE;
    int                       soc_sand_rc = 0;
    bcm_dpp_cosq_gport_info_t port_info;
    SOC_TMC_SCH_FLOW            exact_flow_config;
    int                       flow_id_index;
    

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    sal_memset(&port_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    port_info.flow_config = NULL;
    port_info.se_config = NULL;

    BCMDNX_ALLOC(port_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(port_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (port_info.flow_config == NULL) || (port_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    SOC_TMC_SCH_SE_INFO_clear(port_info.se_config);
    SOC_TMC_SCH_FLOW_clear(port_info.flow_config);

    if (kbits_sec_min != 0) {
        /* no guaranteed rate supported for this type */
        LOG_WARN(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit(%d) kbits_sec_min(%d > 0) unsupported gport(0x%08x)\n"),
                             unit, kbits_sec_min, gport));
    }

    

    /* validate port element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, gport, cosq, 0, &port_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }

    flow_id_index = (port_info.is_sf2 == TRUE) ? 1 : 0;
    (port_info.flow_config)->sub_flow[flow_id_index].shaper.max_rate = kbits_sec_max;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, port_info.flow_id, port_info.flow_config, &exact_flow_config)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, port_info.flow_id, soc_sand_rc, rc));
        goto err;
    }

   BCM_FREE(port_info.flow_config);
   BCM_FREE(port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (port_info.flow_config != NULL)
       BCM_FREE(port_info.flow_config);
    if (port_info.se_config != NULL)
       BCM_FREE(port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_flow_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    bcm_error_t                       rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t         port_info;
    int                               flow_id_index;
    bcm_dpp_cosq_connector_config_t  *connector_config = NULL;
    int                               base_flow_id = 0, is_connector, gport_sf2_type,numq;
    bcm_dpp_cosq_config_t            *cosq_config;


    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit]; 
    sal_memset(&port_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));   

    
    /* consistency check to determine if cosq is valid */
    is_connector = (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ? TRUE : FALSE;
    if (is_connector == TRUE) {
        /* determine flow id */
        base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
    }
    if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        /* determine if associated with  connector or se */
        BCM_INT_DPP_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
        is_connector = (gport_sf2_type == BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) ? TRUE : FALSE;

        if (is_connector == TRUE) {
            /* determine flow id */
            base_flow_id = BCM_COSQ_GPORT_COMPOSITE_SF2_GET(gport);
        }
    }

    if (is_connector) {
        /* retreive connector group state */
        connector_config = (bcm_dpp_cosq_connector_config_t*)_bcm_petra_cosq_element_get(unit,
                                              &(cosq_config->connector_hd), base_flow_id);
        if (connector_config == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) gport delete flow internal state retreival error"), unit, base_flow_id));
        }
        numq = connector_config->num_cos;
    }

    if (is_connector) {
        if (cosq >= numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
        }
    }
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) ||
              (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ) {
        if ( (cosq != 0) && (cosq != -1) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
        }
    }
    else { /* should never reach here */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x), gport type should be connector or scheduler"), unit, gport));
    }
    
    /* misc consistency checks */
    if (kbits_sec_max == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, kbits_sec_max parameter"), unit));
    }
    if (kbits_sec_min != NULL) {
        (*kbits_sec_min) = 0;
    }
    if (flags != NULL) {
        (*flags) = 0;
    }

    port_info.flow_config = NULL;
    port_info.se_config = NULL;

    BCMDNX_ALLOC(port_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(port_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (port_info.flow_config == NULL) || (port_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    SOC_TMC_SCH_SE_INFO_clear(port_info.se_config);
    SOC_TMC_SCH_FLOW_clear(port_info.flow_config);

    /* validate port element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, gport, cosq, 0, &port_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }

    flow_id_index = (port_info.is_sf2 == TRUE) ? 1 : 0;
    (*kbits_sec_max) = (port_info.flow_config)->sub_flow[flow_id_index].shaper.max_rate;

   BCM_FREE(port_info.flow_config);
   BCM_FREE(port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (port_info.flow_config != NULL)
       BCM_FREE(port_info.flow_config);
    if (port_info.se_config != NULL)
       BCM_FREE(port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
 _bcm_petra_cosq_gport_e2e_port_bandwidth_set(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 kbits_sec_min,
                                              uint32 kbits_sec_max,
                                              uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */

    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    if (kbits_sec_max > DPP_COSQ_EGR_SCH_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d out of range max %d"), kbits_sec_max, DPP_COSQ_EGR_SCH_RATE_MAX_KBITS_SEC_PER_DEVICE(unit)));
    }    

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_single_port_rate_sw_set,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_single_port_rate_hw_set,(unit, core, tm_port));
    BCMDNX_IF_ERR_EXIT(rc);


    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e port(%d) core(%d) sched rate to (%d)kbps\n"), 
                          unit, gport, tm_port, core, kbits_sec_max));


exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
 _bcm_petra_cosq_gport_e2e_port_bandwidth_get(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 *kbits_sec_min,
                                              uint32 *kbits_sec_max,
                                              uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_single_port_rate_hw_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;/*always 0*/
    *flags = 0;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) get e2e port(%d) core(%d) sched rate to (%d)kbps\n"), 
                          unit, gport, tm_port, core, *kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
 _bcm_petra_cosq_gport_e2e_interface_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d\nkbits_sec_min must be set to 0"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_if_shaper_rate_set,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e interface sched rate to (%d)kbps\n"), unit, gport, kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
 _bcm_petra_cosq_gport_e2e_interface_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_if_shaper_rate_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;
    *flags = 0;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e interface sched rate to (%d)kbps\n"), 
                          unit, gport, *kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_sched_cl_weight_get(int                        unit,
                                            bcm_gport_t                port,
                                            bcm_cos_queue_t            cosq,
                                            bcm_cosq_control_t         type,
                                            int                       *weight,
                                            bcm_dpp_cosq_gport_info_t *port_info)
{
    bcm_error_t                rc = BCM_E_NONE;
    bcm_dpp_cosq_class_info_t  class_info;
    int                        weight_ap;
    uint32                     soc_sand_rc;
    SOC_TMC_SCH_SE_CL_CLASS_INFO  *class_type = NULL;

    BCMDNX_INIT_FUNC_DEFS;
    (*weight) = 0;

    if (port_info->is_se == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information must be schedule element"), unit));
    }
    if (port_info->se_config->type != SOC_TMC_SCH_SE_TYPE_CL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information schedule element must be of CL type"), unit));
    }
    if ((cosq != 0) && (cosq != -1)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d, must be 0 or -1"), unit, cosq));
    }

    switch (type) {
        case bcmCosqControlDiscreteWeightLevel0:
            weight_ap = 0;
            break;
        case bcmCosqControlDiscreteWeightLevel1:
            weight_ap = 1;
            break;
        case bcmCosqControlDiscreteWeightLevel2:
            weight_ap = 2;
            break;
        case bcmCosqControlDiscreteWeightLevel3:
            weight_ap = 3;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
            break;
    }    

    rc = _bcm_petra_cosq_credit_class_info_get(unit, port_info->se_config, -1, &class_info);
    BCMDNX_IF_ERR_EXIT(rc);

    if ( (class_info.weight_mode != SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) &&
         (class_info.weight_mode != SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid weight mode 0x%x"), unit, class_info.weight_mode));
    }
    if (weight_ap >= class_info.max_discrete_class) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
    }

    BCMDNX_ALLOC(class_type, sizeof(SOC_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    if (class_type == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d,could not allocate class type"),unit));
    }

    SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(class_type);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, port_info->se_config->type_info.cl.id, class_type)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, port_info->se_config->type_info.cl.id, soc_sand_rc, rc));
        goto err;
    }

    (*weight) = class_type->weight[weight_ap];

   BCM_FREE(class_type);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (class_type != NULL) {
       BCM_FREE(class_type);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_flow_get(int unit,
                            bcm_gport_t port,
                            bcm_cos_queue_t cosq,
                            bcm_cosq_control_t type,
                            int *arg)
{
    bcm_error_t                rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t  port_info;
    int                        flow_id_index;    


    BCMDNX_INIT_FUNC_DEFS;
    

    sal_memset(&port_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    port_info.flow_config = NULL;
    port_info.se_config = NULL;

    BCMDNX_ALLOC(port_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(port_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (port_info.flow_config == NULL) || (port_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    switch(type) {

        case bcmCosqControlBandwidthBurstMax:
            if (BCM_GPORT_IS_FABRIC_CLOS(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_burst_get(unit, port, arg);
                flow_id_index = 0;
                break;
            }
            else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_get(unit, port, arg);
                flow_id_index = 0;
                break;
            }      
            else if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) ||
                  BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port) ||
                  BCM_COSQ_GPORT_IS_SCHED_PIR(port))) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                rc = BCM_E_PARAM;
                goto err;
            }

            /* validate port element */
            rc = _bcm_petra_cosq_gport_validate_info_get(unit, port, cosq, 0, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            flow_id_index = (port_info.is_sf2 == TRUE) ? 1 : 0;
            (*arg) = (port_info.flow_config)->sub_flow[flow_id_index].shaper.max_burst;

            break;

        case bcmCosqControlFlowSlowRate:
            if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port)  || BCM_GPORT_IS_FABRIC_CLOS(port))) {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }

            if (BCM_GPORT_IS_FABRIC_CLOS(port))
            {
                /*Configure CLOS FMQs Slow Start Mechanism*/
                /* Ingress Scheduler */
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_get(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

            } else if(BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_get(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            } else {
                /*VOQs connector slow rate*/
                /* validate port element */
                rc = _bcm_petra_cosq_gport_validate_info_get(unit, port, cosq, dpp_device_cosq_gport_connector_element, &port_info);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

                flow_id_index = (port_info.is_sf2 == TRUE) ? 1 : 0;

                if ((port_info.flow_config)->is_slow_enabled == FALSE) {
                    (*arg) = 0;
                }
                else {
                    (*arg) = (port_info.flow_config)->sub_flow[flow_id_index].slow_rate_ndx;
                }

            }
            break;
       case bcmCosqControlFlowSlowRate1:
       case bcmCosqControlFlowSlowRate2:
            if (!(BCM_GPORT_IS_FABRIC_CLOS(port))) 
            {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            /*Configure CLOS FMQs Slow Start Mechanism*/
            /* Ingress Scheduler */
            rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_get(unit, port, cosq, type, arg);
            if (rc != BCM_E_NONE) {
                goto err;
            }
           break;

        case bcmCosqControlDiscreteWeightLevel0:
        case bcmCosqControlDiscreteWeightLevel1:
        case bcmCosqControlDiscreteWeightLevel2:
        case bcmCosqControlDiscreteWeightLevel3:
            if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port))) {
                rc = BCM_E_PARAM;
                goto err;
            }

            /* validate port element */
            rc = _bcm_petra_cosq_gport_validate_info_get(unit, port, cosq, dpp_device_cosq_gport_parent_element, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            rc = _bcm_petra_cosq_control_sched_cl_weight_get(unit, port, cosq, type, arg, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case bcmCosqControlSpLevelMax:
            break;

        case bcmCosqControlSp0WeightMax:
            break;
        case bcmCosqControlSp1WeightMax:
            break;
        case bcmCosqControlSp2WeightMax:
            break;
        case bcmCosqControlSp3WeightMax:
            break;
        case bcmCosqControlSp4WeightMax:
            break;
        case bcmCosqControlSp5WeightMax:
            break;
        case bcmCosqControlSp6WeightMax:
            break;
        case bcmCosqControlSp7WeightMax:
            break;
        case bcmCosqControlSp8WeightMax:
            break;
        case bcmCosqControlSp9WeightMax:
            break;
        case bcmCosqControlSp10WeightMax:
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

   BCM_FREE(port_info.flow_config);
   BCM_FREE(port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:

    if (port_info.flow_config != NULL)
       BCM_FREE(port_info.flow_config);
    if (port_info.se_config != NULL)
       BCM_FREE(port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_hr_fc_validate_info_get(int unit, int hr_mode, bcm_cos_queue_t cosq, int arg, int *hr_class)
{
    bcm_error_t rc = BCM_E_NONE;
    int cos;
   
    
    BCMDNX_INIT_FUNC_DEFS;
    cos = (cosq == -1) ? arg : cosq;

    if (cosq != -1) {
        if (arg != BCM_COSQ_HIGH_PRIORITY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Flow control not supported for cos %d and arg 0x%x\n"), unit, cosq, arg));
        }
    }

    switch (hr_mode) {
        case SOC_TMC_SCH_HR_MODE_SINGLE_WFQ:
            switch (cos) {
                case 0: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 3: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_SINGLE_CLASS_AF1_WFQ; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case SOC_TMC_SCH_HR_MODE_DUAL_WFQ:
            switch (cos) {
                case 0: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 3: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_DUAL_OR_ENHANCED; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case SOC_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
            switch (cos) {
                case 0: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 8: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_DUAL_OR_ENHANCED; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Unknown HR mode %d\n"), unit, hr_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_hr_fc_update(int unit, int profile, int hr_class)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_SCH_PORT_HP_CLASS_INFO class_info;
    uint32 soc_sand_rc;           

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_SCH_PORT_HP_CLASS_INFO_clear(&class_info);

    /* retreive profile */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_hp_class_conf_get,(unit, &class_info)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving HR Flow Control CLass Info, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    /* update profile */
    class_info.lowest_hp_class[profile] = hr_class;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_hp_class_conf_set,(unit, &class_info)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving HR Flow Control CLass Info, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petrs_cosq_port_hr_flow_control_set(int unit, bcm_gport_t port, bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type, int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    int hr_mode, hr_class;
    int old_profile, profile, is_last, is_allocated;
    int core;
    SOC_TMC_SCH_PORT_INFO port_info;
    uint32 soc_sand_rc, fap_port;        

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_SCH_PORT_INFO_clear(&port_info);

    /* determine fap port */
    rc = _bcm_petra_cosq_fap_port_get(unit, port, &fap_port, &core);
    if (rc != BCM_E_NONE) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, got invalid fap port %d,  for port (0x%x)"), unit, fap_port, port));
    }

    /* get associated configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_get,(unit, core, fap_port, &port_info)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving scheduler info port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }
    hr_mode = port_info.hr_mode;

    /* consistency checks and new class info */
    rc = _bcm_petra_cosq_hr_fc_validate_info_get(unit, hr_mode, cosq, arg, &hr_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* get new profile */
    rc = _bcm_dpp_am_template_cosq_port_hr_fc_exchange(unit, fap_port, &hr_class, &old_profile, &is_last, &profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* if required update device configuration */
    if (is_allocated == TRUE) {
        rc = _bcm_petra_cosq_hr_fc_update(unit, profile, hr_class);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* if required update port configuration */
    if ( (old_profile != profile) || (port_info.lowest_hp_class != hr_class) ) {
        port_info.lowest_hp_class = hr_class;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler info port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_e2e_fc_data(unit, 0, old_profile, profile);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_e2e_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowControlPriority:
            /* Supported only in case of not Port-TC enable */
            if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
                rc = _bcm_petrs_cosq_port_hr_flow_control_set(unit, port, cosq, type, arg);
            }
            break;
        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_control_e2e_get(int unit,
                            bcm_gport_t port,
                            bcm_cos_queue_t cosq,
                            bcm_cosq_control_t type,
                            int *arg)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(arg);

    

    switch(type) {
        case bcmCosqControlFlowControlPriority:
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_sched_cl_weight_set(int                        unit,
                                            bcm_gport_t                port,
                                            bcm_cos_queue_t            cosq,
                                            bcm_cosq_control_t         type,
                                            int                        weight,
                                            bcm_dpp_cosq_gport_info_t *port_info)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dpp_cosq_class_info_t        class_info;
    int                              weight_ap;
    uint32                           soc_sand_rc;
    SOC_TMC_SCH_SE_CL_CLASS_INFO        *class_type = NULL, *exact_class_type = NULL;
    bcm_dpp_cosq_sched_class_data_t  class_data;
    int                             *weights, flags = 0;
    int                              is_last, class_template, is_allocated, old_class_template;
    SOC_TMC_SCH_FLOW                    *exact_flow_config = NULL;


    BCMDNX_INIT_FUNC_DEFS;
    if (port_info->is_se == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information must be schedule element"), unit));
    }
    if (port_info->se_config->type != SOC_TMC_SCH_SE_TYPE_CL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information schedule element must be of CL type"), unit));
    }
    if ((cosq != 0) && (cosq != -1)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
    }
    if(weight < 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Weight must be positive %d\n"), unit, weight));
    }

    /* determine if the attachment point is valid */
    switch (type) {
        case bcmCosqControlDiscreteWeightLevel0:
            weight_ap = 0;
            break;
        case bcmCosqControlDiscreteWeightLevel1:
            weight_ap = 1;
            break;
        case bcmCosqControlDiscreteWeightLevel2:
            weight_ap = 2;
            break;
        case bcmCosqControlDiscreteWeightLevel3:
            weight_ap = 3;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
            break;
    }    

    rc = _bcm_petra_cosq_credit_class_info_get(unit, port_info->se_config, -1, &class_info);
    BCMDNX_IF_ERR_EXIT(rc);

    if ( (class_info.weight_mode != SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) &&
         (class_info.weight_mode != SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid weight mode 0x%x"), unit, class_info.weight_mode));
    }
    if (weight_ap >= class_info.max_discrete_class) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
    }

    /* retreive class data */
    BCMDNX_ALLOC(class_type, sizeof(SOC_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    BCMDNX_ALLOC(exact_class_type, sizeof(SOC_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    BCMDNX_ALLOC(exact_flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    if ( (class_type == NULL) || (exact_class_type == NULL) || (exact_flow_config == NULL) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("memory allocation failed")));
    }

    SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(class_type);
    SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(exact_class_type);
    SOC_TMC_SCH_FLOW_clear(exact_flow_config);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, port_info->se_config->type_info.cl.id, class_type)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, port_info->se_config->type_info.cl.id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    weights = (int *)class_type->weight;
    DPP_DEVICE_COSQ_CL_CLASS_DATA_INIT(class_data, class_type->mode, class_type->enhanced_mode, class_type->weight_mode, weights);

    /* update the new template data */
    class_data.weights[weight_ap] = weight;

    /* get new template */
    old_class_template = port_info->se_config->type_info.cl.id;
    rc = _bcm_dpp_am_template_cosq_sched_class_exchange(unit, flags, (int *)&class_data, port_info->se_config->type_info.cl.id, &is_last, &class_template, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);
   
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "  DBG, template Sched(cl), Allocated(%s), is_last(%s), oldTemplate(%d), Template(%d)\n"), ((is_allocated == TRUE) ? "TRUE" : "FALSE"), ((is_last == TRUE) ? "TRUE" : "FALSE"), port_info->se_config->type_info.cl.id, class_template));

    /* if required update h/w with template */
    if (is_allocated == TRUE) {
        /* update class information */
        class_type->weight[weight_ap] = weight;
        class_type->id = class_template;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_set,(unit, class_template, class_type, exact_class_type)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in class type for class index(%d)\n"), unit, class_template));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }

    /* map the new CL profile */
    port_info->se_config->type_info.cl.id = class_template;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, port_info->se_id, port_info->se_config, port_info->flow_config, exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type cl\n"), unit, port_info->se_id));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_class_data(unit, 0, old_class_template, class_template);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(class_type);
    BCM_FREE(exact_class_type);
    BCM_FREE(exact_flow_config);
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_flow_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg)
{
    bcm_error_t               rc = BCM_E_NONE;
    int                       soc_sand_rc = 0;    
    bcm_dpp_cosq_gport_info_t port_info;
    SOC_TMC_SCH_FLOW            exact_flow_config;
    int                       flow_id_index, is_slow_enabled, slow_rate_index;    

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    sal_memset(&port_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    port_info.flow_config = NULL;
    port_info.se_config = NULL;

    BCMDNX_ALLOC(port_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(port_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (port_info.flow_config == NULL) || (port_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    SOC_TMC_SCH_SE_INFO_clear(port_info.se_config);
    SOC_TMC_SCH_FLOW_clear(port_info.flow_config);

    

    switch(type) {

        /* Set burst max for flow shaper */
        case bcmCosqControlBandwidthBurstMax:
        {
            if (BCM_GPORT_IS_FABRIC_CLOS(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_burst_set(unit, port, arg);
                flow_id_index = 0;
                break;
            }
            else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_set(unit, port, arg);
                flow_id_index = 0;
                break;
            }  
            else if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) ||
                  BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port) ||
                  BCM_COSQ_GPORT_IS_SCHED_PIR(port))) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                rc = BCM_E_PARAM;
                goto err;
            }

            /* validate port element */
            rc = _bcm_petra_cosq_gport_validate_info_get(unit, port, cosq, 0, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            /* Validate arg */
            if (arg < 0) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, arg %d invalid\n"), unit, arg));
                rc = BCM_E_PARAM;
                goto err;
            }

            flow_id_index = (port_info.is_sf2 == TRUE) ? 1 : 0;
            (port_info.flow_config)->sub_flow[flow_id_index].shaper.max_burst = arg;

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, port_info.flow_id, port_info.flow_config, &exact_flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, port_info.flow_id, soc_sand_rc, rc));
                goto err;
            }
        }
        break;

        case bcmCosqControlFlowSlowRate:
            if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_GPORT_IS_FABRIC_CLOS(port))) {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            if (BCM_GPORT_IS_FABRIC_CLOS(port))
            {
                /*Configure CLOS FMQs Slow Start Mechanism*/
                /* Ingress Scheduler */
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_set(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

            } else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_set(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            } else {
                /*VOQs connector slow rate*/

                if ( (arg != 0) && (arg != 1) && (arg != 2) ) {
                    rc = BCM_E_PARAM;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid arg %d for type %d\n"), unit, arg, type));
                    goto err;
                }

                /* validate port element */
                rc = _bcm_petra_cosq_gport_validate_info_get(unit, port, cosq, dpp_device_cosq_gport_connector_element, &port_info);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

                is_slow_enabled = (arg == 0) ? FALSE : TRUE;
                slow_rate_index = 1;
                if (is_slow_enabled) {
                    slow_rate_index = (arg == 1) ? 0 : 1;
                }

                flow_id_index = (port_info.is_sf2 == TRUE) ? 1 : 0;

                (port_info.flow_config)->is_slow_enabled = is_slow_enabled;
                if (is_slow_enabled == FALSE) {
                    /* set to default value */
                    (port_info.flow_config)->sub_flow[0].slow_rate_ndx = slow_rate_index;
                    if (port_info.is_composite) {
                        (port_info.flow_config)->sub_flow[1].slow_rate_ndx = slow_rate_index;
                    }
                }
                else {
                    (port_info.flow_config)->sub_flow[flow_id_index].slow_rate_ndx = slow_rate_index;
                }

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, port_info.flow_id, port_info.flow_config, &exact_flow_config)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, port_info.flow_id, soc_sand_rc, rc));
                    goto err;
                }
            }

            break;
       case bcmCosqControlFlowSlowRate1:
       case bcmCosqControlFlowSlowRate2:
            if (!(BCM_GPORT_IS_FABRIC_CLOS(port))) 
            {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            /*Configure CLOS FMQs Slow Start Mechanism*/
            /* Ingress Scheduler */
            rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_set(unit, port, cosq, type, arg);
            if (rc != BCM_E_NONE) {
                goto err;
            }
           break;

        case bcmCosqControlDiscreteWeightLevel0:
        case bcmCosqControlDiscreteWeightLevel1:
        case bcmCosqControlDiscreteWeightLevel2:
        case bcmCosqControlDiscreteWeightLevel3:
            if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port))) {
                rc = BCM_E_PARAM;
                goto err;
            }

            /* validate port element */
            rc = _bcm_petra_cosq_gport_validate_info_get(unit, port, cosq, dpp_device_cosq_gport_parent_element, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            rc = _bcm_petra_cosq_control_sched_cl_weight_set(unit, port, cosq, type, arg, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

   BCM_FREE(port_info.flow_config);
   BCM_FREE(port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (port_info.flow_config != NULL)
       BCM_FREE(port_info.flow_config);
    if (port_info.se_config != NULL)
       BCM_FREE(port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


#ifdef BCM_ARAD_SUPPORT
STATIC int
_bcm_arad_cosq_control_multicast_ingress_priority_scheduler_set(int unit, 
                                                                int cosq, 
                                                                int arg)
{

    uint32 soc_sand_rc;
    uint8 enable;
    BCMDNX_INIT_FUNC_DEFS;

    if(!DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    if(arg != BCM_COSQ_HIGH_PRIORITY && arg != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter %d"), arg));
    }
    enable = (arg == BCM_COSQ_HIGH_PRIORITY)?TRUE:FALSE;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_traffic_class_multicast_priority_map_set,(unit, cosq, enable)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;

}

STATIC int
_bcm_arad_cosq_control_multicast_ingress_priority_scheduler_get(int unit, 
                                                                int cosq, 
                                                                int *arg)
{
    uint32 soc_sand_rc;
    uint8 enable = 0;
    BCMDNX_INIT_FUNC_DEFS; 
    BCMDNX_NULL_CHECK(arg);

    if(!DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_traffic_class_multicast_priority_map_get,(unit, cosq, &enable)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *arg = (enable) ? 
        BCM_COSQ_HIGH_PRIORITY : 
        BCM_COSQ_LOW_PRIORITY;
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;

}
#endif /* BCM_ARAD_SUPPORT */

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port scheduler 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_scheduler_set(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;

        
    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Verify */
                if (arg < 0) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "Invalid arg parameter: negative parameter\n")));
                    rc = BCM_E_PARAM;
                }
                if (arg > DPP_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "Invalid arg parameter: more than max burst\n")));
                    rc = BCM_E_PARAM;
                }
                BCM_IF_ERROR_RETURN(rc);

                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_single_port_max_burst_set,(unit, core, tm_port, arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        if(!SOC_IS_ARAD_B1_AND_BELOW(unit)){
            rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_max_credit_empty_port_set,(unit, arg)));
            BCM_SAND_IF_ERR_EXIT(rc);
        } else {
           BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
        }
            break;
        

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port tc scheduler 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_tc_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, port));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;
                SOC_TMC_EGR_Q_PRIO prio;

                /* Validating device type*/
                if ((type == bcmCosqControlBandwidthBurstMaxEmptyQueue || type == bcmCosqControlBandwidthBurstMaxFlowControlledQueue)
                    &&
                    SOC_IS_ARAD_B1_AND_BELOW(unit)
                    ){
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
                }

                
                rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit, cosq, &prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Validate gport */
                rc = _bcm_petra_cosq_port_priority_validate(unit,port,prio);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DPP_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst\n")));
                }

                /* Set Port-TC rate Info */
                switch (type) {
                    case bcmCosqControlBandwidthBurstMax:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_max_burst_set,(unit,core,tm_port,prio,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_port_priority_max_burst_for_empty_queues_set,(unit,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_port_priority_max_burst_for_fc_queues_set, (unit,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    /* coverity[dead_error_begin:FALSE] */
                    default:
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, Invalid type %d\n"), unit, type));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                }
            }
            break;
        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
    }
 
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the e2e port tc scheduler 
 */
STATIC int
_bcm_petra_cosq_control_e2e_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 ofp_ndx;
                SOC_TMC_TCG_NDX tcg;
                
                /* Validate gport */
                rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &ofp_ndx, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DPP_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT || arg < 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst %d\n"), arg));                    
                }

                /* Set Port-TC rate Info */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_tcg_max_burst_set,(unit, ofp_ndx, tcg, arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port tc scheduler 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
    case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port; 
                SOC_TMC_TCG_NDX tcg;
                
                /* Validate gport */
                rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DPP_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT || arg < 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst, %d\n") , arg));                    
                }

                /* Set conifguration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_max_burst_set,(unit, core, tm_port, tcg, arg));                      
                BCMDNX_IF_ERR_EXIT(rc);
                
            break;
            }
        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the e2e port tc scheduler 
 */
STATIC int
_bcm_petra_cosq_control_e2e_port_tc_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 ofp_ndx;

                /* Validate gport */
                rc = _bcm_petra_cosq_port_priority_validate(unit,port,cosq);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &ofp_ndx, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DPP_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst\n"))); 
                }

                /* Set conifguration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_port_priority_max_burst_set,(unit, ofp_ndx, cosq, arg));                 
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress port pc 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_tc_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
      
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, port));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
            /* Get burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port; 
                SOC_TMC_EGR_Q_PRIO prio;

                /* Validating device type*/
                if ((type == bcmCosqControlBandwidthBurstMaxEmptyQueue || type == bcmCosqControlBandwidthBurstMaxFlowControlledQueue)
                    &&
                    SOC_IS_ARAD_B1_AND_BELOW(unit)
                    ){
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
                }

                rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Validate gport */
                rc = _bcm_petra_cosq_port_priority_validate(unit,port,prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Set arg*/
                switch (type) {
                    case bcmCosqControlBandwidthBurstMax:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_max_burst_get,(unit,core,tm_port,prio,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_port_priority_max_burst_for_empty_queues_get,(unit,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_port_priority_max_burst_for_fc_queues_get,(unit,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    /* coverity[dead_error_begin:FALSE] */
                    default:
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, Invalid type %d\n"), unit, type));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                }
            }

            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
STATIC int
_bcm_petra_cosq_control_e2e_port_tc_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;  
                uint32 ofp_ndx;
                /* Validate gport */
                rc = _bcm_petra_cosq_port_priority_validate(unit,port,cosq);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &ofp_ndx, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_port_priority_max_burst_get,(unit, ofp_ndx, cosq, (uint32*) arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
STATIC int
_bcm_petra_cosq_control_e2e_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;
                uint32 ofp_ndx; 
                SOC_TMC_TCG_NDX tcg; 
                
                /* Validate gport */
                rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &ofp_ndx, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_tcg_max_burst_get,(unit, ofp_ndx, tcg, (uint32*)arg));                              
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
STATIC int
_bcm_petra_cosq_control_egress_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port;
                SOC_TMC_TCG_NDX tcg; 
                
                /* Validate gport */
                rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_max_burst_get,(unit, core, tm_port, tcg, (uint32*)arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress port scheduler 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_scheduler_get(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

        
    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Verify */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_single_port_max_burst_get,(unit, core, tm_port,(uint32*)arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        if (!SOC_IS_ARAD_B1_AND_BELOW(unit)) {
            rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ofp_rates_max_credit_empty_port_get, (unit, arg))); 
                BCM_SAND_IF_ERR_EXIT(rc);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
        }
            break;
        

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress interface scheduler (father of port)
 */
STATIC int
_bcm_petra_cosq_control_egress_interface_scheduler_set(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    soc_port_t  local_port;
    bcm_gport_t local_gport;
    soc_port_t  port_i;
    bcm_gport_t gport_i;
    uint32      tm_port;
    soc_pbmp_t  ports_bm;
    int         core, local_mode, mode_i, weight, is_channelized;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core));
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &local_port));
      
    switch(type) {
        case bcmCosqControlSingleCalendarMode:
            BCM_GPORT_LOCAL_SET(local_gport, local_port);

            /* calendar mode is supported only for channelized nif */
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_channelized_port_get(unit, local_port, &is_channelized));
            if (!is_channelized) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Changing calendar mode is allowed only for channelized interfaces")));
            }

            /* changing calendar mode is allowed only when all ports that belong to the NIF are at the same priority */
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_ports_to_same_interface_get(unit, local_port, &ports_bm));
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_sched_get(unit, local_gport, 0, &local_mode, &weight));

            SOC_PBMP_ITER(ports_bm, port_i) {
                    BCM_GPORT_LOCAL_SET(gport_i,port_i);
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_sched_get(unit, gport_i, 0, &mode_i, &weight));
                    if (local_mode != mode_i) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Changing calendar mode is allowed only when all ports on the interface are at the same priority")));
                        break;
                    }
            }
            if (arg == 1) {
                /* single calendar per NIF */
                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_single_cal_mode_set(unit, local_port, TRUE));
            } else {
                /* two calendars per nif (low and high priority calendars) */
                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_single_cal_mode_set(unit, local_port, FALSE));
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress interface scheduler (father of port)
 */
STATIC int
_bcm_petra_cosq_control_egress_interface_scheduler_get(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int *arg)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    

    switch(type) {
         default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_fmq_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 soc_sand_rc = 0;    
    
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set max burst */
            {
                SOC_TMC_MULT_FABRIC_INFO info,exact_info;
                
                /* Validate */
                if (!(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
                      || (SOC_IS_ARAD(unit) && BCM_COSQ_GPORT_IS_FMQ_ROOT(port))
                      || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port))) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d for this gport(0x%08x) "), unit, type,port));
                }
                if (cosq != 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
                }

                if (arg > DPP_COSQ_FMQ_MAX_BURST_LIMIT || arg < 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid max_burst %d \n"), unit, arg));  
                }

                /* Clear */
                SOC_TMC_MULT_FABRIC_INFO_clear(&info);
                SOC_TMC_MULT_FABRIC_INFO_clear(&exact_info);

                /* Get existing configuration */
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
                
                if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
                    info.guaranteed.gr_shaper.max_burst = arg;
                } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) { /* Best effort */
                    info.best_effort.be_shaper.max_burst = arg;
                } else {
                    /* ARAD only */
                    if (SOC_IS_ARAD(unit) && BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) { /* root */
                        info.max_burst = arg;
                    } else {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Internal error in max burst. Not supposed to come here")));
                    }
                }

                /* Set configuration */
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_set,(unit,&info,&exact_info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_control_fmq_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg)
{
    bcm_error_t rc = BCM_E_NONE;   
    uint32 soc_sand_rc = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);    
    
    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set max burst */
            {
                SOC_TMC_MULT_FABRIC_INFO info,exact_info;
                
                /* Validate */
                if (!(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
                      || (SOC_IS_ARAD(unit) && BCM_COSQ_GPORT_IS_FMQ_ROOT(port))
                      || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port))) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d for this gport(0x%08x) "), unit, type,port));
                }
                if (cosq != 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
                }

                /* Clear */
                SOC_TMC_MULT_FABRIC_INFO_clear(&info);
                SOC_TMC_MULT_FABRIC_INFO_clear(&exact_info);

                /* Get existing configuration */
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
                    *arg = info.guaranteed.gr_shaper.max_burst;
                } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
                    /* Best effort */
                    *arg = info.best_effort.be_shaper.max_burst;
                } else {
                    if (SOC_IS_ARAD(unit) && BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) { /* root */
                        *arg = info.max_burst;
                    } else {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Internal error in max burst. Not supposed to come here")));
                    }
                }
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_control_device_set(int unit,
                                   bcm_gport_t port,
                                   bcm_cos_queue_t cosq,
                                   bcm_cosq_control_t type,
                                   int arg)
{
    bcm_error_t           rc = BCM_E_NONE;
    uint32                soc_sand_rc = 0;    
    soc_error_t           rv;
    SOC_TMC_SCH_SLOW_RATE   slow_max_rates, exact_slow_max_rates;
    int                   index;    
    
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowSlowRate1:
        case bcmCosqControlFlowSlowRate2:
            SOC_TMC_SCH_SLOW_RATE_clear(&slow_max_rates);
            SOC_TMC_SCH_SLOW_RATE_clear(&exact_slow_max_rates);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_slow_max_rates_get,(unit, &slow_max_rates)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving device slow rates soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            index = (type == bcmCosqControlFlowSlowRate1) ? 0 : 1;
            slow_max_rates.rates[index] = arg;

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_slow_max_rates_set,(unit, &slow_max_rates, &exact_slow_max_rates)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in configuring device slow rates (0x%x) soc_sand error 0x%x, error 0x%x\n"), unit, arg, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            break;
        case bcmCosqControlAdmissionTestProfileA:
            {
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;
                
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_get,(unit,SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                info.test_a.ctgry_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CT)) ? 1:0;
                info.test_a.ctgry_trffc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTTC)) ? 1:0;
                info.test_a.ctgry2_3_cnctn_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTCC)) ? 1:0;
                info.test_a.sttstcs_tag_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_ST)) ? 1:0;
                info.test_a.pfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_PFC)) ? 1:0;
                info.test_a.llfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_LLFC)) ? 1:0;

                /* Set new admission test */
                
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_set,(unit,SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
            }
            break;
        case bcmCosqControlAdmissionTestProfileB:
            {
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;
                
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_get,(unit,SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                info.test_b.ctgry_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CT)) ? 1:0;
                info.test_b.ctgry_trffc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTTC)) ? 1:0;
                info.test_b.ctgry2_3_cnctn_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTCC)) ? 1:0;
                info.test_b.sttstcs_tag_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_ST)) ? 1:0;
                info.test_b.pfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_PFC)) ? 1:0;
                info.test_b.llfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_LLFC)) ? 1:0;

                /* Set new admission test */
                
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_set,(unit,SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
            }            
            break;
        case bcmCosqControlFlowControlEnable:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rv = soc_dpp_dbg_flow_control_enable_set(unit, arg);
            BCMDNX_IF_ERR_EXIT(rv);
            break;
        case bcmCosqControlEgressBandwidthEnable:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rv = soc_dpp_dbg_egress_shaping_enable_set(unit, arg);
            BCMDNX_IF_ERR_EXIT(rv);
            break;

#ifdef BCM_ARAD_SUPPORT
        /* Congestion handling (CNM) */
        case bcmCosqControlCongestionManagedQueueMin:
        case bcmCosqControlCongestionManagedQueueMax:
          if(SOC_IS_ARAD(unit)) {
            rc = _bcm_arad_cosq_control_congestion_queue_range_set(unit, type, arg);
            BCMDNX_IF_ERR_EXIT(rc);
          } else {
              BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("contol %d, Invalid for PetraB"), type));
          }
          break;
        case bcmCosqControlMulticastPriorityIngressScheduling:
          if(SOC_IS_ARAD(unit)) {
              rc = _bcm_arad_cosq_control_multicast_ingress_priority_scheduler_set(unit, cosq, arg);
              BCMDNX_IF_ERR_EXIT(rc);
          } else {
              BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("contol %d, Invalid for PetraB"), type));
          }
        break;

        case bcmCosqControlDropLimitAlpha: /* enable/disable fair adaptive tail drop */
            if (cosq) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("bcmCosqControlDropLimitAlpha requires a cosq value of zero")));
            }
            BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_fair_adaptive_tail_drop_enable_set, (unit, arg)));
            break;
#endif

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_device_get(int unit,
                                   bcm_gport_t port,
                                   bcm_cos_queue_t cosq,
                                   bcm_cosq_control_t type,
                                   int *arg)
{
    bcm_error_t           rc = BCM_E_NONE;
    uint32                soc_sand_rc = 0;
    soc_error_t           rv;
    SOC_TMC_SCH_SLOW_RATE   slow_max_rates;
    int                   index;    
    
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowSlowRate1:
        case bcmCosqControlFlowSlowRate2:
            SOC_TMC_SCH_SLOW_RATE_clear(&slow_max_rates);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_slow_max_rates_get,(unit, &slow_max_rates)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving device slow rates soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            index = (type == bcmCosqControlFlowSlowRate1) ? 0 : 1;
            (*arg) = slow_max_rates.rates[index];

            break;
        case bcmCosqControlAdmissionTestProfileA:
        case bcmCosqControlAdmissionTestProfileB:
            {
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;
                
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_get,(unit,SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                *arg = 0;
                if (type == bcmCosqControlAdmissionTestProfileA)
                {
                  DPP_COSQ_ADMISSION_TEST_ADD(*arg,info.test_a);
                } else {
                  DPP_COSQ_ADMISSION_TEST_ADD(*arg,info.test_b);
                }                             
            }
            break;
        case bcmCosqControlFlowControlEnable:
            {   
                uint8   enable;
                rv = soc_dpp_dbg_flow_control_enable_get(unit, &enable);
                BCMDNX_IF_ERR_EXIT(rv);
                *arg = enable ? 1 : 0;
            }
            break;
        case bcmCosqControlEgressBandwidthEnable:
            {
                uint8   enable;
                rv = soc_dpp_dbg_egress_shaping_enable_get(unit, &enable);
                BCMDNX_IF_ERR_EXIT(rv);
                *arg = enable ? 1: 0;
            }
            break;  

#ifdef BCM_ARAD_SUPPORT
        /* Congestion handling (CNM) */
        case bcmCosqControlCongestionManagedQueueMin:
        case bcmCosqControlCongestionManagedQueueMax:
          if(SOC_IS_ARAD(unit))
          {
            rc = _bcm_arad_cosq_control_congestion_queue_range_get(unit, type, arg);
            BCMDNX_IF_ERR_EXIT(rc);
          }
          break;
        case bcmCosqControlMulticastPriorityIngressScheduling:
          if(SOC_IS_ARAD(unit))
          {
              rc = _bcm_arad_cosq_control_multicast_ingress_priority_scheduler_get(unit, cosq, arg);
              BCMDNX_IF_ERR_EXIT(rc);
          }
          break;

        case bcmCosqControlDropLimitAlpha: /* check if fair adaptive tail drop is enabled */
            if (cosq) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("bcmCosqControlDropLimitAlpha requires a cosq value of zero")));
            } else {
                uint8 enabled = 0;
                BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_fair_adaptive_tail_drop_enable_get, (unit, &enabled)));
                *arg = enabled;
            }
            break;
#endif

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set ingress queue control
 */
STATIC int
_bcm_petra_cosq_control_ingress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32                soc_sand_rc = 0;        
    int base_qid, qid;
    bcm_dpp_cosq_voq_config_t *voq_config;
    int core = BCM_CORE_ALL;

#ifdef BCM_ARAD_SUPPORT
    uint32    soc_sand_dev_id;
    int       cnm_queue_base;
    int       cpq_index;
    ARAD_CNM_CPQ_INFO cpq_info;
    bcm_cosq_qcn_config_t qcn_config;
#endif

    BCMDNX_INIT_FUNC_DEFS;
    
#ifdef BCM_ARAD_SUPPORT
    soc_sand_dev_id = (unit);
    SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);
#endif

    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)){
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_COSQ_GPORT_IS_ISQ(port) && (type == bcmCosqControlPacketLengthAdjust)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(port);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected port type, 0x%x, and control type, 0x%x"), port, type));
    }
    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                                         &(_dpp_cosq_config[unit].voq_hd),
                                                                         DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid));

    if (voq_config ==  NULL) {      
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error"), unit, base_qid));
    }

    if (cosq < 0 || cosq >= voq_config->num_cos) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter"), unit, cosq));     
    }

    qid = base_qid + cosq;

    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Set Packet length */
            {
                SOC_TMC_ITM_CR_DISCOUNT_INFO discount_data;
                int new_discount_cls, is_allocated, old_discount_cls;
                
                SOC_TMC_ITM_CR_DISCOUNT_INFO_clear(&discount_data);

                if (arg < DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL || arg > DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument discount %d parameter"), unit, arg));    
                }

                /* Get old data */

                /* Set data configuration */
                discount_data.discount = arg;
                
                /* Exchange SW Data */
                rc = _bcm_dpp_am_template_queue_discount_cls_exchange(unit,qid,&discount_data,&old_discount_cls,NULL,&new_discount_cls,&is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                if (is_allocated) {
                   /* Set new profile data */
                   soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_discount_set,(unit,new_discount_cls,&discount_data)));
                   BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                   
                }

                /* Set new mapping */
                rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,qid,BCM_DPP_COSQ_DISCOUNT_CLS,new_discount_cls);
                BCMDNX_IF_ERR_EXIT(rc);

#ifdef BCM_WARM_BOOT_SUPPORT
                rc = _bcm_dpp_wb_cosq_update_ingr_discount_class_data(unit, 0, old_discount_cls, new_discount_cls);
                BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

            }
            break;
        case bcmCosqControlHeaderUpdateField:
            {
                if (arg < 0 || arg > SOC_TMC_MAX_SIGNATURE) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument signature %d parameter"), unit, arg));    
                }

                rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,qid,BCM_DPP_COSQ_QUEUE_SIGNATURE,arg);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;

#ifdef BCM_ARAD_SUPPORT
        /* Handle CNM - Congestion Managed Queues */
        case bcmCosqControlCongestionManagedQueue:
          if(SOC_IS_ARAD(unit))
          {
            rc = _bcm_petra_cosq_control_device_get(unit, 0, 0, bcmCosqControlCongestionManagedQueueMin, &cnm_queue_base);
            BCMDNX_IF_ERR_EXIT(rc);

            cpq_index = qid - cnm_queue_base;

            soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, cpq_index, &cpq_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            cpq_info.is_cp_enabled = arg;

            soc_sand_rc = arad_cnm_cpq_set(soc_sand_dev_id, cpq_index, &cpq_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
          }
          break;

        case bcmCosqControlCongestionThresholdRandom:
        case bcmCosqControlCongestionFeedbackMax:
        case bcmCosqControlCongestionFeedbackWeight:
        case bcmCosqControlCongestionSetPoint:
          if(SOC_IS_ARAD(unit))
          {
            rc = bcm_arad_cosq_qcn_config_get(unit, port, cosq, 0 /* no flags */, &qcn_config);
            BCMDNX_IF_ERR_EXIT(rc);

            switch(type) {
              case bcmCosqControlCongestionThresholdRandom:
                qcn_config.randomize_sample_threshold = arg;
                break;
              case bcmCosqControlCongestionFeedbackMax:
                qcn_config.max_feedback = arg;
                break;
              case bcmCosqControlCongestionFeedbackWeight:
                qcn_config.weight = arg;
                break;
              case bcmCosqControlCongestionSetPoint:
                qcn_config.size = arg;
                break;
              /* Must default. Otherwise, compilation error */
              /* coverity[dead_error_begin : FALSE]*/
              default:
                break;
            }

            rc = bcm_arad_cosq_qcn_config_set(unit, port, cosq, 0 /* no flags */, &qcn_config);
            BCMDNX_IF_ERR_EXIT(rc);
          }
          break;
#endif

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Retreive ingress queue control
 */
STATIC int
_bcm_petra_cosq_control_ingress_queue_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg)
{
    bcm_error_t rc = BCM_E_NONE;
    int base_qid, qid;
    uint32 soc_sand_rc;
    bcm_dpp_cosq_voq_config_t *voq_config;
    int core = BCM_CORE_ALL;

#ifdef BCM_ARAD_SUPPORT
    uint32    soc_sand_dev_id;
    int       cnm_queue_base;
    int       cpq_index;
    ARAD_CNM_CPQ_INFO cpq_info;
    bcm_cosq_qcn_config_t qcn_config;
#endif

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

#ifdef BCM_ARAD_SUPPORT
    soc_sand_dev_id = (unit);
    SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);
#endif

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)){
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_COSQ_GPORT_IS_ISQ(port) && (type == bcmCosqControlPacketLengthAdjust)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(port);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected port type, 0x%x, and control type, 0x%x"), port, type));
    }
    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                             &(_dpp_cosq_config[unit].voq_hd),
                                                             DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid));

    if (voq_config ==  NULL) {      
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error"), unit, base_qid));     
    }

    if (cosq < 0 || cosq >= voq_config->num_cos) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter"), unit, cosq));     
    }                

    qid = base_qid + cosq;
    
    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Get Packet length */
            {
                SOC_TMC_ITM_CR_DISCOUNT_INFO discount_data;             
                
                /* Get old data */
                rc = _bcm_dpp_am_template_queue_discount_cls_data_get(unit,qid,&discount_data);
                BCMDNX_IF_ERR_EXIT(rc);
                                              
                *arg = discount_data.discount;
            }
            break;
        case bcmCosqControlHeaderUpdateField:
            {
                SOC_TMC_ITM_QUEUE_INFO info;

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit,core,qid,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
/*
 * COVERITY
 *
 * The variable info is assigned inside MBCM_DPP_DRIVER_CALL.
 */
/* coverity[uninit_use : FALSE] */
                *arg = info.signature;
            }
            break;

#ifdef BCM_ARAD_SUPPORT
        /* Handle CNM - Congestion Managed Queues */
        case bcmCosqControlCongestionManagedQueue:
          if(SOC_IS_ARAD(unit))
          {         
              rc = _bcm_petra_cosq_control_device_get(unit, 0, 0, bcmCosqControlCongestionManagedQueueMin, &cnm_queue_base);
            BCMDNX_IF_ERR_EXIT(rc);

            cpq_index = qid - cnm_queue_base;

            soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, cpq_index, &cpq_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            *arg = cpq_info.is_cp_enabled;
          }
          break;

        case bcmCosqControlCongestionThresholdRandom:
        case bcmCosqControlCongestionFeedbackMax:
        case bcmCosqControlCongestionFeedbackWeight:
        case bcmCosqControlCongestionSetPoint:
          if(SOC_IS_ARAD(unit))
          {
            rc = bcm_arad_cosq_qcn_config_get(unit, port, cosq, 0 /* no flags */, &qcn_config);
            BCMDNX_IF_ERR_EXIT(rc);

            switch(type) {
              case bcmCosqControlCongestionThresholdRandom:
                *arg = qcn_config.randomize_sample_threshold;
                break;
              case bcmCosqControlCongestionFeedbackMax:
                *arg = qcn_config.max_feedback;
                break;
              case bcmCosqControlCongestionFeedbackWeight:
                *arg = qcn_config.weight;
                break;
              case bcmCosqControlCongestionSetPoint:
                *arg = qcn_config.size;
                break;
              /* Must default. Otherwise, compilation error */
              /* coverity[dead_error_begin : FALSE]*/
              default:
                break;
            }
          }
          break;
#endif
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: COSQ control settings for egress queues gport 
 */
STATIC int
_bcm_petra_cosq_control_egress_queue_set(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32      soc_sand_rc = 0, tm_port = 0;        
    int         core;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Set Packet length */
            {                

                SOC_TMC_PORT_HEADER_TYPE header_type = 0, header_type_incoming;
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_TYPE cr_discnt_type_ndx = 0, discount_type = 0;
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO discount_data, discount_data_complement;
                int new_discount_cls, is_allocated, old_discount_cls, discount_profile_complement;
                uint32 ref_count_complement;
                
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data);
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data_complement);

                if (cosq != -1 && cosq != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter, should be general -1 or 0 cosq. This type is per port "), unit, cosq));     
                }

                if (arg < DPP_COSQ_EGRESS_CR_DISCOUNT_MIN_VAL || arg > DPP_COSQ_EGRESS_CR_DISCOUNT_MAX_VAL) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument discount %d parameter"), unit, arg));    
                }

                /* Get old data */
                rc = _bcm_dpp_am_template_egress_port_discount_cls_data_get(unit, core, tm_port, &discount_data);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Set data configuration */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port))
                {
                    discount_data.uc_credit_discount = arg;
                }
                else
                {
                    discount_data.mc_credit_discount = arg;
                }
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_egr_hdr_credit_discount_select_get,(unit, core, tm_port,&discount_type)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc); 

                discount_profile_complement = (discount_type == 0) ? 1 : 0;
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_header_type_get,(unit, core, tm_port, &header_type_incoming, &header_type)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc); 

                rc = _bcm_dpp_am_template_egress_port_discount_cls_per_header_type_ref_get(unit, core, discount_profile_complement, header_type, &ref_count_complement);
                BCMDNX_IF_ERR_EXIT(rc);

                if(ref_count_complement != 0) 
                {
                    rc = _bcm_dpp_am_template_egress_port_discount_cls_per_header_type_tdata_get(unit, core, discount_profile_complement, header_type, &discount_data_complement);
                    BCMDNX_IF_ERR_EXIT(rc);
                    if(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port) && discount_data.uc_credit_discount == discount_data_complement.uc_credit_discount) 
                    {
                        discount_data.mc_credit_discount = discount_data_complement.mc_credit_discount;
                    } 
                    else if(BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port) && discount_data.mc_credit_discount == discount_data_complement.mc_credit_discount)
                    {
                        discount_data.uc_credit_discount = discount_data_complement.uc_credit_discount;
                    }
                }
                /* Exchange SW Data */
                rc = _bcm_dpp_am_template_egress_port_discount_cls_exchange(unit, core, tm_port,&discount_data,&old_discount_cls,NULL,&new_discount_cls,&is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                cr_discnt_type_ndx = new_discount_cls;

                if (is_allocated) {
                   soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_header_type_get,(unit,core,tm_port,&header_type_incoming,&header_type)));
                   BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                   /* Set new profile data, data is being set from header type and discount type */                   
                   soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_egr_hdr_credit_discount_type_set,(unit,core,header_type,cr_discnt_type_ndx,&discount_data)));
                   BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                                                 
                }                

                /* Set new mapping port to discount type */
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_egr_hdr_credit_discount_select_set,(unit,core,tm_port,cr_discnt_type_ndx)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);          

            }
            break;      
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: COSQ control settings for egress queues gport 
 */
STATIC int
_bcm_petra_cosq_control_egress_queue_get(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int *arg)
{
    bcm_error_t rc = BCM_E_NONE;      
    int         core;
    uint32      tm_port = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);
    
    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Get Packet length */
            {
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO discount_data;                
                
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data);

                if (cosq != -1 && cosq != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter, should be general -1 or 0 cosq. This type is per port "), unit, cosq));     
                }

                /* Get old data */
                rc = _bcm_dpp_am_template_egress_port_discount_cls_data_get(unit, core, tm_port, &discount_data);
                BCMDNX_IF_ERR_EXIT(rc);
                                            
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port))
                {
                    *arg = discount_data.uc_credit_discount;
                }
                else
                {
                    *arg = discount_data.mc_credit_discount;                    
                }                  
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_profile_mapping_get(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping)
{
    bcm_error_t rv = BCM_E_NONE;
#ifdef BCM_ARAD_SUPPORT
    int qid, base_queue, profile_id;
    bcm_dpp_cosq_voq_config_t *voq_config;
    int core = BCM_CORE_ALL;
#endif /*BCM_ARAD_SUPPORT*/

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(profile_mapping);
#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit))
    {
        switch(profile_mapping->profile_type) {
        case bcmCosqIngressQueueToRateClass:
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_to_map)) {
                base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_to_map);
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport_to_map));
            }
            voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                                                 &(_dpp_cosq_config[unit].voq_hd),
                                                                                 DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue));
            if (voq_config ==  NULL) {      
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error"),
                             unit, base_queue));
            }
            if ((cosq < 0) || (cosq >= voq_config->num_cos)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
            }
            qid = base_queue + cosq;
            rv = _bcm_petra_cosq_voq_class_mapping_get(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, &profile_id);
            BCMDNX_IF_ERR_EXIT(rv);
            BCM_GPORT_PROFILE_SET(profile_mapping->mapped_profile, profile_id);
            break;
        }
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Does not support queue to rate class mapping"), unit));
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_profile_mapping_set(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping)
{
    bcm_error_t rv = BCM_E_NONE;
#ifdef BCM_ARAD_SUPPORT
    int base_queue, qid, profile_id;
    bcm_dpp_cosq_voq_config_t *voq_config;
    int core = BCM_CORE_ALL;
#endif /*BCM_ARAD_SUPPORT*/

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(profile_mapping);
#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit))
    {
        if (BCM_GPORT_IS_PROFILE(profile_mapping->mapped_profile)){
            profile_id = BCM_GPORT_PROFILE_GET(profile_mapping->mapped_profile);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of mapped profile must be BCM_GPORT_PROFILE_TYPE. gport %d is not supported."), profile_mapping->mapped_profile));
        }
        switch(profile_mapping->profile_type) {
        case bcmCosqIngressQueueToRateClass:
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_to_map)) {
                base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_to_map);
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport_to_map));
            }
            voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                                                 &(_dpp_cosq_config[unit].voq_hd),
                                                                                 DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue));
            if (voq_config ==  NULL) {      
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error"),
                             unit, base_queue));
            }
            if ((cosq < 0) || (cosq >= voq_config->num_cos)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
            }
            qid = base_queue + cosq;

            rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set(unit,core,qid,profile_id);
            BCMDNX_IF_ERR_EXIT(rv);
            break;
        }
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Does not support queue to rate class mapping"), unit));
    }
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: 
 * Verify that mapping queues from a rate class with attributes as in data_rate_class_old, 
 * to a rate class with attributes as in data_rate_class_new is legal. 
 * number of queues to be mapped is nof_queues_mapped
 * 
 * Note: Actually the only constrains we have is validating for the tail drop resources  
 */
STATIC int
_bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(int unit,
                                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_old,
                                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_new,
                                                               int nof_queues_mapped, 
                                                               int32 *reservation_change)
{
    bcm_error_t rv = BCM_E_NONE;
    int32 old_guaranteed = 0, new_guaranteed = 0;
    soc_dpp_guaranteed_q_resource_t guaranteed_q_resource;
    BCMDNX_INIT_FUNC_DEFS;
    /* 
     *  calculte: for tail drop in bds and byts:
     *  (unused guaranteed size) + old_rate_class.min_size - new_rate_class.min_size <
     *  (used guaranteed size / 50)
     *  
     */
    if (nof_queues_mapped < 0){
        /*Illegal nof_queues_mapped*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, number of queues mapped(%d) into rate class"), unit, nof_queues_mapped));
    }

    rv = SOC_DPP_WB_ENGINE_GET_VAR(unit, SOC_DPP_WB_ENGINE_VAR_ARAD_TM_GUARANTEED_Q_RESOURCE, &guaranteed_q_resource);
    BCMDNX_IF_ERR_EXIT(rv);
    if (SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode == SOC_DPP_GUARANTEED_Q_RESOURCE_MEMORY) {
        old_guaranteed = data_rate_class_old->queue_min_size;
        new_guaranteed = data_rate_class_new->queue_min_size;
    } else if (SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode == SOC_DPP_GUARANTEED_Q_RESOURCE_BDS){
        old_guaranteed = data_rate_class_old->queue_min_size_bds;
        new_guaranteed = data_rate_class_new->queue_min_size_bds;
    } else {
        /*Illegal guaranteed_q_mode*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("unit %d, Invalid guaranteed queue mode 0x%x"), unit, SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode));
    }
    *reservation_change = (new_guaranteed - old_guaranteed)*nof_queues_mapped;
    if (((int32)(guaranteed_q_resource.total - (guaranteed_q_resource.used))) - *reservation_change <
            guaranteed_q_resource.used / 50) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Ran out of resource to reserve/guarantee for queue")));
    }
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_ARAD_SUPPORT
/*
 * Purpose: Remapp an ingres queue to a rate class directly.
 * stages: 
 * 1. Validate that remapping the queue is legal for all dependent features. (taildrop) 
 * 2. Update SW state: template maneger
 * 3. Update HW: remp queue (qid)
 */
STATIC int
_bcm_petra_cosq_gport_ingress_queue_mapping_profile_set(int unit,
                                                        int core, 
                                                        int qid,
                                                        int rate_class)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class_new, data_rate_class_old;
    int old_rate_class;
    int32 reservation_change;
    BCMDNX_INIT_FUNC_DEFS;
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
     rv = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
     BCMDNX_IF_ERR_EXIT(rv);

     /* 1. Validate that remapping the queue is legal for all dependent features. */
     /* 1.1 Get old and new rate class attributes. */
     rv = _bcm_petra_cosq_voq_class_mapping_get(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, &old_rate_class);
     BCMDNX_IF_ERR_EXIT(rv);
     if (old_rate_class != rate_class) {
         rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit, old_rate_class, &data_rate_class_old);
         BCMDNX_IF_ERR_EXIT(rv);

         rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_class_new);
         BCMDNX_IF_ERR_EXIT(rv);
     
         /*1.2 Validate that expected tail drop configuration is legal, and get the expected tail drop reservation change */
         rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, &data_rate_class_old, &data_rate_class_new, 1, &reservation_change);
         BCMDNX_IF_ERR_EXIT(rv);
        
        /*
         * 2. Update SW state, map queue to new rate class 
         */
        BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_exchange(unit, old_rate_class, rate_class));
        /* 
         * 3. Update HW 
         */
        /* update mapping:*/
        rv = _bcm_petra_cosq_voq_class_mapping_set(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, rate_class);
        BCMDNX_IF_ERR_EXIT(rv);
        /* update tail drop reservation */
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, reservation_change))); 
     }

exit:
    BCMDNX_FUNC_RETURN;

}
#endif /*BCM_ARAD_SUPPORT*/
/* 
 * Purpose: Set mapping between voq and rate class
 */ 
STATIC int
_bcm_petra_cosq_voq_class_mapping_set(int unit,
                                      int core,
                                      int voq,
                                      bcm_dpp_cosq_queue_profile_type_t profile_type,
                                      int profile)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32                soc_sand_rc = 0;    
    SOC_TMC_ITM_QUEUE_INFO info;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_QUEUE_INFO_clear(&info);    

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit,core,voq,&info)));
    SOC_SAND_IF_ERR_EXIT(soc_sand_rc);

    switch(profile_type) {
        case BCM_DPP_COSQ_RATE_CLS:
            info.rate_cls = profile;
            break;
        case BCM_DPP_COSQ_DISCOUNT_CLS:
            info.credit_cls = profile;
            break;
        case BCM_DPP_COSQ_VSQ_CC:
            info.vsq_connection_cls = profile;
            break;
        case BCM_DPP_COSQ_VSQ_TC:
            info.vsq_traffic_cls = profile;
            break;
      case BCM_DPP_COSQ_QUEUE_SIGNATURE:
            info.signature = profile;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid profile type (0x%x)"), unit, profile_type));
    }    

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_set,(unit,core,voq,&info)));
    SOC_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Get mapping between voq and rate class
 */ 
STATIC int
_bcm_petra_cosq_voq_class_mapping_get(int unit,
                                      int core,
                                      int voq,
                                      bcm_dpp_cosq_queue_profile_type_t profile_type,
                                      int* profile)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32                soc_sand_rc = 0;    
    SOC_TMC_ITM_QUEUE_INFO info;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_QUEUE_INFO_clear(&info);    

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit,core,voq,&info)));
    SOC_SAND_IF_ERR_EXIT(soc_sand_rc);

    switch(profile_type) {
        case BCM_DPP_COSQ_RATE_CLS:
            *profile = info.rate_cls;
            break;
        case BCM_DPP_COSQ_DISCOUNT_CLS:
            *profile = info.credit_cls;
            break;
        case BCM_DPP_COSQ_VSQ_CC:
            *profile = info.vsq_connection_cls;
            break;
        case BCM_DPP_COSQ_VSQ_TC:
            *profile = info.vsq_traffic_cls;
            break;
      case BCM_DPP_COSQ_QUEUE_SIGNATURE:
            *profile = info.signature;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid profile type (0x%x)"), unit, profile_type));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_ARAD_SUPPORT    
/* 
 * Purpose: Configure default values in HW rate class information 
 */
int
_bcm_petra_cosq_voq_rate_class_default_set(int unit,
                                           int rate_class,
                                           bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t exact_rate_class_info;
    int tc, ocb_voq_threshold_id;
    int index;
    SOC_TMC_MGMT_OCB_VOQ_INFO ocb_info;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(rate_class_info);
    sal_memset(rate_class_info,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    SOC_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);

    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        /* max queue size */
        rate_class_info->queue_max_size[index] = DPP_COSQ_PB_ING_QUEUE_MAX_SIZE_DEFAULT_VAL;
        rate_class_info->queue_max_size_bds[index] = DPP_COSQ_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL;
        rate_class_info->queue_alpha_bds[index] = ARAD_PLUS_MAX_ALPHA;

        /* WRED */
        rate_class_info->wred_enable[index] = 0;  
    }
    
    /* ECN configuration */
    rate_class_info->ecn_wred_enable = 0;              
    rate_class_info->ecn_queue_max_size = SOC_IS_ARADPLUS(unit) ? DPP_COSQ_PB_ING_QUEUE_MAX_SIZE_DEFAULT_VAL / 2 : ARAD_MAX_QUEUE_SIZE_BYTES;
    rate_class_info->ecn_queue_max_size_bds = DPP_COSQ_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL / 2;


    /* Guaranteed queue size */
    rate_class_info->queue_min_size = 0;
    rate_class_info->queue_min_size_bds = 0;

    rate_class_info->wred_exp_wq = DPP_COSQ_PB_ING_WRED_EXP_WQ_DEFAULT_VAL;

    if (SOC_IS_ARAD(unit)) {
        /* ocb information */
        for(tc = 0; tc < DPP_DEVICE_COSQ_ING_NOF_TC; ++tc){
            for(index = 0; index < DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){                  
                rate_class_info->ocb_info[tc][index].voq_eligible = ocb_info.voq_eligible;
                for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
                {
                    rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_info.th_buffers[ocb_voq_threshold_id];
                    rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_info.th_words[ocb_voq_threshold_id];
                }
            }
        }
    }
   
    /* system RED rate class */
    SOC_TMC_ITM_SYS_RED_QT_INFO_clear(&rate_class_info->sys_red_qt);
    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        SOC_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&rate_class_info->sys_red_qt_dp[index]);
    }
    
    rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit, rate_class, rate_class_info, &exact_rate_class_info);
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}
#endif /*BCM_ARAD_SUPPORT*/

/* 
 * Purpose: Get in HW rate class information 
 */
STATIC int
_bcm_petra_cosq_voq_rate_class_hw_get(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info)
{
    bcm_error_t rv = BCM_E_NONE;
    uint32                soc_sand_rc = 0;    
    int index, set_alpha;
#ifdef BCM_ARAD_SUPPORT
    int tc, ocb_voq_threshold_id;
    SOC_TMC_MGMT_OCB_VOQ_INFO ocb_info;
#endif
    SOC_TMC_ITM_TAIL_DROP_INFO tail_drop_info;
    SOC_TMC_ITM_WRED_QT_DP_INFO wred_info;
    SOC_TMC_ITM_SYS_RED_QT_INFO sys_red_qt_info;
    SOC_TMC_ITM_SYS_RED_QT_DP_INFO sys_red_qt_dp_info;
    int32 alpha = 0;

#ifdef BCM_ARAD_SUPPORT
    int min_supported = SOC_IS_ARAD(unit);
#else
    int min_supported = 0;
#endif

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_NULL_CHECK(rate_class_info);    
    
#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit)){
        SOC_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);
    }
#endif

    set_alpha = SOC_IS_ARADPLUS(unit);

    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        SOC_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_tail_drop_get,(unit,rate_class,index,&tail_drop_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        /* max queue size */
        rate_class_info->queue_max_size[index] = tail_drop_info.max_inst_q_size;
        rate_class_info->queue_max_size_bds[index] = tail_drop_info.max_inst_q_size_bds ;

        /* WRED */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_get,(unit,rate_class,index,&wred_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        rate_class_info->wred_min_avrg_th[index] = wred_info.min_avrg_th;
        rate_class_info->wred_max_avrg_th[index] = wred_info.max_avrg_th;
        rate_class_info->wred_max_probability[index] = wred_info.max_probability;
        rate_class_info->wred_enable[index] = wred_info.wred_en;              

        if (set_alpha) {
            BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_alpha_get,(unit, rate_class, index, &alpha)));
            rate_class_info->queue_alpha_bds[index] = alpha;
        } else {
            rate_class_info->queue_alpha_bds[index] = 0;
        }
    }

    if (!SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        /* ECN configuration */
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_get,(unit, rate_class, BCM_DPP_ECN_DP, &wred_info)));
        rate_class_info->ecn_wred_min_avrg_th = wred_info.min_avrg_th;
        rate_class_info->ecn_wred_max_avrg_th = wred_info.max_avrg_th;
        rate_class_info->ecn_wred_max_probability = wred_info.max_probability;
        rate_class_info->ecn_wred_enable = wred_info.wred_en;              

        SOC_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_tail_drop_get,(unit, rate_class, BCM_DPP_ECN_DP, &tail_drop_info)));
        /* The mbcm call initializes the variable tail_drop_info */
        /* coverity[uninit_use:FALSE] */
        rate_class_info->ecn_queue_max_size = tail_drop_info.max_inst_q_size;
        /* coverity[uninit_use:FALSE] */
        rate_class_info->ecn_queue_max_size_bds = tail_drop_info.max_inst_q_size_bds;
    }

    /* Guaranteed queue size */
    if (min_supported) {
        SOC_TMC_ITM_GUARANTEED_INFO guaranteed_info;
        sal_memset(&guaranteed_info, 0x0, sizeof(guaranteed_info));
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_committed_q_size_get,(unit, rate_class, &guaranteed_info)));
        rate_class_info->queue_min_size = guaranteed_info.guaranteed_size;
        rate_class_info->queue_min_size_bds = guaranteed_info.guaranteed_size_bds;
    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_exp_wq_get,(unit,rate_class,&(rate_class_info->wred_exp_wq))));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit))
    {
        /* ocb information */
        for(tc = 0; tc < DPP_DEVICE_COSQ_ING_NOF_TC; ++tc){
            for(index = 0; index < DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){
                soc_sand_rc = arad_mgmt_ocb_voq_eligible_get(unit, index, rate_class, tc, &ocb_info);
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                        
                rate_class_info->ocb_info[tc][index].voq_eligible = ocb_info.voq_eligible;
                for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
                {
                    rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_info.th_buffers[ocb_voq_threshold_id];
                    rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_info.th_words[ocb_voq_threshold_id];
                }
            }
        }
    }
#endif

    /* System RED */
    SOC_TMC_ITM_SYS_RED_QT_INFO_clear(&sys_red_qt_info);
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_queue_size_boundaries_get,(unit, rate_class, &sys_red_qt_info)));
    for (index = 0; index < SOC_TMC_ITM_SYS_RED_Q_SIZE_RANGES; index++) {
         rate_class_info->sys_red_qt.queue_size_boundaries[index] = sys_red_qt_info.queue_size_boundaries[index];
    }

    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        SOC_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&sys_red_qt_dp_info);
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_q_based_get,(unit, rate_class, index, &sys_red_qt_dp_info)));
        rate_class_info->sys_red_qt_dp[index].adm_th = sys_red_qt_dp_info.adm_th;
        rate_class_info->sys_red_qt_dp[index].drp_prob_high = sys_red_qt_dp_info.drp_prob_high;
        rate_class_info->sys_red_qt_dp[index].drp_prob_low  = sys_red_qt_dp_info.drp_prob_low;
        rate_class_info->sys_red_qt_dp[index].drp_th = sys_red_qt_dp_info.drp_th;
        rate_class_info->sys_red_qt_dp[index].enable = sys_red_qt_dp_info.enable;
        rate_class_info->sys_red_qt_dp[index].prob_th = sys_red_qt_dp_info.prob_th;
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Commit in HW rate class information 
 */
STATIC int
_bcm_petra_cosq_voq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *exact_rate_class_info)
{
    bcm_error_t rv = BCM_E_NONE;
    uint32                soc_sand_rc = 0;    
    int index, set_alpha;
#ifdef BCM_ARAD_SUPPORT
    int tc, ocb_voq_threshold_id;
    SOC_TMC_MGMT_OCB_VOQ_INFO ocb_info, ocb_exact_info;
#endif
    SOC_TMC_ITM_TAIL_DROP_INFO tail_drop_info, exact_tail_drop_info;
    SOC_TMC_ITM_WRED_QT_DP_INFO wred_info, exact_wred_info;
    soc_dpp_config_t *dpp = SOC_DPP_CONFIG(unit);
    SOC_TMC_ITM_SYS_RED_QT_INFO sys_red_qt_info;
    SOC_TMC_ITM_SYS_RED_QT_DP_INFO sys_red_qt_dp_info;
    
#ifdef BCM_ARAD_SUPPORT
    int min_supported = SOC_IS_ARAD(unit);
#else
    int min_supported = 0;
#endif

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_NULL_CHECK(rate_class_info);    
    
    SOC_TMC_ITM_TAIL_DROP_INFO_clear(&exact_tail_drop_info);       
    SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&exact_wred_info);
    
#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit)){
        SOC_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);
    }
#endif

    dpp = SOC_DPP_CONFIG(unit);
    set_alpha = SOC_IS_ARADPLUS(unit);

    sal_memcpy(exact_rate_class_info, rate_class_info, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        SOC_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_tail_drop_get,(unit,rate_class,index,&tail_drop_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        /* max queue size */
        tail_drop_info.max_inst_q_size = rate_class_info->queue_max_size[index];
        tail_drop_info.max_inst_q_size_bds = rate_class_info->queue_max_size_bds[index];

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_tail_drop_set,(unit, rate_class, index, &tail_drop_info, &exact_tail_drop_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        
        exact_rate_class_info->queue_max_size[index] = exact_tail_drop_info.max_inst_q_size;
        exact_rate_class_info->queue_max_size_bds[index] = exact_tail_drop_info.max_inst_q_size_bds;

        /* WRED */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_get,(unit,rate_class,index,&wred_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        wred_info.max_avrg_th = rate_class_info->wred_max_avrg_th[index];
        wred_info.min_avrg_th = rate_class_info->wred_min_avrg_th[index];
        wred_info.max_probability = rate_class_info->wred_max_probability[index];
        wred_info.wred_en = rate_class_info->wred_enable[index];
        wred_info.ignore_packet_size = (dpp->tm.wred_packet_size == 0) ? 1:0;
        wred_info.max_packet_size = dpp->tm.wred_packet_size;
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_set,(unit,rate_class,index,&wred_info,&exact_wred_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                        

        if (set_alpha) {
            BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_alpha_set,(unit, rate_class, index, rate_class_info->queue_alpha_bds[index])));
            exact_rate_class_info->queue_alpha_bds[index] = rate_class_info->queue_alpha_bds[index];
        } else {
            exact_rate_class_info->queue_alpha_bds[index] = 0;
        }

        /* Set exact rate class information according to exact wred information */
        exact_rate_class_info->wred_min_avrg_th[index] = exact_wred_info.min_avrg_th;
        exact_rate_class_info->wred_max_avrg_th[index] = exact_wred_info.max_avrg_th;
        exact_rate_class_info->wred_max_probability[index] = exact_wred_info.max_probability;
        exact_rate_class_info->wred_enable[index] = exact_wred_info.wred_en;              
    }

    if (!SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        /* ECN configuration */
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
        wred_info.max_avrg_th = rate_class_info->ecn_wred_max_avrg_th;
        wred_info.min_avrg_th = rate_class_info->ecn_wred_min_avrg_th;
        wred_info.max_probability = rate_class_info->ecn_wred_max_probability;
        wred_info.wred_en = rate_class_info->ecn_wred_enable;
        wred_info.ignore_packet_size = (dpp->tm.wred_packet_size == 0) ? 1:0;
        wred_info.max_packet_size = dpp->tm.wred_packet_size;
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_set,(unit, rate_class, BCM_DPP_ECN_DP, &wred_info, &exact_wred_info)));
        exact_rate_class_info->ecn_wred_min_avrg_th = exact_wred_info.min_avrg_th;
        exact_rate_class_info->ecn_wred_max_avrg_th = exact_wred_info.max_avrg_th;
        exact_rate_class_info->ecn_wred_max_probability = exact_wred_info.max_probability;
        exact_rate_class_info->ecn_wred_enable = exact_wred_info.wred_en;              

        SOC_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        tail_drop_info.max_inst_q_size = rate_class_info->ecn_queue_max_size;
        tail_drop_info.max_inst_q_size_bds = rate_class_info->ecn_queue_max_size_bds;
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_tail_drop_set,(unit, rate_class, BCM_DPP_ECN_DP, &tail_drop_info, &exact_tail_drop_info)));
        exact_rate_class_info->ecn_queue_max_size = exact_tail_drop_info.max_inst_q_size;
        exact_rate_class_info->ecn_queue_max_size_bds = exact_tail_drop_info.max_inst_q_size_bds;
    }

    /* Guaranteed queue size */
    if (min_supported) {
        SOC_TMC_ITM_GUARANTEED_INFO guaranteed_info, exact_guaranteed_info;
        guaranteed_info.guaranteed_size = rate_class_info->queue_min_size;
        guaranteed_info.guaranteed_size_bds = rate_class_info->queue_min_size_bds;
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_committed_q_size_set,(unit, rate_class, &guaranteed_info, &exact_guaranteed_info)));
        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        exact_rate_class_info->queue_min_size = exact_guaranteed_info.guaranteed_size;
        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        exact_rate_class_info->queue_min_size_bds = exact_guaranteed_info.guaranteed_size_bds;
    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_exp_wq_set,(unit,rate_class,rate_class_info->wred_exp_wq)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    exact_rate_class_info->wred_exp_wq = rate_class_info->wred_exp_wq;

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit))
    {
        /* ocb information */
        for(tc = 0; tc < DPP_DEVICE_COSQ_ING_NOF_TC; ++tc){
            for(index = 0; index < DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){
                soc_sand_rc = arad_mgmt_ocb_voq_eligible_get(unit, index, rate_class, tc, &ocb_info);
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                        
                ocb_info.voq_eligible = rate_class_info->ocb_info[tc][index].voq_eligible;
                for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
                {
                    ocb_info.th_buffers[ocb_voq_threshold_id] = rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id];
                    ocb_info.th_words[ocb_voq_threshold_id] = rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id];
                }
                soc_sand_rc = arad_mgmt_ocb_voq_eligible_set(unit, index, rate_class, tc, &ocb_info, &ocb_exact_info);
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                        
                for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
                {
                    exact_rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_exact_info.th_buffers[ocb_voq_threshold_id];
                    exact_rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_exact_info.th_words[ocb_voq_threshold_id];
                }
            }
        }
    }
#endif

    /* System RED */
    SOC_TMC_ITM_SYS_RED_QT_INFO_clear(&sys_red_qt_info);
    for (index = 0; index < SOC_TMC_ITM_SYS_RED_Q_SIZE_RANGES; index++) {
        sys_red_qt_info.queue_size_boundaries[index] = rate_class_info->sys_red_qt.queue_size_boundaries[index];
    }
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_queue_size_boundaries_set,(unit, rate_class, &sys_red_qt_info, &exact_rate_class_info->sys_red_qt)));

    SOC_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&sys_red_qt_dp_info);
    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        sys_red_qt_dp_info.adm_th        = rate_class_info->sys_red_qt_dp[index].adm_th;
        sys_red_qt_dp_info.drp_prob_high = rate_class_info->sys_red_qt_dp[index].drp_prob_high;
        sys_red_qt_dp_info.drp_prob_low  = rate_class_info->sys_red_qt_dp[index].drp_prob_low;
        sys_red_qt_dp_info.drp_th        = rate_class_info->sys_red_qt_dp[index].drp_th;
        sys_red_qt_dp_info.enable        = rate_class_info->sys_red_qt_dp[index].enable;
        sys_red_qt_dp_info.prob_th       = rate_class_info->sys_red_qt_dp[index].prob_th;
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_q_based_set,(unit, rate_class, index, &sys_red_qt_dp_info)));
    }
             
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Commit in HW rate class information 
 */
STATIC int
_bcm_petra_cosq_sys_red_dp_pr_hw_set(int unit,
                                     int dp_pr,
                                     bcm_dpp_cosq_ingress_system_red_dp_pr_info_t *rate_sys_red_dp_pr_info)
{
    bcm_error_t rv = BCM_E_NONE;
    SOC_TMC_ITM_SYS_RED_DROP_PROB prob_info;

    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_ITM_SYS_RED_DROP_PROB_clear(&prob_info);

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_drop_prob_get,(unit, &prob_info)));
    prob_info.drop_probs[dp_pr] = rate_sys_red_dp_pr_info->sys_red_dp_pr_val;
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_drop_prob_set,(unit, &prob_info)));

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Retreive queue maximal & guaranteed from gport size structure to a rate class data structure 
 */
STATIC int
_bcm_petra_cosq_gport_gport_size_to_rate_class(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t* gport_size,
                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                               int set_alpha, 
                                               int min_supported)
{
    int index = 0;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    BCMDNX_NULL_CHECK(data_rate_class);
    /* Change related information */        
    if (flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED) {
        data_rate_class->sys_red_qt.queue_size_boundaries[color] = gport_size->size_max;
    } else if (flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND) {
        /* Set all dp information */
        for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
            if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
                data_rate_class->queue_max_size[index] = gport_size->size_max;
            } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                data_rate_class->queue_max_size_bds[index] = gport_size->size_max;
                if (set_alpha) {
                    data_rate_class->queue_alpha_bds[index] = gport_size->size_alpha_max;
                }
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
            }        
        }
    } else {
        /* Set specific dp */
        if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
            data_rate_class->queue_max_size[color] = gport_size->size_max;
        } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
            data_rate_class->queue_max_size_bds[color] = gport_size->size_max;
            if (set_alpha) {
                data_rate_class->queue_alpha_bds[color] = gport_size->size_alpha_max;
            }
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
        }        
    }
    if (min_supported) {
        /* The concept of guaranteed is not supported by hardware for ingress replicated copies. We do not check that such queues are not guaranteed here */
        if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
            data_rate_class->queue_min_size = gport_size->size_min;
        } else {
            data_rate_class->queue_min_size_bds = gport_size->size_min;
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
 
}

/* 
 * Purpose: Retreive queue maximal & guaranteed from rate class data structure to a gport size structure 
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_to_gport_size(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t *gport_size,
                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class)
{
    bcm_error_t rv = BCM_E_NONE;
    uint32 relevant_flags;
#ifdef BCM_ARAD_SUPPORT
    int min_supported = SOC_IS_ARAD(unit);
#else
    int min_supported = 0;
#endif
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    BCMDNX_NULL_CHECK(data_rate_class);

    /* Validate params */
    relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC |
                              BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && (!(flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED)) && ((color < 0) || (color >= DPP_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 


    if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
        gport_size->size_max = data_rate_class->queue_max_size[color];
        gport_size->size_min = min_supported ? data_rate_class->queue_min_size : 0;
        gport_size->size_alpha_max = ARAD_PLUS_ALPHA_NOT_SUPPORTED;
    } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
        gport_size->size_max = data_rate_class->queue_max_size_bds[color];
        gport_size->size_min = min_supported ? data_rate_class->queue_min_size_bds : 0;
        gport_size->size_alpha_max = SOC_IS_ARADPLUS(unit) ? data_rate_class->queue_alpha_bds[color] : ARAD_PLUS_ALPHA_NOT_SUPPORTED;
    } else if (flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED) {
        gport_size->size_max = data_rate_class->sys_red_qt.queue_size_boundaries[color];
        gport_size->size_min = 0;
        gport_size->size_alpha_max = ARAD_PLUS_ALPHA_NOT_SUPPORTED;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));       
    }        
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Verify param given to a gport color size API, 
 * maximal & guaranteed size
 */
STATIC int
_bcm_petra_cosq_gport_voq_color_size_verify(int unit, 
                                            bcm_color_t color,
                                            uint32      flags,
                                            bcm_cosq_gport_size_t* gport_size,
                                            int*        set_alpha, 
                                            int*        min_supported) 
{
    uint32 relevant_flags;
    BCMDNX_INIT_FUNC_DEFS;
#ifdef BCM_ARAD_SUPPORT
    *min_supported = SOC_IS_ARAD(unit);
#else
    *min_supported = 0;
#endif

    relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | 
                              BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && 
        (!(flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED)) && 
        ((color < 0) || (color >= DPP_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    /* check that size_min is only used with the resource configured to be guaranteed for the device */
    if (*min_supported && gport_size->size_min) {
        if ((flags & BCM_COSQ_GPORT_SIZE_BYTES) && SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode != SOC_DPP_GUARANTEED_Q_RESOURCE_MEMORY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d is not configured for minimal/guaranteed queue size by memory/bytes"), unit));
        }
        if ((flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) && SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode != SOC_DPP_GUARANTEED_Q_RESOURCE_BDS) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d is not configured for minimal/guaranteed queue size by BDs"), unit));
        }
    }
    if (SOC_IS_ARADPLUS(unit) && (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC)) {
        if (gport_size->size_alpha_max < ARAD_PLUS_MIN_ALPHA || gport_size->size_alpha_max > ARAD_PLUS_MAX_ALPHA) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Illegal size_alpha_max value %d, must be in range %d..%d"),
              gport_size->size_alpha_max, ARAD_PLUS_MIN_ALPHA, ARAD_PLUS_MAX_ALPHA));
        }
        *set_alpha = 1;
    }

exit:
    BCMDNX_FUNC_RETURN;
}
#ifdef BCM_ARAD_SUPPORT
/* 
 * Purpose: Set queue maximal & guaranteed size of a rate class
 * if we called the function in advance mode queue to rate class mapping mode then 
 *    1. if the advance mode is not set then set it
 *    2. configure the rate class directly
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_color_size_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_color_t color,
                                                uint32 flags,
                                                bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t 
        data_rate_class, 
        data_rate_class_old, 
        exact_data_rate_class;
    uint32 ref_count;
    int set_alpha = 0, min_supported = 1;
    int32 reservation_change = 0;
    int rate_class;
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&data_rate_class_old,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }

     /*validate that we use the right mapping mode*/
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    /* 
     * Check that the system is in advance queue to rate class mapping mode, 
     *    if not set it to advance mode.
     */
    rv = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_petra_cosq_gport_voq_color_size_verify(unit, color, flags, gport_size, &set_alpha, &min_supported);
    BCMDNX_IF_ERR_EXIT(rv);

    /* 1. Get rate class data */
    rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_class_old);
    BCMDNX_IF_ERR_EXIT(rv);        
    
    sal_memcpy(&data_rate_class, &data_rate_class_old, sizeof(data_rate_class));

    /* Change related information */        
    rv = _bcm_petra_cosq_gport_gport_size_to_rate_class(unit, color, flags, gport_size, &data_rate_class,set_alpha, min_supported);
    BCMDNX_IF_ERR_EXIT(rv);

    BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_get(unit,rate_class, &ref_count));

    /* check that the remaining resource level is not too low - currently 2% */
    rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit,&data_rate_class_old, &data_rate_class, ref_count, &reservation_change);
    BCMDNX_IF_ERR_EXIT(rv);

    /*2. configure HW*/
    rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit,rate_class,&data_rate_class,&exact_data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    /*recalculate the reservation_change*/
    rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit,&data_rate_class_old, &exact_data_rate_class, ref_count, &reservation_change);
    BCMDNX_IF_ERR_EXIT(rv);

    /*Update HW: total reservation*/
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, reservation_change))); /* update reservation */

exit:
    BCMDNX_FUNC_RETURN;
     
}
#endif /*BCM_ARAD_SUPPORT*/
 
/* 
 * Purpose: Set queue maximal & guaranteed size
 */
int
_bcm_petra_cosq_gport_voq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_voq_config_t *voq_config;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class_old, data_rate_class, exact_data_rate_class,cleared_data_rate;
    int base_qid, qid;
    int new_rate_class, new_rate_class2, old_rate_class, is_allocated, is_allocated2, is_last;
    int set_alpha = 0;
    int32 reservation_change;
    int min_supported = 0;
    int core = BCM_CORE_ALL;
    
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    BCMDNX_NULL_CHECK(gport_size);
#ifdef BCM_ARAD_SUPPORT
    /* Enable Simple Mode*/
    if (SOC_IS_ARAD(unit)){
        BCM_SAND_IF_ERR_EXIT(_bcm_petra_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));
    }
#endif /*BCM_ARAD_SUPPORT*/
    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)){
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport));
    }

    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                                         &(_dpp_cosq_config[unit].voq_hd),
                                                                         DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid));
    if (voq_config ==  NULL) {      
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error"),
                     unit, base_qid));
    }
    if ((cosq < 0) || (cosq >= voq_config->num_cos)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
    }
    rv = _bcm_petra_cosq_gport_voq_color_size_verify(unit, color, flags, gport_size, &set_alpha, &min_supported);
    BCMDNX_IF_ERR_EXIT(rv);

    qid = base_qid + cosq;
    /*
     * Settings Tail drop & guaranteed parameters done in these stages:
     * 1. Get the current rate class template, and update its values with the function arguments.
     * 2. Check if a template with the new values exists or can be allocated.
     * 3. If a new template is needed, write it and see if the new values are legal, and get the exact template values.
     * 4. Write to software the template with the exact values, if it is a new one, also write it to hardware.
     * 5. If in stage 4, the template number changed, update the hardware.
     * 6. Write the final rate class template number for the queue.
     */
    /*Get the current rate class template, and update its values with the function arguments*/
    /*1.1 Get old rate class data */
    rv = _bcm_dpp_am_template_queue_rate_cls_data_get(unit,qid,&data_rate_class_old);
    BCMDNX_IF_ERR_EXIT(rv);

    /*1.2 copy data to use as the new */
    sal_memcpy(&data_rate_class, &data_rate_class_old, sizeof(data_rate_class));

    /*1.3 Change related information */        
    rv = _bcm_petra_cosq_gport_gport_size_to_rate_class(unit, color, flags, gport_size, &data_rate_class,set_alpha, min_supported);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit,&data_rate_class_old, &data_rate_class, 1, &reservation_change);
    BCMDNX_IF_ERR_EXIT(rv);

    /* 2. Test if an update information in SW will succeed. If so, a later update with the exact information should also succeed. */
    rv = _bcm_dpp_am_template_queue_rate_cls_exchange_test(unit, qid, &data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rv);
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "exchange test:  is_last=%d new_rate_class=%d is_allocated=%d"), is_last, new_rate_class, is_allocated));

    /* 3. If this is a new template, write it to hardware, getting back the exact values written to hardware */
    if (is_allocated) {
        rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit,new_rate_class,&data_rate_class,&exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);        
    } else {
        sal_memcpy(&exact_data_rate_class, &data_rate_class, sizeof(exact_data_rate_class));
    }
    if (min_supported) {
        /*recalculate the reservation_change*/
        rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit,&data_rate_class_old, &exact_data_rate_class, 1, &reservation_change);
        BCMDNX_IF_ERR_EXIT(rv);
        /*Update HW: total reservation*/
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, reservation_change)));
    }


    /* 4. Write to software the exact template */
    rv = _bcm_dpp_am_template_queue_rate_cls_exchange(unit, qid, &exact_data_rate_class, &old_rate_class, &is_last, &new_rate_class2, &is_allocated2);
    BCMDNX_IF_ERR_EXIT(rv); /* Should never fail */
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "exchange:       is_last=%d new_rate_class=%d is_allocated=%d"), is_last, new_rate_class2, is_allocated));

    if (new_rate_class2 != new_rate_class) { /* 5. If we now have a different template than previously found */
        if (is_allocated2) { /* If this is a new template, write it to hardware */
            rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit, new_rate_class2, &exact_data_rate_class, &cleared_data_rate);
            BCMDNX_IF_ERR_EXIT(rv);        
        }
        if (is_allocated) { /* Clear the template written to before */
            sal_memset(&data_rate_class, 0x0, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
            rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit, new_rate_class, &data_rate_class, &cleared_data_rate);
        }
    }
    /* 6. Map the queue to the new template in hardware */
    rv = _bcm_petra_cosq_voq_class_mapping_set(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, new_rate_class2);
    BCMDNX_IF_ERR_EXIT(rv);

    /* last profile data */
    if (is_last && new_rate_class2 != old_rate_class) {
        /* clear profile data */
        sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
        rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit,old_rate_class,&data_rate_class,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rv);
    }   
#ifdef BCM_WARM_BOOT_SUPPORT
    rv = _bcm_dpp_wb_cosq_update_ingr_rate_class_data(unit, 0, old_rate_class, new_rate_class2);
    BCMDNX_IF_ERR_EXIT(rv);
#endif /* BCM_WARM_BOOT_SUPPORT */
exit:
    BCMDNX_FUNC_RETURN;
}


#ifdef BCM_ARAD_SUPPORT
/* 
 * Purpose: Retreive queue maximal & guaranteed size of a rate class
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_color_size_get(int unit,
                                                bcm_gport_t gport,
                                                bcm_color_t color,
                                                uint32 flags,
                                                bcm_cosq_gport_size_t *gport_size) 
{
    bcm_error_t rv = BCM_E_NONE;
    int rate_class;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }

    /*validate profiles range*/
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    
    rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_petra_cosq_gport_rate_class_to_gport_size(unit, color, flags, gport_size, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

exit:
    BCMDNX_FUNC_RETURN;
}
#endif /*BCM_ARAD_SUPPORT*/

/* 
 * Purpose: Retreive queue maximal & guaranteed size
 */
STATIC int
_bcm_petra_cosq_gport_voq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_voq_config_t *voq_config;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;
    int base_qid, qid; 
#ifdef BCM_ARAD_SUPPORT
    int rate_class;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
#endif /*BCM_ARAD_SUPPORT*/
    int core = BCM_CORE_ALL;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)){
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport %d is not allowed for minimal/guaranteed queue size by memory/bytes configuration"), unit, gport ));
    }

    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                                         &(_dpp_cosq_config[unit].voq_hd),
                                                                         DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid));

    if (voq_config ==  NULL) {      
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error"),
                     unit, base_qid));
    } else if (voq_config->num_cos == 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, voq %d not added"), unit, base_qid));
    }

    if ((cosq < 0) || (cosq >= voq_config->num_cos)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
    }

    qid = base_qid + cosq;
#ifdef BCM_ARAD_SUPPORT
    /* Get old rate class data */
    BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_get(unit, &queue_to_rate_class_mapping_is_simple));
    if (SOC_IS_ARAD(unit) && queue_to_rate_class_mapping_is_simple != ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        rv = _bcm_petra_cosq_voq_class_mapping_get(unit,core,qid,BCM_DPP_COSQ_RATE_CLS,&rate_class);
        BCMDNX_IF_ERR_EXIT(rv);

        rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);

        rv = _bcm_petra_cosq_gport_rate_class_to_gport_size(unit, color, flags, gport_size, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);
    } else
#endif /*BCM_ARAD_SUPPORT*/
    {
        /* Get old rate class data */
        rv = _bcm_dpp_am_template_queue_rate_cls_data_get(unit,qid,&data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);

        rv = _bcm_petra_cosq_gport_rate_class_to_gport_size(unit, color, flags, gport_size, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_voq_discard_retreive_dps(int unit,
                                         uint32 flags,
                                         int *dps,
                                         int *nof_dps)
{
    int index = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(dps);
    BCMDNX_NULL_CHECK(nof_dps);

    if ((flags & BCM_COSQ_DISCARD_COLOR_ALL) == BCM_COSQ_DISCARD_COLOR_ALL) {
        /* The configuration is relevanat for all dps */
        for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
            dps[index] = index;
        }
        *nof_dps = DPP_DEVICE_COSQ_ING_NOF_DP;
        BCM_EXIT;        
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_GREEN) {
        dps[index++] = 0;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_YELLOW) {
        dps[index++] = 1;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_RED) {
        dps[index++] = 2;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_BLACK) {
        dps[index++] = 3;
    }

    *nof_dps = index;

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * System RED discard/drop probability set
 */
STATIC int 
_bcm_petra_cosq_sys_red_dp_pr_set(int unit,
                                  bcm_dpp_cosq_ingress_rate_class_info_t *data_rate_class,
                                  bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int index = 0, is_last = 0, is_allocated = 0, dp_pr_idx = 0;
    int nof_drop_prec = 0;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];

    bcm_dpp_cosq_ingress_system_red_dp_pr_info_t data_sys_red_dp_pr;
    int new_sys_red_dp_pr_ndx, old_sys_red_dp_pr_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    /* update rate_class with new drop_probability*/
    rc = _bcm_petra_cosq_voq_discard_retreive_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec == 0) {
        /* Nothing to change, just exit */
        BCM_EXIT;
    }

    for (index = 0; index < nof_drop_prec; index++) {
        /* check if discard->drop_probability already exist in am */
        data_sys_red_dp_pr.sys_red_dp_pr_val = discard->drop_probability;

        /* Stage 1: Find new profile according to given settings */

        /* Update information in SW */
        if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
            dp_pr_idx = data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_low;
        } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
            dp_pr_idx = data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_high;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
        }
        rc = _bcm_dpp_am_template_system_red_dp_pr_exchange(unit, dp_pr_idx, &data_sys_red_dp_pr, &old_sys_red_dp_pr_ndx, 
                                                            &is_last, &new_sys_red_dp_pr_ndx, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Commit Changes in HW according to given thresholds */
        if (is_allocated) {
            rc = _bcm_petra_cosq_sys_red_dp_pr_hw_set(unit,new_sys_red_dp_pr_ndx,&data_sys_red_dp_pr);
            BCMDNX_IF_ERR_EXIT(rc);        
        } 
        
        /* Clear old profile */
        if (is_last && new_sys_red_dp_pr_ndx != old_sys_red_dp_pr_ndx) {
            sal_memset(&data_sys_red_dp_pr, 0x0, sizeof(bcm_dpp_cosq_ingress_system_red_dp_pr_info_t));
            rc = _bcm_petra_cosq_sys_red_dp_pr_hw_set(unit, old_sys_red_dp_pr_ndx, &data_sys_red_dp_pr);
            BCMDNX_IF_ERR_EXIT(rc);    
        }
       
        if (discard->flags & BCM_COSQ_DISCARD_ENABLE) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].enable = 0x1;
        } else {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].enable = 0x0;
        }

        if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].adm_th       = discard->min_thresh;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_low = new_sys_red_dp_pr_ndx;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].prob_th      = discard->max_thresh;
        } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].prob_th       = discard->min_thresh;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_high = new_sys_red_dp_pr_ndx;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_th        = discard->max_thresh;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
        }
    }
   
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_sys_red_dp_pr_get(int unit,
                                  bcm_dpp_cosq_ingress_rate_class_info_t *data_rate_class,
                                  bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int dp_pr_idx = 0x0, dp_index = 0x0;
    int nof_drop_prec = 0x0;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];

    bcm_dpp_cosq_ingress_system_red_dp_pr_info_t data_sys_red_dp_pr;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    /* update rate_class with new drop_probability*/
    rc = _bcm_petra_cosq_voq_discard_retreive_dps(unit, discard->flags, drop_prec, &nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec != 1) {
        /* Can get only one color value */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color\n"), unit, discard->flags));
    }

    dp_index = drop_prec[0];

    if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
        discard->min_thresh = data_rate_class->sys_red_qt_dp[dp_index].adm_th;
        dp_pr_idx = data_rate_class->sys_red_qt_dp[dp_index].drp_prob_low;
        discard->max_thresh = data_rate_class->sys_red_qt_dp[dp_index].prob_th;            
    } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
        discard->min_thresh = data_rate_class->sys_red_qt_dp[dp_index].prob_th;
        dp_pr_idx = data_rate_class->sys_red_qt_dp[dp_index].drp_prob_high;
        discard->max_thresh = data_rate_class->sys_red_qt_dp[dp_index].drp_th;
    } else {
        /* Must use one of these flags */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
    }

    rc = _bcm_dpp_am_template_system_red_dp_pr_data_get(unit, dp_pr_idx, &data_sys_red_dp_pr);
    BCMDNX_IF_ERR_EXIT(rc);

    discard->drop_probability = data_sys_red_dp_pr.sys_red_dp_pr_val;

    if (data_rate_class->sys_red_qt_dp[dp_index].enable == 0x1) {
        discard->flags |= BCM_COSQ_DISCARD_ENABLE;
    } else {
        discard->flags &= BCM_COSQ_DISCARD_ENABLE;
    }

    discard->gain = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_discard_verify(int unit,
                                     bcm_cosq_gport_discard_t *discard,
                                     int is_vsq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 relevant_flags, max_drop_probability, max_discard_gain;

    BCMDNX_INIT_FUNC_DEFS;
    
    if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) {
        max_drop_probability = BCM_DPP_COSQ_DISCARD_SYSTEM_RED_FROP_PROB;
        relevant_flags = discard->flags;
        max_discard_gain = 0x0;
    } else {
        relevant_flags = discard->flags & (is_vsq ?
        (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
        BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_ALL |
        BCM_COSQ_DISCARD_BYTES) :
        (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
        BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_ALL |
        BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_MARK_CONGESTION | BCM_COSQ_DISCARD_BUFFER_DESC) );

        max_drop_probability = BCM_DPP_COSQ_DISCARD_FROP_PROB;
        max_discard_gain = DPP_COSQ_PB_WRED_WQ_MAX;
    }

    if (discard->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, discard->flags));
    }

    if (discard->drop_probability < 0 || discard->drop_probability > max_drop_probability) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid drop probability parameter %d"), unit, discard->drop_probability));
    }

    if (discard->gain < 0 || discard->gain > max_discard_gain) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gain parameter %d"), unit, discard->drop_probability));
    }
    
    if (discard->min_thresh > discard->max_thresh) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Min threshold %d is over Max threshold %d"), 
                       unit, discard->min_thresh,discard->max_thresh));
    }

    if (discard->min_thresh < 0 || (SOC_IS_PETRAB(unit) && discard->min_thresh > DPP_COSQ_PB_WRED_MIN_AVRG_TH_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Min threshold %d is invalid"), 
                       unit, discard->min_thresh));
    }

    if (discard->max_thresh < 0 || (SOC_IS_PETRAB(unit) && discard->max_thresh > DPP_COSQ_PB_WRED_MAX_AVRG_TH_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Max threshold %d is invalid"), 
                       unit, discard->max_thresh));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Retreive WRED configuration from discard structure to a rate class data structure 
 */
STATIC int
_bcm_petra_cosq_gport_discard_to_rate_class_data(int unit, 
                                                 bcm_cosq_gport_discard_t *discard,
                                                 bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class)
{
    bcm_error_t rc = BCM_E_NONE;
    int nof_drop_prec, index;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);
    /* Change Rate class configuration according to discard structure */
    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* ECN */
        if (SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }
        data_rate_class->ecn_wred_enable = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? SOC_SAND_TRUE:SOC_SAND_FALSE;
        data_rate_class->ecn_wred_min_avrg_th = discard->min_thresh;
        data_rate_class->ecn_wred_max_avrg_th = discard->max_thresh;
        data_rate_class->ecn_wred_max_probability = discard->drop_probability;
        if (discard->flags & BCM_COSQ_DISCARD_BYTES) {
            data_rate_class->ecn_queue_max_size = discard->ecn_thresh;
            if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid flags parameter 0x%x specified for maximum ECN size.\n"
                  "Both of BCM_COSQ_DISCARD_BYTES and BCM_COSQ_DISCARD_BUFFER_DESC cannot be used together."), discard->flags));
            }
            if (!SOC_IS_ARADPLUS(unit) && discard->ecn_thresh > ARAD_B0_MAX_ECN_QUEUE_BYTES && discard->ecn_thresh < ARAD_MAX_QUEUE_SIZE_BYTES) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Arad B0/B1 ECN queue size limit in bytes can not be in the range of 0x%x-0x%lx.\n"),ARAD_B0_MAX_ECN_QUEUE_BYTES+1 ,ARAD_MAX_QUEUE_SIZE_BYTES-1));
            }
        } else if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
            data_rate_class->ecn_queue_max_size_bds = discard->ecn_thresh;
        }
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) { 
        /* system RED */
        rc = _bcm_petra_cosq_sys_red_dp_pr_set(unit, data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        rc = _bcm_petra_cosq_voq_discard_retreive_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
        BCMDNX_IF_ERR_EXIT(rc);

        if (nof_drop_prec == 0) {
            /* Nothing to change, just exit */
            BCM_EXIT;
        }

        for (index = 0; index < nof_drop_prec; index++) {
            data_rate_class->wred_enable[drop_prec[index]] = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? SOC_SAND_TRUE:SOC_SAND_FALSE;
            data_rate_class->wred_min_avrg_th[drop_prec[index]] = discard->min_thresh;
            data_rate_class->wred_max_avrg_th[drop_prec[index]] = discard->max_thresh;
            data_rate_class->wred_max_probability[drop_prec[index]] = discard->drop_probability;
        }

        /* WRED exp wq parameter is same for all dps and ECN */
        data_rate_class->wred_exp_wq = discard->gain;
    }
exit:
    BCMDNX_FUNC_RETURN;

}
/* 
 * Purpose: Retreive WRED configuration from a rate class data structure to a discard structure
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_data_to_discard(int unit, 
                                                 bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int nof_drop_prec;
    uint32 relevant_flags;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];
    int dp_index;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* ECN */
        if (SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }
        if ((discard->flags & (BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_BUFFER_DESC)) ==
            (BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_BUFFER_DESC)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid flags parameter 0x%x specified for maximum ECN size.\n"
              "Both of BCM_COSQ_DISCARD_BYTES and BCM_COSQ_DISCARD_BUFFER_DESC cannot be used together."), discard->flags));
        }
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) { 
        /* System RED */
        relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                                           BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK |
                                           BCM_COSQ_DISCARD_PROBABILITY1 | BCM_COSQ_DISCARD_PROBABILITY2 |
                                           BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_SYSTEM | BCM_COSQ_DISCARD_COLOR_ALL);

        if (discard->flags != relevant_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x\n"), unit, discard->flags));
        }

    } else { /* not ECN not system RED */
        relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                              BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK);

        if (!relevant_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x\n"), unit, discard->flags));
        }

        if (!(discard->flags & BCM_COSQ_DISCARD_BYTES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no discard type 0x%x\n"), unit, discard->flags));
        }
    }

    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* get ECN WRED */
        discard->drop_probability = data_rate_class->ecn_wred_max_probability;
        discard->min_thresh = data_rate_class->ecn_wred_min_avrg_th;
        discard->max_thresh = data_rate_class->ecn_wred_max_avrg_th;
        if (data_rate_class->ecn_wred_enable == SOC_SAND_TRUE) {
            discard->flags |= BCM_COSQ_DISCARD_ENABLE;
        } else {
            discard->flags &= ~BCM_COSQ_DISCARD_ENABLE;
        }
        if (discard->flags & BCM_COSQ_DISCARD_BYTES) {
            discard->ecn_thresh = data_rate_class->ecn_queue_max_size;
        } else if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
            discard->ecn_thresh = data_rate_class->ecn_queue_max_size_bds;
        }
        discard->gain = data_rate_class->wred_exp_wq;
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) {
        /* system RED */
        rc = _bcm_petra_cosq_sys_red_dp_pr_get(unit, data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);

    } else { /* get regular WRED */
        rc = _bcm_petra_cosq_voq_discard_retreive_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
        BCMDNX_IF_ERR_EXIT(rc);

        if (nof_drop_prec != 1) {
            /* Nothing to change, just exit */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color\n"), unit, discard->flags));
        }
        dp_index = drop_prec[0];

        /* Wred settings is defined by Rate Class profile */
        discard->drop_probability = data_rate_class->wred_max_probability[dp_index];
        discard->min_thresh = data_rate_class->wred_min_avrg_th[dp_index];
        discard->max_thresh = data_rate_class->wred_max_avrg_th[dp_index];
        if (data_rate_class->wred_enable[dp_index] == SOC_SAND_TRUE) {
            discard->flags |= BCM_COSQ_DISCARD_ENABLE;
        }
        discard->gain = data_rate_class->wred_exp_wq;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
#ifdef BCM_ARAD_SUPPORT

/* 
 * Purpose: Set WRED configuration of a rate class
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_discard_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cosq_gport_discard_t *discard)
{ 
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t 
        data_rate_class, 
        exact_data_rate_class;
    int rate_class;
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }
    /*validate profiles range*/
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
   
    /* 
     * Check that the system is in advance queue to rate class mapping mode, 
     *    if not set it to advance mode.
     */
    rv = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rv);

    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    BCMDNX_NULL_CHECK(discard);

    rv = _bcm_petra_cosq_gport_discard_verify(unit, discard ,0);
    BCMDNX_IF_ERR_EXIT(rv);

    /* 1. Get rate class data */
    rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    /* 
     * Change related information
     * This method does not only configure data_rate_class but creates a system red template and access the HW 
     * So if we should fail at the HW configuration or the template configuration: we cannot recover
     */
    rv = _bcm_petra_cosq_gport_discard_to_rate_class_data(unit, discard, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);
    /* 
     * checking that the remaining resource level is not too low - currently 2%
     * is not needed: relevent only for color size
     */
    /*2. configure HW*/
    rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit,rate_class,&data_rate_class,&exact_data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);        

exit:
    BCMDNX_FUNC_RETURN;
} 
#endif /*BCM_ARAD_SUPPORT*/ 

/* 
 * Purpose: Set WRED configuration
 */
STATIC int
_bcm_petra_cosq_gport_voq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_voq_config_t *voq_config;
    int base_qid, qid;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class, exact_data_rate_class, cleared_data_rate;
    int new_rate_class,old_rate_class, is_allocated,is_last;
    int core = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit)){
        BCM_SAND_IF_ERR_EXIT(_bcm_petra_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));
    }
#endif /*BCM_ARAD_SUPPORT*/
    /* Validate Queue */
    base_qid = BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) ? BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport) : BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    
    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                                         &(_dpp_cosq_config[unit].voq_hd),
                                                                         DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid));

    if (voq_config ==  NULL) {      
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error\n"),
                     unit, base_qid));
    }

    if (voq_config->num_cos == 0) {
        /* Not initalized VOQ */
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("Unit(%d) Invalid VOQ %d parameter\n"),
                         unit, base_qid));
    }

    if (cosq < 0 || cosq >= voq_config->num_cos) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) Num cos is invalid. range is 0 - %d\n"),
                     unit, base_qid,voq_config->num_cos - 1));
    }

    rc = _bcm_petra_cosq_gport_discard_verify(unit, discard, 0);
    BCMDNX_IF_ERR_EXIT(rc);
    
    qid = base_qid + cosq;

    /* Wred settings is defined by Rate Class profile */
    /* Get Rate class data */
    rc = _bcm_dpp_am_template_queue_rate_cls_data_get(unit,qid,&data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_gport_discard_to_rate_class_data(unit, discard, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Settings WRED parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Note: This process might lead to a false confirm, when configuration is not exact
       and there aren't profiles that are free. This can be resolved if all configurations
       are given as exact */
     

    /* Stage 1: Find new profile according to given settings */

    /* Update information in SW */
    rc = _bcm_dpp_am_template_queue_rate_cls_exchange(unit, qid, &data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Commit Changes in HW according to given thresholds */
    if (is_allocated) {
        rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit, new_rate_class, &data_rate_class, &exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);        
    } else {
        sal_memcpy(&exact_data_rate_class, &data_rate_class, sizeof(exact_data_rate_class));
    }
    /* Set new mapping */
    rc = _bcm_petra_cosq_voq_class_mapping_set(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Clear old profile */
    if (is_last && new_rate_class != old_rate_class) {
        sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
        rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit,old_rate_class,&data_rate_class,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_ingr_rate_class_data(unit, 0, old_rate_class, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    /* Step 2: Allocate according to exact */
    /* Update information in SW according to exact thresholds */
    /* We have enough profiles here since or data was not exact and we allocated already new profile */
    /* or data was exact thus info is same */
    rc = _bcm_dpp_am_template_queue_rate_cls_exchange(unit, qid, &exact_data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_allocated) {
        /* Set new profile data */
        rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit, new_rate_class, &exact_data_rate_class, &cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Set new mapping */
    rc = _bcm_petra_cosq_voq_class_mapping_set(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Clear old profile */
    if (is_last && new_rate_class != old_rate_class) {
        sal_memset(&data_rate_class, 0x0, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
        rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit, old_rate_class, &data_rate_class, &cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_ingr_rate_class_data(unit, 0, old_rate_class, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_ARAD_SUPPORT
/* 
 * Purpose: Retrieve WRED configuration of a rate class
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_discard_get(int unit, 
                                             bcm_gport_t gport, 
                                             bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;
    int rate_class;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (BCM_GPORT_IS_PROFILE(gport)) { 
        rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }

    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));    

    /*validate profiles range*/
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }

    /* Get Rate class data */
    rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_gport_rate_class_data_to_discard(unit, &data_rate_class, discard);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}
#endif /*BCM_ARAD_SUPPORT*/


/* 
 * Purpose: Retrieve WRED configuration
 */
STATIC int
_bcm_petra_cosq_gport_voq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_voq_config_t *voq_config;
    int base_qid, qid;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;
#ifdef BCM_ARAD_SUPPORT
    int rate_class;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
#endif /*BCM_ARAD_SUPPORT*/
    int core = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));    

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)\n"), unit, gport));
    }

    /* Validate Queue */
    base_qid = BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) ? BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport) : BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    
    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit,
                                                                         &(_dpp_cosq_config[unit].voq_hd),
                                                                         DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid));

    if (voq_config ==  NULL) {      
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) internal state get error\n"),
                     unit, base_qid));
    }

    if (voq_config->num_cos == 0) {
        /* Not initalized VOQ */
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("Unit(%d) Invalid VOQ %d parameter\n"),
                         unit, base_qid));
    }

    if (cosq < 0 || cosq >= voq_config->num_cos) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) Num cos is invalid. range is 0 - %d\n"),
                     unit, base_qid,voq_config->num_cos - 1));
    }
    qid = base_qid + cosq;

#ifdef BCM_ARAD_SUPPORT
    BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_get(unit, &queue_to_rate_class_mapping_is_simple));
    /* Get Rate class data */
    if (SOC_IS_ARAD(unit) && queue_to_rate_class_mapping_is_simple != ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        rc = _bcm_petra_cosq_voq_class_mapping_get(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, &rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_petra_cosq_gport_rate_class_data_to_discard(unit, &data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);
    } else 
#endif /*BCM_ARAD_SUPPORT*/
    {
        rc = _bcm_dpp_am_template_queue_rate_cls_data_get(unit, qid, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_petra_cosq_gport_rate_class_data_to_discard(unit, &data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get mapping port to thresh_type
 */
int
_bcm_petra_cosq_egress_thresh_map_get(int unit,
                                      int port,
                                      uint32 *profile)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_PORT_THRESH_TYPE thresh_type = SOC_TMC_EGR_PORT_NOF_THRESH_TYPES;    
    uint32 soc_sand_rc;    
    int    core=0;
    uint32 tm_port;
    BCMDNX_INIT_FUNC_DEFS;

    rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_thresh_type_get,(unit,core,port,&thresh_type)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *profile = thresh_type;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh entry from hw by profile for Soc_petra B
 */

STATIC int
_bcm_pb_cosq_egress_thresh_entry_get(int unit,
                                        int profile,
                                        bcm_dpp_cosq_egress_thresh_key_info_t* thresh_info)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_PORT_THRESH_TYPE thresh_type;
    SOC_TMC_EGR_FC_OFP_THRESH fc_ofp_thresh;
    SOC_TMC_EGR_DROP_THRESH drop_thresh;    
    uint32 soc_sand_rc;
    int dp,indx;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(thresh_info);    

    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);

    thresh_type = profile;
   
    /* Get scheduled fc */
    for (indx = 0; indx < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); indx++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit,indx,profile,&fc_ofp_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        thresh_info->sch_fc_words_consumed[indx] = fc_ofp_thresh.words;       
        thresh_info->sch_drop_packet_descriptors = fc_ofp_thresh.packet_descriptors;
        thresh_info->sch_fc_data_buffers_tc[indx] = fc_ofp_thresh.words;/* queue_words_consumed parameter used for Data buffers in Arad */
    }
    
    /* Get scheduled drop */
    for (indx = 0; indx < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); indx++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_get,(unit,indx,&drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        thresh_info->sch_drop_pkts_consumed[indx] = drop_thresh.queue_pkts_consumed[thresh_type];
        thresh_info->sch_drop_words_consumed[indx] = drop_thresh.queue_words_consumed[thresh_type];
    } 

    /* Get unscheduled drop */
    for (indx = 0; indx < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); indx++) {
        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++) {
        
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_get,(unit,indx,dp,&drop_thresh)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
            thresh_info->unsch_drop_pkts_consumed[indx][dp] = drop_thresh.queue_pkts_consumed[thresh_type];
            thresh_info->unsch_drop_words_consumed[indx][dp] = drop_thresh.queue_words_consumed[thresh_type];    
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh entry from hw by profile for ARAD
 */

STATIC int
_bcm_arad_cosq_egress_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    uint32 soc_sand_rc;
    int prio,
        dp,
        threshold_type = profile;
    SOC_TMC_EGR_FC_OFP_THRESH
        fc_ofp_thresh,
        fc_ofp_exact_thresh;
    SOC_TMC_EGR_QUEUING_DEV_TH
        dev_thresh;
    SOC_TMC_EGR_DROP_THRESH
        drop_thresh,
        exact_drop_thresh;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* Clear */
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_thresh);
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_exact_thresh);
    SOC_TMC_EGR_QUEUING_DEV_TH_clear(&dev_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&exact_drop_thresh);

    /* Get scheduled fc */
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit, prio, threshold_type, &fc_ofp_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        thresh_info->sch_fc_packet_descriptors_tc[prio] = fc_ofp_thresh.packet_descriptors;
        thresh_info->sch_fc_data_buffers_tc[prio] = fc_ofp_thresh.words;/* queue_words_consumed parameter used for Data buffers in Arad */
    }
    
    /* Get scheduled drop and unscheduled drop with cosq == -1 */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    thresh_info->sch_drop_packet_descriptors = dev_thresh.thresh_type[threshold_type].uc.descriptors;
    thresh_info->sch_drop_data_buffers = dev_thresh.thresh_type[threshold_type].uc.buffers;
    thresh_info->unsch_drop_packet_descriptors = dev_thresh.thresh_type[threshold_type].mc_shared.descriptors;
    thresh_info->unsch_drop_data_buffers = dev_thresh.thresh_type[threshold_type].mc_shared.buffers;
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        thresh_info->unsch_drop_packet_descriptors_available_tc[prio] = dev_thresh.thresh_type[threshold_type].reserved[prio].descriptors;
    }

    /* Port FC Thresholds */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit, ARAD_EGR_Q_PRIO_ALL, threshold_type, &fc_ofp_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    thresh_info->port_fc_packet_descriptors = fc_ofp_thresh.packet_descriptors;
    thresh_info->port_fc_data_buffers = fc_ofp_thresh.data_buffers;


    /* Get scheduled drop */
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_get,(unit, prio, &drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        thresh_info->sch_drop_data_buffers_tc[prio] = drop_thresh.queue_words_consumed[threshold_type]; /* queue_words_consumed parameter used for Data buffers in Arad */
        thresh_info->sch_drop_packet_descriptors_tc[prio] = drop_thresh.queue_pkts_consumed[threshold_type];
    } 

    /* Get unscheduled drop */

    for (prio = 0; prio < SOC_TMC_EGR_NOF_Q_PRIO_ARAD; prio++) {
        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++) {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_get,(unit, prio, dp, &drop_thresh)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            thresh_info->unsch_drop_data_buffers_tc_dp[prio][dp] = drop_thresh.queue_words_consumed[threshold_type];/* queue_words_consumed parameter used for Data buffers in Arad */
            thresh_info->unsch_drop_packet_descriptors_tc_dp[prio][dp] = drop_thresh.queue_pkts_consumed[threshold_type];
        }
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh entry from hw by profile
 */
int
_bcm_petra_cosq_egress_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    BCMDNX_INIT_FUNC_DEFS;

    if(SOC_IS_PETRAB(unit)) {
        rc = _bcm_pb_cosq_egress_thresh_entry_get(unit, profile, thresh_info);
        BCM_IF_ERROR_RETURN(rc);
    }

    if(SOC_IS_ARAD(unit)) {
        rc = _bcm_arad_cosq_egress_thresh_entry_get(unit, profile, thresh_info);
        BCM_IF_ERROR_RETURN(rc);
    }

    BCM_IF_ERROR_RETURN(rc);

    BCM_EXIT;

exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_egress_thresh_to_exact_thresh(int unit,
                                         uint32 thresh,
                                         uint32 *exact_thresh)
{
    bcm_error_t rv = BCM_E_NONE;
#ifdef  BCM_PETRAB_SUPPORT
    SOC_TMC_REG_FIELD thresh_fld;
#endif
    BCMDNX_INIT_FUNC_DEFS;
    /*    thresh_exp_fld,
        thresh_mnt_fld;*/
    /*uint32 mnt_th, exp_th;*/
    
    BCMDNX_NULL_CHECK(exact_thresh);

#ifdef  BCM_PETRAB_SUPPORT
    SOC_TMC_FLD_DEFINE(thresh_fld, 0, DPP_COSQ_PB_EGR_THRESH_NOF_BITS);
#endif
    /*SOC_PETRA_FLD_DEFINE(thresh_mnt_fld, DPP_COSQ_PB_EGR_THRESH_EXP_NOF_BITS, DPP_COSQ_PB_EGR_THRESH_MNT_NOF_BITS);*/

#ifdef  BCM_PETRAB_SUPPORT
    if (SOC_IS_PETRAB(unit)) {
        uint32 soc_sand_rv;
        uint32 thresh_fld_val;
        soc_sand_rv = soc_petra_egr_thresh_fld_to_mnt_exp(&thresh_fld,thresh,exact_thresh,&thresh_fld_val);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    }
#endif  /* BCM_PETRAB_SUPPORT */
#ifdef  BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        *exact_thresh = thresh;
        BCM_EXIT;
    }
#endif  /* BCM_ARAD_SUPPORT */

    BCMDNX_IF_ERR_EXIT(rv);
exit:
BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
STATIC int
_bcm_petra_cosq_egress_thresh_profile_set(int unit,
                                      int port,
                                      int profile)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_PORT_THRESH_TYPE thresh_type;
    uint32 soc_sand_rc;    
    uint32 tm_port;
    int core;

    BCMDNX_INIT_FUNC_DEFS;
    thresh_type = profile;

    rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_thresh_type_set,(unit, core, tm_port, thresh_type)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data in hw
 */
STATIC int
_bcm_petra_cosq_egress_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;
    if(SOC_IS_PETRAB(unit)) {
        rc = _bcm_pb_cosq_egress_thresh_profile_data_set(unit, profile, thresh_info);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if(SOC_IS_ARAD(unit)) {
        rc = _bcm_arad_cosq_egress_thresh_profile_data_set(unit, profile, thresh_info);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else
    {
        rc = BCM_E_UNAVAIL;
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data in hw for Soc_petra B
 */
STATIC int
_bcm_pb_cosq_egress_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    SOC_TMC_EGR_PORT_THRESH_TYPE thresh_type;
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_FC_OFP_THRESH fc_ofp_thresh,exact_fc_ofp_thresh;
    SOC_TMC_EGR_DROP_THRESH drop_thresh,exact_drop_thresh;    
    uint32 soc_sand_rc;
    int dp,q_prio;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    thresh_type = profile;    
    
    /* Clear */
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);

    /* Set scheduled fc */
    for (q_prio = 0; q_prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); q_prio++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit,q_prio,thresh_type,&fc_ofp_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        fc_ofp_thresh.words = thresh_info->sch_fc_words_consumed[q_prio];

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_set,(unit,q_prio,thresh_type,&fc_ofp_thresh,&exact_fc_ofp_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    
    /* Set scheduled drop */
    for (q_prio = 0; q_prio< DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); q_prio++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_get,(unit,q_prio,&drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        drop_thresh.queue_pkts_consumed[thresh_type] = thresh_info->sch_drop_pkts_consumed[q_prio];
        drop_thresh.queue_words_consumed[thresh_type] = thresh_info->sch_drop_words_consumed[q_prio];

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_set,(unit,q_prio,&drop_thresh,&exact_drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    } 

    /* Set unscheduled drop */
    for (q_prio = 0; q_prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); q_prio++) {
        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++) {
        
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_get,(unit,q_prio,dp,&drop_thresh)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
            drop_thresh.queue_pkts_consumed[thresh_type] = thresh_info->unsch_drop_pkts_consumed[q_prio][dp];
            drop_thresh.queue_words_consumed[thresh_type] = thresh_info->unsch_drop_words_consumed[q_prio][dp];
    
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_set,(unit,q_prio,dp,&drop_thresh,&exact_drop_thresh)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data in hw for ARAD
 */
STATIC int
_bcm_arad_cosq_egress_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    uint32 soc_sand_rc;
    int prio,
        dp,
        threshold_type = profile;
    SOC_TMC_EGR_FC_OFP_THRESH
        fc_ofp_thresh,
        fc_ofp_exact_thresh;
    SOC_TMC_EGR_QUEUING_DEV_TH
        *dev_thresh = NULL;
    SOC_TMC_EGR_DROP_THRESH
        drop_thresh,
        exact_drop_thresh;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_ALLOC(dev_thresh, sizeof(SOC_TMC_EGR_QUEUING_DEV_TH), "_bcm_arad_cosq_egress_thresh_profile_data_set.dev_thresh");
    if (dev_thresh == NULL) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
    }
    /* Clear */
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_thresh);
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_exact_thresh);
    SOC_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&exact_drop_thresh);

    /* Set scheduled fc */
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit, prio, threshold_type, &fc_ofp_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(fc_ofp_thresh.packet_descriptors == thresh_info->sch_fc_packet_descriptors_tc[prio] &&
           fc_ofp_thresh.words == thresh_info->sch_fc_data_buffers_tc[prio])
        {
          continue;
        }
        
        
        fc_ofp_thresh.packet_descriptors = thresh_info->sch_fc_packet_descriptors_tc[prio];
        fc_ofp_thresh.words = thresh_info->sch_fc_data_buffers_tc[prio];/* queue_words_consumed parameter used for Data buffers in Arad */

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_set,(unit, prio, threshold_type, &fc_ofp_thresh, &fc_ofp_exact_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    
    /* Port FC Thresholds */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit, ARAD_EGR_Q_PRIO_ALL, threshold_type, &fc_ofp_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if(fc_ofp_thresh.packet_descriptors != thresh_info->port_fc_packet_descriptors ||
       fc_ofp_thresh.data_buffers != thresh_info->port_fc_data_buffers)
    {
      fc_ofp_thresh.packet_descriptors = thresh_info->port_fc_packet_descriptors;
      fc_ofp_thresh.data_buffers = thresh_info->port_fc_data_buffers;

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_set,(unit, ARAD_EGR_Q_PRIO_ALL, threshold_type, &fc_ofp_thresh, &fc_ofp_exact_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

    /* Set scheduled drop and unscheduled drop with cosq == -1 */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    dev_thresh->thresh_type[threshold_type].uc.descriptors = thresh_info->sch_drop_packet_descriptors;
    dev_thresh->thresh_type[threshold_type].uc.buffers = thresh_info->sch_drop_data_buffers;
    dev_thresh->thresh_type[threshold_type].mc_shared.descriptors = thresh_info->unsch_drop_packet_descriptors;
    dev_thresh->thresh_type[threshold_type].mc_shared.buffers = thresh_info->unsch_drop_data_buffers;
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        dev_thresh->thresh_type[threshold_type].reserved[prio].descriptors = thresh_info->unsch_drop_packet_descriptors_available_tc[prio];
    }
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Set scheduled drop */
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_get,(unit, prio, &drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(drop_thresh.queue_words_consumed[threshold_type] == thresh_info->sch_drop_data_buffers_tc[prio] &&
           drop_thresh.queue_pkts_consumed[threshold_type] == thresh_info->sch_drop_packet_descriptors_tc[prio])
        {
          continue;
        }

        drop_thresh.queue_words_consumed[threshold_type] = thresh_info->sch_drop_data_buffers_tc[prio]; /* queue_words_consumed parameter used for Data buffers in Arad */
        drop_thresh.queue_pkts_consumed[threshold_type] = thresh_info->sch_drop_packet_descriptors_tc[prio];

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_set,(unit, prio, &drop_thresh, &exact_drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    } 

    /* Set unscheduled drop */

    for (prio = 0; prio < SOC_TMC_EGR_NOF_Q_PRIO_ARAD; prio++) {
        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++) {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_get,(unit, prio, dp, &drop_thresh)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            if(drop_thresh.queue_words_consumed[threshold_type] == thresh_info->unsch_drop_data_buffers_tc_dp[prio][dp] &&
               drop_thresh.queue_pkts_consumed[threshold_type] == thresh_info->unsch_drop_packet_descriptors_tc_dp[prio][dp])
            {
              continue;
            }

            drop_thresh.queue_words_consumed[threshold_type] = thresh_info->unsch_drop_data_buffers_tc_dp[prio][dp];/* queue_words_consumed parameter used for Data buffers in Arad */
            drop_thresh.queue_pkts_consumed[threshold_type] = thresh_info->unsch_drop_packet_descriptors_tc_dp[prio][dp];
            
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_set,(unit, prio, dp, &drop_thresh, &exact_drop_thresh)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }

    BCM_EXIT;
exit:
    BCM_FREE(dev_thresh);
    BCMDNX_FUNC_RETURN;
}
#ifdef BCM_ARAD_SUPPORT
/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_set(int unit,
                                      SOC_TMC_INTERFACE_ID if_ndx,
                                      int profile)
{
    uint32 soc_sand_rc;    
    SOC_TMC_EGR_QUEUING_IF_FC info;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_get,(unit, if_ndx, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.uc_profile = profile;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_set,(unit, if_ndx, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data for flow control unicast in hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile)
{
    uint32  soc_sand_rc;
    SOC_TMC_EGR_QUEUING_IF_UC_FC info;
    
    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_EGR_QUEUING_IF_UC_FC_clear(&info);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_uc_get,(unit, profile, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.pd_th = thresh_profile->fc_packet_descriptors;
    info.size256_th = thresh_profile->fc_words_consumed;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_uc_set,(unit, profile, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh_type data for flow control unicast from the hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile)
{
    uint32  soc_sand_rc;
    SOC_TMC_EGR_QUEUING_IF_UC_FC info;
    
    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_EGR_QUEUING_IF_UC_FC_clear(&info);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_uc_get,(unit, profile, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    thresh_profile->fc_packet_descriptors = info.pd_th;
    thresh_profile->fc_words_consumed = info.size256_th;

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_set(int unit,
                                      SOC_TMC_INTERFACE_ID if_ndx,
                                      int profile)
{
    uint32 soc_sand_rc;    
    SOC_TMC_EGR_QUEUING_IF_FC info;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_get,(unit, if_ndx, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.mc_pd_profile = profile;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_set,(unit, if_ndx, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh_type data for flow control multicast from the hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile)
{
    uint32  soc_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_mc_get,(unit, profile, &thresh_profile->fc_packet_descriptors)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data for flow control multicast in hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_data_set(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile)
{
    uint32  soc_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_mc_set,(unit, profile, thresh_profile->fc_packet_descriptors)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}
#endif /*BCM_ARAD_SUPPORT */
/* 
 * Purpose:
 * Add egress thresh information to multiset, 
 * Information by gport,cosq and threshold type. 
 */
STATIC int
_bcm_petra_cosq_gport_egress_thresh_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_thresh_key_info_t thresh_key;
    int is_allocated, is_last;
    int template, old_template;
    int core;
    SOC_TMC_EGR_Q_PRIO prio;   
    uint32 exact_value, ofp_ndx;
    int start_prio, end_prio;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Old data get */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_data_get(unit,ofp_ndx,&thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change data */     
    rc = _bcm_petra_egress_thresh_to_exact_thresh(unit,threshold->value,&exact_value);
    BCMDNX_IF_ERR_EXIT(rc);

    /* if cosq = -1 then prio is SOC_TMC_EGR_Q_PRIO_ALL */
    /* in this case need to go over all priorities from SOC_TMC_EGR_Q_PRIO_0 to SOC_TMC_EGR_Q_PRIO_7 */
    /* otherwise, need just to configure the selected priority */
    if(prio == SOC_TMC_EGR_Q_PRIO_ALL)
    {
      start_prio = SOC_TMC_EGR_Q_PRIO_0;
      end_prio = SOC_TMC_EGR_Q_PRIO_7;
    }
    else
    {
      start_prio = prio;
      end_prio = prio;
    }
   
    for(prio = start_prio; prio <= end_prio; prio++)
    {
      switch(threshold->type) {
          case bcmCosqThresholdBytes:
              /* FC or drop */
              if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                  thresh_key.sch_fc_words_consumed[prio] = exact_value;
              } else {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      thresh_key.sch_drop_words_consumed[prio] = exact_value;
                  } else {
                      thresh_key.unsch_drop_words_consumed[prio][threshold->dp] = exact_value;
                  }
              }
              break;     
          case bcmCosqThresholdPackets:
              /* Schedule or Unschedule */
              if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                  thresh_key.sch_drop_pkts_consumed[prio] = exact_value;
              } else {
                  thresh_key.unsch_drop_pkts_consumed[prio][threshold->dp] = exact_value;
              }
              break;
          case bcmCosqThresholdPacketDescriptors:
              /* FC or drop */
              if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                  if(cosq == -1) {
                      thresh_key.port_fc_packet_descriptors = exact_value; 
                  }
                  else
                  {
                      thresh_key.sch_fc_packet_descriptors_tc[cosq] = exact_value;
                  }
              } else {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      if(cosq == -1) {
                          thresh_key.sch_drop_packet_descriptors = exact_value;
                      }
                      else
                      {
                          thresh_key.sch_drop_packet_descriptors_tc[cosq] = exact_value;
                      }
                  } 
                  else
                  {
                      if(cosq == -1) {
                          thresh_key.unsch_drop_packet_descriptors = exact_value;
                      }
                      else
                      {
                          thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp] = exact_value;
                      }
                  }
              }
              break;
          case bcmCosqThresholdDataBuffers:
              /* FC or drop */
              if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                  if(cosq == -1) {
                      thresh_key.port_fc_data_buffers = exact_value;
                  }
                  else
                  {
                      thresh_key.sch_fc_data_buffers_tc[cosq] = exact_value;
                  }
              } 
              else
              {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      if(cosq == -1) {
                          thresh_key.sch_drop_data_buffers = exact_value;
                      }
                      else
                      {
                          thresh_key.sch_drop_data_buffers_tc[cosq] = exact_value;
                      }
                  }
                  else
                  {
                      if(cosq == -1) {
                          thresh_key.unsch_drop_data_buffers = exact_value;
                      }
                      else
                      {
                          thresh_key.unsch_drop_data_buffers_tc_dp[cosq][threshold->dp] = exact_value;
                      }
                  }
              }
              break;
          case bcmCosqThresholdAvailablePacketDescriptors:
              if(cosq < 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("For type bcmCosqThresholdAvailablePacketDescriptors the cosq must be greater or equal to 0\n\r")));
              }
              thresh_key.unsch_drop_packet_descriptors_available_tc[cosq] = exact_value;
              break;
          default:
              BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
      }
    }

    /* Set new object */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_exchange(unit,ofp_ndx,&thresh_key,&old_template,&is_last,&template,&is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (old_template != template) {
        /* Set new profile */
        rc = _bcm_petra_cosq_egress_thresh_profile_set(unit,ofp_ndx,template);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_allocated) {
        /* Set new data for a specific profile */
        rc = _bcm_petra_cosq_egress_thresh_profile_data_set(unit,template,&thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * get egress thresh information from multiset, 
 * Information by gport,cosq and threshold type. 
 */
STATIC int
_bcm_petra_cosq_gport_egress_thresh_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_thresh_key_info_t thresh_key;
    int core;
    SOC_TMC_EGR_Q_PRIO prio;
    uint32 ofp_ndx;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Data get */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_data_get(unit,ofp_ndx,&thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                threshold->value = thresh_key.sch_fc_words_consumed[prio];
            } else {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    threshold->value = thresh_key.sch_drop_words_consumed[prio];
                } else {
                    threshold->value = thresh_key.unsch_drop_words_consumed[prio][threshold->dp];
                }
            }
            break;     
        case bcmCosqThresholdPackets:
            /* Schedule or Unschedule */
            if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                threshold->value = thresh_key.sch_drop_pkts_consumed[prio];
            } else {
                threshold->value = thresh_key.unsch_drop_pkts_consumed[prio][threshold->dp];
            }
            break;
        case bcmCosqThresholdPacketDescriptors:
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                if(cosq == -1) {
                    threshold->value = thresh_key.port_fc_packet_descriptors;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_tc[cosq];
                }
            } else {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    if(cosq == -1) {
                        threshold->value = thresh_key.sch_drop_packet_descriptors;
                    }
                    else
                    {
                        threshold->value = thresh_key.sch_drop_packet_descriptors_tc[cosq];
                    }
                } 
                else
                {
                    if(cosq == -1) {
                        threshold->value = thresh_key.unsch_drop_packet_descriptors;
                    }
                    else
                    {
                        threshold->value = thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp];
                    }
                }
            }
            break;
        case bcmCosqThresholdDataBuffers:
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                if(cosq == -1) {
                    threshold->value = thresh_key.port_fc_data_buffers;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_tc[cosq];
                }
            } 
            else
            {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    if(cosq == -1) {
                        threshold->value = thresh_key.sch_drop_data_buffers;
                    }
                    else
                    {
                        threshold->value = thresh_key.sch_drop_data_buffers_tc[cosq];
                    }
                }
                else
                {
                    if(cosq == -1) {
                        threshold->value = thresh_key.unsch_drop_data_buffers;
                    }
                    else
                    {
                        threshold->value = thresh_key.unsch_drop_data_buffers_tc_dp[cosq][threshold->dp];
                    }
                }
            }
            break;
        case bcmCosqThresholdAvailablePacketDescriptors:
            threshold->value = thresh_key.unsch_drop_packet_descriptors_available_tc[cosq];
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_ocb_threshold_to_rate_class(int unit, 
                                            bcm_cosq_threshold_t *threshold,
                                            bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_cls)
{
    int tc = threshold->tc;
    int vsq_category = threshold->vsq_category;
    int index;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    BCMDNX_NULL_CHECK(data_rate_cls);

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            for (index = 0; index < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS ; ++index) {
                data_rate_cls->ocb_info[tc][vsq_category].th_words[index] = 
                    threshold->value / DPP_DEVICE_PETRA_COSQ_OCB_16BYTES_RESOLUTION;
            }
            break;     
        case bcmCosqThresholdDbuffs:
            for (index = 0; index < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS ; ++index) {
                data_rate_cls->ocb_info[tc][vsq_category].th_buffers[index] = threshold->value;
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if(threshold->flags & BCM_COSQ_THRESHOLD_SET)
    {
        data_rate_cls->ocb_info[tc][vsq_category].voq_eligible = TRUE;
    }
    else if(threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)
    {
        data_rate_cls->ocb_info[tc][vsq_category].voq_eligible = FALSE;
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: 
 * Set Egress device wide flow control scheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_FLOW_CONTROL | BCM_COSQ_THRESHOLD_UNICAST))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }
    
    /* Set only relevant information */
    {
      SOC_TMC_EGR_FC_DEVICE_THRESH dev_thresh,exact_dev_thresh;
      uint32 soc_sand_rc;      

      SOC_TMC_EGR_FC_DEVICE_THRESH_clear(&dev_thresh);

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit,&dev_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

      if (threshold->type == bcmCosqThresholdBytes) {
          dev_thresh.scheduled.words = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
          dev_thresh.scheduled.descriptors = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdDataBuffers) {
          dev_thresh.scheduled.buffers = threshold->value;
      }

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_set,(unit,&dev_thresh,&exact_dev_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control unscheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_FLOW_CONTROL | BCM_COSQ_THRESHOLD_MULTICAST))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }
    
    /* Set only relevant information */
    {
      SOC_TMC_EGR_FC_DEVICE_THRESH dev_thresh,exact_dev_thresh;
      uint32 soc_sand_rc;      

      SOC_TMC_EGR_FC_DEVICE_THRESH_clear(&dev_thresh);

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit,&dev_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

      if (threshold->type == bcmCosqThresholdBytes) {
          dev_thresh.unscheduled.words = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
          dev_thresh.unscheduled.descriptors = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdDataBuffers) {
          dev_thresh.unscheduled.buffers = threshold->value;
      }

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_set,(unit,&dev_thresh,&exact_dev_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control unscheduled pool thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     int pool,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_FLOW_CONTROL))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(pool == 0) {
        if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
        }
    } else if(pool == 1) {
        if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
        }
    }else{
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid pool %d\n"), unit, pool));
    }


    /* Set only relevant information */
    {
      SOC_TMC_EGR_FC_DEVICE_THRESH dev_thresh,exact_dev_thresh;
      uint32 soc_sand_rc;      

      SOC_TMC_EGR_FC_DEVICE_THRESH_clear(&dev_thresh);

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit,&dev_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

      if (threshold->type == bcmCosqThresholdBytes) {
          dev_thresh.unscheduled_pool[pool].words = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
          dev_thresh.unscheduled_pool[pool].descriptors = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdDataBuffers) {
          dev_thresh.unscheduled_pool[pool].buffers = threshold->value;
      }

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_set,(unit,&dev_thresh,&exact_dev_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control global thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_global_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_FLOW_CONTROL))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }
   
    /* Set only relevant information */
    {
      /* Update only relevant information */
      SOC_TMC_EGR_FC_DEVICE_THRESH dev_thresh,exact_dev_thresh;
      uint32 soc_sand_rc;      

      SOC_TMC_EGR_FC_DEVICE_THRESH_clear(&dev_thresh);

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit,&dev_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

      if (threshold->type == bcmCosqThresholdBytes) {
          dev_thresh.global.words = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
          dev_thresh.global.descriptors = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdDataBuffers) {
          dev_thresh.global.buffers = threshold->value;
      }

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_set,(unit,&dev_thresh,&exact_dev_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
            
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_FC_DEVICE_THRESH dev_thresh;
    uint32 soc_sand_rc;       
    
    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_EGR_FC_DEVICE_THRESH_clear(&dev_thresh);

    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL | BCM_COSQ_THRESHOLD_UNICAST;  

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit,&dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    if (threshold->type == bcmCosqThresholdBytes) {
        threshold->value = dev_thresh.scheduled.words;
    }
    if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
        threshold->value = dev_thresh.scheduled.descriptors;
    }
    if (threshold->type == bcmCosqThresholdDataBuffers) {
        threshold->value = dev_thresh.scheduled.buffers;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_FC_DEVICE_THRESH dev_thresh;
    uint32 soc_sand_rc;       
    
    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_EGR_FC_DEVICE_THRESH_clear(&dev_thresh);

    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL | BCM_COSQ_THRESHOLD_MULTICAST;  

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit,&dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    if (threshold->type == bcmCosqThresholdBytes) {
        threshold->value = dev_thresh.unscheduled.words;
    }
    if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
        threshold->value = dev_thresh.unscheduled.descriptors;
    }
    if (threshold->type == bcmCosqThresholdDataBuffers) {
        threshold->value = dev_thresh.unscheduled.buffers;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     int pool,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_FC_DEVICE_THRESH dev_thresh;
    uint32 soc_sand_rc;       
    
    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_EGR_FC_DEVICE_THRESH_clear(&dev_thresh);

    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL;
    if(pool == 0) {
        threshold->flags |= BCM_COSQ_THRESHOLD_MULTICAST_SP0;
    } else if(pool == 1) {
        threshold->flags |= BCM_COSQ_THRESHOLD_MULTICAST_SP1;
    }else{
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid pool %d\n"), unit, pool));
    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit,&dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    if (threshold->type == bcmCosqThresholdBytes) {
        threshold->value = dev_thresh.unscheduled_pool[pool].words;
    }
    if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
        threshold->value = dev_thresh.unscheduled_pool[pool].descriptors;
    }
    if (threshold->type == bcmCosqThresholdDataBuffers) {
        threshold->value = dev_thresh.unscheduled_pool[pool].buffers;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control global thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_global_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_FC_DEVICE_THRESH dev_thresh;
    uint32 soc_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL;         

    SOC_TMC_EGR_FC_DEVICE_THRESH_clear(&dev_thresh);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit,&dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (threshold->type == bcmCosqThresholdBytes) {
        threshold->value = dev_thresh.global.words;
    }
    if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
        threshold->value = dev_thresh.global.descriptors;
    }
    if (threshold->type == bcmCosqThresholdDataBuffers) {
        threshold->value = dev_thresh.global.buffers;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Set Flow control setting for mci thresholds 
 */ 
STATIC int
_bcm_petra_cosq_gport_egress_device_mci_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPackets)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_FLOW_CONTROL | BCM_COSQ_THRESHOLD_MULTICAST))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    /* Update only relevant information */
    {
      SOC_TMC_EGR_FC_MCI_THRESH mci_thresh,exact_mci_thresh;
      uint32 soc_sand_rc, mci_prio_ndx;      

      SOC_TMC_EGR_FC_MCI_THRESH_clear(&mci_thresh);

      
      mci_prio_ndx = 0;

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_mci_fc_get,(unit,mci_prio_ndx,&mci_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

      if (threshold->type == bcmCosqThresholdBytes) {
          mci_thresh.words_unsch = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
          mci_thresh.descriptors_total = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdDataBuffers) {
          mci_thresh.buffers_unsch = threshold->value;
      }
      if (threshold->type == bcmCosqThresholdPackets) {
          mci_thresh.packets_unsch = threshold->value;
      }

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_mci_fc_set,(unit,mci_prio_ndx,&mci_thresh,&exact_mci_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
        
    
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Get Flow control setting for mci thresholds 
 */ 
STATIC int
_bcm_petra_cosq_gport_egress_device_mci_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_EGR_FC_MCI_THRESH mci_thresh;
    int mci_prio_ndx;    
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPackets)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL | BCM_COSQ_THRESHOLD_MULTICAST;  

    SOC_TMC_EGR_FC_MCI_THRESH_clear(&mci_thresh);

    
    mci_prio_ndx = 0;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_mci_fc_get,(unit,mci_prio_ndx,&mci_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (threshold->type == bcmCosqThresholdBytes) {
        threshold->value = mci_thresh.words_unsch;
    }
    if (threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
        threshold->value = mci_thresh.descriptors_total;
    }
    if (threshold->type == bcmCosqThresholdDataBuffers) {
        threshold->value = mci_thresh.buffers_unsch;
    }
    if (threshold->type == bcmCosqThresholdPackets) {
        threshold->value = mci_thresh.packets_unsch;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Set FC configuration per interface.
 */
STATIC int
_bcm_petra_cosq_gport_egress_chnif_fc_threshold_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 ofp_ndx;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_FLOW_CONTROL))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);

  /* Update only relevant information */
    {

      SOC_TMC_EGR_FC_CHNIF_THRESH fc_chnif,exact_fc_chnif;
      SOC_TMC_INTERFACE_ID interface_id = 0;
      uint32 soc_sand_rc;        
    
      SOC_TMC_EGR_FC_CHNIF_THRESH_clear(&fc_chnif);

      rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_to_interface_map_get,(unit, core, ofp_ndx, &interface_id, NULL)));
      BCMDNX_IF_ERR_EXIT(rc);
    
      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_xaui_spaui_fc_get,(unit, interface_id, &fc_chnif)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
      if (threshold->type == bcmCosqThresholdBytes) {
          fc_chnif.words = threshold->value;
      } else {
          fc_chnif.packets = threshold->value;
      }
    
      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_xaui_spaui_fc_set,(unit, interface_id, &fc_chnif, &exact_fc_chnif)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Get FC configuration per interface.
 */
STATIC int
_bcm_petra_cosq_gport_egress_chnif_fc_threshold_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_FC_CHNIF_THRESH fc_chnif;    
    uint32 soc_sand_rc, ofp_ndx;
    int core;
    SOC_TMC_INTERFACE_ID if_id;
    
    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_EGR_FC_CHNIF_THRESH_clear(&fc_chnif);
    
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &ofp_ndx, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_to_interface_map_get,(unit, core, ofp_ndx, &if_id, NULL)));
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Verify */
    
    if (!(threshold->type == bcmCosqThresholdBytes || threshold->type == bcmCosqThresholdPackets)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL;  

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_xaui_spaui_fc_get,(unit, if_id, &fc_chnif)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    if (threshold->type == bcmCosqThresholdBytes) {
        threshold->value = fc_chnif.words;
    } else {
        threshold->value = fc_chnif.packets;
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set FC threshold for scheduled traffic per {port,priority}
 */
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || (SOC_IS_ARAD(unit) && threshold->type == bcmCosqThresholdPacketDescriptors))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_FLOW_CONTROL | BCM_COSQ_THRESHOLD_UNICAST))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if (cosq != -1 && !(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    /* Make the Update */
    rc = _bcm_petra_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get FC threshold for scheduled traffic per {port,priority}
 */
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API\n"), unit));
    }

    if (cosq != -1 && !(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL;  

    /* Get information from SW */
    rc = _bcm_petra_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef  BCM_ARAD_SUPPORT
/* 
 * Purpose:
 * Set FC threshold for traffic per interface
 */
STATIC int
_bcm_petra_cosq_gport_interface_egress_fc_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t uc_thresh_key;
    bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t mc_thresh_key;
    int is_allocated, is_last;
    int template, old_template;
    uint32 exact_value;
    int temp;       

    SOC_TMC_INTERFACE_ID if_id,if_id_internal;

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_FLOW_CONTROL))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }


    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    rc = _bcm_petra_port_to_nif_id(unit,gport,&temp);
    BCMDNX_IF_ERR_EXIT(rc);

    if_id = temp;
    
    if_id_internal = arad_nif2intern_id(unit, if_id);

    if(if_id_internal < 0 || if_id_internal >= SOC_TMC_IF_NOF_NIFS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid interface %d, range: 0-%d\n"), unit, gport, SOC_TMC_IF_NOF_NIFS)); 
    }

    /* Old data get */
    if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
        rc = _bcm_dpp_am_template_cosq_egr_interface_unicast_thresh_data_get(unit,if_id_internal,&uc_thresh_key);
    }
    else
    {
        rc = _bcm_dpp_am_template_cosq_egr_interface_multicast_thresh_data_get(unit,if_id_internal,&mc_thresh_key);
    }
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change data */     
    rc = _bcm_petra_egress_thresh_to_exact_thresh(unit,threshold->value,&exact_value);
    BCMDNX_IF_ERR_EXIT(rc);


    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            /* Schedule or Unschedule */
            uc_thresh_key.fc_words_consumed = exact_value;
            break;     
        case bcmCosqThresholdBufferDescriptors:
        case bcmCosqThresholdPacketDescriptors:
            /* Schedule or Unschedule */
            if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
                uc_thresh_key.fc_packet_descriptors = exact_value;
            }else
            {
                mc_thresh_key.fc_packet_descriptors = exact_value;
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));             
    }

    /* Set new object */
    if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
        rc = _bcm_dpp_am_template_cosq_egr_interface_unicast_thresh_exchange(unit,if_id_internal,&uc_thresh_key,&old_template,&is_last,&template,&is_allocated);
    }
    else
    {
        rc = _bcm_dpp_am_template_cosq_egr_interface_multicast_thresh_exchange(unit,if_id_internal,&mc_thresh_key,&old_template,&is_last,&template,&is_allocated);
    }
    BCMDNX_IF_ERR_EXIT(rc);

    if (old_template != template) {
        /* Set new profile */
        if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
            rc = _bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_set(unit,if_id,template);
        }
        else
        {
            rc = _bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_set(unit,if_id,template);
        }
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_allocated) {
        /* Set new data for a specific profile */
        if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
            rc = _bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_data_set(unit,template,&uc_thresh_key);
        }
        else
        {
            rc = _bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_data_set(unit,template,&mc_thresh_key);
        }
        BCMDNX_IF_ERR_EXIT(rc);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get FC threshold traffic per interface
 */
STATIC int
_bcm_petra_cosq_gport_interface_egress_fc_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t uc_thresh_key;
    bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t mc_thresh_key;
    SOC_TMC_INTERFACE_ID if_id,if_id_internal;

    int temp;

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }


    rc = _bcm_petra_port_to_nif_id(unit,gport,&temp);
    BCMDNX_IF_ERR_EXIT(rc);

    if_id = temp;
    
    if_id_internal = arad_nif2intern_id(unit, if_id);

    if(if_id_internal < 0 || if_id_internal >= SOC_TMC_IF_NOF_NIFS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, invalid interface %d, range: 0-%d\n"), unit, gport, SOC_TMC_IF_NOF_NIFS));
    }
    
    if ( (threshold->type == bcmCosqThresholdBytes) &&
                             !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Threshold bytes applicable for Unicast only")));
    }

    threshold->flags |= BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL;  
    
    /* Get information from SW */
    if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
        rc = _bcm_dpp_am_template_cosq_egr_interface_unicast_thresh_data_get(unit,if_id_internal,&uc_thresh_key);
    }
    else
    {
        rc = _bcm_dpp_am_template_cosq_egr_interface_multicast_thresh_data_get(unit,if_id_internal,&mc_thresh_key);
    }
    BCMDNX_IF_ERR_EXIT(rc);

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            /* Schedule or Unschedule */
            threshold->value = uc_thresh_key.fc_words_consumed;
            break;     
        case bcmCosqThresholdBufferDescriptors:
        case bcmCosqThresholdPacketDescriptors:
            /* Schedule or Unschedule */
            if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
                threshold->value = uc_thresh_key.fc_packet_descriptors;
            }
            else
            {
                threshold->value = mc_thresh_key.fc_packet_descriptors;
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field")));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
#endif  /* BCM_ARAD_SUPPORT */
/* 
 * Purpose: 
 * Set global configuration of scheduled traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int queue_id;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    rc = _bcm_petra_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(queue_id))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    
    {
      /* Update only relevant information */
      SOC_TMC_EGR_DROP_THRESH drop_thresh,exact_drop_thresh;
      uint32 soc_sand_rc;
      SOC_TMC_EGR_Q_PRIO prio;      

      rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,queue_id,&prio);
      BCMDNX_IF_ERR_EXIT(rc);

      SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
        
      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_get,(unit,prio,&drop_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

      if (threshold->type == bcmCosqThresholdBytes) {
          drop_thresh.words_consumed = threshold->value;
      } else if (threshold->type == bcmCosqThresholdPackets) {
          drop_thresh.packets_consumed = threshold->value;
      } else if (threshold->type == bcmCosqThresholdAvailablePacketDescriptors) {
          drop_thresh.descriptors_avail = threshold->value;
      } else if (threshold->type == bcmCosqThresholdAvailableDataBuffers) {
          drop_thresh.buffers_avail = threshold->value;
      } else if (threshold->type == bcmCosqThresholdDataBuffers) {
          drop_thresh.buffers_used = threshold->value;
      } else {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d\n"), threshold->type));
      }

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_set,(unit,prio,&drop_thresh,&exact_drop_thresh)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
     
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of scheduled traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT ,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdPacketDescriptors) {
            info.global.uc.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            info.global.uc.buffers = threshold->value;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int queue_id;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_DROP | BCM_COSQ_THRESHOLD_PER_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    rc = _bcm_petra_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(queue_id))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if (threshold->dp > DPP_COSQ_EGR_DP_NUM_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d\n"), threshold->dp));
    }

    {
        /* Update only relevant information */
        SOC_TMC_EGR_DROP_THRESH drop_thresh,exact_drop_thresh;
        uint32 soc_sand_rc, dp;
        SOC_TMC_EGR_Q_PRIO prio;               
        
        rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,queue_id,&prio);
        BCMDNX_IF_ERR_EXIT(rc);
        
        dp = threshold->dp;
        
        SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_get,(unit,prio,dp,&drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        
        if (threshold->type == bcmCosqThresholdBytes) {
          drop_thresh.words_consumed = threshold->value;
        } else if (threshold->type == bcmCosqThresholdPackets) {
          drop_thresh.packets_consumed = threshold->value;
        } else if (threshold->type == bcmCosqThresholdAvailablePacketDescriptors) {
          drop_thresh.descriptors_avail = threshold->value;
        } else if (threshold->type == bcmCosqThresholdAvailableDataBuffers) {
          drop_thresh.buffers_avail = threshold->value;
        } else if (threshold->type == bcmCosqThresholdDataBuffers) {
          drop_thresh.buffers_used = threshold->value;
        } else {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_set,(unit,prio,dp,&drop_thresh,&exact_drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
             
    }
     
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdPacketDescriptors) {
            info.global.mc.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            info.global.mc.buffers = threshold->value;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of all traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_all_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdPacketDescriptors) {
            info.global.total.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            info.global.total.buffers = threshold->value;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled service pool 0 traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp0_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq < 0 || cosq >= ARAD_NOF_TRAFFIC_CLASSES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq %d\n"), unit, cosq));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdDataBuffers){
            info.pool_tc[0][cosq].mc.buffers = threshold->value;
        } else if(threshold->type == bcmCosqThresholdPacketDescriptors) {
            info.pool_tc[0][cosq].mc.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdAvailableDataBuffers){
            info.pool_tc[0][cosq].reserved.buffers = threshold->value;
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
    
/* 
 * Purpose: 
 * Set global configuration of unscheduled service pool 0 traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp0_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdPacketDescriptors) {
            info.pool[0].mc.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            info.pool[0].mc.buffers = threshold->value;
        } else if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors) {
            info.pool[0].reserved.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdAvailableDataBuffers){
            info.pool[0].reserved.buffers = threshold->value;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled service pool 1 traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp1_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST_SP1 | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq < 0 || cosq >= ARAD_NOF_TRAFFIC_CLASSES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq %d\n"), unit, cosq));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdPacketDescriptors) {
            info.pool_tc[1][cosq].mc.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            info.pool_tc[1][cosq].mc.buffers = threshold->value;
        } else if(threshold->type == bcmCosqThresholdAvailableDataBuffers){
            info.pool_tc[1][cosq].reserved.buffers = threshold->value;
        } 
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }

    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled service pool 1 traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp1_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST_SP1 | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1 ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdPacketDescriptors) {
            info.pool[1].mc.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            info.pool[1].mc.buffers = threshold->value;
        } else if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors) {
            info.pool[1].reserved.descriptors = threshold->value;
        } else if(threshold->type == bcmCosqThresholdAvailableDataBuffers){
            info.pool[1].reserved.buffers = threshold->value;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);         
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of scheduled traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_EGR_Q_PRIO prio;
    SOC_TMC_EGR_DROP_THRESH drop_thresh;
    int queue_id;

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    rc = _bcm_petra_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_DROP;         

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,queue_id,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
        
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_get,(unit,prio,&drop_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (threshold->type == bcmCosqThresholdBytes) {
      threshold->value = drop_thresh.words_consumed;
    } else if (threshold->type == bcmCosqThresholdPackets) {
      threshold->value = drop_thresh.packets_consumed;
    } else if (threshold->type == bcmCosqThresholdAvailablePacketDescriptors) {
      threshold->value = drop_thresh.descriptors_avail;
    } else if (threshold->type == bcmCosqThresholdAvailableDataBuffers) {
      threshold->value = drop_thresh.buffers_avail;
    } else if (threshold->type == bcmCosqThresholdDataBuffers) {
      threshold->value = drop_thresh.buffers_used;
    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
    }
    
                                                 
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of scheduled traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
            threshold->value = info.global.uc.descriptors;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            threshold->value = info.global.uc.buffers;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL,(_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of unscheduled traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, dp;
    SOC_TMC_EGR_Q_PRIO prio;
    SOC_TMC_EGR_DROP_THRESH drop_thresh;
    int queue_id;           

    BCMDNX_INIT_FUNC_DEFS;
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    rc = _bcm_petra_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(queue_id))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if (threshold->dp > DPP_COSQ_EGR_DP_NUM_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_DROP | BCM_COSQ_THRESHOLD_PER_DP;  
        
    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,queue_id,&prio);
    BCMDNX_IF_ERR_EXIT(rc);
    
    dp = threshold->dp;
    
    SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_get,(unit,prio,dp,&drop_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    if (threshold->type == bcmCosqThresholdBytes) {
      threshold->value = drop_thresh.words_consumed;
    } else if (threshold->type == bcmCosqThresholdPackets) {
      threshold->value = drop_thresh.packets_consumed;
    } else if (threshold->type == bcmCosqThresholdAvailablePacketDescriptors) {
      threshold->value = drop_thresh.descriptors_avail;
    } else if (threshold->type == bcmCosqThresholdAvailableDataBuffers) {
      threshold->value = drop_thresh.buffers_avail;
    } else if (threshold->type == bcmCosqThresholdDataBuffers) {
      threshold->value = drop_thresh.buffers_used;
    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
    }
    
                                                 
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of unscheduled traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBufferDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptors))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
            threshold->value = info.global.mc.descriptors;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            threshold->value = info.global.mc.buffers;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of all traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_all_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBufferDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers 
          || threshold->type == bcmCosqThresholdPacketDescriptors))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
            threshold->value = info.global.total.descriptors;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            threshold->value = info.global.total.buffers;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of unscheduled service pool 0 traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp0_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq < 0 || cosq >= ARAD_NOF_TRAFFIC_CLASSES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq %d\n"), unit, cosq));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdDataBuffers){
            threshold->value = info.pool_tc[0][cosq].mc.buffers;
        }
        else if(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
            threshold->value = info.pool_tc[0][cosq].mc.descriptors;
        } else if(threshold->type == bcmCosqThresholdAvailableDataBuffers){
            /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
            /* coverity[uninit_use:FALSE] */
            threshold->value = info.pool_tc[0][cosq].reserved.buffers;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of unscheduled service pool 0 traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp0_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
            threshold->value = info.pool[0].mc.descriptors;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            threshold->value = info.pool[0].mc.buffers;
        } else if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors) {
            threshold->value = info.pool[0].reserved.descriptors;
        } else if(threshold->type == bcmCosqThresholdAvailableDataBuffers){
            /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
            /* coverity[uninit_use:FALSE] */
            threshold->value = info.pool[0].reserved.buffers;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of unscheduled service pool 1 traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp1_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG ("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST_SP1 | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq < 0 || cosq >= ARAD_NOF_TRAFFIC_CLASSES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq %d\n"), unit, cosq));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
            threshold->value = info.pool_tc[1][cosq].mc.descriptors;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            threshold->value = info.pool_tc[1][cosq].mc.buffers;
        } else if(threshold->type == bcmCosqThresholdAvailableDataBuffers){
            /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
            /* coverity[uninit_use:FALSE] */
            threshold->value = info.pool_tc[1][cosq].reserved.buffers;
        } 
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of unscheduled service pool 1 traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp1_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(gport){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,(_BSL_BCM_MSG ("unit %d, Gport should be NULL\n"), unit));
    }

    if(SOC_IS_PETRAB(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNIT,(_BSL_BCM_MSG("unit %d, Not supported in PetraB\n"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_MULTICAST_SP1 | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if(cosq != -1 ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if(SOC_IS_ARAD(unit)) {
        ARAD_EGR_QUEUING_DEV_TH info;
        uint32 soc_sand_rc = SOC_SAND_OK;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if(threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors) {
            threshold->value = info.pool[1].mc.descriptors;
        } else if(threshold->type == bcmCosqThresholdDataBuffers){
            threshold->value = info.pool[1].mc.buffers;
        } else if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors) {
            threshold->value = info.pool[1].reserved.descriptors;
        } else if(threshold->type == bcmCosqThresholdAvailableDataBuffers){
            /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
            /* coverity[uninit_use:FALSE] */
            threshold->value = info.pool[1].reserved.buffers;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid threshold type parameter %d"), threshold->type));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Set unscheduled traffic drop thresholds per port
 */
STATIC int
_bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || (SOC_IS_ARAD(unit) && threshold->type == bcmCosqThresholdPacketDescriptors))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_DROP | BCM_COSQ_THRESHOLD_MULTICAST))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }
    
    if(cosq != -1 && !(threshold->flags & BCM_COSQ_THRESHOLD_PER_DP)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    if (cosq != -1 && threshold->dp > DPP_COSQ_EGR_DP_NUM_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    if (cosq != -1 && !(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors && cosq == -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("-1 is not valid cosq for the type bcmCosqThresholdAvailablePacketDescriptors")));
    }
    /* SW multiset Update */
    rc = _bcm_petra_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Get scheduled traffic drop thresholds per port
 */
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (cosq != -1 && !(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_DROP;  

    /* Get information from SW */
    rc = _bcm_petra_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Set scheduled traffic drop thresholds per port
 */
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || (SOC_IS_ARAD(unit) && threshold->type == bcmCosqThresholdPacketDescriptors))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_EGRESS
        | BCM_COSQ_THRESHOLD_DROP | BCM_COSQ_THRESHOLD_UNICAST))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    /* SW multiset Update */
    rc = _bcm_petra_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Conversion from cosq parameter to egress queue id
 */
STATIC int
_bcm_petra_egress_queue_from_cosq(int unit,
                                  int *queue_id,
                                  int cosq)
{
    bcm_error_t rv = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    switch (cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            *queue_id = 0;
            break;
        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            *queue_id = 1;
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            *queue_id = cosq;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported cosq: %d in this API"), unit,cosq));
    }
    
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_dpp_cosq_internal_priority_get(int unit,
                                    int cosq,
                                    int *priority)
{
    bcm_error_t rv = BCM_E_NONE;
    

    BCMDNX_INIT_FUNC_DEFS;
    switch (cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            *priority = 0;
            break;

        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            *priority = 1;
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported cosq: %d in this API"), unit,cosq));
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Similar functionality to _bcm_petra_egress_queue_from_cosq() function.
 * However this returns the Flow Control priority. The aim of this function
 * to to handle High/Low priority macros. It is the calling function responsibilty
 * to check the cosq range (according to egress queue model) and this function can
 * be called for any device (petra/arad)
 */
STATIC int
_bcm_dpp_cosq_egress_cosq_inband_fc_priority_get(int unit,
                                                 int cosq,
                                                 int *priority)
{
    bcm_error_t rv = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    switch (cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            (*priority) = SOC_TMC_FC_OFP_PRIORITY_HP;
            break;
        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            (*priority) = SOC_TMC_FC_OFP_PRIORITY_LP;
            break;
        default:
            (*priority) = cosq;
    }
    
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Get unscheduled traffic drop thresholds per port
 */
STATIC int
_bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int max_cosq_num; 

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    max_cosq_num = DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);

    if (!((cosq >= -1 && cosq <= max_cosq_num) ||
          (cosq >= BCM_COSQ_HIGH_PRIORITY && cosq <= BCM_COSQ_LOW_PRIORITY))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d, cosq can be in range of 0-1 or High/Low priorities"), cosq));
    }
    
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || (SOC_IS_ARAD(unit) && threshold->type == bcmCosqThresholdPacketDescriptors))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (threshold->dp > DPP_COSQ_EGR_DP_NUM_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors && cosq == -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("-1 is not valid cosq for the type bcmCosqThresholdAvailablePacketDescriptors")));
    }

    threshold->flags = BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_EGRESS | BCM_COSQ_THRESHOLD_DROP;

    if(cosq != -1){
        threshold->flags |= BCM_COSQ_THRESHOLD_PER_DP;
    }

    /* Get information from SW */
    rc = _bcm_petra_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get all info for a specific profile from hw
 */
int
_bcm_petra_cosq_gport_egress_queue_mapping_hw_get(int unit,
                                                  int profile,
                                                  int core,
                                                  bcm_dpp_cosq_egress_queue_mapping_info_t* mapping_info)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE index_type;
    bcm_cos_t index_pri; 
    bcm_color_t index_dp;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;
    
    BCMDNX_INIT_FUNC_DEFS;

    for (index_type = 0; index_type < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO_MAPPING_TYPES; index_type++) {
        for (index_pri = 0; index_pri < DPP_DEVICE_COSQ_ING_NOF_TC; index_pri++) {
            for (index_dp = 0; index_dp < DPP_DEVICE_COSQ_ING_NOF_DP; index_dp++) {
                rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_prio_get,(unit, core, index_type, index_pri, index_dp, profile, &egr_prio));
                BCMDNX_IF_ERR_EXIT(rc);

                mapping_info->queue_mapping[index_type][index_pri][index_dp].dp = egr_prio.dp;
                mapping_info->queue_mapping[index_type][index_pri][index_dp].tc = egr_prio.tc;                
            }
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set new profile for egress queue mapping
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_mapping_hw_set(int unit,
                                                  int profile,
                                                  int core,
                                                  CONST bcm_dpp_cosq_egress_queue_mapping_info_t* mapping_info)
{   
    bcm_error_t rc = BCM_E_NONE;
    int index_dp,index_pri,index_type;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;      
    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Run over all data and commit to hw */
    for (index_type = 0; index_type < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO_MAPPING_TYPES; index_type++) {
        for (index_pri = 0; index_pri < DPP_DEVICE_COSQ_ING_NOF_TC; index_pri++) {
            for (index_dp = 0; index_dp < DPP_DEVICE_COSQ_ING_NOF_DP; index_dp++) {
                egr_prio.dp = mapping_info->queue_mapping[index_type][index_pri][index_dp].dp;
                egr_prio.tc = mapping_info->queue_mapping[index_type][index_pri][index_dp].tc;

                rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_prio_set,(unit, core, index_type, index_pri, index_dp, profile, &egr_prio));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get mapping egress queue
 *
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_map_get(int unit,
                                          bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t *offset)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;
    uint32 tm_port;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));
    SOC_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Validate input params */
    BCMDNX_NULL_CHECK(offset);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Unicast type */
    map_type = SOC_TMC_EGR_UCAST_TO_SCHED;
    *offset = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * init egress port to a specific configuration (out_tc,out_dp)
 */
int
_bcm_petra_cosq_gport_egress_map_init(int unit, bcm_port_t port)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port, nof_priorities;
    int is_last, is_allocated, core;
    int old_profile, new_profile;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    int tc, dp, priority;

    BCMDNX_INIT_FUNC_DEFS;

    rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
    BCMDNX_IF_ERR_EXIT(rc);

    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));

    /* Get Old data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    for(tc = 0; tc < DPP_DEVICE_COSQ_EGR_NOF_TC ; tc++)
    {
        /*select Q*/
        switch(nof_priorities) {
            case 1:
              priority = 0;
              break;
            case 2:
              priority = (tc<4 ? 0 : 1);
              break;
            case 8:
            default:
              priority = tc;
              break;
        }


        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++)
        {
            /* set unsched traffic mapping */
            mapping_info.queue_mapping[SOC_TMC_EGR_MCAST_TO_UNSCHED][tc][dp].dp = dp;
            mapping_info.queue_mapping[SOC_TMC_EGR_MCAST_TO_UNSCHED][tc][dp].tc = priority;

            /* set sched traffic mapping*/
            mapping_info.queue_mapping[SOC_TMC_EGR_UCAST_TO_SCHED][tc][dp].dp = dp;
            mapping_info.queue_mapping[SOC_TMC_EGR_UCAST_TO_SCHED][tc][dp].tc = priority;
        }
    }

    /* Exchange data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_petra_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Map port to new profile */   
    rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;

}

/* 
 * Purpose:
 * Map egress queue to a specific priority (offset)
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_map_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_t ingress_pri,
                                           bcm_color_t ingress_dp,
                                           bcm_cos_queue_t offset)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    int is_last,is_allocated;
    int old_profile, new_profile;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    uint32 tm_port;
    SOC_TMC_EGR_Q_PRIO tc;
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Validate input params */
    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (offset < 0 || offset >= SOC_TMC_EGR_NOF_Q_PRIO_ARAD) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid offset parameter %d"), offset));
    }

    /* Get Old data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change specific entry - preserve dp, change new tc (offset) */
    /* Unicast type and Scheduled to Multicast */
    map_type = SOC_TMC_EGR_UCAST_TO_SCHED;

    rc =  _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit, offset, &tc);
    BCMDNX_IF_ERR_EXIT(rc);

    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc = tc;

    /* Exchange data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile,& is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_petra_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
        }

    /* Map port to new profile */   
    rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Map egress port to a specific multicast configuration (out_tc,out_dp)
 */
STATIC int
_bcm_petra_cosq_gport_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;
    int is_last, is_allocated, core;
    int old_profile, new_profile;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    int queue_id;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }
  
    if (!(flags == BCM_COSQ_MULTICAST_SCHEDULED)) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if (config->scheduled_dp < 0 || config->scheduled_dp > DPP_DEVICE_COSQ_EGR_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid scheduled_dp parameter %d"), config->scheduled_dp));
    }

    rc = _bcm_petra_egress_queue_from_cosq(unit, &queue_id, config->priority);
    BCMDNX_IF_ERR_EXIT(rc);

    if (queue_id < 0 || queue_id >= SOC_TMC_EGR_NOF_Q_PRIO_ARAD) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid config->priority parameter %d"), queue_id));
    }

    /* Get Old data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change specific entry - change new tc, new dp (scheduled_tc,scheduled_dp) */
    /* Schedule Multicast type */
    map_type = SOC_TMC_EGR_MCAST_TO_UNSCHED;

    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].dp = config->scheduled_dp;
    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc = queue_id;

    /* Exchange data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_petra_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Map port to new profile */   
    rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);     

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Retrieve specific multicast configuration (out_dp) from port
 */
STATIC int
_bcm_petra_cosq_gport_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;
    uint32 tm_port;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));
    SOC_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (flags & BCM_COSQ_MULTICAST_UNSCHEDULED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Multicast type */
    map_type = SOC_TMC_EGR_MCAST_TO_UNSCHED;
    config->scheduled_dp = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].dp;
    config->priority = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc;
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Map egress device to a specific multicast configuration (out_tc,out_dp)
 */
STATIC int
_bcm_petra_cosq_device_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    uint32 soc_sand_rv;   
    SOC_TMC_EGR_QUEUING_MC_COS_MAP info;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate input params */
    BCMDNX_NULL_CHECK(config);
    BCM_DPP_UNIT_CHECK(unit);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (!(flags & BCM_COSQ_MULTICAST_UNSCHEDULED)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if (config->unscheduled_se < 0 || config->unscheduled_se > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid unscheduled_se parameter %d"), config->unscheduled_se));
    }

    if (config->unscheduled_sp < 0 || config->unscheduled_sp > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid unscheduled_sp parameter %d"), config->unscheduled_sp));
    }

    if(SOC_IS_ARAD(unit))
    {
        /* Get Old data */
        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_cos_map_get,(unit, ingress_pri, ingress_dp, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

    
        info.tc_group = config->priority;
        info.pool_eligibility = config->unscheduled_se;
        info.pool_id = config->unscheduled_sp;

        /* Set data */
        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_cos_map_set,(unit, ingress_pri, ingress_dp, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
        BCM_EXIT;
    }
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid, only supported for Petra-B"), unit));
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Retrieve specific multicast configuration (out_dp) from port
 */
STATIC int
_bcm_petra_cosq_device_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    uint32 soc_sand_rv;   
    SOC_TMC_EGR_QUEUING_MC_COS_MAP info;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (!(flags == BCM_COSQ_MULTICAST_UNSCHEDULED)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if(SOC_IS_ARAD(unit))
    {
        /* Get Old data */
        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_cos_map_get,(unit, ingress_pri, ingress_dp, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->priority = info.tc_group;
        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->unscheduled_se = info.pool_eligibility;
        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->unscheduled_sp = info.pool_id;
        BCM_EXIT;
    }
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Is invalid, only supported for Petra-B"), unit));
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set tc packet to FMQ queue mapping
 * Valid when enhance is disable 
 */
STATIC int
_bcm_petra_cosq_fmq_mapping_set(int unit, 
                                     bcm_port_t port,
                                     bcm_cos_t priority, 
                                     bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_TR_CLS tc;
    SOC_TMC_MULT_FABRIC_CLS fabric_cls;
    uint32 soc_sand_rv;   

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
    }

    if (priority < 0 || priority >= DPP_COSQ_PACKET_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority));
    }

    if (cosq < 0 || cosq > DPP_COSQ_FMQ_MAX_CLS_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq));
    }

    tc = priority;
    fabric_cls = cosq;

    soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_traffic_class_to_multicast_cls_map_set,(unit,tc,fabric_cls)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : Retreive FMQ queue mapping from packet TC.
 * Valid when enhance is disable 
 */
STATIC int
_bcm_petra_cosq_fmq_mapping_get(int unit,
                                bcm_port_t port,
                                bcm_cos_t priority,
                                bcm_cos_queue_t *cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_TR_CLS tc;
    SOC_TMC_MULT_FABRIC_CLS fabric_cls = 0;
    uint32 soc_sand_rv;        

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(cosq);

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
    }

    if (priority < 0 || priority >= DPP_COSQ_PACKET_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority));
    }

    tc = priority;
 
    soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_traffic_class_to_multicast_cls_map_get,(unit,tc,&fabric_cls)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

    *cosq = fabric_cls;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_e2e_hr_modify(int unit, bcm_gport_t port, int numq, uint32 flags, bcm_gport_t *gport, int is_composite, int is_dual, int hr_mode)
{
    bcm_error_t              rc = BCM_E_NONE;
    bcm_gport_t              port_gport;
    uint32                   fap_port;
    SOC_TMC_SCH_SE_ID        se_id;
    uint32                   soc_sand_rc;    
    SOC_TMC_SCH_PORT_INFO    port_info;
    SOC_TMC_SCH_SE_INFO      se_info;
    SOC_TMC_SCH_FLOW         sch_flow, exact_sch_flow;
    int                      hr_class, old_profile, is_last, profile, is_allocated, flow_id, core;
    bcm_dpp_cosq_config_t    *cosq_config;
    bcm_cos_queue_t          cosq;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    cosq_config = &_dpp_cosq_config[unit];
    /*
     * For ARAD, core should be '0'.
     */
    core = 0 ;

    SOC_TMC_SCH_PORT_INFO_clear(&port_info);
    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(&sch_flow);
    SOC_TMC_SCH_FLOW_clear(&exact_sch_flow);


    if ( !( BCM_COSQ_GPORT_IS_E2E_PORT((*gport)) || BCM_COSQ_GPORT_IS_FMQ_CLASS((*gport)) || BCM_COSQ_GPORT_IS_ISQ_ROOT((*gport)) ||
            (BCM_COSQ_GPORT_IS_E2E_PORT_TC((*gport)) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport 0x%x, modify only supported for e2e ports"), unit, (*gport)));
    }

    if ( (is_composite) || (is_dual) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, is not supported for dual and composite, is_composite: %d, is_dual: %d"), unit,is_composite, is_dual));
    }

    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, (*gport), &port_gport);
    BCMDNX_IF_ERR_EXIT(rc);
    if ( !(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport) || BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) ) {
         BCMDNX_IF_ERR_EXIT(rc); /* does nothing */
    }

    /* Verify PORT-TC */
    if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) {
        rc = _bcm_petra_cosq_port_priority_validate(unit,port_gport,numq);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        /* Verify numq */
        if (numq != 1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
        }
    }

    /* numq determine cosq index.
     * In case of E2E gport - numq = 0 (Petra-B compatbility).
     * In case of Port TC: numq = priority_ndx
     */
    cosq = (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) ? DPP_COSQ_PB_DEFAULT_PORT_TC:numq;

    if (BCM_COSQ_GPORT_IS_FMQ_CLASS((*gport)) || BCM_COSQ_GPORT_IS_ISQ_ROOT((*gport))) {
        if(SOC_IS_JERICHO(unit)){
            uint32 loc_fap_port ;
            rc = _bcm_petra_cosq_fap_port_get(unit, port, &loc_fap_port, &core) ;
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get core for gport: 0x%x, error(0x%x)\r\n"), port, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
            fap_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);
            rc = _bcm_petra_cosq_port2se_id(unit,fap_port,cosq,&se_id);            
            if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) {          
            fap_port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(port_gport);
            rc = _bcm_petra_cosq_port2se_id(unit,fap_port,cosq,&se_id);            
            if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        } else {
            flow_id = BCM_GPORT_SCHEDULER_GET(port_gport);
            se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));
            if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        }

        /* configure scheduler element */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, se_id, &se_info, &sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        se_info.type_info.hr.mode = hr_mode;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_id, &se_info, &sch_flow, &exact_sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }
    else {
        rc = _bcm_petra_cosq_fap_port_get(unit, port_gport, &fap_port, &core);
        if (rc != BCM_E_NONE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, got invalid fap port %d,  for port (0x%x)"), unit, fap_port, port));
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_get,(unit, core, fap_port, &port_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler info port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        
                
        if (SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.hr_modes[cosq] = hr_mode;
        } else {
            port_info.hr_mode = hr_mode;
        }

        /* Port-TC feature: no need to support HR flow control class. since for each HR there is respective flow control priority */
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            hr_class = cosq_config->hr_fc_default_template_data;
            port_info.lowest_hp_class = hr_class;

            /* set default flow control mapping. It is a default profile that is always allocated */
            rc = _bcm_dpp_am_template_cosq_port_hr_fc_exchange(unit, fap_port, &hr_class, &old_profile, &is_last, &profile, &is_allocated);
            BCMDNX_IF_ERR_EXIT(rc);

#ifdef BCM_WARM_BOOT_SUPPORT
            rc = _bcm_dpp_wb_cosq_update_e2e_fc_data(unit, 0, old_profile, profile);
            BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler info port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_hr_mode_get(int unit, uint32 flags, int *hr_mode)
{
    bcm_error_t              rc = BCM_E_NONE;
    int                      hr_mode_mask;


    BCMDNX_INIT_FUNC_DEFS;

    hr_mode_mask = flags & DPP_DEVICE_COSQ_HR_MASK;
    switch (hr_mode_mask) {
        case BCM_COSQ_GPORT_SCHEDULER_HR_DUAL_WFQ:
            (*hr_mode) = SOC_TMC_SCH_HR_MODE_DUAL_WFQ;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_HR_ENHANCED:
            (*hr_mode) = SOC_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_HR_SINGLE_WFQ:
            (*hr_mode) = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;
            break;
        default:
            (*hr_mode) = SOC_TMC_SCH_HR_MODE_NONE;
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid hr mode flags parameter 0x%x\n"), unit, hr_mode_mask));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_hr_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual)
{
    bcm_error_t              rc = BCM_E_NONE;
    uint32                   soc_sand_rc;
    SOC_TMC_SCH_FLOW           flow_config, exact_flow_config;
    SOC_TMC_SCH_SE_INFO        se_config;
    SOC_TMC_SCH_SE_ID          se_index;    
    uint32                   relevant_flags, res_flags = 0;
    int                      hr_mode, core ;
    int                      flow_id = -1, comp_flow_id;
    bcm_dpp_cosq_config_t    *cosq_config;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    cosq_config = &_dpp_cosq_config[unit];    
    /*
     * For ARAD, core should be '0'.
     */
    core = 0 ;
    if(SOC_IS_JERICHO(unit)){
        uint32 loc_fap_port ;
        rc = _bcm_petra_cosq_fap_port_get(unit, port, &loc_fap_port, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get core for gport: 0x%x, error(0x%x)\r\n"), port, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DPP_DEVICE_COSQ_HR_MASK | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    rc = _bcm_petra_cosq_sched_hr_mode_get(unit, relevant_flags, &hr_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* handle BCM_COSQ_GPORT_REPLACE - for e2e ports only */
    if (flags & BCM_COSQ_GPORT_REPLACE) {
        rc = _bcm_petra_cosq_sched_e2e_hr_modify(unit, port, numq, flags, gport, is_composite, is_dual, hr_mode);
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }
    
    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= SHR_RES_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));
        if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, flow_id));
        }

        /* validate flow id */
#ifdef  BCM_PETRAB_SUPPORT
        if (SOC_IS_PETRAB(unit)) {
            if (!SOC_PETRA_SCH_SE_IS_HR(se_index)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE-HR"), unit, flow_id));
            }
        }
#endif  /* BCM_PETRAB_SUPPORT */
#ifdef  BCM_ARAD_SUPPORT
        if (SOC_IS_ARAD(unit)) {
            if (!ARAD_SCH_SE_IS_HR(se_index)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE-HR"), unit, flow_id));
            }
        }
#endif  /* BCM_ARAD_SUPPORT */
    }

    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_flags, is_composite, FALSE, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_composite) { /* adjustment for low level allocation of 2 resources */
        rc = _bcm_petra_se_composite_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_HR, FALSE, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* initialize se */
    se_index =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit %d, hr resource gport_add, flow_id (%d/0x%x) se_index(%d/0x%x\n"), 
                          unit, flow_id, flow_id, se_index, se_index));

    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, hr resource gport_add, is_composite(%s) is_dual(%s)\n"), unit, 
                            (is_composite==1) ? "TRUE":"FALSE",
                 (is_dual==1) ? "TRUE":"FALSE"));

    SOC_TMC_SCH_FLOW_clear(&flow_config);
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    flow_config.flow_type = SOC_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    flow_config.sub_flow[0].credit_source.se_type = cosq_config->default_se_type;
    flow_config.sub_flow[0].credit_source.id = cosq_config->default_se;

    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, hr resource gport_add, subflow 0 credit source se_type(%d) sp_class(%d) id(%d))\n"), unit,
                            flow_config.sub_flow[0].credit_source.se_type, flow_config.sub_flow[0].credit_source.se_info.hr.sp_class,
                 flow_config.sub_flow[0].credit_source.id));

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        flow_config.sub_flow[1].credit_source.se_type = cosq_config->default_se_type;
        flow_config.sub_flow[1].credit_source.id = cosq_config->default_se;
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = SOC_TMC_SCH_SE_TYPE_HR;
    se_config.type_info.hr.mode = hr_mode;
    se_config.is_dual = FALSE;
    se_config.group = SOC_TMC_SCH_GROUP_AUTO; 

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "hr", soc_sand_rc, rc));
        goto err;
    }

    BCM_GPORT_SCHEDULER_SET((*gport), flow_id);
    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
       if(unit >=0 && unit < BCM_LOCAL_UNITS_MAX) {
            bcm_dpp_am_cosq_scheduler_deallocate(unit, res_flags, is_composite, FALSE, is_dual, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_cl_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual,
                         int is_cl_hr)
{
    bcm_error_t                      rc = BCM_E_NONE;
    uint32                           soc_sand_rc;
    SOC_TMC_SCH_FLOW                     flow_config, exact_flow_config;
    SOC_TMC_SCH_SE_INFO                  se_config;
    SOC_TMC_SCH_SE_ID                    se_index, dual_se_index = 0;    
    int                              is_enhanced = FALSE, hr_mode;
    uint32                           relevant_flags, res_flags = 0, enhanced_mask;
    int                              flow_id = -1, comp_flow_id, dual_flow_id, flow_region;
    int                              cl_mode = 0, enhanced_mode = 0, weight_mode = 0, cid;
    bcm_dpp_cosq_config_t           *cosq_config;
    bcm_dpp_cosq_sched_class_data_t  class_data;
    int                              class_flags = SHR_TEMPLATE_MANAGE_SET_WITH_ID;
    int                              is_allocated, class_template;
    int                              is_odd_even;
    uint8                              is_interdigitated;

    

    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];    

    relevant_flags = flags & ( (BCM_COSQ_GPORT_SCHEDULER | DPP_DEVICE_COSQ_CL_MASK | BCM_COSQ_GPORT_COMPOSITE | DPP_DEVICE_COSQ_CL_ENHANCED_MASK | DPP_DEVICE_COSQ_DUAL_SHAPER_MASK | DPP_DEVICE_COSQ_CL_WFQ_MASK | BCM_COSQ_GPORT_WITH_ID) | (DPP_DEVICE_COSQ_FQ_MASK) | (DPP_DEVICE_COSQ_HR_MASK) );

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    enhanced_mask = flags & DPP_DEVICE_COSQ_CL_ENHANCED_MASK;
    switch (enhanced_mask) {
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ:
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ:
            is_enhanced = TRUE;
            break; 
        default:
            is_enhanced = FALSE;
            break; 
    }

    if ( (is_enhanced == TRUE) && ( (is_composite == TRUE) || (is_dual == TRUE) ) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Enhanced cl configuration and composite/dual can not be together specified"), unit));
    }

    /* consistency checks */
    rc = _bcm_petra_cosq_sched_cl_verfiy_flags_mode_get(unit, flags, &cl_mode, &enhanced_mode, &weight_mode);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, cl element flags not correct, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (is_cl_hr) {
        rc = _bcm_petra_cosq_sched_hr_mode_get(unit, relevant_flags, &hr_mode);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= SHR_RES_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,( flow_id)));
        if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }
        /* validate flow id */
#ifdef  BCM_PETRAB_SUPPORT
        if (SOC_IS_PETRAB(unit)) {
            /* The macro SOC_PETRA_SCH_SE_IS_CL may be used for signed varibles also */
            /* coverity[unsigned_compare : FALSE] */
            if (!SOC_PETRA_SCH_SE_IS_CL(se_index)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flow 0x%x specified - does not correspond to SE-CL\n"), unit, flow_id));
                BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
            }
        }
#endif  /* BCM_PETRAB_SUPPORT */
#ifdef  BCM_ARAD_SUPPORT
        if (SOC_IS_ARAD(unit)) {
            /* The macro ARAD_SCH_SE_IS_CL may be used for signed varibles also */
            /* coverity[unsigned_compare : FALSE] */
            if (!ARAD_SCH_SE_IS_CL(se_index)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flow 0x%x specified - does not correspond to SE-CL\n"), unit, flow_id));
                BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
            }
        }
#endif  /* BCM_ARAD_SUPPORT */
    }

    if (is_cl_hr) {
        rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_flags, is_composite, FALSE, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    else {
        /* allocate flow */
        rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_flags, is_composite, is_enhanced, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_CL, NULL, &flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (is_composite) {
        flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(flow_id);
        rc = _bcm_petra_flow_region_config_get(unit, flow_region, &is_interdigitated, &is_odd_even);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, connector region configuration get, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        rc = _bcm_petra_se_composite_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_CL, is_odd_even, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    if (is_dual) {
        rc = _bcm_petra_se_dual_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_CL, TRUE, &dual_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se failure in getting dual flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* get cid */
    rc = _bcm_petra_sched_cl_profile_get(unit, cl_mode, enhanced_mode, weight_mode, TRUE, &cid);
    if (rc != BCM_E_NONE) {
        goto err;
    }

    /* initialize se */
    se_index =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));
    if (is_dual) {
        dual_se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(dual_flow_id)));
    }

    SOC_TMC_SCH_FLOW_clear(&flow_config);
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    flow_config.flow_type = SOC_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    flow_config.sub_flow[0].credit_source.se_type = cosq_config->default_se_type;
    flow_config.sub_flow[0].credit_source.id = cosq_config->default_se;

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        flow_config.sub_flow[1].credit_source.se_type = cosq_config->default_se_type;
        flow_config.sub_flow[1].credit_source.id = cosq_config->default_se;
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = SOC_TMC_SCH_SE_TYPE_CL;
    se_config.type_info.cl.id = cid;
    se_config.is_dual = is_dual;
    se_config.group = SOC_TMC_SCH_GROUP_AUTO; 

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "cl", soc_sand_rc, rc));
        goto err;
    }

    BCM_GPORT_SCHEDULER_SET((*gport), flow_id);

    /* Update reference count */
    /* retreive current template data */
    rc = _bcm_dpp_am_template_cosq_sched_class_data_get(unit, cid, (int *)&class_data);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving SE(%d) class data cid(%d), error 0x%x\n"), unit, se_index, cid, rc));
        goto err;
    }

    class_template = cid;
    rc = _bcm_dpp_am_template_cosq_sched_class_allocate(unit, class_flags, (int *)&class_data, &is_allocated, &class_template);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in incrementing reference count for class template cid(%d), error 0x%x\n"), unit, cid, rc));
        goto err;
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_class_data(unit, 0, class_template, class_template);
    if (rc != BCM_E_NONE) {
        goto err;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    if (is_dual) {
        flow_config.sub_flow[0].id = dual_flow_id;

        se_config.id = dual_se_index;
        se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
        if (is_cl_hr) {
            se_config.type = SOC_TMC_SCH_SE_TYPE_HR;
            se_config.type_info.hr.mode = hr_mode;
        }
        else {
            se_config.type = SOC_TMC_SCH_SE_TYPE_FQ;
            se_config.type_info.fq.no_info = 0;
        }
        se_config.is_dual = is_dual;
        se_config.group = SOC_TMC_SCH_GROUP_AUTO; 

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, dual_se_index, &se_config, &flow_config, &exact_flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "fq", soc_sand_rc, rc));
            goto err;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
        bcm_dpp_am_cosq_scheduler_deallocate(unit, res_flags, is_composite, is_enhanced, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_CL, flow_id);

        
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_fq_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual)
{
    bcm_error_t              rc = BCM_E_NONE;
    uint32                   soc_sand_rc;
    SOC_TMC_SCH_FLOW           flow_config, exact_flow_config;
    SOC_TMC_SCH_SE_INFO        se_config;
    SOC_TMC_SCH_SE_ID          se_index;    
    uint32                   relevant_flags, res_flags = 0;
    int                      flow_id = -1, comp_flow_id;
    bcm_dpp_cosq_config_t   *cosq_config;


    
    

    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];    

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DPP_DEVICE_COSQ_FQ_MASK | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= SHR_RES_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,( flow_id)));
        if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }

        /* validate flow id */
#ifdef  BCM_PETRAB_SUPPORT
        if (SOC_IS_PETRAB(unit)) {
            if (!SOC_PETRA_SCH_SE_IS_FQ(se_index)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flow 0x%x specified - does not correspond to SE-FQ\n"), unit, flow_id));
                BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
            }
        }
#endif  /* BCM_PETRAB_SUPPORT */
#ifdef  BCM_ARAD_SUPPORT
        if (SOC_IS_ARAD(unit)) {
            if (!ARAD_SCH_SE_IS_FQ(se_index)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flow 0x%x specified - does not correspond to SE-FQ\n"), unit, flow_id));
                BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
            }
        }
#endif  /* BCM_ARAD_SUPPORT */

    }

    /* allocate flow */
    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_flags, is_composite, FALSE, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_FQ, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, fq se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_composite) { /* adjustment for low level allocation of 2 resources */
        rc = _bcm_petra_se_composite_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_FQ, FALSE, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, fq se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* initialize se */
    se_index =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));

    SOC_TMC_SCH_FLOW_clear(&flow_config);
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    flow_config.flow_type = SOC_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    flow_config.sub_flow[0].credit_source.se_type = cosq_config->default_se_type;
    flow_config.sub_flow[0].credit_source.id = cosq_config->default_se;

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        flow_config.sub_flow[1].credit_source.se_type = cosq_config->default_se_type;
        flow_config.sub_flow[1].credit_source.id = cosq_config->default_se;
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = SOC_TMC_SCH_SE_TYPE_FQ;
    se_config.type_info.fq.no_info = 0;
    se_config.is_dual = FALSE; /* Always set with CL element */
    se_config.group = SOC_TMC_SCH_GROUP_AUTO; 

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "fq", soc_sand_rc, rc));
        goto err;
    }

    BCM_GPORT_SCHEDULER_SET((*gport), flow_id);
    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
        bcm_dpp_am_cosq_scheduler_deallocate(unit, res_flags, is_composite, FALSE, is_dual, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_FQ, flow_id);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_gport_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport)
{
    bcm_error_t                 rc = BCM_E_NONE;
    uint32                      resource_count = 0;
    int                         is_hr = FALSE, is_cl = FALSE, is_fq = FALSE, is_cl_fq = FALSE, is_cl_hr = FALSE;
    uint32                      relevant_flags, fap_port;
    int                         shaper_mask;
    int                         is_composite, is_dual = FALSE;
    int                         flow_id = 0, sf2_id = 0, se_index, core;
    SOC_TMC_SCH_SE_ID           se_id;
    int                         dual_flow_id, dual_se_index;
    bcm_gport_t                 alternate_gport;
    bcm_dpp_cosq_flow_config_t  *flow_state_config[2] = {NULL, NULL};
    bcm_dpp_cosq_se_config_t    *se_state_config = NULL, *dual_se_state_config = NULL;
    bcm_dpp_cosq_config_t       *cosq_config;
    bcm_cos_queue_t             cosq = 0;
    int                         is_reserved;

    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit] ;
    /*
     * For ARAD, core should be '0'.
     */
    core = 0 ;
    if(SOC_IS_JERICHO(unit)){
        rc = _bcm_petra_cosq_fap_port_get(unit, port, &fap_port, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get core for gport: 0x%x, error(0x%x)\r\n"), port, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    /* basic consistency checks */

    if (gport == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error gport is NULL"), unit));
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DPP_DEVICE_COSQ_HR_MASK | DPP_DEVICE_COSQ_CL_MASK | DPP_DEVICE_COSQ_FQ_MASK | BCM_COSQ_GPORT_COMPOSITE | DPP_DEVICE_COSQ_CL_ENHANCED_MASK | DPP_DEVICE_COSQ_DUAL_SHAPER_MASK | DPP_DEVICE_COSQ_CL_WFQ_MASK | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    if (flags & DPP_DEVICE_COSQ_CL_MASK) {
        is_cl = TRUE;
        resource_count++;
    }
    if (flags & DPP_DEVICE_COSQ_FQ_MASK) {
        is_fq = TRUE;
        resource_count++;
    }
    if (flags & DPP_DEVICE_COSQ_HR_MASK) {
        is_hr = TRUE;
        resource_count++;
    }
    if ((resource_count == 2) && (is_cl == TRUE) && (is_fq == TRUE)) {
        is_cl_fq = TRUE;
        resource_count--; /* consider it one resource of a cl_fq type */
    }
    else if ((resource_count == 2) && (is_cl == TRUE) && (is_hr == TRUE)) {
        is_cl_hr = TRUE;
        resource_count--; /* consider it one resource of a cl_hr type */
    }

    if (resource_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid resource flags 0x%x - only one resource can be allocated, number resources specified %d"), unit, flags, resource_count));
    }
                 
    is_composite = (relevant_flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;
    shaper_mask = relevant_flags & DPP_DEVICE_COSQ_DUAL_SHAPER_MASK;
    if (shaper_mask) {
        switch (shaper_mask) {
            case BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER:
                is_dual = TRUE;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Shaper flags 0x%x\n"), unit, shaper_mask));
                break;
        }
    }

    if ( (is_dual) && (is_cl == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, dual Shaper configuration requires specifing a CL scheduler element\n"), unit));
    }

    /* if cl and fq were both specified make sure that dual shaper is specified */
    if ( (is_cl_fq) && (is_dual == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, specifing both CL and FQ scheduling element also requires specifing dual Shaper configuration\n"), unit));
    }

    /* if cl and hr were both specified make sure that dual shaper is specified */
    /* In order to support {cl, hr} configuration it is necessary to specify    */
    /* {sched, cl, hr, dual} flags. This s unlike {cl, fq} configuration where  */
    /* {fq} flag need not be specified. Thus fq is assumed to be default mode   */
    /* for dual configuration and fq scheduler does not require any additional  */
    /* qualifier.                                                               */
    if ( (is_cl_hr) && (is_dual == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, specifing both CL and HR scheduling element also requires specifing dual Shaper configuration\n"), unit));
    }

    if ( (is_composite == TRUE) && (is_dual == TRUE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, composite and dual Shaper configuration cannot be specified at same time\n"), unit));
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        if (!(BCM_GPORT_IS_SCHEDULER(*gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport (0x%x) corresponding to _WITH_ID flags specified \n"), unit, (*gport)));
        }

    }
    /* Verify numq for other scheduler elements other than HRs */
    if ((is_cl_fq) || (is_cl) || (is_fq) || (is_cl_hr)) {
        if (numq != 1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d\n"), unit, flags));
        }
    }

    if ((is_cl_fq) || (is_cl) || (is_cl_hr)) {
        rc = _bcm_petra_cosq_sched_cl_add(unit, port, numq, flags, gport, is_composite, is_dual, is_cl_hr);
    }
    else if (is_fq) {
        rc = _bcm_petra_cosq_sched_fq_add(unit, port, numq, flags, gport, is_composite, is_dual);
    }
    else if (is_hr) {
        rc = _bcm_petra_cosq_sched_hr_add(unit, port, numq, flags, gport, is_composite, is_dual);
    }
    else {
        rc = BCM_E_PARAM;
    }

    if (rc != BCM_E_NONE) {
        goto err;
    }

    /* allocate resource for flow */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, (*gport), &alternate_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    if (BCM_GPORT_IS_SCHEDULER(alternate_gport)) {
        flow_id = BCM_GPORT_SCHEDULER_GET(alternate_gport);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(alternate_gport) ||
             (BCM_COSQ_GPORT_IS_E2E_PORT_TC(alternate_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable)) {

        /* numq determine cosq index.
         * In case of E2E gport - numq = 1 (Petra-B compatbility) => cosq = 0.
         * In case of Port TC: cosq = numq 
         */
        cosq = (BCM_COSQ_GPORT_IS_E2E_PORT(alternate_gport)) ? DPP_COSQ_PB_DEFAULT_PORT_TC:numq;

        rc = _bcm_petra_cosq_fap_port_get(unit, alternate_gport, &fap_port, &core);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), alternate_gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* verify priority */
        if (BCM_COSQ_GPORT_IS_PORT_TC(alternate_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            rc = _bcm_petra_cosq_port_priority_validate(unit,alternate_gport,cosq);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "verify failed for gport: 0x%x, cosq %d error(0x%x)\n"), alternate_gport, cosq, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
       
        rc = _bcm_petra_cosq_port2se_id(unit,fap_port,cosq,&se_id);
        if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retreive SE for port %d"), unit, fap_port));
        }

        flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
    }

    se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,( flow_id)));
    if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, flow_id));
    }

    rc = _bcm_petra_cosq_is_se_reserved(unit,se_index,&is_reserved);
    if (rc != BCM_E_NONE){
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "failed to get reserved se: 0x%x, error(0x%x)\n"), se_index, rc));
         goto err;
    }

    if (!(flags & BCM_COSQ_GPORT_REPLACE ) || (!is_reserved)) { /* Allocate SW DB in case of REPLACE is unset (allocate new SE) or SE is not a reserved SE. */
        /* allocate and initialize SE state */
        

        se_state_config = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_alloc(unit,
                                                             &(cosq_config->se_hd), se_index);
        if (se_state_config == NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) se(%d) internal state allocation error\n"), unit, se_index));
            rc = BCM_E_RESOURCE;
            goto err;
        }

        se_state_config->ref_cnt = DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE;


        /* need to take care of dual shaper allocation case */
        if (is_dual) {
            rc = _bcm_petra_se_dual_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &dual_flow_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, cl se failure in getting dual flow(%d), error 0x%x\n"), unit, flow_id, rc));
                goto err;
            }


            dual_se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,( dual_flow_id)));
            if (dual_se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, dual_flow_id));
            }


            dual_se_state_config = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_alloc(unit,
                                                             &(cosq_config->se_hd), dual_se_index);
            if (dual_se_state_config == NULL) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Unit(%d) se(%d) internal state allocation error\n"), unit, dual_se_index));
                rc = BCM_E_RESOURCE;
                goto err;
            }

            dual_se_state_config->ref_cnt = DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE;
        }

        /* allocate and initialize coresponding flow state */
        flow_state_config[0] = (bcm_dpp_cosq_flow_config_t *)_bcm_petra_cosq_element_alloc(unit,
                                                     &(_dpp_cosq_config[unit].flow_hd), flow_id);
        
        if (flow_state_config[0] ==  NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, flow_id));
            rc = BCM_E_RESOURCE;
            goto err;
        }
        flow_state_config[0]->weight = 0;
        flow_state_config[0]->mode = BCM_COSQ_SP0;


        /* allocate resource for sub-flow 2 */
        if ( (is_composite) || (is_dual) ) {
            if (is_composite) {
                rc = _bcm_petra_se_composite_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            }
            if (is_dual) {
                rc = _bcm_petra_se_dual_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            }


            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Unit(%d) failed to get sub-flow 2 for flow_id(%d)\n"), unit, sf2_id));
                goto err;
            }

            flow_state_config[1] = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                                     &(_dpp_cosq_config[unit].flow_hd), sf2_id);
            if (flow_state_config[1] ==  NULL) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, sf2_id));
               rc = BCM_E_RESOURCE;
               goto err;
            }
            flow_state_config[1]->weight = 0;
            flow_state_config[1]->mode = BCM_COSQ_SP0;
        }
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_se_all_state(unit, se_index, is_composite, is_dual);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed update of seId(%d), error 0x%x\n"), unit, se_index, rc));
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_connector_gport_add(int unit,
                                    bcm_gport_t port,
                                    int numq,
                                    uint32 flags,
                                    bcm_gport_t *gport)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    uint32 relevant_flags;
    int is_non_contiguous;
    int is_composite;
    int flow_id = -1;
    int res_flags = 0;
    int cur_flow_id, cur_connector, cur_comp_flow_id;    
    SOC_TMC_SCH_FLOW flow_config, exact_flow_config;
    bcm_dpp_cosq_config_t *cosq_config;
    bcm_dpp_cosq_connector_config_t *connector_config = NULL;
    bcm_dpp_cosq_flow_config_t *flow_state_config = NULL;
    bcm_gport_t ingr_port;
    uint8 src_modid;

    BCMDNX_INIT_FUNC_DEFS;
    /* basic consistency checks */
    relevant_flags = flags & (BCM_COSQ_GPORT_VOQ_CONNECTOR | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    if ((numq < 0) || (numq > DPP_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
    }
    if ((numq % DPP_DEVICE_COSQ_COS_ALLOC_SZ) != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, number cos levels (%d) should be multiplier of %d"), unit, numq, DPP_DEVICE_COSQ_COS_ALLOC_SZ));
    }

    is_non_contiguous = (relevant_flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
    is_composite = (relevant_flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= SHR_RES_ALLOC_WITH_ID;

        if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR((*gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport (0x%x) corresponding to _WITH_ID flags specified "), unit, (*gport)));
        }

        flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET((*gport));

        rc = _bcm_petra_cosq_validate_connector_id(unit, is_non_contiguous, is_composite, numq, flow_id);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid connector id %d"), unit, flow_id));
        }
    }

    /* Get modid of source */
    if (BCM_GPORT_IS_SYSTEM_PORT(port)) {
        rc = bcm_petra_stk_sysport_gport_get(unit, port, &ingr_port);
        
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped, gport add for connector cannot be performed"), unit, port));
        }
        /* get system port to mod/port mapping */
        src_modid = BCM_GPORT_MODPORT_MODID_GET(ingr_port);
    } else if (BCM_GPORT_IS_MODPORT(port)) {
        src_modid = BCM_GPORT_MODPORT_MODID_GET(port);
    } else if (BCM_GPORT_IS_LOCAL(port)) {
        int modid;
        /* Get my modid since it is local */
        rc = bcm_petra_stk_my_modid_get(unit, &modid);
        src_modid = (uint8)modid;
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("my modid wasnt set correctly")));
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) ingress port parameter not initialized"), unit));
    }

    
    /* allocate resource */
    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, &src_modid, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, connector resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }    

    cosq_config = &_dpp_cosq_config[unit];

    /* configure resources */
    for (cur_connector = 0, cur_flow_id = flow_id; cur_connector < numq; cur_connector++) {
        _bcm_petra_flow_id_get(unit, flow_id, cur_connector, is_non_contiguous, is_composite, FALSE, &cur_flow_id);

        SOC_TMC_SCH_FLOW_clear(&flow_config);
        SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

        flow_config.flow_type = SOC_TMC_FLOW_SIMPLE;
        flow_config.is_slow_enabled = FALSE;

        flow_config.sub_flow[0].is_valid = TRUE;
        flow_config.sub_flow[0].id = cur_flow_id;

        flow_config.sub_flow[0].credit_source.se_type = cosq_config->default_se_type;
        flow_config.sub_flow[0].credit_source.id = cosq_config->default_se;

        if (is_composite) {
            rc = _bcm_petra_composite_flow_id_get(unit, flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
           
            flow_config.sub_flow[1].id = cur_comp_flow_id;
            flow_config.sub_flow[1].is_valid = TRUE;

            flow_config.sub_flow[1].credit_source.se_type = cosq_config->default_se_type;
            flow_config.sub_flow[1].credit_source.id = cosq_config->default_se;
        }
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, cur_flow_id, &flow_config, &exact_flow_config)));

        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, cur_flow_id, soc_sand_rc, rc));
            goto err;
        }

        /* consistency check */
        if (flow_config.sub_flow[0].id != exact_flow_config.sub_flow[0].id) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, requested flow id %d does not match the configured flow id %d\n"), unit, flow_config.sub_flow[0].id, exact_flow_config.sub_flow[0].id));
            rc = BCM_E_INTERNAL; 
            goto err;
        }

        /* allocate data structure for flow */
        flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                                 &(_dpp_cosq_config[unit].flow_hd), cur_flow_id);
        if (flow_state_config == NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, cur_flow_id));
            rc = BCM_E_RESOURCE;
            goto err;
        }
        flow_state_config->weight = 0;
        flow_state_config->mode = BCM_COSQ_SP0;
  

        if (is_composite) {
            flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                  &(_dpp_cosq_config[unit].flow_hd), cur_comp_flow_id);
            if (flow_state_config == NULL) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, cur_flow_id));
                rc = BCM_E_RESOURCE;
                goto err;
            }
            flow_state_config->weight = 0;
          flow_state_config->mode = BCM_COSQ_SP0;
        }
    }

    /* data structure for connector group */
    connector_config = (bcm_dpp_cosq_connector_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                              &(_dpp_cosq_config[unit].connector_hd), flow_id);
    if (connector_config == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, flow_id));
        rc = BCM_E_RESOURCE;
        goto err;
    }
    /*
     * Note that 'flags' element is set to 'all zero' at _bcm_petra_cosq_element_alloc()
     * above.
     */
    connector_config->num_cos = numq;
#ifdef BCM_DPP_COSQ_CONN_NO_MODID_OPTIMIZATION
    connector_config->src_modid = src_modid;
#endif /* BCM_DPP_COSQ_CONN_NO_MODID_OPTIMIZATION */

    /* update persistent storage */
#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_conn_all_state(unit, flow_id, is_non_contiguous, is_composite, src_modid);
    if (rc != BCM_E_NONE) {
        goto err;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /* update handle */
    BCM_COSQ_GPORT_VOQ_CONNECTOR_SET((*gport), flow_id);

   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "  DBG, Connector Gport(%d:0x%x)\n"), (*gport), (*gport)));


    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:

    
    if (flow_id != -1) {
        bcm_dpp_am_cosq_scheduler_deallocate(unit, res_flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, flow_id);

        if (connector_config != NULL) {

          _bcm_petra_cosq_element_free(unit,
                                       &(_dpp_cosq_config[unit].connector_hd),
                                       flow_id);

#ifdef BCM_WARM_BOOT_SUPPORT
            rc = _bcm_dpp_wb_cosq_update_conn_all_state(unit, flow_id, is_non_contiguous, is_composite, src_modid);
            if (rc != BCM_E_NONE) {
                ;
            }
#endif /* BCM_WARM_BOOT_SUPPORT */
        }

        if (flow_state_config != NULL) {
            for (cur_connector = 0, cur_flow_id = flow_id; cur_connector < numq; cur_connector++) {
                _bcm_petra_flow_id_get(unit, flow_id, cur_connector, is_non_contiguous, is_composite,FALSE, &cur_flow_id);
                _bcm_petra_cosq_element_free(unit,
                                             &(_dpp_cosq_config[unit].connector_hd),
                                             cur_flow_id);
                if (is_composite) {
                    rc = _bcm_petra_composite_flow_id_get(unit, flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
                    BCMDNX_IF_ERR_EXIT(rc);
                    _bcm_petra_cosq_element_free(unit,
                                             &(_dpp_cosq_config[unit].connector_hd),
                                             cur_comp_flow_id);
                }
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int 
bcm_petra_cosq_ingress_queue_bundle_gport_add(int unit, 
                                              bcm_cosq_ingress_queue_bundle_gport_config_t *config, 
                                              bcm_gport_t *gport)
{

    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

    if (config == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Null config pointer")));
    }
    if (config->flags & BCM_COSQ_GPORT_UCAST_QUEUE_GROUP || config->flags & BCM_COSQ_GPORT_ISQ) {
        rc = _bcm_petra_cosq_ucast_gport_add(unit,config,gport);
        BCMDNX_IF_ERR_EXIT(rc);
    } else if (config->flags & BCM_COSQ_GPORT_MCAST_QUEUE_GROUP) {
        rc = _bcm_petra_cosq_mcast_gport_add(unit,config,gport);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Ingress queues add bundle not support for flags(0x%x)"), unit, config->flags));
    }
exit:
    BCMDNX_FUNC_RETURN;
    
}
/*
 * Get the system port destination according to different destination types, 
 * If the destination is in a different TM domain in a stacking configuration than stk_exist == 1, and base queue should be mapped to it. 
 */ 
STATIC int
_bcm_petra_cosq_ingress_queue_get_sysport_destination(
   int unit, 
   int core,
   uint8 is_ucast,
   uint8 is_flow,
   bcm_gport_t port, 
   int *sysport,
   int *stk_exist)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_gport_t sysport_gport = 0xffffffff; /* Assigning all 1s, in case we accidently access it without assigning real value */
    bcm_gport_t port_gport;
    int         tmp_port;
    int         dummy_tc;
    int         flow_id,se_id;
    BCMDNX_INIT_FUNC_DEFS;

   /* When recieve ISQ Class HR , return port accordingly */
    if (is_ucast)
    {
        if (BCM_COSQ_GPORT_IS_ISQ_ROOT(port)) {
           rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit,port,&port_gport);
           if (rc != BCM_E_NONE) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }
           if ( !(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport)) ) {
               BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }

           if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
                tmp_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);            
           } else {
                flow_id = BCM_GPORT_SCHEDULER_GET(port_gport);
                se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));
                if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                    rc = BCM_E_PARAM;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                rc = _bcm_petra_cosq_se_id2port(unit,se_id, &tmp_port, &dummy_tc);                       
                if (rc != BCM_E_NONE || tmp_port == DPP_COSQ_SCH_PORT_ID_INVALID(unit)) {
                    rc = BCM_E_PARAM;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid se 0x%x specified - does not correspond to port\n"), unit, se_id));
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
           BCM_GPORT_LOCAL_SET(port,tmp_port);
        }
    }
    else /*(!is_ucast)*/
    {
        /* When recieve FMQ Class HR , return port accordingly */
        if (BCM_COSQ_GPORT_IS_FMQ_CLASS(port)) {
           rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit,port,&port_gport);
           if (rc != BCM_E_NONE) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }
           if ( !(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport)) ) {
               BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }

           if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
                tmp_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);            
           } else {
                flow_id = BCM_GPORT_SCHEDULER_GET(port_gport);
                se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));
                if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                    rc = BCM_E_PARAM;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                rc = _bcm_petra_cosq_se_id2port(unit,se_id, &tmp_port, &dummy_tc);                       
                if (rc != BCM_E_NONE || tmp_port == DPP_COSQ_SCH_PORT_ID_INVALID(unit)) {
                    rc = BCM_E_PARAM;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid se 0x%x specified - does not correspond to port\n"), unit, se_id));
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
           BCM_GPORT_LOCAL_SET(port,tmp_port);
        }    
    }
    /* Retreive system port from port */
    if (BCM_GPORT_IS_SYSTEM_PORT(port)) {
        sysport_gport = port;
    } else {
        rc = bcm_petra_stk_gport_sysport_get(unit, port, &sysport_gport); /* get system port from gport */
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped, gport add for unicast queue group cannot be performed"), unit, port));
        }
    }    
    /* get system port to mod/port mapping */
    *sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(sysport_gport);
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add gport (0x%08x) dest sysport(%d)\n"), unit, port, *sysport));
    /* Handle stacking sysport, removed: || (BCM_COSQ_GPORT_WITH_ID & flags) */
    if (!(is_flow) && is_ucast) {
        rc = _bcm_petra_cosq_stk_sysport_set(unit, core, sysport_gport, stk_exist);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("Unit(%d) sysport(0x%08x) Fail to handle Stacking (%d)"), unit, *sysport, rc));
        }
    } else {
        *stk_exist = 0;
    }
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_ARAD_SUPPORT
/* 
 * This function is used updates the rate classes ref_count, and tail drop reservation.
 * The input struct bcm_dpp_cosq_queue_attributes_verify_t is used too:
 * 1. Update the reference count for rate classes.
 * 2. Updating tail drop reservation. 
 * 3. Update delay tolerence level ref count in case of deletion. 
 */
STATIC int
_bcm_petra_cosq_ingress_queue_bundle_ref_count_update(
   int unit,
   uint8 is_add,
   bcm_dpp_cosq_queue_attributes_verify_t *queue_attributes_verify)
{
    uint32    
        ref_count;
    uint8 
        queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int 
        index, 
        is_allocated;
    bcm_dpp_cosq_ingress_rate_class_info_t 
        data_rate_cls;
    SOC_TMC_ITM_QT_NDX
        user_q_type;
    int
        hw_q_type;
    BCMDNX_INIT_FUNC_DEFS;
    /*Update delay tolerence level in case of deletion*/
    if (SOC_IS_JERICHO(unit)) {
        if (!is_add) {
            for (index = 0; index < queue_attributes_verify->nof_delay_tolerance; index++) {
                BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, queue_attributes_verify->queue_attributes[index].delay_tolerance_level, &user_q_type));
                DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);
                BCM_SAND_IF_ERR_EXIT(arad_sw_db_queue_type_ref_count_get(unit, hw_q_type, &ref_count));
                ref_count += queue_attributes_verify->delay_tolerance_nof_additions[index];
                BCM_SAND_IF_ERR_EXIT(arad_sw_db_queue_type_ref_count_set(unit, hw_q_type, ref_count));
            }
        }
    }
    /*Update rate class mapping*/
    BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_get(unit, &queue_to_rate_class_mapping_is_simple));
    for (index = 0; index < queue_attributes_verify->nof_rate_class; index++) {
        if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED || 
            queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED) {
            BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_get(unit, queue_attributes_verify->queue_attributes[index].rate_class, &ref_count));
            ref_count += queue_attributes_verify->rate_class_nof_additions[index];
            BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_set(unit, queue_attributes_verify->queue_attributes[index].rate_class, ref_count));
        } else {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_queue_rate_cls_tdata_get(unit, 
                                                                             queue_attributes_verify->queue_attributes[index].rate_class,
                                                                             &data_rate_cls));
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_queue_rate_cls_allocate_group(unit, 
                                                                                  SHR_TEMPLATE_MANAGE_SET_WITH_ID, 
                                                                                  &data_rate_cls, 
                                                                                  queue_attributes_verify->rate_class_nof_additions[index],
                                                                                  &is_allocated, 
                                                                                  (int*)&(queue_attributes_verify->queue_attributes[index].rate_class)));
        }
    }
    /* update tail drop reservation */
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, queue_attributes_verify->reservation_change))); 
    
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * This function is used for:
 * 1. Verifing that a created/deleted queue bundle's attribues are valid. 
 * 1.1. Credit request profiles and rate classes are in valid range. 
 * 1.2. Filling an struct to be used for updating the ref count for each queue in the bundle.
 * 1.2. Updating the reference count for both of them will not result out of range values. 
 * 2. Filling an struct to be used for updating the ref count for each queue in the bundle.
 * 3. Calculation and verifying the validity of tail drop reservation update.
 */
int 
_bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(
   int unit, 
   int base_queue,
   uint8 is_add,
   bcm_cosq_ingress_queue_bundle_gport_config_t *config,
   bcm_gport_t *gport,
   bcm_dpp_cosq_queue_attributes_verify_t *queue_attributes_verify)
{
    bcm_error_t rc = BCM_E_NONE;
    int         nof_rate_class = 0;
    int         rate_class = 0;
    int         rate_class_nof_additions = 0;
    uint32      rate_class_nof_additions_mapping[SOC_TMC_ITM_NOF_RATE_CLASSES];

    int         nof_credit_request_profile = 0;
    int         credit_request_profile = 0;
    int         credit_request_profile_nof_additions = 0;
    uint32      credit_request_profile_nof_additions_mapping[SOC_DPP_DEFS_MAX(NOF_CREDIT_REQUEST_PROFILES)];

    int         cosq = 0;
    int         numq;
    uint32      ref_count;
    uint8       queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;

    int         addition = is_add ? 1 : -1;
    int         core = BCM_CORE_ALL;

    SOC_TMC_ITM_QT_NDX user_q_type;
    int hw_q_type;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info_dummy;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info_sum;
    int32 reservation_change;
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(queue_attributes_verify, 0, sizeof(bcm_dpp_cosq_queue_attributes_verify_t));

    sal_memset(&rate_class_nof_additions_mapping, 0xff, sizeof(rate_class_nof_additions_mapping));
    sal_memset(&credit_request_profile_nof_additions_mapping, 0xff, sizeof(credit_request_profile_nof_additions_mapping));

    sal_memset(&rate_class_info_dummy, 0, sizeof(rate_class_info_dummy));
    sal_memset(&rate_class_info, 0, sizeof(rate_class_info));
    sal_memset(&rate_class_info_sum, 0, sizeof(rate_class_info_sum));
    
    numq = config->numq;
    /*verify credit request profiles*/
    if (!is_add) {
        for (cosq = 0; cosq < config->numq; cosq++){
            int weight;
            rc = _bcm_petra_cosq_gport_ucast_queue_sched_get(unit, *gport, cosq, &(config->queue_atrributes[cosq].delay_tolerance_level) ,&weight);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    for (credit_request_profile = config->queue_atrributes[0].delay_tolerance_level, nof_credit_request_profile = 0, cosq = 0;
         cosq <= numq;
         cosq++, credit_request_profile_nof_additions += addition) {
        if (cosq != numq && credit_request_profile == config->queue_atrributes[cosq].delay_tolerance_level) {
            continue;
        }
        /*Verify the delay tolerance level validity*/
        if (!((credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_15) ||
              (credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
              (credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_16 && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_23))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The delay tolerance level %d is not legal."),unit, credit_request_profile)); 
        }
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, credit_request_profile, &user_q_type));
        DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

        /*Verify the HW q type translated form the delay tolerance level*/
        if (!(0 <= hw_q_type && hw_q_type < SOC_DPP_DEFS_GET(unit, nof_credit_request_profiles))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The credit request profile %d is not legal."),unit, credit_request_profile)); 
        }
        /* 
         * If we didn't see this profile before (credit_request_profile_nof_additions_mapping[credit_request_profile] == 0xffffffff) 
         * Then update the credit_request_profile_nof_additions_mapping array and increas the nof_credit_request_profile counter.
         */
        if (credit_request_profile_nof_additions_mapping[hw_q_type] == 0xffffffff) {
            credit_request_profile_nof_additions_mapping[hw_q_type] = nof_credit_request_profile;
            queue_attributes_verify->queue_attributes[credit_request_profile_nof_additions_mapping[hw_q_type]].delay_tolerance_level = credit_request_profile;
            nof_credit_request_profile++;
        }
        queue_attributes_verify->delay_tolerance_nof_additions[credit_request_profile_nof_additions_mapping[hw_q_type]] += credit_request_profile_nof_additions;
        credit_request_profile_nof_additions = 0;
        credit_request_profile = config->queue_atrributes[cosq].delay_tolerance_level;
    }
    queue_attributes_verify->nof_delay_tolerance = nof_credit_request_profile;

    /*if jericho verify that the expected ref count is legel.*/
    if (SOC_IS_JERICHO(unit)) {
        for (cosq = 0; cosq < queue_attributes_verify->nof_rate_class; cosq++) {
            credit_request_profile = queue_attributes_verify->queue_attributes[cosq].delay_tolerance_level;
            credit_request_profile_nof_additions = queue_attributes_verify->delay_tolerance_nof_additions[cosq];

            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, credit_request_profile, &user_q_type));
            DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

            BCM_SAND_IF_ERR_EXIT(arad_sw_db_queue_type_ref_count_get(unit, hw_q_type, &ref_count));
            ref_count += credit_request_profile_nof_additions;
            if (ref_count > SOC_DPP_DEFS_GET(unit, nof_queues))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the credit request profile %d, the ref_count %d is out of range."),unit, credit_request_profile, ref_count));
            }
        }
    }

    /*verify rate classes*/
    BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_is_simple_get(unit, &queue_to_rate_class_mapping_is_simple));
    if (!is_add) {
        for (cosq = 0; cosq < config->numq; cosq++){
             rc = _bcm_petra_cosq_voq_class_mapping_get(unit, core, base_queue + cosq, BCM_DPP_COSQ_RATE_CLS, &(config->queue_atrributes[cosq].rate_class));
             BCMDNX_IF_ERR_EXIT(rc);
        }
    } 
    for (rate_class = config->queue_atrributes[0].rate_class, nof_rate_class = 0, cosq = 0;
         cosq <= numq;
         cosq++, rate_class_nof_additions += addition) {
        if (cosq != numq && rate_class == config->queue_atrributes[cosq].rate_class) {
            continue;
        }
        /* 
         * If we didn't see this rate class before (rate_class_nof_additions_mapping[rate_class] == 0xffffffff) 
         * Then update the rate_class_nof_additions_mapping array and increas the nof_rate_class counter.
         */
        if (rate_class_nof_additions_mapping[rate_class] == 0xffffffff) {
            rate_class_nof_additions_mapping[rate_class] = nof_rate_class;
            queue_attributes_verify->queue_attributes[rate_class_nof_additions_mapping[rate_class]].rate_class = rate_class;
            nof_rate_class++;
        }
        queue_attributes_verify->rate_class_nof_additions[rate_class_nof_additions_mapping[rate_class]] += rate_class_nof_additions;
        rate_class_nof_additions = 0;
        rate_class = config->queue_atrributes[cosq].rate_class;
    }
    queue_attributes_verify->nof_rate_class = nof_rate_class;

    /*verify rate class attributes*/
    for (cosq = 0; cosq < queue_attributes_verify->nof_rate_class; cosq++)
    {
        rate_class = queue_attributes_verify->queue_attributes[cosq].rate_class;
        if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
        }

        rate_class_nof_additions = queue_attributes_verify->rate_class_nof_additions[cosq];
        if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED) 
        {
            BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_get(unit, rate_class, &ref_count));
            ref_count += rate_class_nof_additions;
            if (ref_count > SOC_DPP_DEFS_GET(unit, nof_queues))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the rate class %d, the ref_count %d is out of range."),unit, rate_class, ref_count));
            }           
            rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);

        } 
        else if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE)
        {
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_queue_rate_cls_ref_get(unit, rate_class, &ref_count));
            if (is_add && ref_count==0) {
                /*return error: we cannot allcoate new rate class on creation of a queue*/
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot create a queue mapped to rate class %d, since it is not configured."),unit, rate_class)); 
            }
            ref_count += rate_class_nof_additions;
            if (ref_count > SOC_DPP_DEFS_GET(unit, nof_queues))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the rate class %d, the ref_count %d is out of range."),unit, rate_class, ref_count));
            }           
            rc = _bcm_dpp_am_template_queue_rate_cls_tdata_get(unit, rate_class, &rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);
        } 
        else if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED) 
        {
            BCM_SAND_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_get(unit, rate_class, &ref_count));
            ref_count += rate_class_nof_additions;
            if (ref_count > SOC_DPP_DEFS_GET(unit, nof_queues))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the rate class %d, the ref_count %d is out of range."),unit, rate_class, ref_count));
            }
            if (is_add && rate_class != 0) 
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("unit %d, Cannot create a queue mapped to a rate class %d != 0, when the queue-to-rate class made is undefined."), unit, rate_class)); 
            }
            rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        rate_class_info_sum.queue_min_size += rate_class_nof_additions * rate_class_info.queue_min_size;
        rate_class_info_sum.queue_min_size_bds += rate_class_nof_additions * rate_class_info.queue_min_size_bds;
    }
    /*Validate that expected tail drop configuration is legal, and get the expected tail drop reservation change */
    rc = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, &rate_class_info_dummy, &rate_class_info_sum, 1, &reservation_change);
    BCMDNX_IF_ERR_EXIT(rc);

    queue_attributes_verify->reservation_change = reservation_change;

exit:
    BCMDNX_FUNC_RETURN;
}
#endif /*BCM_ARAD_SUPPORT*/

STATIC int
_bcm_petra_cosq_mcast_gport_add(int unit,
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport)
{
    bcm_gport_t port;
    int         numq;
    int         cosq;
    uint32      flags;
    bcm_error_t rc = BCM_E_NONE;
    int         is_non_contiguous = FALSE;    
    int         base_fmq = 0, fmq = 0, start_fmq = 0, end_fmq;
    int         alloc_flags = 0;
    int         is_composite = FALSE;
    int         base_flow_id = DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START;
    int         sysport = 0;
    int         mcast_sched_mode = 0;

    uint32 relevant_flags, soc_sand_rc;
    bcm_dpp_cosq_voq_config_t* voq_config = NULL;
    int flow_quartet;
    int flow_id = 0;
    int core = BCM_CORE_ALL, core_index;
    int stk_exist;
#ifdef BCM_ARAD_SUPPORT
    SOC_TMC_ITM_QUEUE_INFO queue_info;
    bcm_dpp_cosq_queue_attributes_verify_t queue_attributes_verify;
#endif /*BCM_ARAD_SUPPORT*/


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_NULL_CHECK(gport);
    BCMDNX_NULL_CHECK(config);
    port = config->port;
    numq = config->numq; 
    flags = config->flags;

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        /*validate rate class mapping params */
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(
           unit, 
           0, /*relevant for deletion only*/
           TRUE, /*is add*/
           config, 
           gport, 
           &queue_attributes_verify));
    }

#endif /*BCM_ARAD_SUPPORT*/
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add multicast queue gport(0x%08x) numq(%d)\n"), unit, port, numq));
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "flags(0x%08x)\n"), flags));

    if (BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR & flags) {
        is_non_contiguous = TRUE;
    }

    if (BCM_COSQ_GPORT_COMPOSITE & flags) {
        is_composite = TRUE;
    }

    /* basic consistency checks */
    relevant_flags = flags & (BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID | BCM_COSQ_GPORT_MCAST_QUEUE_GROUP 
                              | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    if ((numq < 0) || (numq > DPP_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
    }
    if (BCM_COSQ_GPORT_WITH_ID & flags) {
        base_fmq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(*gport);
       
        rc = bcm_petra_fabric_control_get(unit,bcmFabricMulticastQueueMin,&start_fmq);
        BCMDNX_IF_ERR_EXIT(rc);
        
        rc = bcm_petra_fabric_control_get(unit,bcmFabricMulticastQueueMax,&end_fmq);
        BCMDNX_IF_ERR_EXIT(rc);

        if (base_fmq > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q %d with_id failed, queue out of range "), unit, base_fmq));
        }

        if (base_fmq < start_fmq || base_fmq > end_fmq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q %d with_id failed, queue out of range of multicast fabric queues "), unit, base_fmq));
        }

        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(*gport);
        alloc_flags |= SHR_RES_ALLOC_WITH_ID;
    } else {
       BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit(%d) add mc q gport(0x%08x) not supported without with_id"), unit, base_fmq));
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add gport (0x%08x) dest sysport(%d)\n"), unit, port, sysport));
    rc = _bcm_petra_cosq_ingress_queue_get_sysport_destination(unit, 
                                                               core,
                                                               FALSE,/*is_ucast*/
                                                               FALSE,/*is_flow*/
                                                               port,
                                                               &sysport, 
                                                               &stk_exist);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = bcm_petra_fabric_multicast_scheduler_mode_get(unit, &mcast_sched_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Only 4 multicast queues allocated if we are in mode 0 - these are not managed by alloc_mngr.c *
     * so we do not want to allocate them here.  If in mode 1 4k queues are available so allocate.   *
     */
    if (mcast_sched_mode == 0) {
        if ((BCM_COSQ_GPORT_WITH_ID & flags) && (base_fmq != 0)) {
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, mode incompatible with base FMQ(%d) !=0\n"), unit, base_fmq));
            BCMDNX_IF_ERR_EXIT(rc);
        } else {
            base_fmq = 0;
        }
    } else {
        /* call queue allocation wrapper function which    */
        /* calls lower level function - if with_id is set, */
        /* the user has alloc-ed, pass this flag also      */
        if (core == BCM_CORE_ALL && !SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit) && !(SHR_RES_ALLOC_WITH_ID & alloc_flags)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) Cannot allocate ingress queue without ID in asymmetric mode."), unit));
        }
        
        rc = bcm_dpp_am_ingress_voq_allocate(unit,
                                             core,
                                             alloc_flags,
                                             is_non_contiguous,
                                             numq,
                                             DPP_DEVICE_COSQ_QUEUE_REGION_MULTICAST,
                                             &base_fmq);
        
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) gport add fmq group not available (%d)"), unit, port, rc));
        }
    }
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index){
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                                                               &(_dpp_cosq_config[unit].voq_hd),
                                                                               DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_fmq));       
        if (voq_config ==  NULL) {           
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) voq(%d) gport add voq group internal state allocation error\n"),
                                  unit, base_fmq));
            
            rc = BCM_E_RESOURCE;
            goto err;
        }
        voq_config->num_cos = numq;
    }

    for (flow_quartet = 0, fmq = base_fmq; 
         fmq < (base_fmq + numq);
         flow_quartet++, fmq+=DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        SOC_TMC_IPQ_QUARTET_MAP_INFO queue2flow;

        SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

        _bcm_petra_flow_id_get(unit,
                               base_flow_id, 
                               (fmq - base_fmq) /* cos */,
                               is_non_contiguous,
                               is_composite,
                               FALSE /*is_remove*/,
                               &flow_id);

        queue2flow.flow_quartet_index = SOC_TMC_SCH_FLOW_TO_QRTT_ID(flow_id);
        queue2flow.is_composite = is_composite;
        queue2flow.system_physical_port = sysport;
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_set,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(fmq), &queue2flow)));
        
        rc = handle_sand_result(soc_sand_rc);

        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "soc_petra_ipq_queue_to_flow_mapping_set() failed queue(%d) sysport(%u)\n"), fmq, sysport));
        }

        /* Rotate between using default flow ids which are reserved */
        flow_id++;
    }

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        /*Set Queue profiles - credit request profile and rate class acording to config info*/
        for (cosq = 0; cosq < numq; cosq++) {
            SOC_TMC_ITM_QUEUE_INFO_clear(&queue_info);
            /* retrieve current configuration */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, base_fmq + cosq, &queue_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            /* update configuration */
            /*Map each queue offset to relevant rate class*/
            queue_info.rate_cls = config->queue_atrributes[cosq].rate_class;

            /*Map each queue offset to relevant crefit request profile*/
            rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, config->queue_atrributes[cosq].delay_tolerance_level, &(queue_info.cr_req_type_ndx));
            BCMDNX_IF_ERR_EXIT(rc);  

            queue_info.old_cr_req_type_ndx = SOC_TMC_ITM_QT_NDX_INVALID;
               
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_set,(unit, core, base_fmq + cosq, &queue_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        }
        /*Update SW state for rate class mapping*/
        rc = _bcm_petra_cosq_ingress_queue_bundle_ref_count_update(unit, TRUE, &queue_attributes_verify);
        BCMDNX_IF_ERR_EXIT(rc);  
    }
#endif /*BCM_ARAD_SUPPORT*/


#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_voq_state(unit, core, base_fmq);
    if (rc != BCM_E_NONE) {
        goto err;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCM_GPORT_MCAST_QUEUE_GROUP_SET(*gport, base_fmq);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (base_fmq != -1) {
        int rc_free = BCM_E_NONE;
        rc_free = bcm_dpp_am_ingress_voq_deallocate(unit,
                                                    core,
                                                    alloc_flags,
                                                    is_non_contiguous,
                                                    numq,
                                                    base_fmq);
        /* We will vliadate rc after freeing list*/
        BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
            voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, 
                                                                                 &(_dpp_cosq_config[unit].voq_hd),
                                                                                 DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_fmq));
            if (voq_config != NULL) {
                _bcm_petra_cosq_element_free(unit, 
                                             &(_dpp_cosq_config[unit].voq_hd), 
                                             DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_fmq));
            }
        }
        BCMDNX_IF_ERR_EXIT(rc_free);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ucast_gport_add(int unit, 
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport)
{
    int         rc = BCM_E_NONE;
    bcm_gport_t port;
    int         numq;
    int         cosq;
    uint32      flags;
    int         is_non_contiguous = FALSE;
    int         is_flow = FALSE;
    int         is_composite = FALSE;
    int         is_isq = FALSE;
    int         soc_sand_rc = 0;
    int         sysport = 0;
    int         base_flow_id = DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START;
    int         flow_id, flow_quartet;
    int         base_voq = 0, voq = 0;
    int         alloc_flags = 0;
    bcm_gport_t tmp_gport = 0;
    bcm_dpp_cosq_voq_config_t *voq_config = NULL;
    unsigned    direct_mode = 0;
    int stk_exist = 0x0;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE;
#ifdef BCM_ARAD_SUPPORT
    SOC_TMC_ITM_QUEUE_INFO queue_info;
    bcm_dpp_cosq_queue_attributes_verify_t queue_attributes_verify;
#endif /*BCM_ARAD_SUPPORT*/
    BCMDNX_INIT_FUNC_DEFS;

    /*Verify unit*/
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(gport);
    numq = config->numq;
    if ((numq < 0) || (numq > DPP_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, numq));
    }
    port = config->port;
    flags = config->flags;
    tmp_gport = *gport;

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        /*validate rate class mapping params */
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(
           unit, 
           0, /*relevant for deletion only*/
           TRUE, /*is add*/
           config, 
           gport, 
           &queue_attributes_verify));
    }
#endif /*BCM_ARAD_SUPPORT*/

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add unicast queue gport(0x%08x) numq(%d)\n"), unit, port, numq));
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "flags(0x%08x)\n"), flags));    

#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit) && ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        direct_mode = 1;
    }
#endif

    if (BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR & flags) {
        is_non_contiguous = TRUE;
    }

    if (BCM_COSQ_GPORT_TM_FLOW_ID & flags) {
        is_flow = TRUE;
    }

    if (BCM_COSQ_GPORT_COMPOSITE & flags) {
        is_composite = TRUE;
    }

    if (BCM_COSQ_GPORT_ISQ & flags) {
        is_isq = TRUE;
    }
    if (BCM_COSQ_GPORT_SW_ONLY & flags) {
        if (!SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) failed, sw_only configuration not allowed%d"), unit));
        }
        is_sw_only = TRUE;
    }

    if (BCM_COSQ_GPORT_WITH_ID & flags) {
        
        if (is_isq) {
            base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(tmp_gport);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(tmp_gport);
        } else {
            base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(tmp_gport);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(tmp_gport);
        }

        if (base_voq > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, queue out of range %d"), unit, tmp_gport, base_voq));
        }
        if (core < 0 && core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores && core != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, core out of range %d"), unit, tmp_gport, core));
        }

        alloc_flags |= SHR_RES_ALLOC_WITH_ID;
    } else {
        tmp_gport = -1;
        *gport = -1;
        core = config->local_core_id;
        if (core < 0 && core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores && core != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, core out of range %d"), unit, tmp_gport, core));
        }
    }
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add uc gport(0x%08x) flags: interdig(%d) flow(%d) composite(%d)\n"), unit, port, is_non_contiguous, is_flow, is_composite));
    /* Prosses config->port to get the relvent destination sysport*/
    rc = _bcm_petra_cosq_ingress_queue_get_sysport_destination(unit, 
                                                               core,
                                                               TRUE, /*is_ucast*/
                                                               is_flow,
                                                               port, 
                                                               &sysport,
                                                               &stk_exist);
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit=%d, port=0x%x, is_flow=%d, direct_mode=%d, sysport=0x%x\n"), unit, port, is_flow, direct_mode, sysport));
    if (stk_exist == 0x1) {
        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "%s(): stk_exist=%d. exit ucas_cos_add().\n\n"), FUNCTION_NAME(), stk_exist));
        BCM_EXIT;
    }
    /* call queue allocation wrapper function which    */
    /* calls lower level function - if with_id is set, */
    /* the user has alloc-ed, pass this flag also      */
    if (core == BCM_CORE_ALL && !SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit) && !(SHR_RES_ALLOC_WITH_ID & alloc_flags)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) Cannot allocate ingress queue without ID in asymmetric mode."), unit));
    }
    rc = bcm_dpp_am_ingress_voq_allocate(unit,
                                         core,
                                         alloc_flags,
                                         is_non_contiguous,
                                         numq,
                                         (is_isq) ? DPP_DEVICE_COSQ_QUEUE_REGION_ISQ: DPP_DEVICE_COSQ_QUEUE_REGION_UNICAST,
                                         &base_voq);

    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) gport add voq group not available (%d)"), unit, base_voq, rc));
    }
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index){
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_alloc(unit, 
                                                                               &(_dpp_cosq_config[unit].voq_hd),
                                                                               DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        if (voq_config ==  NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) voq(%d) gport add voq group internal state allocation error\n"), unit, base_voq));
            rc = BCM_E_RESOURCE;
            goto err;
        }
        voq_config->num_cos = numq;
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "voq allocated(0x%08x)\n"), base_voq));

    /*VOQ to flow mapping*/
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq+=DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        SOC_TMC_IPQ_QUARTET_MAP_INFO queue2flow;
        SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

        _bcm_petra_flow_id_get(unit,
                               base_flow_id, 
                               (voq - base_voq) /* cos */,
                               is_non_contiguous,
                               is_composite,
                               FALSE /*is_remove*/,
                               &flow_id);

        queue2flow.flow_quartet_index = SOC_TMC_SCH_FLOW_TO_QRTT_ID(flow_id);
        queue2flow.is_composite = is_composite;
        queue2flow.system_physical_port = sysport;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_set,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        rc = handle_sand_result(soc_sand_rc);
        if (rc != BCM_E_NONE) {
            if (is_flow) {
                LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"soc_petra_ipq_queue_to_flow_mapping_set() failed queue(%d)\n"), voq));
            } else {
                LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"soc_petra_ipq_queue_to_flow_mapping_set() failed queue(%d) sysport(%u)\n"), voq, sysport));
            }
        }
        BCMDNX_IF_ERR_EXIT(rc);  
        /* Rotate between using default flow ids which are reserved */
        flow_id++;
    }
    /*SYSPORT to BASEQ MAPPING, SYSPORT MAPPING not required in case of FLOW based forwarding */
    if (!is_flow) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_set,
            (unit, core, sysport, TRUE /* queue is valid */,is_sw_only, base_voq)));
        rc = handle_sand_result(soc_sand_rc); /* set sysport to base queue mapping */
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "soc_petra_ipq_destination_id_packets_base_queue_id_set() failed \
                                  base queue(%d) sysport(%d)\n"), base_voq, sysport));
        }
    }

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        /*Set Queue profiles - credit request profile and rate class acording to config info*/
        for (cosq = 0; cosq < numq; cosq++) {
            SOC_TMC_ITM_QUEUE_INFO_clear(&queue_info);
            /* retrieve current configuration */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, base_voq + cosq, &queue_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            /* update configuration */
            /*Map each queue offset to relevant rate class*/
            queue_info.rate_cls = config->queue_atrributes[cosq].rate_class;

            /*Map each queue offset to relevant crefit request profile*/
            rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, config->queue_atrributes[cosq].delay_tolerance_level, &(queue_info.cr_req_type_ndx));
            BCMDNX_IF_ERR_EXIT(rc);  
            queue_info.old_cr_req_type_ndx = SOC_TMC_ITM_QT_NDX_INVALID;
               
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_set,(unit, core, base_voq + cosq, &queue_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }     
        /*Update SW state for rate class mapping*/
        rc = _bcm_petra_cosq_ingress_queue_bundle_ref_count_update(unit, TRUE, &queue_attributes_verify);
        BCMDNX_IF_ERR_EXIT(rc);  
    }
#endif /*BCM_ARAD_SUPPORT*/

#ifdef BCM_WARM_BOOT_SUPPORT
    /*update WB DB*/
    rc = _bcm_dpp_wb_cosq_update_voq_state(unit, core, base_voq);
    if (rc != BCM_E_NONE) {
        goto err;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    if (is_isq) {
        *gport = BCM_COSQ_GPORT_ISQ_SET(tmp_gport, base_voq);
    } else {                                
        *gport = BCM_GPORT_UNICAST_QUEUE_GROUP_SET(tmp_gport, base_voq);
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;
err:
    if (base_voq != -1) {
        int rc_free = BCM_E_NONE;
        rc_free = bcm_dpp_am_ingress_voq_deallocate(unit,
                                                    core,
                                                    alloc_flags,
                                                    is_non_contiguous,
                                                    numq,
                                                    base_voq);
        /* We will vliadate rc after freeing list*/
        BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
            voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, 
                                                                                 &(_dpp_cosq_config[unit].voq_hd),
                                                                                 DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));

            if (voq_config != NULL) {
                _bcm_petra_cosq_element_free(unit, 
                                             &(_dpp_cosq_config[unit].voq_hd), 
                                             DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
            }
        }
        BCMDNX_IF_ERR_EXIT(rc_free);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_connector_gport_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_gport_t *physical_port,
                                    int *num_cos_levels,
                                    uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    uint32                           soc_sand_rc;
    bcm_dpp_cosq_gport_info_t        gport_info;
    uint8                        is_non_contiguous;
    int                              base_flow_id, flow_region, is_odd_even;
    SOC_TMC_SCH_QUARTET_MAPPING_INFO     quartet_mapping_info;
    bcm_dpp_cosq_connector_config_t  *connector_config = NULL;
    bcm_dpp_cosq_config_t            *cosq_config;


    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];    

    sal_memset(&gport_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    /* determine flow id */
    base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);

    /* retreive connector group state */
    connector_config = (bcm_dpp_cosq_connector_config_t*)_bcm_petra_cosq_element_get(unit,
                                              &(cosq_config->connector_hd), base_flow_id);
    if (connector_config == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) gport get flow internal state retreival error"), unit, base_flow_id));
    }

    gport_info.flow_config = NULL;
    gport_info.se_config = NULL;

    BCMDNX_ALLOC(gport_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(gport_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    if ( (gport_info.flow_config == NULL) || (gport_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* validate gport (connector) */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, gport, 0, dpp_device_cosq_gport_child_element, &gport_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* retreive flow to queue mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_flow_to_queue_mapping_get,
        (unit, SOC_TMC_SCH_FLOW_TO_QRTT_ID(base_flow_id), &quartet_mapping_info)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreving flow (%d) queue mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_flow_id, soc_sand_rc, rc));
        goto err;
    }
    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    BCM_GPORT_MODPORT_SET((*physical_port), quartet_mapping_info.fip_id, 0);

    /* update parameters */
    (*flags) = BCM_COSQ_GPORT_VOQ_CONNECTOR;
    (*flags) |= (gport_info.is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, flow_region, &is_non_contiguous, &is_odd_even);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    (*num_cos_levels) = connector_config->num_cos;

   BCM_FREE(gport_info.flow_config);
   BCM_FREE(gport_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (gport_info.flow_config != NULL)
       BCM_FREE(gport_info.flow_config);
    if (gport_info.se_config != NULL)
       BCM_FREE(gport_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_hr_gport_get(int unit, bcm_dpp_cosq_gport_info_t *gport_info,
                                   SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_FLOW *flow_config,
                                   uint32 *flags)
{
    int                              rc = BCM_E_NONE;

    
    BCMDNX_INIT_FUNC_DEFS;
    switch (se_config->type_info.hr.mode) {
        case SOC_TMC_SCH_HR_MODE_SINGLE_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_SINGLE_WFQ;
            break;

        case SOC_TMC_SCH_HR_MODE_DUAL_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_DUAL_WFQ;
            break;

        case SOC_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_ENHANCED;
            break;

        case SOC_TMC_SCH_HR_MODE_NONE:
        case SOC_TMC_SCH_SE_HR_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            break;
    }

    if (gport_info != NULL) {
        (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
    }
    else {
        (*flags) |= ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                     (flow_config->sub_flow[1].is_valid == TRUE) ) ? BCM_COSQ_GPORT_COMPOSITE: 0;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_cl_gport_get(int unit, bcm_dpp_cosq_gport_info_t *gport_info,
                                   SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_FLOW *flow_config,
                                   uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    uint32                           soc_sand_rc;
    int                              cl_type_ndx;
    SOC_TMC_SCH_SE_CL_CLASS_INFO         class_type;
    bcm_dpp_cosq_gport_info_t        dual_gport_info;
    bcm_gport_t                      pir_gport;
    uint32                           hr_flags = 0;
    SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE ipf_mode;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);
    sal_memset(&dual_gport_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));
    dual_gport_info.flow_config = NULL;
    dual_gport_info.se_config = NULL;

    BCMDNX_ALLOC(dual_gport_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(dual_gport_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (dual_gport_info.flow_config == NULL) || (dual_gport_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    cl_type_ndx = se_config->type_info.cl.id;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, cl_type_ndx, &class_type)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, cl_type_ndx, soc_sand_rc, rc));
        goto err;
    }

    switch (class_type.mode) {
        case SOC_TMC_SCH_CL_MODE_1:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE1_4SP;
            break;

        case SOC_TMC_SCH_CL_MODE_2:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE2_3SP_WFQ;
            break;

        case SOC_TMC_SCH_CL_MODE_3:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE3_WFQ_2SP;
            break;

        case SOC_TMC_SCH_CL_MODE_4:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE4_2SP_WFQ;
            break;

        case SOC_TMC_SCH_CL_MODE_5:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE5_1SP_WFQ;
            break;

        case SOC_TMC_SCH_CL_MODE_NONE:
        case SOC_TMC_SCH_CL_CLASS_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            goto err;
            break;
    }

    if (class_type.mode != SOC_TMC_SCH_CL_MODE_1) {
        switch (class_type.weight_mode) {
            case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
                (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_DISCREET;
                break;

            case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_ipf_mode_get,(unit, &ipf_mode)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, cl_type_ndx, soc_sand_rc, rc));
                    goto err;
                }
                if(ipf_mode == SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE_INVERSE){
                    (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT;
                }
                else if(ipf_mode == SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE_PROPORTIONAL){
                    (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT_PROPORTIONAL;
                }
                else{
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, invalid ipf mode %d\n"), unit, ipf_mode));
                    rc = BCM_E_PARAM;
                    goto err;
                }
                break;

            case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
                (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_CLASS;
                break;

            case SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
            default:
            break;
        }
    }

    switch (class_type.enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ;
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ;
            break;

        case SOC_TMC_SCH_CL_ENHANCED_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            goto err;
            break;
    }

    if (se_config->is_dual) {
        (*flags) |= BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER;

        /* determine type of dual shaper */

        BCM_COSQ_GPORT_SCHED_PIR_SET(pir_gport, gport_info->flow_id);

        rc = _bcm_petra_cosq_gport_validate_info_get(unit, pir_gport, 0, dpp_device_cosq_gport_parent_element, &dual_gport_info);
        if (rc != BCM_E_NONE) {
            goto err;
        }

        if (dual_gport_info.is_se != TRUE) {
            rc = BCM_E_PARAM;
            goto err;
        }

        switch ((dual_gport_info.se_config)->type) {
            case SOC_TMC_SCH_SE_TYPE_HR:
                rc = _bcm_petra_cosq_sched_hr_gport_get(unit, &dual_gport_info, dual_gport_info.se_config, dual_gport_info.flow_config, &hr_flags);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

                (*flags) |= (hr_flags);
                break;

            default:
                break;
       }
    }

    if (gport_info != NULL) {
        (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
    }
    else {
        (*flags) |= ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                     (flow_config->sub_flow[1].is_valid == TRUE) ) ? BCM_COSQ_GPORT_COMPOSITE: 0;
    }

    BCM_FREE(dual_gport_info.flow_config);
    BCM_FREE(dual_gport_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (dual_gport_info.flow_config != NULL)
       BCM_FREE(dual_gport_info.flow_config);
    if (dual_gport_info.se_config != NULL)
       BCM_FREE(dual_gport_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_gport_get(int unit,
                                bcm_gport_t gport,
                                bcm_gport_t *physical_port,
                                int *num_cos_levels,
                                uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    bcm_gport_t                      res_gport;
    bcm_dpp_cosq_gport_info_t        gport_info;


    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&gport_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    gport_info.flow_config = NULL;
    gport_info.se_config = NULL;

    BCMDNX_ALLOC(gport_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(gport_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    if ( (gport_info.flow_config == NULL) || (gport_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport, &res_gport);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* validate gport (scheduler) */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, res_gport, 0, dpp_device_cosq_gport_sched_nocirpir_ds_element, &gport_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    switch ((gport_info.se_config)->type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            rc = _bcm_petra_cosq_sched_hr_gport_get(unit, &gport_info, gport_info.se_config, gport_info.flow_config, flags);
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:
            rc = _bcm_petra_cosq_sched_cl_gport_get(unit, &gport_info, gport_info.se_config, gport_info.flow_config, flags);
            break;

        case SOC_TMC_SCH_SE_TYPE_FQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_FQ;
            (*flags) |= (gport_info.is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
            break;

        default:
            rc = BCM_E_PARAM;
            break;
    }
    if (rc != BCM_E_NONE) {
        goto err;
    }

    (*flags) |= BCM_COSQ_GPORT_SCHEDULER;

    /* In case of Scheduler component, always set num_cos_levels to 1 */
    *num_cos_levels = 1;

   BCM_FREE(gport_info.flow_config);
   BCM_FREE(gport_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (gport_info.flow_config != NULL)
       BCM_FREE(gport_info.flow_config);
    if (gport_info.se_config != NULL)
       BCM_FREE(gport_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_e2e_gport_get(int unit,
                              bcm_gport_t gport,
                              bcm_gport_t *physical_port,
                              int *num_cos_levels,
                              uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t        gport_info;


    BCMDNX_INIT_FUNC_DEFS;
    gport_info.flow_config = NULL;
    gport_info.se_config = NULL;

    BCMDNX_ALLOC(gport_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(gport_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    if ( (gport_info.flow_config == NULL) || (gport_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }


    /* validate gport (scheduler) */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, gport, 0, dpp_device_cosq_gport_sched_nocirpir_ds_element, &gport_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    switch ((gport_info.se_config)->type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            rc = _bcm_petra_cosq_sched_hr_gport_get(unit, &gport_info, gport_info.se_config, gport_info.flow_config, flags);
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:
        case SOC_TMC_SCH_SE_TYPE_FQ:
        default:
            rc = BCM_E_PARAM;
            break;
    }
    if (rc != BCM_E_NONE) {
        goto err;
    }

    (*flags) |= BCM_COSQ_GPORT_SCHEDULER;

    /* In case of Scheduler component, always set num_cos_levels to 1 */
    *num_cos_levels = 1;

    BCM_FREE(gport_info.flow_config);
    BCM_FREE(gport_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (gport_info.flow_config != NULL)
       BCM_FREE(gport_info.flow_config);
    if (gport_info.se_config != NULL)
       BCM_FREE(gport_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ucast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags)
{
    bcm_error_t                  rc = BCM_E_NONE;
    uint8                    is_non_contiguous = FALSE;
    uint8                    is_dest_valid = FALSE;
    uint8                    is_isq = FALSE;
    int                          soc_sand_rc = 0;
    bcm_gport_t                  sysport_gport;
    int                          sysport = 0;
    int                          base_voq = 0;
    bcm_dpp_cosq_voq_config_t   *voq_config = NULL;
    uint32                       dest_base_queue = 0;
    uint32                       queue_region;
    SOC_TMC_IPQ_QUARTET_MAP_INFO     queue2flow;
    unsigned indirect_mode = 1;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE;
    uint8 nof_iter = 0;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    is_isq = (BCM_COSQ_GPORT_IS_ISQ(gport)) ? TRUE: FALSE;
#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit) && ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        indirect_mode = 0;
    }
#endif

    *flags = 0;
    if (is_isq) {
        base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    }

    if (base_voq >= SOC_DPP_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    if (core < 0 && core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) delete uc q gport(0x%08x) failed, core out of range %d"), unit, gport, core));
    }
    SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* Find the queue to flow mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
        (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_voq), &queue2flow)));
    
    rc = handle_sand_result(soc_sand_rc);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("soc_petra_ipq_queue_to_flow_mapping_get() failed base queue(%d)"), base_voq));
    }

    sysport = queue2flow.system_physical_port;

    /* determine if this queue group is non-flow based */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_get,
        (unit, core, sysport, &is_dest_valid, &is_sw_only, &dest_base_queue)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
          (_BSL_BCM_MSG("retrieving base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), 
          sysport, soc_sand_rc, rc));
    }

    if (indirect_mode) {
        /* From the queue to flow mapping, get the system port */
        BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, sysport);

        /* return the physical port given the system port */
        rc = bcm_petra_stk_sysport_gport_get(unit, sysport_gport, physical_port);

        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
              (_BSL_BCM_MSG("Unit(%d) sysport(%d) not mapped for base queue(%d)"), unit, sysport, base_voq));
        }
    } else {
        bcm_port_t fap_port;
        /* ERP port required special attention, since it is not a physical port, and should
           be only mapped in the IPS (mapped to 0xff) */
        if (queue2flow.fap_port_id == SOC_TMC_FAP_EGRESS_REPLICATION_IPS_PORT_ID) {
            fap_port = BCM_DPP_PORT_INTERNAL_ERP(0);
        } else {
            rc = bcm_petra_tm_port_get(unit, queue2flow.fap_port_id, &fap_port);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        BCM_GPORT_MODPORT_SET(*physical_port, queue2flow.fap_id, fap_port);
    }
    /* update parameters */
    /*If dest_base_queue != base_voq, then we should use tm flow ID */
    (*flags) |= (dest_base_queue != base_voq) ? BCM_COSQ_GPORT_TM_FLOW_ID : 0;
    if (is_isq) {
        (*flags) |= BCM_COSQ_GPORT_ISQ;
    } else {
        (*flags) |= BCM_COSQ_GPORT_UCAST_QUEUE_GROUP;
    }
    (*flags) |= (queue2flow.is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                  (_BSL_BCM_MSG("unit %d, error in retreiving queue region %d,error 0x%x\n"), unit, queue_region, rc));
    }
    
    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        if (voq_config ==  NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) gport get voq group internal state get"), unit, base_voq));
        }
        if (!nof_iter){
            *num_cos_levels = voq_config->num_cos;
        }
        nof_iter++;
    }
exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_mcast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags)
{
    bcm_error_t                  rc = BCM_E_NONE;
    uint8                    is_non_contiguous = FALSE;
    int                          soc_sand_rc = 0;
    bcm_gport_t                  sysport_gport;
    int                          sysport = 0;
    int                          base_voq = 0;
    bcm_dpp_cosq_voq_config_t   *voq_config = NULL;
    int                          start_fmq = 0, end_fmq;
    SOC_TMC_IPQ_QUARTET_MAP_INFO     queue2flow;
    uint32                       queue_region;
    unsigned                    indirect_mode = 1;
    int                         core = BCM_CORE_ALL, core_index;
    uint8                       nof_iter = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit) && ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        indirect_mode = 0;
    }
#endif
    *flags = 0;
    base_voq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
        
    rc = bcm_petra_fabric_control_get(unit,bcmFabricMulticastQueueMin,&start_fmq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = bcm_petra_fabric_control_get(unit,bcmFabricMulticastQueueMax,&end_fmq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    if (base_voq > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
          (_BSL_BCM_MSG("unit(%d) get mc q %d failed, queue out of range"),
          unit, base_voq));
    }
    
    if (base_voq < start_fmq || base_voq > end_fmq) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
          (_BSL_BCM_MSG("unit(%d) get mc q %d failed, queue out of range of multicast fabric queues"),
          unit, base_voq));
    }

    SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* Find the queue to flow mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
        (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_voq), &queue2flow)));
    
    rc = handle_sand_result(soc_sand_rc);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("soc_petra_ipq_queue_to_flow_mapping_get() failed base queue(%d)"), base_voq));
    }

    sysport = queue2flow.system_physical_port;

    if (indirect_mode) {
        if (sysport == SOC_TMC_SYS_PHYS_PORT_INVALID) { /* if not mapped return 0 */
            *physical_port = 0;
        } else {
            /* From the queue to flow mapping, get the system port */
            BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, sysport);
    
            rc = bcm_petra_stk_sysport_gport_get(unit, sysport_gport, physical_port);
    
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                  (_BSL_BCM_MSG("Unit(%d) sysport(%d) not mapped for base queue(%d)"), 
                  unit, queue2flow.system_physical_port, base_voq));
            }
        }
    } else {
        if (queue2flow.fap_id == SOC_TMC_MAX_FAP_ID) { /* if not mapped return 0 */
            *physical_port = 0;
        } else {
            bcm_port_t fap_port;
            rc = bcm_petra_tm_port_get(unit, queue2flow.fap_port_id, &fap_port);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_GPORT_MODPORT_SET(*physical_port, queue2flow.fap_id, fap_port);
        }
    }

    /* update parameters */
    (*flags) |= BCM_COSQ_GPORT_MCAST_QUEUE_GROUP;
    (*flags) |= (queue2flow.is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                  (_BSL_BCM_MSG("unit %d, error in retreiving queue region %d,error 0x%x\n"), unit, queue_region, rc));
    }

    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        if (voq_config ==  NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) gport get voq group internal state get"), unit, base_voq));
        }
        if (!nof_iter) {
            *num_cos_levels = voq_config->num_cos;
        }
        nof_iter++;
    }

exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_connector_gport_detach(int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq)
{
    int                              rc = BCM_E_NONE;
    int                              is_parent_reserved_res = FALSE;
    bcm_dpp_cosq_gport_info_t        child_info, parent_info;
    uint32                           soc_sand_rc;
    bcm_dpp_cosq_config_t           *cosq_config;
    int                              child_mode, flow_id_index;
    bcm_dpp_cosq_se_config_t        *se_state_config = NULL;
    SOC_TMC_SCH_SE_INFO             *default_se_info = NULL;
    SOC_TMC_SCH_FLOW                *default_sch_flow = NULL;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    SOC_TMC_SCH_FLOW                     exact_flow_config;
    int                              parent_se_port, dummy_tc;
    bcm_gport_t                      parent_port;


    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];    
    
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    sal_memset(&child_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));
    sal_memset(&parent_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    parent_info.flow_config = NULL;
    parent_info.se_config = NULL;
    child_info.flow_config = NULL;
    child_info.se_config = NULL;
    BCMDNX_ALLOC(parent_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(child_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(child_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    BCMDNX_ALLOC(default_se_info, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(default_sch_flow, sizeof(SOC_TMC_SCH_FLOW), "sch flow");

    if ( (parent_info.flow_config == NULL) || (parent_info.se_config == NULL) ||
             (child_info.flow_config == NULL) || (child_info.se_config == NULL)  ||
             (default_se_info == NULL) || (default_sch_flow == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    SOC_TMC_SCH_FLOW_clear(default_sch_flow);
    SOC_TMC_SCH_SE_INFO_clear(default_se_info);

    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, sched_port, &parent_port);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* validate parent element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, parent_port, 0, dpp_device_cosq_gport_parent_element, &parent_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* validate child element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, input_port, cosq, dpp_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* make sure the parent is a SE */
    if ( !(parent_info.is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, sched_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if parent scheduler element is a reserved resource       */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    if (parent_info.is_se) {
        rc = _bcm_petra_cosq_se_id2port(unit, parent_info.se_id, &parent_se_port, &dummy_tc);
        if (rc != BCM_E_NONE)
        {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Error retreving port id from SE %d\n"), unit,parent_info.se_id));          
          goto err;
        }     
    }
    if ( (parent_info.is_se) &&
                        ( (parent_se_port != DPP_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (parent_info.se_id == cosq_config->default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }
    flow_id_index = (child_info.is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info.flow_config->sub_flow[flow_id_index].credit_source);

    /* consistency checks. */
    /* verify child scheduler connection to parent scheduler              */
    if ( (parent_info.se_config)->id !=
                       (child_info.flow_config)->sub_flow[flow_id_index].credit_source.id ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* if already detached return error */
    if (parent_info.se_id == cosq_config->default_se) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, detach operation on input_port:cos(0x%x:%d) error, already detached\n"), unit, input_port, cosq));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* verify reference count is greater then 0 */
    if (is_parent_reserved_res == FALSE) {
        se_state_config = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_get(unit,
                                         &(cosq_config->se_hd), (parent_info.se_config)->id);
        if (se_state_config ==  NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) parent SE(%d) state not available\n"),
                                  unit, (parent_info.se_config)->id));
            rc = BCM_E_RESOURCE;
            goto err;
        }

        if (se_state_config->ref_cnt <= DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) Parent SE(%d) reference count is 0\n"),
                                  unit, (parent_info.se_config)->id));
            rc = BCM_E_INTERNAL;
            goto err;
        }
    }

    /* detach by setting to default SE */
    /* determine scheduling mode of child with respect to parent */
    rc = _bcm_petra_cosq_mode_get(unit, child_info.flow_config, child_info.is_sf2, &child_mode);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving child element scheduling mode, error 0x%x\n"), unit, rc));
        goto err;
    }

    /* retreive default SE configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, cosq_config->default_se, default_se_info, default_sch_flow)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, cosq_config->default_se, soc_sand_rc, rc));
        goto err;
    }

    /* attach to default / reserved SE */
    cs_info->se_type = default_se_info->type;
    cs_info->id = cosq_config->default_se;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, child_info.flow_id, child_info.flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, child_info.flow_id, soc_sand_rc, rc));
         goto err;
    }

    /* decrement reference count of parent */
    if (is_parent_reserved_res == FALSE) {
        se_state_config->ref_cnt--;
#ifdef BCM_WARM_BOOT_SUPPORT
        rc = _bcm_dpp_wb_cosq_update_se_state(unit, (parent_info.se_config)->id, se_state_config->ref_cnt);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed update of seId(%d) ref , error 0x%x\n"), unit, parent_info.se_id, rc));
        }
#endif /* BCM_WARM_BOOT_SUPPORT */
    }

   BCM_FREE(parent_info.flow_config);
   BCM_FREE(parent_info.se_config);
   BCM_FREE(child_info.flow_config);
   BCM_FREE(child_info.se_config);
   BCM_FREE(default_se_info);
   BCM_FREE(default_sch_flow);
    
    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:

    if (parent_info.flow_config != NULL)  
       BCM_FREE(parent_info.flow_config);
    if (parent_info.se_config != NULL)
       BCM_FREE(parent_info.se_config);
    if (child_info.flow_config != NULL)
       BCM_FREE(child_info.flow_config);
    if (child_info.se_config != NULL)
       BCM_FREE(child_info.se_config);
    if (default_se_info != NULL)
       BCM_FREE(default_se_info);
    if (default_sch_flow != NULL)
       BCM_FREE(default_sch_flow);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_gport_delete(int unit, bcm_gport_t gport)
{
    int                              rc = BCM_E_NONE;
    int                              is_port_reserved_res = FALSE, is_enhanced = FALSE;
    int                              enhanced_mode;
    bcm_dpp_cosq_gport_info_t        port_info, dual_port_info;
    bcm_dpp_cosq_config_t           *cosq_config;
    bcm_dpp_cosq_se_config_t        *se_state_config = NULL;
    SOC_TMC_SCH_FLOW                     exact_flow_config;
    bcm_gport_t                      pir_gport;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    uint32                           soc_sand_rc, flags = 0;
    int                              second_flow_id; /* composite or dual */
    int                              res_flow_id; /* fq adjustment for low level alloaction */
    int                              is_last;


    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];    
    
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    sal_memset(&port_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));
    sal_memset(&dual_port_info,0x0,sizeof(bcm_dpp_cosq_gport_info_t));

    port_info.flow_config = NULL;
    port_info.se_config = NULL;
    dual_port_info.flow_config = NULL;
    dual_port_info.se_config = NULL;

    BCMDNX_ALLOC(port_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(port_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(dual_port_info.flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(dual_port_info.se_config, sizeof(SOC_TMC_SCH_SE_INFO), "se");


    if ( (port_info.flow_config == NULL) || (port_info.se_config == NULL) ||
         (dual_port_info.flow_config == NULL) || (dual_port_info.se_config == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* validate gport element */
    rc = _bcm_petra_cosq_gport_validate_info_get(unit, gport, 0, dpp_device_cosq_gport_sched_nocirpir_ds_element, &port_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* make sure the gport is a SE */
    if ( !(port_info.is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, gport));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if scheduler element is a reserved resource              */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    if (port_info.is_se) {
        if ((port_info.se_id == cosq_config->default_se) || 
            (SOC_IS_PETRAB(unit) && port_info.se_id <= SOC_DPP_DEFS_GET(unit, nof_logical_ports))) {
            is_port_reserved_res = TRUE;
        }
        if (is_port_reserved_res == TRUE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "unit %d, gport(0x%x) is a reserved resource and cannot be deleted\n"), unit, gport));
             rc = BCM_E_PARAM;
             goto err;
        }
    }

    /* check if the SE is not referenced */
    se_state_config = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_get(unit,
                                                &(cosq_config->se_hd), port_info.se_id);
    if (se_state_config == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) state not available\n"), unit, port_info.se_id));
        rc = BCM_E_RESOURCE;
        goto err;
    }

    if (se_state_config->ref_cnt > DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) reference count(%d) not zero \n"),
                              unit, port_info.se_id, se_state_config->ref_cnt));
        rc = BCM_E_INTERNAL;
        goto err;
    }

    /* check if the SE is detached */
    cs_info = &(port_info.flow_config->sub_flow[0].credit_source);
    if (cs_info->id != cosq_config->default_se) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
        rc = BCM_E_PARAM;
        goto err;
    }
    if (port_info.is_composite == TRUE) {
        cs_info = &(port_info.flow_config->sub_flow[1].credit_source);
        if (cs_info->id != cosq_config->default_se) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
            rc = BCM_E_PARAM;
            goto err;
        }
    }

    /* if dual shaper configuration, check that dual SE is not referenced */
    if (port_info.is_dual) {
        BCM_COSQ_GPORT_SCHED_PIR_SET(pir_gport, gport);

        rc = _bcm_petra_cosq_gport_validate_info_get(unit, pir_gport, 0, dpp_device_cosq_gport_parent_element, &dual_port_info);
        if (rc != BCM_E_NONE) {
            goto err;
        }

        if (dual_port_info.is_se != TRUE) {
            rc = BCM_E_PARAM;
            goto err;
        }

        cs_info = &(dual_port_info.flow_config->sub_flow[0].credit_source);
        if (cs_info->id != cosq_config->default_se) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
            rc = BCM_E_PARAM;
            goto err;
        }
    }

    /* disable SE */
    (port_info.se_config)->state = SOC_TMC_SCH_SE_STATE_DISABLE;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, port_info.se_id, port_info.se_config, port_info.flow_config, &exact_flow_config)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, port_info.se_id, soc_sand_rc, rc));
        goto err;
    }

    if (port_info.is_dual) {
        (dual_port_info.se_config)->state = SOC_TMC_SCH_SE_STATE_DISABLE;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, dual_port_info.se_id, dual_port_info.se_config, dual_port_info.flow_config, &exact_flow_config)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, dual_port_info.se_id, soc_sand_rc, rc));
            goto err;
        }
    }

    /* free template resources */
    if ((port_info.se_config)->type == SOC_TMC_SCH_SE_TYPE_CL) {
        rc = _bcm_dpp_am_template_cosq_sched_class_free(unit, (port_info.se_config)->type_info.cl.id, &is_last);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in freeing class template cid(%d), error 0x%x\n"), unit, (port_info.se_config)->type_info.cl.id, rc));
            goto err;
        }

        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "DBG unit %d, CL template(%d) is_last(%s)\n"), unit, (port_info.se_config)->type_info.cl.id, ((is_last == TRUE) ? "TRUE" : "FALSE")));

#ifdef BCM_WARM_BOOT_SUPPORT
        rc = _bcm_dpp_wb_cosq_update_class_data(unit, 0, (port_info.se_config)->type_info.cl.id, (port_info.se_config)->type_info.cl.id);
        if (rc != BCM_E_NONE) {
            goto err;
        }
#endif /* BCM_WARM_BOOT_SUPPORT */

    }

    /* free resources */
    switch ((port_info.se_config)->type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, flags, port_info.is_composite, FALSE, port_info.is_dual, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_HR, port_info.flow_id);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case SOC_TMC_SCH_SE_TYPE_CL:
            rc = _bcm_petra_cosq_sched_enhanced_mode_get(unit, port_info.se_config, &is_enhanced, &enhanced_mode);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, flags, port_info.is_composite, is_enhanced, port_info.is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_CL, port_info.flow_id);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case SOC_TMC_SCH_SE_TYPE_FQ:
        default:
            res_flow_id = port_info.flow_id;

            rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, flags, port_info.is_composite, FALSE, port_info.is_dual, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_FQ, res_flow_id);

            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;
    }


    /* free flow resources */
    _bcm_petra_cosq_element_free(unit, &(cosq_config->flow_hd), port_info.flow_id);

    if ( (port_info.is_composite) || (port_info.is_dual) ) {
        if (port_info.is_composite) {
            rc = _bcm_petra_se_composite_flow_id_get(unit, port_info.flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &second_flow_id);
        }
        if (port_info.is_dual) {
            rc = _bcm_petra_se_dual_flow_id_get(unit, port_info.flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &second_flow_id);
        }
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) failed to get sub-flow 2 for flow_id(%d)\n"), unit, port_info.flow_id));
            goto err;
        }

        _bcm_petra_cosq_element_free(unit, &(cosq_config->flow_hd), second_flow_id);
    }

    /* free SE resources */
    _bcm_petra_cosq_element_free(unit, &(cosq_config->se_hd), port_info.se_id);
    if (port_info.is_dual) {
        _bcm_petra_cosq_element_free(unit, &(cosq_config->se_hd), dual_port_info.se_id);
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_se_all_state(unit, port_info.se_id, port_info.is_composite, port_info.is_dual);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed update of seId(%d), error 0x%x\n"), unit, port_info.se_id, rc));
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCM_FREE(port_info.flow_config);
    BCM_FREE(port_info.se_config);
    BCM_FREE(dual_port_info.flow_config);
    BCM_FREE(dual_port_info.se_config);
    
    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:

    if (port_info.flow_config != NULL)  
       BCM_FREE(port_info.flow_config);
    if (port_info.se_config != NULL)
       BCM_FREE(port_info.se_config);
    if (dual_port_info.flow_config != NULL)  
       BCM_FREE(dual_port_info.flow_config);
    if (dual_port_info.se_config != NULL)
       BCM_FREE(dual_port_info.se_config);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_connector_gport_delete(int unit, bcm_gport_t gport)
{
    int                               rc = BCM_E_NONE;
    uint32                            soc_sand_rc;
    uint32                            flags = 0;
    bcm_dpp_cosq_config_t            *cosq_config;
    uint8                         is_non_contiguous, is_composite;
    int                               base_flow_id, numq, flow_region, is_odd_even;
    int                               cur_flow_id, cur_connector, cur_comp_flow_id;    
    SOC_TMC_SCH_FLOW                      flow_config, exact_flow_config;
    bcm_dpp_cosq_connector_config_t  *connector_config = NULL;


    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];    

    /* determine flow id */
    base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);

    /* consistency check - flow withen valid range */
    if (base_flow_id >= SOC_DPP_CONFIG(unit)->tm.max_connectors) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid base connector id %d"),unit, base_flow_id));
    }

    /* retreive connector group state */
    connector_config = (bcm_dpp_cosq_connector_config_t*)_bcm_petra_cosq_element_get(unit,
                                              &(cosq_config->connector_hd), base_flow_id);
    if (connector_config == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) gport delete flow internal state retreival error"), unit, base_flow_id));
    }
    numq = connector_config->num_cos;

    if (numq == 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
    }

    

    /* determine flow attributes */
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, flow_region, &is_non_contiguous, &is_odd_even);
    BCMDNX_IF_ERR_EXIT(rc);

    SOC_TMC_SCH_FLOW_clear(&flow_config);
    SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

    /* consistency check - all flows are detached */
    is_composite = FALSE;
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_petra_flow_id_get(unit, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE,&cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, cur_flow_id, &flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, cur_flow_id, soc_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }

        if (cur_connector == 0) {
            /* determine flow attributes */
            is_composite = ( (flow_config.sub_flow[0].is_valid == TRUE) &&
                            (flow_config.sub_flow[1].is_valid == TRUE) ) ? TRUE : FALSE;
        }

        if (is_composite) {
            rc = _bcm_petra_composite_flow_id_get(unit, base_flow_id, cur_connector, is_non_contiguous, is_composite,&cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        
        /* consistency check, check that the flows match up */
        if (cur_flow_id != flow_config.sub_flow[0].id) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, flow id mismatch Expected/Actual(%d / %d)\n"), unit, cur_flow_id, flow_config.sub_flow[0].id));
        }
        if (is_composite) {
            if (cur_comp_flow_id != flow_config.sub_flow[1].id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, Comp flow id mismatch Expected/Actual(%d / %d)"), unit, cur_comp_flow_id, flow_config.sub_flow[1].id));
            }
        }

        /* check that the flows are detached */
        if (flow_config.sub_flow[0].credit_source.id != cosq_config->default_se) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow id (%d) not detached"), unit, cur_flow_id));
        }
        if (is_composite) {
            if (flow_config.sub_flow[1].credit_source.id != cosq_config->default_se) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Comp flow id (%d) not detached"), unit, cur_comp_flow_id));
            }
        }
    }

    /* delete all flows */
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_petra_flow_id_get(unit, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE,&cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, cur_flow_id, &flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, cur_flow_id, soc_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }

        flow_config.sub_flow[0].is_valid = FALSE;
        if (is_composite) {
            flow_config.sub_flow[1].is_valid = FALSE;
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, cur_flow_id, &flow_config, &exact_flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, cur_flow_id, soc_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }
    }

    /* free resources */
    rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, base_flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error freeing connector resources (baseFlowId: %d) from resource manager, error 0x%x\n"), unit, base_flow_id, rc));
        BCM_ERR_EXIT_NO_MSG(rc);
    }

    /* free flow resources */
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_petra_flow_id_get(unit, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE, &cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);
        rc = _bcm_petra_cosq_element_free(unit, &(_dpp_cosq_config[unit].connector_hd), cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        if (is_composite) {
            rc = _bcm_petra_composite_flow_id_get(unit, base_flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
            rc = _bcm_petra_cosq_element_free(unit, &(cosq_config->connector_hd), cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* free connector group resources */
    rc = _bcm_petra_cosq_element_free(unit, &(cosq_config->connector_hd), base_flow_id);
    BCMDNX_IF_ERR_EXIT(rc);

    /* update persistent storage */
#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_conn_all_state(unit, base_flow_id, is_non_contiguous, is_composite, -1);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_mcast_gport_delete(int unit, bcm_gport_t gport)
{
    int                         rc = BCM_E_NONE, result = BCM_E_NONE;
    uint8                   is_non_contiguous = FALSE;
    int                         soc_sand_rc = 0;
    int                         base_voq = 0, voq = 0, numq = 0, queue_region;
    bcm_dpp_cosq_voq_config_t  *voq_config = NULL;
    bcm_dpp_cosq_config_t      *cosq_config;
    SOC_TMC_IPQ_QUARTET_MAP_INFO    queue2flow;
    int                         alloc_flags = 0, flow_quartet;
    SOC_SAND_U32_RANGE              mc_queue_range;
    int                         mcast_sched_mode = 0;
    int                         core = BCM_CORE_ALL, core_index;
    uint8                       nof_iters = 0; 
    int                         numq_tmp = -1;
#ifdef BCM_ARAD_SUPPORT
    bcm_dpp_cosq_queue_attributes_verify_t          queue_attributes_verify;
    bcm_cosq_ingress_queue_bundle_gport_config_t    config;
#endif

    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];    

    SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* determine base queue id */
    base_voq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);

    /* consistency checks */
    if (base_voq >= SOC_DPP_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    /* consistency check that it is withen the multicast queue range */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_enhanced_get,(unit, &mc_queue_range)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
          (_BSL_BCM_MSG("Unit (%d), retreiving multicast queue range failed, soc_sand error (0x%x), error 0x%x"), unit, soc_sand_rc, rc));
    }

    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    if ( (base_voq < mc_queue_range.start) || (base_voq > mc_queue_range.end) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("base voq is out of the provided range")));
    }

    /* determine queue region mode */
    queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    BCMDNX_IF_ERR_EXIT(rc);

    /* retreive queue group state */
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, 
                                                                             &(cosq_config->voq_hd), 
                                                                             DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        if (voq_config == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,
              (_BSL_BCM_MSG("Unit(%d) baseVoq(%d) error retreiving internal state"), unit, base_voq));
        }
        numq = voq_config->num_cos;
        if (nof_iters && numq_tmp != numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Different configuration between cores"),unit));
        }
        numq_tmp = numq;
        if (numq == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
        }
        nof_iters++;
    }

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        config.numq = numq;
        rc = _bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, base_voq, FALSE, &config, &gport, &queue_attributes_verify);
        BCMDNX_IF_ERR_EXIT(rc);
    }
#endif

    /* determine if queue group association with connectors is removed */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
          (_BSL_BCM_MSG("soc_petra_ipq_queue_to_flow_mapping_get() failed queue(%d)"), voq));
        }

        /* check if queue is dis-connected */
        /* coverity[unsigned_compare:FALSE] */
        if ( (SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) <
                                 DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) ||
             (SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) >=
                                 DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, queue (%d) not dsconnected"), unit, voq));
        }
    }

    /* delete queue group */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_qrtt_unmap,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(voq))));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unmap of queue quartet failed Voq(%d), soc_sand error 0x%x, error 0x%x\n"), voq, soc_sand_rc, rc));
            if (flow_quartet == 0) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unmap of queue quartet failed")));
            }
        }
    }

    result = bcm_petra_fabric_multicast_scheduler_mode_get(unit, &mcast_sched_mode);
    BCMDNX_IF_ERR_EXIT(result);
    
    /* free resources */

    /* If multicast scheduling mode=0, queues 0-3 are used - these aren't reserved through alloc manager. *
     * otherwise, 1k queues can be used for multicast and these are managed by alloc manager              *
     */
    if (mcast_sched_mode != 0) {
        result = bcm_dpp_am_ingress_voq_deallocate(unit, core, alloc_flags, is_non_contiguous, numq, base_voq);
    }

    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        if (voq_config != NULL) {
            _bcm_petra_cosq_element_free(unit, &(cosq_config->voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        }
    }   
    BCMDNX_IF_ERR_EXIT(rc);

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        /* When deleting a new voq it is unmapped from some rate class*/
        rc = _bcm_petra_cosq_ingress_queue_bundle_ref_count_update(unit, FALSE, &queue_attributes_verify);
        BCMDNX_IF_ERR_EXIT(rc);
    }
#endif /*BCM_ARAD_SUPPORT*/


#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_voq_state(unit, core, base_voq);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_IF_ERR_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ucast_gport_delete(int unit, bcm_gport_t gport)
{
    int                         rc = BCM_E_NONE, result = BCM_E_NONE;
    uint8                   is_non_contiguous = FALSE,
                                is_dest_valid, is_dest = FALSE;
    uint8                   is_isq = FALSE;
    int                         soc_sand_rc = 0;
    int                         base_voq = 0,voq = 0, numq = 0, queue_region;
    bcm_dpp_cosq_voq_config_t  *voq_config = NULL;
    bcm_dpp_cosq_config_t      *cosq_config;
    SOC_TMC_IPQ_QUARTET_MAP_INFO    queue2flow;
    int                         sysport = 0, alloc_flags = 0, flow_quartet;
    uint32                      dest_base_queue = 0;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE, nof_iters = 0;
    int                        numq_tmp = -1;
#ifdef BCM_ARAD_SUPPORT
    bcm_dpp_cosq_queue_attributes_verify_t          queue_attributes_verify;
    bcm_cosq_ingress_queue_bundle_gport_config_t    config;
#endif


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    cosq_config = &_dpp_cosq_config[unit];    

    SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    is_isq = (BCM_COSQ_GPORT_IS_ISQ(gport)) ? TRUE: FALSE;

   /* determine base queue id */
    if (is_isq) {
        base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    }

    /* consistency checks */
    if (base_voq >= SOC_DPP_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    if (core < 0 && core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) get uc q gport(0x%08x failed, core out of range %d"), unit, gport, core));
    }

    

    /* determine queue region mode */
    queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    BCMDNX_IF_ERR_EXIT(rc);

    /* retreive queue group state */
    

    /* retreive queue group state */
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, 
                                                                             &(cosq_config->voq_hd),
                                                                             DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        if (voq_config == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,
              (_BSL_BCM_MSG("Unit(%d) baseVoq(%d) error retreiving internal state"), unit, base_voq));
        }
        numq = voq_config->num_cos;
        if (nof_iters && numq_tmp != numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Different configuration between cores"),unit));
        }
        numq_tmp = numq;
        if (numq == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
        }
        nof_iters++;
    }

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        config.numq = numq;
        rc = _bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, base_voq, FALSE, &config, &gport, &queue_attributes_verify);
        BCMDNX_IF_ERR_EXIT(rc);
    }
#endif

    /* determine if queue group association with connectors is removed */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
            (unit, core ,SOC_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
              (_BSL_BCM_MSG("soc_petra_ipq_queue_to_flow_mapping_get() failed queue(%d)"), voq));
        }

        /* determine state */
        if (flow_quartet == 0) {
            sysport = queue2flow.system_physical_port;
        }

        /* check if queue is dis-connected */
        /* coverity[unsigned_compare:FALSE] */
        if ( (SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) <
                                 DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) ||
             (SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) >=
                                 DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, queue (%d) not disconnected"), unit, voq));
        }
    }

    /* determine if this queue group is non-flow based */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_get,
        (unit, core, sysport, &is_dest_valid, &is_sw_only, &dest_base_queue)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
          (_BSL_BCM_MSG("retreiving base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), sysport, soc_sand_rc, rc));
    }

    if (dest_base_queue == base_voq) {
        is_dest = TRUE;

        /* disable configuration */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_set,
            (unit, core, sysport, FALSE, is_sw_only, dest_base_queue)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
              (_BSL_BCM_MSG("disabling base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), sysport, soc_sand_rc, rc));
        }
    }

    /* delete queue group */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_qrtt_unmap,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(voq))));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unmap of queue quartet failed Voq(%d), soc_sand error 0x%x, error 0x%x\n"), voq, soc_sand_rc, rc));
            if ( (flow_quartet == 0) && (is_dest == FALSE) ) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unmap of queue quartet failed")));
            }
        }
    }

    /* free resources */
    result = bcm_dpp_am_ingress_voq_deallocate(unit, core, alloc_flags, is_non_contiguous, numq, base_voq);
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        if (voq_config != NULL) {
            _bcm_petra_cosq_element_free(unit, &(cosq_config->voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq));
        }
    }   

    BCMDNX_IF_ERR_EXIT(rc);

#ifdef BCM_ARAD_SUPPORT
    if (SOC_IS_ARAD(unit)) {
        /* When deleting a new voq it is unmapped from some rate class*/
        rc = _bcm_petra_cosq_ingress_queue_bundle_ref_count_update(unit, FALSE, &queue_attributes_verify);
        BCMDNX_IF_ERR_EXIT(rc);
    }
#endif /*BCM_ARAD_SUPPORT*/

#ifdef BCM_WARM_BOOT_SUPPORT
    rc = _bcm_dpp_wb_cosq_update_voq_state(unit, core, base_voq);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_IF_ERR_EXIT(result);
exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_sched_cl_profile_get(int unit, int mode, int enhanced_mode, int weight_mode, int validate_only, int *cid)
{
    int rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    (*cid) = -1;
    switch(weight_mode) {
        case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
            switch (mode) {
                case SOC_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_ind;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_ind_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_ind_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_ind;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_ind_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_ind_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_ind;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_ind_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_ind_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_1:
                case SOC_TMC_SCH_CL_MODE_2:
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
            switch (mode) {
                case SOC_TMC_SCH_CL_MODE_1:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode1;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode1_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode1_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_2:
                case SOC_TMC_SCH_CL_MODE_3:
                case SOC_TMC_SCH_CL_MODE_4:
                case SOC_TMC_SCH_CL_MODE_5:
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        
        case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
            switch (mode) {
                case SOC_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_des;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_des_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_des_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_des;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_des_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_des_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_des;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_des_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_des_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_1:
                    rc = BCM_E_PARAM;
                    break;
                case SOC_TMC_SCH_CL_MODE_2:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_des;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_des_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_des_elp_fq;
                            break;
                    }
                    break;
            }
            break;

        
        case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
            switch (mode) {
                case SOC_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_cls;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_cls_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_cls_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_cls;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_cls_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_cls_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_cls;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_cls_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_cls_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_1:
                    rc = BCM_E_PARAM;
                    break;
                case SOC_TMC_SCH_CL_MODE_2:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_cls;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_cls_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_cls_elp_fq;
                            break;
                    }
                    break;
            }
            break;

        default:
            rc = BCM_E_PARAM;
            break;
    }

    if (validate_only == TRUE) {
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
    
    if ((*cid) != -1) {
        BCMDNX_IF_ERR_EXIT(rc); /* does nothing */
        BCM_EXIT;
    }

    /* get id via template management code */
    

    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid CL settings")));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_cl_verfiy_flags_mode_get(int unit, int flags, int *cl_mode, int *enhanced_mode, int *weight_mode)
{
    int rc = BCM_E_NONE;
    int cl_type_flags, cl_enhanced_flags, cl_weight_flags, cid;
    SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE configured_ipf_mode = SOC_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES;
    SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE ipf_mode;
    int  soc_sand_rc = 0;



    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    cl_type_flags = (flags & DPP_DEVICE_COSQ_CL_MASK);
    cl_enhanced_flags = (flags & DPP_DEVICE_COSQ_CL_ENHANCED_MASK);
    cl_weight_flags = (flags & DPP_DEVICE_COSQ_CL_WFQ_MASK);

    /* consistency check of cl type */
    switch (cl_type_flags) {
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE1_4SP:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_1;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE2_3SP_WFQ:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_2;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE3_WFQ_2SP:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_3;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE4_2SP_WFQ:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_4;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE5_1SP_WFQ:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_5;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl type flags parameter 0x%x\n"), unit, cl_type_flags));
            rc = BCM_E_PARAM;
            break;
    }

    /* consistency check of cl enhanced mode */
    switch (cl_enhanced_flags) {
        case 0:
            (*enhanced_mode) = SOC_TMC_CL_ENHANCED_MODE_DISABLED;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ:
            (*enhanced_mode) = SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ:
            (*enhanced_mode) = SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl enhanced flags parameter 0x%x\n"), unit, cl_enhanced_flags));
            rc = BCM_E_PARAM;
            break;
    }
    /* consistency check of cl weight mode */
    switch (cl_weight_flags) {
        case 0:
            (*weight_mode) = SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT:
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT_PROPORTIONAL:
            ipf_mode = (BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT == cl_weight_flags) ? SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE_INVERSE : SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE_PROPORTIONAL; 
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_ipf_mode_get,(unit, &configured_ipf_mode)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, get ipf mode, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
                break;
            }
            /* ipf mode not initialized*/
            if (configured_ipf_mode == SOC_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES){
                uint32 soc_sand_rc;
#ifdef BCM_WARM_BOOT_SUPPORT
                rc = _bcm_dpp_wb_cosq_update_ipf_mode(unit, ipf_mode);
                BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_ipf_mode_set,(unit, ipf_mode)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, set ipf mode %d, soc_sand error 0x%x, error 0x%x\n"), unit, ipf_mode, soc_sand_rc, rc));
                    break;
                }
            }
            else if(configured_ipf_mode != ipf_mode){
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, you can not use inverse and proportinal Independent per flow CL\n"), unit));
                rc = BCM_E_PARAM;
                break;
            }
            (*weight_mode) = SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_DISCREET:
            (*weight_mode) = SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_CLASS:
            (*weight_mode) = SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl weight flags parameter 0x%x\n"), unit, cl_weight_flags));
            rc = BCM_E_PARAM;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);

    /* consistency check across {type, enhanced mode, weight mode } */
    rc = _bcm_petra_sched_cl_profile_get(unit, (*cl_mode), (*enhanced_mode), (*weight_mode), TRUE, &cid);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* STATIC */ int
_bcm_petra_sched_cl_nbr_discrete_levels_get(int unit, int cl_mode, int *nbr_levels)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch(cl_mode) {
        case SOC_TMC_SCH_CL_MODE_1:
            (*nbr_levels) = 0;
            break;

        case SOC_TMC_SCH_CL_MODE_2:
            (*nbr_levels) = 2;
            break;

        case SOC_TMC_SCH_CL_MODE_3:
            (*nbr_levels) = 3;
            break;

        case SOC_TMC_SCH_CL_MODE_4:
            (*nbr_levels) = 3;
            break;

        case SOC_TMC_SCH_CL_MODE_5:
            (*nbr_levels) = 4;
            break;

        default:
            (*nbr_levels) = 0;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cl mode 0x%x"), unit, cl_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* STATIC */ int
_bcm_petra_sched_cl_default_cl_weights_get(int unit, int cl_mode, int *weights)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(weights, 0, (sizeof(int) * SOC_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS));

    switch(cl_mode) {
        case SOC_TMC_SCH_CL_MODE_1:
            break;

        case SOC_TMC_SCH_CL_MODE_2:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            break;

        case SOC_TMC_SCH_CL_MODE_3:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            break;

        case SOC_TMC_SCH_CL_MODE_4:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            break;

        case SOC_TMC_SCH_CL_MODE_5:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            *(weights + 3) = 8;
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cl mode 0x%x"), unit, cl_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_sched_cl_dynamic_profile_init(int unit)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_sched_class_template_add(int unit,
                                    int mode,
                                    int enhanced_mode,
                                    int weight_mode,
                                    int *weights,
                                    int flags,
                                    int *template,
                                    int *is_allocated,
                                    int ref_cnt)
{
    int                              rc = BCM_E_NONE;
    bcm_dpp_cosq_sched_class_data_t  class_data;
    int                              expected_template = -1;
    int                              ref_count, count;



    BCMDNX_INIT_FUNC_DEFS;
    ref_count = (ref_cnt > 0) ? ref_cnt : 1;

    /* consistency check */
    if (flags & SHR_TEMPLATE_MANAGE_SET_WITH_ID) {
        expected_template = (*template);
    }

    DPP_DEVICE_COSQ_CL_CLASS_DATA_INIT(class_data, mode, enhanced_mode, weight_mode, weights);

    for (count = 0; count < ref_count; count++) {
        rc = _bcm_dpp_am_template_cosq_sched_class_allocate(unit, flags, (int *)&class_data, is_allocated, template);

        BCMDNX_IF_ERR_EXIT(rc);

        /* consistency check */
        if (expected_template != -1) {
            rc = (expected_template != (*template)) ? BCM_E_INTERNAL : rc; 
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Unexpected Sched Class Template, Expected(%d) Actual(%d)\n"), unit, expected_template, (*template)));        
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_sched_cl_profile_init(int unit)
{
    int rc = BCM_E_NONE;
    SOC_TMC_SCH_SE_CL_CLASS_TABLE *cl_class_table = NULL, *exact_cl_class_table = NULL;
    uint32 soc_sand_rc;    
    int weights[SOC_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS];
    int template, flags = SHR_TEMPLATE_MANAGE_SET_WITH_ID, is_allocated;    


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ALLOC(cl_class_table, sizeof(SOC_TMC_SCH_SE_CL_CLASS_TABLE), "class table");
    if (cl_class_table == NULL) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }
    BCMDNX_ALLOC(exact_cl_class_table, sizeof(SOC_TMC_SCH_SE_CL_CLASS_TABLE), "class table");
    if (exact_cl_class_table == NULL) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    SOC_TMC_SCH_SE_CL_CLASS_TABLE_clear(cl_class_table);
    SOC_TMC_SCH_SE_CL_CLASS_TABLE_clear(exact_cl_class_table);    

    cl_class_table->nof_class_types = bcm_dpp_cosq_cl_cid_last;

    /* weight mode - independent */
    sal_memset(weights, 0, (sizeof(int) * SOC_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS));

    /* initialization of default templates. Default templates are allocated thus giving them */
    /* a reference count of one. This will ensure (without any additional checks) that the   */
    /* default templates nver get freed.                                                     */
    rc = _bcm_dpp_am_template_cosq_sched_class_init(unit);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * independent per flow - mode 3
     */
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_ind, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_ind_ehp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_ind_elp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode3_ind;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode3_ind_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode3_ind_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * independent per flow - mode 4
     */
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_ind, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_ind_ehp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_ind_elp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode4_ind;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode4_ind_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode4_ind_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * independent per flow - mode 5
     */
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_ind, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_ind_ehp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_ind_elp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode5_ind;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode5_ind_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode5_ind_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * independent per flow - mode 1
     */
    /* weight mode - none.  setting weights mode to SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST */
    /* causes error.  Instead set h/w to SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW. */
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode1, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode1_ehp_fq, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode1_elp_fq, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode1;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode1_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode1_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    
    /* weight mode - discrete flow */
    /*
     * discrete flow - mode 3
     */
    _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_3, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_des, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_des_ehp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_des_elp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode3_des;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode3_des_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode3_des_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * discrete flow - mode 4
     */
    _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_4, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_des, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_des_ehp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_des_elp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode4_des;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode4_des_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode4_des_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * discrete flow - mode 5
     */
    _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_5, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_des, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_des_ehp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_des_elp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode5_des;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode5_des_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode5_des_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * discrete flow - mode 2
     */
    _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_2, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_des, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_des_ehp_fq, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_des_elp_fq, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode2_des;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode2_des_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode2_des_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /* weight mode - discrete per class flow */
    /*
     * discrete per class flow - mode 3
     */
    _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_3, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_cls, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_cls_ehp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_cls_elp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode3_cls;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode3_cls_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode3_cls_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * discrete per class flow - mode 4
     */
    _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_4, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_cls, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_cls_ehp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_cls_elp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode4_cls;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode4_cls_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode4_cls_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * discrete per class flow - mode 5
     */
    _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_5, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_cls, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_cls_ehp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_cls_elp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode5_cls;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode5_cls_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode5_cls_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * discrete per class flow - mode 2
     */
    _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_2, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_cls, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_cls_ehp_fq, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_cls_elp_fq, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);

    /* add corresponding default templates */
    template = bcm_dpp_cosq_cl_cid_mode2_cls;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode2_cls_ehp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    template = bcm_dpp_cosq_cl_cid_mode2_cls_elp_fq;
    rc = _bcm_petra_sched_class_template_add(unit, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
    BCMDNX_IF_ERR_EXIT(rc);

    /*
     * configure h/w
     */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_table_set,(unit, cl_class_table, exact_cl_class_table)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up cl param table\n"), unit));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

    rc = _bcm_petra_sched_cl_dynamic_profile_init(unit);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(cl_class_table);
    BCM_FREE(exact_cl_class_table);
    BCMDNX_FUNC_RETURN;
}


/*
 * default port for reserved SE (type HR) credit source
 */

STATIC int
_bcm_petra_cosq_default_port_get(int unit, int *port)
{
    soc_port_t  first_phy_port;
    bcm_pbmp_t      ports_map;

    BCMDNX_INIT_FUNC_DEFS;    

    (*port) = 0;
    BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
    BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
    BCM_PBMP_ITER(ports_map, first_phy_port) {break;}

    (*port) = first_phy_port;

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_priority_mode_to_nof_priorities(int unit, 
                                                SOC_TMC_EGR_PORT_PRIORITY_MODE priority_mode, 
                                                int* nof_priorities)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (priority_mode)
    {
    case SOC_TMC_EGR_PORT_ONE_PRIORITY:
      *nof_priorities = 1;
      break;
    case SOC_TMC_EGR_PORT_TWO_PRIORITIES:
      *nof_priorities = 2;
      break;
    case SOC_TMC_EGR_PORT_EIGHT_PRIORITIES:
      *nof_priorities = 8;
      break;
    default:
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, priority type is invalid"), unit));
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_sched_init(int unit)
{
    bcm_error_t                 rc = BCM_E_NONE;
    int                         flow_id, default_port, core;
    int                         priority_i = 0;
    bcm_port_t                  port_i = 0;
    bcm_gport_t                 gport = 0;
    uint32                      res_mngr_flags = 0, nof_priorities = 0, fap_port;
    uint32                      soc_sand_rc;
    SOC_TMC_SCH_FLOW            flow_config, exact_flow_config;
    SOC_TMC_SCH_SE_INFO         se_config;
    SOC_TMC_SCH_SE_ID           se_index = 0, default_se;            
    bcm_dpp_cosq_config_t       *cosq_config;
    int                         index;
    int                         is_coldboot = TRUE;
    bcm_dpp_cosq_flow_config_t* flow_state_config;
    pbmp_t                   ports_map;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    cosq_config = &_dpp_cosq_config[unit];    

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        is_coldboot = FALSE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /* initialize FMQ class resources as not being allocated */
    for (index = 0; index < DPP_DEVICE_FMQ_CLASS_PORTS; index++) {
        cosq_config->fmq_class_ports[index] = BCM_GPORT_INVALID;
    }

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        SOC_DPP_ALLOW_WARMBOOT_WRITE(bcm_petra_cosq_restore_fmq_hr_state(unit), rc);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, fmq hr restore state failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    rc = _bcm_dpp_wb_cosq_update_ipf_mode(unit, SOC_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES);
    BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_ipf_mode_set,(unit, SOC_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
      rc = translate_sand_success_failure(soc_sand_rc);
      BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in setting ipf initial value, soc_sand error 0x%x, rc error 0x%x"), unit, soc_sand_rc, rc));
    }

    if (SOC_IS_PETRAB(unit)) {
      /* HR resources for ports. "*_WITH_ID" not currently supported. Sequencing   */
      /* ensures the initial resources are allocated                               */
      /* In Petra-B each port has one HR resource */
      for (fap_port = 0; fap_port <= SOC_TMC_SCH_MAX_PORT_ID_PETRA; fap_port++) {
          rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
          if (rc != BCM_E_NONE) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
              BCMDNX_IF_ERR_EXIT(rc);
          }
          LOG_VERBOSE(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, port(%d) hr resources, flow_id 0x%x\n"), unit, fap_port, flow_id));

          flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                                                                         &(_dpp_cosq_config[unit].flow_hd), flow_id);
      
          if (flow_state_config ==  NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, flow_id));
            rc = BCM_E_RESOURCE;
            BCMDNX_IF_ERR_EXIT(rc);
          }
          flow_state_config->weight = 0;
          flow_state_config->mode = BCM_COSQ_SP0;
      } 
    } else if (SOC_IS_ARAD(unit)) {
      /* HR resources for ports. */
      /* In ARAD each Port-TC has HR resource */
      res_mngr_flags = SHR_RES_ALLOC_WITH_ID;
      rc = soc_port_sw_db_valid_ports_get(unit, 0, &ports_map);
      if (rc != BCM_E_NONE) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, failed to get ports bmp, error 0x%x\n"), unit, rc));
              BCMDNX_IF_ERR_EXIT(rc);
          }
      BCM_PBMP_ITER(ports_map, port_i) {
          BCM_COSQ_GPORT_E2E_PORT_SET(gport, port_i); 
          rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core);
          if (rc != BCM_E_NONE) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_i, rc));
              continue;
          }
          if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "Invalid fap port %d\n"), fap_port));
              continue;
          }

          BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities));
          
          for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
          {
              soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
              if(SOC_SAND_FAILURE(soc_sand_rc)) {
                  rc = translate_sand_success_failure(soc_sand_rc);
                  BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority_i, soc_sand_rc, rc));
              }
               
              if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit))
              {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, se id retreive invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                  continue;
              }
              flow_id =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_index)));

              rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
              if (rc != BCM_E_NONE) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                  BCMDNX_IF_ERR_EXIT(rc);
              }
              LOG_VERBOSE(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, port(%d) priority(%d) hr resources, flow_id 0x%x\n"), unit, fap_port, priority_i ,flow_id));
              flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                                                                           &(_dpp_cosq_config[unit].flow_hd), flow_id);
        
              if (flow_state_config ==  NULL) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, flow_id));
                rc = BCM_E_RESOURCE;
                BCMDNX_IF_ERR_EXIT(rc);
              }
              flow_state_config->weight = 0;
              flow_state_config->mode = BCM_COSQ_SP0;
          }
      }
      res_mngr_flags = 0x0;
    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unit invalid, error 0x%x"), unit, rc));
    }

    /* additional HR resource allocated to hookup objects just created */
    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_FQ, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                                                                   &(_dpp_cosq_config[unit].flow_hd), flow_id);
    
    if (flow_state_config ==  NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, flow_id));
        rc = BCM_E_RESOURCE;
        BCMDNX_IF_ERR_EXIT(rc);
    }
    flow_state_config->weight = 0;
    flow_state_config->mode = BCM_COSQ_SP0;


    se_index =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));
    cosq_config->default_se = se_index;
    cosq_config->default_se_flow = flow_id;
    cosq_config->default_se_type = SOC_TMC_SCH_SE_TYPE_FQ;
    cosq_config->default_se_class = 0;
    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, default fq for hookup, flow_id(%d/0x%x) se_index(%d/0x%x)\n"), unit, flow_id, flow_id, se_index, se_index));

    if (is_coldboot) {
        /* get credit source */
        rc = _bcm_petra_cosq_default_port_get(unit, &default_port);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failure in getting default port (for hookup), error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
       
        if (SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            
            priority_i = 0;      
        } else {
            priority_i = DPP_COSQ_PB_DEFAULT_PORT_TC;
        }
        rc = _bcm_petra_cosq_port2se_id(unit,default_port,priority_i,&default_se);
        if (rc != BCM_E_NONE || default_se == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, unable to retreive SE for port %d"), unit, default_port));
        }

        /* hookup the reserved HR resource to the hierarchy */

        SOC_TMC_SCH_FLOW_clear(&flow_config);
        SOC_TMC_SCH_FLOW_clear(&exact_flow_config);

        flow_config.flow_type = SOC_TMC_FLOW_AGGREGATE;
        flow_config.is_slow_enabled = FALSE;
        flow_config.sub_flow[0].is_valid = TRUE;
        flow_config.sub_flow[0].id = flow_id;

        flow_config.sub_flow[0].credit_source.se_type = SOC_TMC_SCH_SE_TYPE_HR;
        flow_config.sub_flow[0].credit_source.se_info.hr.sp_class = SOC_TMC_SCH_FLOW_HR_CLASS_EF1;
        flow_config.sub_flow[0].credit_source.id = default_se;

        
        if (SOC_IS_ARAD(unit)) {
            flow_config.sub_flow[0].shaper.max_burst = 0x0;
        }

        SOC_TMC_SCH_SE_INFO_clear(&se_config);
        se_config.id = se_index;
        se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
        se_config.type = SOC_TMC_SCH_SE_TYPE_FQ;
        se_config.type_info.fq.no_info=0;
        se_config.is_dual = FALSE;
        se_config.group = SOC_TMC_SCH_GROUP_AUTO; 

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_index, &se_config, &flow_config, &exact_flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "hr", soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }

    if (is_coldboot) {
        /* state restored during warmboot */
        rc = _bcm_petra_sched_cl_profile_init(unit);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl profile init failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /*ingress scheduler init*/
    if (is_coldboot)
    {
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_init, (unit)));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    SOC_DPP_WARMBOOT_RELEASE_HW_MUTEX(rc);
    if(rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              " Failed while executing the macro SOC_DPP_WARMBOOT_RELEASE_HW_MUTEX.\n")));
    }
    BCMDNX_FUNC_RETURN;
}

/* calender based flow control reception (Inband/Out-of-band) */
STATIC int
_bcm_petra_cosq_cal_reception_fc_path_add(int unit,
                           int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target,
                           int is_fc_calender,
                           int is_fc_inband, 
                           int fc_calender_port,
                           int fc_nif_id)
{
    bcm_error_t                     rc = BCM_E_NONE;
    SOC_TMC_FC_CAL_IF_INFO          cal_if_info;
    SOC_TMC_FC_REC_CALENDAR         *cal_buff = NULL;
    SOC_TMC_FC_REC_CAL_DEST         cal_dest = SOC_TMC_FC_REC_CAL_DEST_NONE;
    SOC_TMC_FC_PFC_GENERIC_BITMAP   generic_bm;
    uint32                          soc_sand_rc;
    bcm_dpp_cosq_config_t           *cosq_config;
    bcm_dpp_cosq_rx_cal_t           *rx_cal;
    int                             is_llfc, update_entry = 0;
    int                      priority, queue_id, valid, nof_ilkn_ports;
    uint32                   flow_id, cl_id, target_id=0;
    int core=0; 

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    cosq_config = &_dpp_cosq_config[unit];  
    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);  

    BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_REC_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
    SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);

    if (is_fc_inband) {
        if (fc_calender_port >= nof_ilkn_ports) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }
        rx_cal = &cosq_config->inband_cal[fc_calender_port].rx;
    }
    else {
        if (fc_calender_port >= SOC_DPP_MAX_OOB_PORTS) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }
        rx_cal = &cosq_config->oob_cal[fc_calender_port].rx;
    }
    if ((rx_cal->valid != TRUE) && (BCM_GPORT_IS_SCHEDULER(target->port) == 0x0)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, rx calender not valid for port(%d)\n"), unit, fc_calender_port));
        rc = BCM_E_PARAM;
        goto err;
    }

    /* retrieve calender setting */
    soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_get,(unit, rx_cal->cal_mode_ndx, rx_cal->intf, &cal_if_info, cal_buff));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in %s calender(%d) retreive, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  rx_cal->intf, soc_sand_rc, rc));
        goto err;
    }

    
    if (is_fc_inband) {
        /* check it does not overlap with the LLFC calender space */
        if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[rx_cal->intf] != SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE_DISABLE) {
            if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[rx_cal->intf] == SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE1) {
                if (source->calender_index == 0) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, invalid calender index (%d), reserved for LLFC\n"), unit, source->calender_index));
                    rc = BCM_E_PARAM;
                    goto err;
                }
            }
            else if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[rx_cal->intf] == SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE2) {
                if ((source->calender_index % 16) == 0) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, invalid calender index (%d), reserved for LLFC\n"), unit, source->calender_index));
                    rc = BCM_E_PARAM;
                    goto err;
                }
            }
        }
    }

    is_llfc = (target->cosq == -1) ? TRUE : FALSE;


    if (BCM_GPORT_IS_SCHEDULER(target->port)) {

        if (!SOC_IS_ARDON(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Setting Schedualer CL as target gport (0x%x) supported only for Ardon (FCV)"), target->port));
        }

        /* 
         * Mapping FCV calander bit map to SCH CL 
         * Source is calender_index. Target is CL index. 
         * extract CL index: Target Scheduler gport =  (64 * 1024) + CL_Index * 4
         */
        flow_id = BCM_GPORT_SCHEDULER_GET(target->port);
        cl_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit, mbcm_dpp_sch_flow2se_id, (flow_id)));

        valid = is_for_delete ? 0x0 : 0x1;
        rc = arad_fc_shr_mapping(unit, source->calender_index, cl_id, 0x0 /* select */, valid);
        BCMDNX_IF_ERR_EXIT(rc);

    } else if(target->flags & BCM_COSQ_FC_RETRANSMIT)
    {
#ifdef  BCM_ARAD_SUPPORT
        if(SOC_IS_ARAD(unit))
        {
            /* ILKN Retransmit Entry */
            cal_dest = SOC_TMC_FC_REC_CAL_DEST_RETRANSMIT;
        
            target_id = fc_calender_port;

            is_llfc = FALSE;
        }
#endif
    }
    else if (is_llfc) {
        /* support LLFC setting for OOB interface. Inband Interface calender settings  */
        /* are via SOC properties.                                                     */
        if (is_fc_inband) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, LLFC setting not valid for inband interface (%d)\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }

        target_id = 0;
#ifdef  BCM_ARAD_SUPPORT
        if(SOC_IS_ARAD(unit))
        {
            bcm_port_t user_port;
            uint32 phy_port;

            cal_dest = SOC_TMC_FC_REC_CAL_DEST_NIF_LL;            

            rc = bcm_petra_cosq_user_port_get(unit, target->port, &user_port);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error retreiving user_port for gport (0x%x)\n"), unit, target->port));
                goto err;
            }

            rc = soc_port_sw_db_first_phy_port_get(unit, user_port, &phy_port /*one based*/);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error retreiving phy)port for port (0x%x)\n"), unit, target->port));
                goto err;
            }

            target_id = phy_port - 1;
        }
#endif
#ifdef  BCM_PETRAB_SUPPORT
        if(SOC_IS_PETRAB(unit))
        {
            uint32                   target_nif_id;

            cal_dest = SOC_TMC_FC_REC_CAL_DEST_NIF;

            rc = bcm_petra_cosq_port_nif_get(unit, target->port, &target_nif_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error retreiving nif_id for gport (0x%x)\n"), unit, target->port));
                goto err;
            }
            bcm_port_to_scaled_down_nif_id(unit, target_nif_id, &target_id);
        }
#endif
    }
    else { /* PFC Configuration (Not LLFC or Retransmit) */
        if (BCM_GPORT_IS_MODPORT(target->port) || BCM_COSQ_GPORT_IS_E2E_PORT(target->port) || BCM_GPORT_IS_LOCAL(target->port) ||
            BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(target->port) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(target->port)) {

#ifdef  BCM_ARAD_SUPPORT
            if(SOC_IS_ARAD(unit))
            {
                rc = _bcm_petra_cosq_cal_reception_pfc_set(unit, is_for_delete, target, cal_buff, source->calender_index, &target_id, &cal_dest, &update_entry);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in creation of PFC generic bitmap profiles \n"), unit));
                goto err;
                }
            }
#endif
            if((BCM_GPORT_IS_MODPORT(target->port) || BCM_GPORT_IS_LOCAL(target->port)) && update_entry == 0)
            {
                rc = _bcm_petra_egress_queue_from_cosq(unit, &queue_id, target->cosq);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

                rc = _bcm_petra_cosq_fap_port_get(unit, target->port, &target_id, &core);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

#ifdef  BCM_PETRAB_SUPPORT
              if(SOC_IS_PETRAB(unit))
              {
                  cal_dest = (queue_id == 0) ? SOC_TMC_FC_REC_CAL_DEST_OFP_EGQ_HP : SOC_TMC_FC_REC_CAL_DEST_OFP_EGQ_LP;
              }
#endif
#ifdef BCM_ARAD_SUPPORT
              if(SOC_IS_ARAD(unit))
              {
                  /* Check if the port has 8 queues/priorities - set DEST TYPE accordingly */
                  uint32 nof_prio;
                  rc = soc_port_sw_db_tm_port_to_out_port_priority_get(unit, target_id, 0, &nof_prio);
                  if (rc != BCM_E_NONE) {
                      goto err;
                  }

                  if(nof_prio == 8)

                  {
                      cal_dest = SOC_TMC_FC_REC_CAL_DEST_PORT_8_PRIORITY;
                  }
                  else
                  {
                      cal_dest = SOC_TMC_FC_REC_CAL_DEST_PORT_2_PRIORITY;
                  }
                  /* When destination is PORT, Target ID should be the base queue-pair */

                  rc = soc_port_sw_db_tm_port_to_base_q_pair_get((unit), core, target_id, &target_id);
                  if (rc != BCM_E_NONE) {
                      goto err;
                  }
              }
#endif
            }
            else if (update_entry == 0 && (BCM_COSQ_GPORT_IS_E2E_PORT(target->port) ||
                      BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(target->port) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(target->port))) {
                rc = _bcm_dpp_cosq_internal_priority_get(unit, target->priority, &priority);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

                rc = _bcm_petra_cosq_fap_port_get(unit, target->port, &target_id, &core);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

#ifdef  BCM_PETRAB_SUPPORT
                if(SOC_IS_PETRAB(unit))
                {
                    cal_dest = (priority == 0) ? SOC_TMC_FC_REC_CAL_DEST_OFP_SCH_HR_HP : SOC_TMC_FC_REC_CAL_DEST_OFP_SCH_HR_LP;
                }
#endif
#ifdef  BCM_ARAD_SUPPORT
                if(SOC_IS_ARAD(unit))
                {
                    cal_dest = SOC_TMC_FC_REC_CAL_DEST_PFC;

                    /* When destination is PFC, Target ID should be the queue-pair */

                    rc = soc_port_sw_db_tm_port_to_base_q_pair_get((unit), core, target_id, &target_id);
                    if (rc != BCM_E_NONE) {
                        goto err;
                    }

                    target_id += target->cosq;

                } /* SOC_IS_ARAD(unit) */
#endif /* BCM_ARAD_SUPPORT */       
            }
        }
        else {
            rc = BCM_E_PARAM;
            goto err;
        }
    }

      /* Delete only */
      if (is_for_delete) {
          cal_dest = SOC_TMC_FC_REC_CAL_DEST_NONE;
      }

    /* update calender entry */
    (cal_buff + source->calender_index)->destination = cal_dest;
    (cal_buff + source->calender_index)->id = target_id;

    soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_set,(unit, rx_cal->cal_mode_ndx, rx_cal->intf, &cal_if_info, cal_buff));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in %s calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"), rx_cal->intf, soc_sand_rc, rc));
        goto err;
    }

err:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }

    return(rc);
exit:
    BCM_FREE(cal_buff);
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cal_reception_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count              /* INOUT */
                                           )
{
    bcm_error_t              rc = BCM_E_NONE;
    SOC_TMC_FC_CAL_IF_INFO        cal_if_info;
    SOC_TMC_FC_REC_CALENDAR      *cal_buff = NULL;
    uint32                   soc_sand_rc;
    bcm_dpp_cosq_config_t   *cosq_config;
    int                      cal_index, nof_ilkn_ports;
    bcm_dpp_cosq_rx_cal_t   *rx_cal;
#ifdef BCM_ARAD_SUPPORT
    SOC_TMC_FC_REC_CAL_DEST       cal_dest = SOC_TMC_FC_REC_CAL_DEST_NONE;
    uint32                   dev_id;
    int                      internal_target_id;
    uint32                   target_nif_id;
    int                      queue_id;
    SOC_TMC_FC_PFC_GENERIC_BITMAP generic_bm;
    int bm_tmp, generic_bm_id;
    uint8                 queue_found = FALSE;
    uint32                    fap_port = 0, tc = 0;
    soc_port_t port;
#endif
    int                     core=0; 
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);

    /* Init values */
    cosq_config = &_dpp_cosq_config[unit];    
#ifdef BCM_ARAD_SUPPORT
    dev_id =  (unit);
#endif

    BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_REC_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);
    for (cal_index = 0; cal_index < SOC_PETRA_FC_OOB_CAL_LEN_MAX; cal_index++) {
        SOC_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
    }

    if (is_fc_inband) {
        if (fc_calender_port >= nof_ilkn_ports) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }
        rx_cal = &cosq_config->inband_cal[fc_calender_port].rx;
    }
    else {
        if (fc_calender_port >= SOC_DPP_MAX_OOB_PORTS) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }
        rx_cal = &cosq_config->oob_cal[fc_calender_port].rx;
    }
    if (rx_cal->valid != TRUE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, rx calender not valid for port(%d)\n"), unit, fc_calender_port));
        rc = BCM_E_PARAM;
        goto err;
    }

    /* Get Calender setting */
    soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_get,(unit, rx_cal->cal_mode_ndx, rx_cal->intf, &cal_if_info, cal_buff));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in %s calender(%d) retreive, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  rx_cal->intf, soc_sand_rc, rc));
        goto err;
    }

    if ( (source->calender_index < 0) || (source->calender_index >= cal_if_info.cal_len) ) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, out of range calender index (%d)\n"), unit, source->calender_index));
        rc = BCM_E_PARAM;
        goto err;
    }

#ifdef BCM_ARAD_SUPPORT
    /* Calendar entry is according to SOURCE, so we have only one target */
    cal_dest = cal_buff[source->calender_index].destination;
    internal_target_id = cal_buff[source->calender_index].id;
#endif

    if(*target_count >= max_target) goto err;

#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit))
    {
      if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_RETRANSMIT)
      {
        target[*target_count].flags = BCM_COSQ_FC_RETRANSMIT;
        
        /* Internal NIF to NIF ID (Retransmit is ILKN) */
        target_nif_id = arad_nif_intern2nif_id(dev_id, ARAD_NIF_TYPE_ILKN, internal_target_id);
        
        /* NIF ID to GPORT */
        rc = bcm_petra_cosq_nif_to_gport_get(unit, target_nif_id , &target[*target_count].port);
        BCMDNX_IF_ERR_EXIT(rc);

        *target_count += 1;
      }
      else if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_NIF_LL)
      {
        target[*target_count].cosq = -1;
        
        /* Convert internal to NIF ID */
        target_nif_id = arad_nif_intern2nif_id(dev_id, ARAD_NIF_TYPE_ILKN, cal_buff[source->calender_index].id);
        
        /* NIF ID to GPORT */
        rc = bcm_petra_cosq_nif_to_gport_get(unit, target_nif_id , &target[*target_count].port);
        BCMDNX_IF_ERR_EXIT(rc);

        *target_count += 1;
      }
      else if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC)
      {
        generic_bm_id = cal_buff[source->calender_index].id;

        /* Get the current Profile */
        rc = _bcm_dpp_am_template_fc_generic_pfc_mapping_data_get(unit, generic_bm_id, &generic_bm); 
        BCMDNX_IF_ERR_EXIT(rc);

        for(queue_id = 0; queue_id < SOC_TMC_FC_PFC_GENERIC_BITMAP_SIZE; queue_id++)
        {
          bm_tmp = generic_bm.bitmap[queue_id / 32];
          if(bm_tmp & SOC_SAND_BIT(queue_id % 32))
          {
            /* Queue Pair to FAP Port / TC */
            soc_sand_rc = arad_egr_queuing_q_pair_port_tc_find(dev_id, queue_id, &queue_found, &fap_port, &tc);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            /* FAP Port to Local Port */
            rc = soc_port_sw_db_tm_to_local_port_get(unit, core, fap_port, &port);
            BCMDNX_IF_ERR_EXIT(rc);
            
            /* Local Port to GPORT */
            BCM_GPORT_LOCAL_SET(target[*target_count].port, port);
            
            target[*target_count].cosq = tc;


            *target_count += 1;
            if(*target_count >= max_target) goto err;
          }
        } /* queue_id loop */        
      }
      else if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_PFC)
      {
        /* Queue Pair to FAP Port / TC */
        soc_sand_rc = arad_egr_queuing_q_pair_port_tc_find(dev_id, cal_buff[source->calender_index].id, &queue_found, &fap_port, &tc);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        /* FAP Port to Local Port */
        rc = soc_port_sw_db_tm_to_local_port_get(unit, core, fap_port, &port);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Local Port to GPORT */
        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

        target[*target_count].cosq = tc;
        *target_count += 1;
      }
      else if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_PORT_8_PRIORITY || cal_dest == SOC_TMC_FC_REC_CAL_DEST_PORT_2_PRIORITY)
      {     
        /* FAP Port to Local Port */
        rc = soc_port_sw_db_tm_to_local_port_get(unit, core, cal_buff[source->calender_index].id, &port);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Local Port to GPORT */
        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

        *target_count += 1;
      }
    }/* SOC_IS_ARAD */
#endif

err:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }

    return(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef  BCM_ARAD_SUPPORT

/* Arad only
 * Handles the creation of PFC Generic Bitmap Profiles.
 * Relevant when adding more than one destination to the same entry 
 * when the destination is PFC or PORT */
STATIC int
_bcm_petra_cosq_cal_reception_pfc_set(int unit, 
                                      int is_for_delete,
                                      bcm_cosq_fc_endpoint_t *target,
                                      SOC_TMC_FC_REC_CALENDAR *cal_buff,
                                      int cal_index,
                                      uint32 *target_id,                 /* Out */
                                      SOC_TMC_FC_REC_CAL_DEST *cal_dest,  /* Out */
                                      int *update_entry)              /* Out - indicates if we updated an entry */

{
    bcm_error_t                     rc = BCM_E_NONE;
    SOC_TMC_FC_PFC_GENERIC_BITMAP   generic_bm;
    int                             generic_bm_id = 0, generic_bm_is_allocated = 0, new_generic_bm_id = -1;
    int                             pfc_bit_index = 0, core;
    int                             nof_bits = 1, bit;
    uint32                          base_q_pair, target_port;

    BCMDNX_INIT_FUNC_DEFS;

    generic_bm_is_allocated = 0;

    SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);

    /* This function is for Arad only (used by _bcm_petra_cosq_cal_reception_fc_path_add) */
    if(!SOC_IS_ARAD(unit))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Arad Only"))); 
    }

    /* Check if the current entry is a PFC Generic Bitmap Mapping Profile*/
    if ((cal_buff + cal_index)->destination == SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC)
    {
        generic_bm_id = (cal_buff + cal_index)->id;

        /* Check the entry destination id is valid */
        if(generic_bm_id >= SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps))
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Invalid Calendar Entry")));
        }

        /* Get the current Profile */
        rc = _bcm_dpp_am_template_fc_generic_pfc_mapping_data_get(unit, generic_bm_id, &generic_bm); 
        BCMDNX_IF_ERR_EXIT(rc);
    
        *update_entry = 1;
    }
    /* Check if we need to create a PFC Generic Bitmap Mapping Profile */
    else if ((cal_buff + cal_index)->destination == SOC_TMC_FC_REC_CAL_DEST_PORT_8_PRIORITY ||
           (cal_buff + cal_index)->destination == SOC_TMC_FC_REC_CAL_DEST_PORT_2_PRIORITY ||
           (cal_buff + cal_index)->destination == SOC_TMC_FC_REC_CAL_DEST_PFC)
    {
        /* Create a new Profile  */
        generic_bm_id = SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps);

        *update_entry = 1;

        switch ((cal_buff + cal_index)->destination)
        {
        case SOC_TMC_FC_REC_CAL_DEST_PORT_8_PRIORITY:
          nof_bits = 8;
          break;
        case SOC_TMC_FC_REC_CAL_DEST_PORT_2_PRIORITY:
          nof_bits = 2;
          break;
        case SOC_TMC_FC_REC_CAL_DEST_PFC:
        default:
          nof_bits = 1;
        }
    }

    if(*update_entry == 1)
    {   
        /* Calculate the PFC bit according to target's port and cosq*/
        rc = _bcm_petra_cosq_fap_port_get(unit, target->port, &target_port, &core);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_tm_port_to_base_q_pair_get((unit), core, target_port, &base_q_pair);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Update the existing Profile with the new data */
        for(bit = 0; bit < nof_bits; bit++)
        {

          /* PFC BIT = Queue Pair = Base Queue + TC */
          pfc_bit_index = base_q_pair + target->cosq + bit;


          if(pfc_bit_index >= SOC_TMC_FC_PFC_GENERIC_BITMAP_SIZE || pfc_bit_index < 0)
          {
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid Port/Cosq for PFC")));
          }

          generic_bm.bitmap[pfc_bit_index / 32] = generic_bm.bitmap[pfc_bit_index / 32] | SOC_SAND_BIT(pfc_bit_index % 32);
        }

    /* Delete only */
    if (is_for_delete) {
        SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
    }

    rc = _bcm_dpp_am_template_fc_generic_pfc_mapping_exchange(unit, generic_bm_id, &generic_bm, NULL, &new_generic_bm_id, &generic_bm_is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

        /* Update HW if needed */
        if(generic_bm_is_allocated)
        {
            rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, new_generic_bm_id, &generic_bm);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    *target_id = new_generic_bm_id;
    *cal_dest = SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC;

exit:
    BCMDNX_FUNC_RETURN;
}

#endif

STATIC int _bcm_petra_cosq_pfc_bitmap_get(int unit, 
                                          uint32 flags, 
                                          bcm_port_t port, 
                                          bcm_cos_queue_t cosq, 
                                          SOC_TMC_FC_PFC_GENERIC_BITMAP *generic_bm)
{
    bcm_error_t rc = BCM_E_NONE;

    uint32 base_queue_pair, nof_priorities;
    soc_pbmp_t same_interface_ports;
    soc_port_t port_i;

    BCMDNX_INIT_FUNC_DEFS;

    /* Mapping PFC source to port target */
    if (flags & BCM_COSQ_FC_PORT_OVER_PFC) {
        /* get base queue and nof priorities of port */
        rc = soc_port_sw_db_base_q_pair_get(unit, port, &base_queue_pair);
        SOCDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
        SOCDNX_IF_ERR_EXIT(rc);

        SHR_BITSET_RANGE(generic_bm->bitmap, base_queue_pair, nof_priorities);
    }
    /* Mapping PFC source to relevant priority in all ports on same interface */
    else if (flags & BCM_COSQ_FC_INTF_COSQ_PFC) {
        /* get all the local port belong to specific interface */
        rc = soc_port_sw_db_ports_to_same_interface_get(unit, port, &same_interface_ports);
        SOCDNX_IF_ERR_EXIT(rc);

        SOC_PBMP_ITER(same_interface_ports, port_i) {
            /* get base queue of each port */
            rc = soc_port_sw_db_base_q_pair_get(unit, port, &base_queue_pair);
            SOCDNX_IF_ERR_EXIT(rc);

            rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
            SOCDNX_IF_ERR_EXIT(rc);

            if (cosq > nof_priorities) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, cosq (%d) out of range [0, %d]\n"), unit, cosq, (nof_priorities-1)));
            }

            SHR_BITSET_RANGE(generic_bm->bitmap, base_queue_pair + cosq, 1);
        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x)"), unit, flags));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* non-calender based flow control reception (Inband) */
STATIC int
_bcm_petra_cosq_noncal_reception_fc_path_add(int unit,
                                             int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target,
                           int is_fc_calender,
                           int is_fc_inband, 
                           int fc_calender_port,
                           int fc_nif_id)
{
    bcm_error_t rc = BCM_E_NONE;
    int is_llfc;
    int is_channelization_ability, no_classes, no_queues;
    uint32 target_nif_id, fap_port;
    uint32 soc_sand_rc;
    SOC_TMC_FC_REC_INBND_INFO inbnd_info;
    int priority, queue_id, core;
    int is_safc = 0;
    bcm_dpp_cosq_config_t *cosq_config;
    uint32 internal_id = 0;
    uint32 is_channalzied;
    uint32 tm_port;
    SOC_TMC_FC_PFC_GENERIC_BITMAP generic_bm;
    int old_generic_bm_id = 0, generic_bm_is_last = 0, new_generic_bm_id = -1, generic_bm_is_allocated = 0;
    SOC_TMC_FC_PFC_MAP pfc_map;
    bcm_port_t src_user_port = 0;
    uint32 phy_port = 0;
    int cosq_index = 0, cosq_start = 0, cosq_end = 0;
    bcm_dpp_cosq_pfc_rx_type_t cur_pfc_type;
    uint32 nof_priorities;

    BCMDNX_INIT_FUNC_DEFS;

    cosq_config = &_dpp_cosq_config[unit]; 

    SOC_TMC_FC_REC_INBND_INFO_clear(&inbnd_info);

    is_llfc = (source->cosq == -1) ? TRUE : FALSE;

    if ((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) || 
        (target->flags & BCM_COSQ_FC_INTF_COSQ_PFC)) {
        /* check paramemters*/
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }

        if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, target flag *_IMPLICIT not specified\n"), unit));
        }

        if (target->flags & ~(BCM_COSQ_FC_PORT_OVER_PFC | BCM_COSQ_FC_INTF_COSQ_PFC | BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
        }

        if ((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) && (target->flags & BCM_COSQ_FC_INTF_COSQ_PFC)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x) : BCM_COSQ_FC_PORT_OVER_PFC and BCM_COSQ_FC_INTF_COSQ_PFC cannot be used together\n"), unit, target->flags));
        }

        if (target->port != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unexpected target port (0x%x)\n"), unit, target->port));
        }

        if (target->cosq != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target cosq (0x%x)\n"), unit, target->cosq));
        }

        /* get tm port, core and interface */
        rc = bcm_petra_cosq_user_port_get(unit, source->port, &src_user_port);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_out_port_priority_get(unit, src_user_port, &nof_priorities);
        SOCDNX_IF_ERR_EXIT(rc);
            
        if (target->flags & BCM_COSQ_FC_PORT_OVER_PFC) {
            if (source->cosq == -1) {
                cosq_start = 0;
                cosq_end = SOC_TMC_EGR_NOF_Q_PRIO_ARAD;
            }
            else {
                if ((source->cosq < 0 ) || (source->cosq >= SOC_TMC_EGR_NOF_Q_PRIO_ARAD)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source cosq (%d) out of range [0, %d]"), unit, source->cosq, (SOC_TMC_EGR_NOF_Q_PRIO_ARAD - 1)));
                }
                cosq_start = source->cosq;
                cosq_end = source->cosq + 1;
            }

            cur_pfc_type = _BCM_DPP_COSQ_PFC_RX_PORT_OVER;
        }
        else {
            if ((source->cosq < 0 ) || (source->cosq >= nof_priorities)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source cosq (%d) out of range [0, %d]"), unit, source->cosq, (nof_priorities - 1)));
            }
            cosq_start = source->cosq;
            cosq_end = source->cosq + 1;

            cur_pfc_type = _BCM_DPP_COSQ_PFC_RX_INTF_COSQ;
        }

        rc = soc_port_sw_db_local_to_tm_port_get(unit, src_user_port, &tm_port, &core);
        SOCDNX_IF_ERR_EXIT(rc);

        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_is_channelized, (unit, core, tm_port, &is_channalzied));
        BCMDNX_IF_ERR_EXIT(rc);

        if ((target->flags & BCM_COSQ_FC_INTF_COSQ_PFC) && (is_channalzied == 0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Setting BCM_COSQ_FC_INTF_COSQ_PFC supported only for channalized port"), unit));
        }

        if ((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) && (source->cosq == -1) && (is_channalzied != 0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Setting BCM_COSQ_FC_PORT_OVER_PFC with source.cosq = -1 supported only for non-channalized port"), unit));
        }

        rc = soc_port_sw_db_first_phy_port_get(unit, src_user_port, &phy_port);
        SOCDNX_IF_ERR_EXIT(rc);
        internal_id = phy_port - 1;

        /*
         * check if current pfc map type conflict with existing configuration 
         * only one pfc map type can be configured on the same interface
         */
        if ((cosq_config->rx_pfc_map_info[internal_id] != _BCM_DPP_COSQ_PFC_RX_NONE) && 
            (cosq_config->rx_pfc_map_info[internal_id] != _BCM_DPP_COSQ_PFC_RX_DEFAULT) &&
            (cosq_config->rx_pfc_map_info[internal_id] != cur_pfc_type)) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("unit %d, unexpected pfc map type(%d) conflict with existing pfc map type(%d)\n"), unit,
                cur_pfc_type, cosq_config->rx_pfc_map_info[internal_id]));
        }


        /* set info of pfc generic bitmap */
        SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
        if (!is_for_delete) {
            rc = _bcm_petra_cosq_pfc_bitmap_get(unit, (target->flags & (BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_INTF_COSQ_PFC)), 
                src_user_port, source->cosq, &generic_bm);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        for (cosq_index = cosq_start; cosq_index < cosq_end; cosq_index++) {
            /* get info of pfc mapping from HW */
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_mapping_get, (unit, internal_id, cosq_index, &pfc_map));
            BCMDNX_IF_ERR_EXIT(rc);

            if (pfc_map.mode == SOC_TMC_FC_PFC_MAP_GENERIC_BITMAP) {
                old_generic_bm_id = pfc_map.index;
            }
            else {
                old_generic_bm_id = SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps);
            }

            rc = _bcm_dpp_am_template_fc_generic_pfc_mapping_exchange(unit, old_generic_bm_id, &generic_bm, &generic_bm_is_last, &new_generic_bm_id, &generic_bm_is_allocated);
            BCMDNX_IF_ERR_EXIT(rc);

            /* set HW for new pfc generic bitmap if needed*/
            if(generic_bm_is_allocated)
            {
                rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, new_generic_bm_id, &generic_bm);
                BCMDNX_IF_ERR_EXIT(rc);
            }

            /* set HW for old pfc generic bitmap if needed*/
            if (generic_bm_is_last && 
                (old_generic_bm_id != new_generic_bm_id) &&
                (old_generic_bm_id >= 0) && 
                (old_generic_bm_id < SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps))) {
                SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, old_generic_bm_id, &generic_bm);
                BCMDNX_IF_ERR_EXIT(rc);
            }

            /* set info of pfc mapping */
            if (!is_for_delete) {
                pfc_map.mode = SOC_TMC_FC_PFC_MAP_GENERIC_BITMAP;
                pfc_map.index = new_generic_bm_id;
                pfc_map.valid = 1;
            }
            else {
                pfc_map.mode = SOC_TMC_FC_PFC_MAP_EGQ;
                pfc_map.index = internal_id * SOC_TMC_EGR_NOF_Q_PRIO_ARAD + cosq_index;
                pfc_map.valid = 1;
            }

            /* set HW for pfc mapping */
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_mapping_set, (unit, internal_id, cosq_index, &pfc_map));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        if (!is_for_delete) {
            cosq_config->rx_pfc_map_info[internal_id] = cur_pfc_type;
        }
        else {
            cosq_config->rx_pfc_map_info[internal_id] = _BCM_DPP_COSQ_PFC_RX_NONE;
        }
#ifdef BCM_WARM_BOOT_SUPPORT
        rc = _bcm_dpp_wb_cosq_update_pfc_rx_type_data(unit, internal_id);
        BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */

    }
    else if (is_llfc) { /* LLFC */
        /* consistency checks */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)"), unit, source->flags));
        }
        if ((target->flags & ~(BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)"), unit, target->flags));
        }
        if (!(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
            rc = bcm_petra_cosq_port_nif_get(unit, target->port, &target_nif_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error retreiving nif_id for gport (0x%x)\n"), unit, target->port));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            if (fc_nif_id != target_nif_id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source nif_id(0x%x) and target nif_id (0x%x) do not match"), unit, fc_nif_id, target_nif_id));
            }
            if (target->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq specified(0x%x)"), unit, target->cosq));
            }
        }

        inbnd_info.mode = SOC_TMC_FC_INBND_MODE_LL;

        /* Delete only */
        if (is_for_delete) {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_DISABLED;
        }

        soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_inbnd_set,(unit, fc_nif_id, &inbnd_info));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to config LLFC nif_id(%d), soc_sand error 0x%x\n"), unit, fc_nif_id, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }
    else {
        /* consistency checks */
        if ( !(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(target->port) ||
               BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(target->port) ||
               BCM_GPORT_IS_MODPORT(target->port) || BCM_GPORT_IS_LOCAL(target->port)) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unexpected gport (0x%x) for CBFC target"), unit, target->port));
        }
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) for CBFC"), unit, source->flags));
        }
        if ((target->flags & ~(BCM_COSQ_FC_INHERIT_UP | BCM_COSQ_FC_INHERIT_DOWN)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x) for CBFC"), unit, target->flags));
        }
        if ((target->flags & BCM_COSQ_FC_INHERIT_UP) && (target->flags & BCM_COSQ_FC_INHERIT_DOWN)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x) for CBFC"), unit, target->flags));
        }

        rc = bcm_petra_cosq_port_info_get(unit, target->port, &is_channelization_ability,
                                                         &no_classes, &target_nif_id, &no_queues);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error retreiving target port info(0x%x)\n"), unit, target->port));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if ((source->cosq < 0 ) || (source->cosq >= no_classes)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source cosq (%d) out of range"), unit, source->cosq));
        }

        rc = _bcm_petra_egress_queue_from_cosq(unit, &queue_id, target->cosq);
        BCMDNX_IF_ERR_EXIT(rc);
        if ((queue_id < 0) || (queue_id >= no_queues)) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, queue id (%d) out of range"), unit, queue_id));
        }

        rc = _bcm_dpp_cosq_egress_cosq_inband_fc_priority_get(unit, target->cosq, &priority);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_petra_cosq_fap_port_get(unit, target->port, &fap_port, &core);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = bcm_petra_cosq_port_nif_get(unit, target->port, &target_nif_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error retreiving nif_id for gport (0x%x)\n"), unit, target->port));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fc_nif_id != target_nif_id) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source nif_id(0x%x) and target nif_id (0x%x) do not match"), unit, fc_nif_id, target_nif_id));
        }

        rc = bcm_petra_cosq_user_port_get(unit, source->port, &src_user_port);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_first_phy_port_get(unit, src_user_port, &phy_port);
        SOCDNX_IF_ERR_EXIT(rc);
        internal_id = phy_port - 1;
        /*
         * check if current pfc map type conflict with existing configuration 
         * only one pfc map type can be configured on the same interface
         */
        if ((cosq_config->rx_pfc_map_info[internal_id] != _BCM_DPP_COSQ_PFC_RX_NONE) &&
            (cosq_config->rx_pfc_map_info[internal_id] != _BCM_DPP_COSQ_PFC_RX_DEFAULT)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("unit %d, unexpected pfc map type conflict with existing config\n"), unit));
        }

        rc = bcm_port_control_get(unit, fap_port, bcmPortControlSAFCReceive, &is_safc);
        BCMDNX_IF_ERR_EXIT(rc);

        if(is_safc)
        {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_SAFC;
        }
        else
        {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_PFC;
        }

        if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
            inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_UP;
        }
        else if (target->flags & BCM_COSQ_FC_INHERIT_DOWN) {
            inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_DOWN;
        }
        else {
            inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_DISABLED;
        }
        
        /* Delete only */
        if (is_for_delete) {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_DISABLED;
        }

        soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_inbnd_set,(unit, target_nif_id, &inbnd_info));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to config CBFC nif_id(%d), soc_sand error 0x%x\n"), unit, target_nif_id, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }

        if (!is_for_delete) {
            cosq_config->rx_pfc_map_info[internal_id] = _BCM_DPP_COSQ_PFC_RX_DEFAULT;
        }
        else {
            cosq_config->rx_pfc_map_info[internal_id] = _BCM_DPP_COSQ_PFC_RX_NONE;
        }
#ifdef BCM_WARM_BOOT_SUPPORT
        rc = _bcm_dpp_wb_cosq_update_pfc_rx_type_data(unit, internal_id);
        BCMDNX_IF_ERR_EXIT(rc);
#endif /* BCM_WARM_BOOT_SUPPORT */
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_noncal_reception_fc_path_get(int unit,
                                             bcm_cosq_fc_direction_type_t fc_direction,
                                             bcm_cosq_fc_endpoint_t *source,
                                             int max_target,
                                             bcm_cosq_fc_endpoint_t *target, /* OUT */
                                             int *target_count               /* OUT */
                                             )
{
    bcm_error_t rc = BCM_E_NONE;
    int is_llfc;
    SOC_TMC_FC_REC_INBND_INFO inbnd_info;
    uint32 target_nif_id, soc_sand_rc;
    ARAD_NIF_TYPE            nif_type;
    int internal_target_id;
    bcm_dpp_cosq_config_t *cosq_config;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_FC_REC_INBND_INFO_clear(&inbnd_info);

    is_llfc = (source->cosq == -1) ? TRUE : FALSE;

    if(*target_count >= max_target) goto exit;

    if (!is_llfc) 
    {
        soc_port_t port;
        uint32 dev_id;

        cosq_config = &_dpp_cosq_config[unit]; 
        
        /* Check all interfaces for FC configuration */
        for(internal_target_id = 0; internal_target_id < 32; internal_target_id++)
        {
          /* Get the NIF Type */
          port = SOC_INFO(unit).port_p2l_mapping[internal_target_id+1];
          soc_sand_rc = arad_port_to_nif_type(unit, port, &nif_type);
          if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error in retreiving nif type, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
              BCMDNX_IF_ERR_EXIT(rc);
          }

          /* Convert internal to NIF ID */
          dev_id = unit;
          target_nif_id = arad_nif_intern2nif_id(dev_id, nif_type, internal_target_id);
          if (target_nif_id == SOC_TMC_NIF_ID_NONE || target_nif_id == SOC_TMC_IF_ID_CPU ||
              target_nif_id == SOC_TMC_IF_ID_OLP || target_nif_id == SOC_TMC_IF_ID_RCY ||
              target_nif_id == SOC_TMC_IF_ID_ERP || target_nif_id == SOC_TMC_IF_ID_OAMP) {
            continue;
          }

          /* Get FC Configuration */
          soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_inbnd_get,(unit, target_nif_id, &inbnd_info));
          if (SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to config CBFC nif_id(%d), soc_sand error 0x%x\n"), unit, target_nif_id, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
          }

          /* Target is relevant only for PFC */
          if(inbnd_info.mode == SOC_TMC_FC_INBND_MODE_PFC || inbnd_info.mode == SOC_TMC_FC_INBND_MODE_SAFC)
          {

            if (cosq_config->rx_pfc_map_info[internal_target_id] == _BCM_DPP_COSQ_PFC_RX_PORT_OVER) {
              target[*target_count].flags = BCM_COSQ_FC_PORT_OVER_PFC;
            }
            else if (cosq_config->rx_pfc_map_info[internal_target_id] == _BCM_DPP_COSQ_PFC_RX_INTF_COSQ) {
              target[*target_count].flags = BCM_COSQ_FC_INTF_COSQ_PFC;
            }
            else {
              if (inbnd_info.pfc.inherit == SOC_TMC_FC_INBND_PFC_INHERIT_UP) {
                target[*target_count].flags = BCM_COSQ_FC_INHERIT_UP;
              }
              else if (inbnd_info.pfc.inherit == SOC_TMC_FC_INBND_PFC_INHERIT_DOWN) {
                target[*target_count].flags = BCM_COSQ_FC_INHERIT_DOWN;
              }
            }

            /* NIF ID to GPORT */
            rc = bcm_petra_cosq_nif_to_gport_get(unit, target_nif_id , &target[*target_count].port);
            BCMDNX_IF_ERR_EXIT(rc);

            *target_count += 1;
            if(*target_count >= max_target) goto exit;
          }
        }/* internal id loop */
    }
      
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* retrieve VSQ information */
STATIC int
_bcm_petra_cosq_vsq_info_get(int unit, bcm_gport_t vsq, bcm_cosq_vsq_info_t *vsq_info)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_type, vsq_type_info;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(vsq_info);
    
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport type is not vsq (0x%x)"), unit, vsq));
    }

    vsq_type = BCM_COSQ_GPORT_VSQ_TYPE_GET(vsq);
    vsq_type_info = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GET(vsq);

    vsq_info->flags = vsq_type;

    if (vsq_type & (BCM_COSQ_VSQ_CT)) {
      vsq_info->ct_id = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPA_CATEGORY_GET(vsq_type_info);
    } else if (vsq_type & (BCM_COSQ_VSQ_CTTC)) {
      vsq_info->ct_id = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_CATEGORY_GET(vsq_type_info);
      vsq_info->traffic_class = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(vsq_type_info);          
    } else if (vsq_type & (BCM_COSQ_VSQ_CTCC)) {
      vsq_info->ct_id = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPC_CATEGORY_GET(vsq_type_info);
      vsq_info->cc_id = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPC_CONNECTION_GET(vsq_type_info);      
    } else if (vsq_type & (BCM_COSQ_VSQ_PP)) {
      vsq_info->pp_vsq_id = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPD_STATISTICS_TAG_GET(vsq_type_info);
    } else if (vsq_type & (BCM_COSQ_VSQ_PFC)){
      vsq_info->src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_SRC_PORT_GET(vsq_type_info);
      vsq_info->traffic_class = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_TC_GET(vsq_type_info);
    } else if (vsq_type & (BCM_COSQ_VSQ_LLFC)) {
      vsq_info->src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPF_SRC_PORT_GET(vsq_type_info);      
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* given a interface retreive inband flow control information for that interface */
/* (SOC_PB_FC_GEN_INBND_INFO sructure)                                               */
STATIC int
_bcm_petra_cosq_interface_fc_info_get(int unit, bcm_gport_t port, uint32 *nif_id,
                                      SOC_TMC_FC_GEN_INBND_INFO *inbnd_info)
{
    bcm_error_t  rc = BCM_E_NONE;
    uint32       soc_sand_rc;


    BCMDNX_INIT_FUNC_DEFS;

    if ( !(BCM_GPORT_IS_MODPORT(port) || BCM_GPORT_IS_LOCAL(port) || !(BCM_GPORT_IS_SET(port))) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid port type for (0x%x)"), unit, port));
    }

    rc = bcm_petra_cosq_port_nif_get(unit, port, nif_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error retreiving nif_id for gport (0x%x)\n"), unit, port));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_get,(unit, (*nif_id), inbnd_info));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, nif_id %d, error in retreiving inband interface flow control info, soc_sand error 0x%x, error 0x%x\n"), unit, (*nif_id), soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* given a VSQ retreive inband flow control information for an interface         */
/* (SOC_PB_FC_GEN_INBND_INFO structure)                                              */
STATIC int
_bcm_petra_cosq_vsq_fc_info_get(int unit, bcm_gport_t vsq_port, uint32 *nif_id,
                                                  SOC_TMC_FC_GEN_INBND_INFO *inbnd_info)
{
    bcm_error_t          rc = BCM_E_NONE;
    bcm_cosq_vsq_info_t  vsq_info;


    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_vsq_info_get(unit, vsq_port, &vsq_info); 
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_interface_fc_info_get(unit, vsq_info.src_port, nif_id, inbnd_info);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_interface_fc_info_set(int unit, 
                                      int is_for_delete,
                                      uint32 nif_id,
                                      SOC_TMC_FC_GEN_INBND_INFO *inbnd_info)
{
    bcm_error_t  rc = BCM_E_NONE;
    uint32       soc_sand_rc;


    BCMDNX_INIT_FUNC_DEFS;

    /* Delete only */
    if (is_for_delete) {
        inbnd_info->mode = SOC_TMC_FC_INBND_MODE_DISABLED;
    }

    soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_set,(unit, nif_id, inbnd_info));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, nif_id %d, error in configuring inband interface flow control info, soc_sand error 0x%x, error 0x%x\n"), unit, nif_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* calender based flow control generation (Inband/Out-of-band) */
STATIC int
_bcm_petra_cosq_cal_generation_fc_path_add(int unit,
                                                               int is_for_delete,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           bcm_cosq_fc_endpoint_t *target,
                                           bcm_cosq_vsq_info_t *vsq_info,
                                           int is_fc_calender,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int fc_nif_id)                       /* not used */
{
    bcm_error_t              rc = BCM_E_NONE;
    bcm_dpp_cosq_tx_cal_t   *tx_cal = NULL;
    SOC_TMC_FC_CAL_IF_INFO       cal_if_info;
    SOC_TMC_FC_GEN_CALENDAR      *cal_buff = NULL;
    uint32                   soc_sand_rc;
    bcm_dpp_cosq_config_t   *cosq_config;
    int                      priority;
    /*int                      cal_index;*/
    SOC_TMC_FC_GEN_CAL_SRC       cal_src = 0;
    int                      cal_id[4], cal_id_entries = 0, cur_entry;
    int                      restore = FALSE;
    bcm_dpp_cosq_vsq_type_t  vsq_group_type;
    SOC_TMC_ITM_VSQ_GROUP        soc_tmcvsq_group;
    int                      vsq_index, nof_ilkn_ports;
    SOC_TMC_ITM_VSQ_NDX          vsq_id = 0;
    uint32 nif_id;
    uint32 target_id;

    
#ifdef  BCM_ARAD_SUPPORT
    SOC_TMC_FC_PFC_GENERIC_BITMAP hcfc_bitmap;
    int bit, bitmap_index;
    int delete_hcfc_entry = 0, i;
#endif
    

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);

    cosq_config = &_dpp_cosq_config[unit];    

#ifdef  BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit))
    {
        cal_src = SOC_TMC_FC_GEN_CAL_SRC_CONST;
        cal_id[0] = 0;
    }
#endif
#ifdef  BCM_PETRAB_SUPPORT
    if(SOC_IS_PETRAB(unit))
    {   
        cal_src = SOC_TMC_FC_GEN_CAL_SRC_NONE;
    }
#endif
    

    BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_GEN_CALENDAR) * SOC_PETRA_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);

    /* consistency checks */
    if (is_fc_inband) {
        if (fc_calender_port >= nof_ilkn_ports) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }
        tx_cal = &cosq_config->inband_cal[fc_calender_port].tx;
    }
    else {
        if (fc_calender_port >= SOC_DPP_MAX_OOB_PORTS) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }
        tx_cal = &cosq_config->oob_cal[fc_calender_port].tx;
    }
    if (tx_cal->valid != TRUE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, tx calender not valid for port(%d)\n"), unit, fc_calender_port));
        rc = BCM_E_PARAM;
        goto err;
    }
  
    /* retrieve calender setting */
    soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_get,(unit, tx_cal->cal_mode_ndx, tx_cal->intf, &cal_if_info, cal_buff));

    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in %s calender(%d) retreive, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  tx_cal->intf, soc_sand_rc, rc));
        goto err;
    }
            
    if(target->flags & BCM_COSQ_FC_RETRANSMIT)
    {
#ifdef  BCM_ARAD_SUPPORT
      if(SOC_IS_ARAD(unit))
      {
        /* ILKN Retransmit Entry  - Arad Only */
        cal_src = SOC_TMC_FC_GEN_CAL_SRC_RETRANSMIT;

        cal_id_entries = 1;
        cal_id[0] = fc_calender_port;
      }
#endif
    }
    
    else if(target->flags & BCM_COSQ_FC_HCFC_BITMAP)
    {
#ifdef  BCM_ARAD_SUPPORT
      if(SOC_IS_ARAD(unit))
      {
        bit = target->priority;
        bitmap_index = target->cosq;

        cal_src = SOC_TMC_FC_GEN_CAL_SRC_HCFC;

        cal_id_entries = 1;
        cal_id[0] = bitmap_index;

        soc_sand_rc = arad_fc_hcfc_bitmap_get(unit, bitmap_index, &hcfc_bitmap);
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in %s calender(%d): HCFC bitmap get failed, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  tx_cal->intf, soc_sand_rc, rc));
            goto err;
        }

        hcfc_bitmap.bitmap[bit / 32] = (hcfc_bitmap.bitmap[bit / 32] | (0x1 << (bit % 32))) & ~(is_for_delete << (bit % 32)); 

        if(is_for_delete)
        {
          delete_hcfc_entry = 1;
          for(i = 0; i < 8; i++)
          {
            if(hcfc_bitmap.bitmap[i] != 0)
            {
              delete_hcfc_entry = 0;
              break;
            }
          }
        }

        soc_sand_rc = arad_fc_hcfc_bitmap_set(unit, bitmap_index, &hcfc_bitmap);
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in %s calender(%d): HCFC bitmap set failed, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  tx_cal->intf, soc_sand_rc, rc));
            goto err;
        }
      }
#endif
      
    }
    else if (vsq_info->flags & BCM_COSQ_VSQ_GL) {
        /* Global resources */

        /* consistency checks */
        if ( (source->flags != 0) || (target->flags != 0) ) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flags source(0x%x) target(0x%x)\n"), unit, source->flags, target->flags));
            rc = BCM_E_PARAM;
            goto err;
        }

        /* validate source cos */
        rc = _bcm_dpp_cosq_internal_priority_get(unit, source->cosq, &priority);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            goto err;
        }

        /* validate destination cos */
        if ( (priority == 0) && !((target->cosq == 0) || (target->cosq != -1)) ) {
            /* Global High Priority */

            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid target cosq (%d)\n"), unit, target->cosq));
            goto err;
        }
        else if ( (priority == 1) && !(target->cosq == 0) ) {
            /* Global Low Priority */

            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid target cosq (%d)\n"), unit, target->cosq));
            goto err;
        }
#ifdef  BCM_PETRAB_SUPPORT
        if(SOC_IS_PETRAB(unit))
        {
            /* The CAL SRC separate HP from LP*/
            cal_src = (priority == 0) ? SOC_TMC_FC_GEN_CAL_SRC_GLB_HP : SOC_TMC_FC_GEN_CAL_SRC_GLB_LP;
            cal_id[0] = SOC_TMC_FC_CAL_GLB_RCS_ID_BDB;
            cal_id[1] = SOC_TMC_FC_CAL_GLB_RCS_ID_UNI;
            cal_id[2] = SOC_TMC_FC_CAL_GLB_RCS_ID_MUL;
        }
#endif
#ifdef  BCM_ARAD_SUPPORT
        if(SOC_IS_ARAD(unit))
        {
            /* The CAL ID separate HP(0,1,2) form LP(3,4,5) */
            cal_src = SOC_TMC_FC_GEN_CAL_SRC_GLB_RCS;
            /* ID = HP ? 0 : 3 */
            cal_id[0] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_BDB : SOC_TMC_FC_CAL_GLB_RCS_ID_BDB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
            /* ID = HP ? 1 : 4 */
            cal_id[1] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_UNI : SOC_TMC_FC_CAL_GLB_RCS_ID_UNI + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
            /* ID = HP ? 2 : 5 */
            cal_id[2] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_MUL : SOC_TMC_FC_CAL_GLB_RCS_ID_MUL + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
        }
#endif
        /* We need an entry per every GLB RCS type - total of 3 */
        cal_id_entries = SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
        if ((target->calender_index + (cal_id_entries - 1)) >= cal_if_info.cal_len) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, out of range calender index (%d)\n"), unit, (target->calender_index + (cal_id_entries - 1))));
            rc = BCM_E_PARAM;
            goto err;
        }
    }
    else if(BCM_COSQ_GPORT_IS_VSQ(source->port)){
      /* port/interface resources */

      /* consistency checks */
      if ( (source->flags != 0) || (target->flags != 0) ) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid flags source(0x%x) target(0x%x)\n"), unit, source->flags, target->flags));
        rc = BCM_E_PARAM;
        goto err;
      }

      if ( (source->cosq != 0) || (target->cosq != 0) ) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid cosq source (%d), target(%d)\n"), unit, source->cosq, target->cosq));
        goto err;
      }

      /* retrieve vsq index */
      rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, source->port, &vsq_group_type,
        &vsq_index);
      if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x\n"), unit, source->port, rc));
        rc = BCM_E_PARAM;
        goto err;
      }

      rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_group);
      if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Error in _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type 0x%x\n"), unit, rc));
        rc = BCM_E_PARAM;
        goto err;
      }

      soc_sand_rc = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_itm_vsq_index_fc_group2global,( soc_tmcvsq_group, vsq_index, &vsq_id)));
      if (SOC_SAND_FAILURE(soc_sand_rc)) {
          rc = translate_sand_success_failure(soc_sand_rc);
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Invalid vsq id 0x%x specified\n"), unit, vsq_id));
          restore = TRUE;
          goto err;
      }

#ifdef  BCM_PETRAB_SUPPORT
      if(SOC_IS_PETRAB(unit))
      {
        cal_src = SOC_TMC_FC_GEN_CAL_SRC_STE;
      }
#endif
#ifdef  BCM_ARAD_SUPPORT
      if(SOC_IS_ARAD(unit))
      {
        if(soc_tmcvsq_group == SOC_TMC_ITM_VSQ_GROUP_LLFC) {
          /* Group E */
          cal_src = SOC_TMC_FC_GEN_CAL_SRC_LLFC_VSQ;
        }
        else if(soc_tmcvsq_group == SOC_TMC_ITM_VSQ_GROUP_PFC) {
          /* Group F */
          cal_src = SOC_TMC_FC_GEN_CAL_SRC_PFC_VSQ;
        }
        else
        {
          /* Group A/B/C/D */
          cal_src = SOC_TMC_FC_GEN_CAL_SRC_STE;
        }
      }
#endif
      cal_id_entries = 1;
      cal_id[0] = vsq_id;
    }
    else
    {
        /* NIF RX Indication */
        if ( !(BCM_GPORT_IS_MODPORT(source->port) || BCM_GPORT_IS_LOCAL(source->port) || 
            ((SOC_PORT_VALID(unit, source->port)) && (IS_PORT(unit, source->port)))   ) ) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unexpected target port (0x%x)"), unit, source->port));
        }

        target_id = 0;
        if(SOC_IS_PETRAB(unit)) {
            rc = bcm_petra_cosq_port_nif_get(unit, source->port, &nif_id);
            BCMDNX_IF_ERR_EXIT(rc);

            bcm_port_to_scaled_down_nif_id(unit, nif_id, &target_id);
        } else {
#ifdef  BCM_ARAD_SUPPORT
            bcm_port_t user_port;
            uint32 phy_port;

            rc = bcm_petra_cosq_user_port_get(unit, source->port, &user_port);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = soc_port_sw_db_first_phy_port_get(unit, user_port, &phy_port /*one based*/);
            BCMDNX_IF_ERR_EXIT(rc);

            target_id = phy_port - 1;
#endif
        }

        cal_src = SOC_TMC_FC_GEN_CAL_SRC_LLFC;
        cal_id_entries = 1;
        cal_id[0] = target_id;
    }

    /* Delete case */
    if (is_for_delete) {
#ifdef  BCM_ARAD_SUPPORT
      if(SOC_IS_ARAD(unit)) {
        /* Delete if target is HCFC and DELETE_HCFC_ENTRY=1 */
        /* Or if target is not HCFC */
        if(
           ((target->flags & BCM_COSQ_FC_HCFC_BITMAP) && (delete_hcfc_entry == 1)) ||
           !(target->flags & BCM_COSQ_FC_HCFC_BITMAP)
          )
        {
          cal_src = SOC_TMC_FC_GEN_CAL_SRC_CONST;
          cal_id[0] = 0;
          cal_id_entries = 1;
        }
      }
#endif
#ifdef  BCM_PETRAB_SUPPORT
      if(SOC_IS_PETRAB(unit)) {
        cal_src = SOC_TMC_FC_GEN_CAL_SRC_NONE;
        cal_id[0] = 0;
        cal_id_entries = 1;
      }
#endif
    }

    /* update calender */
    for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {
        (cal_buff + target->calender_index + cur_entry)->source = cal_src;
        (cal_buff + target->calender_index + cur_entry)->id = cal_id[cur_entry];
    }

  /* configure calender */
  soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_set,(unit, tx_cal->cal_mode_ndx, tx_cal->intf, &cal_if_info, cal_buff));
  
  if (SOC_SAND_FAILURE(soc_sand_rc)) {
      rc = translate_sand_success_failure(soc_sand_rc);
      LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, error in %s Tx calender(%d) setup, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  tx_cal->intf, soc_sand_rc, rc));
      restore = TRUE;
      goto err;
  }

  if (cal_buff != NULL) {
     BCM_FREE(cal_buff);
  }

  BCMDNX_IF_ERR_EXIT(rc);
  BCM_EXIT;

err:
    if (restore == TRUE) {
        for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {
            (cal_buff + target->calender_index + cur_entry)->source = SOC_TMC_FC_GEN_CAL_SRC_NONE;
            (cal_buff + target->calender_index + cur_entry)->id = 0;
        }
        soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_set,(unit, tx_cal->cal_mode_ndx, tx_cal->intf, &cal_if_info, cal_buff));
        
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in %s Tx calender(%d) setup, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  tx_cal->intf, soc_sand_rc, rc));
        }
    }

    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCM_FREE(cal_buff);
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cal_generation_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           bcm_cosq_vsq_info_t *vsq_info,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count             /* INOUT */
                                           )                       
{
    bcm_error_t              rc = BCM_E_NONE;
    bcm_dpp_cosq_tx_cal_t   *tx_cal = NULL;
    SOC_TMC_FC_CAL_IF_INFO       cal_if_info;
    SOC_TMC_FC_GEN_CALENDAR      *cal_buff = NULL;
    uint32                   soc_sand_rc;
    bcm_dpp_cosq_config_t   *cosq_config;
    int                      cal_index, nof_ilkn_ports;
#ifdef BCM_ARAD_SUPPORT
    SOC_TMC_FC_GEN_CAL_SRC       cal_src = 0;
    int                      target_nif_id;
    uint32 dev_id;
#endif

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);

    /* Init values */
    cosq_config = &_dpp_cosq_config[unit];    
 
    if(*target_count >= max_target) goto err;

    BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_GEN_CALENDAR) * SOC_PETRA_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);
    for (cal_index = 0; cal_index < SOC_PETRA_FC_OOB_CAL_LEN_MAX; cal_index++) {
        SOC_TMC_FC_GEN_CALENDAR_clear((cal_buff + cal_index));
    }

    /* Get the calendar type */
    if (is_fc_inband) {
        if (fc_calender_port >= nof_ilkn_ports) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }
        tx_cal = &cosq_config->inband_cal[fc_calender_port].tx;
    }
    else {
        if (fc_calender_port >= SOC_DPP_MAX_OOB_PORTS) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            rc = BCM_E_PARAM;
            goto err;
        }
        tx_cal = &cosq_config->oob_cal[fc_calender_port].tx;
    }
    if (tx_cal->valid != TRUE) {
        /* No calendar */
        goto err;
    }

    /* Get the calender setting */
    soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_get,(unit, tx_cal->cal_mode_ndx, tx_cal->intf, &cal_if_info, cal_buff));

    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in %s calender(%d) retreive, soc_sand error 0x%x, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  tx_cal->intf, soc_sand_rc, rc));
        goto err;
    }

    /* Search for the Target */
    for(cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++)
    {
#ifdef BCM_ARAD_SUPPORT
      cal_src = cal_buff[cal_index].source;

      /* Need to handle RETRANSMIT ONLY - other srouces ignores target information */
      if(SOC_IS_ARAD(unit) && cal_src == SOC_TMC_FC_GEN_CAL_SRC_RETRANSMIT)
      {
        target[*target_count].calender_index = cal_index;

        /* Internal NIF to NIF ID (Retransmit is ILKN) */
        dev_id = unit;
        target_nif_id = arad_nif_intern2nif_id(dev_id, ARAD_NIF_TYPE_ILKN, cal_buff[cal_index].id);
        /* NIF ID to GPORT */
        rc = bcm_petra_cosq_nif_to_gport_get(unit, target_nif_id , &target[*target_count].port);

        *target_count += 1;
        if (*target_count >= max_target) goto err;
      }
#endif
    }

err:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* non-calender based flow control generation (Inband) */
STATIC int
_bcm_petra_cosq_noncal_generation_fc_path_add(int unit,
                                              int is_for_delete,
                                              bcm_cosq_fc_direction_type_t fc_direction,
                                              bcm_cosq_fc_endpoint_t *source,
                                              bcm_cosq_fc_endpoint_t *target,
                                              bcm_cosq_vsq_info_t *vsq_info,
                                              int is_fc_calender,            /* not used */
                                              int is_fc_inband,              /* not used */
                                              int fc_calender_port,          /* not used */
                                              int fc_nif_id)                 /* not used */
{
    bcm_error_t              rc = BCM_E_NONE;
    uint32                   soc_sand_rc;
    int                      priority;
    SOC_TMC_FC_GEN_INBND_INFO    inbnd_info;
    uint32                   nif_id;
    int                      is_channelization_ability, no_classes, no_queues;
    SOC_TMC_FC_INGR_GEN_GLB_HP_MODE glb_hp_mode;
    int is_llfc;

#ifdef BCM_ARAD_SUPPORT
    int is_safc = 0;
    bcm_cosq_vsq_info_t  temp_vsq_info;
    bcm_port_t port;
#endif

    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_FC_GEN_INBND_INFO_clear(&inbnd_info);

    /* consistency checks */
    if ( (source->calender_index != 0) || (target->calender_index != 0) ) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, calender not valid source (%d), target (%d)\n"), unit, source->calender_index, target->calender_index));
        rc = BCM_E_PARAM;
        goto err;
    }

    if ( (vsq_info->flags & BCM_COSQ_VSQ_LLFC) || (vsq_info->flags & BCM_COSQ_VSQ_PFC) ) {
        /* interface resources */

        /* consistency checks */

        if (source->flags != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
            rc = BCM_E_PARAM;
            goto err;
        }

        if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, target flag *_IMPLICIT not specified\n"), unit));
            rc = BCM_E_PARAM;
        }
        if (target->port != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, unexpected target port (0x%x)\n"), unit, target->port));
            rc = BCM_E_PARAM;
            goto err;
        }

        if ( (target->flags & ~(BCM_COSQ_FC_INHERIT_UP | BCM_COSQ_FC_INHERIT_DOWN | BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) ||
                   ((vsq_info->flags & BCM_COSQ_VSQ_PFC) &&
                          (target->flags & BCM_COSQ_FC_INHERIT_UP) &&
                                            (target->flags & BCM_COSQ_FC_INHERIT_DOWN)) ||
                   ((vsq_info->flags & BCM_COSQ_VSQ_LLFC) &&
                          ((target->flags & BCM_COSQ_FC_INHERIT_UP) || 
                                            (target->flags & BCM_COSQ_FC_INHERIT_DOWN))) ) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
            rc = BCM_E_PARAM;
            goto err;
        }
        if (target->cosq != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, invalid target cosq (0x%x)\n"), unit, target->cosq));
            rc = BCM_E_PARAM;
            goto err;
        }

        rc = _bcm_petra_cosq_vsq_fc_info_get(unit, source->port, &nif_id, &inbnd_info);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving inband flow control info for vsq (0x%x), error 0x%x\n"), unit, source->port, rc));
            goto err;
        }

        if ((vsq_info->flags & BCM_COSQ_VSQ_LLFC) && (inbnd_info.cb.glbl_rcs_low != 0)) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "unit %d, Enabling Inband LLFC on port/interface (0x%x/%d) disabling Global Low priorities flow control\n"), unit, target->port, nif_id));
        }

        /* update info */
        if (vsq_info->flags & BCM_COSQ_VSQ_LLFC) {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_LL;
            inbnd_info.cb.glbl_rcs_low = 0;
            inbnd_info.cb.inherit = SOC_TMC_FC_INBND_CB_INHERIT_DISABLED;
        }
#ifdef  BCM_ARAD_SUPPORT
        else if(SOC_IS_ARAD(unit) && (vsq_info->flags & BCM_COSQ_VSQ_PFC))
        {
            rc = _bcm_petra_cosq_vsq_info_get(unit, source->port, &temp_vsq_info);   
            BCMDNX_IF_ERR_EXIT(rc);

            rc = bcm_petra_port_control_get(unit, temp_vsq_info.src_port, bcmPortControlSAFCTransmit, &is_safc);
            BCMDNX_IF_ERR_EXIT(rc);

            if(is_safc)
            {
              inbnd_info.mode = SOC_TMC_FC_INBND_MODE_SAFC;
            }
            else
            {
              inbnd_info.mode = SOC_TMC_FC_INBND_MODE_PFC;
            }

            if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
                inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_UP;
            }
            else if (target->flags &   BCM_COSQ_FC_INHERIT_DOWN) {
                inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_DOWN;
            }
            else{
                inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_DISABLED;
            }
        }
#endif
#ifdef BCM_PETRAB_SUPPORT
        else if (SOC_IS_PETRAB(unit)) /* CB */{
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_CB;
            if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
                inbnd_info.cb.inherit = SOC_TMC_FC_INBND_CB_INHERIT_UP;
            }
            else if (target->flags &   BCM_COSQ_FC_INHERIT_DOWN) {
                inbnd_info.cb.inherit = SOC_TMC_FC_INBND_CB_INHERIT_DOWN;
            }
            else
            {
              inbnd_info.cb.inherit = SOC_TMC_FC_INBND_CB_INHERIT_DISABLED;
            }
        }
#endif

        /* configure info */
        rc = _bcm_petra_cosq_interface_fc_info_set(unit, is_for_delete, nif_id, &inbnd_info);
        if (rc != BCM_E_NONE) {
            goto err;
        }
    }
    else if (vsq_info->flags & BCM_COSQ_VSQ_GL) {
        /* global resources */

        /* consistency checks */
        if (source->flags != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            rc = BCM_E_PARAM;
            goto err;
        }

        /* validate source cos */
        rc = _bcm_dpp_cosq_internal_priority_get(unit, source->cosq, &priority);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            goto err;
        }

        /* validate destination cos */
        if ( (priority == 0) && !((target->cosq == 0) || (target->cosq != -1)) ) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid target cosq (%d)\n"), unit, target->cosq));
            goto err;
        }
        else if ( (priority == 1) && !(target->cosq == 0) ) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid target cosq (%d)\n"), unit, target->cosq));
            goto err;
        }

        if (priority == 0) {
            /* Global High Prioriry */
            if (target->flags != BCM_COSQ_FC_ENDPOINT_PORT_ALL) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flags target(0x%x), Need to set *_ALL flag\n"), unit, target->flags));
                rc = BCM_E_PARAM;
                goto err;
            }

            glb_hp_mode = SOC_TMC_FC_INGR_GEN_GLB_HP_MODE_ALL;
            soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_glb_hp_set,(unit, glb_hp_mode));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error in setting InBand (LLFC) Hi Priorirty Flow Control, soc_sand error: 0x%x, error: 0x%x\n"), unit, soc_sand_rc, rc));
              goto err;
            }
        }
        else {
            /* Global Low Priority */
            /* consistency checks*/
            /* target flags */
            if (target->flags != 0) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, unexpected target flag (0x%x)\n"), unit, target->flags));
                rc = BCM_E_PARAM;
                goto err;
            }

            /* target port */
            if ( !(BCM_GPORT_IS_MODPORT(target->port) || BCM_GPORT_IS_LOCAL(target->port)) ) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, unexpected target port (0x%x)\n"), unit, target->port));
                rc = BCM_E_PARAM;
                goto err;
            }
            rc = _bcm_petra_cosq_interface_fc_info_get(unit, target->port, &nif_id, &inbnd_info);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
                goto err;
            }

            /* target cosq */
            rc = bcm_petra_cosq_port_info_get(unit, target->port, &is_channelization_ability,
                                                     &no_classes, &nif_id, &no_queues);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error retreiving target port info(0x%x)\n"), unit, target->port));
                goto err;
            }
            if ((target->cosq < 0 ) || (target->cosq >= no_classes)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, target cosq (%d) out of range\n"), unit, target->cosq));
                rc = BCM_E_PARAM;
                goto err;
            }

            if (inbnd_info.mode == SOC_TMC_FC_INBND_MODE_DISABLED) {
                LOG_WARN(BSL_LS_BCM_COSQ,
                         (BSL_META_U(unit,
                                     "unit %d, Enabling Inband Global Low  CBFC on port/interface (0x%x/%d) that is not enabled for Flow Control, Marking it as CBFC\n"), unit, target->port, nif_id));
                inbnd_info.mode = SOC_TMC_FC_INBND_MODE_CB;
            }
            else if (inbnd_info.mode != SOC_TMC_FC_INBND_MODE_CB && inbnd_info.mode != SOC_TMC_FC_INBND_MODE_PFC && inbnd_info.mode != SOC_TMC_FC_INBND_MODE_SAFC) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Cannot enable Inband Global Low  CBFC on port/interface (0x%x/%d) that is configured for LLFC\n"), unit, target->port, nif_id));
                rc = BCM_E_PARAM;
                goto err;
            }

            /* update state */
#ifdef  BCM_ARAD_SUPPORT
            if(SOC_IS_ARAD(unit))
            {
              inbnd_info.pfc.glbl_rcs_low |= (1 << target->cosq);
            }
#endif
#ifdef  BCM_PETRAB_SUPPORT
            if(SOC_IS_PETRAB(unit))
            {
              inbnd_info.cb.glbl_rcs_low |= (1 << target->cosq);
            }
#endif
            
            /* configure */
            rc = _bcm_petra_cosq_interface_fc_info_set(unit, is_for_delete, nif_id, &inbnd_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
        }
    }
    else if(source->flags & BCM_COSQ_FC_ETH_PORT) {

        /* consistency checks */
        if ((source->flags & ~(BCM_COSQ_FC_ETH_PORT)) != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
            rc = BCM_E_PARAM;
            goto err;
        }

        if (target->flags != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
            rc = BCM_E_PARAM;
            goto err;
        }

        if (source->cosq != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
            rc = BCM_E_PARAM;
            goto err;
        }

        rc = bcm_petra_cosq_port_info_get(unit, target->port, &is_channelization_ability,
                                                     &no_classes, &nif_id, &no_queues);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error retreiving target port info(0x%x)\n"), unit, target->port));
            goto err;
        }

        if ((target->cosq < -1 ) || (target->cosq >= no_classes)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, target cosq (%d) out of range\n"), unit, target->cosq));
            rc = BCM_E_PARAM;
            goto err;
        }

        /* retreive information */
        rc = _bcm_petra_cosq_interface_fc_info_get(unit, target->port, &nif_id, &inbnd_info);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
            goto err;
        }

        is_llfc = (target->cosq == -1) ? TRUE : FALSE;

        /* update info */
        if (is_llfc) {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_LL;
        }
        else {
            rc = bcm_petra_cosq_user_port_get(unit, target->port, &port);
            BCMDNX_IF_ERR_EXIT(rc);
                
            rc = bcm_petra_port_control_get(unit, port, bcmPortControlSAFCTransmit, &is_safc);
            BCMDNX_IF_ERR_EXIT(rc);

            if(is_safc) {
                inbnd_info.mode = SOC_TMC_FC_INBND_MODE_SAFC;
            }
            else {
                inbnd_info.mode = SOC_TMC_FC_INBND_MODE_PFC;
            }

            inbnd_info.pfc.nif_cls_bitmap |= (1 << target->cosq);
        }

        /* configure */
        rc = _bcm_petra_cosq_interface_fc_info_set(unit, is_for_delete, nif_id, &inbnd_info);
        if (rc != BCM_E_NONE) {
            goto err;
        }
    }
    else {
        rc = BCM_E_UNAVAIL;
        goto err;
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_noncal_generation_fc_path_get(int unit,
                                              bcm_cosq_fc_direction_type_t fc_direction,
                                              bcm_cosq_fc_endpoint_t *source,
                                              bcm_cosq_vsq_info_t *vsq_info,
                                              int max_target,
                                              bcm_cosq_fc_endpoint_t *target, /* OUT */
                                              int *target_count               /* INOUT */
                                              )                
{
    bcm_error_t              rc = BCM_E_NONE;
    int                      priority;
    SOC_TMC_FC_GEN_INBND_INFO    inbnd_info;
    uint32                   nif_id;
#ifdef BCM_ARAD_SUPPORT
    uint32                   soc_sand_rc;
    int                      i, internal_target_id, target_nif_id;
    ARAD_NIF_TYPE            nif_type;
#endif

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_FC_GEN_INBND_INFO_clear(&inbnd_info);

    if(*target_count >= max_target) goto err;

    if ( (vsq_info->flags & BCM_COSQ_VSQ_LLFC) || (vsq_info->flags & BCM_COSQ_VSQ_PFC) ) {
        /* interface resources */
        /* consistency checks */
        if (source->flags != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
            rc = BCM_E_PARAM;
            goto err;
        }

        rc = _bcm_petra_cosq_vsq_fc_info_get(unit, source->port, &nif_id, &inbnd_info);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving inband flow control info for vsq (0x%x), error 0x%x\n"), unit, source->port, rc));
            goto err;
        }
#ifdef BCM_ARAD_SUPPORT
        if(SOC_IS_ARAD(unit))
        {
          if (inbnd_info.pfc.inherit == SOC_TMC_FC_INBND_PFC_INHERIT_UP) {
            target[*target_count].flags = BCM_COSQ_FC_INHERIT_UP;
          }
          else if (inbnd_info.pfc.inherit == SOC_TMC_FC_INBND_PFC_INHERIT_DOWN) {
            target[*target_count].flags = BCM_COSQ_FC_INHERIT_DOWN;
          }
        }
#endif
#ifdef BCM_PETRAB_SUPPORT
        if(SOC_IS_PETRAB(unit))
        {
          if (inbnd_info.cb.inherit == SOC_TMC_FC_INBND_CB_INHERIT_UP) {
            target[*target_count].flags = BCM_COSQ_FC_INHERIT_UP;
          }
          else if (inbnd_info.cb.inherit == SOC_TMC_FC_INBND_CB_INHERIT_DOWN) {
            target[*target_count].flags =  BCM_COSQ_FC_INHERIT_DOWN;
          }
        }
#endif
        if(inbnd_info.mode != SOC_TMC_FC_INBND_MODE_DISABLED)
        {
          *target_count += 1;
        }
    }
    else if (vsq_info->flags & BCM_COSQ_VSQ_GL) {
        /* global resources */

        /* consistency checks */
        if (source->flags != 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            rc = BCM_E_PARAM;
            goto err;
        }

        /* validate source cos */
        rc = _bcm_dpp_cosq_internal_priority_get(unit, source->cosq, &priority);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            goto err;
        }

        if (priority == 0) {
            /* Global High Prioriry */
            /* Target is irrelevant */
        }
        else {
            /* Global Low Priority */

 #ifdef BCM_ARAD_SUPPORT
            if(SOC_IS_ARAD(unit))
            {
              soc_port_t port;
              uint32 dev_id;

              dev_id = unit;
              /* Check all interfaces for FC configuration */
              for(internal_target_id = 0; internal_target_id < 32; internal_target_id++)
              {

                /* Get the NIF Type */
                port = SOC_INFO(unit).port_p2l_mapping[internal_target_id+1];
                soc_sand_rc = arad_port_to_nif_type(unit, port, &nif_type);
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in retreiving nif type, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                }

                /* Convert internal to NIF ID */
                target_nif_id = arad_nif_intern2nif_id(dev_id, nif_type, internal_target_id);
                  
                /* Get FC Configuration */
                soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_get,(unit, target_nif_id, &inbnd_info));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, failed to config CBFC nif_id(%d), soc_sand error 0x%x\n"), unit, target_nif_id, soc_sand_rc));
                  BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
                }

                /* Target is relevant only for PFC */
                if(inbnd_info.mode == SOC_TMC_FC_INBND_MODE_PFC || inbnd_info.mode == SOC_TMC_FC_INBND_MODE_SAFC)
                {
                  for(i = 0; i < 8; i++)
                  {
                    if(inbnd_info.pfc.glbl_rcs_low & SOC_SAND_BIT(i))
                    {
                      target[*target_count].cosq = i;
                      
                      /* NIF ID to GPORT */
                      rc = bcm_petra_cosq_nif_to_gport_get(unit, target_nif_id , &target[*target_count].port);

                      *target_count += 1;
                      if(*target_count >= max_target) goto err;
                    }
                  }
                }

              } /* Internal ID Loop */
            }/* SOC_IS_ARAD */
#endif
        }
    }
    else if(target->flags & BCM_COSQ_FC_ETH_PORT) {
        soc_port_t port;

        /* Check all interfaces for FC configuration */
        for(internal_target_id = 0; internal_target_id < 32; internal_target_id++)
        {
            /* Get the NIF Type */
            port = SOC_INFO(unit).port_p2l_mapping[internal_target_id+1];
            soc_sand_rc = arad_port_to_nif_type(unit, port, &nif_type);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                     "unit %d, error in retreiving nif type, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            /* Convert internal to NIF ID */
            target_nif_id = arad_nif_intern2nif_id(unit, nif_type, internal_target_id);

            /* Get FC Configuration */
            soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_get,(unit, target_nif_id, &inbnd_info));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                     "unit %d, failed to config CBFC nif_id(%d), soc_sand error 0x%x\n"), unit, target_nif_id, soc_sand_rc));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
            }

            /* Target is relevant only for PFC */
            if((inbnd_info.mode == SOC_TMC_FC_INBND_MODE_PFC) || (inbnd_info.mode == SOC_TMC_FC_INBND_MODE_SAFC))
            {
                for(i = 0; i < 8; i++)
                {
                    if(inbnd_info.pfc.nif_cls_bitmap & SOC_SAND_BIT(i))
                    {
                        target[*target_count].cosq = i;

                        /* NIF ID to GPORT */
                        rc = bcm_petra_cosq_nif_to_gport_get(unit, target_nif_id , &target[*target_count].port);

                        *target_count += 1;
                        if(*target_count >= max_target) goto err;
                    }
                }
            }
            else if (inbnd_info.mode == SOC_TMC_FC_INBND_MODE_LL) {
                target[*target_count].cosq = -1;

                /* NIF ID to GPORT */
                rc = bcm_petra_cosq_nif_to_gport_get(unit, target_nif_id , &target[*target_count].port);

                *target_count += 1;
                if(*target_count >= max_target) goto err;
            }


        } /* Internal ID Loop */
    }

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
  BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_link_fc_verify(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;
    if (target->flags != BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid flags parameter 0x%x\n"), unit, target->flags));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (source->cosq != -1)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid cosq parameter 0x%x\n"), unit, target->cosq));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_link_fc_add(int unit,
                       int is_for_delete,
                       bcm_cosq_fc_direction_type_t fc_direction,
                       bcm_cosq_fc_endpoint_t *source,
                       bcm_cosq_fc_endpoint_t *target)
{
    uint32 link;
    uint32 soc_sand_rc;
    SOC_TMC_FABRIC_FC info_rx;
    SOC_TMC_FABRIC_FC info_tx;
    SOC_TMC_CONNECTION_DIRECTION direction;
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_FABRIC_FC_clear(unit, &info_rx);
    SOC_TMC_FABRIC_FC_clear(unit, &info_tx);

    link = SOC_DPP_FABRIC_PORT_TO_LINK(unit, source->port);
    rc = _bcm_petra_link_fc_verify(unit,fc_direction,source,target);
    BCMDNX_IF_ERR_EXIT(rc);        
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_get,(unit, &info_rx,&info_tx)));
    if(SOC_SAND_FAILURE(soc_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get flow control parameters, soc_sand error 0x%x\n"), unit, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }    
    if (fc_direction == bcmCosqFlowControlGeneration) {
        info_tx.enable[link] = (is_for_delete == FALSE)?TRUE:FALSE; 
        direction = SOC_TMC_CONNECTION_DIRECTION_TX;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_set,(unit, direction, &info_tx)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable generation flow control on link %d, soc_sand error 0x%x\n"), unit, link, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }    
    }
    if (fc_direction == bcmCosqFlowControlReception) {
        info_rx.enable[link] = TRUE; 
        direction = SOC_TMC_CONNECTION_DIRECTION_RX;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_set,(unit, direction, &info_rx)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable reception flow control on link %d, soc_sand error 0x%x\n"), unit, link, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_link_fc_delete(int unit,
                       bcm_cosq_fc_direction_type_t fc_direction,
                       bcm_cosq_fc_endpoint_t *source,
                       bcm_cosq_fc_endpoint_t *target)
{
    uint32 link;
    uint32 soc_sand_rc;
    SOC_TMC_FABRIC_FC info_rx;
    SOC_TMC_FABRIC_FC info_tx;
    SOC_TMC_CONNECTION_DIRECTION direction;
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_FABRIC_FC_clear(unit, &info_rx);
    SOC_TMC_FABRIC_FC_clear(unit, &info_tx);

    link = SOC_DPP_FABRIC_PORT_TO_LINK(unit, source->port);
    _bcm_petra_link_fc_verify(unit,fc_direction,source,target);
    BCMDNX_IF_ERR_EXIT(rc);        
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_get,(unit, &info_rx, &info_tx)));
    if(SOC_SAND_FAILURE(soc_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get flow control parameters, soc_sand error 0x%x\n"), unit, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }    
    if (fc_direction == bcmCosqFlowControlGeneration) {
        info_tx.enable[link] = FALSE; 
        direction = SOC_TMC_CONNECTION_DIRECTION_TX;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_set,(unit, direction,&info_tx)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable generation flow control on link %d, soc_sand error 0x%x\n"), unit, link, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }    
    }
    if (fc_direction == bcmCosqFlowControlReception) {
        info_rx.enable[link] = FALSE; 
        direction = SOC_TMC_CONNECTION_DIRECTION_RX;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_set,(unit, direction, &info_rx)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable reception flow control on link %d, soc_sand error 0x%x\n"), unit, link, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}



STATIC int
_bcm_petra_cosq_fc_path_add_remove(int unit,
                                   int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (source == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow control source not specified"), unit));
    }
    if (target == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow control target not specified"), unit));
    }

    if (fc_direction == bcmCosqFlowControlGeneration) {
        rc = _bcm_petra_cosq_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target);
    }
    else if (fc_direction == bcmCosqFlowControlReception) {
        rc = _bcm_petra_cosq_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow control direction %d"), unit, fc_direction));
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_generation_fc_path_add(int unit,
                                       int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    int                  is_fc_calender, is_fc_inband;
    uint32               fc_calender_port, fc_nif_id;
    bcm_cosq_vsq_info_t  vsq_info;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_petra_link_fc_add(unit, is_for_delete, fc_direction,source,target);
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    
    }
    else {
        /* Port is incoming nif port */
    
        if(BCM_COSQ_GPORT_IS_VSQ(source->port))
        {
          /* vsq validation and retreive vsq inormation */
          rc = _bcm_petra_cosq_vsq_info_get(unit, source->port, &vsq_info);
          BCMDNX_IF_ERR_EXIT(rc);
        }
        else
        {
          sal_memset(&vsq_info, 0, sizeof(vsq_info));
        }
    
        if (target->port == BCM_GPORT_TYPE_NONE) {
            is_fc_calender = FALSE;
            is_fc_inband = TRUE;
            fc_calender_port = -1;
            fc_nif_id = -1;
        }
        else {
            if ( !(BCM_GPORT_IS_MODPORT(target->port) || BCM_GPORT_IS_CONGESTION(target->port) || BCM_GPORT_IS_LOCAL(target->port) || 
                  ((SOC_PORT_VALID(unit, target->port)) && (IS_PORT(unit, target->port)))   ) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unexpected target port (0x%x)"), unit, target->port));
            }
    
            /* determine if calender based flow control generation */
            rc = bcm_petra_cosq_fc_port_info_get(unit, target->port, &is_fc_calender,
                                                  &is_fc_inband, &fc_calender_port, &fc_nif_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
        if (is_fc_calender || target->flags & BCM_COSQ_FC_HCFC_BITMAP) {
            /*
             * COVERITY *
             * Coverity note: Overruning callee's array of size 328 by passing argument "source->port"(which evaluates to 328) in call to "_bcm_petra_cosq_cal_generation_fc_path_add". 
             * In check there are no overun. */
            /* coverity[overrun-call] */
            rc = _bcm_petra_cosq_cal_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                           &vsq_info, is_fc_calender, is_fc_inband, fc_calender_port, fc_nif_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            rc = _bcm_petra_cosq_noncal_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                           &vsq_info, is_fc_calender, is_fc_inband, fc_calender_port, fc_nif_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_reception_fc_path_add(int unit,
                                      int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;
    int         is_fc_calender, is_fc_inband;
    uint32      fc_calender_port, fc_nif_id;

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_petra_link_fc_add(unit, is_for_delete, fc_direction,source,target);
    }
    else {
        /* Port is incoming nif port */
        if (BCM_GPORT_IS_MODPORT(source->port) || BCM_GPORT_IS_CONGESTION(source->port) || BCM_GPORT_IS_LOCAL(source->port)) {
            rc = bcm_petra_cosq_fc_port_info_get(unit, source->port, &is_fc_calender,
                                                  &is_fc_inband, &fc_calender_port, &fc_nif_id);
            BCMDNX_IF_ERR_EXIT(rc);
    
            if (is_fc_calender) {
               rc = _bcm_petra_cosq_cal_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                                      is_fc_calender, is_fc_inband, fc_calender_port, fc_nif_id);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            else {
                rc = _bcm_petra_cosq_noncal_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                                      is_fc_calender, is_fc_inband, fc_calender_port, fc_nif_id);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        else {
            
            /*        bcm_petra_cosq_control_set(), Type => bcmCosqControlFlowControlPriority */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid port type for source port (0x%x)"), unit, source->port));
        }
    
    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_generation_fc_path_get(int unit,
                                       bcm_cosq_fc_direction_type_t fc_direction,
                                       bcm_cosq_fc_endpoint_t *source,
                                       int target_max,
                                       bcm_cosq_fc_endpoint_t *target, /* OUT */
                                       int *target_count)              /* OUT */
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    int                  is_fc_inband;
    uint32               fc_calender_port;
    bcm_cosq_vsq_info_t  vsq_info;
    
    BCMDNX_INIT_FUNC_DEFS;

    /* Init the results counter */
    *target_count = 0;

    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /* Port is link port */
        /* Target is irrelevant */
    }
    else {
        /* Port is incoming NIF */
    
        /* Retreive VSQ inormation */
        rc = _bcm_petra_cosq_vsq_info_get(unit, source->port, &vsq_info);
        BCMDNX_IF_ERR_EXIT(rc);
        
        for(fc_calender_port = 0; fc_calender_port < 2; fc_calender_port++)
        {
          for(is_fc_inband = 0; is_fc_inband < 2; is_fc_inband++)
          {
            /* Get CAL FC Targets */
            rc = _bcm_petra_cosq_cal_generation_fc_path_get(unit, fc_direction, source, &vsq_info, is_fc_inband, fc_calender_port, target_max, 
                                                            target, target_count);
            BCMDNX_IF_ERR_EXIT(rc);
          }
        }

        /* Get NON-CAL FC Targets */
        rc = _bcm_petra_cosq_noncal_generation_fc_path_get(unit, fc_direction, source, &vsq_info, target_max, 
                                                           target, target_count);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_reception_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count)
{
    bcm_error_t rc = BCM_E_NONE;
    int         is_fc_calender, is_fc_inband;
    uint32      fc_calender_port, fc_nif_id;

    BCMDNX_INIT_FUNC_DEFS;

    /* Init values */
    *target_count = 0;

    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /* Port is link port */
        /* Target is irrelevant */
    }
    else {
        /* Port is incoming nif port */
        if (BCM_GPORT_IS_MODPORT(source->port) || BCM_GPORT_IS_CONGESTION(source->port) || BCM_GPORT_IS_LOCAL(source->port)) 
        {
          /* Get FC info according to source port */
          rc = bcm_petra_cosq_fc_port_info_get(unit, source->port, &is_fc_calender,
                                                &is_fc_inband, &fc_calender_port, &fc_nif_id);
          BCMDNX_IF_ERR_EXIT(rc);

          if (is_fc_calender) {
             rc = _bcm_petra_cosq_cal_reception_fc_path_get(unit, fc_direction, source,
                                    is_fc_inband, fc_calender_port, target_max, target, target_count);
              BCMDNX_IF_ERR_EXIT(rc);
          }
          else {
              rc = _bcm_petra_cosq_noncal_reception_fc_path_get(unit, fc_direction, source,
                                                                target_max, target, target_count);
              BCMDNX_IF_ERR_EXIT(rc);
          }
        }
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_generation_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) 
    {

        /*Port is link port*/
         rc =  _bcm_petra_link_fc_delete(unit,fc_direction,source,target); 
        BCMDNX_IF_ERR_EXIT(rc);
    
    }
    else {
        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
        BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_reception_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_petra_link_fc_delete(unit,fc_direction,source,target); 

        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
        BCMDNX_FUNC_RETURN;
}

/*
 * Local Functions (Resource allocation)
 */
int
_bcm_petra_flow_region_config(int unit, int region_start, int region_end,
                              int is_interdigitated, int is_oddEven)
{
    bcm_error_t rc = BCM_E_NONE;    
    SOC_TMC_SCH_GLOBAL_PER1K_INFO per1k_info;
    uint32 soc_sand_rc;
    int cur_region;

   BCMDNX_INIT_FUNC_DEFS;

   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "DBG, FLOW REGION Start(%d), End(%d), isInterdigitated %s, isOddEven %s\n"), region_start, region_end, ((is_interdigitated) ? "TRUE" : "FALSE"), ((is_oddEven) ? "TRUE" : "FALSE")));

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        BCM_EXIT;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    SOC_TMC_SCH_GLOBAL_PER1K_INFO_clear(&per1k_info);    
    per1k_info.is_interdigitated = is_interdigitated;
    per1k_info.is_odd_even = is_oddEven;

    
    per1k_info.is_cl_cir = TRUE;

    if ( (region_start < (DPP_DEVICE_COSQ_CONFIG_FLOW_REGION_START(unit) - 1)) ||
         (region_end > ((DPP_DEVICE_COSQ_CONFIG_FLOW_REGION_START(unit) - 1) +
                        (DPP_DEVICE_COSQ_CONFIG_FLOW_REGIONS(unit) - 1))) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid region range for %d-%d"),unit, region_start, region_end));
    }

    for (cur_region = region_start; cur_region <= region_end; cur_region++) {

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_per1k_info_set,(unit, cur_region, &per1k_info)));

        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to config flow region %d, soc_sand error 0x%x\n"), unit, cur_region, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_flow_region_config_get(int unit, int flow_region, uint8 *p_is_interdigitated, int *p_is_oddEven)
{
    bcm_error_t rc = BCM_E_NONE;    
    SOC_TMC_SCH_GLOBAL_PER1K_INFO per1k_info;
    uint32 soc_sand_rc;    

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_per1k_info_get,(unit, flow_region, &per1k_info)));

    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to get flow flow_region %d, soc_sand error 0x%x\n"), unit, flow_region, soc_sand_rc));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    *p_is_interdigitated = per1k_info.is_interdigitated;
    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    *p_is_oddEven = per1k_info.is_odd_even;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* This is a callback function, registered to the alloc manager to be called 
 * whenever a new 1k region is allocated.  At that time, we need to set the
 * region to be interdigitated or not.
 */
int
_bcm_petra_queue_region_config(int unit, int core, int region_start, int region_end,
                               int is_interdigitated)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;  

   BCMDNX_INIT_FUNC_DEFS;
   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "DBG, QUEUE REGION Start(%d), End(%d), isInterdigitated %s\n"), region_start, region_end, ((is_interdigitated) ? "TRUE" : "FALSE")));

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        BCM_EXIT;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    if ( (region_start > (DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ||
         (region_end > (DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid region range for %d-%d"),unit, region_start, region_end));
    }
    if (core < 0 && core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for queue region config."), unit, core));
    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_interdigitated_mode_set,
        (unit, core, region_start, is_interdigitated)));
    rc = handle_sand_result(soc_sand_rc);

    if (rc != BCM_E_NONE) {
      LOG_ERROR(BSL_LS_BCM_COSQ, \
                (BSL_META_U(unit, \
                            "soc_petra_ipq_queue_interdigitated_mode_set() failed \
                            base queue %d\n"),
                 region_start*1024));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_queue_region_config_get(int unit, int core, int queue_region, uint8 *is_interdigitated)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;   

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if ( (queue_region < 0) || (queue_region > (DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid range for queue region %d"),unit, queue_region ));
    }
    if (core < 0 && core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for queue region config."), unit, core));
    }
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_queue_interdigitated_mode_get,(unit, core, queue_region, is_interdigitated)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving queue region %d, soc_sand error 0x%x, error 0x%x\n"), unit, queue_region, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Support Functions - Flow 
 */

int
_bcm_petra_flow_id_get(int unit, int base_flow_id, int cos, int is_non_contiguous, int is_composite, int is_remove, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_region;
    int is_odd_even;
    uint8 is_interdigitated; /*Dummy*/

    BCMDNX_INIT_FUNC_DEFS;
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, flow_region, &is_interdigitated, &is_odd_even);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_remove) {
        (*flow) = DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START;
    }
    else{
        if (is_non_contiguous) {
            if (is_odd_even) {
                (*flow) = (is_composite) ? (base_flow_id + cos * 4) : 
                                                  (base_flow_id + ((cos & 0x6) * 2) + (cos & 0x01));
            } else {
                /*Does not matter if composite or not composite*/
                (*flow) = (base_flow_id + ((cos & 0x6) * 2) + (cos & 0x01));
            }
        }
        else {
            (*flow) = (is_composite) ? (base_flow_id + cos * 2) : (base_flow_id + cos);
        }

        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_composite_flow_id_get(int unit, int base_flow_id, int cos, int is_non_contiguous, int is_composite, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_region;
    int is_odd_even;
    uint8 is_interdigitated; /*Dummy*/

    BCMDNX_INIT_FUNC_DEFS;
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, flow_region, &is_interdigitated, &is_odd_even);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_composite) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, must be composite flow"),unit));
    }

    rc = _bcm_petra_flow_id_get(unit, base_flow_id, cos, is_non_contiguous, is_composite, FALSE,flow);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_odd_even && is_non_contiguous) {
        (*flow)=(*flow)&0x2 ? ((*flow)-2) : ((*flow)+2);        
    } else {
        (*flow)++;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* STATIC */ int
_bcm_petra_se_flow_id_get(int unit, int flow_id, SOC_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_odd_even == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, must be odd-even flow"),unit));
    }

    switch (type) {
        case SOC_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;

        case SOC_TMC_SCH_SE_TYPE_HR:
        case SOC_TMC_SCH_SE_TYPE_FQ:
            if ( !(flow_id & 0x1) && (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;

        case SOC_TMC_SCH_SE_TYPE_NONE:
        default:
            if (flow_id & 0x2) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_se_composite_flow_id_get(int unit, int flow_id, SOC_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (type) {
        case SOC_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                (*flow) = flow_id + 1;
            } else {
                (*flow) = flow_id + 2;
            }
            break;

        case SOC_TMC_SCH_SE_TYPE_HR:
        case SOC_TMC_SCH_SE_TYPE_FQ:
            if ( !(flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 2;
            break;

        case SOC_TMC_SCH_SE_TYPE_NONE:
        default:
            if (flow_id & 0x2) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                (*flow) = (flow_id & 0x1) ? (flow_id - 1) : (flow_id + 1);
            } else {
                (*flow) = (flow_id & 0x2) ? (flow_id - 2) : (flow_id + 2);
            }
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
_bcm_petra_se_dual_flow_id_get(int unit, int flow_id, SOC_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_odd_even == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, must be odd-even flow"),unit));
    }

    switch (type) {
        case SOC_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 1;
            break;

        case SOC_TMC_SCH_SE_TYPE_HR:
        case SOC_TMC_SCH_SE_TYPE_FQ:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            break;

        case SOC_TMC_SCH_SE_TYPE_NONE:
        default:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 1;

            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_nbr_flow_quartets_for_queue_quartet(int unit, int is_interdigitated, int is_composite,
                                                                       int *nbr_flow_quartets)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if ( (is_interdigitated == FALSE) && (is_composite == FALSE) ) {
        (*nbr_flow_quartets) = 1;
    }
    else if ( (is_interdigitated == TRUE) && (is_composite == TRUE) ) {
        (*nbr_flow_quartets) = 4;
    }
    else {
        (*nbr_flow_quartets) = 2;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode1_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP3; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP3; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP4; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP3; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP4; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode2_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP2; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP3; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP3; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode3_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP0; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP0; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode4_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP2; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode5_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP0; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP0; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP1; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the scheduling discipline (mode) as viewed by the user application.
 */
STATIC int
_bcm_petra_cosq_mode_get(int unit, SOC_TMC_SCH_FLOW *flow_config, int is_sf2, int *mode)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_id_index;
    SOC_TMC_SCH_SUBFLOW *sub_flow_config;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info;
    SOC_TMC_SCH_SE_INFO *parent_se = NULL;
    SOC_TMC_SCH_FLOW *parent_flow_config = NULL;
    SOC_TMC_SCH_SE_CL_CLASS_INFO class_type;
    uint32 soc_sand_rc;


    BCMDNX_INIT_FUNC_DEFS;
    flow_id_index = (is_sf2 == TRUE) ? 1 : 0;
    sub_flow_config = &(flow_config->sub_flow[flow_id_index]);
    cs_info = &(sub_flow_config->credit_source);

    switch (cs_info->se_type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            switch (cs_info->se_info.hr.sp_class) {
                case SOC_TMC_SCH_FLOW_HR_CLASS_EF1:              (*mode) = BCM_COSQ_SP0;  break;
                case SOC_TMC_SCH_FLOW_HR_CLASS_EF2:              (*mode) = BCM_COSQ_SP1;  break;
                case SOC_TMC_SCH_FLOW_HR_CLASS_EF3:              (*mode) = BCM_COSQ_SP2;  break;
                case SOC_TMC_SCH_FLOW_HR_SINGLE_CLASS_AF1_WFQ:   (*mode) = BCM_COSQ_SP3;  break;
                case SOC_TMC_SCH_FLOW_HR_SINGLE_CLASS_BE1:       (*mode) = BCM_COSQ_SP4;  break;
                case SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_AF1_WFQ:     (*mode) = BCM_COSQ_SP3;  break;
                case SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_BE1_WFQ:     (*mode) = BCM_COSQ_SP4;  break;
                case SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_BE2:         (*mode) = BCM_COSQ_SP5;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF1:     (*mode) = BCM_COSQ_SP3;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF2:     (*mode) = BCM_COSQ_SP4;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF3:     (*mode) = BCM_COSQ_SP5;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF4:     (*mode) = BCM_COSQ_SP6;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF5:     (*mode) = BCM_COSQ_SP7;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF6:     (*mode) = BCM_COSQ_SP8;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE1_WFQ: (*mode) = BCM_COSQ_SP9;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE2:     (*mode) = BCM_COSQ_SP10; break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:            

            BCMDNX_ALLOC(parent_flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
            BCMDNX_ALLOC(parent_se, sizeof(SOC_TMC_SCH_SE_INFO), "se");
            if ( (parent_flow_config == NULL) ||(parent_se == NULL) ) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            SOC_TMC_SCH_SE_INFO_clear(parent_se);
            SOC_TMC_SCH_FLOW_clear(parent_flow_config);
            SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            /* retreive parent element */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, cs_info->id, parent_se, parent_flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, "cl", soc_sand_rc, rc));
                goto err;
            }

            /* determine parent element attribute */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, parent_se->type_info.cl.id, &class_type)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, parent_se->type_info.cl.id, soc_sand_rc, rc));
                goto err;
            }

            /* map the element attribute to user specified scheduling discipline */
            switch (class_type.mode) {
                case SOC_TMC_SCH_CL_MODE_1:
                    rc = _bcm_petra_cosq_cl_mode1_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case SOC_TMC_SCH_CL_MODE_2:
                    rc = _bcm_petra_cosq_cl_mode2_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case SOC_TMC_SCH_CL_MODE_3:
                    rc = _bcm_petra_cosq_cl_mode3_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case SOC_TMC_SCH_CL_MODE_4:
                    rc = _bcm_petra_cosq_cl_mode4_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case SOC_TMC_SCH_CL_MODE_5:
                    rc = _bcm_petra_cosq_cl_mode5_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                default: rc = BCM_E_PARAM; goto err; break;
            }
           BCM_FREE(parent_flow_config);
           BCM_FREE(parent_se);
            break;

        case SOC_TMC_SCH_SE_TYPE_FQ: (*mode) = BCM_COSQ_SP0; break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (parent_flow_config != NULL)
       BCM_FREE(parent_flow_config);
    if (parent_se != NULL) 
       BCM_FREE(parent_se);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode1_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode2_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch(mode) {
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch(mode) {
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch(mode) {
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode3_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch(mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;
              
        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode4_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode5_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {

        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0:
                         DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
                default:
                    switch(mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the "flow mode info" that corresponds to the attach point (i.e. mode) of
 * the child. The "flow info mode" contains information of flow type to be configured in child
 * flow and the parents weight mode corresponding to this attach point.
 */
STATIC int
_bcm_petra_cosq_credit_class_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, int mode, bcm_dpp_cosq_class_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_SCH_SE_CL_CLASS_INFO class_type;

    
    BCMDNX_INIT_FUNC_DEFS;
    switch(se_config->type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            switch (se_config->type_info.hr.mode) {
                case SOC_TMC_SCH_HR_MODE_SINGLE_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_SINGLE_CLASS_AF1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_SINGLE_CLASS_BE1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;

                case SOC_TMC_SCH_HR_MODE_DUAL_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_AF1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_BE1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP5: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_BE2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;

                case SOC_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP5: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP6: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF4, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP7: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF5, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP8: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF6, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP9: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP10: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
                    }
                    break;

                default : rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;           
            }
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:            
            SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, se_config->type_info.cl.id, &class_type)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, se_config->type_info.cl.id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            switch (class_type.mode) {
                case SOC_TMC_SCH_CL_MODE_1:
                    rc = _bcm_petra_cosq_credit_class_cl_mode1_info_get(unit, se_config, &class_type,mode, info); break;
                case SOC_TMC_SCH_CL_MODE_2:
                    rc = _bcm_petra_cosq_credit_class_cl_mode2_info_get(unit, se_config, &class_type,mode, info); break;
                case SOC_TMC_SCH_CL_MODE_3:
                    rc = _bcm_petra_cosq_credit_class_cl_mode3_info_get(unit, se_config, &class_type,mode, info); break;
                case SOC_TMC_SCH_CL_MODE_4:
                    rc = _bcm_petra_cosq_credit_class_cl_mode4_info_get(unit, se_config, &class_type,mode, info); break;
                case SOC_TMC_SCH_CL_MODE_5:
                    rc = _bcm_petra_cosq_credit_class_cl_mode5_info_get(unit, se_config, &class_type,mode, info); break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        case SOC_TMC_SCH_SE_TYPE_FQ:
            switch(mode) {
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, -1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
            }
            break;

        default: rc = BCM_E_PARAM; BCMDNX_IF_ERR_EXIT(rc); break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the scheduling discipline (mode) as viewed by the user application.
 */
STATIC int
_bcm_petra_cosq_sched_enhanced_mode_get(int unit, SOC_TMC_SCH_SE_INFO *sch_info, int *is_enhanced, int *enhanced_mode)
{
    bcm_error_t                rc = BCM_E_NONE;
    uint32                     soc_sand_rc;    
    SOC_TMC_SCH_SE_CL_CLASS_INFO   class_type;


    BCMDNX_INIT_FUNC_DEFS;
    switch (sch_info->type) {
        case SOC_TMC_SCH_SE_TYPE_CL:            
            SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, sch_info->type_info.cl.id, &class_type)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, sch_info->type_info.cl.id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            (*enhanced_mode) = class_type.enhanced_mode;
            (*is_enhanced) = ( (class_type.enhanced_mode == SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP) ||
                  (class_type.enhanced_mode == SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP) ) ? TRUE : FALSE;
            break;

        case SOC_TMC_SCH_SE_TYPE_HR:
        case SOC_TMC_SCH_SE_TYPE_FQ:
        default:
            (*is_enhanced) = FALSE;
            (*enhanced_mode) = SOC_TMC_SCH_CL_ENHANCED_MODE_LAST; /* not valid */
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the cl discrete weight  as viewed by the user application.
 */
STATIC int
_bcm_petra_cosq_cl_sched_weight_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info, bcm_dpp_cosq_class_info_t *info, int *weight)
{
    bcm_error_t                rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (cs_info->se_info.cl.sp_class) {
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL0;
            break;

        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL1;
            break;

        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL2;
            break;

        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL3;
            break;

        default:
            rc = BCM_E_INTERNAL;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_credit_class_weight_validate(int unit, int weight, bcm_dpp_cosq_class_info_t *info, int *updated_type)
{
    bcm_error_t rc = BCM_E_NONE;
    int discrete_weight_index = 0;


    BCMDNX_INIT_FUNC_DEFS;
    switch (info->weight_mode) {
        case SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
             if (weight != 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type;
             break;

        case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
             if (weight <= 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             else if (weight > info->max_weight) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type;
             break;

        case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
        case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
             if (weight >= 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
            
             for (discrete_weight_index = 0; (weight != 0) &&
                    (discrete_weight_index < BCM_DEVICE_PETRA_COSQ_DWEIGHT_MAX_INDEX);
                                                              discrete_weight_index++) {
                 weight++;
             }
             if (weight != 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             if (discrete_weight_index > info->max_discrete_class) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type + (discrete_weight_index - 1);
          
             break;

        default:
             rc = BCM_E_PARAM;
             break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_port_tcg_validate(int unit, bcm_gport_t gport, SOC_TMC_TCG_NDX tcg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 nof_priorities;
    int port;

    BCMDNX_INIT_FUNC_DEFS;
    /* Retreive port */
    rc = bcm_petra_cosq_user_port_get(unit, gport, &port);
    BCMDNX_IF_ERR_EXIT(rc);
    
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));

    if (tcg >= nof_priorities) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("cosq is out of range. Should be in range of 0-%d. gport: 0x%x cosq %d failed, error(0x%x)"), nof_priorities, gport, tcg, rc));
    }

    if (nof_priorities != DPP_COSQ_TCG_NOF_PRIORITIES_SUPPORT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d TCG is not supported for given port 0x%x. "), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_port_priority_validate(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 nof_priorities;
    int port;

    BCMDNX_INIT_FUNC_DEFS;
    /* Retreive port */
    rc = bcm_petra_cosq_user_port_get(unit, gport, &port);
    BCMDNX_IF_ERR_EXIT(rc);
    
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));

    if (cosq >= nof_priorities) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("cosq is out of range. Should be in range of 0-%d. gport: 0x%x cosq %d failed, error(0x%x)"), nof_priorities - 1, gport, cosq, rc));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_validate_info_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int flags, bcm_dpp_cosq_gport_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;
    int is_child, is_parent, is_sched_object_ns, is_connnector_object;
    uint8 is_connector = FALSE, is_se = FALSE;
    uint8 is_non_contiguous = FALSE, is_composite = FALSE, is_dual = FALSE;
    uint8 is_sf2 = FALSE;
    int is_odd_even = TRUE;
    int base_flow_id = -1, flow_id = -1, sf2_id = -1, flow_region;
    SOC_TMC_SCH_SE_ID se_id = 0;
    int pass2 = FALSE;
    SOC_TMC_SCH_FLOW *flow_config;
    SOC_TMC_SCH_SE_INFO *se_config;
    uint32 soc_sand_rc, port;    
    int gport_sf2_type;
    int priority = 0;
    int state_check = FALSE, is_warmboot_phase = FALSE, is_reserved;
    int fap_port, core;
    bcm_dpp_cosq_connector_config_t  *conn_info;
    bcm_dpp_cosq_se_config_t *se_info;

    BCMDNX_INIT_FUNC_DEFS;

    /* coverity[deref_ptr:FALSE] */
    flow_config = info->flow_config;
    se_config = info->se_config;

    SOC_TMC_SCH_FLOW_clear(flow_config);
    SOC_TMC_SCH_SE_INFO_clear(se_config);    

    is_child = (flags & dpp_device_cosq_gport_child_element) ? TRUE : FALSE;
    is_parent = (flags & dpp_device_cosq_gport_parent_element) ? TRUE : FALSE;
    is_sched_object_ns = (flags & dpp_device_cosq_gport_sched_nocirpir_ds_element) ? TRUE : FALSE;
    is_connnector_object = (flags & dpp_device_cosq_gport_connector_element) ? TRUE : FALSE;

#ifdef BCM_WARM_BOOT_SUPPORT
    BCM_DPP_UNIT_CHECK(unit);

    if (SOC_WARM_BOOT(unit)) {
        is_warmboot_phase = TRUE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /*
     * consistency checks
     */
    if (is_child) {
        if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport) ||
              BCM_GPORT_IS_SCHEDULER(gport) || BCM_COSQ_GPORT_IS_SCHED_CIR(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_PIR(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Unexpected child gport type, 0x%x"), gport));
        }
    }  

    if (is_parent) {
        if (!(BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_CIR(gport) || BCM_COSQ_GPORT_IS_SCHED_PIR(gport) ||
              BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Unexpected parent gport type, 0x%x"), gport));
        }
    }

    if (is_sched_object_ns) {
        if (!(BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
              BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected sched object name space gport type, 0x%x"), gport));
        }
    }

    if (is_connnector_object) {
        if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected connector gport type, 0x%x"), gport));
        }

        if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
            BCM_INT_DPP_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
            if (gport_sf2_type != BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) {
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected connector gport type, 0x%x"), gport));
            }
        }
    }

    if (BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
            BCM_COSQ_GPORT_IS_SCHED_CIR(gport) || BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) {
        if ((cosq != 0) && (cosq != -1)) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
        }
        is_se = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        if ((cosq < 0) || (cosq > DPP_DEVICE_COSQ_MAX_COS)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
        }
        is_se = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        if ((cosq < 0) || (cosq > DPP_DEVICE_COSQ_MAX_COS)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
        }
        is_connector = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        /* determine if associated with  connector or se */
        BCM_INT_DPP_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
        is_connector = (gport_sf2_type == BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) ? TRUE : FALSE;

        if (is_connector == FALSE) {
            is_se = TRUE;
            if ((cosq != 0) && (cosq != -1)) { 
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
            }
        }
        else {
            if ((cosq < 0) || (cosq > DPP_DEVICE_COSQ_MAX_COS)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, cosq));
            }
        }
    }

    /*
     * determine if the gport is valid (pass1).
     */
    if (BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        rc = _bcm_petra_cosq_fap_port_get(unit, gport, &port, &core);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
            priority = DPP_COSQ_PB_DEFAULT_PORT_TC;
        } else {
            /* Port-TC */
            /* validate priority */
            rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "verify for gport: 0x%x cosq %d failed, error(0x%x)\n"), gport, cosq, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            priority = cosq;
        }

        rc = _bcm_petra_cosq_port2se_id(unit,port,priority,&se_id);
        if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retreive SE for port %d"), unit, port));
        }

        base_flow_id = flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));

        /* retreive SE info */
    }
    else if (BCM_GPORT_IS_SCHEDULER(gport)) {
        base_flow_id = flow_id = BCM_GPORT_SCHEDULER_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_SCHED_CIR_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_SCHED_PIR_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_COMPOSITE_SF2_GET(gport);
        is_sf2 = TRUE;
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retreive SE for port %d"), unit, /* port */0));
    }

    if ( (is_se) && (base_flow_id != -1) ) {
        se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(base_flow_id)));
        if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retreive SE associated with flow %d"), unit, base_flow_id));
        }
    }

    if (is_connector) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, base_flow_id, flow_config)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving sch flow (%d), soc_sand error 0x%x, error 0x%x\n"), unit, base_flow_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }
    else if (is_se) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, se_id, se_config, flow_config)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }

    is_composite = ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                            (flow_config->sub_flow[1].is_valid == TRUE) ) ? TRUE : FALSE;
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, flow_region, &is_non_contiguous, &is_odd_even);
    BCMDNX_IF_ERR_EXIT(rc);

    /* determine if pass2 is required */
    if (BCM_GPORT_IS_SCHEDULER(gport)) {
        if (se_config->is_dual == TRUE) {
            if (is_sched_object_ns == TRUE) {
                is_dual = TRUE;
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, not a dual configuration for se 0x%x"), unit, se_id));
            }
        }
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) {
        if (se_config->is_dual == FALSE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, not a dual configuration for se 0x%x"), unit, se_id));
        }
        is_dual = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) {
        if (se_config->is_dual == FALSE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, not a dual configuration for se 0x%x"), unit, se_id));
        }
        is_dual = TRUE;
        rc = _bcm_petra_se_dual_flow_id_get(unit, base_flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &flow_id);
        BCMDNX_IF_ERR_EXIT(rc);
        se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(flow_id)));
        if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retreive SE associated with flow %d"), unit, flow_id));
        }
        pass2 = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        
        rc = _bcm_petra_flow_id_get(unit, base_flow_id, cosq, is_non_contiguous, is_composite, FALSE,&flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        pass2 = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        if (is_connector) {
            rc = _bcm_petra_flow_id_get(unit, base_flow_id, cosq, is_non_contiguous, is_composite, FALSE, &flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
            pass2 = TRUE;

            rc = _bcm_petra_composite_flow_id_get(unit, base_flow_id, cosq, is_non_contiguous, is_composite,&sf2_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            rc = _bcm_petra_se_composite_flow_id_get(unit, base_flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* pass 2 processing */
    if (pass2 == TRUE) {
        if (is_connector) {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, flow_id, flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving sch flow (%d), soc_sand error 0x%x, error 0x%x\n"), unit, flow_id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
        else if (is_se) {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, se_id, se_config, flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }

    if (info == NULL) {
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    /* state consistency check */
    /* NOTE: if required checking can be based on any additional flags that may be later added */
    if ( (is_warmboot_phase == FALSE) &&
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport) ||
              BCM_GPORT_IS_SCHEDULER(gport) || BCM_COSQ_GPORT_IS_SCHED_CIR(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ) {
        if (is_connector) {
            _bcm_petra_cosq_is_conn_reserved(unit, base_flow_id, &is_reserved);
            if (is_reserved != TRUE) {
                state_check = TRUE;
            }
        }
        else if (is_se) {
            fap_port = DPP_COSQ_SCH_PORT_ID_INVALID(unit);
            _bcm_petra_cosq_is_se_reserved(unit, se_id, &is_reserved);
            rc = _bcm_petra_cosq_se_id2port(unit, se_id, &fap_port, &priority);
            if (rc != BCM_E_NONE) {
                state_check = TRUE;
            }
            else if ( (is_reserved != TRUE) && (fap_port == DPP_COSQ_SCH_PORT_ID_INVALID(unit)) ) {
                state_check = TRUE;
            }
        }
    }
    if (state_check == TRUE) {
        if (is_connector) {
            conn_info = (bcm_dpp_cosq_connector_config_t *)_bcm_petra_cosq_element_get(unit, &(_dpp_cosq_config[unit].connector_hd), base_flow_id);
            if ( (conn_info == NULL) || (conn_info->num_cos == 0) || (cosq >= conn_info->num_cos) ) {
                rc = BCM_E_NOT_FOUND;
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        else if (is_se) {
            se_info = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_get(unit, &(_dpp_cosq_config[unit].se_hd), se_id);
            if ( (se_info == NULL) || (se_info->ref_cnt == 0) ) {
                rc = BCM_E_NOT_FOUND;
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

    /* update data structure */
    info->is_connector = is_connector;
    info->is_se = is_se;
    info->is_composite = is_composite;
    info->is_non_contiguous = is_non_contiguous;
    info->is_dual = is_dual;
    info->is_sf2 = is_sf2;
    info->flow_id = flow_id;
    if (is_se) {
        info->se_id = se_id;
    }

    info->actual_flow_id = flow_id;
    if (is_sf2) {
        info->actual_flow_id = sf2_id;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_validate_connector_id(int unit, int is_non_contiguous, int is_composite, int num_cos, int flow_id)
{
    int rc = BCM_E_NONE;

   
    BCMDNX_INIT_FUNC_DEFS;
    if (is_non_contiguous) {
        if (!(flow_id & 0x2)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, connector 0x%x not at an offset of 2\n"), unit, flow_id));
            rc = BCM_E_PARAM;
        }
    }
    switch (is_non_contiguous) {
        case TRUE:
            switch (is_composite) {
                case TRUE:
                    if (((flow_id - 0x2) % (num_cos * 4)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"),num_cos*4, unit, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                case FALSE:
                    if (((flow_id - 0x2) % (num_cos * 2)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), num_cos*2, unit, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                default: rc = BCM_E_PARAM; break;
            }
            break;

        case FALSE:
            switch (is_composite) {
                case TRUE:
                    if ((flow_id % (num_cos * 2)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), num_cos*2, unit, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                case FALSE:
                    if ((flow_id % num_cos) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), num_cos, unit, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                default: rc = BCM_E_PARAM; break;
            }
            break;

        default: rc = BCM_E_PARAM; break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_parent_gport_to_resource_gport(int unit, bcm_gport_t sched_port, bcm_gport_t *parent_port)
{
    bcm_error_t rc = BCM_E_NONE;
    int sched_id;
    bcm_dpp_cosq_config_t   *cosq_config;


    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];
    (*parent_port) = sched_port;

    if (BCM_GPORT_IS_SCHEDULER(sched_port)) {
        sched_id = BCM_GPORT_SCHEDULER_GET(sched_port);

        if (sched_id >= DPP_COSQ_SCH_MAX_FLOW_ID(unit)) {
            switch (sched_id) {
                case _SHR_GPORT_FMQ_CLASS1:
                    if (cosq_config->fmq_class_ports[0] == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-1 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = cosq_config->fmq_class_ports[0];
                    break;
                case _SHR_GPORT_FMQ_CLASS2:
                    if (cosq_config->fmq_class_ports[1] == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-2 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = cosq_config->fmq_class_ports[1];
                    break;
                case _SHR_GPORT_FMQ_CLASS3:
                    if (cosq_config->fmq_class_ports[2] == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-3 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = cosq_config->fmq_class_ports[2];
                    break;
                case _SHR_GPORT_FMQ_CLASS4:
                    if (cosq_config->fmq_class_ports[3] == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-4 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = cosq_config->fmq_class_ports[3];
                    break;
                case _SHR_GPORT_ISQ_ROOT:
                  if (cosq_config->isq_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, ISQ resource not allocated, need to set isq range\n"), unit));
                        break;
                    }
                    (*parent_port) = cosq_config->isq_port;
                    break;
            default:
              (*parent_port) = sched_port;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Utility Functions
 */


/* function which returns pbmp or internal port associated with the given FAP port */
int
bcm_petra_tm_port_get(int unit, int p_fap_port, bcm_port_t* port)
{
    soc_port_t out_port;
    int     core=0; 
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_tm_to_local_port_get,(unit, core, p_fap_port, &out_port)));

   *port = out_port;

exit:
    BCMDNX_FUNC_RETURN;
}

/* Returns the FAP port associated with the given mod:port gport */

STATIC int
_bcm_petra_cosq_fap_port_get(int unit, bcm_gport_t gport, uint32 *p_fap_port, int* core)
{
    bcm_port_t port = 0;

    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_LOCAL(gport)) {
        port = BCM_GPORT_LOCAL_GET(gport);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DPP_PORT_INTERFACE_START;
        }

    } else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_GET(gport);
        /* if this is the interface, return the fap port associated with that interface */
        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            port -= BCM_DPP_PORT_INTERFACE_START;
        }
    } else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_PORT_TC_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(gport);        
    } else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_PORT_TCG_GET(gport);        
    } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TCG_GET(gport);        
    } else if (BCM_GPORT_IS_MODPORT(gport)) {
        port = BCM_GPORT_MODPORT_PORT_GET(gport);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DPP_PORT_INTERFACE_START;
        }
        
    } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_GET(gport);
    } else if ((SOC_PORT_VALID(unit, port)) && (IS_PORT(unit, port))) {
        port = gport;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Query invalid, port must be of type mod/port or e2e for gport 0x%08x"), gport));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_tm_port_get, (unit, port, p_fap_port, core)));

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) port(%d) fap_port(%d)\n"), unit, port, *p_fap_port));
    
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_user_port_get(int unit, bcm_gport_t gport, bcm_port_t *user_port)
{
    int rc = BCM_E_NONE;
    bcm_port_t port = 0;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_LOCAL(gport)) {
        port = BCM_GPORT_LOCAL_GET(gport);
        
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_GET(gport);

        /* if this is the interface, return the fap port associated with that interface */
        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            port -= BCM_DPP_PORT_INTERFACE_START;
        }
    }
    else if (BCM_GPORT_IS_MODPORT(gport)) {
        port = BCM_GPORT_MODPORT_PORT_GET(gport);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DPP_PORT_INTERFACE_START;
        }
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_PORT_TC_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_PORT_TCG_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TCG_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_GET(gport);
    }
    else if ((SOC_PORT_VALID(unit, gport)) && (IS_PORT(unit, gport))) {
        port = gport;
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Query invalid, port must be of type mod/port or e2e for gport 0x%08x"), gport));
    }

    (*user_port) = port;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fc_port_info_get(int             unit,
                                bcm_gport_t     gport,
                                int            *is_fc_calender,
                                int            *is_fc_inband,
                                uint32         *fc_calender_port,
                                uint32         *nif_id)
{
    int rc = BCM_E_NONE;
    int nif_nbr;
    bcm_port_t user_port;
    int congestion_port, ilkn_port = 0, is_ilkn;


    BCMDNX_INIT_FUNC_DEFS;
    /* check if it is a congestion port */
    if (BCM_GPORT_IS_CONGESTION(gport)) {
        congestion_port = BCM_GPORT_CONGESTION_GET(gport);
        if (congestion_port >= SOC_DPP_CONFIG(unit)->tm.max_oob_ports) {
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "invalid congestion port (%d)\n"), congestion_port));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        (*is_fc_calender) = TRUE;
        (*is_fc_inband) = FALSE;
        (*fc_calender_port) = congestion_port;
        (*nif_id) = congestion_port;

        goto exit;
    }

    rc = bcm_petra_cosq_user_port_get(unit, gport, &user_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = bcm_port_to_nif_id(unit, user_port, &nif_nbr);
    BCMDNX_IF_ERR_EXIT(rc);

    is_ilkn = FALSE;

#ifdef BCM_PETRAB_SUPPORT
    if(SOC_IS_PETRAB(unit))
    {
      is_ilkn = SOC_PB_NIF_IS_TYPE_ID(ILKN, nif_nbr);
      ilkn_port = nif_nbr - SOC_PB_NIF_ID_ILKN_FIRST;
    }
#endif
#ifdef BCM_ARAD_SUPPORT
    if(SOC_IS_ARAD(unit))
    {
      is_ilkn = ARAD_NIF_IS_TYPE_ID(ILKN, nif_nbr);
      ilkn_port = nif_nbr - ARAD_NIF_ID_ILKN_FIRST;
    }
#endif

    if (is_ilkn) {
        if (ilkn_port >= SOC_DPP_CONFIG(unit)->tm.max_interlaken_ports) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "invalid interlaken port (%d)\n"), ilkn_port));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
        (*is_fc_calender) = TRUE;
        (*is_fc_inband) = TRUE;
        (*fc_calender_port) = ilkn_port;
        (*nif_id) = nif_nbr;
    }
    else {
        (*is_fc_calender) = FALSE;
        (*is_fc_inband) = TRUE;
        (*fc_calender_port) = -1;
        (*nif_id) = nif_nbr;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_port_info_get(int             unit,
                             bcm_gport_t     gport,
                             int            *is_channelization_ability,
                             int            *no_classes,
                             uint32         *nif_id,
                             int            *no_queues)
{
    int rc = BCM_E_NONE;
    int nif_nbr;
    bcm_port_t user_port;

#ifdef BCM_ARAD_SUPPORT
      ARAD_NIF_TYPE interface_type;
#endif
    
    BCMDNX_INIT_FUNC_DEFS;
    rc = bcm_petra_cosq_user_port_get(unit, gport, &user_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = bcm_port_to_nif_id(unit, user_port, &nif_nbr);
    BCMDNX_IF_ERR_EXIT(rc);

    (*nif_id) = nif_nbr;
    if SOC_PB_NIF_IS_TYPE_ID(XAUI, nif_nbr) {
        (*no_classes) = 8;
        (*is_channelization_ability) = FALSE;
    }
    else if SOC_PB_NIF_IS_TYPE_ID(RXAUI, nif_nbr) {
        (*no_classes) = 8;
        (*is_channelization_ability) = FALSE;
    }
    else if SOC_PB_NIF_IS_TYPE_ID(SGMII, nif_nbr) {
        (*no_classes) = 2;
        (*is_channelization_ability) = FALSE;
    }
    else if SOC_PB_NIF_IS_TYPE_ID(QSGMII, nif_nbr) {
        (*no_classes) = 2;
        (*is_channelization_ability) = FALSE;
    }
    else if SOC_PB_NIF_IS_TYPE_ID(ILKN, nif_nbr) {
        (*no_classes) = 8;
        (*is_channelization_ability) = TRUE;
    }
#ifdef BCM_ARAD_SUPPORT
    else if(SOC_IS_ARAD(unit)) {
      interface_type = arad_nif_id2type(nif_nbr);
      if(interface_type == ARAD_NIF_TYPE_10GBASE_R) {
        (*no_classes) = 8;
        (*is_channelization_ability) = FALSE;
      }
      else if(interface_type == ARAD_NIF_TYPE_40G_XLGE) {
        (*no_classes) = 8;
        (*is_channelization_ability) = FALSE;
      }
      else if(interface_type == ARAD_NIF_TYPE_100G_CGE) {
        (*no_classes) = 8;
        (*is_channelization_ability) = FALSE;
      }
      else {
        rc = BCM_E_INTERNAL;
      }
    }
#endif
    else {
        
        rc = BCM_E_INTERNAL;
    }

    
    (*no_queues) = 2;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_port_nif_get(int              unit,
                             bcm_gport_t     gport,
                             uint32         *nif_id)
{
    int rc = BCM_E_NONE;
    int nif_nbr;
    bcm_port_t user_port;

    
    BCMDNX_INIT_FUNC_DEFS;
    rc = bcm_petra_cosq_user_port_get(unit, gport, &user_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = bcm_port_to_nif_id(unit, user_port, &nif_nbr);
    BCMDNX_IF_ERR_EXIT(rc);

    (*nif_id) = nif_nbr;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_nif_to_gport_get(int              unit,
                                uint32          nif_id,
                                bcm_gport_t     *gport)
{
    int rc = BCM_E_NONE;
    bcm_port_t user_port;
    bcm_gport_t gport_lcl;

    
    BCMDNX_INIT_FUNC_DEFS;

    rc = bcm_port_from_nif_id(unit, nif_id, &user_port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Local port to Gport */
    BCM_GPORT_LOCAL_SET(gport_lcl, user_port);
    
    (*gport) = gport_lcl;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC unsigned int
_bcm_cosq_bit_count_get(uint32 value)
{ 
    uint32 count = 0; 

    while (value > 0) {           /* until all bits are zero  */
        if ((value & 1) == 1) {   /* check lower bit */
            count++; 
        } 
        value >>= 1;              /* shift bits, removing lower bit */
    } 

    return count;
} 


/*
 * element (data structure) allocation
 */
/* This function to be populated if we allocate dynamically memory for */
/* flow_hd, se_hd, connector_hd, voq_hd rather than having this fixed  */
/* in the bcm_dpp_cosq_config_t structure                              */
/* structure.                                                          */            
/* static */ bcm_dpp_cosq_list_hd_t *
_bcm_petra_cosq_listhd_alloc(int unit)
{
    return(NULL);
}
/* This function populates the information about the list being created */
/* It does not allocate the memory for the data structure to be stored */
STATIC int
_bcm_petra_cosq_listhd_init(int unit,
                            bcm_dpp_cosq_list_hd_t *hd,
                            int num_elements_per_blk,
                            int element_size,
                            int index_divisor,
                            bcm_dpp_cosq_hdlist_type_t type)
{
    int rc = BCM_E_NONE;
    char *type_str;

    BCMDNX_INIT_FUNC_DEFS;
    if (hd == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid head pointer %p"), unit, hd));
    }

 
    hd->num_elements_per_blk = num_elements_per_blk;
    hd->element_size = element_size;
    if (type >= dpp_cosq_hdlist_invalid) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid list type(%d)"), unit, type));
    }
    type_str = _dpp_list_hd_type_str[type];
    hd->type = type;

    hd->index_divisor = index_divisor;
    hd->blk = NULL;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) create hdlist memory for type(%s) num_elements_per_blk(%d) sz(%d)\n"),
                          unit, type_str, num_elements_per_blk, element_size));
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* This function allocates a block of memory if the block hasn't already been allocated */
/* for the given index.  Currently, only a single block is supported.  In the future    */
/* this can be extended to support multiple blocks of smaller configurable sizes        */
/* (num_elements_per_blk)                                                               */
uint8*
_bcm_petra_cosq_element_alloc(int unit, bcm_dpp_cosq_list_hd_t *hd, int element_index)
{
    char *type_str;
    bcm_dpp_cosq_blk_info_t *blk_p;
    uint8 *element = NULL;
    void    *p;

    if (hd == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Invalid head pointer (%p)\n"), unit, hd));
        return NULL;
    }

    if (hd->type >= dpp_cosq_hdlist_invalid) { 
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) cosq state invalid type(%d\n"), unit, hd->type));
        return NULL;
    }
    type_str = _dpp_list_hd_type_str[hd->type];

    if (hd->blk == NULL) {
        /* Allocate block */
        hd->blk = sal_alloc(sizeof(bcm_dpp_cosq_blk_info_t), "block info");
        if (hd->blk == NULL) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) block allocation failed cosq state(%s)\n"), unit, type_str));
            return NULL;
        }
        sal_memset(hd->blk, 0x00, sizeof(*(hd->blk)));

        
        blk_p = hd->blk;
        blk_p->start_element = 0;
        blk_p->end_element = (hd->num_elements_per_blk)/(hd->index_divisor);
        blk_p->count = hd->num_elements_per_blk;
        blk_p->used = 0;
        blk_p->data = sal_alloc((hd->element_size * hd->num_elements_per_blk), type_str);

        if (blk_p->data == NULL) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "Unit(%d) element allocation failed cosq state(%s)\n"), unit, type_str));
            return NULL;
        }
        sal_memset(blk_p->data, 0, (hd->element_size * hd->num_elements_per_blk));
        
        p = (void *)((char *)blk_p->data + (hd->element_size * hd->num_elements_per_blk));
        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) allocate block cosq state for ( %s) start_addr(%p) end_addr(%p) num_elem(%d)\n"),
                              unit, type_str, blk_p->data, p,
                   hd->num_elements_per_blk));

    } else {
        blk_p = hd->blk;
    }

    element = (uint8 *)(blk_p->data);
    element += (element_index/(hd->index_divisor)) * hd->element_size;


    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) give cosq state from( %s) for element_index(%d) address(%p) divisor(%d) size(%d)\n"),
                          unit, type_str, element_index, element, hd->index_divisor, hd->element_size ));
    return(element);
}

uint8 *
_bcm_petra_cosq_element_get(int unit, bcm_dpp_cosq_list_hd_t *hd, int element_index)
{
    char *type_str;
    bcm_dpp_cosq_blk_info_t *blk_p;
    uint8 *element = NULL;


    if (hd == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Invalid head pointer (%p)\n"), unit, hd));
        return NULL;
    }

    if (hd->type >=  dpp_cosq_hdlist_invalid) { 
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) cosq state invalid type(%d)\n"), unit, hd->type));
        return NULL;
    }

    type_str = _dpp_list_hd_type_str[hd->type];

    if (hd->blk == NULL) {
        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) cosq state (%s) not allocated\n"), unit, type_str));
        return NULL;
        
    } else {
        blk_p = hd->blk;
    }

     
    element = (uint8 *)(blk_p->data);
    element += (element_index/(hd->index_divisor)) * hd->element_size;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) get cosq state from( %s) for element_index(%d) address(0x%p)\n"),
                          unit, type_str, element_index, element));
    return(element);
}

STATIC int
_bcm_petra_cosq_element_free(int unit, bcm_dpp_cosq_list_hd_t *hd, int element_index)
{
    int                       rc = BCM_E_NONE;
    bcm_dpp_cosq_blk_info_t  *blk_p;
    uint8                    *element = NULL;


    BCMDNX_INIT_FUNC_DEFS;
    if ( (hd == NULL) || (hd->type >= dpp_cosq_hdlist_invalid) || (hd->blk == NULL) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid head pointer (%p)"), unit, hd));
    }

    blk_p = hd->blk;

    element = (uint8 *)(blk_p->data);
    element += (element_index/(hd->index_divisor)) * hd->element_size;

    sal_memset(element, 0x0, hd->element_size);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_fmq_hr_port_allocate(int unit, int nbr_ports, int *ports)
{
    int rc = BCM_E_NONE;
    int index = 0;
    bcm_gport_t sysport,mod_gport;
    int mymodid;
    SOC_TMC_SCH_PORT_INFO port_info;
    uint32 soc_sand_rc;
#ifdef BCM_ARAD_SUPPORT
    int* hr_fmq_array = NULL;
#endif
    
    int     core=0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* 
     * FMQ and ISQ HRs are being assumed to be allocated after soc init.
     * All HRs that are currently used are Ports-HRs
     * FMQ and ISQ HRs must be allocated from a free PS.
     * So first find a free PS and then allocate HRs.
     * This being handled in the following API.
     */ 
#ifdef BCM_ARAD_SUPPORT 
    if (SOC_IS_ARAD(unit)) {
        rc = soc_arad_fmq_base_hr_get(unit,&hr_fmq_array);
        BCMDNX_IF_ERR_EXIT(rc);
    }
#endif
    /* 
     * Allocate unused local ports
     */
    for (index = 0; index < nbr_ports; index++) {
        rc = _bcm_petra_port_find_free_port_and_allocate(unit, SOC_PORT_IF_NOCXN, 0, &ports[index]);
        BCMDNX_IF_ERR_EXIT(rc);

#ifdef  BCM_ARAD_SUPPORT
        if (SOC_IS_ARAD(unit)) {
            soc_port_t logical_port;

            soc_sand_rc = arad_egr_dsp_pp_to_base_q_pair_set(unit, core, ports[index], hr_fmq_array[index]);
            BCMDNX_IF_ERR_EXIT(soc_sand_rc); 
            
            if (hr_fmq_array[index] % 8 == 0) { /* Set new configured PS */
                soc_sand_rc = arad_egr_dsp_pp_priorities_mode_set(unit, core, ports[index], SOC_TMC_EGR_PORT_ONE_PRIORITY);
                BCMDNX_IF_ERR_EXIT(soc_sand_rc);
            } 

            /* Update only SW */
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, ports[index], &logical_port));
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_set(unit, logical_port, 1));
        }
#endif
    }  

    for (index = 0; index < nbr_ports; index++) {
        /* Set port enable */        
        SOC_TMC_SCH_PORT_INFO_clear(&port_info);
        port_info.enable = TRUE;
        DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, ports[index], &port_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);        
    }

    if (SOC_IS_PETRAB(unit)) {
      
      rc = bcm_petra_stk_my_modid_get(unit,&mymodid);
      BCMDNX_IF_ERR_EXIT(rc);

      for (index = 0; index < nbr_ports; index++) {
          BCM_GPORT_MODPORT_SET(mod_gport,mymodid,ports[index]);
          BCM_GPORT_SYSTEM_PORT_ID_SET(sysport,ports[index]);

          rc = bcm_petra_stk_sysport_gport_set(unit,sysport,mod_gport);
          BCMDNX_IF_ERR_EXIT(rc);           
      }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_fmq_hr_port_deallocate(int unit, int nbr_ports, int *ports)
{
    int rc = BCM_E_NONE;
    int index = 0;


    BCMDNX_INIT_FUNC_DEFS;
    
    for (index = 0; index < nbr_ports; index++) {
        ;
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_WARM_BOOT_SUPPORT
STATIC int
bcm_petra_cosq_restore_fmq_hr_state(int unit)
{
    int                      rc = BCM_E_NONE;
    int                      index, nbr_ports, ports[DPP_DEVICE_FMQ_CLASS_PORTS];
    SOC_TMC_SCH_SE_ID            se_id[DPP_DEVICE_FMQ_CLASS_PORTS];
    int                      flow_id[DPP_DEVICE_FMQ_CLASS_PORTS];
    bcm_dpp_cosq_config_t   *cosq_config;


    BCMDNX_INIT_FUNC_DEFS;

    cosq_config = &_dpp_cosq_config[unit];

    rc = bcm_petra_fabric_enhance_ports_get(unit, &nbr_ports, ports);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nbr_ports == 0) {
        /* state already initialized */
        BCM_EXIT;
    }

    for (index = 0; index < nbr_ports; index++) {

        /* retreive corresponding SE element */
        rc = _bcm_petra_cosq_port2se_id(unit, ports[index], DPP_COSQ_PB_DEFAULT_PORT_TC, &(se_id[index]));
        if (rc != BCM_E_NONE || se_id[index] == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in retreiving seId for fapPort(%d)"), unit, ports[index]));
        }

        /* retreive corresponding flow id */
        flow_id[index] = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,( (se_id[index]))));
        if (flow_id[index] == DPP_COSQ_SCH_FLOW_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in retreiving FlowId for seId(0x%x)"), unit, se_id[index]));
        }
    }

    /* update local data structures with FMQ Class Schedulers */
    for (index = 0; index < nbr_ports; index++) {
        /* scheduler gport format */
        BCM_GPORT_SCHEDULER_SET(cosq_config->fmq_class_ports[index], flow_id[index]);
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:

    BCMDNX_FUNC_RETURN;
}

#endif /* BCM_WARM_BOOT_SUPPORT */

STATIC int
_bcm_petra_cosq_isq_hr_port_allocate(int unit, int *port)
{
    int rc = BCM_E_NONE;
    SOC_TMC_SCH_PORT_INFO port_info;
    uint32 soc_sand_rc;
#ifdef BCM_ARAD_SUPPORT    
    int hr_isq;
#endif
    int     core=0; 

    BCMDNX_INIT_FUNC_DEFS;
#ifdef BCM_ARAD_SUPPORT    
    /* 
     * FMQ and ISQ HRs are being assumed to be allocated after soc init.
     * All HRs that are currently used are Ports-HRs
     * FMQ and ISQ HRs must be allocated from a free PS.
     * for ARAD first find a free PS and then allocate HRs.
     * This being handled in the following API.
     */ 

    if (SOC_IS_ARAD(unit)) {
        rc = soc_arad_isq_hr_get(unit,&hr_isq);
        BCMDNX_IF_ERR_EXIT(rc);
    }
#endif
    
    /* 
     * Allocate unused local ports
     */
    rc = _bcm_petra_port_find_free_port_and_allocate(unit, SOC_PORT_IF_NOCXN, 0, port);
    BCMDNX_IF_ERR_EXIT(rc);

#ifdef  BCM_ARAD_SUPPORT   
    if (SOC_IS_ARAD(unit)) {
        soc_port_t logical_port;

        soc_sand_rc = arad_egr_dsp_pp_to_base_q_pair_set(unit, core, *port, hr_isq);
        BCMDNX_IF_ERR_EXIT(soc_sand_rc); 
        
        if (hr_isq % 8 == 0) { /* Set new configured PS */
            soc_sand_rc = arad_egr_dsp_pp_priorities_mode_set(unit, core, *port, SOC_TMC_EGR_PORT_ONE_PRIORITY);
            BCMDNX_IF_ERR_EXIT(soc_sand_rc);
        } 
        /* Update only SW */
        BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, *port, &logical_port));
        BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_set(unit, logical_port, 1));
                         
    }
#endif
    
    /* Set port enable */        
    SOC_TMC_SCH_PORT_INFO_clear(&port_info);
    port_info.enable = TRUE;
    DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
    if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
    }    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, *port, &port_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);        

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_isq_hr_port_deallocate(int unit, int *port)
{
    int rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * External Functions
 */
int
bcm_petra_cosq_fmq_hr_allocate(int unit, int nbr_ports, int *ports)
{
    int index = 0;
    int rc = BCM_E_NONE;
    bcm_dpp_cosq_config_t   *cosq_config;
    uint32 soc_sand_rc;
    SOC_TMC_SCH_SE_ID se_id[DPP_DEVICE_FMQ_CLASS_PORTS];
    int flow_id[DPP_DEVICE_FMQ_CLASS_PORTS];
    SOC_TMC_SCH_SE_INFO se_info;
    SOC_TMC_SCH_FLOW  sch_flow, exact_sch_flow;    
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    cosq_config = &_dpp_cosq_config[unit];

    if (nbr_ports > DPP_DEVICE_FMQ_CLASS_PORTS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, number of ports %d, is out of range"), unit, nbr_ports));
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(&sch_flow);
    SOC_TMC_SCH_FLOW_clear(&exact_sch_flow);

    rc = _bcm_petra_cosq_fmq_hr_port_allocate(unit, nbr_ports, ports);
    BCMDNX_IF_ERR_EXIT(rc);


    /* enable the HR scheduler elements */
    for (index = 0; index < nbr_ports; index++) {        

        /* retreive corresponding SE element */
        rc = _bcm_petra_cosq_port2se_id(unit,ports[index],DPP_COSQ_PB_DEFAULT_PORT_TC,&(se_id[index]));
        if (rc != BCM_E_NONE || se_id[index] == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            rc = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, ports[index]));
            goto err;
        }

        /* retreive corresponding flow id */
        flow_id[index] = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,((se_id[index]))));
        if (flow_id[index] == DPP_COSQ_SCH_FLOW_ID_INVALID(unit)) {
            rc = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving FlowId for seId(0x%x)\n"), unit, se_id[index]));
            goto err;
        }

        /* configure scheduler element */
        soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, se_id[index], &se_info, &sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id[index], soc_sand_rc, rc));
            goto err;
        }

        se_info.state = SOC_TMC_SCH_SE_STATE_ENABLE;
        se_info.type_info.hr.mode = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_id[index], &se_info, &sch_flow, &exact_sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id[index], soc_sand_rc, rc));
            goto err;
        }
    }

    /* update local data structures with FMQ Class Schedulers */
    for (index = 0; index < nbr_ports; index++) {
        /* scheduler gport format */
        BCM_GPORT_SCHEDULER_SET(cosq_config->fmq_class_ports[index], flow_id[index]);
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_ucast_qid_range_set(int unit, int core, int qid_start, int qid_end)
{   
    int                      rc = BCM_E_NONE;
    bcm_dpp_cosq_config_t   *cosq_config;
    int                     core_index;


    BCMDNX_INIT_FUNC_DEFS;

    cosq_config = &_dpp_cosq_config[unit];
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index){
        if (qid_start != -1) {
            cosq_config->ingress[core_index].ucast_qid_start = qid_start;
        }
        if (qid_end != -1) {
            cosq_config->ingress[core_index].ucast_qid_end = qid_end;
        }
    }
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_ucast_qid_range_get(int unit, int core, int *qid_start, int *qid_end)
{   
    int                      rc = BCM_E_NONE;
    bcm_dpp_cosq_config_t   *cosq_config;
    int                     core_index = (core == BCM_CORE_ALL || SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit)) ? 0 : core;

    BCMDNX_INIT_FUNC_DEFS;

    cosq_config = &_dpp_cosq_config[unit];

    (*qid_start) = cosq_config->ingress[core_index].ucast_qid_start;
    (*qid_end) = cosq_config->ingress[core_index].ucast_qid_end;

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_is_se_reserved(int unit, int se_id, int *is_reserved)
{
    int                      rc = BCM_E_NONE;
    bcm_dpp_cosq_config_t   *cosq_config;
    int fap_port;
    bcm_cos_t priority;

    BCMDNX_INIT_FUNC_DEFS;
    
    cosq_config = &_dpp_cosq_config[unit];
    (*is_reserved) = FALSE;
    
    if ( (se_id >= SOC_DPP_CONFIG(unit)->tm.port_hr_se_min) && (se_id <= SOC_DPP_CONFIG(unit)->tm.port_hr_se_max) ) {
        if (SOC_IS_PETRAB(unit)) {
            (*is_reserved) = TRUE;
        } else { /* ARAD */
            rc = _bcm_petra_cosq_se_id2port(unit, se_id, &fap_port, &priority);
            if (rc == BCM_E_NONE) {
                if (DPP_COSQ_SCH_PORT_ID_INVALID(unit) != fap_port) {
                    (*is_reserved) = TRUE;
                }
            }
        }
    }

    if (se_id == cosq_config->default_se) {
        (*is_reserved) = TRUE;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int 
_bcm_petra_cosq_is_conn_reserved(int unit, int conn_id, int *is_reserved)
{
    BCMDNX_INIT_FUNC_DEFS;

    (*is_reserved) = FALSE;

    if ( (conn_id >= DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) &&
         (conn_id < (DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START +
                         DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS)) ) {
        (*is_reserved) = TRUE;
    }

    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_is_queue_reserved(int unit, int queue_id, int *is_reserved)
{
    int                      rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;

    (*is_reserved) = FALSE;

    
    /*         currently the following range is always reserved in allocation manager */
    /*         during init phase. This will change once enhanced mode is supported.   */
    if ( (queue_id >= DPP_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MIN) && (queue_id <= DPP_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MAX) ) {
        (*is_reserved) = TRUE;
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fmq_hr_deallocate(int unit, int nbr_ports, int *ports)
{
    int index = 0;
    int rc = BCM_E_NONE;
    bcm_dpp_cosq_config_t   *cosq_config;
    uint32 soc_sand_rc;
    SOC_TMC_SCH_SE_ID se_id;
    SOC_TMC_SCH_SE_INFO se_info;
    SOC_TMC_SCH_FLOW  sch_flow, exact_sch_flow;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    cosq_config = &_dpp_cosq_config[unit];

    if (nbr_ports > DPP_DEVICE_FMQ_CLASS_PORTS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, number of ports %d, is out of range"), unit, nbr_ports));
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(&sch_flow);
    SOC_TMC_SCH_FLOW_clear(&exact_sch_flow);

    

    for (index = 0; index < nbr_ports; index++) {
        /* retreive corresponding SE element */
        rc = _bcm_petra_cosq_port2se_id(unit,ports[index],DPP_COSQ_PB_DEFAULT_PORT_TC,&se_id);
        if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            rc = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, ports[index]));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* configure scheduler element */
        soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, se_id, &se_info, &sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        se_info.state = SOC_TMC_SCH_SE_STATE_DISABLE;
        se_info.type_info.hr.mode = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_id, &se_info, &sch_flow, &exact_sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }

    rc = _bcm_petra_cosq_fmq_hr_port_deallocate(unit, nbr_ports, ports);

    for (index = 0; index < nbr_ports; index++) {
        cosq_config->fmq_class_ports[index] = BCM_GPORT_INVALID;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_isq_hr_allocate(int unit, int *port)
{
    int rc = BCM_E_NONE;
    bcm_dpp_cosq_config_t   *cosq_config;
    uint32 soc_sand_rc;
    SOC_TMC_SCH_SE_ID se_id;
    int flow_id;
    SOC_TMC_SCH_SE_INFO se_info;
    SOC_TMC_SCH_FLOW  sch_flow, exact_sch_flow;    
    
    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];

    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(&sch_flow);
    SOC_TMC_SCH_FLOW_clear(&exact_sch_flow);

    rc = _bcm_petra_cosq_isq_hr_port_allocate(unit, port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* enable the HR scheduler elements */
    /* retreive corresponding SE element */
    rc = _bcm_petra_cosq_port2se_id(unit, *port,DPP_COSQ_PB_DEFAULT_PORT_TC,&(se_id));
    if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
      rc = BCM_E_INTERNAL;
      LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, *port));
      goto err;
    }

    /* retreive corresponding flow id */
    flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,((se_id))));
    if (flow_id == DPP_COSQ_SCH_FLOW_ID_INVALID(unit)) {
      rc = BCM_E_INTERNAL;
      LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, error in retreiving FlowId for seId(0x%x)\n"), unit, se_id));
      goto err;
    }

    /* configure scheduler element */
    soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, se_id, &se_info, &sch_flow)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
      rc = translate_sand_success_failure(soc_sand_rc);
      LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), 
                            unit, se_id, soc_sand_rc, rc));
      goto err;
    }

    se_info.state = SOC_TMC_SCH_SE_STATE_ENABLE;
    se_info.type_info.hr.mode = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_id, &se_info, &sch_flow, &exact_sch_flow)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
      rc = translate_sand_success_failure(soc_sand_rc);
      LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), 
                            unit, se_id, soc_sand_rc, rc));
      goto err;
    }

    /* scheduler gport format */
    BCM_GPORT_SCHEDULER_SET(cosq_config->isq_port, flow_id);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_isq_hr_deallocate(int unit, int *port)
{
    int rc = BCM_E_NONE;
    bcm_dpp_cosq_config_t   *cosq_config;
    uint32 soc_sand_rc;
    SOC_TMC_SCH_SE_ID se_id;
    SOC_TMC_SCH_SE_INFO se_info;
    SOC_TMC_SCH_FLOW  sch_flow, exact_sch_flow;
    
    BCMDNX_INIT_FUNC_DEFS;
    cosq_config = &_dpp_cosq_config[unit];
    
    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(&sch_flow);
    SOC_TMC_SCH_FLOW_clear(&exact_sch_flow);
    
    
    
    /* retreive corresponding SE element */
    rc = _bcm_petra_cosq_port2se_id(unit, *port, DPP_COSQ_PB_DEFAULT_PORT_TC, &se_id);
    if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
        rc = BCM_E_INTERNAL;
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, *port));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    /* configure scheduler element */
    soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, se_id, &se_info, &sch_flow)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }
    
    se_info.state = SOC_TMC_SCH_SE_STATE_DISABLE;
    se_info.type_info.hr.mode = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, se_id, &se_info, &sch_flow, &exact_sch_flow)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }
    
    
    rc = _bcm_petra_cosq_isq_hr_port_deallocate(unit, port);
    
    cosq_config->isq_port = BCM_GPORT_INVALID;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_cosq_fmq_vsq_category_mode_set(int unit, int core, bcm_fabric_vsq_category_mode_t vsq_category_mode)
{
    bcm_dpp_cosq_config_t   *cosq_config;
    int                     core_index;
    BCMDNX_INIT_FUNC_DEFS;

    cosq_config = &_dpp_cosq_config[unit];
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        if (vsq_category_mode < 0 || vsq_category_mode > bcmFabricVsqCatagoryMode2) {
            LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"unit %d, error in setting vsq category mode %d\n"), unit, vsq_category_mode));
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("vsq_category_mode invalid")));
        }
        cosq_config->ingress[core_index].vsq_category_mode = vsq_category_mode;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fmq_vsq_category_mode_get(int unit, int core, bcm_fabric_vsq_category_mode_t *vsq_category_mode)
{
    int rc = BCM_E_NONE;
    bcm_dpp_cosq_config_t   *cosq_config;
    int                     core_index = (core == BCM_CORE_ALL || SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit)) ? 0 : core;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(vsq_category_mode);

    cosq_config = &_dpp_cosq_config[unit];

    *vsq_category_mode = cosq_config->ingress[core_index].vsq_category_mode;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ingress_tc_mapping_set(int unit, 
                                       bcm_port_t port,
                                       bcm_cos_t priority, 
                                       bcm_cos_queue_t cosq)
{
  int rc = BCM_E_NONE;
  int soc_sand_rc = SOC_SAND_OK;
  SOC_TMC_ITM_TC_MAPPING tc_mapping;
  int tc, new_tc, dest_ndx, dest_base_queue, is_allocated, is_last, new_mapping_profile;
  uint32 old_profile;
  int is_flow;
  int nof_quartet,quartet_index;
  bcm_dpp_cosq_voq_config_t *voq_config;
  SOC_TMC_IPQ_EXPLICIT_MAPPING_MODE_INFO mapping_mode_info;
  uint32 flow_mapping_queue_base_offset;
  BCMDNX_INIT_FUNC_DEFS;
  SOC_TMC_ITM_TC_MAPPING_clear(&tc_mapping);

  if(SOC_IS_PETRAB(unit)){
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, only ARAD is supported"), unit));
  }

  if (!BCM_GPORT_IS_SYSTEM_PORT (port) && 
      !BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) && 
      !BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) && 
      !BCM_COSQ_GPORT_IS_ISQ(port)) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
  }

  if (priority < 0 || priority >= DPP_COSQ_PACKET_NOF_TC) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority));
  }

  if (cosq < 0 || cosq >= DPP_COSQ_PACKET_NOF_TC) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq));
  }

  if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port))
  {
    dest_base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    is_flow = 1;
  }
  else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) 
  {
    dest_base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    is_flow = 1;
     
  } 
  else if (BCM_COSQ_GPORT_IS_ISQ(port))
  {
      dest_base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(port);
      is_flow = 1;
  }
  else if (BCM_GPORT_IS_SYSTEM_PORT(port)) 
  {
    dest_ndx = BCM_GPORT_SYSTEM_PORT_ID_GET(port);
    is_flow = 0;
  }
  else 
  {
    /* Protected by higher level function, but added just to be on the safe side */
    return BCM_E_PARAM;
  }

  tc = priority;
  new_tc = cosq;

  if(is_flow)
  {
    /*if dest_ndx is flow then find its num of quartets, else num of quartets is 1*/
    /*get VOQ configuration from dest_base_queue*/
    
    voq_config = (bcm_dpp_cosq_voq_config_t*)_bcm_petra_cosq_element_get(unit, &(_dpp_cosq_config[unit].voq_hd), DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,BCM_CORE_ALL, dest_base_queue));
    /*dest_ndx not allocated, or not configed*/
    if (voq_config ==  NULL || voq_config->num_cos ==  0) 
    {
        BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
    }
    nof_quartet = (voq_config->num_cos)/4;

    /*dest_ndx is the flow id before mapped into VOQ: dest_base_queue - (global offset)*/
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_explicit_mapping_mode_info_get,(unit,&mapping_mode_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc); 

    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    flow_mapping_queue_base_offset = (mapping_mode_info.queue_id_add_not_decrement)?mapping_mode_info.base_queue_id:0;
    dest_ndx = dest_base_queue - flow_mapping_queue_base_offset;

    /* Get old data */
    rc = _bcm_dpp_am_template_ingress_flow_tc_mapping_data_get(unit,dest_ndx ,&tc_mapping);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Set data configuration */
    tc_mapping.new_tc[tc] = new_tc;

    /* Exchange SW Data */
    rc = _bcm_dpp_am_template_ingress_flow_tc_mapping_exchange(unit, dest_ndx, &tc_mapping, &old_profile, &is_last, &new_mapping_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);   
  }
  else
  {
    /*if dest_ndx is flow then find its num of quartets, else num of quartets is 1*/
    nof_quartet = 1;

    /* Get old data */
    rc = _bcm_dpp_am_template_ingress_uc_tc_mapping_data_get(unit,dest_ndx ,&tc_mapping);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Set data configuration */
    tc_mapping.new_tc[tc] = new_tc;

    /* Exchange SW Data */
    rc = _bcm_dpp_am_template_ingress_uc_tc_mapping_exchange(unit, dest_ndx, &tc_mapping, &old_profile, &is_last, &new_mapping_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);
  }

  if (is_allocated) {
    /* Set new profile data */
    rc = _bcm_petra_cosq_ingress_tc_mapping_hw_set(unit, new_mapping_profile, is_flow, &tc_mapping);
    BCMDNX_IF_ERR_EXIT(rc);
  }

  /*for each quartet(dest_ndx + (quartet_index * 4)) configure its profile using new_mapping_profile*/
  for (quartet_index = 0;quartet_index < nof_quartet; quartet_index++) {
      /* Set new mapping */
      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_tc_profile_set,(unit, is_flow, dest_ndx + (quartet_index * 4), new_mapping_profile)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
  }

  BCMDNX_IF_ERR_EXIT(rc);
exit:
  BCMDNX_FUNC_RETURN;
}

STATIC int _bcm_petra_cosq_ingress_tc_mapping_hw_set(int unit,
                                              int profile,
                                              int is_flow,
                                              SOC_TMC_ITM_TC_MAPPING *tc_mapping)
{
  int rc = BCM_E_NONE;
  int soc_sand_rc = SOC_SAND_OK;
  int i;

  BCMDNX_INIT_FUNC_DEFS;
  for(i=0; i < SOC_TMC_NOF_TRAFFIC_CLASSES ; i++)
  {
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_tc_profile_map_set,(unit, profile, is_flow, i, tc_mapping->new_tc[i])));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                   
  }

  BCMDNX_IF_ERR_EXIT(rc);
exit:
  BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ingress_tc_mapping_get(int unit, 
                                       bcm_port_t port,
                                       bcm_cos_t priority, 
                                       bcm_cos_queue_t *cosq)
{
  int rc = BCM_E_NONE;
  SOC_TMC_ITM_TC_MAPPING tc_mapping;
  int dest_ndx=0;
  int is_flow;

  BCMDNX_INIT_FUNC_DEFS;
  SOC_TMC_ITM_TC_MAPPING_clear(&tc_mapping);

  if(SOC_IS_PETRAB(unit)){
    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, only ARAD is supported"), unit));
  }

  if (!BCM_GPORT_IS_SYSTEM_PORT (port) && 
      !BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) && 
      !BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) && 
      !BCM_COSQ_GPORT_IS_ISQ(port)) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
  }

  if (priority < 0 || priority >= DPP_COSQ_PACKET_NOF_TC) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority));
  }

  if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port))
  {
    dest_ndx = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    is_flow = 1;
  }
  else if(BCM_GPORT_IS_MCAST_QUEUE_GROUP(port))
  {
    dest_ndx = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    is_flow = 1;
  }
  else if (BCM_COSQ_GPORT_IS_ISQ(port))
  {
      dest_ndx = BCM_COSQ_GPORT_ISQ_QID_GET(port);
    is_flow = 1;
  }
  else if (BCM_GPORT_IS_SYSTEM_PORT(port)) 
  {
    dest_ndx = BCM_GPORT_SYSTEM_PORT_ID_GET(port);
    is_flow = 0;
  }
  else 
  {
    /* Protected by higher level function, but added just to be on the safe side */
    return BCM_E_PARAM;
  }

  if(is_flow)
  {
    /* Get old data */
    rc = _bcm_dpp_am_template_ingress_flow_tc_mapping_data_get(unit,dest_ndx ,&tc_mapping);
    BCMDNX_IF_ERR_EXIT(rc);
  }
  else
  {
    /* Get old data */
    rc = _bcm_dpp_am_template_ingress_uc_tc_mapping_data_get(unit,dest_ndx ,&tc_mapping);
    BCMDNX_IF_ERR_EXIT(rc);
  }

  if(cosq != NULL)
  {
    *cosq = tc_mapping.new_tc[priority];
  }

  BCMDNX_IF_ERR_EXIT(rc);
exit:
  BCMDNX_FUNC_RETURN;
}
#ifdef BCM_ARAD_SUPPORT
STATIC int _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(int unit, int generic_bm_id, SOC_TMC_FC_PFC_GENERIC_BITMAP *bitmap)
{
    int rc = BCM_E_NONE;
    int soc_sand_rc = SOC_SAND_OK;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_pfc_generic_bitmap_set,(unit, generic_bm_id, bitmap)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                   

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
#endif

STATIC int _bcm_petra_cosq_stk_sysport_set(int unit, int core, bcm_gport_t sysport_gport, int *stk_exist)
{
    int 
        rv = BCM_E_NONE,
        soc_sand_rc = SOC_SAND_OK,
        local_modid;
    uint32
        sysport_modid,
        is_same_domain = 0x0,
        dest_base_queue = 0x0;
    bcm_gport_t
        sysport,
        modport_gport;
    int 
        sysport_domain;
    uint8 
        is_sw_only = FALSE; /*We want to write to HW.*/

    BCMDNX_INIT_FUNC_DEFS;
 
    BCM_DPP_UNIT_CHECK(unit);
    if (stk_exist == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("NULL argument")));
    }

    *stk_exist = 0x0;

    /* Get local modid*/ 
    rv = bcm_petra_stk_my_modid_get(unit, &local_modid);
    if (rv) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "local modid invalid bcm_petra_stk_my_modid_get() rv=%s\n"), bcm_errmsg(rv)));
        BCMDNX_IF_ERR_EXIT(rv);
    }

    /* Get mod/fap id from sysyport */ 
    rv = bcm_petra_stk_sysport_gport_get(unit, sysport_gport, &modport_gport);
    BCMDNX_IF_ERR_EXIT(rv);
    sysport_modid = BCM_GPORT_MODPORT_MODID_GET(modport_gport);

    /* check if modid in other TM doamin */
     rv = bcm_petra_stk_modid_to_domain_find(unit, local_modid, sysport_modid, &is_same_domain);
     BCM_SAND_IF_ERR_EXIT(rv);

     if (is_same_domain == 0x0) {

         /* Get sysport TM-domain */
         rv = bcm_petra_stk_domain_modid_get(unit, sysport_modid, &sysport_domain);
         BCM_SAND_IF_ERR_EXIT(rv);

         /* Set dest_base_queue {16:6 all ones, 5:0 tmd}*/
         dest_base_queue = ((uint32)sysport_domain) | (0x7ff << 6);

         /* connect VOQ to sysport */
         sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(sysport_gport);
         soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_destination_id_packets_base_queue_id_set,(unit, core, sysport, TRUE /* queue is valid */,is_sw_only ,dest_base_queue)));
         rv = handle_sand_result(soc_sand_rc); /* set sysport to base queue mapping */
         if (rv != BCM_E_NONE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "soc_petra_ipq_destination_id_packets_base_queue_id_set() failed \"base queue(%d) sysport(%d)\n"), dest_base_queue, sysport));
         }

         *stk_exist = 0x1;
     }            

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Map from a bcm_cosq_gport_stats_t to a bcm_dpp_counter_t.
 *  if the use_color is true it means that the dp is part of the counter_id
 */
STATIC int
_bcm_dpp_cosq_gport_stat_map(bcm_cosq_gport_stats_t bcmstat,
                             unsigned int use_color, /* If True, the color of stat was used */
                             bcm_dpp_counter_t *ctrstat)
{
    uint8 is_offset_base_stat = TRUE;
    switch(bcmstat){
    case bcmCosqGportOffset0Packets:
        *ctrstat = bcm_dpp_counter_offset0_pkts;
        break;
    case bcmCosqGportOffset0Bytes:
        *ctrstat = bcm_dpp_counter_offset0_bytes;
        break;
    case bcmCosqGportOffset1Packets:
        *ctrstat = bcm_dpp_counter_offset1_pkts;
        break;
    case bcmCosqGportOffset1Bytes:
        *ctrstat = bcm_dpp_counter_offset1_bytes;
        break;
    case bcmCosqGportOffset2Packets:
        *ctrstat = bcm_dpp_counter_offset2_pkts;
        break;
    case bcmCosqGportOffset2Bytes:
        *ctrstat = bcm_dpp_counter_offset2_bytes;
        break;
    case bcmCosqGportOffset3Packets:
        *ctrstat = bcm_dpp_counter_offset3_pkts;
        break;
    case bcmCosqGportOffset3Bytes:
        *ctrstat = bcm_dpp_counter_offset3_bytes;
        break;
    case bcmCosqGportOffset4Packets:
        *ctrstat = bcm_dpp_counter_offset4_pkts;
        break;
    case bcmCosqGportOffset4Bytes:
        *ctrstat = bcm_dpp_counter_offset4_bytes;
        break;
    case bcmCosqGportOffset5Packets:
        *ctrstat = bcm_dpp_counter_offset5_pkts;
        break;
    case bcmCosqGportOffset5Bytes:
        *ctrstat = bcm_dpp_counter_offset5_bytes;
        break;
    case bcmCosqGportOffset6Packets:
        *ctrstat = bcm_dpp_counter_offset6_pkts;
        break;
    case bcmCosqGportOffset6Bytes:
        *ctrstat = bcm_dpp_counter_offset6_bytes;
        break;
    case bcmCosqGportOffset7Packets:
        *ctrstat = bcm_dpp_counter_offset7_pkts;
        break;
    case bcmCosqGportOffset7Bytes:
        *ctrstat = bcm_dpp_counter_offset7_bytes;
        break;
    default:
        is_offset_base_stat = FALSE;
    }
    if(is_offset_base_stat){
        return BCM_E_NONE;
    }
    if (use_color == 0) {
        switch (bcmstat) {
        case bcmCosqGportGreenAcceptedPkts:
            *ctrstat = bcm_dpp_counter_fwd_green_pkts;
            break;
        case bcmCosqGportGreenAcceptedBytes:
            *ctrstat = bcm_dpp_counter_fwd_green_bytes;
            break;
        case bcmCosqGportNotGreenAcceptedPkts:
            *ctrstat = bcm_dpp_counter_fwd_not_green_pkts;
            break;
        case bcmCosqGportNotGreenAcceptedBytes:
            *ctrstat = bcm_dpp_counter_fwd_not_green_bytes;
            break;
        case bcmCosqGportGreenDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_green_pkts;
            break;
        case bcmCosqGportGreenDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_green_bytes;
            break;
        case bcmCosqGportNotGreenDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_not_green_pkts;
            break;
        case bcmCosqGportNotGreenDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_not_green_bytes;
            break;
        case bcmCosqGportYellowAcceptedPkts:
            *ctrstat = bcm_dpp_counter_fwd_yellow_pkts;
            break;
        case bcmCosqGportYellowAcceptedBytes:
            *ctrstat = bcm_dpp_counter_fwd_yellow_bytes;
            break;
        case bcmCosqGportYellowDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_yellow_pkts;
            break;
        case bcmCosqGportYellowDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_yellow_bytes;
            break;
        case bcmCosqGportRedAcceptedPkts:
            *ctrstat = bcm_dpp_counter_fwd_red_pkts;
            break;
        case bcmCosqGportRedAcceptedBytes:
            *ctrstat = bcm_dpp_counter_fwd_red_bytes;
            break;
        case bcmCosqGportRedDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_red_pkts;
            break;
        case bcmCosqGportRedDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_red_bytes;
            break;
        case bcmCosqGportGreenPkts:
            *ctrstat = bcm_dpp_counter_green_pkts;
            break;
        case bcmCosqGportGreenBytes:
            *ctrstat = bcm_dpp_counter_green_bytes;
            break;
        case bcmCosqGportNotGreenPkts:
            *ctrstat = bcm_dpp_counter_not_green_pkts;
            break;
        case bcmCosqGportNotGreenBytes:
            *ctrstat = bcm_dpp_counter_not_green_bytes;
            break;
        case bcmCosqGportDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_bytes;
            break;
        case bcmCosqGportDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_pkts;
            break;
        case bcmCosqGportEnqueuedBytes:
            *ctrstat = bcm_dpp_counter_fwd_bytes;
            break;
        case bcmCosqGportReceivedBytes:
            *ctrstat = bcm_dpp_counter_bytes;
            break;
        case bcmCosqGportEnqueuedPkts:
            *ctrstat = bcm_dpp_counter_fwd_pkts;
            break;
        case bcmCosqGportReceivedPkts:
            *ctrstat = bcm_dpp_counter_pkts;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META("unable to map GPORT stat %d; not supported\n"),
bcmstat));
            return BCM_E_UNAVAIL;
        }
    }
    else /* use_color == 1 */ {
        switch (bcmstat) {
        case bcmCosqGportGreenAcceptedPkts:
        case bcmCosqGportNotGreenAcceptedPkts:
        case bcmCosqGportYellowAcceptedPkts:
        case bcmCosqGportRedAcceptedPkts:
        case bcmCosqGportEnqueuedPkts:
            *ctrstat = bcm_dpp_counter_fwd_pkts;
            break;
        case bcmCosqGportGreenAcceptedBytes:
        case bcmCosqGportNotGreenAcceptedBytes:
        case bcmCosqGportYellowAcceptedBytes:
        case bcmCosqGportRedAcceptedBytes:
        case bcmCosqGportEnqueuedBytes:
            *ctrstat = bcm_dpp_counter_fwd_bytes;
            break;
        case bcmCosqGportGreenDroppedPkts:
        case bcmCosqGportNotGreenDroppedPkts:
        case bcmCosqGportYellowDroppedPkts:
        case bcmCosqGportRedDroppedPkts:
        case bcmCosqGportDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_pkts;
            break;
        case bcmCosqGportGreenDroppedBytes:
        case bcmCosqGportNotGreenDroppedBytes:
        case bcmCosqGportYellowDroppedBytes:
        case bcmCosqGportRedDroppedBytes:
        case bcmCosqGportDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_bytes;
            break;
        case bcmCosqGportNotGreenPkts:
        case bcmCosqGportGreenPkts:
        case bcmCosqGportReceivedPkts:
            *ctrstat = bcm_dpp_counter_pkts;
            break;
        case bcmCosqGportNotGreenBytes:
        case bcmCosqGportGreenBytes:
        case bcmCosqGportReceivedBytes:
            *ctrstat = bcm_dpp_counter_bytes;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META("unable to map GPORT stat %d; not supported\n"),
bcmstat));
            return BCM_E_UNAVAIL;
        }
    }
    return BCM_E_NONE;
}

/*
 *  Figure out the counter processor and counter set ID (and number of sets) to
 *  read according to the requested GPORT and offset.  If the value at
 *  numCosLevels is -1, this will fill in the proper values for the GPORT; if
 *  it is any other value, it assumes the value was already filled in.
 */
STATIC int
_bcm_dpp_cosq_gport_to_counter_proc_and_set(int unit,
                                            bcm_gport_t gport,
                                            int offset,
                                            int maxCtrSet,
                                            bcm_dpp_counter_t ctrStat,
                                            unsigned int *use_color, /* If True, the color of stat was used */
                                            unsigned int *ctrProc,
                                            unsigned int *ctrSet,
                                            uint32 *numCosLevels,
                                            unsigned int *numCtrSet)
{
    int result;
    unsigned int voq;
    bcm_gport_t physPort;
    uint32 flags;
   
    bcm_port_t   user_port;
    uint32       tm_port  = 0;
    uint32       pp_port  = 0;
    int          is_mc = 0;
    unsigned int use_color_get = 0;

    BCMDNX_INIT_FUNC_DEFS;

    result = BCM_E_NONE;
    voq = ~0;
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport)) {
        voq = BCM_COSQ_GPORT_IS_ISQ(gport)? 
            BCM_COSQ_GPORT_ISQ_QID_GET(gport): BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        if ((-1) == (*numCosLevels)) {
            result = _bcm_petra_cosq_ucast_gport_get(unit,
                                                     gport,
                                                     &physPort,
                                                     numCosLevels,
                                                     &flags);
        }
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        voq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        if ((-1) == (*numCosLevels)) {
            result = _bcm_petra_cosq_mcast_gport_get(unit,
                                                     gport,
                                                     &physPort,
                                                     numCosLevels,
                                                     &flags);
        }
    } else if ( BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport) ) {
        int core;

        /* Retreive port */
        result = bcm_petra_cosq_user_port_get(unit, gport, &user_port);
        BCMDNX_IF_ERR_EXIT(result);
        /* For egress TM counter there are 8 traffic classes, not matter what the EGQ's priority level is */
        *numCosLevels = DPP_DEVICE_COSQ_EGR_NOF_TC;

        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_tm_port_get, (unit, user_port, &tm_port, &core)));
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, user_port, &pp_port, &core)));

    } else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "COSQ stats not supported for unit"
                              " %d GPORT %08X\n"),
                   unit,
                   gport));
        result = BCM_E_PARAM;
    }

    if (BCM_E_NONE == result) {
        if (SOC_IS_ARAD(unit) && (0 <= offset) && (*numCosLevels > offset)) {

            is_mc = ((BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) ? 1 : 0);
            if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))  {
                 result = bcm_dpp_counter_find_egress_que(unit,
                         maxCtrSet,
                         offset,
                         tm_port, 
                         is_mc,
                         pp_port,
                         ctrStat,
                         &use_color_get,
                         ctrProc,
                         ctrSet,  
                         numCtrSet);
            } else {
                result = bcm_dpp_counter_find_voq(unit,
                                              voq + offset,
                                              ctrProc,
                                              ctrSet,
                                              ctrStat,
                                              NULL,        
                                              NULL);
                if (numCtrSet != NULL) {
                    *numCtrSet = 1;
                }
            }
        } else { /* if ((0 <= offset) && (numCosLevels > offset)) */
            result = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d gport %08X offset %d is"
                                  " not valid (must be 0..%d)\n"),
                       unit,
                       gport,
                       offset,
                       *numCosLevels));
        } /* if ((0 <= offset) && (numCosLevels > offset)) */
    } /* if (BCM_E_NONE == result) */
    BCMDNX_IF_ERR_EXIT(result);

    if (use_color != NULL) {
        *use_color = use_color_get;
    }
exit:
    BCMDNX_FUNC_RETURN;

}

/*
 *  Get a statistic for a GPORT (and a specific offset within that GPORT)
 */
int
bcm_petra_cosq_gport_stat_get(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              bcm_cosq_gport_stats_t stat,
                              uint64 *value)
{
    unsigned int ctrProc;
    unsigned int ctrSet[DPP_COSQ_COUNTERS_MAX_SETS];
    bcm_dpp_counter_t ctrStat;
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    uint64 v, total_v;
    unsigned int i, numCtrSet;
    unsigned int use_color;


    BCMDNX_INIT_FUNC_DEFS;

    /*convert to internal type*/
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stat, 0, &ctrStat));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                                gport,                                                               
                                                                cosq,
                                                                DPP_COSQ_COUNTERS_MAX_SETS,
                                                                ctrStat,
                                                                &use_color,
                                                                &ctrProc,
                                                                ctrSet,
                                                                &numCosLevels,
                                                                &numCtrSet));

    /*convert the type (important just for case of egress que counting)*/
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stat, use_color, &ctrStat));
    COMPILER_64_ZERO(total_v);
    for (i=0; i<numCtrSet; i++) {
        BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_get(unit, ctrProc, ctrSet[i], ctrStat, &v));
        COMPILER_64_ADD_64(total_v, v);
    }
    *value = total_v;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * read many stats by one call. We don't update the counters with direct read in this API 
*/
int
bcm_petra_cosq_gport_statistic_multi_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_gport_t lgl_gport,
                                   bcm_cos_queue_t cosq,
                                   int stat_count,
                                   bcm_cosq_gport_stats_t *stats_array,
                                   int value_count,
                                   uint64 *value_array)
{
    unsigned int ctrProc;
    unsigned int ctrSet[1];
    bcm_dpp_counter_t ctrStat[DPP_COSQ_COUNTERS_MAX_STATS];
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    unsigned int stat_index;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(stats_array);
    BCMDNX_NULL_CHECK(value_array);
    if(stat_count != value_count){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("stat_count must be equal to value_count")));
    }
    if (stat_count > DPP_COSQ_COUNTERS_MAX_STATS){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("stat_count must be lower than %d"), DPP_COSQ_COUNTERS_MAX_STATS));
    }
    /* not a voq gport*/
    if(!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(lgl_gport) || BCM_COSQ_GPORT_IS_ISQ(lgl_gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(lgl_gport))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("COSQ statistic multi get support just for voq GPORT types and not %08X\n"), lgl_gport));
    }
    for ( stat_index = 0 ; stat_index < stat_count ; stat_index++){
        /*convert to internal type*/
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stats_array[stat_index], 0, &ctrStat[stat_index]));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                                lgl_gport,                                                               
                                                                cosq,
                                                                DPP_COSQ_COUNTERS_MAX_SETS,
                                                                ctrStat[0],
                                                                NULL,
                                                                &ctrProc,
                                                                ctrSet,
                                                                &numCosLevels,
                                                                NULL));
    BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_multi_get(unit, ctrProc, *ctrSet, stat_count, ctrStat, value_array));

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Set a statistic for a GPORT (and a specific offset within that GPORT)
 */
int
bcm_petra_cosq_gport_stat_set(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              bcm_cosq_gport_stats_t stat,
                              uint64 value)
{
    unsigned int ctrProc;
    unsigned int ctrSet[DPP_COSQ_COUNTERS_MAX_SETS];
    bcm_dpp_counter_t ctrStat;
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    unsigned int numCtrSet, i;
    unsigned int use_color;


    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stat, 0, &ctrStat));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                                gport,                                                               
                                                                cosq,
                                                                DPP_COSQ_COUNTERS_MAX_SETS,
                                                                ctrStat,
                                                                &use_color,
                                                                &ctrProc,
                                                                ctrSet,
                                                                &numCosLevels,
                                                                &numCtrSet));

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stat, use_color, &ctrStat));
    for (i=0; i<numCtrSet; i++) {
        BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_set(unit, ctrProc, ctrSet[i], ctrStat, value));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Enable/disable statistics for a GPORT
 *
 *  On PetraB/Arad, the stats are actually enabled by the counter processor
 *  configuration, so this returns an error if the caller tries to set it the
 *  other way, and success if the caller tries to set it as configured.
 */
int
bcm_petra_cosq_gport_stat_enable_set(int unit,
                                     bcm_gport_t gport,
                                     int enable)
{
    int result;
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    unsigned int use_color;
    BCMDNX_INIT_FUNC_DEFS;

    result = _bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                         gport,
                                                         0 /* offset */,
                                                         0,
                                                         bcm_dpp_counter_count,
                                                         &use_color,
                                                         NULL,
                                                         NULL,
                                                         &numCosLevels,
                                                         NULL);
    if (enable) {
        if (BCM_E_NONE != result) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG("gport %08X can not enable stats since"
                                       " there is no counter processor set to"
                                       " cover stats for it"),
                              gport));
        }
    } else {
        if (BCM_E_NONE == result) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG,
                             (_BSL_BCM_MSG("gport %08X can not disable stats since"
                                       " there is a counter processor set to"
                                       " cover stats for it"),
                              gport));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Get statistics state for a GPORT
 *
 *  On PetraB/Arad, the stats are actually enabled by the counter processor
 *  configuration, so this merely returns TRUE or FALSE according to whether
 *  the particular GPORT is covered by at least one of the counter processors.
 */
int
bcm_petra_cosq_gport_stat_enable_get(int unit,
                                     bcm_gport_t gport,
                                     int *enable)
{
    int result;
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    unsigned int use_color, numCtrSet;
    unsigned int ctrProc;
    unsigned int ctrSet[DPP_COSQ_COUNTERS_MAX_SETS];
    BCMDNX_INIT_FUNC_DEFS;

    result = _bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                         gport,
                                                         0 /* offset */,
                                                         1,
                                                         bcm_dpp_counter_count,
                                                         &use_color,
                                                         &ctrProc,
                                                         ctrSet,
                                                         &numCosLevels,
                                                         &numCtrSet);
    *enable = (BCM_E_NONE == result);
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_sched_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int mode,
                                                       int weight)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (mode != BCM_COSQ_WEIGHTED_FAIR_QUEUING) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: mode: %d\n"), mode)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to BCM_COSQ_WEIGHTED_FAIR_QUEUING")));
    }

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_sched_set, (unit, gport, weight)));

exit:    
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight)
{

    BCMDNX_INIT_FUNC_DEFS;
         
    *mode = BCM_COSQ_WEIGHTED_FAIR_QUEUING;
    
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_sched_get, (unit, gport, weight)));
        
    BCMDNX_FUNC_RETURN;   
}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg)
{
    SOC_TMC_ING_SCH_CLOS_INFO clos_info;
    int                       core;
    BCMDNX_INIT_FUNC_DEFS;

    core = BCM_GPORT_SCHEDULER_CORE_GET(port);
    if (core == BCM_CORE_ALL) 
    {
        core = 0;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_slow_start_get, (unit, core, &clos_info)));
    switch(type) {
        case bcmCosqControlFlowSlowRate:
            /*Enable/Disable slow start mechanism for multicast queues*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_enable;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_enable;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
            break;
        case bcmCosqControlFlowSlowRate1:
            /*Get first rate of slow start mechanism*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_0;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_0;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        case bcmCosqControlFlowSlowRate2:
            /*Get first rate of slow start mechanism*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_1;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_1;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
             break;
     }

exit:    
    BCMDNX_FUNC_RETURN;  

}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg)
{
    SOC_TMC_ING_SCH_CLOS_INFO clos_info;
    int                       core, index;
    BCMDNX_INIT_FUNC_DEFS;
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);

    BCM_DPP_CORES_ITER(core, index)
    {
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_slow_start_get, (unit, index, &clos_info)));

        /*setting all shaper fields to don't touch (0xffffffff)*/
        SOC_TMC_ING_SCH_CLOS_INFO_SHAPERS_dont_touch(&clos_info);

        switch(type) {
            case bcmCosqControlFlowSlowRate:
                /*Enable/Disable slow start mechanism for multicast queues*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_enable = arg ? 1 : 0;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_enable = arg ? 1 : 0;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                break;
            case bcmCosqControlFlowSlowRate1:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                /*Configure first rate of slow start mechanism*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_0 = arg;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_0 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            case bcmCosqControlFlowSlowRate2:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                /*Configure first rate of slow start mechanism*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_1 = arg;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_1 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
                 break;
         }

         BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_slow_start_set, (unit, index, &clos_info)));

    }
exit:    
    BCMDNX_FUNC_RETURN;  

}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg)
{
    SOC_TMC_ING_SCH_SHAPER   shaper_info;
    int                      core;
    BCMDNX_INIT_FUNC_DEFS;

    core = BCM_GPORT_SCHEDULER_CORE_GET(port);
    if (core == BCM_CORE_ALL) 
    {
        core = 0;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_slow_start_get, (unit, core, &shaper_info)));
    switch(type) {
        case bcmCosqControlFlowSlowRate:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_enable;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
            break;
        case bcmCosqControlFlowSlowRate1:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_rate_phase_0;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        case bcmCosqControlFlowSlowRate2:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_rate_phase_1;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
             break;
     }

exit:    
    BCMDNX_FUNC_RETURN;  
}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg)
{
    SOC_TMC_ING_SCH_SHAPER    shaper_info;
    int                       core, index;
    BCMDNX_INIT_FUNC_DEFS;
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);

    BCM_DPP_CORES_ITER(core, index)
    {
        /*setting slow start shaper fields to don't touch (0xffffffff)*/
        shaper_info.slow_start_enable = SOC_TMC_ING_SCH_DONT_TOUCH;
        shaper_info.slow_start_rate_phase_0 = SOC_TMC_ING_SCH_DONT_TOUCH;
        shaper_info.slow_start_rate_phase_1 = SOC_TMC_ING_SCH_DONT_TOUCH;        

        switch(type) {
            case bcmCosqControlFlowSlowRate:
                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_enable = arg ? 1 : 0;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                break;
            case bcmCosqControlFlowSlowRate1:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_rate_phase_0 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            case bcmCosqControlFlowSlowRate2:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_rate_phase_1 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
                break;
         }

         BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_slow_start_set, (unit, index, &shaper_info)));

    }
exit:    
    BCMDNX_FUNC_RETURN;  
}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int mode,
                                                       int weight)
{
BCMDNX_INIT_FUNC_DEFS;

    if (mode != BCM_COSQ_WEIGHTED_FAIR_QUEUING) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: mode: %d\n"), mode)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to BCM_COSQ_WEIGHTED_FAIR_QUEUING")));
    }
  
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_sched_set, (unit, gport, weight)));
      
exit:    
    BCMDNX_FUNC_RETURN;   
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight)
{
    BCMDNX_INIT_FUNC_DEFS;

    *mode = BCM_COSQ_WEIGHTED_FAIR_QUEUING;
    
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_sched_get, (unit, gport, weight)));
  
    BCMDNX_FUNC_RETURN;   
}

int
_bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_get(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 *kbits_sec_min, 
                                                           uint32 *kbits_sec_max, 
                                                           uint32 *flags)
{
    BCMDNX_INIT_FUNC_DEFS;

    *kbits_sec_min = 0;
    *flags = 0;

    
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_bandwidth_get, (unit, gport, kbits_sec_max)));
        
    BCMDNX_FUNC_RETURN;
}


int
_bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_set(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 kbits_sec_min, 
                                                           uint32 kbits_sec_max, 
                                                           uint32 flags)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    if (flags != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: flags: %d\n"), flags)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to 0")));
    }
    
    if (kbits_sec_max == 1) {
        kbits_sec_max = 2;
    }  

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_bandwidth_set, (unit, gport, kbits_sec_max)));
      
exit:    
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_get(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 *kbits_sec_min, 
                                                           uint32 *kbits_sec_max, 
                                                           uint32 *flags)
{
    BCMDNX_INIT_FUNC_DEFS;
      
    *kbits_sec_min = 0;
    *flags = 0;
     
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_bandwidth_get, (unit, gport, kbits_sec_max))); 

    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_set(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 kbits_sec_min, 
                                                           uint32 kbits_sec_max, 
                                                           uint32 flags)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    if (flags != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: flags: %d\n"), flags)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to 0")));
    }
    
    if (kbits_sec_max == 1) {
        kbits_sec_max = 2;
    }

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_bandwidth_set, (unit, gport, kbits_sec_max))); 
exit:        
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_WARM_BOOT_SUPPORT_SW_DUMP
int
_bcm_dpp_cosq_sw_dump(int unit)
{
    int                                 rc = BCM_E_NONE;
    int                                 nbr_entry, base_qid = 0, base_cid = 0, nbr_cos = 0, nbr_se;
    bcm_dpp_cosq_voq_config_t          *voq_config;
    bcm_dpp_cosq_connector_config_t    *conn_config;
    bcm_gport_t                         conn_gport, physical_port, se_gport;
    int                                 num_cos_levels, flow_id, dual_flow_id, dual_se_id;
    int                                 is_non_contiguous = 0, is_composite, is_dual;
    uint32                              flags;
    bcm_dpp_cosq_flow_config_t         *flow_config;
    bcm_dpp_cosq_se_config_t           *se_config;
    uint8                              *se_info = NULL;
    int                                 core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_ALLOC(se_info, sizeof(uint8) * ((SOC_DPP_CONFIG(unit)->tm.max_ses / 8) + 1), "temp se info");
    if (se_info == NULL) {
        return(BCM_E_MEMORY);
    }
    sal_memset(se_info, 0, sizeof(uint8) * ((SOC_DPP_CONFIG(unit)->tm.max_ses / 8) + 1));


    LOG_CLI((BSL_META_U(unit,
                        "\nVoQ State\n")));
    for (nbr_entry = 0, base_qid = 0;
           nbr_entry < (DPP_DEVICE_PETRA_VOQ_HD_SIZE(unit) + 1) / DPP_DEVICE_COSQ_COS_ALLOC_SZ;
                                        base_qid += DPP_DEVICE_COSQ_COS_ALLOC_SZ, nbr_entry++) {
        voq_config = (bcm_dpp_cosq_voq_config_t *)_bcm_petra_cosq_element_get(unit,
                                              &(_dpp_cosq_config[unit].voq_hd), base_qid);
        if (voq_config == NULL) {
            continue;
        }

        if (voq_config->num_cos == 0) {
            continue;
        }
        core = DPP_DEVICE_PETRA_VOQ_HD_CORE(unit ,base_qid);
        LOG_CLI((BSL_META_U(unit,
                            "  baseVoq(%d), core(%d) numCos(%d)\n"), DPP_DEVICE_PETRA_VOQ_HD_ID(unit, core, base_qid), core, voq_config->num_cos));
    }

    LOG_CLI((BSL_META_U(unit,
                        "\nConnector State\n")));
    for (nbr_entry = 0, base_cid = 0;
           nbr_entry < (DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit) + 1) / DPP_DEVICE_COSQ_COS_ALLOC_SZ;
                                        base_cid += DPP_DEVICE_COSQ_COS_ALLOC_SZ, nbr_entry++) {
        conn_config = (bcm_dpp_cosq_connector_config_t *)_bcm_petra_cosq_element_get(unit,
                                              &(_dpp_cosq_config[unit].connector_hd), base_cid);
        if (conn_config == NULL) {
            continue;
        }

        if (conn_config->num_cos == 0) {
            continue;
        }

        LOG_CLI((BSL_META_U(unit,
                            "  baseConn(%d), numCos(%d), flags(0x%04X)\n"), base_cid, conn_config->num_cos, (unsigned short)conn_config->flags));

        BCM_COSQ_GPORT_VOQ_CONNECTOR_SET(conn_gport, base_cid);
        rc = bcm_petra_cosq_gport_get(unit, conn_gport, &physical_port, &num_cos_levels, &flags);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failure in getting gport(0x%x) info, error 0x%x\n"), unit, conn_gport, rc));
            goto err;
        }

        is_non_contiguous = (flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
        is_composite = (flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;

        for (nbr_cos = 0; nbr_cos < conn_config->num_cos; nbr_cos++) {

            rc = _bcm_petra_flow_id_get(unit, base_cid, nbr_cos, is_non_contiguous, is_composite, FALSE,&flow_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_cos, rc));
                goto err;
            }

            flow_config = (bcm_dpp_cosq_flow_config_t *)_bcm_petra_cosq_element_get(unit,
                                                   &(_dpp_cosq_config[unit].flow_hd), flow_id);
            if (flow_config == NULL) {
                rc = BCM_E_INTERNAL;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting flow(%d) info, error 0x%x\n"), unit, flow_id, rc));
                goto err;
            }

            LOG_CLI((BSL_META_U(unit,
                                "    cos(%d), flow(%d), weight(%d)\n"), nbr_cos, flow_id, flow_config->weight));

            if (is_composite) {
                rc = _bcm_petra_composite_flow_id_get(unit, base_cid, nbr_cos, is_non_contiguous, is_composite, &flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, failure in getting Composite Flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_cos, rc));
                    goto err;
                }

                flow_config = (bcm_dpp_cosq_flow_config_t *)_bcm_petra_cosq_element_get(unit,
                                                   &(_dpp_cosq_config[unit].flow_hd), flow_id);
                if (flow_config == NULL) {
                    rc = BCM_E_INTERNAL;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, failure in getting Composite flow(%d) info, error 0x%x\n"), unit, flow_id, rc));
                    goto err;
                }

                LOG_CLI((BSL_META_U(unit,
                                    "    cos(%d), composite-flow(%d), weight(%d)\n"), nbr_cos, flow_id, flow_config->weight));
            }
        }
    }

    LOG_CLI((BSL_META_U(unit,
                        "\nSE State\n")));

    for (nbr_se = 0; nbr_se < SOC_DPP_CONFIG(unit)->tm.max_ses; nbr_se++) {

        /* check that the element is not already processed */
        if (se_info[(nbr_se / 8)] & (1 << (nbr_se % 8))) {
            continue;
        }

        se_config = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_get(unit,
                                              &(_dpp_cosq_config[unit].se_hd), nbr_se);
        if (se_config == NULL) {
            continue;
        }

        if (se_config->ref_cnt == 0) {
            continue;
        }

        /* update temp state to indicate element processed */
        se_info[(nbr_se / 8)] |= (1 << (nbr_se % 8));

        LOG_CLI((BSL_META_U(unit,
                            "  SE(%d), ref_cnt(%d)\n"), nbr_se,
                 (se_config->ref_cnt - DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE)));

        flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,( nbr_se)));
        BCM_GPORT_SCHEDULER_SET(se_gport, flow_id);

        rc = bcm_petra_cosq_gport_get(unit, se_gport, &physical_port, &num_cos_levels, &flags);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failure in getting gport(0x%x) info, error 0x%x\n"), unit, se_gport, rc));
            goto err;
        }

        flow_config = (bcm_dpp_cosq_flow_config_t *)_bcm_petra_cosq_element_get(unit,
                                                   &(_dpp_cosq_config[unit].flow_hd), flow_id);
        if (flow_config == NULL) {
            rc = BCM_E_INTERNAL;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failure in getting flow(%d) info, error 0x%x\n"), unit, flow_id, rc));
            goto err;
        }
        LOG_CLI((BSL_META_U(unit,
                            "    flow(%d), weight(%d)\n"), flow_id, flow_config->weight));

        is_non_contiguous = (flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
        is_composite = (flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;
        is_dual = (flags & BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER) ? TRUE : FALSE;

        if (is_composite) {
            rc = _bcm_petra_composite_flow_id_get(unit, base_cid, nbr_se, is_non_contiguous, is_composite, &flow_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting Composite Flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_se, rc));
                goto err;
            }

            flow_config = (bcm_dpp_cosq_flow_config_t *)_bcm_petra_cosq_element_get(unit,
                                                   &(_dpp_cosq_config[unit].flow_hd), flow_id);
            if (flow_config == NULL) {
                rc = BCM_E_INTERNAL;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting Composite flow(%d) info, error 0x%x\n"), unit, flow_id, rc));
                goto err;
            }

            LOG_CLI((BSL_META_U(unit,
                                "    Composite Flow(%d), weight(%d)\n"), flow_id, flow_config->weight));
        }

        if (is_dual) {

            rc = _bcm_petra_se_dual_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_CL, TRUE, &dual_flow_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, cl se failure in getting dual flow(%d), error 0x%x\n"), unit, flow_id, rc));
                goto err;
            }

            dual_se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,( dual_flow_id)));
            if (dual_se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                rc = BCM_E_INTERNAL;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, dual_flow_id));
                goto err;
            }

            /* update temp state to indicate element processed */
            se_info[(nbr_se / 8)] |= (1 << (dual_se_id % 8));

            se_config = (bcm_dpp_cosq_se_config_t *)_bcm_petra_cosq_element_get(unit,
                                              &(_dpp_cosq_config[unit].se_hd), dual_se_id);
            if ( (se_config == NULL) || (se_config->ref_cnt == 0) ) {
                rc = BCM_E_INTERNAL;
                goto err;
            }

            LOG_CLI((BSL_META_U(unit,
                                "    SE-Dual(%d), ref_cnt(%d)\n"), nbr_se,
                     (se_config->ref_cnt - DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE)));


            flow_config = (bcm_dpp_cosq_flow_config_t *)_bcm_petra_cosq_element_get(unit,
                                                   &(_dpp_cosq_config[unit].flow_hd), dual_flow_id);
            if (flow_config == NULL) {
                rc = BCM_E_INTERNAL;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting dual flow(%d) info, error 0x%x\n"), unit, dual_flow_id, rc));
                goto err;
            }

            LOG_CLI((BSL_META_U(unit,
                                "    flow(%d), weight(%d)\n"), dual_flow_id, flow_config->weight));
        }

    }

    LOG_CLI((BSL_META_U(unit,
                        "\n")));

    BCM_FREE(se_info);


    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;
err:
    if (se_info  != NULL) {
       BCM_FREE(se_info);
    }

exit:
    BCMDNX_FUNC_RETURN;
}
#endif /* BCM_WARM_BOOT_SUPPORT_SW_DUMP */


STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg)
{
    BCMDNX_INIT_FUNC_DEFS;
    
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_burst_get, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg)
{
    BCMDNX_INIT_FUNC_DEFS;
 
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_burst_get, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;   
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg)
{
    BCMDNX_INIT_FUNC_DEFS;

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_burst_set, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg)
{
    BCMDNX_INIT_FUNC_DEFS;

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_burst_set, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;  
}

/* when a port added or removed (dynamic port) the coresspoding hr should be added or removed */
int 
_bcm_petra_cosq_hr_handle(int unit, int port, int enable)
{
    int                         core, priority_i, flow_id, rc;
    uint32                      fap_port, nof_priorities;
    SOC_TMC_SCH_PORT_INFO       port_info;
    bcm_gport_t                 gport;
    uint32                      res_mngr_flags = 0, soc_sand_rc = 0;
    SOC_TMC_SCH_SE_ID           se_index = 0;
    bcm_dpp_cosq_flow_config_t* flow_state_config; 

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));
    SOC_TMC_SCH_PORT_INFO_clear(&port_info);
    BCM_COSQ_GPORT_E2E_PORT_SET(gport, port);

    /* A new port is added*/
    if (enable) 
    {   
        /* Set default port information */
        port_info.enable = TRUE;
        DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
          port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }

        rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), fap_port));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* allocate hr */ 
         res_mngr_flags = SHR_RES_ALLOC_WITH_ID;
         
         for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
         {
             soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
             if(SOC_SAND_FAILURE(soc_sand_rc)) {
                 rc = translate_sand_success_failure(soc_sand_rc);
                 BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority_i, soc_sand_rc, rc));
             }
              
             if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit))
             {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, se id retreive invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                 continue;
             }
             flow_id =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_index)));

             rc = bcm_dpp_am_cosq_scheduler_allocate(unit, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
             if (rc != BCM_E_NONE) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                 BCMDNX_IF_ERR_EXIT(rc);
             }
             LOG_VERBOSE(BSL_LS_BCM_COSQ,
                         (BSL_META_U(unit,
                                     "unit %d, port(%d) priority(%d) hr resources, flow_id 0x%x\n"), unit, fap_port, priority_i ,flow_id));
             flow_state_config = (bcm_dpp_cosq_flow_config_t*)_bcm_petra_cosq_element_alloc(unit,
                                                                                           &(_dpp_cosq_config[unit].flow_hd), flow_id);
        
             if (flow_state_config ==  NULL) {
               LOG_ERROR(BSL_LS_BCM_COSQ,
                         (BSL_META_U(unit,
                                     "Unit(%d) flow_id(%d) gport add flow internal state allocation error\n"), unit, flow_id));
               rc = BCM_E_RESOURCE;
               BCMDNX_IF_ERR_EXIT(rc);
             }
             flow_state_config->weight = 0;
             flow_state_config->mode = BCM_COSQ_SP0;
         }
    }
    else /* An exising port is deleted */
    {
        /* Set default port information */
        port_info.enable = FALSE;
        DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_NONE);
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
          port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_NONE;
        }

        rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), fap_port));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        /* release hr */
         res_mngr_flags = 0;
        
         for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
         {
             /* retrieve flow id */
             soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
             if(SOC_SAND_FAILURE(soc_sand_rc)) {
                 rc = translate_sand_success_failure(soc_sand_rc);
                 BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority_i, soc_sand_rc, rc));
             }
              
             if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit))
             {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, se id retreive invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                 continue;
             }
             flow_id =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_index)));

             /* free HR resources */
             rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
             if (rc != BCM_E_NONE) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                 BCMDNX_IF_ERR_EXIT(rc);
             }
             _bcm_petra_cosq_element_free(unit, &(_dpp_cosq_config[unit].flow_hd), flow_id);

         }

    }

exit:
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_ARAD_SUPPORT
int
_bcm_arad_cosq_control_congestion_queue_range_set(int unit, 
                                                 bcm_cosq_control_t type, 
                                                 int arg)
{
  int rv = BCM_E_NONE;
  int soc_sand_dev_id, soc_sand_rc;
  ARAD_CNM_Q_MAPPING_INFO info;
  int num_of_queues;

  BCMDNX_INIT_FUNC_DEFS;
  soc_sand_dev_id = (unit);

  soc_sand_rc = arad_cnm_queue_mapping_get(soc_sand_dev_id, &info);
  BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
  
  if(type == bcmCosqControlCongestionManagedQueueMin)
  {
    info.cp_queue_low = arg;
  }

  if(type == bcmCosqControlCongestionManagedQueueMax)
  {
    info.cp_queue_high = arg;
  }

  num_of_queues = info.cp_queue_high - info.cp_queue_low + 1;
  if(num_of_queues > DPP_COSQ_ARAD_CNM_MAX_CP_QUEUES)
  {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, number of congestion managed queues is too large (%d)"), unit, num_of_queues));
  }

  soc_sand_rc = arad_cnm_queue_mapping_set(soc_sand_dev_id, &info);
  BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

  BCMDNX_IF_ERR_EXIT(rv);
exit:
  BCMDNX_FUNC_RETURN;
}

int
_bcm_arad_cosq_control_congestion_queue_range_get(int unit, 
                                                 bcm_cosq_control_t type, 
                                                 int *arg)
{
  int rv = BCM_E_NONE;
  int soc_sand_dev_id, soc_sand_rc;
  ARAD_CNM_Q_MAPPING_INFO info;
  
  BCMDNX_INIT_FUNC_DEFS;
  soc_sand_dev_id = (unit);

  soc_sand_rc = arad_cnm_queue_mapping_get(soc_sand_dev_id, &info);
  BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
  
  if(type == bcmCosqControlCongestionManagedQueueMin)
  {
    *arg = info.cp_queue_low;
  }

  if(type == bcmCosqControlCongestionManagedQueueMax)
  {
    *arg = info.cp_queue_high;
  }

  BCMDNX_IF_ERR_EXIT(rv);
exit:
  BCMDNX_FUNC_RETURN;
}
#endif


/* Configure Weighted Random Early Discard (WRED).
   global drop per DP , and ECN enabled or not*/
int bcm_petra_cosq_discard_set(
    int unit, 
    uint32 flags) 
{
    uint32 discard_dp, enable_ecn = flags & BCM_COSQ_DISCARD_MARK_CONGESTION;
    int ecn_not_supported = SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit);

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);

    /* check unsupported flags */
    if (enable_ecn) {
        if (ecn_not_supported) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }
        flags &= ~BCM_COSQ_DISCARD_MARK_CONGESTION;
    }
    if (flags & ~(BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_ALL)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag. Supported flags are: BCM_COSQ_DISCARD_ENABLE, "
                                                "BCM_COSQ_DISCARD_COLOR_BLACK, BCM_COSQ_DISCARD_COLOR_RED, BCM_COSQ_DISCARD_COLOR_YELLOW, "
                                                "BCM_COSQ_DISCARD_COLOR_ALL and BCM_COSQ_DISCARD_MARK_CONGESTION")));    
    }

    switch (flags) {
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_ALL):
            /* Drop all packets */
            discard_dp = 0;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_YELLOW):
            /* Drop all packets with DP 1 or above */
            discard_dp = 1;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED):
            /* Drop all packets with DP 2 or above */
            discard_dp = 2;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK):
            /* Drop all packets with DP 3 or above */
            discard_dp = 3;
            break;
        case 0:
            /* No discard per DP */
            discard_dp = 4;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag combination\n"))); 
    } 

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dp_discard_set,(unit, discard_dp)));

    if (!ecn_not_supported) {
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_enable_ecn,(unit, enable_ecn)));
    }
    
exit:              
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;   
}

/* Get configuration of Weighted Random Early Discard (WRED).
   global drop per DP, and ECN enabled */
int bcm_petra_cosq_discard_get(
    int unit, 
    uint32 *flags)
{
    uint32 soc_sand_rc = 0, discard_dp = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dp_discard_get,(unit, &discard_dp)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (discard_dp > 3) { /* No discard per DP */
        *flags = 0;
    } 
    else { 
        /* BCM_COSQ_DISCARD_ENABLE is set */
        *flags = BCM_COSQ_DISCARD_ENABLE;

        switch (discard_dp) {
        case 0:
            /* Drop all packets */
            *flags |= BCM_COSQ_DISCARD_COLOR_ALL;
            break;
        case 1:
            /* Drop all packets with DP 1 or above */
            *flags |= (BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_YELLOW);
            break;
        case 2:
            /* Drop all packets with DP 2 or above */
            *flags |= (BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED);
            break;
        default: /* case 3 */
            /* Drop all packets with DP 3 or above */
            *flags |= BCM_COSQ_DISCARD_COLOR_BLACK;
        }
    }

    if (!SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_get_ecn_enabled,(unit, &discard_dp)));
        if (discard_dp) {
            *flags |= BCM_COSQ_DISCARD_MARK_CONGESTION;
        }
    }
    
exit:              
    BCMDNX_FUNC_RETURN;
}

int _bcm_cosq_before_traffic_validation(int unit)
{
  int rv = BCM_E_NONE;

  BCMDNX_INIT_FUNC_DEFS;

#ifdef  BCM_PETRAB_SUPPORT
  if(SOC_IS_PETRAB(unit))
  {
    return BCM_E_NONE;
  }
#endif

#ifdef  BCM_ARAD_SUPPORT
  if(SOC_IS_ARAD(unit))
  {
    /* Check each queue */
    /* Check only using single SP */
    /* Check PD values are below 4k */
    /* Add reserved value to SP Max Reserved */
    /* Check each service pool */
    /* Check MAX value is below 13k */
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "skip_before_traffic_validation", 0) == 0)
    {
      rv = _bcm_arad_cosq_update_reserved_pd_threshold_all_sps(unit);
        BCMDNX_IF_ERR_EXIT(rv);
    }
  }
#endif

    BCMDNX_IF_ERR_EXIT(rv);
exit:              
    BCMDNX_FUNC_RETURN;
}

/*
 * Set the mapping of device (module) to credit value.
 * In Arad plus only two such values are supported.
 */
int
bcm_petra_cosq_dest_credit_size_set(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 credit_size)
{
    uint16 credit_worth_local, credit_worth_remote;
    uint32 credit_value_type = ARAD_PLUS_FAP_CREDIT_VALUE_LOCAL;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    if (!SOC_IS_ARADPLUS(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The API is not supported on this device.")));
    }
    BCM_SAND_IF_ERR_EXIT(arad_plus_mgmt_credit_worth_get_unsafe(unit, &credit_worth_local, &credit_worth_remote));
    if (credit_size == credit_worth_local) {
    } else if (credit_size == credit_worth_remote) {
        credit_value_type = ARAD_PLUS_FAP_CREDIT_VALUE_REMOTE;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Credit size %u is different from both local=%u and remote=%u credit sizes."),
          (unsigned)credit_size, (unsigned)credit_worth_local, (unsigned)credit_worth_remote));
    }
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_module_to_credit_worth_map_set, (unit, dest_modid, credit_value_type)));

exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the mapping of device (module) to credit value.
 * In Arad plus only two such values are supported.
 */
int 
bcm_petra_cosq_dest_credit_size_get(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 *credit_size)
{
    uint16 credit_worth_local, credit_worth_remote;
    uint32 credit_value_type = 0;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    _BCM_DPP_SWITCH_API_START(unit);
    if (!SOC_IS_ARADPLUS(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The API is not supported on this device.")));
    }
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_module_to_credit_worth_map_get, (unit, dest_modid, &credit_value_type)));
    BCM_SAND_IF_ERR_EXIT(arad_plus_mgmt_credit_worth_get_unsafe(unit, &credit_worth_local, &credit_worth_remote));
    if (credit_value_type == ARAD_PLUS_FAP_CREDIT_VALUE_LOCAL) {
        *credit_size = credit_worth_local;
    } else if (credit_value_type == ARAD_PLUS_FAP_CREDIT_VALUE_REMOTE) {
        *credit_size = credit_worth_remote;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("The credit size of FAP ID %u was not set."),
          (unsigned)dest_modid));
    }

exit:
    _BCM_DPP_SWITCH_API_END(unit);
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_flow_control_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 flow_control_mask)
{
    SOC_TMC_MULT_FABRIC_FLOW_CONTROL_MAP fc_map;
    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_MULT_FABRIC_FLOW_CONTROL_MAP_clear(&fc_map);

    if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(port)) {
        fc_map.bfmc0_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(port)) {
        fc_map.bfmc1_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(port)) {
        fc_map.bfmc2_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
        fc_map.gfmc_lb_fc_map = flow_control_mask;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, gport(0x%08x) not supported."), unit, port));
    }

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mult_fabric_flow_control_set, (unit, &fc_map)));

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_flow_control_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 *flow_control_mask)
{
    SOC_TMC_MULT_FABRIC_FLOW_CONTROL_MAP fc_map;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(flow_control_mask);

    SOC_TMC_MULT_FABRIC_FLOW_CONTROL_MAP_clear(&fc_map);
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mult_fabric_flow_control_get, (unit, &fc_map)));

    if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(port)) {
        *flow_control_mask = fc_map.bfmc0_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(port)) {
        *flow_control_mask = fc_map.bfmc1_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(port)) {
        *flow_control_mask = fc_map.bfmc2_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
        *flow_control_mask = fc_map.gfmc_lb_fc_map;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, gport(0x%08x) not supported."), unit, port));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

