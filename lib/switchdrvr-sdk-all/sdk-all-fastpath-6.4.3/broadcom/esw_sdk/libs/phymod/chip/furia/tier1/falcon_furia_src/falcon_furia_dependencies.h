/**************************************************************************************
 **************************************************************************************
 *                                                                                    *
 *  Revision      :  $Id: falcon_furia_dependencies.h 661 2014-08-14 23:20:49Z kirand $ *
 *                                                                                    *
 *  Description   :  API Dependencies to be provided by IP user                       *
 *                                                                                    *
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$                                                              *
 *  No portions of this material may be reproduced in any form without                *
 *  the written permission of:                                                        *
 *      Broadcom Corporation                                                          *
 *      5300 California Avenue                                                        *
 *      Irvine, CA  92617                                                             *
 *                                                                                    *
 *  All information contained in this document is Broadcom Corporation                *
 *  company private proprietary, and trade secret.                                    *
 *                                                                                    *
 **************************************************************************************
 **************************************************************************************/

/** @file falcon_furia_dependencies.h
 * Dependencies to be provided by IP User
 */

#ifndef FALCON_FURIA_API_DEPENDENCIES_H
#define FALCON_FURIA_API_DEPENDENCIES_H

#include "falcon_furia_usr_includes.h"
#include "../common/srds_api_err_code.h"
#include <phymod/phymod.h>
err_code_t falcon_furia_pm_acc_set(const phymod_access_t *pa);
err_code_t falcon_furia_pm_acc_get(phymod_access_t *pa);
/** Read a register from the currently selected Serdes IP Lane.
 * @param address Address of register to be read
 * @param val read from the register
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_pmd_rdt_reg(uint16_t address, uint16_t *val);           


/** Write to a register from the currently selected Serdes IP Lane.
 * @param address Address of register to be written
 * @param val Value to be written to the register
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_pmd_wr_reg(uint16_t address, uint16_t val); 


/** Masked Register Write to the currently selected Serdes IP core/lane.
 * If using Serdes MDIO controller to access the registers, implement this function using falcon_furia_pmd_mdio_mwr_reg(..)
 *
 * If NOT using a Serdes MDIO controller or the Serdes PMI Masked write feature, please use the following code to
 * implement this function
 *
 *    falcon_furia_pmd_wr_reg(addr, ((falcon_furia_pmd_rd_reg(addr) & ~mask) | (mask & (val << lsb))));
 *
 * @param addr Address of register to be written
 * @param mask 16-bit mask indicating the position of the field with bits of 1s
 * @param lsb  LSB of the field
 * @param val  16bit value to be written
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_pmd_mwr_reg(uint16_t addr, uint16_t mask, uint8_t lsb, uint16_t val); 


/** Write message to the logger with the designated verbose level.
 * Output is sent to stdout and a logfile
 * @param message_verbose_level   Verbose level for the current message
 * @param format Format string as in printf
 * @param ... Additional variables used as in printf
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
int logger_write(int message_verbose_level, const char *format, ...);


/** Delay the execution of the code for atleast specified amount of time in nanoseconds.
 * This function is used ONLY for delays less than 1 microsecond, non-zero error code may be returned otherwise.
 * The user can implement this as an empty function if their register access latency exceeds 1 microsecond.
 * @param delay_ns Delay in nanoseconds
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_delay_ns(uint16_t delay_ns); 


/** Delay the execution of the code for atleast specified amount of time in microseconds.
 * For longer delays, accuracy is required. When requested delay is > 100ms, the implemented delay is assumed 
 * to be < 10% bigger than requested.
 * This function is used ONLY for delays greater than or equal to 1 microsecond.
 * @param delay_us Delay in microseconds
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_delay_us(uint32_t delay_us);


/** Return the address of current selected Serdes IP lane.
 * @return the IP level address of the current lane. 0 to N-1, for an N lane IP
 */
uint8_t falcon_furia_get_lane(void);


/** Polls for register field "uc_dsc_ready_for_cmd" to be 1 within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code. 
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided in falcon_furia_functions.c.
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_uc_dsc_ready_for_cmd_equals_1(uint32_t timeout_ms);

/** Polls lane variable usr_diag_status to verify data is available in uC diag buffer.
 * It then reads a WORD of data wich is 2 float8_t samples, it converts them to uint32_t
 * and returns them in the memory pointed to by *data.
 *
 * @param data is pointer to 2 element array of uint32_tpassed from uC through dsc_data
 * @param status returns a status byte
 *    bit 15 - indicates the ey scan is complete
 *    bit 14 - indicates uC is slower than read access
 *    bit 13 - indicates uC is faster than read access
 *    bit 7-0 - indicates amount of data in the uC buffer
 *
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_diag_eye_data(uint32_t *data,uint16_t *status, uint32_t timeout_ms);

/** Polls lane variable usr_diag_status to verify data is available in uC diag buffer.
 *
 * @param status returns a status byte
 *    bit 15 - indicates the ey scan is complete
 *    bit 14-0 - reserved for debug
 *
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_diag_done(uint16_t *status, uint32_t timeout_ms);

/** Polls for register field "dsc_state" to be "DSC_STATE_UC_TUNE"
 * within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code. 
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided in
 * falcon_furia_functions.c. 
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_dsc_state_equals_uc_tune(uint32_t timeout_ms);

/*-----------------------------------*/
/*  Serdes uC Lane Info Structure    */
/*-----------------------------------*/

/** uC Lane Info Struct */
typedef struct {
    uint8_t   is_direct_ram_access_avail;
    uint16_t  core_var_base_address;
    uint16_t  trace_mem_base_address;
    uint16_t  lane_var_base_address;
    uint16_t  diag_base_address;           /* tracemem_size/num_uc_lanes*uc_lane_idx */
    uint8_t   uc_lane_idx;
    uint16_t  lane_ram_size;
    uint16_t  diag_max_idx;                /* maximum index into diag lane memory (tracemem_size/num_uc_lanes - 1) */
	uint16_t  trace_mem_size;
} falcon_furia_uc_lane_info_st;

/** Retrieve Lane Based Information.
* Retrieve current lane memory address information
* @param ext_uc_lane_info an output pointer pointed to uC lane info struct
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_get_uc_ln_info(falcon_furia_uc_lane_info_st *ext_uc_lane_info);


/** Convert uC lane index.
* Convert uC lane index to system ID string
* @param string an output pointer pointed to system ID
* @param uc_lane_idx uC lane index
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_uc_lane_idx_to_system_id(const  char *string , uint8_t uc_lane_idx);

/*---------------------------------------------*/
/*  Serdes IP RAM access - Lane RAM Variables  */
/*---------------------------------------------*/
/*          rd - read; wr - write              */ 
/*          b  - byte; w  - word               */
/*---------------------------------------------*/
/** Unsigned Word Read of a uC RAM variable.
* Write access through Micro Register Interface for PMD IPs. Output as little-endian format the LSB is the lowest address.
* @param rd_val 16bit unsigned value to be read from RAM variable
* @param addr Address of RAM variable to be read
* @param size Size of RAM in word to be read
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_rdw_ram(uint16_t *rd_val, uint16_t addr, uint16_t size);

/** Unsigned Byte Read of a uC RAM variable.
* Write access through Micro Register Interface for PMD IPs. 
* @param rd_val 8bit unsigned value to be read from RAM variable
* @param addr Address of RAM variable to be read
* @param size Size of RAM in byte to be read
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_rdb_ram(uint8_t *rd_val, uint16_t addr, uint16_t size);

/** Unsigned Byte Write of a uC RAM variable.
* Write access through Micro Register Interface for PMD IPs
* @param addr Address of RAM variable to be written
* @param size Size of RAM in byte to be written
* @param wr_val 8bit unsigned value to be written to RAM variable
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_wrb_ram(uint16_t addr, uint16_t size, uint8_t *wr_val);


/** Unsigned Word Write of a uC RAM variable.
* Write access through Micro Register Interface for PMD IPs
* @param addr Address of RAM variable to be written
* @param size Size of RAM in word to be written
* @param wr_val 16bit unsigned value to be written to RAM variable
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_wrw_ram(uint16_t addr, uint16_t size, uint16_t *wr_val);

/** Polls for register field "st_afe_tx_fifo_resetb" to be 1 within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code.
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided in falcon_furia_functions.c.
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_st_afe_tx_fifo_resetb_equals_1(uint32_t timeout_ms);


/** Read a register from the currently selected Serdes IP Lane.
 * @param address Address of register to be read
 * @param val read from the register
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_pmd_rdt_reg(uint16_t address, uint16_t *val);           


/** Write to a register from the currently selected Serdes IP Lane.
 * @param address Address of register to be written
 * @param val Value to be written to the register
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_pmd_wr_reg(uint16_t address, uint16_t val); 


/** Masked Register Write to the currently selected Serdes IP core/lane.
 * If using Serdes MDIO controller to access the registers, implement this function using falcon_furia_pmd_mdio_mwr_reg(..)
 *
 * If NOT using a Serdes MDIO controller or the Serdes PMI Masked write feature, please use the following code to
 * implement this function
 *
 *    falcon_furia_pmd_wr_reg(addr, ((falcon_furia_pmd_rd_reg(addr) & ~mask) | (mask & (val << lsb))));
 *
 * @param addr Address of register to be written
 * @param mask 16-bit mask indicating the position of the field with bits of 1s
 * @param lsb  LSB of the field
 * @param val  16bit value to be written
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_pmd_mwr_reg(uint16_t addr, uint16_t mask, uint8_t lsb, uint16_t val); 


/** Write message to the logger with the designated verbose level.
 * Output is sent to stdout and a logfile
 * @param message_verbose_level   Verbose level for the current message
 * @param format Format string as in printf
 * @param ... Additional variables used as in printf
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
int logger_write(int message_verbose_level, const char *format, ...);


/** Delay the execution of the code for atleast specified amount of time in nanoseconds.
 * This function is used ONLY for delays less than 1 microsecond, non-zero error code may be returned otherwise.
 * The user can implement this as an empty function if their register access latency exceeds 1 microsecond.
 * @param delay_ns Delay in nanoseconds
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_delay_ns(uint16_t delay_ns); 


/** Delay the execution of the code for atleast specified amount of time in microseconds.
 * For longer delays, accuracy is required. When requested delay is > 100ms, the implemented delay is assumed 
 * to be < 10% bigger than requested.
 * This function is used ONLY for delays greater than or equal to 1 microsecond.
 * @param delay_us Delay in microseconds
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_delay_us(uint32_t delay_us);


/** Return the address of current selected Serdes IP lane.
 * @return the IP level address of the current lane. 0 to N-1, for an N lane IP
 */
uint8_t falcon_furia_get_lane(void);


/** Polls for register field "uc_dsc_ready_for_cmd" to be 1 within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code. 
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided in falcon_furia_functions.c.
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_uc_dsc_ready_for_cmd_equals_1(uint32_t timeout_ms);

/** Polls lane variable usr_diag_status to verify data is available in uC diag buffer.
 * It then reads a WORD of data wich is 2 float8_t samples, it converts them to uint32_t
 * and returns them in the memory pointed to by *data.
 *
 * @param data is pointer to 2 element array of uint32_tpassed from uC through dsc_data
 * @param status returns a status byte
 *    bit 15 - indicates the ey scan is complete
 *    bit 14 - indicates uC is slower than read access
 *    bit 13 - indicates uC is faster than read access
 *    bit 7-0 - indicates amount of data in the uC buffer
 *
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_diag_eye_data(uint32_t *data,uint16_t *status, uint32_t timeout_ms);

/** Polls lane variable usr_diag_status to verify data is available in uC diag buffer.
 *
 * @param status returns a status byte
 *    bit 15 - indicates the ey scan is complete
 *    bit 14-0 - reserved for debug
 *
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_diag_done(uint16_t *status, uint32_t timeout_ms);

/** Polls for register field "dsc_state" to be "DSC_STATE_UC_TUNE"
 * within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code. 
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided in
 * falcon_furia_functions.c. 
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_dsc_state_equals_uc_tune(uint32_t timeout_ms);

/** Convert uC lane index.
* Convert uC lane index to system ID string
* @param string an output pointer pointed to system ID
* @param uc_lane_idx uC lane index
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_uc_lane_idx_to_system_id(const  char *string , uint8_t uc_lane_idx);

/*---------------------------------------------*/
/*  Serdes IP RAM access - Lane RAM Variables  */
/*---------------------------------------------*/
/*          rd - read; wr - write              */ 
/*          b  - byte; w  - word               */
/*---------------------------------------------*/
/** Unsigned Word Read of a uC RAM variable.
* Write access through Micro Register Interface for PMD IPs. Output as little-endian format the LSB is the lowest address.
* @param rd_val 16bit unsigned value to be read from RAM variable
* @param addr Address of RAM variable to be read
* @param size Size of RAM in word to be read
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_rdw_ram(uint16_t *rd_val, uint16_t addr, uint16_t size);

/** Unsigned Byte Read of a uC RAM variable.
* Write access through Micro Register Interface for PMD IPs. 
* @param rd_val 8bit unsigned value to be read from RAM variable
* @param addr Address of RAM variable to be read
* @param size Size of RAM in byte to be read
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_rdb_ram(uint8_t *rd_val, uint16_t addr, uint16_t size);

/** Unsigned Byte Write of a uC RAM variable.
* Write access through Micro Register Interface for PMD IPs
* @param addr Address of RAM variable to be written
* @param size Size of RAM in byte to be written
* @param wr_val 8bit unsigned value to be written to RAM variable
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_wrb_ram(uint16_t addr, uint16_t size, uint8_t *wr_val);


/** Unsigned Word Write of a uC RAM variable.
* Write access through Micro Register Interface for PMD IPs
* @param addr Address of RAM variable to be written
* @param size Size of RAM in word to be written
* @param wr_val 16bit unsigned value to be written to RAM variable
* @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
*/ 
err_code_t falcon_furia_wrw_ram(uint16_t addr, uint16_t size, uint16_t *wr_val);

/** Polls for register field "st_afe_tx_fifo_resetb" to be 1 within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code.
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided in falcon_furia_functions.c.
 * @param timeout_ms Maximum time interval in milliseconds for which the polling is done
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors)  
 */
err_code_t falcon_furia_poll_st_afe_tx_fifo_resetb_equals_1(uint32_t timeout_ms);


#endif
