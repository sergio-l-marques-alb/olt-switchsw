diff -rupN linux-4.1.8-UL200.ori/arch/powerpc/boot/dts/fsl/ul200g.dts linux-4.1.8-UL200.mod/arch/powerpc/boot/dts/fsl/ul200g.dts
--- linux-4.1.8-UL200.ori/arch/powerpc/boot/dts/fsl/ul200g.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8-UL200.mod/arch/powerpc/boot/dts/fsl/ul200g.dts	2018-02-08 14:52:37.724475576 +0000
@@ -0,0 +1,431 @@
+/dts-v1/;
+
+/ {
+        model = "fsl,P1010";
+        compatible = "fsl,P1010RDB";
+        #address-cells = <0x2>;
+        #size-cells = <0x2>;
+
+        aliases {
+                serial0 = "/soc@ffe00000/serial@4500";
+                serial1 = "/soc@ffe00000/serial@4600";
+		ethernet0 = &enet0;
+		spi1 = &spi1;
+        };
+
+        cpus {
+                #address-cells = <0x1>;
+                #size-cells = <0x0>;
+
+                PowerPC,P1010@0 {
+                        device_type = "cpu";
+                        reg = <0x0>;
+                        next-level-cache = <0x1>;
+                };
+        };
+
+        memory {
+                device_type = "memory";
+        };
+        
+	ifc@ffe1e000 {
+                #address-cells = <0x2>;
+                #size-cells = <0x1>;
+                compatible = "fsl,ifc", "simple-bus";
+                reg = <0x0 0xffe1e000 0x0 0x2000>;
+                interrupts = <0x10 0x2 0x13 0x2>;
+                interrupt-parent = <0x2>;
+                ranges = <0x0 0x0 0x0 0xff800000 0x20000>;
+
+                nand@0,0 {
+                        #address-cells = <0x1>;
+                        #size-cells = <0x1>;
+                        compatible = "fsl,ifc-nand";
+			//nand-sw-ecc-bch;
+
+                        reg = <0x0 0x0 0x40000>;
+
+                        partition@0 {
+                                reg = <0x0 0xA0000>;
+                                label = "NAND U-Boot Image";
+                        };
+
+                        partition@80000 {
+                                reg = <0xA0000 0x60000>;
+                                label = "NAND U-BOOT - ENV";
+                        };
+
+                        partition@100000 {
+                                reg = <0x100000 0x100000>;
+                                label = "NAND DTB Image";
+                        };
+
+                        partition@200000 {
+                                reg = <0x200000 0x400000>;
+                                label = "NAND Linux Kernel Image";
+                        };
+
+                        partition@600000 {
+                                reg = <0x600000 0x400000>;
+                                label = "NAND Compressed RFS Image";
+                        };
+
+                        partition@a00000 {
+                                reg = <0xa00000 0xf00000>;
+                                label = "NAND JFFS2 Root File System";
+                        };
+
+                        partition@1900000 {
+                                reg = <0x1900000 0x700000>;
+                                label = "NAND User area";
+                        };
+
+                        partition@2000000 {
+                                reg = <0x2000000 0x2000000>;
+                                label = "NAND BIG User area";
+                        };
+                };
+        };
+
+        soc@ffe00000 {
+                #address-cells = <0x1>;
+                #size-cells = <0x1>;
+                device_type = "soc";
+                compatible = "fsl,p1020-immr", "simple-bus";
+                ranges = <0x0 0x0 0xffe00000 0x100000>;
+                bus-frequency = <0x0>;
+
+                ecm-law@0 {
+                        compatible = "fsl,ecm-law";
+                        reg = <0x0 0x1000>;
+                        fsl,num-laws = <0xc>;
+                };
+
+                ecm@1000 {
+                        compatible = "fsl,p1020-ecm", "fsl,ecm";
+                        reg = <0x1000 0x1000>;
+                        interrupts = <0x10 0x2>;
+                        interrupt-parent = <0x2>;
+                };
+
+                memory-controller@2000 {
+                        compatible = "fsl,p1020-memory-controller";
+                        reg = <0x2000 0x1000>;
+                        interrupt-parent = <0x2>;
+                        interrupts = <0x10 0x2>;
+                };
+
+                i2c@3000 {
+                        #address-cells = <0x1>;
+                        #size-cells = <0x0>;
+                        cell-index = <0x0>;
+                        compatible = "fsl-i2c";
+                        reg = <0x3000 0x100>;
+                        interrupts = <0x2b 0x2>;
+                        interrupt-parent = <0x2>;
+                        dfsrr;
+
+                        //rtc@68 {
+                        //        compatible = "pericom,pt7c4338";
+                        //        reg = <0x68>;
+                        //};
+                };
+
+                i2c@3100 {
+                        #address-cells = <0x1>;
+                        #size-cells = <0x0>;
+                        cell-index = <0x1>;
+                        compatible = "fsl-i2c";
+                        reg = <0x3100 0x100>;
+                        interrupts = <0x2b 0x2>;
+                        interrupt-parent = <0x2>;
+                        dfsrr;
+
+                        temp-sensor@4d {
+                                compatible = "maxim,max6581";
+                                reg = <0x4d>;
+                                smbus-timeout-disable;
+                                resistance-cancellation;
+                                alert-mask = <0x72>;
+                                over-temperature-mask = <0x7f>;
+                        };
+			power-mon@67 {
+				compatible = "lltc,ltc2945";
+                                reg = <0x67>;
+			};
+                };
+
+
+//                i2c@3000 {
+//			#address-cells = <1>;
+//		        #size-cells = <0>;
+//		        cell-index = <0>;
+//		        compatible = "fsl-i2c";
+//		        reg = <0x3000 0x100>;
+//		        interrupts = <43 2 0 0>;
+//		        dfsrr;
+//                };
+//
+//                i2c@3100 {
+//		        #address-cells = <1>;
+//		        #size-cells = <0>;
+//		        cell-index = <1>;
+//		        compatible = "fsl-i2c";
+//		        reg = <0x3100 0x100>;
+//		        interrupts = <43 2 0 0>;
+//		        dfsrr;
+//                
+//			temp-sensor@4d {
+//				compatible = "maxim,max6581";
+//				reg = <0x4d>;
+//				smbus-timeout-disable;
+//				resistance-cancellation;
+//				alert-mask = <0x72>;
+//				over-temperature-mask = <0x7f>;
+//			};
+//		};
+
+                serial@4500 {
+                        cell-index = <0x0>;
+                        device_type = "serial";
+                        compatible = "ns16550";
+                        reg = <0x4500 0x100>;
+                        clock-frequency = <0x0>;
+                        interrupts = <0x2a 0x2>;
+                        interrupt-parent = <0x2>;
+                };
+
+                serial@4600 {
+                        cell-index = <0x1>;
+                        device_type = "serial";
+                        compatible = "ns16550";
+                        reg = <0x4600 0x100>;
+                        clock-frequency = <0x0>;
+                        interrupts = <0x2a 0x2>;
+                        interrupt-parent = <0x2>;
+                };
+
+                spi1: spi@7000 {
+                        cell-index = <0x0>;
+                        #address-cells = <0x1>;
+                        #size-cells = <0x0>;
+                        compatible = "fsl,mpc8536-espi";
+                        reg = <0x7000 0x1000>;
+                        interrupts = <0x3b 0x2>;
+                        interrupt-parent = <0x2>;
+                        fsl,espi-num-chipselects = <4>;
+                };
+
+                gpio-controller@f000 {
+                        #gpio-cells = <0x2>;
+                        compatible = "fsl,mpc8572-gpio";
+                        reg = <0xf000 0x100>;
+                        interrupts = <0x2f 0x2>;
+                        interrupt-parent = <0x2>;
+                        gpio-controller;
+                };
+
+                tdm@16000 {
+                        device_type = "tdm";
+                        compatible = "fsl,starlite-tdm";
+                        reg = <0x16000 0x200 0x2c000 0x2000>;
+                        clock-frequency = <0x0>;
+                        interrupts = <0x10 0x8 0x3e 0x8>;
+                        interrupt-parent = <0x2>;
+                };
+
+                l2-cache-controller@20000 {
+                        compatible = "fsl,p1020-l2-cache-controller";
+                        reg = <0x20000 0x1000>;
+                        cache-line-size = <0x20>;
+                        cache-size = <0x40000>;
+                        interrupt-parent = <0x2>;
+                        interrupts = <0x10 0x2>;
+                        linux,phandle = <0x1>;
+                        phandle = <0x1>;
+                };
+
+                dma@21300 {
+                        #address-cells = <0x1>;
+                        #size-cells = <0x1>;
+                        compatible = "fsl,eloplus-dma";
+                        reg = <0x21300 0x4>;
+                        ranges = <0x0 0x21100 0x200>;
+                        cell-index = <0x0>;
+
+                        dma-channel@0 {
+                                compatible = "fsl,eloplus-dma-channel";
+                                reg = <0x0 0x80>;
+                                cell-index = <0x0>;
+                                interrupt-parent = <0x2>;
+                                interrupts = <0x14 0x2>;
+                        };
+
+                        dma-channel@80 {
+                                compatible = "fsl,eloplus-dma-channel";
+                                reg = <0x80 0x80>;
+                                cell-index = <0x1>;
+                                interrupt-parent = <0x2>;
+                                interrupts = <0x15 0x2>;
+                        };
+
+                        dma-channel@100 {
+                                compatible = "fsl,eloplus-dma-channel";
+                                reg = <0x100 0x80>;
+                                cell-index = <0x2>;
+                                interrupt-parent = <0x2>;
+                                interrupts = <0x16 0x2>;
+                        };
+
+                        dma-channel@180 {
+                                compatible = "fsl,eloplus-dma-channel";
+                                reg = <0x180 0x80>;
+                                cell-index = <0x3>;
+                                interrupt-parent = <0x2>;
+                                interrupts = <0x17 0x2>;
+                        };
+                };
+
+                mdio0: mdio@24000 {
+                        #address-cells = <0x1>;
+                        #size-cells = <0x0>;
+		        compatible = "fsl,etsec2-mdio";
+		        reg = <0x24000 0x1000 0xb0030 0x4>;
+
+
+                        phy0: ethernet-phy@0 {
+                                interrupts = <0x3 0x1>;
+                                reg = <0x1>;
+                        };
+
+                        phy1: ethernet-phy@1 {
+                                interrupts = <0x3 0x1>;
+				compatible = "ptin,dsa-switch";
+                                reg = <0x10>;
+                        };
+
+                        phy2: ethernet-phy@2 {
+                                interrupts = <0x3 0x1>;
+                                reg = <0x2>;
+                        };
+                };
+
+                mdio@25000 {
+                        #address-cells = <0x1>;
+                        #size-cells = <0x0>;
+
+                        tbi0: tbi-phy@11 {
+                                reg = <0x11>;
+                                device_type = "tbi-phy";
+                        };
+                };
+
+                mdio@26000 {
+                        #address-cells = <0x1>;
+                        #size-cells = <0x0>;
+
+                        tbi1: tbi-phy@11 {
+                                reg = <0x11>;
+                                device_type = "tbi-phy";
+                        };
+                };
+
+                ptimer@b0e00 {
+                        compatible = "fsl,gianfar-ptp-timer";
+                        reg = <0xb0e00 0xb0>;
+                        interrupts = <0x44 0x2 0x45 0x2 0x46 0x2>;
+                        interrupt-parent = <0x2>;
+                        tmr-prsc = <0x2>;
+                        cksel = <0x1>;
+                };
+
+                enet0: ethernet@b0000 {
+                        #address-cells = <0x1>;
+                        #size-cells = <0x1>;
+                        device_type = "network";
+                        model = "eTSEC";
+                        compatible = "fsl,etsec2";
+                        fsl,num_rx_queues = <0x8>;
+                        fsl,num_tx_queues = <0x8>;
+			fsl,magic-packet;
+                        local-mac-address = [00 00 00 00 00 00];
+			ranges;
+                        interrupt-parent = <0x2>;
+	                tbi-handle = <&tbi0>;
+			fixed-link = <0x0 0x1 0x3e8 0x0 0x0>;
+
+                        queue-group@0 {
+                                #address-cells = <0x1>;
+                                #size-cells = <0x1>;
+                                reg = <0xb0000 0x1000>;
+                                fsl,rx-bit-map = <0xff>;
+                                fsl,tx-bit-map = <0xff>;
+                                interrupts = <0x1d 0x2 0x1e 0x2 0x22 0x2>;
+                        };
+                };
+
+                pic@40000 {
+                        interrupt-controller;
+                        #address-cells = <0x0>;
+                        #interrupt-cells = <0x2>;
+                        reg = <0x40000 0x40000>;
+                        compatible = "chrp,open-pic";
+                        device_type = "open-pic";
+                        linux,phandle = <0x2>;
+                        phandle = <0x2>;
+                };
+
+                message@41400 {
+                        compatible = "fsl,p1020-msg", "fsl,mpic-msg";
+                        reg = <0x41400 0x200>;
+                        interrupts = <0xb0 0x2 0xb1 0x2 0xb2 0x2 0xb3 0x2>;
+                        interrupt-parent = <0x2>;
+                };
+
+                message@42400 {
+                        compatible = "fsl,p1020-msg", "fsl,mpic-msg";
+                        reg = <0x42400 0x200>;
+                        interrupts = <0xb4 0x2 0xb5 0x2 0xb6 0x2 0xb7 0x2>;
+                        interrupt-parent = <0x2>;
+                };
+
+                msi@41600 {
+                        compatible = "fsl,p1020-msi", "fsl,mpic-msi";
+                        reg = <0x41600 0x80>;
+                        msi-available-ranges = <0x0 0x100>;
+                        interrupts = <0xe0 0x0 0xe1 0x0 0xe2 0x0 0xe3 0x0 0xe4 0x0 0xe5 0x0 0xe6 0x0 0xe7 0x0>;
+                        interrupt-parent = <0x2>;
+                };
+
+                global-utilities@e0000 {
+                        compatible = "fsl,p2020-guts";
+                        reg = <0xe0000 0x1000>;
+                        fsl,has-rstcr;
+                };
+        };
+//
+//        pcie@ffe0a000 {
+//                compatible = "fsl,p1010-pcie", "fsl,qoriq-pcie-v2.3", "fsl,qoriq-pcie-v2.2";
+//                device_type = "pci";
+//                #interrupt-cells = <0x1>;
+//                #size-cells = <0x2>;
+//                #address-cells = <0x3>;
+//                reg = <0x0 0xffe0a000 0x0 0x1000>;
+//                bus-range = <0x0 0xff>;
+//                ranges = <0x2000000 0x0 0x80000000 0x0 0x80000000 0x0 0x20000000 0x1000000 0x0 0x0 0x0 0xffc00000 0x0 0x10000>;
+//                clock-frequency = <0x7735940>;
+//                interrupt-parent = <0x2>;
+//                interrupts = <0x1a 0x2>;
+//                interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
+//                interrupt-map = <0x0 0x0 0x0 0x1 0x2 0x0 0x1 0x0 0x0 0x0 0x2 0x2 0x1 0x1 0x0 0x0 0x0 0x3 0x2 0x2 0x1 0x0 0x0 0x0 0x4 0x2 0x3 0x1>;
+//
+//                pcie@0 {
+//                        reg = <0x0 0x0 0x0 0x0 0x0>;
+//                        #size-cells = <0x2>;
+//                        #address-cells = <0x3>;
+//                        device_type = "pci";
+//                        ranges = <0x2000000 0x0 0x80000000 0x2000000 0x0 0x80000000 0x0 0x20000000 0x1000000 0x0 0x0 0x1000000 0x0 0x0 0x0 0x10000>;
+//                };
+//        };
+};
+
diff -rupN linux-4.1.8-UL200.ori/arch/powerpc/sysdev/Kconfig linux-4.1.8-UL200.mod/arch/powerpc/sysdev/Kconfig
--- linux-4.1.8-UL200.ori/arch/powerpc/sysdev/Kconfig	2016-10-20 14:46:32.323588000 +0100
+++ linux-4.1.8-UL200.mod/arch/powerpc/sysdev/Kconfig	2018-02-08 14:52:37.334505205 +0000
@@ -45,3 +45,8 @@ config FSL_CORENET_RCPM
 	bool
 	help
 	  This option enables support for RCPM (Run Control/Power Management).
+
+config PTIN_ETH_MARVELL_SWITCH
+	bool
+	default y
+
diff -rupN linux-4.1.8-UL200.ori/arch/powerpc/sysdev/Makefile linux-4.1.8-UL200.mod/arch/powerpc/sysdev/Makefile
--- linux-4.1.8-UL200.ori/arch/powerpc/sysdev/Makefile	2016-10-20 14:46:32.323588000 +0100
+++ linux-4.1.8-UL200.mod/arch/powerpc/sysdev/Makefile	2018-02-08 14:52:37.344504445 +0000
@@ -60,6 +60,8 @@ obj-$(CONFIG_UCODE_PATCH)	+= micropatch.
 obj-$(CONFIG_PPC_MPC512x)	+= mpc5xxx_clocks.o
 obj-$(CONFIG_PPC_MPC52xx)	+= mpc5xxx_clocks.o
 
+obj-$(CONFIG_PTIN_ETH_MARVELL_SWITCH)   += mv88e632x_of.o
+
 ifeq ($(CONFIG_SUSPEND),y)
 obj-$(CONFIG_6xx)		+= 6xx-suspend.o
 endif
diff -rupN linux-4.1.8-UL200.ori/arch/powerpc/sysdev/mv88e632x_of.c linux-4.1.8-UL200.mod/arch/powerpc/sysdev/mv88e632x_of.c
--- linux-4.1.8-UL200.ori/arch/powerpc/sysdev/mv88e632x_of.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8-UL200.mod/arch/powerpc/sysdev/mv88e632x_of.c	2018-02-08 14:52:37.338504901 +0000
@@ -0,0 +1,170 @@
+#include <linux/of.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+
+#include <linux/list.h>
+#include <linux/netdevice.h>    
+#include <linux/phy.h>
+#include <linux/cdev.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+
+#include <../net/dsa/dsa_priv.h>
+#include "mv88e632x_of.h"
+
+
+#define READ_MV_REG_CMD    0x1
+#define WRITE_MV_REG_CMD   0x2
+
+struct miscdevice misc_sw;
+static int mvdev_open = 0;
+
+struct mii_bus *global_bus; 
+
+static int Major;
+#define DEVICE_NAME "marvell_sw_dev"
+
+int mv88e632x_reg_read(struct mii_bus *bus, int addr, int reg) {
+    return mdiobus_read(bus, addr, reg);
+}
+
+int mv88e632x_reg_write(struct mii_bus *bus, int addr, int reg, u16 val) {
+    return mdiobus_write(bus, addr, reg, val);
+}
+
+static ssize_t read_mv88e632x(struct file *file, char __user *data, size_t size, loff_t *offset) {
+	printk("%s(0x%p, 0x%p, 0x%zu, 0x%p)\n", __FUNCTION__, file, data, size, offset);
+    return mv88e632x_reg_read(global_bus, data[0], data[1]);
+}
+
+static ssize_t write_mv88e632x(struct file *file, const char __user *data, size_t size, loff_t *offset) {
+    u16 val = (data[2]<<8 | data [3]);
+	printk("%s(0x%p, 0x%p, 0x%zu, 0x%p)\n", __FUNCTION__, file, data, size, offset);
+    mv88e632x_reg_write(global_bus, data[0], data[1], val);
+	return 0;
+}
+
+static int mv88e632x_probe(struct platform_device *ofdev/*, const struct of_device_id *match*/) {
+    
+    printk ("Probe do driver da PTIN MV88e632x\n");
+    return 0;
+}
+
+static int mv88e632x_remove(struct platform_device *ofdev) {
+    printk ("Remove do driver da PTIN MV88e632x\n");
+    
+	return 0;
+}
+
+static struct of_device_id mv88e632x_match[] = {
+	{
+		.compatible = "ptin,dsa-switch",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mv88e632x_match);
+
+static int open_mv88e632x(struct inode *inode, struct file *file) {
+	//printk("%s(0x%p, 0x%p)\n", __FUNCTION__, inode, file);
+    if (mvdev_open) return -EBUSY;
+
+    mvdev_open=1;
+	return 0;
+}
+
+static int release_mv88e632x(struct inode *inode, struct file *file) {
+	//printk("%s(0x%p, 0x%p)\n", __FUNCTION__, inode, file);
+    mvdev_open=0;
+	return 0;
+}
+
+static long ioctl_mv88e632x(struct file *file, unsigned int cmd, unsigned long arg) { 
+    int retval = 0;
+	switch ( cmd ) {
+        case READ_MV_REG_CMD:
+			retval=mv88e632x_reg_read(global_bus, (unsigned char)(arg>>8), (unsigned char)arg);
+            break;
+        case WRITE_MV_REG_CMD:
+            retval=mv88e632x_reg_write(global_bus, (unsigned char)(arg>>24), (unsigned char)(arg>>16), (unsigned short)arg);
+			break;
+		default:
+			retval = -EINVAL;
+	}
+	return retval;
+}
+
+static struct file_operations mv_fops = {
+    .open = open_mv88e632x,
+    .release = release_mv88e632x,
+    .read = read_mv88e632x,
+    .write = write_mv88e632x,
+    .unlocked_ioctl = ioctl_mv88e632x,
+};
+
+static struct platform_driver mv88e632x_driver = {
+	.driver = {
+		.name = "mv88e632x",
+		.owner = THIS_MODULE,
+		.of_match_table = mv88e632x_match,
+	},
+	.probe = mv88e632x_probe,
+	.remove = mv88e632x_remove,
+};
+
+
+static int __init mv88e632x_init(void) {
+    printk ("Init do driver da PTIN MV88e632x\n");
+
+	return platform_driver_register(&mv88e632x_driver); 
+}
+module_init(mv88e632x_init);
+
+void mv88e632x_exit(void) {
+    unregister_chrdev(Major, DEVICE_NAME);
+	platform_driver_unregister(&mv88e632x_driver);
+}
+module_exit(mv88e632x_exit);
+
+struct phy_device * mv88e632x_detect(struct mii_bus *bus, int sw_addr) {
+    struct phy_device *dev = NULL;
+	u32 phy_id;
+    int ret=0;
+
+    Major = register_chrdev(0, DEVICE_NAME, &mv_fops);
+
+	if (Major < 0) {
+	    printk(KERN_ALERT "Registering marvell char device failed with %d\n", Major);
+	}else {
+        printk(KERN_ALERT "Registering marvell char device with %d \n", Major);
+    }
+
+    printk ("Initializing MV88e632x (addr %X): \n", sw_addr);
+	ret = mv88e632x_reg_read(bus, REG_PORT(0), 0x03);
+	if (ret >= 0 && ret != 0xFFFF) {
+		phy_id = ret & 0xfff0;
+		if (phy_id == 0x0950)
+			printk("Marvell 88E6095/88E6095F Detected\n");
+		else if (phy_id == 0x1060)
+			printk("Marvell 88E6131 Detected\n");
+        else if (phy_id == 0x3100)
+            printk("Marvell 88E6321 Detected\n");
+        else if (phy_id == 0x1150)
+            printk("Marvell 88E6320 Detected\n");
+        else{
+            printk("Unknown Device Detected - but will use it anyway %04X\n", ret);
+        }
+	}else{
+        printk("Marvell 88E6095/88E6095F not Detected - but will use it anyway\n");
+        phy_id = 0x3100;
+    }
+
+    global_bus = bus;
+
+    return dev;
+
+}
+
+MODULE_LICENSE("GPL");
+
diff -rupN linux-4.1.8-UL200.ori/arch/powerpc/sysdev/mv88e632x_of.h linux-4.1.8-UL200.mod/arch/powerpc/sysdev/mv88e632x_of.h
--- linux-4.1.8-UL200.ori/arch/powerpc/sysdev/mv88e632x_of.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8-UL200.mod/arch/powerpc/sysdev/mv88e632x_of.h	2018-02-08 14:52:37.345504369 +0000
@@ -0,0 +1,12 @@
+#ifndef __MARVELL_88E632X_DRIVER__
+#define __MARVELL_88E632X_DRIVER__
+
+#include <linux/phy.h>
+
+#define REG_PORT(p)            (0x10 + (p))
+#define REG_GLOBAL             0x1b
+#define REG_GLOBAL2            0x1c
+
+extern struct phy_device * mv88e632x_detect(struct mii_bus *bus, int sw_addr);
+
+#endif  //__MARVELL_88E6095X_DRIVER__
diff -rupN linux-4.1.8-UL200.ori/drivers/mtd/nand/fsl_ifc_nand.c linux-4.1.8-UL200.mod/drivers/mtd/nand/fsl_ifc_nand.c
--- linux-4.1.8-UL200.ori/drivers/mtd/nand/fsl_ifc_nand.c	2016-10-20 15:09:36.175248000 +0100
+++ linux-4.1.8-UL200.mod/drivers/mtd/nand/fsl_ifc_nand.c	2018-02-08 14:52:35.003682293 +0000
@@ -463,10 +463,11 @@ static void fsl_ifc_cmdfunc(struct mtd_i
 
 		/*
 		 * although currently it's 8 bytes for READID, we always read
-		 * the maximum 256 bytes(for PARAM)
+		 * the maximum 8192 bytes(for PARAM) supported by IFC controller
+		 * as extended page may be available for some NAND devices.
 		 */
-		ifc_out32(256, &ifc->ifc_nand.nand_fbcr);
-		ifc_nand_ctrl->read_bytes = 256;
+		ifc_out32(0, &ifc->ifc_nand.nand_fbcr); /* Read whole page */
+		ifc_nand_ctrl->read_bytes = 8192; /* Maximum supported page by IFC */
 
 		set_addr(mtd, 0, 0, 0);
 		fsl_ifc_run_command(mtd);
@@ -606,6 +607,29 @@ static void fsl_ifc_cmdfunc(struct mtd_i
 		fsl_ifc_run_command(mtd);
 		return;
 
+	case NAND_CMD_RNDOUT: {
+		__le16 Tccs = 0;
+		chip->onfi_version ? (Tccs = chip->onfi_params.t_ccs)
+					: (Tccs = chip->jedec_params.t_ccs);
+		ifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |
+				(IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |
+				(IFC_FIR_OP_CMD1 << IFC_NAND_FIR0_OP2_SHIFT) |
+				(IFC_FIR_OP_NWAIT << IFC_NAND_FIR0_OP3_SHIFT),
+				&ifc->ifc_nand.nand_fir0);
+
+		ifc_out32((NAND_CMD_RNDOUT << IFC_NAND_FCR0_CMD0_SHIFT) |
+				(NAND_CMD_RNDOUTSTART << IFC_NAND_FCR0_CMD1_SHIFT),
+				&ifc->ifc_nand.nand_fcr0);
+
+		/* Wait for minimum change column set-up time. But it does not harm
+		 * to wait more time, so calculated based on 333.3 MHz input IFC clock
+		 */
+		ifc_out32((0xFF & (le16_to_cpu(Tccs)/3)), &ifc->ifc_nand.ncfgr);
+		set_addr(mtd, column, 0, 0);
+		fsl_ifc_run_command(mtd);
+		return;
+	}
+
 	default:
 		dev_err(priv->dev, "%s: error, unsupported command 0x%x.\n",
 					__func__, command);
diff -rupN linux-4.1.8-UL200.ori/drivers/of/of_mdio.c linux-4.1.8-UL200.mod/drivers/of/of_mdio.c
--- linux-4.1.8-UL200.ori/drivers/of/of_mdio.c	2016-10-20 15:09:36.175248000 +0100
+++ linux-4.1.8-UL200.mod/drivers/of/of_mdio.c	2018-02-08 14:52:35.186668390 +0000
@@ -20,6 +20,10 @@
 #include <linux/of_mdio.h>
 #include <linux/module.h>
 
+#ifdef CONFIG_PTIN_ETH_MARVELL_SWITCH
+#include <../arch/powerpc/sysdev/mv88e632x_of.h>
+#endif
+
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
 MODULE_LICENSE("GPL");
 
@@ -53,8 +57,20 @@ static int of_mdiobus_register_phy(struc
 
 	if (!is_c45 && !of_get_phy_id(child, &phy_id))
 		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
-	else
-		phy = get_phy_device(mdio, addr, is_c45);
+       else {
+#ifdef CONFIG_PTIN_ETH_MARVELL_SWITCH
+               if(of_device_is_compatible(child, "ptin,dsa-switch")){
+                       printk("bus addr 0x%p\n", mdio);
+                       mv88e632x_detect(mdio,addr);
+                       phy = get_phy_device(mdio, addr, is_c45);
+               }else{
+                       printk("bus addr 0x%p\n", mdio);
+                       phy = get_phy_device(mdio, addr, is_c45);
+               }
+#else
+                phy = get_phy_device(mdio, addr, is_c45);
+#endif
+       }
 	if (!phy || IS_ERR(phy))
 		return 1;
 
diff -rupN linux-4.1.8-UL200.ori/drivers/spi/Kconfig linux-4.1.8-UL200.mod/drivers/spi/Kconfig
--- linux-4.1.8-UL200.ori/drivers/spi/Kconfig	2016-10-20 15:09:36.175248000 +0100
+++ linux-4.1.8-UL200.mod/drivers/spi/Kconfig	2018-02-08 14:52:35.350655931 +0000
@@ -638,6 +638,12 @@ config SPI_DW_MMIO
 	tristate "Memory-mapped io interface driver for DW SPI core"
 	depends on SPI_DESIGNWARE
 
+config PTIN_SPI
+        tristate "Driver for ptin spi bus"
+        depends on SPI_SPIDEV
+        default y if SPI_SPIDEV
+
+
 #
 # There are lots of SPI device types, with sensors and memory
 # being probably the most widely used ones.
diff -rupN linux-4.1.8-UL200.ori/drivers/spi/Makefile linux-4.1.8-UL200.mod/drivers/spi/Makefile
--- linux-4.1.8-UL200.ori/drivers/spi/Makefile	2016-10-20 15:09:36.175248000 +0100
+++ linux-4.1.8-UL200.mod/drivers/spi/Makefile	2018-02-08 14:52:35.355655551 +0000
@@ -89,3 +89,4 @@ obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
 obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
 obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
+obj-$(CONFIG_PTIN_SPI)              += ptin-spi.o
diff -rupN linux-4.1.8-UL200.ori/drivers/spi/ptin-spi.c linux-4.1.8-UL200.mod/drivers/spi/ptin-spi.c
--- linux-4.1.8-UL200.ori/drivers/spi/ptin-spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8-UL200.mod/drivers/spi/ptin-spi.c	2018-02-08 14:52:35.354655627 +0000
@@ -0,0 +1,70 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#define PTIN_SPI_MAX_DEVS 4
+#define PTIN_SPI_BUS_NUM 1
+
+static struct spi_device *spi_device[PTIN_SPI_MAX_DEVS];
+
+static int __init spi_init(void) {
+    int ret, i;
+    struct spi_master *master;
+    struct spi_board_info spi_device_info[PTIN_SPI_MAX_DEVS];
+
+    printk("spi: ptin spi_init\n");
+
+    for (i=0;i<PTIN_SPI_MAX_DEVS;i++) {
+        sprintf(spi_device_info[i].modalias, "%s", "spidev");
+        spi_device_info[i].max_speed_hz = 40000000;
+        spi_device_info[i].bus_num = PTIN_SPI_BUS_NUM;
+        spi_device_info[i].chip_select = i;
+        spi_device_info[i].mode = 0;
+    }
+
+    /*To send data we have to know what spi port/pins should be used. This information
+     *       can be found in the device-tree. */
+    master = spi_busnum_to_master(PTIN_SPI_BUS_NUM);
+    if( !master ){
+        printk("%s ERROR! MASTER not found.\n", __FILE__);
+        return -ENODEV;
+    }
+
+    for (i=0;i<PTIN_SPI_MAX_DEVS;i++) {
+        // create a new slave device, given the master and device info
+        spi_device[i] = spi_new_device( master, &spi_device_info[i]);
+        if( !spi_device[i] ) {
+            printk("%s ERROR! FAILED to create slave device 0.\n", __FUNCTION__);
+          //return -ENODEV;
+        } 
+
+        spi_device[i]->bits_per_word = 8;
+        ret = spi_setup( spi_device[i] );
+        if( ret ){
+            printk("%s ERROR! FAILED to setup slave 0.\n", __FUNCTION__);
+            spi_unregister_device( spi_device[i] );
+            //return -ENODEV;
+        }
+
+    }
+
+    return 0;
+}
+
+
+static void __exit spi_exit(void) {
+    int i;
+
+    for (i=0;i<PTIN_SPI_MAX_DEVS;i++) {
+        if( spi_device[i] ){
+            spi_unregister_device( spi_device[i] );
+        }
+    }
+}
+
+module_init(spi_init);
+module_exit(spi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sergio Marques <email protected>");
+MODULE_DESCRIPTION("PTIN SPI module");
