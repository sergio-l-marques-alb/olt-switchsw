diff -rupN linux-4.1.8.ori/arch/powerpc/boot/dts/fsl/cxo2t4-uc.dts linux-4.1.8.mod/arch/powerpc/boot/dts/fsl/cxo2t4-uc.dts
--- linux-4.1.8.ori/arch/powerpc/boot/dts/fsl/cxo2t4-uc.dts	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8.mod/arch/powerpc/boot/dts/fsl/cxo2t4-uc.dts	2018-02-20 11:27:13.629402097 +0000
@@ -0,0 +1,236 @@
+/include/ "cxo2t4-uc-pre.dtsi"
+
+/ {
+        model = "fsl,P2041RDB";
+        compatible = "fsl,P2041RDB";
+        #address-cells = <2>;
+        #size-cells = <2>;
+        interrupt-parent = <&mpic>;
+
+        aliases {
+                ethernet0 = &enet0;
+                ethernet1 = &enet1;
+                phy_sgmii_2 = &phy_sgmii_2;
+                phy_sgmii_3 = &phy_sgmii_3;
+		spi1 = &spi1;
+        };
+
+        memory {
+                device_type = "memory";
+        };
+
+        reserved-memory {
+                #address-cells = <2>;
+                #size-cells = <2>;
+                ranges;
+
+                bman_fbpr: bman-fbpr {
+                        size = <0 0x1000000>;
+                        alignment = <0 0x1000000>;
+                };
+                qman_fqd: qman-fqd {
+                        size = <0 0x800000>;
+                        alignment = <0 0x800000>;
+                };
+                qman_pfdr: qman-pfdr {
+                        size = <0 0x2000000>;
+                        alignment = <0 0x2000000>;
+                };
+                pme_pdsr: pme-pdsr {
+                        compatible = "fsl,pme-pdsr";
+                        alloc-ranges = <0 0 0x10000 0>;
+                        size = <0 0x1000000>;
+                        alignment = <0 0x1000000>;
+                };
+                pme_sre: pme-sre {
+                         compatible = "fsl,pme-sre";
+                         alloc-ranges = <0 0 0x10000 0>;
+                         size = <0 0xa00000>;
+                         alignment = <0 0xa00000>;
+                };
+        };
+
+        dcsr: dcsr@f00000000 {
+                ranges = <0x00000000 0xf 0x00000000 0x01008000>;
+        };
+
+        bportals: bman-portals@ff4000000 {
+                ranges = <0x0 0xf 0xf4000000 0x200000>;
+        };
+
+        qportals: qman-portals@ff4200000 {
+                ranges = <0x0 0xf 0xf4200000 0x200000>;
+        };
+
+        soc: soc@ffe000000 {
+                ranges = <0x00000000 0xf 0xfe000000 0x1000000>;
+                reg = <0xf 0xfe000000 0 0x00001000>;
+                
+	        spi1: spi@110000 {
+	                #address-cells = <1>;
+                	#size-cells = <0>;
+        	        compatible = "fsl,mpc8536-espi";
+	               	reg = <0x110000 0x1000>;
+        	        interrupts = <53 0x2>;
+	                interrupt-parent = <&mpic>;
+                	fsl,espi-num-chipselects = <4>;
+        	        fsl,csbef = <1>;
+	                fsl,csaft = <1>;
+        	};
+
+                i2c@118000 {
+
+	                rtc@56 {
+                                compatible = "microcrystal,rv3029";
+                                reg = <0x56>;
+                        };
+
+                };
+
+                i2c@118100 {
+
+                };
+
+                usb1: usb@211000 {
+                        dr_mode = "host";
+                };
+
+                fman0: fman@400000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			cell-index = <1>;
+			compatible = "fsl,fman";
+			ranges = <0 0x400000 0x100000>;
+			reg = <0x400000 0x100000>;
+			clocks = <&fman_clk>;
+			clock-names = "fmanclk";
+
+                        enet0: ethernet@e0000 {
+                                tbi-handle = <&tbi0>;
+                                phy-handle = <&phy_sgmii_2>;
+                                phy-connection-type = "sgmii";
+				#address-cells = <1>;
+                        };
+
+                        mdio0: mdio@e1120 {
+                                tbi0: tbi-phy@8 {
+                                        reg = <0x8>;
+                                        device_type = "tbi-phy";
+                                };
+
+                                phy_sgmii_2: ethernet-phy@3 {
+                                        reg = <0x3>;
+                                };
+                                phy_sgmii_3: ethernet-phy@8 {
+                                compatible = "ptin,dsa-switch";
+                                        reg = <0x8>;
+                                };
+
+                        };
+
+                        enet1: ethernet@e2000 {
+                                tbi-handle = <&tbi1>;
+                                phy-connection-type = "sgmii";
+				fixed-link = <4 1 1000 0 0> ;
+                        };
+
+                        mdio@e3120 {
+                                tbi1: tbi-phy@31 {
+                                        reg = <31>;
+                                        device_type = "tbi-phy";
+                                };
+                        };
+                };
+        };
+
+        //rio: rapidio@ffe0c0000 {
+        //        reg = <0xf 0xfe0c0000 0 0x11000>;
+        //        
+        //        port1 {
+        //                ranges = <0 0 0xc 0x20000000 0 0x10000000>;
+        //        };
+        //        port2 {
+        //                ranges = <0 0 0xc 0x30000000 0 0x10000000>;
+        //        };
+        //};
+
+
+        lbc: localbus@ffe124000 {
+                reg = <0xf 0xfe124000 0 0x1000>;
+                ranges = <0 0 0xf 0xe8000000 0x08000000
+                          1 0 0xf 0xffa00000 0x00040000>;
+
+                flash@0,0 {
+                        compatible = "cfi-flash";
+                        reg = <0 0 0x08000000>;
+                        bank-width = <2>;
+                        device-width = <2>;
+                };
+        };
+
+/*
+        pci0: pcie@ffe200000 {
+                reg = <0xf 0xfe200000 0 0x1000>;
+                ranges = <0x02000000 0 0xe0000000 0xc 0x00000000 0x0 0x20000000
+                          0x01000000 0 0x00000000 0xf 0xf8000000 0x0 0x00010000>;
+                pcie@0 {
+                        ranges = <0x02000000 0 0xe0000000
+                                  0x02000000 0 0xe0000000
+                                  0 0x20000000
+        
+                                  0x01000000 0 0x00000000
+                                  0x01000000 0 0x00000000
+                                  0 0x00010000>;
+                };
+        };
+        
+        pci1: pcie@ffe201000 {
+                reg = <0xf 0xfe201000 0 0x1000>;
+                ranges = <0x02000000 0x0 0xe0000000 0xc 0x20000000 0x0 0x20000000
+                          0x01000000 0x0 0x00000000 0xf 0xf8010000 0x0 0x00010000>;
+                pcie@0 {
+                        ranges = <0x02000000 0 0xe0000000
+                                  0x02000000 0 0xe0000000
+                                  0 0x20000000
+        
+                                  0x01000000 0 0x00000000
+                                  0x01000000 0 0x00000000
+                                  0 0x00010000>;
+                };
+        };
+        
+        pci2: pcie@ffe202000 {
+                reg = <0xf 0xfe202000 0 0x1000>;
+                ranges = <0x02000000 0 0xe0000000 0xc 0x40000000 0 0x20000000
+                          0x01000000 0 0x00000000 0xf 0xf8020000 0 0x00010000>;
+                pcie@0 {
+                        ranges = <0x02000000 0 0xe0000000
+                                  0x02000000 0 0xe0000000
+                                  0 0x20000000
+        
+        
+                                  0x01000000 0 0x00000000
+                                  0x01000000 0 0x00000000
+                                  0 0x00010000>;
+                };
+        };
+*/
+        fsl,dpaa {
+                compatible = "fsl,p2041-dpaa", "fsl,dpaa";
+
+                ethernet@0 {
+                        compatible = "fsl,p2041-dpa-ethernet", "fsl,dpa-ethernet";
+                        fsl,fman-mac = <&enet1>;
+                };
+                ethernet@1 {
+                        compatible = "fsl,p2041-dpa-ethernet", "fsl,dpa-ethernet";
+                        fsl,fman-mac = <&enet0>;
+                };
+        };
+};
+
+/include/ "cxo2t4-uc-post.dtsi"
+/include/ "qoriq-dpaa-res1.dtsi"
+
+
+
diff -rupN linux-4.1.8.ori/arch/powerpc/boot/dts/fsl/cxo2t4-uc-post.dtsi linux-4.1.8.mod/arch/powerpc/boot/dts/fsl/cxo2t4-uc-post.dtsi
--- linux-4.1.8.ori/arch/powerpc/boot/dts/fsl/cxo2t4-uc-post.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8.mod/arch/powerpc/boot/dts/fsl/cxo2t4-uc-post.dtsi	2018-02-20 11:27:13.634402084 +0000
@@ -0,0 +1,480 @@
+/*
+ * P2041/P2040 Silicon/SoC Device Tree Source (post include)
+ *
+ * Copyright 2011 - 2014 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+&bman_fbpr {
+	compatible = "fsl,bman-fbpr";
+	alloc-ranges = <0 0 0x10 0>;
+};
+
+&qman_fqd {
+	compatible = "fsl,qman-fqd";
+	alloc-ranges = <0 0 0x10 0>;
+};
+
+&qman_pfdr {
+	compatible = "fsl,qman-pfdr";
+	alloc-ranges = <0 0 0x10 0>;
+};
+
+&lbc {
+	compatible = "fsl,p2041-elbc", "fsl,elbc", "simple-bus";
+	interrupts = <25 2 0 0>;
+	#address-cells = <2>;
+	#size-cells = <1>;
+};
+
+/* controller at 0x200000 */
+//&pci0 {
+//	compatible = "fsl,p2041-pcie", "fsl,qoriq-pcie-v2.2";
+//	device_type = "pci";
+//	#size-cells = <2>;
+//	#address-cells = <3>;
+//	bus-range = <0x0 0xff>;
+//	clock-frequency = <33333333>;
+//	interrupts = <16 2 1 15>;
+//	fsl,iommu-parent = <&pamu0>;
+//	fsl,liodn-reg = <&guts 0x500>; /* PEX1LIODNR */
+//	pcie@0 {
+//		reg = <0 0 0 0 0>;
+//		#interrupt-cells = <1>;
+//		#size-cells = <2>;
+//		#address-cells = <3>;
+//		device_type = "pci";
+//		interrupts = <16 2 1 15>;
+//		interrupt-map-mask = <0xf800 0 0 7>;
+//		interrupt-map = <
+//			/* IDSEL 0x0 */
+//			0000 0 0 1 &mpic 40 1 0 0
+//			0000 0 0 2 &mpic 1 1 0 0
+//			0000 0 0 3 &mpic 2 1 0 0
+//			0000 0 0 4 &mpic 3 1 0 0
+//			>;
+//	};
+//};
+
+/* controller at 0x201000 */
+//&pci1 {
+//	compatible = "fsl,p2041-pcie", "fsl,qoriq-pcie-v2.2";
+//	device_type = "pci";
+//	#size-cells = <2>;
+//	#address-cells = <3>;
+//	bus-range = <0 0xff>;
+//	clock-frequency = <33333333>;
+//	interrupts = <16 2 1 14>;
+//	fsl,iommu-parent = <&pamu0>;
+//	fsl,liodn-reg = <&guts 0x504>; /* PEX2LIODNR */
+//	pcie@0 {
+//		reg = <0 0 0 0 0>;
+//		#interrupt-cells = <1>;
+//		#size-cells = <2>;
+//		#address-cells = <3>;
+//		device_type = "pci";
+//		interrupts = <16 2 1 14>;
+//		interrupt-map-mask = <0xf800 0 0 7>;
+//		interrupt-map = <
+//			/* IDSEL 0x0 */
+//			0000 0 0 1 &mpic 41 1 0 0
+//			0000 0 0 2 &mpic 5 1 0 0
+//			0000 0 0 3 &mpic 6 1 0 0
+//			0000 0 0 4 &mpic 7 1 0 0
+//			>;
+//	};
+//};
+
+/* controller at 0x202000 */
+//&pci2 {
+//	compatible = "fsl,p2041-pcie", "fsl,qoriq-pcie-v2.2";
+//	device_type = "pci";
+//	#size-cells = <2>;
+//	#address-cells = <3>;
+//	bus-range = <0x0 0xff>;
+//	clock-frequency = <33333333>;
+//	interrupts = <16 2 1 13>;
+//	fsl,iommu-parent = <&pamu0>;
+//	fsl,liodn-reg = <&guts 0x508>; /* PEX3LIODNR */
+//	pcie@0 {
+//		reg = <0 0 0 0 0>;
+//		#interrupt-cells = <1>;
+//		#size-cells = <2>;
+//		#address-cells = <3>;
+//		device_type = "pci";
+//		interrupts = <16 2 1 13>;
+//		interrupt-map-mask = <0xf800 0 0 7>;
+//		interrupt-map = <
+//			/* IDSEL 0x0 */
+//			0000 0 0 1 &mpic 42 1 0 0
+//			0000 0 0 2 &mpic 9 1 0 0
+//			0000 0 0 3 &mpic 10 1 0 0
+//			0000 0 0 4 &mpic 11 1 0 0
+//			>;
+//	};
+//};
+
+//&rio {
+//	compatible = "fsl,srio";
+//	interrupts = <16 2 1 11>;
+//	#address-cells = <2>;
+//	#size-cells = <2>;
+//	fsl,iommu-parent = <&pamu0>;
+//	ranges;
+//
+//	port1 {
+//		#address-cells = <2>;
+//		#size-cells = <2>;
+//		cell-index = <1>;
+//		fsl,liodn-reg = <&guts 0x510>; /* RIO1LIODNR */
+//	};
+//
+//	port2 {
+//		#address-cells = <2>;
+//		#size-cells = <2>;
+//		cell-index = <2>;
+//		fsl,liodn-reg = <&guts 0x514>; /* RIO2LIODNR */
+//	};
+//};
+
+&dcsr {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "fsl,dcsr", "simple-bus";
+
+	dcsr-epu@0 {
+		compatible = "fsl,p2041-dcsr-epu", "fsl,dcsr-epu";
+		interrupts = <52 2 0 0
+			      84 2 0 0
+			      85 2 0 0>;
+		reg = <0x0 0x1000>;
+	};
+	dcsr-npc {
+		compatible = "fsl,dcsr-npc";
+		reg = <0x1000 0x1000 0x1000000 0x8000>;
+	};
+	dcsr-nxc@2000 {
+		compatible = "fsl,dcsr-nxc";
+		reg = <0x2000 0x1000>;
+	};
+	dcsr-corenet {
+		compatible = "fsl,dcsr-corenet";
+		reg = <0x8000 0x1000 0xB0000 0x1000>;
+	};
+	dcsr-dpaa@9000 {
+		compatible = "fsl,p2041-dcsr-dpaa", "fsl,dcsr-dpaa";
+		reg = <0x9000 0x1000>;
+	};
+	dcsr-ocn@11000 {
+		compatible = "fsl,p2041-dcsr-ocn", "fsl,dcsr-ocn";
+		reg = <0x11000 0x1000>;
+	};
+	dcsr-ddr@12000 {
+		compatible = "fsl,dcsr-ddr";
+		dev-handle = <&ddr1>;
+		reg = <0x12000 0x1000>;
+	};
+	dcsr-nal@18000 {
+		compatible = "fsl,p2041-dcsr-nal", "fsl,dcsr-nal";
+		reg = <0x18000 0x1000>;
+	};
+	dcsr-rcpm@22000 {
+		compatible = "fsl,p2041-dcsr-rcpm", "fsl,dcsr-rcpm";
+		reg = <0x22000 0x1000>;
+	};
+	dcsr-cpu-sb-proxy@40000 {
+		compatible = "fsl,dcsr-e500mc-sb-proxy", "fsl,dcsr-cpu-sb-proxy";
+		cpu-handle = <&cpu0>;
+		reg = <0x40000 0x1000>;
+	};
+	dcsr-cpu-sb-proxy@41000 {
+		compatible = "fsl,dcsr-e500mc-sb-proxy", "fsl,dcsr-cpu-sb-proxy";
+		cpu-handle = <&cpu1>;
+		reg = <0x41000 0x1000>;
+	};
+	dcsr-cpu-sb-proxy@42000 {
+		compatible = "fsl,dcsr-e500mc-sb-proxy", "fsl,dcsr-cpu-sb-proxy";
+		cpu-handle = <&cpu2>;
+		reg = <0x42000 0x1000>;
+	};
+	dcsr-cpu-sb-proxy@43000 {
+		compatible = "fsl,dcsr-e500mc-sb-proxy", "fsl,dcsr-cpu-sb-proxy";
+		cpu-handle = <&cpu3>;
+		reg = <0x43000 0x1000>;
+	};
+};
+
+/include/ "qoriq-bman1-portals.dtsi"
+
+/include/ "qoriq-qman1-portals.dtsi"
+
+&soc {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	device_type = "soc";
+	compatible = "simple-bus";
+
+	soc-sram-error {
+		compatible = "fsl,soc-sram-error";
+		interrupts = <16 2 1 29>;
+	};
+
+	corenet-law@0 {
+		compatible = "fsl,corenet-law";
+		reg = <0x0 0x1000>;
+		fsl,num-laws = <32>;
+	};
+
+	ddr1: memory-controller@8000 {
+		compatible = "fsl,qoriq-memory-controller-v4.5", "fsl,qoriq-memory-controller";
+		reg = <0x8000 0x1000>;
+		interrupts = <16 2 1 23>;
+	};
+
+	cpc: l3-cache-controller@10000 {
+		compatible = "fsl,p2041-l3-cache-controller", "fsl,p4080-l3-cache-controller", "cache";
+		reg = <0x10000 0x1000>;
+		interrupts = <16 2 1 27>;
+	};
+
+	corenet-cf@18000 {
+		compatible = "fsl,corenet1-cf", "fsl,corenet-cf";
+		reg = <0x18000 0x1000>;
+		interrupts = <16 2 1 31>;
+		fsl,ccf-num-csdids = <32>;
+		fsl,ccf-num-snoopids = <32>;
+	};
+
+	iommu@20000 {
+		compatible = "fsl,pamu-v1.0", "fsl,pamu";
+		reg = <0x20000 0x4000>; /* for compatibility with older PAMU drivers */
+		ranges = <0 0x20000 0x4000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupts = <
+			24 2 0 0
+			16 2 1 30>;
+		fsl,portid-mapping = <0x0f000000>;
+
+		pamu0: pamu@0 {
+			reg = <0 0x1000>;
+			fsl,primary-cache-geometry = <32 1>;
+			fsl,secondary-cache-geometry = <128 2>;
+		};
+
+		pamu1: pamu@1000 {
+			reg = <0x1000 0x1000>;
+			fsl,primary-cache-geometry = <32 1>;
+			fsl,secondary-cache-geometry = <128 2>;
+		};
+
+		pamu2: pamu@2000 {
+			reg = <0x2000 0x1000>;
+			fsl,primary-cache-geometry = <32 1>;
+			fsl,secondary-cache-geometry = <128 2>;
+		};
+
+		pamu3: pamu@3000 {
+			reg = <0x3000 0x1000>;
+			fsl,primary-cache-geometry = <32 1>;
+			fsl,secondary-cache-geometry = <128 2>;
+		};
+	};
+
+/include/ "qoriq-mpic.dtsi"
+
+	guts: global-utilities@e0000 {
+		compatible = "fsl,qoriq-device-config-1.0";
+		reg = <0xe0000 0xe00>;
+		fsl,has-rstcr;
+		#sleep-cells = <1>;
+		fsl,liodn-bits = <12>;
+	};
+
+	pins: global-utilities@e0e00 {
+		compatible = "fsl,qoriq-pin-control-1.0";
+		reg = <0xe0e00 0x200>;
+		#sleep-cells = <2>;
+	};
+
+/include/ "qoriq-clockgen1.dtsi"
+	global-utilities@e1000 {
+		compatible = "fsl,p2041-clockgen", "fsl,qoriq-clockgen-1.0";
+	};
+
+	rcpm: global-utilities@e2000 {
+		compatible = "fsl,qoriq-rcpm-1.0";
+		reg = <0xe2000 0x1000>;
+		#sleep-cells = <1>;
+	};
+
+	sfp: sfp@e8000 {
+		compatible = "fsl,p2041-sfp", "fsl,qoriq-sfp-1.0";
+		reg	   = <0xe8000 0x1000>;
+	};
+
+	serdes: serdes@ea000 {
+		compatible = "fsl,p2041-serdes";
+		reg	   = <0xea000 0x1000>;
+	};
+
+/include/ "qoriq-dma-0.dtsi"
+	dma@100300 {
+		fsl,iommu-parent = <&pamu0>;
+		fsl,liodn-reg = <&guts 0x580>; /* DMA1LIODNR */
+	};
+
+/include/ "qoriq-dma-1.dtsi"
+	dma@101300 {
+		fsl,iommu-parent = <&pamu0>;
+		fsl,liodn-reg = <&guts 0x584>; /* DMA2LIODNR */
+	};
+
+/include/ "qoriq-espi-0.dtsi"
+	spi@110000 {
+		fsl,espi-num-chipselects = <4>;
+	};
+
+/include/ "qoriq-esdhc-0.dtsi"
+	sdhc@114000 {
+		compatible = "fsl,p2041-esdhc", "fsl,esdhc";
+		fsl,iommu-parent = <&pamu1>;
+		fsl,liodn-reg = <&guts 0x530>; /* eSDHCLIODNR */
+		sdhci,auto-cmd12;
+	};
+
+/include/ "qoriq-i2c-0.dtsi"
+/include/ "qoriq-i2c-1.dtsi"
+/include/ "qoriq-duart-0.dtsi"
+/include/ "qoriq-duart-1.dtsi"
+/include/ "qoriq-gpio-0.dtsi"
+/include/ "qoriq-usb2-mph-0.dtsi"
+	usb0: usb@210000 {
+		compatible = "fsl-usb2-mph-v1.6", "fsl,mpc85xx-usb2-mph", "fsl-usb2-mph";
+		phy_type = "utmi";
+		fsl,iommu-parent = <&pamu1>;
+		fsl,liodn-reg = <&guts 0x520>; /* USB1LIODNR */
+		port0;
+	};
+
+/include/ "qoriq-usb2-dr-0.dtsi"
+	usb1: usb@211000 {
+		compatible = "fsl-usb2-dr-v1.6", "fsl,mpc85xx-usb2-dr", "fsl-usb2-dr";
+		fsl,iommu-parent = <&pamu1>;
+		fsl,liodn-reg = <&guts 0x524>; /* USB2LIODNR */
+		dr_mode = "host";
+		phy_type = "utmi";
+	};
+
+/include/ "qoriq-sata2-0.dtsi"
+	sata@220000 {
+		fsl,iommu-parent = <&pamu1>;
+		fsl,liodn-reg = <&guts 0x550>; /* SATA1LIODNR */
+	};
+
+/include/ "qoriq-sata2-1.dtsi"
+	sata@221000 {
+		fsl,iommu-parent = <&pamu1>;
+		fsl,liodn-reg = <&guts 0x554>; /* SATA2LIODNR */
+	};
+
+/include/ "qoriq-sec4.2-0.dtsi"
+crypto: crypto@300000 {
+		fsl,iommu-parent = <&pamu1>;
+	};
+
+/include/ "qoriq-pme-0.dtsi"
+/include/ "qoriq-qman1.dtsi"
+/include/ "qoriq-bman1.dtsi"
+/include/ "qoriq-fman-0.dtsi"
+/include/ "qoriq-fman-0-1g-0.dtsi"
+/include/ "qoriq-fman-0-1g-1.dtsi"
+/*
+/include/ "qoriq-fman-0-1g-2.dtsi"
+/include/ "qoriq-fman-0-1g-3.dtsi"
+/include/ "qoriq-fman-0-1g-4.dtsi"
+/include/ "qoriq-fman-0-10g-0.dtsi"
+*/
+	fman0: fman@400000 {
+		/* tx - 1g - 0 */
+		port@a8000 {
+			fsl,qman-channel-id = <0x41>;
+		};
+		/* tx - 1g - 1 */
+		port@a9000 {
+			fsl,qman-channel-id = <0x42>;
+		};
+		/* tx - 1g - 2 */
+		port@aa000 {
+			fsl,qman-channel-id = <0x43>;
+		};
+		/* tx - 1g - 3 */
+		port@ab000 {
+			fsl,qman-channel-id = <0x44>;
+		};
+		/* tx - 1g - 4 */
+		port@ac000 {
+			fsl,qman-channel-id = <0x45>;
+		};
+		/* tx - 10g - 0 */
+		port@b0000 {
+			fsl,qman-channel-id = <0x40>;
+		};
+		/* offline 0 */
+		port@81000 {
+			fsl,qman-channel-id = <0x46>;
+		};
+		/* offline 1 */
+		port@82000 {
+			fsl,qman-channel-id = <0x47>;
+		};
+		/* offline 2 */
+		port@83000 {
+			fsl,qman-channel-id = <0x48>;
+		};
+		/* offline 3 */
+		port@84000 {
+			fsl,qman-channel-id = <0x49>;
+		};
+		/* offline 4 */
+		port@85000 {
+			fsl,qman-channel-id = <0x4a>;
+		};
+		/* offline 5 */
+		port@86000 {
+			fsl,qman-channel-id = <0x4b>;
+		};
+	};
+
+/include/ "qoriq-rman-0.dtsi"
+	rman: rman@1e0000 {
+		fsl,qman-channels-id = <0x62 0x63>;
+	};
+};
diff -rupN linux-4.1.8.ori/arch/powerpc/boot/dts/fsl/cxo2t4-uc-pre.dtsi linux-4.1.8.mod/arch/powerpc/boot/dts/fsl/cxo2t4-uc-pre.dtsi
--- linux-4.1.8.ori/arch/powerpc/boot/dts/fsl/cxo2t4-uc-pre.dtsi	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8.mod/arch/powerpc/boot/dts/fsl/cxo2t4-uc-pre.dtsi	2018-02-20 11:27:13.637402077 +0000
@@ -0,0 +1,127 @@
+/*
+ * P2041 Silicon/SoC Device Tree Source (pre include)
+ *
+ * Copyright 2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/dts-v1/;
+
+/include/ "e500mc_power_isa.dtsi"
+
+/ {
+	compatible = "fsl,P2041";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	interrupt-parent = <&mpic>;
+
+	aliases {
+		ccsr = &soc;
+		dcsr = &dcsr;
+
+		serial0 = &serial0;
+		serial1 = &serial1;
+		serial2 = &serial2;
+		serial3 = &serial3;
+		//pci0 = &pci0;
+		//pci1 = &pci1;
+		//pci2 = &pci2;
+		usb0 = &usb0;
+		usb1 = &usb1;
+		dma0 = &dma0;
+		dma1 = &dma1;
+		sdhc = &sdhc;
+		msi0 = &msi0;
+		msi1 = &msi1;
+		msi2 = &msi2;
+
+		crypto = &crypto;
+		sec_jr0 = &sec_jr0;
+		sec_jr1 = &sec_jr1;
+		sec_jr2 = &sec_jr2;
+		sec_jr3 = &sec_jr3;
+		rtic_a = &rtic_a;
+		rtic_b = &rtic_b;
+		rtic_c = &rtic_c;
+		rtic_d = &rtic_d;
+		sec_mon = &sec_mon;
+
+		pme = &pme;
+		qman = &qman;
+		bman = &bman;
+		fman0 = &fman0;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: PowerPC,e500mc@0 {
+			device_type = "cpu";
+			reg = <0>;
+			clocks = <&clockgen 1 0>;
+			next-level-cache = <&L2_0>;
+			fsl,portid-mapping = <0x80000000>;
+			L2_0: l2-cache {
+				next-level-cache = <&cpc>;
+			};
+		};
+		cpu1: PowerPC,e500mc@1 {
+			device_type = "cpu";
+			reg = <1>;
+			clocks = <&clockgen 1 1>;
+			next-level-cache = <&L2_1>;
+			fsl,portid-mapping = <0x40000000>;
+			L2_1: l2-cache {
+				next-level-cache = <&cpc>;
+			};
+		};
+		cpu2: PowerPC,e500mc@2 {
+			device_type = "cpu";
+			reg = <2>;
+			clocks = <&clockgen 1 2>;
+			next-level-cache = <&L2_2>;
+			fsl,portid-mapping = <0x20000000>;
+			L2_2: l2-cache {
+				next-level-cache = <&cpc>;
+			};
+		};
+		cpu3: PowerPC,e500mc@3 {
+			device_type = "cpu";
+			reg = <3>;
+			clocks = <&clockgen 1 3>;
+			next-level-cache = <&L2_3>;
+			fsl,portid-mapping = <0x10000000>;
+			L2_3: l2-cache {
+				next-level-cache = <&cpc>;
+			};
+		};
+	};
+};
diff -rupN linux-4.1.8.ori/arch/powerpc/sysdev/Kconfig linux-4.1.8.mod/arch/powerpc/sysdev/Kconfig
--- linux-4.1.8.ori/arch/powerpc/sysdev/Kconfig	2018-02-20 13:41:55.115453037 +0000
+++ linux-4.1.8.mod/arch/powerpc/sysdev/Kconfig	2018-02-20 11:27:13.492402453 +0000
@@ -45,3 +45,7 @@ config FSL_CORENET_RCPM
 	bool
 	help
 	  This option enables support for RCPM (Run Control/Power Management).
+
+config PTIN_ETH_MARVELL_SWITCH
+	bool
+	default y
diff -rupN linux-4.1.8.ori/arch/powerpc/sysdev/Makefile linux-4.1.8.mod/arch/powerpc/sysdev/Makefile
--- linux-4.1.8.ori/arch/powerpc/sysdev/Makefile	2018-02-20 13:41:55.116453033 +0000
+++ linux-4.1.8.mod/arch/powerpc/sysdev/Makefile	2018-02-20 11:27:13.498402437 +0000
@@ -60,6 +60,8 @@ obj-$(CONFIG_UCODE_PATCH)	+= micropatch.
 obj-$(CONFIG_PPC_MPC512x)	+= mpc5xxx_clocks.o
 obj-$(CONFIG_PPC_MPC52xx)	+= mpc5xxx_clocks.o
 
+obj-$(CONFIG_PTIN_ETH_MARVELL_SWITCH)   += mv88e6095x_of.o
+
 ifeq ($(CONFIG_SUSPEND),y)
 obj-$(CONFIG_6xx)		+= 6xx-suspend.o
 endif
diff -rupN linux-4.1.8.ori/arch/powerpc/sysdev/mv88e6095x_of.c linux-4.1.8.mod/arch/powerpc/sysdev/mv88e6095x_of.c
--- linux-4.1.8.ori/arch/powerpc/sysdev/mv88e6095x_of.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8.mod/arch/powerpc/sysdev/mv88e6095x_of.c	2018-02-20 11:27:13.492402453 +0000
@@ -0,0 +1,731 @@
+/*
+ * net/dsa/mv88e6095.c - Marvell 88e6095/6095f/6131 switch chip support
+ * Copyright (c) 2008-2009 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/of.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+/*#include <linux/of_platform.h>*/
+#include <linux/platform_device.h>
+
+
+#include <linux/list.h>
+#include <linux/netdevice.h>    
+#include <linux/phy.h>
+#include <linux/cdev.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+
+#include <../net/dsa/dsa_priv.h>
+#include <../net/dsa/mv88e6xxx.h>
+
+
+#define READ_MV_REG_CMD    0x1
+#define WRITE_MV_REG_CMD   0x2
+#define READ_CCSR_REG_CMD  0x3
+#define WRITE_CCSR_REG_CMD_ADD 0x41
+#define WRITE_CCSR_REG_CMD_VAL 0x42
+
+//#define SW_CHR_MAJOR 32
+//
+//static dev_t cdev_devnum;
+//static struct device *cdev_sw;
+//static struct class *sw_class;
+struct miscdevice misc_sw;
+static int mvdev_open = 0;
+
+struct mii_bus *global_bus; 
+int global_sw_addr;
+
+int ccsr_reg_add;
+
+static int Major;
+#define DEVICE_NAME "marvell_sw_dev"
+
+int mv88e6095_reg_read(struct mii_bus *bus, int sw_addr, int addr, int reg)
+{
+	int ret, cnt;    
+
+    if (sw_addr != 0) {
+
+        cnt=0;
+        //while ( (bus->read(bus, sw_addr, 0)&0x8000) != 0x0000 ) {
+        while ( (mdiobus_read(bus, sw_addr, 0)&0x8000) != 0x0000 ) {
+            printk("%s: Tive de esperar... E nao estava a estera...\n", __FUNCTION__); cnt++;
+            msleep(10);
+
+        if (cnt>100)
+            return -1;
+        }
+
+        /*
+         * Transmit the read command.
+         */
+        //ret = bus->write(bus, sw_addr, 0, 0x9800 | (addr << 5) | reg);
+        ret = mdiobus_write(bus, sw_addr, 0, 0x9800 | (addr << 5) | reg);
+        if (ret < 0)
+            return ret;
+
+        cnt=0;
+        //while ( (bus->read(bus, sw_addr, 0)&0x8000) != 0x0000 ) {
+        while ( (mdiobus_read(bus, sw_addr, 0)&0x8000) != 0x0000 ) {
+            printk("%s: Tive de esperar\n", __FUNCTION__); cnt++;
+            msleep(10);
+            if (cnt>100) return -1;
+        }
+
+        /*
+         * Read the data.
+         */
+        //ret = bus->read(bus, sw_addr, 1);
+        ret = mdiobus_read(bus, sw_addr, 1);
+
+        if (ret < 0)
+            return ret;
+
+    } else {
+
+
+        printk("%s: Nao estava a contar com isto!!!!\n", __FUNCTION__);
+        //ret = bus->read(bus, sw_addr, reg);
+        ret = mdiobus_read(bus, sw_addr, reg);
+        if (ret < 0)
+            return ret;
+    }
+    /*printk("Read MV reg %d of port %d with val 0x%X\n", reg, addr, ret & 0xffff );*/
+	return ret & 0xffff;
+}
+
+int mv88e6095_reg_write(struct mii_bus *bus, int sw_addr, int addr, int reg, u16 val)
+{
+	int ret, cnt;
+
+/*    printk("Write MV reg %d of port %d with 0x%04X\n", reg, addr, val);*/
+
+    if (sw_addr != 0) {
+        cnt=0;
+        //while ( (bus->read(bus, sw_addr, 0)&0x8000) != 0x0000 ) {
+        while ( (mdiobus_read(bus, sw_addr, 0)&0x8000) != 0x0000 ) {
+            printk("%s: Tive de esperar... E nao estava a estera...\n", __FUNCTION__);cnt++;
+            msleep(10);
+            if (cnt>100) return -1;
+        }
+
+        /*
+         * Transmit the data to write.
+         */
+        //ret = bus->write(bus, sw_addr, 1, val);
+        ret = mdiobus_write(bus, sw_addr, 1, val);
+        if (ret < 0)
+            return ret;
+
+        /*
+         * Transmit the write command.
+         */
+        //ret = bus->write(bus, sw_addr, 0, 0x9400 | (addr << 5) | reg);
+        ret = mdiobus_write(bus, sw_addr, 0, 0x9400 | (addr << 5) | reg);
+        if (ret < 0)
+            return ret;
+        
+        cnt=0;
+        //while ( (bus->read(bus, sw_addr, 0)&0x8000) != 0x0000 ) {
+        while ( (mdiobus_read(bus, sw_addr, 0)&0x8000) != 0x0000 ) {
+           printk("%s: Tive de esperar\n", __FUNCTION__);cnt++;
+           msleep(10);
+        if (cnt>100)
+            return -1;
+        }
+    } else {
+
+        printk("%s: Nao estava a contar com isto!!!!\n", __FUNCTION__);
+        //ret = bus->write(bus, sw_addr, reg, val);
+        ret = mdiobus_write(bus, sw_addr, reg, val);
+        if (ret < 0)
+            return ret;
+    }
+
+	return 0;
+}
+
+int ccsr_reg_read(int offset){
+	int __iomem *ccsr = NULL;
+	int retval;
+
+	ccsr = ioremap(0xFFE000000, 0x1000000);
+	retval = ccsr[offset/4];
+
+	iounmap(ccsr);
+
+	return retval;
+}
+
+int ccsr_reg_write(int val){
+	int __iomem *ccsr = NULL;
+
+	ccsr = ioremap(0xFFE000000, 0x1000000);
+	ccsr[ccsr_reg_add/4] = val;
+	iounmap(ccsr);
+
+	return 0;
+}
+
+static ssize_t read_mv88e6095(struct file *file, char __user *data, size_t size, loff_t *offset)
+{
+	printk("%s(0x%p, 0x%p, 0x%zu, 0x%p)\n", __FUNCTION__, file, data, size, offset);
+    return mv88e6095_reg_read(global_bus, global_sw_addr, data[0], data[1]);
+}
+
+static ssize_t write_mv88e6095(struct file *file, const char __user *data, size_t size, loff_t *offset)
+{
+    u16 val = (data[2]<<8 | data [3]);
+	printk("%s(0x%p, 0x%p, 0x%zu, 0x%p)\n", __FUNCTION__, file, data, size, offset);
+    mv88e6095_reg_write(global_bus, global_sw_addr, data[0], data[1], val);
+	return 0;
+}
+
+//static int __devinit mv88e6095_probe(struct platform_device *ofdev/*, const struct of_device_id *match*/)
+static int mv88e6095_probe(struct platform_device *ofdev/*, const struct of_device_id *match*/)
+{
+    
+    printk ("Probe do driver da PTIN MV88e6095\n");
+    return 0;
+}
+
+static int mv88e6095_remove(struct platform_device *ofdev)
+{
+    printk ("Remove do driver da PTIN MV88e6095\n");
+    
+	return 0;
+}
+
+static struct of_device_id mv88e6095_match[] = {
+	{
+		.compatible = "ptin,dsa-switch",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mv88e6095_match);
+
+static int open_mv88e6095(struct inode *inode, struct file *file)
+{
+	//printk("%s(0x%p, 0x%p)\n", __FUNCTION__, inode, file);
+    if (mvdev_open) return -EBUSY;
+
+    mvdev_open=1;
+	return 0;
+}
+
+static int release_mv88e6095(struct inode *inode, struct file *file)
+{
+	//printk("%s(0x%p, 0x%p)\n", __FUNCTION__, inode, file);
+    mvdev_open=0;
+	return 0;
+}
+
+static long ioctl_mv88e6095(struct file *file, unsigned int cmd, unsigned long arg) {
+	int retval = 0;
+	switch ( cmd ) {
+        case READ_MV_REG_CMD:
+			return (mv88e6095_reg_read(global_bus, global_sw_addr, (unsigned char)(arg>>8), (unsigned char)arg));
+			break;
+        case WRITE_MV_REG_CMD:
+            mv88e6095_reg_write(global_bus, global_sw_addr, (unsigned char)(arg>>24), (unsigned char)(arg>>16), (unsigned short)arg);
+			break;
+		case READ_CCSR_REG_CMD:
+			return (ccsr_reg_read((int)arg));
+			break;
+		case WRITE_CCSR_REG_CMD_ADD:
+			ccsr_reg_add = (int)arg;
+			break;
+		case WRITE_CCSR_REG_CMD_VAL:
+			return (ccsr_reg_write((int)arg));
+			break;
+		default:
+			retval = -EINVAL;
+	}
+	return retval;
+}
+
+static struct file_operations mv_fops = {
+    .open = open_mv88e6095,
+    .release = release_mv88e6095,
+    .read = read_mv88e6095,
+    .write = write_mv88e6095,
+    .unlocked_ioctl = ioctl_mv88e6095,
+};
+
+static struct platform_driver mv88e6095_driver = {
+	.driver = {
+		.name = "mv88e6095",
+		.owner = THIS_MODULE,
+		.of_match_table = mv88e6095_match,
+	},
+	.probe = mv88e6095_probe,
+	.remove = mv88e6095_remove,
+};
+
+
+static int __init mv88e6095_init(void)
+{
+    printk ("Init do driver da PTIN MV88e6095\n");
+
+	return platform_driver_register(&mv88e6095_driver); 
+}
+module_init(mv88e6095_init);
+
+void mv88e6095_exit(void)
+{
+    unregister_chrdev(Major, DEVICE_NAME);
+	platform_driver_unregister(&mv88e6095_driver);
+}
+module_exit(mv88e6095_exit);
+
+//static struct dsa_switch_driver mv88e6095_switch_driver = {
+//	.tag_protocol		= cpu_to_be16(ETH_P_DSA),
+//	.priv_size		= sizeof(struct mv88e6xxx_priv_state),
+//	.probe			= mv88e6095_probe,
+//	.setup			= mv88e6095_setup,
+//	.set_addr		= mv88e6xxx_set_addr_direct,
+//	.phy_read		= mv88e6095_phy_read,
+//	.phy_write		= mv88e6095_phy_write,
+//	.poll_link		= mv88e6xxx_poll_link,
+//	.get_strings		= mv88e6095_get_strings,
+//	.get_ethtool_stats	= mv88e6095_get_ethtool_stats,
+//	.get_sset_count		= mv88e6095_get_sset_count,
+//};
+
+//static int mv88e6095_switch_reset(struct mii_bus *bus, int sw_addr)
+//{
+//	int i;
+//	int ret;
+//
+//	/*
+//	 * Set all ports to the disabled state.
+//	 */
+//	for (i = 0; i < 11; i++) {
+//		ret = mv88e6095_reg_read(bus, sw_addr, REG_PORT(i), 0x04);
+//        mv88e6095_reg_write(bus, sw_addr, REG_PORT(i), 0x04, ret & 0xfffc);
+//	}
+//
+//	/*
+//	 * Wait for transmit queues to drain.
+//	 */
+//	msleep(2);
+//
+//	/*
+//	 * Reset the switch.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, REG_GLOBAL, 0x04, 0xC400);
+//
+//	/*
+//	 * Wait up to one second for reset to complete.
+//	 */
+//	for (i = 0; i < 1000; i++) {
+//		ret = mv88e6095_reg_read(bus, sw_addr, REG_GLOBAL, 0x00);
+//		if ((ret & 0xc800) == 0xc800)
+//			break;
+//
+//		msleep(1);
+//	}
+//	if (i == 1000)
+//		return -ETIMEDOUT;
+//
+//	return 0;
+//}
+//
+//static int mv88e6095_setup_global(struct mii_bus *bus, int sw_addr)
+//{
+////	int ret;
+////	int i;
+//
+//	/*
+//	 * Enable the PHY polling unit, don't discard packets with
+//	 * excessive collisions, use a weighted fair queueing scheme
+//	 * to arbitrate between packet queues, set the maximum frame
+//	 * size to 1632, and mask all interrupt sources.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, REG_GLOBAL, 0x04, 0x4400);
+//
+//	/*
+//	 * Set the default address aging time to 5 minutes, and
+//	 * enable address learn messages to be sent to all message
+//	 * ports.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, REG_GLOBAL, 0x0A, 0x0148);
+//
+////	/*
+////	 * Configure the priority mapping registers.
+////	 */
+////	ret = mv88e6xxx_config_prio(ds);
+////	if (ret < 0)
+////		return ret;
+//
+//	/*
+//	 * Set the VLAN ethertype to 0x8100.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, REG_GLOBAL, 0x19, 0x8100);
+//
+//	/*
+//	 * Disable ARP mirroring, and configure the upstream port as
+//	 * the port to which ingress and egress monitor frames are to
+//	 * be sent.
+//	 */
+////	REG_WRITE(REG_GLOBAL, 0x1a, (dsa_upstream_port(ds) * 0x1100) | 0x00f0);
+//
+//	/*
+//	 * Disable cascade port functionality, and set the switch's
+//	 * DSA device number.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, REG_GLOBAL, 0x1C, 0xE000);
+//
+//	/*
+//	 * Send all frames with destination addresses matching
+//	 * 01:80:c2:00:00:0x to the CPU port.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, REG_GLOBAL2, 0x3, 0xFFFF);
+//	//REG_WRITE(REG_GLOBAL2, 0x03, 0xffff);
+//
+//	/*
+//	 * Ignore removed tag data on doubly tagged packets, disable
+//	 * flow control messages, force flow control priority to the
+//	 * highest, and send all special multicast frames to the CPU
+//	 * port at the higest priority.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, REG_GLOBAL2, 0x05, 0x00FF);
+//	//REG_WRITE(REG_GLOBAL2, 0x05, 0x00ff);
+//
+//	/*
+//	 * Program the DSA routing table.
+//	 */
+////	for (i = 0; i < 32; i++) {
+////		int nexthop;
+////
+////		nexthop = 0x1f;
+////		if (i != ds->index && i < ds->dst->pd->nr_chips)
+////			nexthop = ds->pd->rtable[i] & 0x1f;
+////
+////		REG_WRITE(REG_GLOBAL2, 0x06, 0x8000 | (i << 8) | nexthop);
+////	}
+//
+//	/*
+//	 * Clear all trunk masks.
+//	 */
+////	for (i = 0; i < 8; i++)
+////		REG_WRITE(REG_GLOBAL2, 0x07, 0x8000 | (i << 12) | 0x7ff);
+////
+////	/*
+////	 * Clear all trunk mappings.
+////	 */
+////	for (i = 0; i < 16; i++)
+////		REG_WRITE(REG_GLOBAL2, 0x08, 0x8000 | (i << 11));
+//
+//	/*
+//	 * Force the priority of IGMP/MLD snoop frames and ARP frames
+//	 * to the highest setting.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, REG_GLOBAL2, 0x0F, 0x00FF);
+//	//REG_WRITE(REG_GLOBAL2, 0x0f, 0x00ff);
+//
+//	return 0;
+//}
+//
+//static int mv88e6095_setup_port(struct mii_bus *bus, int sw_addr, int p)
+//{
+//	int addr = REG_PORT(p);
+//	u16 val;
+//
+//	/*
+//	 * MAC Forcing register: don't force link, speed, duplex
+//	 * or flow control state to any particular values on physical
+//	 * ports, but force the CPU port and all DSA ports to 1000 Mb/s
+//	 * full duplex.
+//	 */
+//	//if (dsa_is_cpu_port(ds, p) || ds->dsa_port_mask & (1 << p))
+//    if (p == 9 || p == 10)
+//        mv88e6095_reg_write(bus, sw_addr, addr, 0x01, 0x003E);
+//        //REG_WRITE(addr, 0x01, 0x003e);
+//    else
+//        mv88e6095_reg_write(bus, sw_addr, addr, 0x01, 0x0003);
+//		//REG_WRITE(addr, 0x01, 0x0003);
+//
+//	/*
+//	 * Port Control: disable Core Tag, disable Drop-on-Lock,
+//	 * transmit frames unmodified, disable Header mode,
+//	 * enable IGMP/MLD snoop, disable DoubleTag, disable VLAN
+//	 * tunneling, determine priority by looking at 802.1p and
+//	 * IP priority fields (IP prio has precedence), and set STP
+//	 * state to Forwarding.
+//	 *
+//	 * If this is the upstream port for this switch, enable
+//	 * forwarding of unknown unicasts, and enable DSA tagging
+//	 * mode.
+//	 *
+//	 * If this is the link to another switch, use DSA tagging
+//	 * mode, but do not enable forwarding of unknown unicasts.
+//	 */
+//	val = 0x0433;
+//	if (p == 9 || p == 10)
+//		val |= 0x0104;
+////	if (ds->dsa_port_mask & (1 << p))
+////		val |= 0x0100;
+//    mv88e6095_reg_write(bus, sw_addr, addr, 0x04, val);
+////	REG_WRITE(addr, 0x04, val);
+//
+//	/*
+//	 * Port Control 1: disable trunking.  Also, if this is the
+//	 * CPU port, enable learn messages to be sent to this port.
+//	 */
+//    if (p==9 || p==10) mv88e6095_reg_write(bus, sw_addr, addr, 0x05, 0x8000);
+//    else mv88e6095_reg_write(bus, sw_addr, addr, 0x05, 0x0000);
+//	//REG_WRITE(addr, 0x05, dsa_is_cpu_port(ds, p) ? 0x8000 : 0x0000);
+//
+//	/*
+//	 * Port based VLAN map: give each port its own address
+//	 * database, allow the CPU port to talk to each of the 'real'
+//	 * ports, and allow each of the 'real' ports to only talk to
+//	 * the upstream port.
+//	 */
+////	val = (p & 0xf) << 12;
+////	if (dsa_is_cpu_port(ds, p))
+////		val |= ds->phys_port_mask;
+////	else
+////		val |= 1 << dsa_upstream_port(ds);
+////	REG_WRITE(addr, 0x06, val);
+//
+//	/*
+//	 * Default VLAN ID and priority: don't set a default VLAN
+//	 * ID, and set the default packet priority to zero.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, addr, 0x07, 0x0000);
+//	//REG_WRITE(addr, 0x07, 0x0000);
+//
+//	/*
+//	 * Port Control 2: don't force a good FCS, don't use
+//	 * VLAN-based, source address-based or destination
+//	 * address-based priority overrides, don't let the switch
+//	 * add or strip 802.1q tags, don't discard tagged or
+//	 * untagged frames on this port, do a destination address
+//	 * lookup on received packets as usual, don't send a copy
+//	 * of all transmitted/received frames on this port to the
+//	 * CPU, and configure the upstream port number.
+//	 *
+//	 * If this is the upstream port for this switch, enable
+//	 * forwarding of unknown multicast addresses.
+//	 */
+//	val = 0x0080 | 0x9;
+//	if (p == 9)
+//		val |= 0x0040;
+//    mv88e6095_reg_write(bus, sw_addr, addr, 0x08, val);
+//	//REG_WRITE(addr, 0x08, val);
+//
+//	/*
+//	 * Rate Control: disable ingress rate limiting.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, addr, 0x09, 0x0000);
+//	//REG_WRITE(addr, 0x09, 0x0000);
+//
+//	/*
+//	 * Rate Control 2: disable egress rate limiting.
+//	 */
+//    mv88e6095_reg_write(bus, sw_addr, addr, 0x0A, 0x0000);
+//	//REG_WRITE(addr, 0x0a, 0x0000);
+//
+//	/*
+//	 * Port Association Vector: when learning source addresses
+//	 * of packets, add the address to the address database using
+//	 * a port bitmap that has only the bit for this port set and
+//	 * the other bits clear.
+//	 */
+//	//REG_WRITE(addr, 0x0b, 1 << p);
+//
+//	/*
+//	 * Tag Remap: use an identity 802.1p prio -> switch prio
+//	 * mapping.
+//	 */
+//	//REG_WRITE(addr, 0x18, 0x3210);
+//
+//	/*
+//	 * Tag Remap 2: use an identity 802.1p prio -> switch prio
+//	 * mapping.
+//	 */
+//	//REG_WRITE(addr, 0x19, 0x7654);
+//
+//	return 0;
+//}
+//
+//static int mv88e6095_setup(struct mii_bus *bus, int sw_addr)
+//{
+//	int i;
+//	int ret;
+//
+////	mv88e6xxx_ppu_state_init(ds);
+//
+//	ret = mv88e6095_switch_reset(bus, sw_addr);
+//	if (ret < 0)
+//		return ret;
+//
+//	/* @@@ initialise vtu and atu */
+//
+//	ret = mv88e6095_setup_global(bus, sw_addr);
+//	if (ret < 0)
+//		return ret;
+//
+//	for (i = 0; i < 11; i++) {
+//		ret = mv88e6095_setup_port(bus, sw_addr, i);
+//		if (ret < 0)
+//			return ret;
+//	}
+//
+//	return 0;
+//}
+//
+//static int mv88e6095_port_to_phy_addr(int port)
+//{
+//	if (port >= 0 && port <= 11)
+//		return port;
+//	return -1;
+//}
+//
+//static int
+//mv88e6095_phy_read(struct dsa_switch *ds, int port, int regnum)
+//{
+//	int addr = mv88e6095_port_to_phy_addr(port);
+//	return mv88e6xxx_phy_read_ppu(ds, addr, regnum);
+//}
+//
+//static int
+//mv88e6095_phy_write(struct dsa_switch *ds,
+//			      int port, int regnum, u16 val)
+//{
+//	int addr = mv88e6095_port_to_phy_addr(port);
+//	return mv88e6xxx_phy_write_ppu(ds, addr, regnum, val);
+//}
+//
+//static struct mv88e6xxx_hw_stat mv88e6095_hw_stats[] = {
+//	{ "in_good_octets", 8, 0x00, },
+//	{ "in_bad_octets", 4, 0x02, },
+//	{ "in_unicast", 4, 0x04, },
+//	{ "in_broadcasts", 4, 0x06, },
+//	{ "in_multicasts", 4, 0x07, },
+//	{ "in_pause", 4, 0x16, },
+//	{ "in_undersize", 4, 0x18, },
+//	{ "in_fragments", 4, 0x19, },
+//	{ "in_oversize", 4, 0x1a, },
+//	{ "in_jabber", 4, 0x1b, },
+//	{ "in_rx_error", 4, 0x1c, },
+//	{ "in_fcs_error", 4, 0x1d, },
+//	{ "out_octets", 8, 0x0e, },
+//	{ "out_unicast", 4, 0x10, },
+//	{ "out_broadcasts", 4, 0x13, },
+//	{ "out_multicasts", 4, 0x12, },
+//	{ "out_pause", 4, 0x15, },
+//	{ "excessive", 4, 0x11, },
+//	{ "collisions", 4, 0x1e, },
+//	{ "deferred", 4, 0x05, },
+//	{ "single", 4, 0x14, },
+//	{ "multiple", 4, 0x17, },
+//	{ "out_fcs_error", 4, 0x03, },
+//	{ "late", 4, 0x1f, },
+//	{ "hist_64bytes", 4, 0x08, },
+//	{ "hist_65_127bytes", 4, 0x09, },
+//	{ "hist_128_255bytes", 4, 0x0a, },
+//	{ "hist_256_511bytes", 4, 0x0b, },
+//	{ "hist_512_1023bytes", 4, 0x0c, },
+//	{ "hist_1024_max_bytes", 4, 0x0d, },
+//};
+//
+//static void
+//mv88e6095_get_strings(struct dsa_switch *ds, int port, uint8_t *data)
+//{
+//	mv88e6xxx_get_strings(ds, ARRAY_SIZE(mv88e6095_hw_stats),
+//			      mv88e6095_hw_stats, port, data);
+//}
+//
+//static void
+//mv88e6095_get_ethtool_stats(struct dsa_switch *ds,
+//				  int port, uint64_t *data)
+//{
+//	mv88e6xxx_get_ethtool_stats(ds, ARRAY_SIZE(mv88e6095_hw_stats),
+//				    mv88e6095_hw_stats, port, data);
+//}
+//
+//static int mv88e6095_get_sset_count(struct dsa_switch *ds)
+//{
+//	return ARRAY_SIZE(mv88e6095_hw_stats);
+//}
+//
+
+
+
+struct phy_device * mv88e6095_detect(struct mii_bus *bus, int sw_addr)
+{
+    struct phy_device *dev = NULL;
+	u32 phy_id;
+    int i, ret=0;
+
+    Major = register_chrdev(0, DEVICE_NAME, &mv_fops);
+
+	if (Major < 0) {
+	    printk(KERN_ALERT "Registering marvell char device failed with %d\n", Major);
+	}else {
+        printk(KERN_ALERT "Registering marvell char device with %d \n", Major);
+    }
+
+    printk ("Initializing MV88e6095 (addr %d): \n", sw_addr);
+
+	ret = mv88e6095_reg_read(bus, sw_addr, REG_PORT(0), 0x03);
+	if (ret >= 0 && ret != 0xFFFF) {
+		phy_id = ret & 0xfff0;
+		if (phy_id == 0x0950)
+			printk("Marvell 88E6095/88E6095F Detected\n");
+		else if (phy_id == 0x1060)
+			printk("Marvell 88E6131 Detected\n");
+        else{
+            printk("Unknown Device Detected - but will use it anyway\n");
+        }
+	}else{
+        printk("Marvell 88E6095/88E6095F not Detected - but will use it anyway\n");
+        phy_id = 0x0950;
+    }
+
+	//dev = phy_device_create(bus, sw_addr, phy_id);
+
+    printk ("Set MV88e6095 port bitmap...\n");
+    //FE Ports
+    for (i=0;i<8;i++){
+        mv88e6095_reg_write(bus, sw_addr, REG_PORT(i), 0x06, 0x0600);
+    }
+
+    //GbE Ports
+    mv88e6095_reg_write(bus, sw_addr, REG_PORT(8),  0x06, 0x0600);    //HUGO porto G0 liga ao switch FPGA CXP360G
+    mv88e6095_reg_write(bus, sw_addr, REG_PORT(9),  0x06, 0x05ff);
+    mv88e6095_reg_write(bus, sw_addr, REG_PORT(10), 0x06, 0x03ff);
+    
+    printk ("Activate MV88e6095 ports\n");
+    //GbE Ports
+    mv88e6095_reg_write(bus, sw_addr, REG_PORT(8), 0x01, 0x003E); //HUGO porto G0 liga ao switch FPGA CXP360G
+    mv88e6095_reg_write(bus, sw_addr, REG_PORT(9), 0x01, 0x003E);
+    mv88e6095_reg_write(bus, sw_addr, REG_PORT(10), 0x01, 0x003E);
+
+    //FE Ports
+    for (i=0;i<11;i++){
+        printk ("Switch Port %d Control reg: 0x%X\r\n", i, mv88e6095_reg_read(bus, sw_addr, REG_PORT(i), 0x4));
+        mv88e6095_reg_write(bus, sw_addr, REG_PORT(i), 0x04, 0x0077);
+        msleep(100);
+        printk ("Switch Port %d Control reg: 0x%X\r\n", i, mv88e6095_reg_read(bus, sw_addr, REG_PORT(i), 0x4));
+    }
+
+    global_bus = bus;
+    global_sw_addr = sw_addr;
+
+	return dev;
+
+}
+
+MODULE_LICENSE("GPL");
+
diff -rupN linux-4.1.8.ori/arch/powerpc/sysdev/mv88e6095x_of.h linux-4.1.8.mod/arch/powerpc/sysdev/mv88e6095x_of.h
--- linux-4.1.8.ori/arch/powerpc/sysdev/mv88e6095x_of.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8.mod/arch/powerpc/sysdev/mv88e6095x_of.h	2018-02-20 11:27:13.495402445 +0000
@@ -0,0 +1,13 @@
+
+#ifndef __MARVELL_88E6095X_DRIVER__
+#define __MARVELL_88E6095X_DRIVER__
+
+#include <linux/phy.h>
+
+#define REG_PORT(p)		(0x10 + (p))
+#define REG_GLOBAL		0x1b
+#define REG_GLOBAL2		0x1c
+
+extern struct phy_device * mv88e6095_detect(struct mii_bus *bus, int sw_addr);
+
+#endif  //__MARVELL_88E6095X_DRIVER__
diff -rupN linux-4.1.8.ori/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c linux-4.1.8.mod/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
--- linux-4.1.8.ori/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c	2018-02-20 13:41:55.116453033 +0000
+++ linux-4.1.8.mod/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c	2018-02-20 11:27:10.774409503 +0000
@@ -1128,7 +1128,11 @@ static void FreeFmDev(t_LnxWrpFmDev  *p_
 /* FMan character device file operations */
 extern struct file_operations fm_fops;
 
-static int /*__devinit*/ fm_probe(struct platform_device *of_dev)
+#ifndef __devinit
+#define __devinit __init*
+#endif
+
+static int __devinit fm_probe(struct platform_device *of_dev)
 {
     t_LnxWrpFmDev   *p_LnxWrpFmDev;
 
diff -rupN linux-4.1.8.ori/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm_port.c linux-4.1.8.mod/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm_port.c
--- linux-4.1.8.ori/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm_port.c	2018-02-20 13:41:55.117453029 +0000
+++ linux-4.1.8.mod/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm_port.c	2018-02-20 11:27:10.769409516 +0000
@@ -1299,7 +1299,11 @@ static void FreeFmPortDev(t_LnxWrpFmPort
 			      p_LnxWrpFmPortDev->memSize);
 }
 
-static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
+#ifndef __devinit
+#define __devinit __init*
+#endif
+
+static int __devinit fm_port_probe(struct platform_device *of_dev)
 {
 	t_LnxWrpFmPortDev *p_LnxWrpFmPortDev;
 	t_LnxWrpFmDev *p_LnxWrpFmDev;
diff -rupN linux-4.1.8.ori/drivers/of/of_mdio.c linux-4.1.8.mod/drivers/of/of_mdio.c
--- linux-4.1.8.ori/drivers/of/of_mdio.c	2018-02-20 13:41:55.117453029 +0000
+++ linux-4.1.8.mod/drivers/of/of_mdio.c	2018-02-20 11:27:11.053408779 +0000
@@ -20,6 +20,10 @@
 #include <linux/of_mdio.h>
 #include <linux/module.h>
 
+#ifdef CONFIG_PTIN_ETH_MARVELL_SWITCH
+#include <../arch/powerpc/sysdev/mv88e6095x_of.h>
+#endif
+
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
 MODULE_LICENSE("GPL");
 
@@ -39,7 +43,6 @@ static int of_get_phy_id(struct device_n
 	}
 	return -EINVAL;
 }
-
 static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *child,
 				   u32 addr)
 {
@@ -53,8 +56,20 @@ static int of_mdiobus_register_phy(struc
 
 	if (!is_c45 && !of_get_phy_id(child, &phy_id))
 		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
-	else
+	else {
+#ifdef CONFIG_PTIN_ETH_MARVELL_SWITCH
+		if(of_device_is_compatible(child, "ptin,dsa-switch")){
+			printk("bus addr 0x%p\n", mdio);
+			mv88e6095_detect(mdio,addr);
+			phy = get_phy_device(mdio, addr, is_c45);
+		}else{
+			printk("bus addr 0x%p\n", mdio);
+			phy = get_phy_device(mdio, addr, is_c45);
+		}
+#else
 		phy = get_phy_device(mdio, addr, is_c45);
+#endif
+	}
 	if (!phy || IS_ERR(phy))
 		return 1;
 
diff -rupN linux-4.1.8.ori/drivers/rtc/Kconfig linux-4.1.8.mod/drivers/rtc/Kconfig
--- linux-4.1.8.ori/drivers/rtc/Kconfig	2016-10-20 15:09:36.175248000 +0100
+++ linux-4.1.8.mod/drivers/rtc/Kconfig	2018-02-20 11:27:10.972408989 +0000
@@ -129,7 +129,6 @@ config RTC_DRV_TEST
 	  will be called rtc-test.
 
 comment "I2C RTC drivers"
-	depends on I2C
 
 if I2C
 
@@ -202,6 +201,15 @@ config RTC_DRV_DS1307
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ds1307.
 
+config RTC_DRV_DS1307_HWMON
+	bool "HWMON support for rtc-ds1307"
+	depends on RTC_DRV_DS1307 && HWMON
+	depends on !(RTC_DRV_DS1307=y && HWMON=m)
+	default y
+	help
+	  Say Y here if you want to expose temperature sensor data on
+	  rtc-ds1307 (only DS3231)
+
 config RTC_DRV_DS1374
 	tristate "Dallas/Maxim DS1374"
 	depends on I2C
@@ -230,17 +238,6 @@ config RTC_DRV_DS1672
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ds1672.
 
-config RTC_DRV_DS3232
-	tristate "Dallas/Maxim DS3232"
-	depends on I2C
-	help
-	  If you say yes here you get support for Dallas Semiconductor
-	  DS3232 real-time clock chips. If an interrupt is associated
-	  with the device, the alarm functionality is supported.
-
-	  This driver can also be built as a module.  If so, the module
-	  will be called rtc-ds3232.
-
 config RTC_DRV_HYM8563
 	tristate "Haoyu Microelectronics HYM8563"
 	depends on I2C && OF
@@ -309,10 +306,10 @@ config RTC_DRV_MAX8997
 
 config RTC_DRV_MAX77686
 	tristate "Maxim MAX77686"
-	depends on MFD_MAX77686
+	depends on MFD_MAX77686 || MFD_MAX77620
 	help
 	  If you say yes here you will get support for the
-	  RTC of Maxim MAX77686 PMIC.
+	  RTC of Maxim MAX77686/MAX77620/MAX77802 PMIC.
 
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-max77686.
@@ -327,16 +324,6 @@ config RTC_DRV_RK808
 	  This driver can also be built as a module. If so, the module
 	  will be called rk808-rtc.
 
-config RTC_DRV_MAX77802
-	tristate "Maxim 77802 RTC"
-	depends on MFD_MAX77686
-	help
-	  If you say yes here you will get support for the
-	  RTC of Maxim MAX77802 PMIC.
-
-	  This driver can also be built as a module. If so, the module
-	  will be called rtc-max77802.
-
 config RTC_DRV_RS5C372
 	tristate "Ricoh R2025S/D, RS5C372A/B, RV5C386, RV5C387A"
 	help
@@ -384,25 +371,6 @@ config RTC_DRV_X1205
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-x1205.
 
-config RTC_DRV_PALMAS
-	tristate "TI Palmas RTC driver"
-	depends on MFD_PALMAS
-	help
-	  If you say yes here you get support for the RTC of TI PALMA series PMIC
-	  chips.
-
-	  This driver can also be built as a module. If so, the module
-	  will be called rtc-palma.
-
-config RTC_DRV_PCF2127
-	tristate "NXP PCF2127"
-	help
-	  If you say yes here you get support for the NXP PCF2127/29 RTC
-	  chips.
-
-	  This driver can also be built as a module. If so, the module
-	  will be called rtc-pcf2127.
-
 config RTC_DRV_PCF8523
 	tristate "NXP PCF8523"
 	help
@@ -412,6 +380,14 @@ config RTC_DRV_PCF8523
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-pcf8523.
 
+config RTC_DRV_PCF85063
+	tristate "NXP PCF85063"
+	help
+	  If you say yes here you get support for the PCF85063 RTC chip
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-pcf85063.
+
 config RTC_DRV_PCF8563
 	tristate "Philips PCF8563/Epson RTC8564"
 	help
@@ -422,14 +398,6 @@ config RTC_DRV_PCF8563
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-pcf8563.
 
-config RTC_DRV_PCF85063
-	tristate "nxp PCF85063"
-	help
-	  If you say yes here you get support for the PCF85063 RTC chip
-
-	  This driver can also be built as a module. If so, the module
-	  will be called rtc-pcf85063.
-
 config RTC_DRV_PCF8583
 	tristate "Philips PCF8583"
 	help
@@ -494,6 +462,16 @@ config RTC_DRV_TWL4030
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-twl.
 
+config RTC_DRV_PALMAS
+	tristate "TI Palmas RTC driver"
+	depends on MFD_PALMAS
+	help
+	  If you say yes here you get support for the RTC of TI PALMA series PMIC
+	  chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-palma.
+
 config RTC_DRV_TPS6586X
 	tristate "TI TPS6586X RTC driver"
 	depends on MFD_TPS6586X
@@ -551,6 +529,16 @@ config RTC_DRV_FM3130
 	  This driver can also be built as a module. If so the module
 	  will be called rtc-fm3130.
 
+config RTC_DRV_RX8010
+	tristate "Epson RX8010SJ"
+	depends on I2C
+	help
+	  If you say yes here you get support for the Epson RX8010SJ RTC
+	  chip.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-rx8010.
+
 config RTC_DRV_RX8581
 	tristate "Epson RX-8581"
 	help
@@ -577,15 +565,6 @@ config RTC_DRV_EM3027
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-em3027.
 
-config RTC_DRV_RV3029C2
-	tristate "Micro Crystal RTC"
-	help
-	  If you say yes here you get support for the Micro Crystal
-	  RV3029-C2 RTC chips.
-
-	  This driver can also be built as a module. If so, the module
-	  will be called rtc-rv3029c2.
-
 config RTC_DRV_S5M
 	tristate "Samsung S2M/S5M series"
 	depends on MFD_SEC_CORE
@@ -620,6 +599,15 @@ config RTC_DRV_M41T94
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-m41t94.
 
+config RTC_DRV_DS1302
+	tristate "Dallas/Maxim DS1302"
+	depends on SPI
+	help
+	  If you say yes here you get support for the Dallas DS1302 RTC chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-ds1302.
+
 config RTC_DRV_DS1305
 	tristate "Dallas/Maxim DS1305/DS1306"
 	help
@@ -665,15 +653,6 @@ config RTC_DRV_DS1390
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ds1390.
 
-config RTC_DRV_MAX6902
-	tristate "Maxim MAX6902"
-	help
-	  If you say yes here you will get support for the
-	  Maxim MAX6902 SPI RTC chip.
-
-	  This driver can also be built as a module. If so, the module
-	  will be called rtc-max6902.
-
 config RTC_DRV_R9701
 	tristate "Epson RTC-9701JE"
 	help
@@ -683,6 +662,23 @@ config RTC_DRV_R9701
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-r9701.
 
+config RTC_DRV_RX4581
+	tristate "Epson RX-4581"
+	help
+	  If you say yes here you will get support for the Epson RX-4581.
+
+	  This driver can also be built as a module. If so the module
+	  will be called rtc-rx4581.
+
+config RTC_DRV_RX6110
+	tristate "Epson RX-6110"
+	select REGMAP_SPI
+	help
+	  If you say yes here you will get support for the Epson RX-6610.
+
+	  This driver can also be built as a module. If so the module
+	  will be called rtc-rx6110.
+
 config RTC_DRV_RS5C348
 	tristate "Ricoh RS5C348A/B"
 	help
@@ -692,14 +688,14 @@ config RTC_DRV_RS5C348
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-rs5c348.
 
-config RTC_DRV_DS3234
-	tristate "Maxim/Dallas DS3234"
+config RTC_DRV_MAX6902
+	tristate "Maxim MAX6902"
 	help
-	  If you say yes here you get support for the
-	  Maxim/Dallas DS3234 SPI RTC chip.
+	  If you say yes here you will get support for the
+	  Maxim MAX6902 SPI RTC chip.
 
 	  This driver can also be built as a module. If so, the module
-	  will be called rtc-ds3234.
+	  will be called rtc-max6902.
 
 config RTC_DRV_PCF2123
 	tristate "NXP PCF2123"
@@ -710,14 +706,6 @@ config RTC_DRV_PCF2123
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-pcf2123.
 
-config RTC_DRV_RX4581
-	tristate "Epson RX-4581"
-	help
-	  If you say yes here you will get support for the Epson RX-4581.
-
-	  This driver can also be built as a module. If so the module
-	  will be called rtc-rx4581.
-
 config RTC_DRV_MCP795
 	tristate "Microchip MCP795"
 	help
@@ -728,6 +716,60 @@ config RTC_DRV_MCP795
 
 endif # SPI_MASTER
 
+#
+# Helper to resolve issues with configs that have SPI enabled but I2C
+# modular.  See SND_SOC_I2C_AND_SPI for more information
+#
+config RTC_I2C_AND_SPI
+	tristate
+	default m if I2C=m
+	default y if I2C=y
+	default y if SPI_MASTER=y
+	select REGMAP_I2C if I2C
+	select REGMAP_SPI if SPI_MASTER
+
+comment "SPI and I2C RTC drivers"
+
+config RTC_DRV_DS3232
+	tristate "Dallas/Maxim DS3232/DS3234"
+	depends on RTC_I2C_AND_SPI
+	help
+	  If you say yes here you get support for Dallas Semiconductor
+	  DS3232 and DS3234 real-time clock chips. If an interrupt is associated
+	  with the device, the alarm functionality is supported.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called rtc-ds3232.
+
+config RTC_DRV_PCF2127
+	tristate "NXP PCF2127"
+	depends on RTC_I2C_AND_SPI
+	help
+	  If you say yes here you get support for the NXP PCF2127/29 RTC
+	  chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-pcf2127.
+
+config RTC_DRV_RV3029C2
+	tristate "Micro Crystal RV3029/3049"
+	depends on RTC_I2C_AND_SPI
+	help
+	  If you say yes here you get support for the Micro Crystal
+	  RV3029 and RV3049 RTC chips.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-rv3029c2.
+
+config RTC_DRV_RV3029_HWMON
+	bool "HWMON support for RV3029/3049"
+	depends on RTC_DRV_RV3029C2 && HWMON
+	depends on !(RTC_DRV_RV3029C2=y && HWMON=m)
+	default y
+	help
+	  Say Y here if you want to expose temperature sensor data on
+	  rtc-rv3029.
+
 comment "Platform RTC drivers"
 
 # this 'CMOS' RTC driver is arch dependent because <asm-generic/rtc.h>
@@ -785,12 +827,6 @@ config RTC_DRV_DS1286
 	help
 	  If you say yes here you get support for the Dallas DS1286 RTC chips.
 
-config RTC_DRV_DS1302
-	tristate "Dallas DS1302"
-	depends on SH_SECUREEDGE5410
-	help
-	  If you say yes here you get support for the Dallas DS1302 RTC chips.
-
 config RTC_DRV_DS1511
 	tristate "Dallas DS1511"
 	depends on HAS_IOMEM
@@ -1061,7 +1097,7 @@ config RTC_DRV_WM8350
 
 config RTC_DRV_SPEAR
 	tristate "SPEAR ST RTC"
-	depends on PLAT_SPEAR
+	depends on PLAT_SPEAR || COMPILE_TEST
 	default y
 	help
 	 If you say Y here you will get support for the RTC found on
@@ -1093,7 +1129,7 @@ config RTC_DRV_AB8500
 
 config RTC_DRV_NUC900
 	tristate "NUC910/NUC920 RTC driver"
-	depends on ARCH_W90X900
+	depends on ARCH_W90X900 || COMPILE_TEST
 	help
 	  If you say yes here you get support for the RTC subsystem of the
 	  NUC910/NUC920 used in embedded systems.
@@ -1111,9 +1147,19 @@ config RTC_DRV_OPAL
 
 comment "on-CPU RTC drivers"
 
+config RTC_DRV_ASM9260
+	tristate "Alphascale asm9260 RTC"
+	depends on MACH_ASM9260
+	help
+	  If you say yes here you get support for the RTC on the
+	  Alphascale asm9260 SoC.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-asm9260.
+
 config RTC_DRV_DAVINCI
 	tristate "TI DaVinci RTC"
-	depends on ARCH_DAVINCI_DM365
+	depends on ARCH_DAVINCI_DM365 || COMPILE_TEST
 	help
 	  If you say yes here you get support for the RTC on the
 	  DaVinci platforms (DM365).
@@ -1123,7 +1169,7 @@ config RTC_DRV_DAVINCI
 
 config RTC_DRV_DIGICOLOR
 	tristate "Conexant Digicolor RTC"
-	depends on ARCH_DIGICOLOR
+	depends on ARCH_DIGICOLOR || COMPILE_TEST
 	help
 	  If you say yes here you get support for the RTC on Conexant
 	  Digicolor platforms. This currently includes the CX92755 SoC.
@@ -1142,7 +1188,7 @@ config RTC_DRV_IMXDI
 
 config RTC_DRV_OMAP
 	tristate "TI OMAP Real Time Clock"
-	depends on ARCH_OMAP || ARCH_DAVINCI
+	depends on ARCH_OMAP || ARCH_DAVINCI || COMPILE_TEST
 	help
 	  Say "yes" here to support the on chip real time clock
 	  present on TI OMAP1, AM33xx, DA8xx/OMAP-L13x, AM43xx and DRA7xx.
@@ -1159,7 +1205,7 @@ config HAVE_S3C_RTC
 
 config RTC_DRV_S3C
 	tristate "Samsung S3C series SoC RTC"
-	depends on ARCH_S3C64XX || HAVE_S3C_RTC
+	depends on ARCH_S3C64XX || HAVE_S3C_RTC || COMPILE_TEST
 	help
 	  RTC (Realtime Clock) driver for the clock inbuilt into the
 	  Samsung S3C24XX series of SoCs. This can provide periodic
@@ -1175,7 +1221,7 @@ config RTC_DRV_S3C
 
 config RTC_DRV_EP93XX
 	tristate "Cirrus Logic EP93XX"
-	depends on ARCH_EP93XX
+	depends on ARCH_EP93XX || COMPILE_TEST
 	help
 	  If you say yes here you get support for the
 	  RTC embedded in the Cirrus Logic EP93XX processors.
@@ -1205,7 +1251,7 @@ config RTC_DRV_SH
 
 config RTC_DRV_VR41XX
 	tristate "NEC VR41XX"
-	depends on CPU_VR41XX
+	depends on CPU_VR41XX || COMPILE_TEST
 	help
 	  If you say Y here you will get access to the real time clock
 	  built into your NEC VR41XX CPU.
@@ -1235,14 +1281,14 @@ config RTC_DRV_PL031
 
 config RTC_DRV_AT32AP700X
 	tristate "AT32AP700X series RTC"
-	depends on PLATFORM_AT32AP
+	depends on PLATFORM_AT32AP || COMPILE_TEST
 	help
 	  Driver for the internal RTC (Realtime Clock) on Atmel AVR32
 	  AT32AP700x family processors.
 
 config RTC_DRV_AT91RM9200
 	tristate "AT91RM9200 or some AT91SAM9 RTC"
-	depends on ARCH_AT91
+	depends on ARCH_AT91 || COMPILE_TEST
 	help
 	  Driver for the internal RTC (Realtime Clock) module found on
 	  Atmel AT91RM9200's and some  AT91SAM9 chips. On AT91SAM9 chips
@@ -1250,7 +1296,7 @@ config RTC_DRV_AT91RM9200
 
 config RTC_DRV_AT91SAM9
 	tristate "AT91SAM9 RTT as RTC"
-	depends on ARCH_AT91
+	depends on ARCH_AT91 || COMPILE_TEST
 	select MFD_SYSCON
 	help
 	  Some AT91SAM9 SoCs provide an RTT (Real Time Timer) block which
@@ -1310,7 +1356,7 @@ config RTC_DRV_PXA
 
 config RTC_DRV_VT8500
 	tristate "VIA/WonderMedia 85xx SoC RTC"
-	depends on ARCH_VT8500
+	depends on ARCH_VT8500 || COMPILE_TEST
 	help
 	  If you say Y here you will get access to the real time clock
 	  built into your VIA VT8500 SoC or its relatives.
@@ -1325,14 +1371,15 @@ config RTC_DRV_SUN4V
 
 config RTC_DRV_SUN6I
 	tristate "Allwinner A31 RTC"
-	depends on MACH_SUN6I || MACH_SUN8I
+	default MACH_SUN6I || MACH_SUN8I || COMPILE_TEST
+	depends on ARCH_SUNXI
 	help
-	  If you say Y here you will get support for the RTC found on
-	  Allwinner A31.
+	  If you say Y here you will get support for the RTC found in
+	  some Allwinner SoCs like the A31 or the A64.
 
 config RTC_DRV_SUNXI
 	tristate "Allwinner sun4i/sun7i RTC"
-	depends on MACH_SUN4I || MACH_SUN7I
+	depends on MACH_SUN4I || MACH_SUN7I || COMPILE_TEST
 	help
 	  If you say Y here you will get support for the RTC found on
 	  Allwinner A10/A20.
@@ -1353,7 +1400,7 @@ config RTC_DRV_TX4939
 
 config RTC_DRV_MV
 	tristate "Marvell SoC RTC"
-	depends on ARCH_DOVE || ARCH_MVEBU
+	depends on ARCH_DOVE || ARCH_MVEBU || COMPILE_TEST
 	help
 	  If you say yes here you will get support for the in-chip RTC
 	  that can be found in some of Marvell's SoC devices, such as
@@ -1364,7 +1411,7 @@ config RTC_DRV_MV
 
 config RTC_DRV_ARMADA38X
 	tristate "Armada 38x Marvell SoC RTC"
-	depends on ARCH_MVEBU
+	depends on ARCH_MVEBU || COMPILE_TEST
 	help
 	  If you say yes here you will get support for the in-chip RTC
 	  that can be found in the Armada 38x Marvell's SoC device
@@ -1383,7 +1430,7 @@ config RTC_DRV_PS3
 
 config RTC_DRV_COH901331
 	tristate "ST-Ericsson COH 901 331 RTC"
-	depends on ARCH_U300
+	depends on ARCH_U300 || COMPILE_TEST
 	help
 	  If you say Y here you will get access to ST-Ericsson
 	  COH 901 331 RTC clock found in some ST-Ericsson Mobile
@@ -1429,7 +1476,7 @@ config RTC_DRV_MPC5121
 
 config RTC_DRV_JZ4740
 	tristate "Ingenic JZ4740 SoC"
-	depends on MACH_JZ4740
+	depends on MACH_JZ4740 || COMPILE_TEST
 	help
 	  If you say yes here you get support for the Ingenic JZ4740 SoC RTC
 	  controller.
@@ -1438,7 +1485,7 @@ config RTC_DRV_JZ4740
 	  will be called rtc-jz4740.
 
 config RTC_DRV_LPC32XX
-	depends on ARCH_LPC32XX
+	depends on ARCH_LPC32XX || COMPILE_TEST
 	tristate "NXP LPC32XX RTC"
 	help
 	  This enables support for the NXP RTC in the LPC32XX
@@ -1448,7 +1495,7 @@ config RTC_DRV_LPC32XX
 
 config RTC_DRV_PM8XXX
 	tristate "Qualcomm PMIC8XXX RTC"
-	depends on MFD_PM8XXX || MFD_SPMI_PMIC
+	depends on MFD_PM8XXX || MFD_SPMI_PMIC || COMPILE_TEST
 	help
 	  If you say yes here you get support for the
 	  Qualcomm PMIC8XXX RTC.
@@ -1458,7 +1505,7 @@ config RTC_DRV_PM8XXX
 
 config RTC_DRV_TEGRA
 	tristate "NVIDIA Tegra Internal RTC driver"
-	depends on ARCH_TEGRA
+	depends on ARCH_TEGRA || COMPILE_TEST
 	help
 	  If you say yes here you get support for the
 	  Tegra 200 series internal RTC module.
@@ -1540,6 +1587,16 @@ config RTC_DRV_XGENE
 	  This driver can also be built as a module, if so, the module
 	  will be called "rtc-xgene".
 
+config RTC_DRV_PIC32
+	tristate "Microchip PIC32 RTC"
+	depends on MACH_PIC32
+	default y
+	help
+	   If you say yes here you get support for the PIC32 RTC module.
+
+	   This driver can also be built as a module. If so, the module
+	   will be called rtc-pic32
+
 comment "HID Sensor RTC drivers"
 
 config RTC_DRV_HID_SENSOR_TIME
diff -rupN linux-4.1.8.ori/drivers/rtc/rtc-rv3029c2.c linux-4.1.8.mod/drivers/rtc/rtc-rv3029c2.c
--- linux-4.1.8.ori/drivers/rtc/rtc-rv3029c2.c	2016-10-20 15:09:36.175248000 +0100
+++ linux-4.1.8.mod/drivers/rtc/rtc-rv3029c2.c	2018-02-20 11:51:27.386639728 +0000
@@ -1,7 +1,8 @@
 /*
- * Micro Crystal RV-3029C2 rtc class driver
+ * Micro Crystal RV-3029 / RV-3049 rtc class driver
  *
  * Author: Gregory Hermant <gregory.hermant@calao-systems.com>
+ *         Michael Buesch <m@bues.ch>
  *
  * based on previously existing rtc class drivers
  *
@@ -9,251 +10,481 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * NOTE: Currently this driver only supports the bare minimum for read
- * and write the RTC and alarms. The extra features provided by this chip
- * (trickle charger, eeprom, T° compensation) are unavailable.
  */
 
 #include <linux/module.h>
 #include <linux/i2c.h>
+#include <linux/spi/spi.h>
 #include <linux/bcd.h>
 #include <linux/rtc.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/regmap.h>
 
 /* Register map */
 /* control section */
-#define RV3029C2_ONOFF_CTRL		0x00
-#define RV3029C2_IRQ_CTRL		0x01
-#define RV3029C2_IRQ_CTRL_AIE		(1 << 0)
-#define RV3029C2_IRQ_FLAGS		0x02
-#define RV3029C2_IRQ_FLAGS_AF		(1 << 0)
-#define RV3029C2_STATUS			0x03
-#define RV3029C2_STATUS_VLOW1		(1 << 2)
-#define RV3029C2_STATUS_VLOW2		(1 << 3)
-#define RV3029C2_STATUS_SR		(1 << 4)
-#define RV3029C2_STATUS_PON		(1 << 5)
-#define RV3029C2_STATUS_EEBUSY		(1 << 7)
-#define RV3029C2_RST_CTRL		0x04
-#define RV3029C2_CONTROL_SECTION_LEN	0x05
+#define RV3029_ONOFF_CTRL		0x00
+#define RV3029_ONOFF_CTRL_WE		BIT(0)
+#define RV3029_ONOFF_CTRL_TE		BIT(1)
+#define RV3029_ONOFF_CTRL_TAR		BIT(2)
+#define RV3029_ONOFF_CTRL_EERE		BIT(3)
+#define RV3029_ONOFF_CTRL_SRON		BIT(4)
+#define RV3029_ONOFF_CTRL_TD0		BIT(5)
+#define RV3029_ONOFF_CTRL_TD1		BIT(6)
+#define RV3029_ONOFF_CTRL_CLKINT	BIT(7)
+#define RV3029_IRQ_CTRL			0x01
+#define RV3029_IRQ_CTRL_AIE		BIT(0)
+#define RV3029_IRQ_CTRL_TIE		BIT(1)
+#define RV3029_IRQ_CTRL_V1IE		BIT(2)
+#define RV3029_IRQ_CTRL_V2IE		BIT(3)
+#define RV3029_IRQ_CTRL_SRIE		BIT(4)
+#define RV3029_IRQ_FLAGS		0x02
+#define RV3029_IRQ_FLAGS_AF		BIT(0)
+#define RV3029_IRQ_FLAGS_TF		BIT(1)
+#define RV3029_IRQ_FLAGS_V1IF		BIT(2)
+#define RV3029_IRQ_FLAGS_V2IF		BIT(3)
+#define RV3029_IRQ_FLAGS_SRF		BIT(4)
+#define RV3029_STATUS			0x03
+#define RV3029_STATUS_VLOW1		BIT(2)
+#define RV3029_STATUS_VLOW2		BIT(3)
+#define RV3029_STATUS_SR		BIT(4)
+#define RV3029_STATUS_PON		BIT(5)
+#define RV3029_STATUS_EEBUSY		BIT(7)
+#define RV3029_RST_CTRL			0x04
+#define RV3029_RST_CTRL_SYSR		BIT(4)
+#define RV3029_CONTROL_SECTION_LEN	0x05
 
 /* watch section */
-#define RV3029C2_W_SEC			0x08
-#define RV3029C2_W_MINUTES		0x09
-#define RV3029C2_W_HOURS		0x0A
-#define RV3029C2_REG_HR_12_24		(1<<6)  /* 24h/12h mode */
-#define RV3029C2_REG_HR_PM		(1<<5)  /* PM/AM bit in 12h mode */
-#define RV3029C2_W_DATE			0x0B
-#define RV3029C2_W_DAYS			0x0C
-#define RV3029C2_W_MONTHS		0x0D
-#define RV3029C2_W_YEARS		0x0E
-#define RV3029C2_WATCH_SECTION_LEN	0x07
+#define RV3029_W_SEC			0x08
+#define RV3029_W_MINUTES		0x09
+#define RV3029_W_HOURS			0x0A
+#define RV3029_REG_HR_12_24		BIT(6) /* 24h/12h mode */
+#define RV3029_REG_HR_PM		BIT(5) /* PM/AM bit in 12h mode */
+#define RV3029_W_DATE			0x0B
+#define RV3029_W_DAYS			0x0C
+#define RV3029_W_MONTHS			0x0D
+#define RV3029_W_YEARS			0x0E
+#define RV3029_WATCH_SECTION_LEN	0x07
 
 /* alarm section */
-#define RV3029C2_A_SC			0x10
-#define RV3029C2_A_MN			0x11
-#define RV3029C2_A_HR			0x12
-#define RV3029C2_A_DT			0x13
-#define RV3029C2_A_DW			0x14
-#define RV3029C2_A_MO			0x15
-#define RV3029C2_A_YR			0x16
-#define RV3029C2_ALARM_SECTION_LEN	0x07
+#define RV3029_A_SC			0x10
+#define RV3029_A_MN			0x11
+#define RV3029_A_HR			0x12
+#define RV3029_A_DT			0x13
+#define RV3029_A_DW			0x14
+#define RV3029_A_MO			0x15
+#define RV3029_A_YR			0x16
+#define RV3029_A_AE_X			BIT(7)
+#define RV3029_ALARM_SECTION_LEN	0x07
 
 /* timer section */
-#define RV3029C2_TIMER_LOW		0x18
-#define RV3029C2_TIMER_HIGH		0x19
+#define RV3029_TIMER_LOW		0x18
+#define RV3029_TIMER_HIGH		0x19
 
 /* temperature section */
-#define RV3029C2_TEMP_PAGE		0x20
+#define RV3029_TEMP_PAGE		0x20
 
 /* eeprom data section */
-#define RV3029C2_E2P_EEDATA1		0x28
-#define RV3029C2_E2P_EEDATA2		0x29
+#define RV3029_E2P_EEDATA1		0x28
+#define RV3029_E2P_EEDATA2		0x29
+#define RV3029_E2PDATA_SECTION_LEN	0x02
 
 /* eeprom control section */
-#define RV3029C2_CONTROL_E2P_EECTRL	0x30
-#define RV3029C2_TRICKLE_1K		(1<<0)  /*  1K resistance */
-#define RV3029C2_TRICKLE_5K		(1<<1)  /*  5K resistance */
-#define RV3029C2_TRICKLE_20K		(1<<2)  /* 20K resistance */
-#define RV3029C2_TRICKLE_80K		(1<<3)  /* 80K resistance */
-#define RV3029C2_CONTROL_E2P_XTALOFFSET	0x31
-#define RV3029C2_CONTROL_E2P_QCOEF	0x32
-#define RV3029C2_CONTROL_E2P_TURNOVER	0x33
+#define RV3029_CONTROL_E2P_EECTRL	0x30
+#define RV3029_EECTRL_THP		BIT(0) /* temp scan interval */
+#define RV3029_EECTRL_THE		BIT(1) /* thermometer enable */
+#define RV3029_EECTRL_FD0		BIT(2) /* CLKOUT */
+#define RV3029_EECTRL_FD1		BIT(3) /* CLKOUT */
+#define RV3029_TRICKLE_1K		BIT(4) /* 1.5K resistance */
+#define RV3029_TRICKLE_5K		BIT(5) /* 5K   resistance */
+#define RV3029_TRICKLE_20K		BIT(6) /* 20K  resistance */
+#define RV3029_TRICKLE_80K		BIT(7) /* 80K  resistance */
+#define RV3029_TRICKLE_MASK		(RV3029_TRICKLE_1K |\
+					 RV3029_TRICKLE_5K |\
+					 RV3029_TRICKLE_20K |\
+					 RV3029_TRICKLE_80K)
+#define RV3029_TRICKLE_SHIFT		4
+#define RV3029_CONTROL_E2P_XOFFS	0x31 /* XTAL offset */
+#define RV3029_CONTROL_E2P_XOFFS_SIGN	BIT(7) /* Sign: 1->pos, 0->neg */
+#define RV3029_CONTROL_E2P_QCOEF	0x32 /* XTAL temp drift coef */
+#define RV3029_CONTROL_E2P_TURNOVER	0x33 /* XTAL turnover temp (in *C) */
+#define RV3029_CONTROL_E2P_TOV_MASK	0x3F /* XTAL turnover temp mask */
 
 /* user ram section */
-#define RV3029C2_USR1_RAM_PAGE		0x38
-#define RV3029C2_USR1_SECTION_LEN	0x04
-#define RV3029C2_USR2_RAM_PAGE		0x3C
-#define RV3029C2_USR2_SECTION_LEN	0x04
+#define RV3029_USR1_RAM_PAGE		0x38
+#define RV3029_USR1_SECTION_LEN		0x04
+#define RV3029_USR2_RAM_PAGE		0x3C
+#define RV3029_USR2_SECTION_LEN		0x04
+
+struct rv3029_data {
+	struct device		*dev;
+	struct rtc_device	*rtc;
+	struct regmap		*regmap;
+	int irq;
+};
 
-static int
-rv3029c2_i2c_read_regs(struct i2c_client *client, u8 reg, u8 *buf,
-	unsigned len)
+static int rv3029_read_regs(struct device *dev, u8 reg, u8 *buf,
+			    unsigned int len)
 {
-	int ret;
+	struct rv3029_data *rv3029 = dev_get_drvdata(dev);
 
-	if ((reg > RV3029C2_USR1_RAM_PAGE + 7) ||
-		(reg + len > RV3029C2_USR1_RAM_PAGE + 8))
+	if ((reg > RV3029_USR1_RAM_PAGE + 7) ||
+	    (reg + len > RV3029_USR1_RAM_PAGE + 8))
 		return -EINVAL;
 
-	ret = i2c_smbus_read_i2c_block_data(client, reg, len, buf);
-	if (ret < 0)
-		return ret;
-	if (ret < len)
-		return -EIO;
-	return 0;
+	return regmap_bulk_read(rv3029->regmap, reg, buf, len);
 }
 
-static int
-rv3029c2_i2c_write_regs(struct i2c_client *client, u8 reg, u8 const buf[],
-			unsigned len)
+static int rv3029_write_regs(struct device *dev, u8 reg, u8 const buf[],
+			     unsigned int len)
 {
-	if ((reg > RV3029C2_USR1_RAM_PAGE + 7) ||
-		(reg + len > RV3029C2_USR1_RAM_PAGE + 8))
+	struct rv3029_data *rv3029 = dev_get_drvdata(dev);
+
+	if ((reg > RV3029_USR1_RAM_PAGE + 7) ||
+	    (reg + len > RV3029_USR1_RAM_PAGE + 8))
 		return -EINVAL;
 
-	return i2c_smbus_write_i2c_block_data(client, reg, len, buf);
+	return regmap_bulk_write(rv3029->regmap, reg, buf, len);
 }
 
-static int
-rv3029c2_i2c_get_sr(struct i2c_client *client, u8 *buf)
+static int rv3029_update_bits(struct device *dev, u8 reg, u8 mask, u8 set)
 {
-	int ret = rv3029c2_i2c_read_regs(client, RV3029C2_STATUS, buf, 1);
+	u8 buf;
+	int ret;
+
+	ret = rv3029_read_regs(dev, reg, &buf, 1);
+	if (ret < 0)
+		return ret;
+	buf &= ~mask;
+	buf |= set & mask;
+	ret = rv3029_write_regs(dev, reg, &buf, 1);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int rv3029_get_sr(struct device *dev, u8 *buf)
+{
+	int ret = rv3029_read_regs(dev, RV3029_STATUS, buf, 1);
 
 	if (ret < 0)
 		return -EIO;
-	dev_dbg(&client->dev, "status = 0x%.2x (%d)\n", buf[0], buf[0]);
+	dev_dbg(dev, "status = 0x%.2x (%d)\n", buf[0], buf[0]);
 	return 0;
 }
 
-static int
-rv3029c2_i2c_set_sr(struct i2c_client *client, u8 val)
+static int rv3029_set_sr(struct device *dev, u8 val)
 {
 	u8 buf[1];
 	int sr;
 
 	buf[0] = val;
-	sr = rv3029c2_i2c_write_regs(client, RV3029C2_STATUS, buf, 1);
-	dev_dbg(&client->dev, "status = 0x%.2x (%d)\n", buf[0], buf[0]);
+	sr = rv3029_write_regs(dev, RV3029_STATUS, buf, 1);
+	dev_dbg(dev, "status = 0x%.2x (%d)\n", buf[0], buf[0]);
 	if (sr < 0)
 		return -EIO;
 	return 0;
 }
 
-static int
-rv3029c2_i2c_read_time(struct i2c_client *client, struct rtc_time *tm)
+static int rv3029_eeprom_busywait(struct device *dev)
 {
-	u8 buf[1];
+	int i, ret;
+	u8 sr;
+
+	for (i = 100; i > 0; i--) {
+		ret = rv3029_get_sr(dev, &sr);
+		if (ret < 0)
+			break;
+		if (!(sr & RV3029_STATUS_EEBUSY))
+			break;
+		usleep_range(1000, 10000);
+	}
+	if (i <= 0) {
+		dev_err(dev, "EEPROM busy wait timeout.\n");
+		return -ETIMEDOUT;
+	}
+
+	return ret;
+}
+
+static int rv3029_eeprom_exit(struct device *dev)
+{
+	/* Re-enable eeprom refresh */
+	return rv3029_update_bits(dev, RV3029_ONOFF_CTRL,
+				  RV3029_ONOFF_CTRL_EERE,
+				  RV3029_ONOFF_CTRL_EERE);
+}
+
+static int rv3029_eeprom_enter(struct device *dev)
+{
+	int ret;
+	u8 sr;
+
+	/* Check whether we are in the allowed voltage range. */
+	ret = rv3029_get_sr(dev, &sr);
+	if (ret < 0)
+		return ret;
+	if (sr & (RV3029_STATUS_VLOW1 | RV3029_STATUS_VLOW2)) {
+		/* We clear the bits and retry once just in case
+		 * we had a brown out in early startup.
+		 */
+		sr &= ~RV3029_STATUS_VLOW1;
+		sr &= ~RV3029_STATUS_VLOW2;
+		ret = rv3029_set_sr(dev, sr);
+		if (ret < 0)
+			return ret;
+		usleep_range(1000, 10000);
+		ret = rv3029_get_sr(dev, &sr);
+		if (ret < 0)
+			return ret;
+		if (sr & (RV3029_STATUS_VLOW1 | RV3029_STATUS_VLOW2)) {
+			dev_err(dev,
+				"Supply voltage is too low to safely access the EEPROM.\n");
+			return -ENODEV;
+		}
+	}
+
+	/* Disable eeprom refresh. */
+	ret = rv3029_update_bits(dev, RV3029_ONOFF_CTRL, RV3029_ONOFF_CTRL_EERE,
+				 0);
+	if (ret < 0)
+		return ret;
+
+	/* Wait for any previous eeprom accesses to finish. */
+	ret = rv3029_eeprom_busywait(dev);
+	if (ret < 0)
+		rv3029_eeprom_exit(dev);
+
+	return ret;
+}
+
+static int rv3029_eeprom_read(struct device *dev, u8 reg,
+			      u8 buf[], size_t len)
+{
+	int ret, err;
+
+	err = rv3029_eeprom_enter(dev);
+	if (err < 0)
+		return err;
+
+	ret = rv3029_read_regs(dev, reg, buf, len);
+
+	err = rv3029_eeprom_exit(dev);
+	if (err < 0)
+		return err;
+
+	return ret;
+}
+
+static int rv3029_eeprom_write(struct device *dev, u8 reg,
+			       u8 const buf[], size_t len)
+{
+	int ret, err;
+	size_t i;
+	u8 tmp;
+
+	err = rv3029_eeprom_enter(dev);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < len; i++, reg++) {
+		ret = rv3029_read_regs(dev, reg, &tmp, 1);
+		if (ret < 0)
+			break;
+		if (tmp != buf[i]) {
+			ret = rv3029_write_regs(dev, reg, &buf[i], 1);
+			if (ret < 0)
+				break;
+		}
+		ret = rv3029_eeprom_busywait(dev);
+		if (ret < 0)
+			break;
+	}
+
+	err = rv3029_eeprom_exit(dev);
+	if (err < 0)
+		return err;
+
+	return ret;
+}
+
+static int rv3029_eeprom_update_bits(struct device *dev,
+				     u8 reg, u8 mask, u8 set)
+{
+	u8 buf;
+	int ret;
+
+	ret = rv3029_eeprom_read(dev, reg, &buf, 1);
+	if (ret < 0)
+		return ret;
+	buf &= ~mask;
+	buf |= set & mask;
+	ret = rv3029_eeprom_write(dev, reg, &buf, 1);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static irqreturn_t rv3029_handle_irq(int irq, void *dev_id)
+{
+	struct device *dev = dev_id;
+	struct rv3029_data *rv3029 = dev_get_drvdata(dev);
+	struct mutex *lock = &rv3029->rtc->ops_lock;
+	unsigned long events = 0;
+	u8 flags, controls;
 	int ret;
-	u8 regs[RV3029C2_WATCH_SECTION_LEN] = { 0, };
 
-	ret = rv3029c2_i2c_get_sr(client, buf);
+	mutex_lock(lock);
+
+	ret = rv3029_read_regs(dev, RV3029_IRQ_CTRL, &controls, 1);
+	if (ret) {
+		dev_warn(dev, "Read IRQ Control Register error %d\n", ret);
+		mutex_unlock(lock);
+		return IRQ_NONE;
+	}
+
+	ret = rv3029_read_regs(dev, RV3029_IRQ_FLAGS, &flags, 1);
+	if (ret) {
+		dev_warn(dev, "Read IRQ Flags Register error %d\n", ret);
+		mutex_unlock(lock);
+		return IRQ_NONE;
+	}
+
+	if (flags & RV3029_IRQ_FLAGS_AF) {
+		flags &= ~RV3029_IRQ_FLAGS_AF;
+		controls &= ~RV3029_IRQ_CTRL_AIE;
+		events |= RTC_AF;
+	}
+
+	if (events) {
+		rtc_update_irq(rv3029->rtc, 1, events);
+		rv3029_write_regs(dev, RV3029_IRQ_FLAGS, &flags, 1);
+		rv3029_write_regs(dev, RV3029_IRQ_CTRL, &controls, 1);
+	}
+	mutex_unlock(lock);
+
+	return IRQ_HANDLED;
+}
+
+static int rv3029_read_time(struct device *dev, struct rtc_time *tm)
+{
+	u8 buf[1];
+	int ret;
+	u8 regs[RV3029_WATCH_SECTION_LEN] = { 0, };
+	ret = rv3029_get_sr(dev, buf);
 	if (ret < 0) {
-		dev_err(&client->dev, "%s: reading SR failed\n", __func__);
+		dev_err(dev, "%s: reading SR failed\n", __func__);
 		return -EIO;
 	}
 
-	ret = rv3029c2_i2c_read_regs(client, RV3029C2_W_SEC , regs,
-					RV3029C2_WATCH_SECTION_LEN);
+	ret = rv3029_read_regs(dev, RV3029_W_SEC, regs,
+			       RV3029_WATCH_SECTION_LEN);
 	if (ret < 0) {
-		dev_err(&client->dev, "%s: reading RTC section failed\n",
-			__func__);
+		dev_err(dev, "%s: reading RTC section failed\n", __func__);
 		return ret;
 	}
 
-	tm->tm_sec = bcd2bin(regs[RV3029C2_W_SEC-RV3029C2_W_SEC]);
-	tm->tm_min = bcd2bin(regs[RV3029C2_W_MINUTES-RV3029C2_W_SEC]);
+	tm->tm_sec = bcd2bin(regs[RV3029_W_SEC - RV3029_W_SEC]);
+	tm->tm_min = bcd2bin(regs[RV3029_W_MINUTES - RV3029_W_SEC]);
+
 
 	/* HR field has a more complex interpretation */
 	{
-		const u8 _hr = regs[RV3029C2_W_HOURS-RV3029C2_W_SEC];
-		if (_hr & RV3029C2_REG_HR_12_24) {
+		const u8 _hr = regs[RV3029_W_HOURS - RV3029_W_SEC];
+
+		if (_hr & RV3029_REG_HR_12_24) {
 			/* 12h format */
 			tm->tm_hour = bcd2bin(_hr & 0x1f);
-			if (_hr & RV3029C2_REG_HR_PM)	/* PM flag set */
+			if (_hr & RV3029_REG_HR_PM)	/* PM flag set */
 				tm->tm_hour += 12;
 		} else /* 24h format */
 			tm->tm_hour = bcd2bin(_hr & 0x3f);
 	}
 
-	tm->tm_mday = bcd2bin(regs[RV3029C2_W_DATE-RV3029C2_W_SEC]);
-	tm->tm_mon = bcd2bin(regs[RV3029C2_W_MONTHS-RV3029C2_W_SEC]) - 1;
-	tm->tm_year = bcd2bin(regs[RV3029C2_W_YEARS-RV3029C2_W_SEC]) + 100;
-	tm->tm_wday = bcd2bin(regs[RV3029C2_W_DAYS-RV3029C2_W_SEC]) - 1;
+	tm->tm_mday = bcd2bin(regs[RV3029_W_DATE - RV3029_W_SEC]);
+	tm->tm_mon = bcd2bin(regs[RV3029_W_MONTHS - RV3029_W_SEC]) - 1;
+	tm->tm_year = bcd2bin(regs[RV3029_W_YEARS - RV3029_W_SEC]) + 100;
+	tm->tm_wday = bcd2bin(regs[RV3029_W_DAYS - RV3029_W_SEC]) - 1;
 
 	return 0;
 }
 
-static int rv3029c2_rtc_read_time(struct device *dev, struct rtc_time *tm)
-{
-	return rv3029c2_i2c_read_time(to_i2c_client(dev), tm);
-}
-
-static int
-rv3029c2_i2c_read_alarm(struct i2c_client *client, struct rtc_wkalrm *alarm)
+static int rv3029_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
 	struct rtc_time *const tm = &alarm->time;
 	int ret;
-	u8 regs[8];
+	u8 regs[8], controls, flags;
 
-	ret = rv3029c2_i2c_get_sr(client, regs);
+	ret = rv3029_get_sr(dev, regs);
 	if (ret < 0) {
-		dev_err(&client->dev, "%s: reading SR failed\n", __func__);
+		dev_err(dev, "%s: reading SR failed\n", __func__);
 		return -EIO;
 	}
 
-	ret = rv3029c2_i2c_read_regs(client, RV3029C2_A_SC, regs,
-					RV3029C2_ALARM_SECTION_LEN);
+	ret = rv3029_read_regs(dev, RV3029_A_SC, regs,
+			       RV3029_ALARM_SECTION_LEN);
 
 	if (ret < 0) {
-		dev_err(&client->dev, "%s: reading alarm section failed\n",
-			__func__);
+		dev_err(dev, "%s: reading alarm section failed\n", __func__);
 		return ret;
 	}
 
-	tm->tm_sec = bcd2bin(regs[RV3029C2_A_SC-RV3029C2_A_SC] & 0x7f);
-	tm->tm_min = bcd2bin(regs[RV3029C2_A_MN-RV3029C2_A_SC] & 0x7f);
-	tm->tm_hour = bcd2bin(regs[RV3029C2_A_HR-RV3029C2_A_SC] & 0x3f);
-	tm->tm_mday = bcd2bin(regs[RV3029C2_A_DT-RV3029C2_A_SC] & 0x3f);
-	tm->tm_mon = bcd2bin(regs[RV3029C2_A_MO-RV3029C2_A_SC] & 0x1f) - 1;
-	tm->tm_year = bcd2bin(regs[RV3029C2_A_YR-RV3029C2_A_SC] & 0x7f) + 100;
-	tm->tm_wday = bcd2bin(regs[RV3029C2_A_DW-RV3029C2_A_SC] & 0x07) - 1;
+	ret = rv3029_read_regs(dev, RV3029_IRQ_CTRL, &controls, 1);
+	if (ret) {
+		dev_err(dev, "Read IRQ Control Register error %d\n", ret);
+		return ret;
+	}
+	ret = rv3029_read_regs(dev, RV3029_IRQ_FLAGS, &flags, 1);
+	if (ret < 0) {
+		dev_err(dev, "Read IRQ Flags Register error %d\n", ret);
+		return ret;
+	}
 
-	return 0;
-}
+	tm->tm_sec = bcd2bin(regs[RV3029_A_SC - RV3029_A_SC] & 0x7f);
+	tm->tm_min = bcd2bin(regs[RV3029_A_MN - RV3029_A_SC] & 0x7f);
+	tm->tm_hour = bcd2bin(regs[RV3029_A_HR - RV3029_A_SC] & 0x3f);
+	tm->tm_mday = bcd2bin(regs[RV3029_A_DT - RV3029_A_SC] & 0x3f);
+	tm->tm_mon = bcd2bin(regs[RV3029_A_MO - RV3029_A_SC] & 0x1f) - 1;
+	tm->tm_year = bcd2bin(regs[RV3029_A_YR - RV3029_A_SC] & 0x7f) + 100;
+	tm->tm_wday = bcd2bin(regs[RV3029_A_DW - RV3029_A_SC] & 0x07) - 1;
 
-static int
-rv3029c2_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
-{
-	return rv3029c2_i2c_read_alarm(to_i2c_client(dev), alarm);
+	alarm->enabled = !!(controls & RV3029_IRQ_CTRL_AIE);
+	alarm->pending = (flags & RV3029_IRQ_FLAGS_AF) && alarm->enabled;
+
+	return 0;
 }
 
-static int rv3029c2_rtc_i2c_alarm_set_irq(struct i2c_client *client,
-					int enable)
+static int rv3029_alarm_irq_enable(struct device *dev, unsigned int enable)
 {
 	int ret;
-	u8 buf[1];
+	u8 controls;
 
-	/* enable AIE irq */
-	ret = rv3029c2_i2c_read_regs(client, RV3029C2_IRQ_CTRL,	buf, 1);
+	ret = rv3029_read_regs(dev, RV3029_IRQ_CTRL, &controls, 1);
 	if (ret < 0) {
-		dev_err(&client->dev, "can't read INT reg\n");
+		dev_warn(dev, "Read IRQ Control Register error %d\n", ret);
 		return ret;
 	}
+
+	/* enable/disable AIE irq */
 	if (enable)
-		buf[0] |= RV3029C2_IRQ_CTRL_AIE;
+		controls |= RV3029_IRQ_CTRL_AIE;
 	else
-		buf[0] &= ~RV3029C2_IRQ_CTRL_AIE;
+		controls &= ~RV3029_IRQ_CTRL_AIE;
 
-	ret = rv3029c2_i2c_write_regs(client, RV3029C2_IRQ_CTRL, buf, 1);
+	ret = rv3029_write_regs(dev, RV3029_IRQ_CTRL, &controls, 1);
 	if (ret < 0) {
-		dev_err(&client->dev, "can't set INT reg\n");
+		dev_err(dev, "can't update INT reg\n");
 		return ret;
 	}
 
 	return 0;
 }
 
-static int rv3029c2_rtc_i2c_set_alarm(struct i2c_client *client,
-					struct rtc_wkalrm *alarm)
+static int rv3029_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 {
 	struct rtc_time *const tm = &alarm->time;
 	int ret;
@@ -267,66 +498,48 @@ static int rv3029c2_rtc_i2c_set_alarm(st
 	if (tm->tm_year < 100)
 		return -EINVAL;
 
-	ret = rv3029c2_i2c_get_sr(client, regs);
+	ret = rv3029_get_sr(dev, regs);
 	if (ret < 0) {
-		dev_err(&client->dev, "%s: reading SR failed\n", __func__);
+		dev_err(dev, "%s: reading SR failed\n", __func__);
 		return -EIO;
 	}
-	regs[RV3029C2_A_SC-RV3029C2_A_SC] = bin2bcd(tm->tm_sec & 0x7f);
-	regs[RV3029C2_A_MN-RV3029C2_A_SC] = bin2bcd(tm->tm_min & 0x7f);
-	regs[RV3029C2_A_HR-RV3029C2_A_SC] = bin2bcd(tm->tm_hour & 0x3f);
-	regs[RV3029C2_A_DT-RV3029C2_A_SC] = bin2bcd(tm->tm_mday & 0x3f);
-	regs[RV3029C2_A_MO-RV3029C2_A_SC] = bin2bcd((tm->tm_mon & 0x1f) - 1);
-	regs[RV3029C2_A_DW-RV3029C2_A_SC] = bin2bcd((tm->tm_wday & 7) - 1);
-	regs[RV3029C2_A_YR-RV3029C2_A_SC] = bin2bcd((tm->tm_year & 0x7f) - 100);
 
-	ret = rv3029c2_i2c_write_regs(client, RV3029C2_A_SC, regs,
-					RV3029C2_ALARM_SECTION_LEN);
+	/* Activate all the alarms with AE_x bit */
+	regs[RV3029_A_SC - RV3029_A_SC] = bin2bcd(tm->tm_sec) | RV3029_A_AE_X;
+	regs[RV3029_A_MN - RV3029_A_SC] = bin2bcd(tm->tm_min) | RV3029_A_AE_X;
+	regs[RV3029_A_HR - RV3029_A_SC] = (bin2bcd(tm->tm_hour) & 0x3f)
+		| RV3029_A_AE_X;
+	regs[RV3029_A_DT - RV3029_A_SC] = (bin2bcd(tm->tm_mday) & 0x3f)
+		| RV3029_A_AE_X;
+	regs[RV3029_A_MO - RV3029_A_SC] = (bin2bcd(tm->tm_mon + 1) & 0x1f)
+		| RV3029_A_AE_X;
+	regs[RV3029_A_DW - RV3029_A_SC] = (bin2bcd(tm->tm_wday + 1) & 0x7)
+		| RV3029_A_AE_X;
+	regs[RV3029_A_YR - RV3029_A_SC] = (bin2bcd(tm->tm_year - 100))
+		| RV3029_A_AE_X;
+
+	/* Write the alarm */
+	ret = rv3029_write_regs(dev, RV3029_A_SC, regs,
+				RV3029_ALARM_SECTION_LEN);
 	if (ret < 0)
 		return ret;
 
 	if (alarm->enabled) {
-		u8 buf[1];
-
-		/* clear AF flag */
-		ret = rv3029c2_i2c_read_regs(client, RV3029C2_IRQ_FLAGS,
-						buf, 1);
-		if (ret < 0) {
-			dev_err(&client->dev, "can't read alarm flag\n");
-			return ret;
-		}
-		buf[0] &= ~RV3029C2_IRQ_FLAGS_AF;
-		ret = rv3029c2_i2c_write_regs(client, RV3029C2_IRQ_FLAGS,
-						buf, 1);
-		if (ret < 0) {
-			dev_err(&client->dev, "can't set alarm flag\n");
-			return ret;
-		}
 		/* enable AIE irq */
-		ret = rv3029c2_rtc_i2c_alarm_set_irq(client, 1);
+		ret = rv3029_alarm_irq_enable(dev, 1);
 		if (ret)
 			return ret;
-
-		dev_dbg(&client->dev, "alarm IRQ armed\n");
 	} else {
 		/* disable AIE irq */
-		ret = rv3029c2_rtc_i2c_alarm_set_irq(client, 0);
+		ret = rv3029_alarm_irq_enable(dev, 0);
 		if (ret)
 			return ret;
-
-		dev_dbg(&client->dev, "alarm IRQ disabled\n");
 	}
 
 	return 0;
 }
 
-static int rv3029c2_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
-{
-	return rv3029c2_rtc_i2c_set_alarm(to_i2c_client(dev), alarm);
-}
-
-static int
-rv3029c2_i2c_set_time(struct i2c_client *client, struct rtc_time const *tm)
+static int rv3029_set_time(struct device *dev, struct rtc_time *tm)
 {
 	u8 regs[8];
 	int ret;
@@ -339,89 +552,439 @@ rv3029c2_i2c_set_time(struct i2c_client
 	if (tm->tm_year < 100)
 		return -EINVAL;
 
-	regs[RV3029C2_W_SEC-RV3029C2_W_SEC] = bin2bcd(tm->tm_sec);
-	regs[RV3029C2_W_MINUTES-RV3029C2_W_SEC] = bin2bcd(tm->tm_min);
-	regs[RV3029C2_W_HOURS-RV3029C2_W_SEC] = bin2bcd(tm->tm_hour);
-	regs[RV3029C2_W_DATE-RV3029C2_W_SEC] = bin2bcd(tm->tm_mday);
-	regs[RV3029C2_W_MONTHS-RV3029C2_W_SEC] = bin2bcd(tm->tm_mon+1);
-	regs[RV3029C2_W_DAYS-RV3029C2_W_SEC] = bin2bcd((tm->tm_wday & 7)+1);
-	regs[RV3029C2_W_YEARS-RV3029C2_W_SEC] = bin2bcd(tm->tm_year - 100);
+	regs[RV3029_W_SEC - RV3029_W_SEC] = bin2bcd(tm->tm_sec);
+	regs[RV3029_W_MINUTES - RV3029_W_SEC] = bin2bcd(tm->tm_min);
+	regs[RV3029_W_HOURS - RV3029_W_SEC] = bin2bcd(tm->tm_hour);
+	regs[RV3029_W_DATE - RV3029_W_SEC] = bin2bcd(tm->tm_mday);
+	regs[RV3029_W_MONTHS - RV3029_W_SEC] = bin2bcd(tm->tm_mon + 1);
+	regs[RV3029_W_DAYS - RV3029_W_SEC] = bin2bcd(tm->tm_wday + 1) & 0x7;
+	regs[RV3029_W_YEARS - RV3029_W_SEC] = bin2bcd(tm->tm_year - 100);
 
-	ret = rv3029c2_i2c_write_regs(client, RV3029C2_W_SEC, regs,
-					RV3029C2_WATCH_SECTION_LEN);
+	ret = rv3029_write_regs(dev, RV3029_W_SEC, regs,
+				RV3029_WATCH_SECTION_LEN);
 	if (ret < 0)
 		return ret;
 
-	ret = rv3029c2_i2c_get_sr(client, regs);
+	ret = rv3029_get_sr(dev, regs);
 	if (ret < 0) {
-		dev_err(&client->dev, "%s: reading SR failed\n", __func__);
+		dev_err(dev, "%s: reading SR failed\n", __func__);
 		return ret;
 	}
 	/* clear PON bit */
-	ret = rv3029c2_i2c_set_sr(client, (regs[0] & ~RV3029C2_STATUS_PON));
+	ret = rv3029_set_sr(dev, (regs[0] & ~RV3029_STATUS_PON));
 	if (ret < 0) {
-		dev_err(&client->dev, "%s: reading SR failed\n", __func__);
+		dev_err(dev, "%s: reading SR failed\n", __func__);
 		return ret;
 	}
 
 	return 0;
 }
 
-static int rv3029c2_rtc_set_time(struct device *dev, struct rtc_time *tm)
+static const struct rv3029_trickle_tab_elem {
+	u32 r;		/* resistance in ohms */
+	u8 conf;	/* trickle config bits */
+} rv3029_trickle_tab[] = {
+	{
+		.r	= 1076,
+		.conf	= RV3029_TRICKLE_1K | RV3029_TRICKLE_5K |
+			  RV3029_TRICKLE_20K | RV3029_TRICKLE_80K,
+	}, {
+		.r	= 1091,
+		.conf	= RV3029_TRICKLE_1K | RV3029_TRICKLE_5K |
+			  RV3029_TRICKLE_20K,
+	}, {
+		.r	= 1137,
+		.conf	= RV3029_TRICKLE_1K | RV3029_TRICKLE_5K |
+			  RV3029_TRICKLE_80K,
+	}, {
+		.r	= 1154,
+		.conf	= RV3029_TRICKLE_1K | RV3029_TRICKLE_5K,
+	}, {
+		.r	= 1371,
+		.conf	= RV3029_TRICKLE_1K | RV3029_TRICKLE_20K |
+			  RV3029_TRICKLE_80K,
+	}, {
+		.r	= 1395,
+		.conf	= RV3029_TRICKLE_1K | RV3029_TRICKLE_20K,
+	}, {
+		.r	= 1472,
+		.conf	= RV3029_TRICKLE_1K | RV3029_TRICKLE_80K,
+	}, {
+		.r	= 1500,
+		.conf	= RV3029_TRICKLE_1K,
+	}, {
+		.r	= 3810,
+		.conf	= RV3029_TRICKLE_5K | RV3029_TRICKLE_20K |
+			  RV3029_TRICKLE_80K,
+	}, {
+		.r	= 4000,
+		.conf	= RV3029_TRICKLE_5K | RV3029_TRICKLE_20K,
+	}, {
+		.r	= 4706,
+		.conf	= RV3029_TRICKLE_5K | RV3029_TRICKLE_80K,
+	}, {
+		.r	= 5000,
+		.conf	= RV3029_TRICKLE_5K,
+	}, {
+		.r	= 16000,
+		.conf	= RV3029_TRICKLE_20K | RV3029_TRICKLE_80K,
+	}, {
+		.r	= 20000,
+		.conf	= RV3029_TRICKLE_20K,
+	}, {
+		.r	= 80000,
+		.conf	= RV3029_TRICKLE_80K,
+	},
+};
+
+static void rv3029_trickle_config(struct device *dev)
+{
+	struct device_node *of_node = dev->of_node;
+	const struct rv3029_trickle_tab_elem *elem;
+	int i, err;
+	u32 ohms;
+	u8 trickle_set_bits;
+
+	if (!of_node)
+		return;
+
+	/* Configure the trickle charger. */
+	err = of_property_read_u32(of_node, "trickle-resistor-ohms", &ohms);
+	if (err) {
+		/* Disable trickle charger. */
+		trickle_set_bits = 0;
+	} else {
+		/* Enable trickle charger. */
+		for (i = 0; i < ARRAY_SIZE(rv3029_trickle_tab); i++) {
+			elem = &rv3029_trickle_tab[i];
+			if (elem->r >= ohms)
+				break;
+		}
+		trickle_set_bits = elem->conf;
+		dev_info(dev,
+			 "Trickle charger enabled at %d ohms resistance.\n",
+			 elem->r);
+	}
+	err = rv3029_eeprom_update_bits(dev, RV3029_CONTROL_E2P_EECTRL,
+					RV3029_TRICKLE_MASK,
+					trickle_set_bits);
+	if (err < 0)
+		dev_err(dev, "Failed to update trickle charger config\n");
+}
+
+#ifdef CONFIG_RTC_DRV_RV3029_HWMON
+
+static int rv3029_read_temp(struct device *dev, int *temp_mC)
+{
+	int ret;
+	u8 temp;
+
+	ret = rv3029_read_regs(dev, RV3029_TEMP_PAGE, &temp, 1);
+	if (ret < 0)
+		return ret;
+
+	*temp_mC = ((int)temp - 60) * 1000;
+
+	return 0;
+}
+
+static ssize_t rv3029_hwmon_show_temp(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
 {
-	return rv3029c2_i2c_set_time(to_i2c_client(dev), tm);
+	int ret, temp_mC;
+
+	ret = rv3029_read_temp(dev, &temp_mC);
+	if (ret < 0)
+		return ret;
+
+	return sprintf(buf, "%d\n", temp_mC);
 }
 
-static const struct rtc_class_ops rv3029c2_rtc_ops = {
-	.read_time	= rv3029c2_rtc_read_time,
-	.set_time	= rv3029c2_rtc_set_time,
-	.read_alarm	= rv3029c2_rtc_read_alarm,
-	.set_alarm	= rv3029c2_rtc_set_alarm,
+static ssize_t rv3029_hwmon_set_update_interval(struct device *dev,
+						struct device_attribute *attr,
+						const char *buf,
+						size_t count)
+{
+	unsigned long interval_ms;
+	int ret;
+	u8 th_set_bits = 0;
+
+	ret = kstrtoul(buf, 10, &interval_ms);
+	if (ret < 0)
+		return ret;
+
+	if (interval_ms != 0) {
+		th_set_bits |= RV3029_EECTRL_THE;
+		if (interval_ms >= 16000)
+			th_set_bits |= RV3029_EECTRL_THP;
+	}
+	ret = rv3029_eeprom_update_bits(dev, RV3029_CONTROL_E2P_EECTRL,
+					RV3029_EECTRL_THE | RV3029_EECTRL_THP,
+					th_set_bits);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t rv3029_hwmon_show_update_interval(struct device *dev,
+						 struct device_attribute *attr,
+						 char *buf)
+{
+	int ret, interval_ms;
+	u8 eectrl;
+
+	ret = rv3029_eeprom_read(dev, RV3029_CONTROL_E2P_EECTRL,
+				 &eectrl, 1);
+	if (ret < 0)
+		return ret;
+
+	if (eectrl & RV3029_EECTRL_THE) {
+		if (eectrl & RV3029_EECTRL_THP)
+			interval_ms = 16000;
+		else
+			interval_ms = 1000;
+	} else {
+		interval_ms = 0;
+	}
+
+	return sprintf(buf, "%d\n", interval_ms);
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, rv3029_hwmon_show_temp,
+			  NULL, 0);
+static SENSOR_DEVICE_ATTR(update_interval, S_IWUSR | S_IRUGO,
+			  rv3029_hwmon_show_update_interval,
+			  rv3029_hwmon_set_update_interval, 0);
+
+static struct attribute *rv3029_hwmon_attrs[] = {
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_update_interval.dev_attr.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(rv3029_hwmon);
 
-static struct i2c_device_id rv3029c2_id[] = {
-	{ "rv3029c2", 0 },
-	{ }
+static void rv3029_hwmon_register(struct device *dev, const char *name)
+{
+	struct rv3029_data *rv3029 = dev_get_drvdata(dev);
+	struct device *hwmon_dev;
+
+	hwmon_dev = devm_hwmon_device_register_with_groups(dev, name, rv3029,
+							   rv3029_hwmon_groups);
+	if (IS_ERR(hwmon_dev)) {
+		dev_warn(dev, "unable to register hwmon device %ld\n",
+			 PTR_ERR(hwmon_dev));
+	}
+}
+
+#else /* CONFIG_RTC_DRV_RV3029_HWMON */
+
+static void rv3029_hwmon_register(struct device *dev, const char *name)
+{
+}
+
+#endif /* CONFIG_RTC_DRV_RV3029_HWMON */
+
+static struct rtc_class_ops rv3029_rtc_ops = {
+	.read_time	= rv3029_read_time,
+	.set_time	= rv3029_set_time,
 };
-MODULE_DEVICE_TABLE(i2c, rv3029c2_id);
 
-static int rv3029c2_probe(struct i2c_client *client,
-			  const struct i2c_device_id *id)
+static int rv3029_probe(struct device *dev, struct regmap *regmap, int irq,
+			const char *name)
 {
-	struct rtc_device *rtc;
+	struct rv3029_data *rv3029;
 	int rc = 0;
 	u8 buf[1];
 
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_EMUL))
-		return -ENODEV;
+	rv3029 = devm_kzalloc(dev, sizeof(*rv3029), GFP_KERNEL);
+	if (!rv3029)
+		return -ENOMEM;
+
+	rv3029->regmap = regmap;
+	rv3029->irq = irq;
+	rv3029->dev = dev;
+	dev_set_drvdata(dev, rv3029);
 
-	rc = rv3029c2_i2c_get_sr(client, buf);
+	rc = rv3029_get_sr(dev, buf);
 	if (rc < 0) {
-		dev_err(&client->dev, "reading status failed\n");
+		dev_err(dev, "reading status failed\n");
 		return rc;
 	}
 
-	rtc = devm_rtc_device_register(&client->dev, client->name,
-					&rv3029c2_rtc_ops, THIS_MODULE);
-
-	if (IS_ERR(rtc))
-		return PTR_ERR(rtc);
+	rv3029_trickle_config(dev);
+	rv3029_hwmon_register(dev, name);
 
-	i2c_set_clientdata(client, rtc);
+	rv3029->rtc = devm_rtc_device_register(dev, name, &rv3029_rtc_ops,
+					       THIS_MODULE);
+	if (IS_ERR(rv3029->rtc)) {
+		dev_err(dev, "unable to register the class device\n");
+		return PTR_ERR(rv3029->rtc);
+	}
+
+	if (rv3029->irq > 0) {
+		rc = devm_request_threaded_irq(dev, rv3029->irq,
+					       NULL, rv3029_handle_irq,
+					       IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+					       "rv3029", dev);
+		if (rc) {
+			dev_warn(dev, "unable to request IRQ, alarms disabled\n");
+			rv3029->irq = 0;
+		} else {
+			rv3029_rtc_ops.read_alarm = rv3029_read_alarm;
+			rv3029_rtc_ops.set_alarm = rv3029_set_alarm;
+			rv3029_rtc_ops.alarm_irq_enable = rv3029_alarm_irq_enable;
+		}
+	}
 
 	return 0;
 }
 
-static struct i2c_driver rv3029c2_driver = {
+#if IS_ENABLED(CONFIG_I2C)
+
+static int rv3029_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct regmap *regmap;
+	static const struct regmap_config config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK |
+				     I2C_FUNC_SMBUS_BYTE)) {
+		dev_err(&client->dev, "Adapter does not support SMBUS_I2C_BLOCK or SMBUS_I2C_BYTE\n");
+		return -ENODEV;
+	}
+
+	regmap = devm_regmap_init_i2c(client, &config);
+	if (IS_ERR(regmap)) {
+		dev_err(&client->dev, "%s: regmap allocation failed: %ld\n",
+			__func__, PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+
+	return rv3029_probe(&client->dev, regmap, client->irq, client->name);
+}
+
+static struct i2c_device_id rv3029_id[] = {
+	{ "rv3029", 0 },
+	{ "rv3029c2", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, rv3029_id);
+
+static struct i2c_driver rv3029_driver = {
 	.driver = {
 		.name = "rtc-rv3029c2",
 	},
-	.probe = rv3029c2_probe,
-	.id_table = rv3029c2_id,
+	.probe		= rv3029_i2c_probe,
+	.id_table	= rv3029_id,
 };
 
-module_i2c_driver(rv3029c2_driver);
+static int rv3029_register_driver(void)
+{
+	return i2c_add_driver(&rv3029_driver);
+}
+
+static void rv3029_unregister_driver(void)
+{
+	i2c_del_driver(&rv3029_driver);
+}
+
+#else
+
+static int rv3029_register_driver(void)
+{
+	return 0;
+}
+
+static void rv3029_unregister_driver(void)
+{
+}
+
+#endif
+
+#if IS_ENABLED(CONFIG_SPI_MASTER)
+
+static int rv3049_probe(struct spi_device *spi)
+{
+	static const struct regmap_config config = {
+		.reg_bits = 8,
+		.val_bits = 8,
+	};
+	struct regmap *regmap;
+
+	regmap = devm_regmap_init_spi(spi, &config);
+	if (IS_ERR(regmap)) {
+		dev_err(&spi->dev, "%s: regmap allocation failed: %ld\n",
+			__func__, PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+
+	return rv3029_probe(&spi->dev, regmap, spi->irq, "rv3049");
+}
+
+static struct spi_driver rv3049_driver = {
+	.driver = {
+		.name    = "rv3049",
+	},
+	.probe   = rv3049_probe,
+};
+
+static int rv3049_register_driver(void)
+{
+	return spi_register_driver(&rv3049_driver);
+}
+
+static void rv3049_unregister_driver(void)
+{
+	spi_unregister_driver(&rv3049_driver);
+}
+
+#else
+
+static int rv3049_register_driver(void)
+{
+	return 0;
+}
+
+static void rv3049_unregister_driver(void)
+{
+}
+
+#endif
+
+static int __init rv30x9_init(void)
+{
+	int ret;
+
+	ret = rv3029_register_driver();
+	if (ret) {
+		pr_err("Failed to register rv3029 driver: %d\n", ret);
+		return ret;
+	}
+
+	ret = rv3049_register_driver();
+	if (ret) {
+		pr_err("Failed to register rv3049 driver: %d\n", ret);
+		rv3029_unregister_driver();
+	}
+
+	return ret;
+}
+module_init(rv30x9_init)
+
+static void __exit rv30x9_exit(void)
+{
+	rv3049_unregister_driver();
+	rv3029_unregister_driver();
+}
+module_exit(rv30x9_exit)
 
 MODULE_AUTHOR("Gregory Hermant <gregory.hermant@calao-systems.com>");
-MODULE_DESCRIPTION("Micro Crystal RV3029C2 RTC driver");
+MODULE_AUTHOR("Michael Buesch <m@bues.ch>");
+MODULE_DESCRIPTION("Micro Crystal RV3029/RV3049 RTC driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("spi:rv3049");
diff -rupN linux-4.1.8.ori/drivers/spi/Kconfig linux-4.1.8.mod/drivers/spi/Kconfig
--- linux-4.1.8.ori/drivers/spi/Kconfig	2018-02-20 13:41:55.117453029 +0000
+++ linux-4.1.8.mod/drivers/spi/Kconfig	2018-02-20 11:27:11.228408325 +0000
@@ -638,6 +638,11 @@ config SPI_DW_MMIO
 	tristate "Memory-mapped io interface driver for DW SPI core"
 	depends on SPI_DESIGNWARE
 
+config PLD_PTIN_SPI
+        tristate "Driver for ptin pld"
+        depends on SPI_SPIDEV
+	default y if SPI_SPIDEV
+
 #
 # There are lots of SPI device types, with sensors and memory
 # being probably the most widely used ones.
diff -rupN linux-4.1.8.ori/drivers/spi/Makefile linux-4.1.8.mod/drivers/spi/Makefile
--- linux-4.1.8.ori/drivers/spi/Makefile	2018-02-20 13:41:55.117453029 +0000
+++ linux-4.1.8.mod/drivers/spi/Makefile	2018-02-20 11:27:11.232408315 +0000
@@ -89,3 +89,5 @@ obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
 obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
 obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
+obj-$(CONFIG_PLD_PTIN_SPI)              += pld-ptin-spi.o
+
diff -rupN linux-4.1.8.ori/drivers/spi/pld-ptin-spi.c linux-4.1.8.mod/drivers/spi/pld-ptin-spi.c
--- linux-4.1.8.ori/drivers/spi/pld-ptin-spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8.mod/drivers/spi/pld-ptin-spi.c	2018-02-20 11:27:11.230408320 +0000
@@ -0,0 +1,138 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+/*QorIQ-SDK2.0.mod/drivers/spi/pld-ptin-spi.c*/
+
+static struct spi_device *spi_device_0;
+static struct spi_device *spi_device_1;
+static struct spi_device *spi_device_2;
+static struct spi_device *spi_device_3;
+
+static int __init spi_init(void) {
+    int ret;
+    struct spi_master *master;
+
+       //printk("JAIME_DBG: spi_init\n");
+
+    //Register information about your slave device:
+       struct spi_board_info spi_device_info_0 = {                     //CPLD
+        .modalias = "spidev",
+        .max_speed_hz = 40000000, //speed your device (slave) can handle
+        .bus_num = 1,
+        .chip_select = 0,
+        .mode = 0,
+    };
+       struct spi_board_info spi_device_info_1 = {                     //FPGA
+        .modalias = "spidev",
+        .max_speed_hz = 40000000, //speed your device (slave) can handle
+        .bus_num = 1,
+        .chip_select = 1,
+        .mode = 0,
+    };
+       struct spi_board_info spi_device_info_2 = {                     //ZL30363
+        .modalias = "spidev",
+        .max_speed_hz = 40000000, //speed your device (slave) can handle
+        .bus_num = 1,
+        .chip_select = 2,
+        .mode = 0,
+    };
+    struct spi_board_info spi_device_info_3 = {                        //LIU-DS21348
+        .modalias = "spidev",
+        .max_speed_hz = 40000000, //speed your device (slave) can handle
+        .bus_num = 1,
+        .chip_select = 3,
+        .mode = 0,
+    };
+
+    /*To send data we have to know what spi port/pins should be used. This information
+      can be found in the device-tree. */
+    master = spi_busnum_to_master( spi_device_info_0.bus_num );
+    if( !master ){
+        printk("MASTER not found.\n");
+            return -ENODEV;
+    }
+
+    // create a new slave device, given the master and device info
+    spi_device_0 = spi_new_device( master, &spi_device_info_0);
+    if( !spi_device_0 ) {
+        printk("FAILED to create slave device 0.\n");
+        //return -ENODEV;
+    }
+
+       // create a new slave device, given the master and device info
+    spi_device_1 = spi_new_device( master, &spi_device_info_1);
+    if( !spi_device_1 ) {
+        printk("FAILED to create slave device 1.\n");
+        //return -ENODEV;
+    }
+
+       // create a new slave device, given the master and device info
+    spi_device_2 = spi_new_device( master, &spi_device_info_2);
+    if( !spi_device_2 ) {
+        printk("FAILED to create slave device 2.\n");
+        //return -ENODEV;
+    }
+
+       // create a new slave device, given the master and device info
+    spi_device_3 = spi_new_device( master, &spi_device_info_3);
+    if( !spi_device_3 ) {
+        printk("FAILED to create slave device 3.\n");
+        //return -ENODEV;
+    }
+
+    spi_device_0->bits_per_word = 8;
+       spi_device_1->bits_per_word = 8;
+       spi_device_2->bits_per_word = 8;
+       spi_device_3->bits_per_word = 8;
+
+    ret = spi_setup( spi_device_0 );
+    if( ret ){
+        printk("FAILED to setup slave 0.\n");
+        spi_unregister_device( spi_device_0 );
+        //return -ENODEV;
+    }
+       ret = spi_setup( spi_device_1 );
+    if( ret ){
+        printk("FAILED to setup slave 1.\n");
+        spi_unregister_device( spi_device_1 );
+        //return -ENODEV;
+    }
+       ret = spi_setup( spi_device_2 );
+    if( ret ){
+        printk("FAILED to setup slave 2.\n");
+        spi_unregister_device( spi_device_2 );
+        //return -ENODEV;
+    }
+       ret = spi_setup( spi_device_3 );
+    if( ret ){
+        printk("FAILED to setup slave 3.\n");
+        spi_unregister_device( spi_device_3 );
+        //return -ENODEV;
+    }
+    return 0;
+}
+
+
+static void __exit spi_exit(void)
+{
+    if( spi_device_0 ){
+        spi_unregister_device( spi_device_0 );
+    }
+       if( spi_device_1 ){
+        spi_unregister_device( spi_device_1 );
+    }
+       if( spi_device_2 ){
+        spi_unregister_device( spi_device_2 );
+    }
+       if( spi_device_3 ){
+        spi_unregister_device( spi_device_3 );
+    }
+}
+
+module_init(spi_init);
+module_exit(spi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sergio Marques <email protected>");
+MODULE_DESCRIPTION("PTIN SPI module");
diff -rupN linux-4.1.8.ori/drivers/spi/spi-fsl-espi.c linux-4.1.8.mod/drivers/spi/spi-fsl-espi.c
--- linux-4.1.8.ori/drivers/spi/spi-fsl-espi.c	2018-02-20 13:41:55.118453025 +0000
+++ linux-4.1.8.mod/drivers/spi/spi-fsl-espi.c	2018-02-20 11:27:11.233408312 +0000
@@ -377,9 +377,15 @@ static void fsl_espi_rw_trans(struct spi
 	fsl_espi_do_trans(m, espi_trans);
 
 	/* If there is at least one RX byte then copy it to rx_buf */
-	if (tx_only < SPCOM_TRANLEN_MAX)
+	if (tx_only < SPCOM_TRANLEN_MAX) {
+#if 1
 		memcpy(rx_buf, espi_trans->rx_buf + tx_only,
 				trans_len - tx_only);
+#else
+		memcpy(rx_buf, espi_trans->rx_buf + tx_only + 1,
+                                trans_len - tx_only - 1);
+#endif
+	}
 
 	espi_trans->actual_length += espi_trans->len;
 
@@ -406,10 +412,13 @@ static int fsl_espi_do_one_msg(struct sp
 		if ((t->tx_buf) || (t->rx_buf))
 			xfer_len += t->len;
 	}
-
 	espi_trans.n_tx = n_tx;
 	espi_trans.n_rx = n_rx;
+#if 1
 	espi_trans.len = xfer_len;
+#else
+	espi_trans.len = n_tx+n_rx;
+#endif
 	espi_trans.actual_length = 0;
 	espi_trans.status = 0;
 
diff -rupN linux-4.1.8.ori/net/dsa/mv88e6xxx.h linux-4.1.8.mod/net/dsa/mv88e6xxx.h
--- linux-4.1.8.ori/net/dsa/mv88e6xxx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-4.1.8.mod/net/dsa/mv88e6xxx.h	2018-02-20 11:27:10.026411443 +0000
@@ -0,0 +1,95 @@
+/*
+ * net/dsa/mv88e6xxx.h - Marvell 88e6xxx switch chip support
+ * Copyright (c) 2008 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __MV88E6XXX_H
+#define __MV88E6XXX_H
+
+#define REG_PORT(p)            (0x10 + (p))
+#define REG_GLOBAL             0x1b
+#define REG_GLOBAL2            0x1c
+
+struct mv88e6xxx_priv_state {
+       /*
+        * When using multi-chip addressing, this mutex protects
+        * access to the indirect access registers.  (In single-chip
+        * mode, this mutex is effectively useless.)
+        */
+       struct mutex    smi_mutex;
+
+#ifdef CONFIG_NET_DSA_MV88E6XXX_NEED_PPU
+       /*
+        * Handles automatic disabling and re-enabling of the PHY
+        * polling unit.
+        */
+       struct mutex            ppu_mutex;
+       int                     ppu_disabled;
+       struct work_struct      ppu_work;
+       struct timer_list       ppu_timer;
+#endif
+
+       /*
+        * This mutex serialises access to the statistics unit.
+        * Hold this mutex over snapshot + dump sequences.
+        */
+       struct mutex    stats_mutex;
+
+       int             id; /* switch product id */
+};
+
+struct mv88e6xxx_hw_stat {
+       char string[ETH_GSTRING_LEN];
+       int sizeof_stat;
+       int reg;
+};
+
+int __mv88e6xxx_reg_read(struct mii_bus *bus, int sw_addr, int addr, int reg);
+int mv88e6xxx_reg_read(struct dsa_switch *ds, int addr, int reg);
+int __mv88e6xxx_reg_write(struct mii_bus *bus, int sw_addr, int addr,
+                          int reg, u16 val);
+int mv88e6xxx_reg_write(struct dsa_switch *ds, int addr, int reg, u16 val);
+int mv88e6xxx_config_prio(struct dsa_switch *ds);
+int mv88e6xxx_set_addr_direct(struct dsa_switch *ds, u8 *addr);
+int mv88e6xxx_set_addr_indirect(struct dsa_switch *ds, u8 *addr);
+int mv88e6xxx_phy_read(struct dsa_switch *ds, int addr, int regnum);
+int mv88e6xxx_phy_write(struct dsa_switch *ds, int addr, int regnum, u16 val);
+void mv88e6xxx_ppu_state_init(struct dsa_switch *ds);
+int mv88e6xxx_phy_read_ppu(struct dsa_switch *ds, int addr, int regnum);
+int mv88e6xxx_phy_write_ppu(struct dsa_switch *ds, int addr,
+                           int regnum, u16 val);
+void mv88e6xxx_poll_link(struct dsa_switch *ds);
+void mv88e6xxx_get_strings(struct dsa_switch *ds,
+                          int nr_stats, struct mv88e6xxx_hw_stat *stats,
+                          int port, uint8_t *data);
+void mv88e6xxx_get_ethtool_stats(struct dsa_switch *ds,
+                                int nr_stats, struct mv88e6xxx_hw_stat *stats,
+                                int port, uint64_t *data);
+
+#define REG_READ(addr, reg)                                            \
+       ({                                                              \
+               int __ret;                                              \
+                                                                       \
+               __ret = mv88e6xxx_reg_read(ds, addr, reg);              \
+               if (__ret < 0)                                          \
+                       return __ret;                                   \
+               __ret;                                                  \
+       })
+
+#define REG_WRITE(addr, reg, val)                                      \
+       ({                                                              \
+               int __ret;                                              \
+                                                                       \
+               __ret = mv88e6xxx_reg_write(ds, addr, reg, val);        \
+               if (__ret < 0)                                          \
+                       return __ret;                                   \
+       })
+
+
+
+#endif
