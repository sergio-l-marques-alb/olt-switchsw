diff -rupN linux-denx-3.18.25-ori/arch/powerpc/kernel/prom.c linux-denx-3.18.25-mod/arch/powerpc/kernel/prom.c
--- linux-denx-3.18.25-ori/arch/powerpc/kernel/prom.c	2016-11-17 13:38:47.000000000 +0000
+++ linux-denx-3.18.25-mod/arch/powerpc/kernel/prom.c	2016-11-23 15:15:03.000000000 +0000
@@ -642,6 +642,11 @@ void __init early_init_devtree(void *par
 
 	DBG(" -> early_init_devtree(%p)\n", params);
 
+	//Para que este kernel possa ser lançado via uboot-1.3.0
+        initrd_start=(unsigned long) *((unsigned long *)((unsigned char *)params+0x167C));
+        initrd_end  =(unsigned long) *((unsigned long *)((unsigned char *)params+0x168C));
+        DBG("%s initrd ----> %08lX %08lX\n", __FUNCTION__, initrd_start, initrd_end);
+
 	/* Too early to BUG_ON(), do it by hand */
 	if (!early_init_dt_verify(params))
 		panic("BUG: Failed verifying flat device tree, bad version?");
@@ -706,7 +711,7 @@ void __init early_init_devtree(void *par
 	memblock_allow_resize();
 	memblock_dump_all();
 
-	DBG("Phys. mem: %llx\n", memblock_phys_mem_size());
+	DBG("Phys. mem: %llx\n", (long long unsigned int) memblock_phys_mem_size());
 
 	/* We may need to relocate the flat tree, do it now.
 	 * FIXME .. and the initrd too? */
diff -rupN linux-denx-3.18.25-ori/arch/powerpc/sysdev/Kconfig linux-denx-3.18.25-mod/arch/powerpc/sysdev/Kconfig
--- linux-denx-3.18.25-ori/arch/powerpc/sysdev/Kconfig	2016-11-17 13:38:47.000000000 +0000
+++ linux-denx-3.18.25-mod/arch/powerpc/sysdev/Kconfig	2016-11-23 13:17:20.000000000 +0000
@@ -40,3 +40,8 @@ config SCOM_DEBUGFS
 config GE_FPGA
 	bool
 	default n
+
+config PTIN_ETH_MARVELL_SWITCH
+	bool
+	default y
+
diff -rupN linux-denx-3.18.25-ori/arch/powerpc/sysdev/Makefile linux-denx-3.18.25-mod/arch/powerpc/sysdev/Makefile
--- linux-denx-3.18.25-ori/arch/powerpc/sysdev/Makefile	2016-11-17 13:38:47.000000000 +0000
+++ linux-denx-3.18.25-mod/arch/powerpc/sysdev/Makefile	2016-11-23 13:17:20.000000000 +0000
@@ -60,6 +60,8 @@ obj-$(CONFIG_UCODE_PATCH)	+= micropatch.
 obj-$(CONFIG_PPC_MPC512x)	+= mpc5xxx_clocks.o
 obj-$(CONFIG_PPC_MPC52xx)	+= mpc5xxx_clocks.o
 
+obj-$(CONFIG_PTIN_ETH_MARVELL_SWITCH)   += mv88e6095x_of.o
+
 ifeq ($(CONFIG_SUSPEND),y)
 obj-$(CONFIG_6xx)		+= 6xx-suspend.o
 endif
diff -rupN linux-denx-3.18.25-ori/arch/powerpc/sysdev/mv88e6095x_of.c linux-denx-3.18.25-mod/arch/powerpc/sysdev/mv88e6095x_of.c
--- linux-denx-3.18.25-ori/arch/powerpc/sysdev/mv88e6095x_of.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-denx-3.18.25-mod/arch/powerpc/sysdev/mv88e6095x_of.c	2016-11-23 13:17:20.000000000 +0000
@@ -0,0 +1,128 @@
+/*
+ * net/dsa/mv88e6095.c - Marvell 88e6095/6095f/6131 switch chip support
+ * Copyright (c) 2008-2009 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/of.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+/*#include <linux/of_platform.h>*/
+#include <linux/platform_device.h>
+
+
+#include <linux/list.h>
+#include <linux/netdevice.h>    
+#include <linux/phy.h>
+#include <linux/cdev.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+
+#include <../net/dsa/dsa_priv.h>
+#include <../net/dsa/mv88e6xxx.h>
+
+
+#define READ_MV_REG_CMD    0x1
+#define WRITE_MV_REG_CMD   0x2
+#define READ_CCSR_REG_CMD  0x3
+#define WRITE_CCSR_REG_CMD_ADD 0x41
+#define WRITE_CCSR_REG_CMD_VAL 0x42
+
+//#define SW_CHR_MAJOR 32
+//
+//static dev_t cdev_devnum;
+//static struct device *cdev_sw;
+//static struct class *sw_class;
+struct miscdevice misc_sw;
+//static int mvdev_open = 0;
+
+struct mii_bus *global_bus; 
+int global_sw_addr;
+
+//static int Major;
+#define DEVICE_NAME "marvell_sw_dev"
+
+
+int mv88e6095_reg_read(struct mii_bus *bus, int sw_addr, int addr, int reg)
+{
+        int ret;
+
+        /*
+         * Transmit the read command.
+         */
+        ret = bus->write(bus, sw_addr, 0, 0x9800 | (addr << 5) | reg);
+        if (ret < 0)
+                return ret;
+
+        /*
+         * Read the data.
+         */
+        ret = bus->read(bus, sw_addr, 1);
+        if (ret < 0)
+                return ret;
+
+        return ret & 0xffff;
+}
+
+int mv88e6095_reg_write(struct mii_bus *bus, int sw_addr, int addr,
+                          int reg, u16 val)
+{
+        int ret;
+
+        /*
+         * Transmit the data to write.
+         */
+        ret = bus->write(bus, sw_addr, 1, val);
+        if (ret < 0)
+                return ret;
+
+        /*
+         * Transmit the write command.
+         */
+        ret = bus->write(bus, sw_addr, 0, 0x9400 | (addr << 5) | reg);
+        if (ret < 0)
+                return ret;
+
+        return 0;
+}
+
+struct phy_device * mv88e6095_detect(struct mii_bus *bus, int sw_addr)
+{
+    struct phy_device *dev = NULL;
+        u32 phy_id;
+    int ret=0;
+
+    printk ("Initializing MV88e6095 (addr %d): \n", sw_addr);
+
+        ret = mv88e6095_reg_read(bus, sw_addr, REG_PORT(0), 0x03);
+        if (ret >= 0 && ret != 0xFFFF) {
+                phy_id = ret & 0xfff0;
+                if (phy_id == 0x0950)
+                        printk("Marvell 88E6095/88E6095F Detected\n");
+                else if (phy_id == 0x1060)
+                        printk("Marvell 88E6131 Detected\n");
+        else{
+            printk("Unknown Device Detected - but will use it anyway\n");
+        }
+        }else{
+        printk("Marvell 88E6095/88E6095F not Detected - but will use it anyway\n");
+        phy_id = 0x0950;
+    }
+
+        dev = phy_device_create(bus, sw_addr, phy_id, 0, NULL);
+
+//    printk ("Configure PTIN MV88e6095...\n");
+//    //mv88e6095_setup(bus, sw_addr);
+//    mv88e6095_reg_write(bus, sw_addr, REG_PORT(9), 0x01, 0x003E);
+//    mv88e6095_reg_write(bus, sw_addr, REG_PORT(10), 0x01, 0x003E);
+
+        return dev;
+
+}
+
+
+MODULE_LICENSE("GPL");
+
diff -rupN linux-denx-3.18.25-ori/arch/powerpc/sysdev/mv88e6095x_of.h linux-denx-3.18.25-mod/arch/powerpc/sysdev/mv88e6095x_of.h
--- linux-denx-3.18.25-ori/arch/powerpc/sysdev/mv88e6095x_of.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-denx-3.18.25-mod/arch/powerpc/sysdev/mv88e6095x_of.h	2016-11-23 13:17:20.000000000 +0000
@@ -0,0 +1,13 @@
+
+#ifndef __MARVELL_88E6095X_DRIVER__
+#define __MARVELL_88E6095X_DRIVER__
+
+#include <linux/phy.h>
+
+#define REG_PORT(p)		(0x10 + (p))
+#define REG_GLOBAL		0x1b
+#define REG_GLOBAL2		0x1c
+
+extern struct phy_device * mv88e6095_detect(struct mii_bus *bus, int sw_addr);
+
+#endif  //__MARVELL_88E6095X_DRIVER__
diff -rupN linux-denx-3.18.25-ori/cxo640g_uP2.dts linux-denx-3.18.25-mod/cxo640g_uP2.dts
--- linux-denx-3.18.25-ori/cxo640g_uP2.dts	2016-11-18 09:30:29.000000000 +0000
+++ linux-denx-3.18.25-mod/cxo640g_uP2.dts	2016-11-23 15:20:31.000000000 +0000
@@ -336,10 +336,11 @@
                 reg = <0x0 0xe0008000 0x0 0x1000>;
 	};
 	
-	chosen {
-		linux,stdout-path = &serial0;
+	chosen{
+		//linux,stdout-path = &serial0;
+		linux,stdout-path = "/soc8544@e0000000/serial@4500";
 		bootargs = "root=/dev/ram rw ip=off console=ttyS0,115200 ramdisk_size=196608";
-		linux,initrd-start = <0x1D977000>;
-		linux,initrd-end = <0x1FE9F315>;
+		//linux,initrd-start = <0x1dad7000>;
+		//linux,initrd-end = <0x1ffff315>;
 	};
 };
diff -rupN linux-denx-3.18.25-ori/drivers/of/fdt.c linux-denx-3.18.25-mod/drivers/of/fdt.c
--- linux-denx-3.18.25-ori/drivers/of/fdt.c	2016-11-17 14:14:36.000000000 +0000
+++ linux-denx-3.18.25-mod/drivers/of/fdt.c	2016-11-23 15:19:03.000000000 +0000
@@ -167,7 +167,7 @@ static void * unflatten_dt_node(void *bl
 	int new_format = 0;
 
 	pathp = fdt_get_name(blob, *poffset, &l);
-	if (!pathp)
+	if (!pathp) 
 		return mem;
 
 	allocl = l++;
@@ -722,22 +722,30 @@ static void __init early_init_dt_check_f
 
 	pr_debug("Looking for initrd properties... ");
 
-	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
-	if (!prop)
-		return;
-	start = of_read_number(prop, len/4);
-
-	prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
-	if (!prop)
-		return;
-	end = of_read_number(prop, len/4);
-
-	initrd_start = (unsigned long)__va(start);
-	initrd_end = (unsigned long)__va(end);
-	initrd_below_start_ok = 1;
-
-	pr_debug("initrd_start=0x%llx  initrd_end=0x%llx\n",
-		 (unsigned long long)start, (unsigned long long)end);
+        if (!initrd_start || (initrd_start>=initrd_end)) {
+            prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
+            if (!prop)
+                    return;
+            start = of_read_number(prop, len/4);
+
+            prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
+            if (!prop)
+                    return;
+            end = of_read_number(prop, len/4);
+
+        } else {
+            start=initrd_start;
+            end=initrd_end;
+        }
+
+        initrd_start = (unsigned long)__va(start);
+        initrd_end = (unsigned long)__va(end);
+
+        initrd_below_start_ok = 1;
+
+        pr_debug("initrd_start=0x%lx  initrd_end=0x%lx\n",
+                 initrd_start, initrd_end);
+                 //(unsigned long long)start, (unsigned long long)end);
 }
 #else
 static inline void early_init_dt_check_for_initrd(unsigned long node)
diff -rupN linux-denx-3.18.25-ori/drivers/of/of_mdio.c linux-denx-3.18.25-mod/drivers/of/of_mdio.c
--- linux-denx-3.18.25-ori/drivers/of/of_mdio.c	2016-11-17 14:14:36.000000000 +0000
+++ linux-denx-3.18.25-mod/drivers/of/of_mdio.c	2016-11-23 13:18:11.000000000 +0000
@@ -20,6 +20,10 @@
 #include <linux/of_mdio.h>
 #include <linux/module.h>
 
+#ifdef CONFIG_PTIN_ETH_MARVELL_SWITCH
+#include <../arch/powerpc/sysdev/mv88e6095x_of.h>
+#endif
+
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
 MODULE_LICENSE("GPL");
 
@@ -39,7 +43,6 @@ static int of_get_phy_id(struct device_n
 	}
 	return -EINVAL;
 }
-
 static int of_mdiobus_register_phy(struct mii_bus *mdio, struct device_node *child,
 				   u32 addr)
 {
@@ -53,8 +56,20 @@ static int of_mdiobus_register_phy(struc
 
 	if (!is_c45 && !of_get_phy_id(child, &phy_id))
 		phy = phy_device_create(mdio, addr, phy_id, 0, NULL);
-	else
-		phy = get_phy_device(mdio, addr, is_c45);
+	else {
+#ifdef CONFIG_PTIN_ETH_MARVELL_SWITCH
+               if(of_device_is_compatible(child, "ptin,dsa-switch")){
+                       printk("bus addr 0x%p\n", mdio);
+                       mv88e6095_detect(mdio,addr);
+                       phy = get_phy_device(mdio, addr, is_c45);
+               }else{
+                       printk("bus addr 0x%p\n", mdio);
+                       phy = get_phy_device(mdio, addr, is_c45);
+               }
+#else
+               phy = get_phy_device(mdio, addr, is_c45);
+#endif
+	}
 	if (!phy || IS_ERR(phy))
 		return 1;
 
diff -rupN linux-denx-3.18.25-ori/kernel/softirq.c linux-denx-3.18.25-mod/kernel/softirq.c
--- linux-denx-3.18.25-ori/kernel/softirq.c	2016-11-17 14:41:08.000000000 +0000
+++ linux-denx-3.18.25-mod/kernel/softirq.c	2016-11-23 13:18:19.000000000 +0000
@@ -660,9 +660,9 @@ static void run_ksoftirqd(unsigned int c
 		local_irq_enable();
 		cond_resched();
 
-		preempt_disable();
+		/*preempt_disable();
 		rcu_note_context_switch(cpu);
-		preempt_enable();
+		preempt_enable();*/
 
 		return;
 	}
diff -rupN linux-denx-3.18.25-ori/net/dsa/mv88e6xxx.h linux-denx-3.18.25-mod/net/dsa/mv88e6xxx.h
--- linux-denx-3.18.25-ori/net/dsa/mv88e6xxx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-denx-3.18.25-mod/net/dsa/mv88e6xxx.h	2016-11-23 13:17:56.000000000 +0000
@@ -0,0 +1,95 @@
+/*
+ * net/dsa/mv88e6xxx.h - Marvell 88e6xxx switch chip support
+ * Copyright (c) 2008 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __MV88E6XXX_H
+#define __MV88E6XXX_H
+
+#define REG_PORT(p)		(0x10 + (p))
+#define REG_GLOBAL		0x1b
+#define REG_GLOBAL2		0x1c
+
+struct mv88e6xxx_priv_state {
+	/*
+	 * When using multi-chip addressing, this mutex protects
+	 * access to the indirect access registers.  (In single-chip
+	 * mode, this mutex is effectively useless.)
+	 */
+	struct mutex	smi_mutex;
+
+#ifdef CONFIG_NET_DSA_MV88E6XXX_NEED_PPU
+	/*
+	 * Handles automatic disabling and re-enabling of the PHY
+	 * polling unit.
+	 */
+	struct mutex		ppu_mutex;
+	int			ppu_disabled;
+	struct work_struct	ppu_work;
+	struct timer_list	ppu_timer;
+#endif
+
+	/*
+	 * This mutex serialises access to the statistics unit.
+	 * Hold this mutex over snapshot + dump sequences.
+	 */
+	struct mutex	stats_mutex;
+
+	int		id; /* switch product id */
+};
+
+struct mv88e6xxx_hw_stat {
+	char string[ETH_GSTRING_LEN];
+	int sizeof_stat;
+	int reg;
+};
+
+int __mv88e6xxx_reg_read(struct mii_bus *bus, int sw_addr, int addr, int reg);
+int mv88e6xxx_reg_read(struct dsa_switch *ds, int addr, int reg);
+int __mv88e6xxx_reg_write(struct mii_bus *bus, int sw_addr, int addr,
+                          int reg, u16 val);
+int mv88e6xxx_reg_write(struct dsa_switch *ds, int addr, int reg, u16 val);
+int mv88e6xxx_config_prio(struct dsa_switch *ds);
+int mv88e6xxx_set_addr_direct(struct dsa_switch *ds, u8 *addr);
+int mv88e6xxx_set_addr_indirect(struct dsa_switch *ds, u8 *addr);
+int mv88e6xxx_phy_read(struct dsa_switch *ds, int addr, int regnum);
+int mv88e6xxx_phy_write(struct dsa_switch *ds, int addr, int regnum, u16 val);
+void mv88e6xxx_ppu_state_init(struct dsa_switch *ds);
+int mv88e6xxx_phy_read_ppu(struct dsa_switch *ds, int addr, int regnum);
+int mv88e6xxx_phy_write_ppu(struct dsa_switch *ds, int addr,
+			    int regnum, u16 val);
+void mv88e6xxx_poll_link(struct dsa_switch *ds);
+void mv88e6xxx_get_strings(struct dsa_switch *ds,
+			   int nr_stats, struct mv88e6xxx_hw_stat *stats,
+			   int port, uint8_t *data);
+void mv88e6xxx_get_ethtool_stats(struct dsa_switch *ds,
+				 int nr_stats, struct mv88e6xxx_hw_stat *stats,
+				 int port, uint64_t *data);
+
+#define REG_READ(addr, reg)						\
+	({								\
+		int __ret;						\
+									\
+		__ret = mv88e6xxx_reg_read(ds, addr, reg);		\
+		if (__ret < 0)						\
+			return __ret;					\
+		__ret;							\
+	})
+
+#define REG_WRITE(addr, reg, val)					\
+	({								\
+		int __ret;						\
+									\
+		__ret = mv88e6xxx_reg_write(ds, addr, reg, val);	\
+		if (__ret < 0)						\
+			return __ret;					\
+	})
+
+
+
+#endif
