/*
 * $Id: cint_load_balancing_hw_cfg_gen.c
 */

/*
 * This cint provides an example on generating the HW configuration data used by the LB offline simulator.
 * The file $SDK/src/examples/dnx/load_balancing_sim/cint_load_balancing_hw_cfg_ag.c will be autogenerated based on the parameters set in the system.
 *
 * ./bcm.user
 * cint ../../../../src/examples/dnx/load_balancing_sim/cint_load_balancing_hw_cfg_gen.c
 * cint
 * cint_dnx_switch_lb_offline_sim_generate(0);
 *
 */
/** An enumeration used by the LB offline simulator to indicate active device */
enum cint_load_balancing_sim_device_type_e {
    DEVICE_TYPE_JERICHO2_A0 = 0,
    DEVICE_TYPE_JERICHO2_B0 = 1,
    DEVICE_TYPE_QUMRAN2_A0 = 2,
    DEVICE_TYPE_QUMRAN2_B0 = 3,
    DEVICE_TYPE_JERICHO2C = 4,
    DEVICE_TYPE_JERICHO2P = 5,
    DEVICE_TYPE_JERICHO2X = 6
} ;

int DNX_SWITCH_LB_NOF_VRS = 100;
uint32 MAX_BUFFER_SIZE = 1024;
char *filename = "src/examples/dnx/load_balancing_sim/jr2_family/cint_load_balancing_hw_cfg_ag.c";

/**
 * \brief 
 * The purpose of this function is to retrieve the hashing enablers per header
 * \param [in] unit - The unit number
 * \param [out] nof_header_types - number of header types in enabler_keys and enabler_values
 * \param [out] enabler_keys - A list of unique header types
 * \param [out] enabler_values - A list of bitmaps indicating enabled header fields per header type
 *
 * \retval Zero if no error was detected
 * \retval Negative if error was detected.
 */
int
dnx_switch_lb_hash_enablers_get(
    int unit,
    uint32 *nof_header_types,
    uint32 *enabler_keys,
    int *enabler_values)
{
    int idx, rv = BCM_E_NONE;
    uint32 header_types[7] = { bcmSwitchHashIP4OuterField, bcmSwitchHashIP4InnerField, bcmSwitchHashIP6Field,
        bcmSwitchHashL2OuterField, bcmSwitchHashL2InnerField, bcmSwitchHashL4Field, bcmSwitchHashMPLSField0
    };
    *nof_header_types = sizeof(header_types) / sizeof(header_types[0]);
    sal_memcpy(enabler_keys, header_types, sizeof(header_types[0]) * *nof_header_types);
    for (idx = 0; idx < *nof_header_types; idx++)
    {
        rv = bcm_switch_control_get(unit, header_types[idx], &enabler_values[idx]);
        if (rv != BCM_E_NONE)
        {
            printf("Error, LB hash_fields_masking_get - %d \n", rv);
            return rv;
        }
    }
    return rv;
}

/*
 * Return the polynomial value given the polynomial enumeration value.
 */
uint32
load_balancing_sim_hw_cfg_polynomial_value_get(
    bcm_switch_hash_config_t poly_enum)
{
    switch (poly_enum)
    {
        case BCM_HASH_CONFIG_CRC16_0x1015d:
            return 0x015d;
        case BCM_HASH_CONFIG_CRC16_0x100d7:
            return 0x00d7;
        case BCM_HASH_CONFIG_CRC16_0x10039:
            return 0x0039;
        case BCM_HASH_CONFIG_CRC16_0x10ac5:
            return 0x0ac5;
        case BCM_HASH_CONFIG_CRC16_0x109e7:
            return 0x09e7;
        case BCM_HASH_CONFIG_CRC16_0x10939:
            return 0x0939;
        case BCM_HASH_CONFIG_CRC16_0x12105:
            return 0x2105;
        case BCM_HASH_CONFIG_CRC16_0x1203d:
            return 0x203d;
        default:
            return 0;
    }
}

/*
 * This function will be replaced by a function to access VR directly.
 * The aim of the function is to extract an array of values for the header field enablers and symmetrical hashing indication.
 */
int
load_balancing_sim_hw_cfg_vr_get(
    int unit,
    uint32 *vr_values)
{
    uint32 nof_types;
    uint32 keys[7];
    int values[7];
    int rv = BCM_E_NONE;

    rv = dnx_switch_lb_hash_enablers_get(unit, &nof_types, keys, values);
    if (rv != BCM_E_NONE)
    {
        printf("Error, dnx_switch_lb_hash_enablers_get - %d\n", rv);
        return rv;
    }

    vr_values[0] = (values[4] & BCM_HASH_FIELD_MAC_ADDRESS) ? 1 : 0;
    vr_values[1] = (values[4] & BCM_HASH_NON_SYMMETRICAL) ? 0 : 1;
    vr_values[2] = (values[4] & BCM_HASH_FIELD_ETHER_TYPE) ? 1 : 0;
    vr_values[3] = (values[3] & BCM_HASH_FIELD_MAC_ADDRESS) ? 1 : 0;
    vr_values[4] = (values[3] & BCM_HASH_NON_SYMMETRICAL) ? 0 : 1;
    vr_values[5] = (values[3] & BCM_HASH_FIELD_ETHER_TYPE) ? 1 : 0;
    vr_values[6] = 1;
    vr_values[7] = 1;
    vr_values[8] = 1;
    vr_values[9] = 1;
    vr_values[10] = (values[1] & BCM_HASH_FIELD_IPV4_ADDRESS) ? 1 : 0;
    vr_values[11] = (values[1] & BCM_HASH_NON_SYMMETRICAL) ? 0 : 1;
    vr_values[12] = (values[1] & BCM_HASH_FIELD_PROTOCOL) ? 1 : 0;
    vr_values[13] = (values[0] & BCM_HASH_FIELD_IPV4_ADDRESS) ? 1 : 0;
    vr_values[14] = (values[0] & BCM_HASH_NON_SYMMETRICAL) ? 0 : 1;
    vr_values[15] = (values[0] & BCM_HASH_FIELD_PROTOCOL) ? 1 : 0;
    vr_values[16] = (values[2] & BCM_HASH_FIELD_FLOW_LABEL) ? 1 : 0;
    vr_values[17] = (values[2] & BCM_HASH_FIELD_NXT_HDR) ? 1 : 0;
    vr_values[18] = (values[2] & BCM_HASH_FIELD_IPV6_ADDRESS) ? 1 : 0;
    vr_values[19] = (values[2] & BCM_HASH_NON_SYMMETRICAL) ? 0 : 1;
    vr_values[20] = (values[5] & BCM_HASH_FIELD_L4) ? 1 : 0;
    vr_values[21] = (values[5] & BCM_HASH_NON_SYMMETRICAL) ? 0 : 1;
    vr_values[22] = 1;
    vr_values[23] = (values[6] & BCM_HASH_MPLS_ALL_LABELS) ? 1 : 0;
    vr_values[24] = -1;

    return rv;
}

/**
 * The aim of this diagnostics function is to generate the cint_load_balancing_hw_cfg_ag.c file dynamically,
 * filling in the data for the HW configuration.
 */
int
cint_dnx_switch_lb_offline_sim_generate(
    int unit)
{
    int rv = BCM_E_NONE;
    void *file;
    char file_data[1024];
    int value;
    const int nof_clients =  *(dnxc_data_get(unit, "switch", "load_balancing", "nof_lb_clients", NULL));
    uint32 nof_vrs = 0;
    uint32 iter;
    uint32 clients_polynomial_seeds[nof_clients];
    uint32 clients_polynomial[nof_clients];
    uint32 clients_16_crc_selection[nof_clients];
    uint32 vr_values[DNX_SWITCH_LB_NOF_VRS];
    uint32 device_id_enum = 0;
    int lb_clients[nof_clients] =
        { bcmSwitchNwkHashConfig, bcmSwitchTrunkHashConfig, bcmSwitchECMPHashConfig, bcmSwitchECMPSecondHierHashConfig,
        bcmSwitchECMPThirdHierHashConfig
    };
    bcm_switch_control_key_t control_key;
    bcm_switch_control_info_t control_info;

    char * header =
"/*
 * $Id: cint_load_balancing_hw_cfg_ag.c
 * AUTO GENERATED using cint function \"cint_dnx_switch_lb_offline_sim_generate\"
 * DO NOT EDIT!
 */\n";

    char *enum_data =
"
/* A list of supported devices by the simulator */
enum load_balancing_sim_device_type_e {
    DEVICE_TYPE_JERICHO2_A0,
    DEVICE_TYPE_JERICHO2_B0,
    DEVICE_TYPE_QUMRAN2_A0,
    DEVICE_TYPE_QUMRAN2_B0,
    DEVICE_TYPE_JERICHO2C,
    DEVICE_TYPE_JERICHO2P,
    DEVICE_TYPE_JERICHO2X
};

";


    char *structure_data = "
/*
 * This structure holds all the relevant HW values to generate the load balancing keys.
 */
struct load_balancing_sim_hw_cfg_t
{
    /*
     * The device which the simulation should simulate.
     */
    load_balancing_sim_device_type_e device;
    /*
     * The seed that is used by the parser
     */
    uint32 parser_seed;
    /*
     * Seed that are used to generate the MPLS hash fields
     */
    uint32 mpls_seed[2];
    /*
     * The seeds of the CRC functions that each LB client uses.
     */
    uint32 clients_polynomial_seeds[5];
    /*
     * The CRC function that each LBclient uses
     */
    uint32 clients_polynomial[5];
    /*
     * The CRC 16 bit selection that each client uses.
     */
    uint32 clients_16_crc_selection[5];
    /*
     * An array of Virtual register values
     */
    uint8 virtual_reg_values[60];
};

";

    if ((file = cint_fopen(filename, "w+")) == NULL)
    {
        printf("Cannot open file: %s\n", filename);
        return BCM_E_UNAVAIL;
    }
    device_id_enum = *dnxc_data_get(unit, "switch", "load_balancing_sim", "device_enum", NULL);

    /*
     * Create File Header
     */
    cint_fwrite(file, header);
    cint_fwrite(file, enum_data);
    cint_fwrite(file, structure_data);

    snprintf(file_data, MAX_BUFFER_SIZE, "/** Hw configuration instance */
load_balancing_sim_hw_cfg_t load_balancing_sim_hw_cfg = {
    %u,
", device_id_enum);
    cint_fwrite(file, file_data);

    /*
     * Get parser seed
     */
    rv = bcm_switch_control_get(unit, bcmSwitchParserHashSeed, &value);
    snprintf(file_data, MAX_BUFFER_SIZE, "    0x%04x,
", value);
    cint_fwrite(file, file_data);

    /*
     * Get MPLS hash function seed
     */
    rv = bcm_switch_control_get(unit, bcmSwitchMplsStack0HashSeed, &value);
    snprintf(file_data, MAX_BUFFER_SIZE, "    {0x%04x, 0},\n", value);
    cint_fwrite(file, file_data);

    /*
     * Get clients LB configuration
     */
    for (iter = 0; iter < nof_clients; iter++)
    {
        /*
         * Get client CRC function
         */
        rv = bcm_switch_control_get(unit, lb_clients[iter], &value);
        clients_polynomial[iter] = load_balancing_sim_hw_cfg_polynomial_value_get(value);

        /*
         * Get client CRC function seed
         */
        control_key.type = bcmSwitchHashSeed;
        control_key.index = value;
        rv = bcm_switch_control_indexed_get(unit, control_key, &control_info);
        clients_polynomial_seeds[iter] = control_info.value;

        /*
         * Get client CRC function input selection
         */
        control_key.type = bcmSwitchLayerRecordModeSelection;
        control_key.index = lb_clients[iter];
        rv = bcm_switch_control_indexed_get(unit, control_key, &control_info);
        clients_16_crc_selection[iter] = control_info.value;
    }

    snprintf(file_data, MAX_BUFFER_SIZE, "    { 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x },\n",
                 clients_polynomial_seeds[0], clients_polynomial_seeds[1], clients_polynomial_seeds[2],
                 clients_polynomial_seeds[3], clients_polynomial_seeds[4]);
    cint_fwrite(file, file_data);
    snprintf(file_data, MAX_BUFFER_SIZE, "    { 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x },\n",
                 clients_polynomial[0], clients_polynomial[1], clients_polynomial[2], clients_polynomial[3],
                 clients_polynomial[4]);
    cint_fwrite(file, file_data);
    snprintf(file_data, MAX_BUFFER_SIZE, "    { 0x%04x, 0x%04x, 0x%04x, 0x%04x, 0x%04x },\n",
                 clients_16_crc_selection[0], clients_16_crc_selection[1], clients_16_crc_selection[2],
                 clients_16_crc_selection[3], clients_16_crc_selection[4]);
    cint_fwrite(file, file_data);

    snprintf(file_data, MAX_BUFFER_SIZE,
                 "  /** 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 */\n");
    cint_fwrite(file, file_data);

    rv = load_balancing_sim_hw_cfg_vr_get(unit, vr_values);

    for (iter = 0; iter < DNX_SWITCH_LB_NOF_VRS; iter++)
    {
        if (vr_values[iter] == -1)
        {
            nof_vrs = iter;
            break;
        }
    }
    for (iter = 0; iter < nof_vrs; iter++)
    {
        /** iter indicates last valid VR value */
        if (iter + 1 == nof_vrs)
        {
            snprintf(file_data, MAX_BUFFER_SIZE, "%u },\n", vr_values[iter]);
        }
        else if (iter == 0)
        {
            snprintf(file_data, MAX_BUFFER_SIZE, "    { %u, ", vr_values[iter]);
        }
        else
        {
            snprintf(file_data, MAX_BUFFER_SIZE, "%u, ", vr_values[iter]);
        }
        cint_fwrite(file, file_data);
    }

    snprintf(file_data, MAX_BUFFER_SIZE, "};\n");
    cint_fwrite(file, file_data);

    /*
     * Close output file
     */
    if (file != NULL)
    {
        cint_fclose(file);
    }

    printf("FILE %s was autogenerated.\n", filename);
    return rv;
}

int
cint_dnx_switch_lb_offline_sim_destroy(
    int unit)
{
    int rv = BCM_E_NONE;
    rv = cint_fremove(filename);
    if (rv != BCM_E_NONE)
    {
        printf("Error, could not delete file - \"%s\"\n", filename);
    }
    return rv;
}
