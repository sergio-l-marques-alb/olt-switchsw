/** \file jr2_a0_data_ingr_congestion.c
 * 
 * DEVICE DATA - INGR_CONGESTION
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_COSQ
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_ingr_congestion.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_dram.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_system_red.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_nif.h>
#include <bcm_int/dnx/cosq/ingress/ingress_congestion.h>
#include <bcm_int/dnx/cosq/ingress/system_red.h>
#include <soc/dnx/dbal/dbal.h>
#include <shared/utilex/utilex_integer_arithmetic.h>
/*
 * }
 */

/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: config
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_config_pp_port_by_reassembly_overwrite_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_config;
    int feature_index = dnx_data_ingr_congestion_config_pp_port_by_reassembly_overwrite;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set numeric guarantee_mode
 * numeric info:
 * guarantee mode
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_config_guarantee_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_config;
    int define_index = dnx_data_ingr_congestion_config_define_guarantee_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_INGRESS_CONGESTION_MANAGEMENT;
    define->property.doc = 
        "\n"
        "legacy SoC property to define CGM guarantee mode\n"
        "defined here just to ensure unsupported value is not specified by user\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_direct_map;
    define->property.method_str = "suffix_direct_map";
    define->property.suffix = "guarantee_mode";
    define->property.nof_mapping = 1;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "LOOSE";
    define->property.mapping[0].val = 0;
    define->property.mapping[0].is_default = 1 ;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric wred_packet_size
 * numeric info:
 * max packet size used in WRED parameters computation
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_config_wred_packet_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_config;
    int define_index = dnx_data_ingr_congestion_config_define_wred_packet_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_DISCARD_MTU_SIZE;
    define->property.doc = 
        "\n"
        "Maximal packet size\n"
        "used in computation of WRED parameters\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_range;
    define->property.method_str = "range";
    define->property.range_min = 0;
    define->property.range_max = 16*1024-1;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: info
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_cgm_hw_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int feature_index = dnx_data_ingr_congestion_info_cgm_hw_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define threshold_granularity
 * define info:
 * Granularity (non bytes) thresholds are written to HW with
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_threshold_granularity_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_threshold_granularity;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define words_resolution
 * define info:
 * Size of each HW word in bytes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_words_resolution_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_words_resolution;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define bytes_threshold_granularity
 * define info:
 * Granularity bytes thresholds are written to HW with
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_bytes_threshold_granularity_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_bytes_threshold_granularity;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.info.threshold_granularity_get(unit)*dnx_data_ingr_congestion.info.words_resolution_get(unit);

    /* Set value */
    define->data = dnx_data_ingr_congestion.info.threshold_granularity_get(unit)*dnx_data_ingr_congestion.info.words_resolution_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_dropped_reasons_cgm
 * define info:
 * number of reasons for the dropped packets in CGM
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_nof_dropped_reasons_cgm_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_nof_dropped_reasons_cgm;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 33;

    /* Set value */
    define->data = 33;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wred_max_gain
 * define info:
 * maximal allowed value of gain for WRED
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_wred_max_gain_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_wred_max_gain;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 31;

    /* Set value */
    define->data = 31;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wred_granularity
 * define info:
 * granularity of WRED parameters for coefficient calculation
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_wred_granularity_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_wred_granularity;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_pds_in_pdb
 * define info:
 * number of SRAM PDs in PDB
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_nof_pds_in_pdb_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_nof_pds_in_pdb;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_jumbo_packet_size
 * define info:
 * Maximum size of jumbo packet
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_max_jumbo_packet_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_max_jumbo_packet_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 10000;

    /* Set value */
    define->data = 10000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric max_sram_pdbs
 * numeric info:
 * Maximal number of SRAM PDBS
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_max_sram_pdbs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_max_sram_pdbs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS)->max/dnx_data_ingr_congestion.info.nof_pds_in_pdb_get(unit);

    /* Set value */
    define->data = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS)->max/dnx_data_ingr_congestion.info.nof_pds_in_pdb_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric max_dram_bdbs
 * numeric info:
 * Maximal number of DRAM BDBS
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_max_dram_bdbs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_max_dram_bdbs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_dram.buffers.nof_bdbs_get(unit);

    /* Set value */
    define->data = dnx_data_dram.buffers.nof_bdbs_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric max_total_bytes
 * numeric info:
 * Maximal total bytes resources
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_max_total_bytes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_max_total_bytes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xffffffff;

    /* Set value */
    define->data = 0xffffffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_active_drams
 * numeric info:
 * Number of active drams. Used to calculate total bytes resources available in device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_nof_active_drams_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_nof_active_drams;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = utilex_nof_on_bits_in_long(dnx_data_dram.general_info.dram_info_get(unit)->dram_bitmap);

    /* Set value */
    define->data = utilex_nof_on_bits_in_long(dnx_data_dram.general_info.dram_info_get(unit)->dram_bitmap);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric total_bytes
 * numeric info:
 * total bytes resources according to available DRAM
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_total_bytes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int define_index = dnx_data_ingr_congestion_info_define_total_bytes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_ingress_congestion_calc_available_total_bytes(dnx_data_ingr_congestion.info.max_total_bytes_get(unit),dnx_data_ingr_congestion.info.nof_active_drams_get(unit),dnx_data_dram.general_info.max_nof_drams_get(unit));

    /* Set value */
    define->data = dnx_ingress_congestion_calc_available_total_bytes(dnx_data_ingr_congestion.info.max_total_bytes_get(unit),dnx_data_ingr_congestion.info.nof_active_drams_get(unit),dnx_data_dram.general_info.max_nof_drams_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table resource
 * Module - 'ingr_congestion', Submodule - 'info', table - 'resource'
 * Resource Size - per resource
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_resource_set(
    int unit)
{
    int type_index;
    dnx_data_ingr_congestion_info_resource_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int table_index = dnx_data_ingr_congestion_info_table_resource;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 3;
    table->info_get.key_size[0] = 3;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_info_resource_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_info_table_resource");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_info_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->max = 0;
    default_data->hw_resolution_max = 0;
    default_data->hw_resolution_nof_bits = 0;
    default_data->fadt_alpha_min = 0;
    default_data->fadt_alpha_max = 0;
    /* Set Default Values */
    for (type_index = 0; type_index < table->keys[0].size; type_index++)
    {
        data = (dnx_data_ingr_congestion_info_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DNX_INGRESS_CONGESTION_RESOURCE_TOTAL_BYTES < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_info_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_RESOURCE_TOTAL_BYTES, 0);
        data->max = dnx_data_ingr_congestion.info.total_bytes_get(unit);
        data->hw_resolution_max = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_TOTAL_BYTES)->max/dnx_data_ingr_congestion.info.bytes_threshold_granularity_get(unit);
        data->hw_resolution_nof_bits = 24;
        data->fadt_alpha_min = -15;
        data->fadt_alpha_max = 15;
    }
    if (DNX_INGRESS_CONGESTION_RESOURCE_SRAM_BUFFERS < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_info_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_BUFFERS, 0);
        data->max = 64*1024-1;
        data->hw_resolution_max = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_BUFFERS)->max/dnx_data_ingr_congestion.info.threshold_granularity_get(unit);
        data->hw_resolution_nof_bits = 12;
        data->fadt_alpha_min = -7;
        data->fadt_alpha_max = 7;
    }
    if (DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_info_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS, 0);
        data->max = 128*1024-1;
        data->hw_resolution_max = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS)->max/dnx_data_ingr_congestion.info.threshold_granularity_get(unit);
        data->hw_resolution_nof_bits = 13;
        data->fadt_alpha_min = -7;
        data->fadt_alpha_max = 7;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table dp_free_res_presentage_drop
 * Module - 'ingr_congestion', Submodule - 'info', table - 'dp_free_res_presentage_drop'
 * Amount of free resource precntage to cause drop per DP
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_set(
    int unit)
{
    int dp_index;
    dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int table_index = dnx_data_ingr_congestion_info_table_dp_free_res_presentage_drop;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 4;
    table->info_get.key_size[0] = 4;

    /* Info - default values */
    table->values[0].default_val = "100";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_info_table_dp_free_res_presentage_drop");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->drop_precentage = 100;
    /* Set Default Values */
    for (dp_index = 0; dp_index < table->keys[0].size; dp_index++)
    {
        data = (dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, dp_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->drop_precentage = 0;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->drop_precentage = 15;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->drop_precentage = 25;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->drop_precentage = 100;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table admission_preferences
 * Module - 'ingr_congestion', Submodule - 'info', table - 'admission_preferences'
 * admission preferences (admit/guaranteed) per DP.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_info_admission_preferences_set(
    int unit)
{
    int dp_index;
    dnx_data_ingr_congestion_info_admission_preferences_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_info;
    int table_index = dnx_data_ingr_congestion_info_table_admission_preferences;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 3;
    table->info_get.key_size[0] = 3;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_info_admission_preferences_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_info_table_admission_preferences");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_info_admission_preferences_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->is_guarantee_over_admit = 0;
    /* Set Default Values */
    for (dp_index = 0; dp_index < table->keys[0].size; dp_index++)
    {
        data = (dnx_data_ingr_congestion_info_admission_preferences_t *) dnxc_data_mgmt_table_data_get(unit, table, dp_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - is_guarantee_over_admit
     */
    table->values[0].property.name = spn_COSQ_ADMISSION_PREFERENCE;
    table->values[0].property.doc =
        "\n"
        "if GUARANTEE_OVER_ADMIT is set, than in case statistic admission tests fail (for example WRED),\n"
        "but the queue level is within the guaranteed, packet will enter.\n"
        "this soc property is only rlevant for DPs 0-2 (DP3 is always dropped).\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_suffix_direct_map;
    table->values[0].property.method_str = "suffix_direct_map";
    table->values[0].property.suffix = "";
    table->values[0].property.nof_mapping = 2;
    DNXC_DATA_ALLOC(table->values[0].property.mapping, dnxc_data_property_map_t, table->values[0].property.nof_mapping, "dnx_data_ingr_congestion_info_admission_preferences_t property mapping");

    table->values[0].property.mapping[0].name = "ADMIT_OVER_GUARANTEE";
    table->values[0].property.mapping[0].val = 0;
    table->values[0].property.mapping[0].is_default = 1 ;
    table->values[0].property.mapping[1].name = "GUARANTEE_OVER_ADMIT";
    table->values[0].property.mapping[1].val = 1;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));

    for (dp_index = 0; dp_index < table->keys[0].size; dp_index++)
    {
        data = (dnx_data_ingr_congestion_info_admission_preferences_t *) dnxc_data_mgmt_table_data_get(unit, table, dp_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, dp_index, &data->is_guarantee_over_admit));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: fadt_tail_drop
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set numeric default_max_size_byte_threshold_for_ocb_only
 * numeric info:
 * Default for max size threshold for byte resource when rate class is OCB only
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_fadt_tail_drop_default_max_size_byte_threshold_for_ocb_only_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_fadt_tail_drop;
    int define_index = dnx_data_ingr_congestion_fadt_tail_drop_define_default_max_size_byte_threshold_for_ocb_only;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8*1024*1024;

    /* Set value */
    define->data = 8*1024*1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: dram_bound
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define fadt_alpha_min
 * define info:
 * min value for fadt dram thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dram_bound_fadt_alpha_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dram_bound;
    int define_index = dnx_data_ingr_congestion_dram_bound_define_fadt_alpha_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = -8;

    /* Set value */
    define->data = -8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fadt_alpha_max
 * define info:
 * max value for fadt dram thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dram_bound_fadt_alpha_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dram_bound;
    int define_index = dnx_data_ingr_congestion_dram_bound_define_fadt_alpha_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table resource
 * Module - 'ingr_congestion', Submodule - 'dram_bound', table - 'resource'
 * DRAM Resource info per resource
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dram_bound_resource_set(
    int unit)
{
    int type_index;
    dnx_data_ingr_congestion_dram_bound_resource_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dram_bound;
    int table_index = dnx_data_ingr_congestion_dram_bound_table_resource;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 3;
    table->info_get.key_size[0] = 3;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_dram_bound_resource_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_dram_bound_table_resource");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_dram_bound_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->max = 0;
    default_data->is_resource_range = 0;
    /* Set Default Values */
    for (type_index = 0; type_index < table->keys[0].size; type_index++)
    {
        data = (dnx_data_ingr_congestion_dram_bound_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DNX_INGRESS_CONGESTION_DRAM_BOUND_RESOURCE_SRAM_BYTES < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dram_bound_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_DRAM_BOUND_RESOURCE_SRAM_BYTES, 0);
        data->max = 0xffffff;
        data->is_resource_range = FALSE;
    }
    if (DNX_INGRESS_CONGESTION_DRAM_BOUND_RESOURCE_SRAM_BUFFERS < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dram_bound_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_DRAM_BOUND_RESOURCE_SRAM_BUFFERS, 0);
        data->max = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_BUFFERS)->max;
        data->is_resource_range = TRUE;
    }
    if (DNX_INGRESS_CONGESTION_DRAM_BOUND_RESOURCE_SRAM_PDS < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dram_bound_resource_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_DRAM_BOUND_RESOURCE_SRAM_PDS, 0);
        data->max = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS)->max;
        data->is_resource_range = TRUE;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: voq
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_rate_class
 * define info:
 * number of VOQ rate classes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_voq_nof_rate_class_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_voq;
    int define_index = dnx_data_ingr_congestion_voq_define_nof_rate_class;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define rate_class_nof_bits
 * define info:
 * number of bits in VOQ rate class
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_voq_rate_class_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_voq;
    int define_index = dnx_data_ingr_congestion_voq_define_rate_class_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_compensation_profiles
 * define info:
 * number of VOQ compensation profiles. used for voq compensation calculation
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_voq_nof_compensation_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_voq;
    int define_index = dnx_data_ingr_congestion_voq_define_nof_compensation_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_compensation
 * define info:
 * set to eth compensation (Preamable + IFG + CRC)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_voq_default_compensation_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_voq;
    int define_index = dnx_data_ingr_congestion_voq_define_default_compensation;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 24;

    /* Set value */
    define->data = 24;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define voq_congestion_notification_fifo_size
 * define info:
 * Number of elements in congestion notification FIFO for VOQ
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_voq_voq_congestion_notification_fifo_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_voq;
    int define_index = dnx_data_ingr_congestion_voq_define_voq_congestion_notification_fifo_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: vsq
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_size_watermark_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int feature_index = dnx_data_ingr_congestion_vsq_size_watermark_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define vsq_rate_class_nof
 * define info:
 * Number of VSQ rate classes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_rate_class_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_rate_class_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_a_rate_class_nof
 * define info:
 * Number of VSQ-A rate classes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_a_rate_class_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_a_rate_class_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_a_nof
 * define info:
 * Number of VSQ-A
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_a_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_a_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_b_nof
 * define info:
 * Number of VSQ-B
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_b_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_b_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_c_nof
 * define info:
 * Number of VSQ-C
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_c_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_c_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_d_nof
 * define info:
 * Number of VSQ-D
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_d_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_d_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_e_nof
 * define info:
 * Number of VSQ-E
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_e_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_e_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.vsq.vsq_e_hw_nof_get(unit) - 1;

    /* Set value */
    define->data = dnx_data_ingr_congestion.vsq.vsq_e_hw_nof_get(unit) - 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_e_hw_nof
 * define info:
 * Number of VSQ-E in HW, including reserved VSQ-E
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_e_hw_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_e_hw_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 48+4;

    /* Set value */
    define->data = 48+4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_f_nof
 * define info:
 * Number of VSQ-F
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_f_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_f_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.vsq.vsq_f_hw_nof_get(unit) - 1;

    /* Set value */
    define->data = dnx_data_ingr_congestion.vsq.vsq_f_hw_nof_get(unit) - 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_f_hw_nof
 * define info:
 * Number of VSQ-F in HW, including reserved VSQ-F
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_f_hw_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_f_hw_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 384+8;

    /* Set value */
    define->data = 384+8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define pool_nof
 * define info:
 * Number of resource pools
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_pool_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_pool_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define connection_class_nof
 * define info:
 * Number of connection classes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_connection_class_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_connection_class_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tc_pg_profile_nof
 * define info:
 * Number of tc->pg profiles
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_tc_pg_profile_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_tc_pg_profile_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_e_congestion_notification_fifo_size
 * define info:
 * Number of elements in congestion notification FIFO for PB VSQ PG
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_e_congestion_notification_fifo_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_e_congestion_notification_fifo_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vsq_f_congestion_notification_fifo_size
 * define info:
 * Number of elements in congestion notification FIFO for PB VSQ LLFC
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_f_congestion_notification_fifo_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_f_congestion_notification_fifo_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define oversubscription_bubble_width
 * define info:
 * Bubble width (in cycles) required for VSQ occupancy memory read
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_oversubscription_bubble_width_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_oversubscription_bubble_width;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric vsq_e_default
 * numeric info:
 * Default mapping of VSQ-E
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_e_default_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_e_default;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.vsq.vsq_e_nof_get(unit);

    /* Set value */
    define->data = dnx_data_ingr_congestion.vsq.vsq_e_nof_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric vsq_f_default
 * numeric info:
 * Default mapping of VSQ-F
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_vsq_f_default_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int define_index = dnx_data_ingr_congestion_vsq_define_vsq_f_default;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.vsq.vsq_f_nof_get(unit);

    /* Set value */
    define->data = dnx_data_ingr_congestion.vsq.vsq_f_nof_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table info
 * Module - 'ingr_congestion', Submodule - 'vsq', table - 'info'
 * General VSQ info
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_vsq_info_set(
    int unit)
{
    int vsq_group_index;
    dnx_data_ingr_congestion_vsq_info_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    int table_index = dnx_data_ingr_congestion_vsq_table_info;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_INGRESS_CONGESTION_VSQ_GROUP_NOF;
    table->info_get.key_size[0] = DNX_INGRESS_CONGESTION_VSQ_GROUP_NOF;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_vsq_info_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_vsq_table_info");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_vsq_info_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->nof = -1;
    /* Set Default Values */
    for (vsq_group_index = 0; vsq_group_index < table->keys[0].size; vsq_group_index++)
    {
        data = (dnx_data_ingr_congestion_vsq_info_t *) dnxc_data_mgmt_table_data_get(unit, table, vsq_group_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DNX_INGRESS_CONGESTION_VSQ_GROUP_CTGRY < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_vsq_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_VSQ_GROUP_CTGRY, 0);
        data->nof = dnx_data_ingr_congestion.vsq.vsq_a_nof_get(unit);
    }
    if (DNX_INGRESS_CONGESTION_VSQ_GROUP_CTGRY_TRAFFIC_CLS < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_vsq_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_VSQ_GROUP_CTGRY_TRAFFIC_CLS, 0);
        data->nof = dnx_data_ingr_congestion.vsq.vsq_b_nof_get(unit);
    }
    if (DNX_INGRESS_CONGESTION_VSQ_GROUP_CTGRY_CNCTN_CLS < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_vsq_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_VSQ_GROUP_CTGRY_CNCTN_CLS, 0);
        data->nof = dnx_data_ingr_congestion.vsq.vsq_c_nof_get(unit);
    }
    if (DNX_INGRESS_CONGESTION_VSQ_GROUP_STTSTCS_TAG < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_vsq_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_VSQ_GROUP_STTSTCS_TAG, 0);
        data->nof = dnx_data_ingr_congestion.vsq.vsq_d_nof_get(unit);
    }
    if (DNX_INGRESS_CONGESTION_VSQ_GROUP_SRC_PORT < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_vsq_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_VSQ_GROUP_SRC_PORT, 0);
        data->nof = dnx_data_ingr_congestion.vsq.vsq_e_nof_get(unit);
    }
    if (DNX_INGRESS_CONGESTION_VSQ_GROUP_PG < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_vsq_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_VSQ_GROUP_PG, 0);
        data->nof = dnx_data_ingr_congestion.vsq.vsq_f_nof_get(unit);
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: init
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define fifo_size
 * define info:
 * size of each tar fifo
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_init_fifo_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_init;
    int define_index = dnx_data_ingr_congestion_init_define_fifo_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table vsq_words_rjct_map
 * Module - 'ingr_congestion', Submodule - 'init', table - 'vsq_words_rjct_map'
 * initialization info for VSQ words reject map - defines combinations which should be turn on
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_init_vsq_words_rjct_map_set(
    int unit)
{
    int index_index;
    dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_init;
    int table_index = dnx_data_ingr_congestion_init_table_vsq_words_rjct_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 6;
    table->info_get.key_size[0] = 6;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "0";
    table->values[5].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_init_vsq_words_rjct_map_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_init_table_vsq_words_rjct_map");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->is_total_shared_blocked = 0;
    default_data->is_port_pg_shared_blocked = 0;
    default_data->is_total_headroom_blocked = 0;
    default_data->is_port_pg_headroom_blocked = 0;
    default_data->is_voq_in_guaranteed = 0;
    default_data->vsq_guaranteed_status = 0;
    /* Set Default Values */
    for (index_index = 0; index_index < table->keys[0].size; index_index++)
    {
        data = (dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 0;
        data->is_total_headroom_blocked = 1;
        data->is_port_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->is_total_shared_blocked = 0;
        data->is_port_pg_shared_blocked = 1;
        data->is_total_headroom_blocked = 1;
        data->is_port_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_total_headroom_blocked = 1;
        data->is_port_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_total_headroom_blocked = 1;
        data->is_port_pg_headroom_blocked = 0;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (4 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_total_headroom_blocked = 0;
        data->is_port_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (5 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_words_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_total_headroom_blocked = 1;
        data->is_port_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table vsq_sram_rjct_map
 * Module - 'ingr_congestion', Submodule - 'init', table - 'vsq_sram_rjct_map'
 * initialization info for VSQ SRAM reject map - defines combinations which should be turn on
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_init_vsq_sram_rjct_map_set(
    int unit)
{
    int index_index;
    dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_init;
    int table_index = dnx_data_ingr_congestion_init_table_vsq_sram_rjct_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 9;
    table->info_get.key_size[0] = 9;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "0";
    table->values[5].default_val = "0";
    table->values[6].default_val = "0";
    table->values[7].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_init_table_vsq_sram_rjct_map");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->is_total_shared_blocked = 0;
    default_data->is_port_pg_shared_blocked = 0;
    default_data->is_headroom_extension_blocked = 0;
    default_data->is_total_headroom_blocked = 0;
    default_data->is_port_headroom_blocked = 0;
    default_data->is_pg_headroom_blocked = 0;
    default_data->is_voq_in_guaranteed = 0;
    default_data->vsq_guaranteed_status = 0;
    /* Set Default Values */
    for (index_index = 0; index_index < table->keys[0].size; index_index++)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->is_total_shared_blocked = 0;
        data->is_port_pg_shared_blocked = 1;
        data->is_headroom_extension_blocked = 1;
        data->is_total_headroom_blocked = 1;
        data->is_port_headroom_blocked = 1;
        data->is_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 0;
        data->is_headroom_extension_blocked = 1;
        data->is_total_headroom_blocked = 1;
        data->is_port_headroom_blocked = 1;
        data->is_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_headroom_extension_blocked = 1;
        data->is_total_headroom_blocked = 1;
        data->is_port_headroom_blocked = 1;
        data->is_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_headroom_extension_blocked = 0;
        data->is_total_headroom_blocked = 1;
        data->is_port_headroom_blocked = 0;
        data->is_pg_headroom_blocked = 0;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (4 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_headroom_extension_blocked = 0;
        data->is_total_headroom_blocked = 0;
        data->is_port_headroom_blocked = 1;
        data->is_pg_headroom_blocked = 0;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (5 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_headroom_extension_blocked = 1;
        data->is_total_headroom_blocked = 0;
        data->is_port_headroom_blocked = 0;
        data->is_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (6 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_headroom_extension_blocked = 1;
        data->is_total_headroom_blocked = 0;
        data->is_port_headroom_blocked = 1;
        data->is_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (7 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_headroom_extension_blocked = 0;
        data->is_total_headroom_blocked = 1;
        data->is_port_headroom_blocked = 1;
        data->is_pg_headroom_blocked = 0;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }
    if (8 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_vsq_sram_rjct_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
        data->is_total_shared_blocked = 1;
        data->is_port_pg_shared_blocked = 1;
        data->is_headroom_extension_blocked = 1;
        data->is_total_headroom_blocked = 1;
        data->is_port_headroom_blocked = 1;
        data->is_pg_headroom_blocked = 1;
        data->vsq_guaranteed_status = DBAL_ENUM_FVAL_VSQ_GUARANTEED_STATUS_BLOCKED;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table dp_global_sram_buffer_drop
 * Module - 'ingr_congestion', Submodule - 'init', table - 'dp_global_sram_buffer_drop'
 * Amount of free sram buffer resource to cause drop per DP
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_set(
    int unit)
{
    int dp_index;
    dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_init;
    int table_index = dnx_data_ingr_congestion_init_table_dp_global_sram_buffer_drop;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 4;
    table->info_get.key_size[0] = 4;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_init_table_dp_global_sram_buffer_drop");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->set_threshold = 0;
    default_data->clear_threshold = 0;
    /* Set Default Values */
    for (dp_index = 0; dp_index < table->keys[0].size; dp_index++)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, dp_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->set_threshold = 64;
        data->clear_threshold = 112;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->set_threshold = 128;
        data->clear_threshold = 176;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->set_threshold = 176;
        data->clear_threshold = 240;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->set_threshold = 240;
        data->clear_threshold = 288;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table dp_global_sram_pdb_drop
 * Module - 'ingr_congestion', Submodule - 'init', table - 'dp_global_sram_pdb_drop'
 * Amount of free sram pdb resource to cause drop per DP
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_set(
    int unit)
{
    int dp_index;
    dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_init;
    int table_index = dnx_data_ingr_congestion_init_table_dp_global_sram_pdb_drop;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 4;
    table->info_get.key_size[0] = 4;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_init_table_dp_global_sram_pdb_drop");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->set_threshold = 0;
    default_data->clear_threshold = 0;
    /* Set Default Values */
    for (dp_index = 0; dp_index < table->keys[0].size; dp_index++)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, dp_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->set_threshold = 64;
        data->clear_threshold = 112;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->set_threshold = 128;
        data->clear_threshold = 176;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->set_threshold = 176;
        data->clear_threshold = 240;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->set_threshold = 240;
        data->clear_threshold = 288;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table dp_global_dram_bdb_drop
 * Module - 'ingr_congestion', Submodule - 'init', table - 'dp_global_dram_bdb_drop'
 * Amount of free dram bdb resource to cause drop per DP
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_set(
    int unit)
{
    int dp_index;
    dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_init;
    int table_index = dnx_data_ingr_congestion_init_table_dp_global_dram_bdb_drop;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 4;
    table->info_get.key_size[0] = 4;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_init_table_dp_global_dram_bdb_drop");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->set_threshold = 0;
    default_data->clear_threshold = 0;
    /* Set Default Values */
    for (dp_index = 0; dp_index < table->keys[0].size; dp_index++)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, dp_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->set_threshold = 128;
        data->clear_threshold = 128;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->set_threshold = 144;
        data->clear_threshold = 144;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->set_threshold = 192;
        data->clear_threshold = 192;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->set_threshold = 224;
        data->clear_threshold = 224;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table equivalent_global_drop
 * Module - 'ingr_congestion', Submodule - 'init', table - 'equivalent_global_drop'
 * Equavalent amount per VOQ resource to per-DP global drop (not configurable by user)
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_init_equivalent_global_drop_set(
    int unit)
{
    int type_index;
    dnx_data_ingr_congestion_init_equivalent_global_drop_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_init;
    int table_index = dnx_data_ingr_congestion_init_table_equivalent_global_drop;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 3;
    table->info_get.key_size[0] = 3;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_init_equivalent_global_drop_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_init_table_equivalent_global_drop");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_init_equivalent_global_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->drop = 0;
    /* Set Default Values */
    for (type_index = 0; type_index < table->keys[0].size; type_index++)
    {
        data = (dnx_data_ingr_congestion_init_equivalent_global_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DNX_INGRESS_CONGESTION_RESOURCE_TOTAL_BYTES < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_equivalent_global_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_RESOURCE_TOTAL_BYTES, 0);
        data->drop = dnx_data_ingr_congestion.init.dp_global_dram_bdb_drop_get(unit, 3)->set_threshold*32*1024*10/3;
    }
    if (DNX_INGRESS_CONGESTION_RESOURCE_SRAM_BUFFERS < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_equivalent_global_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_BUFFERS, 0);
        data->drop = dnx_data_ingr_congestion.init.dp_global_sram_buffer_drop_get(unit, 3)->set_threshold;
    }
    if (DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_init_equivalent_global_drop_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS, 0);
        data->drop = dnx_data_ingr_congestion.init.dp_global_dram_bdb_drop_get(unit, 3)->set_threshold*4*4/3;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: dbal
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set numeric admission_test_nof
 * numeric info:
 * Number of admission test
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_admission_test_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_admission_test_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 37;

    /* Set value */
    define->data = 37;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric dram_bdbs_th_nof_bits
 * numeric info:
 * Number of bits dram bdbs set/clear threshold
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_dram_bdbs_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_dram_bdbs_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_system_red.info.resource_get(unit, DNX_SYSTEM_RED_RESOURCE_DRAM_BDBS)->hw_resolution_nof_bits+1;

    /* Set value */
    define->data = dnx_data_system_red.info.resource_get(unit, DNX_SYSTEM_RED_RESOURCE_DRAM_BDBS)->hw_resolution_nof_bits+1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_pdbs_th_nof_bits
 * numeric info:
 * Number of bits sram pdbs set/clear threshold
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_pdbs_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_pdbs_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_system_red.info.resource_get(unit, DNX_SYSTEM_RED_RESOURCE_SRAM_PDBS)->hw_resolution_nof_bits+1;

    /* Set value */
    define->data = dnx_data_system_red.info.resource_get(unit, DNX_SYSTEM_RED_RESOURCE_SRAM_PDBS)->hw_resolution_nof_bits+1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_buffer_th_nof_bits
 * numeric info:
 * Number of bits sram buffer set/clear threshold
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_BUFFERS)->hw_resolution_nof_bits;

    /* Set value */
    define->data = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_BUFFERS)->hw_resolution_nof_bits;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_buffer_free_th_nof_bits
 * numeric info:
 * Number of bits sram buffer set/clear threshold for reaching full size of the resource
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_free_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_free_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.dbal.sram_buffer_th_nof_bits_get(unit)+1;

    /* Set value */
    define->data = dnx_data_ingr_congestion.dbal.sram_buffer_th_nof_bits_get(unit)+1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_pds_th_nof_bits
 * numeric info:
 * Number of bits sram PDs set/clear threshold
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_pds_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_pds_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS)->hw_resolution_nof_bits;

    /* Set value */
    define->data = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_SRAM_PDS)->hw_resolution_nof_bits;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric total_bytes_th_nof_bits
 * numeric info:
 * Number of bits total bytes set/clear threshold
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_total_bytes_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_total_bytes_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_TOTAL_BYTES)->hw_resolution_nof_bits;

    /* Set value */
    define->data = dnx_data_ingr_congestion.info.resource_get(unit, DNX_INGRESS_CONGESTION_RESOURCE_TOTAL_BYTES)->hw_resolution_nof_bits;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric dram_bdbs_nof_bits
 * numeric info:
 * Number of bits for dram bdbs
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_dram_bdbs_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_dram_bdbs_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 18;

    /* Set value */
    define->data = 18;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_pdbs_nof_bits
 * numeric info:
 * Number of bits for sram pdbs
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_pdbs_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_pdbs_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_buffer_nof_bits
 * numeric info:
 * Number of bits for sram buffer
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 17;

    /* Set value */
    define->data = 17;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sqm_debug_pkt_ctr_nof_bits
 * numeric info:
 * Number of bits for SRAM Queue Manager enqueued/dequeued packets degug counters
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sqm_debug_pkt_ctr_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sqm_debug_pkt_ctr_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 48;

    /* Set value */
    define->data = 48;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_buffer_per_pool_nof_bits
 * numeric info:
 * Number of bits SRAM Buffers per pool
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_per_pool_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_per_pool_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_pds_per_pool_nof_bits
 * numeric info:
 * Number of bits SRAM PDs per pool
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_pds_per_pool_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_pds_per_pool_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 13;

    /* Set value */
    define->data = 13;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric compensation_delta_nof_bits
 * numeric info:
 * Number of bits for header delta
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_compensation_delta_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_compensation_delta_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_buffer_size_voq_occupancy_nof_bits
 * numeric info:
 * Number of bits for SRAM buffer size for CGM_VOQ_OCCUPANCY dbal
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_size_voq_occupancy_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_size_voq_occupancy_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric size_in_words_sram_voq_occupancy_nof_bits
 * numeric info:
 * Number of bits for SRAM words size for CGM_VOQ_OCCUPANCY dbal
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_size_in_words_sram_voq_occupancy_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_size_in_words_sram_voq_occupancy_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_pds_size_occupancy_nof_bits
 * numeric info:
 * Number of bits for SRAM pd size for CGM_VOQ_OCCUPANCY and VSQ_GROUP_OCCUPANCY dbal
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_pds_size_occupancy_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_pds_size_occupancy_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 17;

    /* Set value */
    define->data = 17;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_buffer_size_vsq_occupancy_nof_bits
 * numeric info:
 * Number of bits for SRAM buffer size for VSQ_GROUP_OCCUPANCY dbal
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_size_vsq_occupancy_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_size_vsq_occupancy_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 24;

    /* Set value */
    define->data = 24;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric size_in_words_occupancy_nof_bits
 * numeric info:
 * Number of bits for VOQ combined Words size for CGM_VOQ_OCCUPANCY dbal
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_size_in_words_occupancy_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_size_in_words_occupancy_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 28;

    /* Set value */
    define->data = 28;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric dram_bounds_sram_words_th_nof_bits
 * numeric info:
 * Number of bits for SRAM words threshold
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_dram_bounds_sram_words_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_dram_bounds_sram_words_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_buffers_vsq_th_nof_bits
 * numeric info:
 * Number of bits for VSQ SRAM buffer threshold
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffers_vsq_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_buffers_vsq_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sram_vsq_pds_th_nof_bits
 * numeric info:
 * Number of bits for VSQ PDS threshold
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_sram_vsq_pds_th_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int define_index = dnx_data_ingr_congestion_dbal_define_sram_vsq_pds_th_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 13;

    /* Set value */
    define->data = 13;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table admission_bits_mapping
 * Module - 'ingr_congestion', Submodule - 'dbal', table - 'admission_bits_mapping'
 * Mapping of bits in addmission mask
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_dbal_admission_bits_mapping_set(
    int unit)
{
    int rjct_bit_index;
    dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    int table_index = dnx_data_ingr_congestion_dbal_table_admission_bits_mapping;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_INGRESS_CONGESTION_REJECT_BIT_NOF;
    table->info_get.key_size[0] = DNX_INGRESS_CONGESTION_REJECT_BIT_NOF;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_dbal_admission_bits_mapping_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_dbal_table_admission_bits_mapping");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->index = -1;
    /* Set Default Values */
    for (rjct_bit_index = 0; rjct_bit_index < table->keys[0].size; rjct_bit_index++)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, rjct_bit_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SRAM_PDS_TOTAL_SHARED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SRAM_PDS_TOTAL_SHARED, 0);
        data->index = 0;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SRAM_PDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SRAM_PDS_MAX_SIZE, 0);
        data->index = 1;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SRAM_BUFFERS_TOTAL_SHARED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SRAM_BUFFERS_TOTAL_SHARED, 0);
        data->index = 2;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SRAM_BUFFERS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SRAM_BUFFERS_MAX_SIZE, 0);
        data->index = 3;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_WORDS_TOTAL_SHARED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_WORDS_TOTAL_SHARED, 0);
        data->index = 4;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_WORDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_WORDS_MAX_SIZE, 0);
        data->index = 5;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SYSTEM_RED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_SYSTEM_RED, 0);
        data->index = 6;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_WRED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_WRED, 0);
        data->index = 7;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_DRAM_BLOCK < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VOQ_DRAM_BLOCK, 0);
        data->index = 8;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_SRAM_PDS_TOTAL_SHARED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_SRAM_PDS_TOTAL_SHARED, 0);
        data->index = 9;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_SRAM_PDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_SRAM_PDS_MAX_SIZE, 0);
        data->index = 10;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_D_SRAM_PDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_D_SRAM_PDS_MAX_SIZE, 0);
        data->index = 11;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_C_SRAM_PDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_C_SRAM_PDS_MAX_SIZE, 0);
        data->index = 12;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_B_SRAM_PDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_B_SRAM_PDS_MAX_SIZE, 0);
        data->index = 13;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_A_SRAM_PDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_A_SRAM_PDS_MAX_SIZE, 0);
        data->index = 14;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_SRAM_BUFFERS_TOTAL_SHARED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_SRAM_BUFFERS_TOTAL_SHARED, 0);
        data->index = 15;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_SRAM_BUFFERS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_SRAM_BUFFERS_MAX_SIZE, 0);
        data->index = 16;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_D_SRAM_BUFFERS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_D_SRAM_BUFFERS_MAX_SIZE, 0);
        data->index = 17;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_C_SRAM_BUFFERS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_C_SRAM_BUFFERS_MAX_SIZE, 0);
        data->index = 18;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_B_SRAM_BUFFERS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_B_SRAM_BUFFERS_MAX_SIZE, 0);
        data->index = 19;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_A_SRAM_BUFFERS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_A_SRAM_BUFFERS_MAX_SIZE, 0);
        data->index = 20;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_WORDS_TOTAL_SHARED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_WORDS_TOTAL_SHARED, 0);
        data->index = 21;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_WORDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_F_WORDS_MAX_SIZE, 0);
        data->index = 22;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_D_WORDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_D_WORDS_MAX_SIZE, 0);
        data->index = 23;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_C_WORDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_C_WORDS_MAX_SIZE, 0);
        data->index = 24;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_B_WORDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_B_WORDS_MAX_SIZE, 0);
        data->index = 25;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_A_WORDS_MAX_SIZE < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_A_WORDS_MAX_SIZE, 0);
        data->index = 26;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_F_WORDS_WRED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_F_WORDS_WRED, 0);
        data->index = 27;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_WORDS_WRED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_E_WORDS_WRED, 0);
        data->index = 28;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_D_WORDS_WRED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_D_WORDS_WRED, 0);
        data->index = 29;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_C_WORDS_WRED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_C_WORDS_WRED, 0);
        data->index = 30;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_B_WORDS_WRED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_B_WORDS_WRED, 0);
        data->index = 31;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_A_WORDS_WRED < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_VSQ_A_WORDS_WRED, 0);
        data->index = 32;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_DRAM_BDBS_OCCUPANCY < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_DRAM_BDBS_OCCUPANCY, 0);
        data->index = 33;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_SRAM_BUFFERS_OCCUPANCY < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_SRAM_BUFFERS_OCCUPANCY, 0);
        data->index = 34;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_SRAM_PDS_OCCUPANCY < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_SRAM_PDS_OCCUPANCY, 0);
        data->index = 35;
    }
    if (DNX_INGRESS_CONGESTION_REJECT_BIT_DP_LEVEL < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_dbal_admission_bits_mapping_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_INGRESS_CONGESTION_REJECT_BIT_DP_LEVEL, 0);
        data->index = 36;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: sram_buffer
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_drop_profiles
 * define info:
 * number of profiles, used for drop logic
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_sram_buffer_nof_drop_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_sram_buffer;
    int define_index = dnx_data_ingr_congestion_sram_buffer_define_nof_drop_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_drop_profiles_bits
 * numeric info:
 * number of bits in drop profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_sram_buffer_nof_drop_profiles_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_sram_buffer;
    int define_index = dnx_data_ingr_congestion_sram_buffer_define_nof_drop_profiles_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = utilex_log2_round_up(dnx_data_ingr_congestion.sram_buffer.nof_drop_profiles_get(unit));

    /* Set value */
    define->data = utilex_log2_round_up(dnx_data_ingr_congestion.sram_buffer.nof_drop_profiles_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table drop_tresholds
 * Module - 'ingr_congestion', Submodule - 'sram_buffer', table - 'drop_tresholds'
 * free sram buffers drop thresholds
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_ingr_congestion_sram_buffer_drop_tresholds_set(
    int unit)
{
    int index_index;
    dnx_data_ingr_congestion_sram_buffer_drop_tresholds_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = dnx_data_ingr_congestion_submodule_sram_buffer;
    int table_index = dnx_data_ingr_congestion_sram_buffer_table_drop_tresholds;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 3;
    table->info_get.key_size[0] = 3;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_ingr_congestion_sram_buffer_drop_tresholds_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_ingr_congestion_sram_buffer_table_drop_tresholds");

    /* Store Default Values */
    default_data = (dnx_data_ingr_congestion_sram_buffer_drop_tresholds_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->value = 0;
    /* Set Default Values */
    for (index_index = 0; index_index < table->keys[0].size; index_index++)
    {
        data = (dnx_data_ingr_congestion_sram_buffer_drop_tresholds_t *) dnxc_data_mgmt_table_data_get(unit, table, index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_sram_buffer_drop_tresholds_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->value = 100;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_sram_buffer_drop_tresholds_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->value = 200;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_ingr_congestion_sram_buffer_drop_tresholds_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->value = 300;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jr2_a0_data_ingr_congestion_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_ingr_congestion;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: config
     */
    submodule_index = dnx_data_ingr_congestion_submodule_config;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_config_define_guarantee_mode;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_config_guarantee_mode_set;
    data_index = dnx_data_ingr_congestion_config_define_wred_packet_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_config_wred_packet_size_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_ingr_congestion_config_pp_port_by_reassembly_overwrite;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_ingr_congestion_config_pp_port_by_reassembly_overwrite_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: info
     */
    submodule_index = dnx_data_ingr_congestion_submodule_info;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_info_define_threshold_granularity;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_threshold_granularity_set;
    data_index = dnx_data_ingr_congestion_info_define_words_resolution;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_words_resolution_set;
    data_index = dnx_data_ingr_congestion_info_define_bytes_threshold_granularity;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_bytes_threshold_granularity_set;
    data_index = dnx_data_ingr_congestion_info_define_nof_dropped_reasons_cgm;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_nof_dropped_reasons_cgm_set;
    data_index = dnx_data_ingr_congestion_info_define_wred_max_gain;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_wred_max_gain_set;
    data_index = dnx_data_ingr_congestion_info_define_wred_granularity;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_wred_granularity_set;
    data_index = dnx_data_ingr_congestion_info_define_nof_pds_in_pdb;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_nof_pds_in_pdb_set;
    data_index = dnx_data_ingr_congestion_info_define_max_jumbo_packet_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_max_jumbo_packet_size_set;
    data_index = dnx_data_ingr_congestion_info_define_max_sram_pdbs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_max_sram_pdbs_set;
    data_index = dnx_data_ingr_congestion_info_define_max_dram_bdbs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_max_dram_bdbs_set;
    data_index = dnx_data_ingr_congestion_info_define_max_total_bytes;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_max_total_bytes_set;
    data_index = dnx_data_ingr_congestion_info_define_nof_active_drams;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_nof_active_drams_set;
    data_index = dnx_data_ingr_congestion_info_define_total_bytes;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_info_total_bytes_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_ingr_congestion_info_cgm_hw_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_ingr_congestion_info_cgm_hw_support_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_ingr_congestion_info_table_resource;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_info_resource_set;
    data_index = dnx_data_ingr_congestion_info_table_dp_free_res_presentage_drop;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_info_dp_free_res_presentage_drop_set;
    data_index = dnx_data_ingr_congestion_info_table_admission_preferences;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_info_admission_preferences_set;
    /*
     * Attach submodule: fadt_tail_drop
     */
    submodule_index = dnx_data_ingr_congestion_submodule_fadt_tail_drop;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_fadt_tail_drop_define_default_max_size_byte_threshold_for_ocb_only;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_fadt_tail_drop_default_max_size_byte_threshold_for_ocb_only_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: dram_bound
     */
    submodule_index = dnx_data_ingr_congestion_submodule_dram_bound;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_dram_bound_define_fadt_alpha_min;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dram_bound_fadt_alpha_min_set;
    data_index = dnx_data_ingr_congestion_dram_bound_define_fadt_alpha_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dram_bound_fadt_alpha_max_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_ingr_congestion_dram_bound_table_resource;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_dram_bound_resource_set;
    /*
     * Attach submodule: voq
     */
    submodule_index = dnx_data_ingr_congestion_submodule_voq;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_voq_define_nof_rate_class;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_voq_nof_rate_class_set;
    data_index = dnx_data_ingr_congestion_voq_define_rate_class_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_voq_rate_class_nof_bits_set;
    data_index = dnx_data_ingr_congestion_voq_define_nof_compensation_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_voq_nof_compensation_profiles_set;
    data_index = dnx_data_ingr_congestion_voq_define_default_compensation;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_voq_default_compensation_set;
    data_index = dnx_data_ingr_congestion_voq_define_voq_congestion_notification_fifo_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_voq_voq_congestion_notification_fifo_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: vsq
     */
    submodule_index = dnx_data_ingr_congestion_submodule_vsq;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_rate_class_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_rate_class_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_a_rate_class_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_a_rate_class_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_a_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_a_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_b_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_b_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_c_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_c_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_d_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_d_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_e_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_e_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_e_hw_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_e_hw_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_f_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_f_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_f_hw_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_f_hw_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_pool_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_pool_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_connection_class_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_connection_class_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_tc_pg_profile_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_tc_pg_profile_nof_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_e_congestion_notification_fifo_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_e_congestion_notification_fifo_size_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_f_congestion_notification_fifo_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_f_congestion_notification_fifo_size_set;
    data_index = dnx_data_ingr_congestion_vsq_define_oversubscription_bubble_width;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_oversubscription_bubble_width_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_e_default;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_e_default_set;
    data_index = dnx_data_ingr_congestion_vsq_define_vsq_f_default;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_vsq_vsq_f_default_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_ingr_congestion_vsq_size_watermark_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_ingr_congestion_vsq_size_watermark_support_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_ingr_congestion_vsq_table_info;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_vsq_info_set;
    /*
     * Attach submodule: init
     */
    submodule_index = dnx_data_ingr_congestion_submodule_init;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_init_define_fifo_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_init_fifo_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_ingr_congestion_init_table_vsq_words_rjct_map;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_init_vsq_words_rjct_map_set;
    data_index = dnx_data_ingr_congestion_init_table_vsq_sram_rjct_map;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_init_vsq_sram_rjct_map_set;
    data_index = dnx_data_ingr_congestion_init_table_dp_global_sram_buffer_drop;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_init_dp_global_sram_buffer_drop_set;
    data_index = dnx_data_ingr_congestion_init_table_dp_global_sram_pdb_drop;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_init_dp_global_sram_pdb_drop_set;
    data_index = dnx_data_ingr_congestion_init_table_dp_global_dram_bdb_drop;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_init_dp_global_dram_bdb_drop_set;
    data_index = dnx_data_ingr_congestion_init_table_equivalent_global_drop;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_init_equivalent_global_drop_set;
    /*
     * Attach submodule: dbal
     */
    submodule_index = dnx_data_ingr_congestion_submodule_dbal;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_dbal_define_admission_test_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_admission_test_nof_set;
    data_index = dnx_data_ingr_congestion_dbal_define_dram_bdbs_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_dram_bdbs_th_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_pdbs_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_pdbs_th_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_th_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_free_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_free_th_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_pds_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_pds_th_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_total_bytes_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_total_bytes_th_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_dram_bdbs_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_dram_bdbs_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_pdbs_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_pdbs_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sqm_debug_pkt_ctr_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sqm_debug_pkt_ctr_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_per_pool_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_per_pool_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_pds_per_pool_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_pds_per_pool_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_compensation_delta_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_compensation_delta_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_size_voq_occupancy_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_size_voq_occupancy_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_size_in_words_sram_voq_occupancy_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_size_in_words_sram_voq_occupancy_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_pds_size_occupancy_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_pds_size_occupancy_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_buffer_size_vsq_occupancy_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffer_size_vsq_occupancy_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_size_in_words_occupancy_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_size_in_words_occupancy_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_dram_bounds_sram_words_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_dram_bounds_sram_words_th_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_buffers_vsq_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_buffers_vsq_th_nof_bits_set;
    data_index = dnx_data_ingr_congestion_dbal_define_sram_vsq_pds_th_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_dbal_sram_vsq_pds_th_nof_bits_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_ingr_congestion_dbal_table_admission_bits_mapping;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_dbal_admission_bits_mapping_set;
    /*
     * Attach submodule: sram_buffer
     */
    submodule_index = dnx_data_ingr_congestion_submodule_sram_buffer;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_ingr_congestion_sram_buffer_define_nof_drop_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_sram_buffer_nof_drop_profiles_set;
    data_index = dnx_data_ingr_congestion_sram_buffer_define_nof_drop_profiles_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_ingr_congestion_sram_buffer_nof_drop_profiles_bits_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_ingr_congestion_sram_buffer_table_drop_tresholds;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_ingr_congestion_sram_buffer_drop_tresholds_set;

    SHR_FUNC_EXIT;
}
#undef BSL_LOG_MODULE
/* *INDENT-ON* */
