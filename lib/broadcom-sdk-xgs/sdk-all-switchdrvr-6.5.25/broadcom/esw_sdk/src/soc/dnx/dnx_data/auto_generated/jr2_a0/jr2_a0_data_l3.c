/** \file jr2_a0_data_l3.c
 * 
 * DEVICE DATA - L3
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_L3
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_l3.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_lif.h>
#include <shared/utilex/utilex_integer_arithmetic.h>
#include <bcm_int/dnx/l3/l3_fec.h>
#include <bcm_int/dnx/l3/l3_vrrp.h>
/*
 * }
 */

/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: egr_pointed
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define first_egr_pointed_id
 * define info:
 * Identifier of very first virtual egress pointed object.                            Range is from 'first_egr_pointed_id' to 'nof_egr_pointed_ids - 1'
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_egr_pointed_first_egr_pointed_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_egr_pointed;
    int define_index = dnx_data_l3_egr_pointed_define_first_egr_pointed_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_egr_pointed_ids
 * numeric info:
 * Number of virtual egress pointed object ids
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_egr_pointed_nof_egr_pointed_ids_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_egr_pointed;
    int define_index = dnx_data_l3_egr_pointed_define_nof_egr_pointed_ids;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_l3.egr_pointed.nof_bits_in_egr_pointed_id_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_l3.egr_pointed.nof_bits_in_egr_pointed_id_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_bits_in_egr_pointed_id
 * numeric info:
 * Number of bits representing one virtual egress pointed object id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_egr_pointed;
    int define_index = dnx_data_l3_egr_pointed_define_nof_bits_in_egr_pointed_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.out_lif.outlif_pointer_size_get(unit);

    /* Set value */
    define->data = dnx_data_lif.out_lif.outlif_pointer_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: fec
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_separate_fwd_rpf_dbs_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int feature_index = dnx_data_l3_fec_separate_fwd_rpf_dbs;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_uneven_bank_sizes_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int feature_index = dnx_data_l3_fec_uneven_bank_sizes;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_mc_rpf_sip_based_supported_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int feature_index = dnx_data_l3_fec_mc_rpf_sip_based_supported;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define nof_fecs
 * define info:
 * The maximal number of FECs supported by the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_nof_fecs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_fecs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xC0000;

    /* Set value */
    define->data = 0xC0000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define first_valid_fec_ecmp_id
 * define info:
 * The ID of the first valid FEC/ECMP group which can be created.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_first_valid_fec_ecmp_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_first_valid_fec_ecmp_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fec_id_for_single_dhb_cluster_pair_granularity
 * define info:
 * The maximal FEC ID that support a single DHB cluasters pair.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_max_fec_id_for_single_dhb_cluster_pair_granularity_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_fec_id_for_single_dhb_cluster_pair_granularity;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MIN(dnx_data_l3.fec.nof_fecs_get(unit),0x80000)-1;

    /* Set value */
    define->data = UTILEX_MIN(dnx_data_l3.fec.nof_fecs_get(unit),0x80000)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fec_id_for_double_dhb_cluster_pair_granularity
 * define info:
 * The maximal FEC ID that requiere an even number of DHB clusters pairs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_max_fec_id_for_double_dhb_cluster_pair_granularity_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_fec_id_for_double_dhb_cluster_pair_granularity;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.fec.nof_fecs_get(unit)-1;

    /* Set value */
    define->data = dnx_data_l3.fec.nof_fecs_get(unit)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_default_fec
 * define info:
 * The maximal FEC id that can be used for default route.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_max_default_fec_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_default_fec;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1FFFF;

    /* Set value */
    define->data = 0x1FFFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define bank_size
 * define info:
 * The smallest number of FECs which belong to the same hierarchy.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_bank_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_bank_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 26214;

    /* Set value */
    define->data = 26214;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define bank_size_round_up
 * define info:
 * In some cases FEC bank size contains extra FECs due to round up which results from physical to logical translation.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_bank_size_round_up_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_bank_size_round_up;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.fec.bank_size_get(unit)+2;

    /* Set value */
    define->data = dnx_data_l3.fec.bank_size_get(unit)+2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_nof_super_fecs_per_bank
 * define info:
 * The max NOF SUPER FEC IDs per resource manager bank.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_max_nof_super_fecs_per_bank_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_nof_super_fecs_per_bank;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.fec.bank_size_round_up_get(unit)/2;

    /* Set value */
    define->data = dnx_data_l3.fec.bank_size_round_up_get(unit)/2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_physical_fecs_per_bank
 * define info:
 * The number of physical FEC IDs per bank.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_nof_physical_fecs_per_bank_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_physical_fecs_per_bank;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8192;

    /* Set value */
    define->data = 8192;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define bank_nof_physical_rows
 * define info:
 * The NOF rows that a FEC bank has.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_bank_nof_physical_rows_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_bank_nof_physical_rows;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x2000;

    /* Set value */
    define->data = 0x2000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define super_fec_size
 * define info:
 * The number of bits of a single super FEC in the MDB.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_super_fec_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_super_fec_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 150;

    /* Set value */
    define->data = 150;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_nof_banks
 * define info:
 * The maximal NOF possible banks in the device (not MDB profile dependent).
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_max_nof_banks_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_nof_banks;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_l3.fec.nof_fecs_get(unit)/dnx_data_l3.fec.bank_size_get(unit));

    /* Set value */
    define->data = (dnx_data_l3.fec.nof_fecs_get(unit)/dnx_data_l3.fec.bank_size_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define first_bank_without_id_alloc
 * define info:
 * the first fec allocation bank that can be used for allocating FECs without an ID.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_first_bank_without_id_alloc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_first_bank_without_id_alloc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_l3.ecmp.total_nof_ecmp_get(unit) + dnx_data_l3.fec.bank_size_get(unit) - 1)/dnx_data_l3.fec.bank_size_get(unit);

    /* Set value */
    define->data = (dnx_data_l3.ecmp.total_nof_ecmp_get(unit) + dnx_data_l3.fec.bank_size_get(unit) - 1)/dnx_data_l3.fec.bank_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define first_shared_bank
 * define info:
 * The first FEC bank id index which has values in the ECMP and the FEC ranges.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_first_shared_bank_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_first_shared_bank;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_l3.fec.first_bank_without_id_alloc_get(unit) - 1);

    /* Set value */
    define->data = (dnx_data_l3.fec.first_bank_without_id_alloc_get(unit) - 1);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_super_fec_id
 * define info:
 * The max ID of the super FEC.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_max_super_fec_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_super_fec_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_l3.fec.nof_fecs_get(unit)/2-1);

    /* Set value */
    define->data = (dnx_data_l3.fec.nof_fecs_get(unit)/2-1);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fec_directions
 * define info:
 * The number of FEC directions.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_nof_fec_directions_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_fec_directions;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_dpc_fec_db
 * define info:
 * The number of DPC FEC DBs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_nof_dpc_fec_db_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_dpc_fec_db;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fec_dbs_all_cores
 * define info:
 * The number of FEC DBs for all cores.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_nof_fec_dbs_all_cores_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_fec_dbs_all_cores;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_mdb.direct.nof_fec_dbs_get(unit) - dnx_data_l3.fec.nof_dpc_fec_db_get(unit) + (dnx_data_l3.fec.nof_dpc_fec_db_get(unit) * dnx_data_device.general.nof_cores_get(unit)));

    /* Set value */
    define->data = (dnx_data_mdb.direct.nof_fec_dbs_get(unit) - dnx_data_l3.fec.nof_dpc_fec_db_get(unit) + (dnx_data_l3.fec.nof_dpc_fec_db_get(unit) * dnx_data_device.general.nof_cores_get(unit)));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fec_result_types
 * define info:
 * The number of result types in fec_result_type_fields
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_nof_fec_result_types_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_fec_result_types;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric fer_hw_version
 * numeric info:
 * This value indicates the HW version of the FER
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_fer_hw_version_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_fer_hw_version;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = DNX_L3_FER_HW_VERSION_1;

    /* Set value */
    define->data = DNX_L3_FER_HW_VERSION_1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric fec_property_supported_flags
 * numeric info:
 * Supported BCM_SWITCH_FEC_PROPERTY_* flags to verify the bcm_switch_fec_property_get API.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_fec_property_supported_flags_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_fec_property_supported_flags;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (BCM_SWITCH_FEC_PROPERTY_1ST_HIERARCHY | BCM_SWITCH_FEC_PROPERTY_2ND_HIERARCHY | BCM_SWITCH_FEC_PROPERTY_3RD_HIERARCHY);

    /* Set value */
    define->data = (BCM_SWITCH_FEC_PROPERTY_1ST_HIERARCHY | BCM_SWITCH_FEC_PROPERTY_2ND_HIERARCHY | BCM_SWITCH_FEC_PROPERTY_3RD_HIERARCHY);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table fec_resource_info
 * Module - 'l3', Submodule - 'fec', table - 'fec_resource_info'
 * FEC recource types information
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_fec_resource_info_set(
    int unit)
{
    int resource_type_index;
    dnx_data_l3_fec_fec_resource_info_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int table_index = dnx_data_l3_fec_table_fec_resource_info;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 4;
    table->info_get.key_size[0] = 4;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fec_fec_resource_info_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_fec_table_fec_resource_info");

    /* Store Default Values */
    default_data = (dnx_data_l3_fec_fec_resource_info_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->is_protection_type = 0;
    default_data->is_statistic_type = 0;
    /* Set Default Values */
    for (resource_type_index = 0; resource_type_index < table->keys[0].size; resource_type_index++)
    {
        data = (dnx_data_l3_fec_fec_resource_info_t *) dnxc_data_mgmt_table_data_get(unit, table, resource_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_NO_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_resource_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_NO_STAT, 0);
        data->is_protection_type = 0;
        data->is_statistic_type = 0;
    }
    if (DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_W_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_resource_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_W_STAT, 0);
        data->is_protection_type = 1;
        data->is_statistic_type = 1;
    }
    if (DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_NO_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_resource_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_NO_STAT, 0);
        data->is_protection_type = 1;
        data->is_statistic_type = 0;
    }
    if (DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_W_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_resource_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_W_STAT, 0);
        data->is_protection_type = 0;
        data->is_statistic_type = 1;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table super_fec_result_types_map
 * Module - 'l3', Submodule - 'fec', table - 'super_fec_result_types_map'
 * Map FEC dbal result type to an actual FEC type and FEC recource type.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_super_fec_result_types_map_set(
    int unit)
{
    int dbal_result_type_index;
    dnx_data_l3_fec_super_fec_result_types_map_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int table_index = dnx_data_l3_fec_table_super_fec_result_types_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 12;
    table->info_get.key_size[0] = 12;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fec_super_fec_result_types_map_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_fec_table_super_fec_result_types_map");

    /* Store Default Values */
    default_data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->fec_type_in_super_fec = 0;
    default_data->fec_resource_type = 0;
    /* Set Default Values */
    for (dbal_result_type_index = 0; dbal_result_type_index < table->keys[0].size; dbal_result_type_index++)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, dbal_result_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DBAL_RESULT_TYPE_SUPER_FEC_1ST_HIERARCHY_SUPER_FEC_NO_PROTECTION < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_1ST_HIERARCHY_SUPER_FEC_NO_PROTECTION, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_NO_PROTECTION_NO_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_NO_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_1ST_HIERARCHY_SUPER_FEC_W_PROTECTION_W_1_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_1ST_HIERARCHY_SUPER_FEC_W_PROTECTION_W_1_STAT, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_W_PROTECTION_W_1_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_W_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_1ST_HIERARCHY_SUPER_FEC_W_PROTECTION < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_1ST_HIERARCHY_SUPER_FEC_W_PROTECTION, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_W_PROTECTION_NO_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_NO_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_1ST_HIERARCHY_SUPER_FEC_NO_PROTECTION_W_2_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_1ST_HIERARCHY_SUPER_FEC_NO_PROTECTION_W_2_STAT, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_NO_PROTECTION_W_2_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_W_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_2ND_HIERARCHY_SUPER_FEC_NO_PROTECTION < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_2ND_HIERARCHY_SUPER_FEC_NO_PROTECTION, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_NO_PROTECTION_NO_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_NO_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_2ND_HIERARCHY_SUPER_FEC_W_PROTECTION_W_1_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_2ND_HIERARCHY_SUPER_FEC_W_PROTECTION_W_1_STAT, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_W_PROTECTION_W_1_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_W_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_2ND_HIERARCHY_SUPER_FEC_W_PROTECTION < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_2ND_HIERARCHY_SUPER_FEC_W_PROTECTION, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_W_PROTECTION_NO_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_NO_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_2ND_HIERARCHY_SUPER_FEC_NO_PROTECTION_W_2_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_2ND_HIERARCHY_SUPER_FEC_NO_PROTECTION_W_2_STAT, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_NO_PROTECTION_W_2_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_W_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_3RD_HIERARCHY_SUPER_FEC_NO_PROTECTION < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_3RD_HIERARCHY_SUPER_FEC_NO_PROTECTION, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_NO_PROTECTION_NO_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_NO_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_3RD_HIERARCHY_SUPER_FEC_W_PROTECTION_W_1_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_3RD_HIERARCHY_SUPER_FEC_W_PROTECTION_W_1_STAT, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_W_PROTECTION_W_1_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_W_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_3RD_HIERARCHY_SUPER_FEC_W_PROTECTION < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_3RD_HIERARCHY_SUPER_FEC_W_PROTECTION, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_W_PROTECTION_NO_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_W_PROT_NO_STAT;
    }
    if (DBAL_RESULT_TYPE_SUPER_FEC_3RD_HIERARCHY_SUPER_FEC_NO_PROTECTION_W_2_STAT < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_super_fec_result_types_map_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_RESULT_TYPE_SUPER_FEC_3RD_HIERARCHY_SUPER_FEC_NO_PROTECTION_W_2_STAT, 0);
        data->fec_type_in_super_fec = DBAL_FIELD_FEC_ENTRY_NO_PROTECTION_W_2_STATS;
        data->fec_resource_type = DBAL_ENUM_FVAL_FEC_RESOURCE_TYPE_NO_PROT_W_STAT;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table fec_result_type_fields
 * Module - 'l3', Submodule - 'fec', table - 'fec_result_type_fields'
 * FEC table result type information.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_fec_result_type_fields_set(
    int unit)
{
    int result_type_index;
    dnx_data_l3_fec_fec_result_type_fields_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int table_index = dnx_data_l3_fec_table_fec_result_type_fields;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 9;
    table->info_get.key_size[0] = 9;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fec_fec_result_type_fields_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_fec_table_fec_result_type_fields");

    /* Store Default Values */
    default_data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->has_global_outlif = 0;
    default_data->has_global_outlif_second = 0;
    default_data->has_mc_rpf = 0;
    default_data->has_eei = 0;
    default_data->has_htm = 0;
    /* Set Default Values */
    for (result_type_index = 0; result_type_index < table->keys[0].size; result_type_index++)
    {
        data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, result_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION, 0);
        data->has_mc_rpf = 1;
    }
    if (DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_EEI < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_EEI, 0);
        data->has_eei = 1;
    }
    if (DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0 < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0, 0);
        data->has_global_outlif = 1;
    }
    if (DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0_17BIT_LIF1 < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0_17BIT_LIF1, 0);
        data->has_global_outlif = 1;
        data->has_global_outlif_second = 1;
    }
    if (DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0_HTM < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0_HTM, 0);
        data->has_global_outlif = 1;
        data->has_htm = 1;
    }
    if (DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0_LIF1_MC_RPF < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0_LIF1_MC_RPF, 0);
        data->has_global_outlif = 1;
        data->has_global_outlif_second = 1;
        data->has_mc_rpf = 1;
    }
    if (DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0_MC_RPF < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_result_type_fields_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_IRPP_FEC_ENTRY_FORMAT_FEC_ENTRY_DESTINATION_LIF0_MC_RPF, 0);
        data->has_global_outlif = 1;
        data->has_mc_rpf = 1;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table fec_physical_db
 * Module - 'l3', Submodule - 'fec', table - 'fec_physical_db'
 * A list with FEC physical DBs
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_fec_physical_db_set(
    int unit)
{
    dnx_data_l3_fec_fec_physical_db_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int table_index = dnx_data_l3_fec_table_fec_physical_db;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Info - default values */
    table->values[0].default_val = "MDB_NOF_PHYSICAL_TABLES";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fec_fec_physical_db_t, (1 + 1 /* to store default value */ ), "data of dnx_data_l3_fec_table_fec_physical_db");

    /* Store Default Values */
    default_data = (dnx_data_l3_fec_fec_physical_db_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->physical_table[0] = MDB_NOF_PHYSICAL_TABLES;
    /* Set Default Values */
    data = (dnx_data_l3_fec_fec_physical_db_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    sal_memcpy(data, default_data, table->size_of_values);
    /*
     * Set Values - Entries
     */
    data = (dnx_data_l3_fec_fec_physical_db_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->physical_table[0] = MDB_PHYSICAL_TABLE_FEC_1;
    data->physical_table[1] = MDB_PHYSICAL_TABLE_FEC_2;
    data->physical_table[2] = MDB_PHYSICAL_TABLE_FEC_3;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table fec_tables_info
 * Module - 'l3', Submodule - 'fec', table - 'fec_tables_info'
 * FEC tables Information.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fec_fec_tables_info_set(
    int unit)
{
    int mdb_table_index;
    dnx_data_l3_fec_fec_tables_info_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int table_index = dnx_data_l3_fec_table_fec_tables_info;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = MDB_NOF_PHYSICAL_TABLES;
    table->info_get.key_size[0] = MDB_NOF_PHYSICAL_TABLES;

    /* Info - default values */
    table->values[0].default_val = "DBAL_NOF_TABLES";
    table->values[1].default_val = "DBAL_ENUM_FVAL_HIERARCHY_LEVEL_NO_HIERARCHY";
    table->values[2].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fec_fec_tables_info_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_fec_table_fec_tables_info");

    /* Store Default Values */
    default_data = (dnx_data_l3_fec_fec_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->dbal_table = DBAL_NOF_TABLES;
    default_data->hierarchy = DBAL_ENUM_FVAL_HIERARCHY_LEVEL_NO_HIERARCHY;
    default_data->index = 0;
    /* Set Default Values */
    for (mdb_table_index = 0; mdb_table_index < table->keys[0].size; mdb_table_index++)
    {
        data = (dnx_data_l3_fec_fec_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, mdb_table_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (MDB_PHYSICAL_TABLE_FEC_1 < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, MDB_PHYSICAL_TABLE_FEC_1, 0);
        data->dbal_table = DBAL_TABLE_SUPER_FEC_1ST_HIERARCHY;
        data->hierarchy = DBAL_ENUM_FVAL_HIERARCHY_LEVEL_HIERARCHY_LEVEL_1;
        data->index = 0;
    }
    if (MDB_PHYSICAL_TABLE_FEC_2 < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, MDB_PHYSICAL_TABLE_FEC_2, 0);
        data->dbal_table = DBAL_TABLE_SUPER_FEC_2ND_HIERARCHY;
        data->hierarchy = DBAL_ENUM_FVAL_HIERARCHY_LEVEL_HIERARCHY_LEVEL_2;
        data->index = 1;
    }
    if (MDB_PHYSICAL_TABLE_FEC_3 < table->keys[0].size)
    {
        data = (dnx_data_l3_fec_fec_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, MDB_PHYSICAL_TABLE_FEC_3, 0);
        data->dbal_table = DBAL_TABLE_SUPER_FEC_3RD_HIERARCHY;
        data->hierarchy = DBAL_ENUM_FVAL_HIERARCHY_LEVEL_HIERARCHY_LEVEL_3;
        data->index = 2;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: fer
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fer_mux_connection_supported_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fer;
    int feature_index = dnx_data_l3_fer_mux_connection_supported;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define mdb_granularity_ratio
 * define info:
 * This value indicate the ratio between the FER FEC granularity relative to the MDB
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fer_mdb_granularity_ratio_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fer;
    int define_index = dnx_data_l3_fer_define_mdb_granularity_ratio;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: source_address
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define source_address_table_size
 * define info:
 * The number of entries in the source address table.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_source_address_source_address_table_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_source_address;
    int define_index = dnx_data_l3_source_address_define_source_address_table_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define custom_sa_use_dual_homing
 * define info:
 * Indication whether ARP custom sa feature is using EEDB dual homing field or full mac address from source address table.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_source_address_custom_sa_use_dual_homing_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_source_address;
    int define_index = dnx_data_l3_source_address_define_custom_sa_use_dual_homing;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table address_type_info
 * Module - 'l3', Submodule - 'source_address', table - 'address_type_info'
 * Information about how many entries each address type takes in source_address_map table.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_source_address_address_type_info_set(
    int unit)
{
    int address_type_index;
    dnx_data_l3_source_address_address_type_info_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_source_address;
    int table_index = dnx_data_l3_source_address_table_address_type_info;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = source_address_type_count;
    table->info_get.key_size[0] = source_address_type_count;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_source_address_address_type_info_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_source_address_table_address_type_info");

    /* Store Default Values */
    default_data = (dnx_data_l3_source_address_address_type_info_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->nof_entries = 0;
    /* Set Default Values */
    for (address_type_index = 0; address_type_index < table->keys[0].size; address_type_index++)
    {
        data = (dnx_data_l3_source_address_address_type_info_t *) dnxc_data_mgmt_table_data_get(unit, table, address_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (source_address_type_default < table->keys[0].size)
    {
        data = (dnx_data_l3_source_address_address_type_info_t *) dnxc_data_mgmt_table_data_get(unit, table, source_address_type_default, 0);
        data->nof_entries = 1;
    }
    if (source_address_type_mac_prefix < table->keys[0].size)
    {
        data = (dnx_data_l3_source_address_address_type_info_t *) dnxc_data_mgmt_table_data_get(unit, table, source_address_type_mac_prefix, 0);
        data->nof_entries = 2;
    }
    if (source_address_type_ipv4 < table->keys[0].size)
    {
        data = (dnx_data_l3_source_address_address_type_info_t *) dnxc_data_mgmt_table_data_get(unit, table, source_address_type_ipv4, 0);
        data->nof_entries = 1;
    }
    if (source_address_type_ipv6 < table->keys[0].size)
    {
        data = (dnx_data_l3_source_address_address_type_info_t *) dnxc_data_mgmt_table_data_get(unit, table, source_address_type_ipv6, 0);
        data->nof_entries = 4;
    }
    if (source_address_type_mac_dual_homing < table->keys[0].size)
    {
        data = (dnx_data_l3_source_address_address_type_info_t *) dnxc_data_mgmt_table_data_get(unit, table, source_address_type_mac_dual_homing, 0);
        data->nof_entries = 2;
    }
    if (source_address_type_full_mac < table->keys[0].size)
    {
        data = (dnx_data_l3_source_address_address_type_info_t *) dnxc_data_mgmt_table_data_get(unit, table, source_address_type_full_mac, 0);
        data->nof_entries = 2;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: vrf
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_vrf
 * define info:
 * The maximal number of VRFs supported by the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrf_nof_vrf_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrf;
    int define_index = dnx_data_l3_vrf_define_nof_vrf;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 65536;

    /* Set value */
    define->data = 65536;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_vrf_ipv6
 * define info:
 * The maximal number of VRFs supported by the device for an IPv6 MC table.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrf_nof_vrf_ipv6_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrf;
    int define_index = dnx_data_l3_vrf_define_nof_vrf_ipv6;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16384;

    /* Set value */
    define->data = 16384;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: routing_enablers
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_ptc_routing_enable_profile_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int feature_index = dnx_data_l3_routing_enablers_ptc_routing_enable_profile_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define routing_enable_vector_length
 * define info:
 * The length in bits of the routing enablers vector.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_routing_enable_vector_length_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int define_index = dnx_data_l3_routing_enablers_define_routing_enable_vector_length;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.routing_enablers.routing_enable_indication_nof_bits_per_layer_get(unit) * dnx_data_l3.routing_enablers.routing_enable_nof_profiles_per_layer_get(unit) * dnx_data_device.general.max_nof_layer_protocols_get(unit);

    /* Set value */
    define->data = dnx_data_l3.routing_enablers.routing_enable_indication_nof_bits_per_layer_get(unit) * dnx_data_l3.routing_enablers.routing_enable_nof_profiles_per_layer_get(unit) * dnx_data_device.general.max_nof_layer_protocols_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define routing_enable_action_support
 * define info:
 * Indication whether routing enable action profiles are used to determine layer termination.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_routing_enable_action_support_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int define_index = dnx_data_l3_routing_enablers_define_routing_enable_action_support;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define routing_enable_action_profile_size
 * define info:
 * Size in bits of the routing enable action profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_routing_enable_action_profile_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int define_index = dnx_data_l3_routing_enablers_define_routing_enable_action_profile_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define routing_enable_indication_nof_bits_per_layer
 * define info:
 * Number of bits in the routing enable vector responsible for a single uc/mc indication per layer type.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_routing_enable_indication_nof_bits_per_layer_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int define_index = dnx_data_l3_routing_enablers_define_routing_enable_indication_nof_bits_per_layer;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define routing_enable_nof_profiles_per_layer
 * define info:
 * Number of routing enabled indications (UC/MC) per layer type.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_routing_enable_nof_profiles_per_layer_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int define_index = dnx_data_l3_routing_enablers_define_routing_enable_nof_profiles_per_layer;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define routing_enabled_action_profile_id
 * define info:
 * The ID of the action profile which indicates that layer termination is enabled
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_routing_enabled_action_profile_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int define_index = dnx_data_l3_routing_enablers_define_routing_enabled_action_profile_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table layer_enablers_by_id
 * Module - 'l3', Submodule - 'routing_enablers', table - 'layer_enablers_by_id'
 * List of layer types based on index
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_layer_enablers_by_id_set(
    int unit)
{
    int idx_index;
    dnx_data_l3_routing_enablers_layer_enablers_by_id_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int table_index = dnx_data_l3_routing_enablers_table_layer_enablers_by_id;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_device.general.max_nof_layer_protocols_get(unit);
    table->info_get.key_size[0] = dnx_data_device.general.max_nof_layer_protocols_get(unit);

    /* Info - default values */
    table->values[0].default_val = "DBAL_NOF_ENUM_LAYER_TYPES_VALUES";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_routing_enablers_layer_enablers_by_id_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_routing_enablers_table_layer_enablers_by_id");

    /* Store Default Values */
    default_data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->layer_type = DBAL_NOF_ENUM_LAYER_TYPES_VALUES;
    /* Set Default Values */
    for (idx_index = 0; idx_index < table->keys[0].size; idx_index++)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, idx_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_ETHERNET;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_IPV4;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_IPV6;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_MPLS;
    }
    if (4 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_FCOE;
    }
    if (5 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_L2TP;
    }
    if (6 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_PPPOE;
    }
    if (7 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_SRV6_ENDPOINT;
    }
    if (8 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_SRV6_BEYOND;
    }
    if (9 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_INGRESS_SCTP_EGRESS_FTMH;
    }
    if (10 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_GTP;
    }
    if (11 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_PPP;
    }
    if (12 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_by_id_t *) dnxc_data_mgmt_table_data_get(unit, table, 12, 0);
        data->layer_type = DBAL_ENUM_FVAL_LAYER_TYPES_IPVX;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table layer_enablers
 * Module - 'l3', Submodule - 'routing_enablers', table - 'layer_enablers'
 * Map layer type to routing enabled/disabled indication
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_routing_enablers_layer_enablers_set(
    int unit)
{
    int layer_type_index;
    dnx_data_l3_routing_enablers_layer_enablers_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int table_index = dnx_data_l3_routing_enablers_table_layer_enablers;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DBAL_NOF_ENUM_LAYER_TYPES_VALUES;
    table->info_get.key_size[0] = DBAL_NOF_ENUM_LAYER_TYPES_VALUES;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_routing_enablers_layer_enablers_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_routing_enablers_table_layer_enablers");

    /* Store Default Values */
    default_data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->uc_enable = 0;
    default_data->mc_enable = 0;
    default_data->disable_profile = 0;
    /* Set Default Values */
    for (layer_type_index = 0; layer_type_index < table->keys[0].size; layer_type_index++)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, layer_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DBAL_ENUM_FVAL_LAYER_TYPES_ETHERNET < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_ETHERNET, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_IPV4 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_IPV4, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_IPV6 < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_IPV6, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_MPLS < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_MPLS, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_FCOE < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_FCOE, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_L2TP < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_L2TP, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_PPPOE < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_PPPOE, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_SRV6_ENDPOINT < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_SRV6_ENDPOINT, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_SRV6_BEYOND < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_SRV6_BEYOND, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_INGRESS_SCTP_EGRESS_FTMH < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_INGRESS_SCTP_EGRESS_FTMH, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_GTP < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_GTP, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_PPP < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_PPP, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }
    if (DBAL_ENUM_FVAL_LAYER_TYPES_IPVX < table->keys[0].size)
    {
        data = (dnx_data_l3_routing_enablers_layer_enablers_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LAYER_TYPES_IPVX, 0);
        data->uc_enable = 1;
        data->mc_enable = 1;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: rif
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_rif_out_rif_part_of_lif_mngr_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_rif;
    int feature_index = dnx_data_l3_rif_out_rif_part_of_lif_mngr;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define max_nof_rifs
 * define info:
 * Maximum number of rifs supported by the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_rif_max_nof_rifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_rif;
    int define_index = dnx_data_l3_rif_define_max_nof_rifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x20000;

    /* Set value */
    define->data = 0x20000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_rifs
 * numeric info:
 * Number of rifs available in the system.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_rif_nof_rifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_rif;
    int define_index = dnx_data_l3_rif_define_nof_rifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4096;

    /* Set value */
    define->data = 4096;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "rif_id_max";
    define->property.doc = 
        "\n"
        "Default: 4096\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_custom;
    define->property.method_str = "custom";

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnx_data_property_l3_rif_nof_rifs_read(unit, (uint32 *) &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: fwd
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_ipmc_rif_key_participation_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int feature_index = dnx_data_l3_fwd_ipmc_rif_key_participation;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_host_entry_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int feature_index = dnx_data_l3_fwd_host_entry_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_tcam_entry_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int feature_index = dnx_data_l3_fwd_tcam_entry_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_ipmc_config_cmprs_vrf_group_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int feature_index = dnx_data_l3_fwd_ipmc_config_cmprs_vrf_group;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_lpm_default_entry_set_by_prefix_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int feature_index = dnx_data_l3_fwd_lpm_default_entry_set_by_prefix;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_kaps_lpm_strength_profile_map_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int feature_index = dnx_data_l3_fwd_kaps_lpm_strength_profile_map_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define flp_fragment_support
 * define info:
 * Indicate whether the LB fragmentation is handled by the FLP.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_flp_fragment_support_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_flp_fragment_support;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_mc_group_lpm
 * define info:
 * The maximum number of MC group ID for IPMC route entries.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_max_mc_group_lpm_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_max_mc_group_lpm;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1FFFF;

    /* Set value */
    define->data = 0x1FFFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_mc_group_em
 * define info:
 * The maximum number of MC group ID for IPMC host entries.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_max_mc_group_em_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_max_mc_group_em;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x7FFFF;

    /* Set value */
    define->data = 0x7FFFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_my_mac_prefixes
 * define info:
 * The number of my MACs prefixes.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_nof_my_mac_prefixes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_nof_my_mac_prefixes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define compressed_sip_svl_size
 * define info:
 * The size in bits of the IPMC IP6 compressed SIP for SVL table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_compressed_sip_svl_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_compressed_sip_svl_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_compressed_svl_sip
 * define info:
 * Number of supported IPMC compressed SIPs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_nof_compressed_svl_sip_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_nof_compressed_svl_sip;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_l3.fwd.compressed_sip_svl_size_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_l3.fwd.compressed_sip_svl_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define lpm_strength_profiles_support
 * define info:
 * Indicates whether the KAPS strength mapping is different per LPM profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_lpm_strength_profiles_support_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_lpm_strength_profiles_support;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_lpm_strength_profiles
 * define info:
 * The number of LPM strength profiles
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_nof_lpm_strength_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_nof_lpm_strength_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define compressed_sip_ivl_size
 * define info:
 * The size in bits of the IPMC IP6 compressed SIP for IVL table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_compressed_sip_ivl_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_compressed_sip_ivl_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 13;

    /* Set value */
    define->data = 13;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_compressed_ivl_sip
 * define info:
 * Number of supported IPMC compressed SIPs for IVL table.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_nof_compressed_ivl_sip_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_nof_compressed_ivl_sip;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_l3.fwd.compressed_sip_ivl_size_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_l3.fwd.compressed_sip_ivl_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric uc_supported_route_flags
 * numeric info:
 * Supported L3 unicast route flags.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_uc_supported_route_flags_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_uc_supported_route_flags;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (BCM_L3_IP6 | BCM_L3_REPLACE | BCM_L3_HIT_CLEAR | BCM_L3_HIT | BCM_L3_INTERNAL_ROUTE);

    /* Set value */
    define->data = (BCM_L3_IP6 | BCM_L3_REPLACE | BCM_L3_HIT_CLEAR | BCM_L3_HIT | BCM_L3_INTERNAL_ROUTE);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric uc_supported_route_flags2
 * numeric info:
 * Supported L3 unicast route flags2.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_uc_supported_route_flags2_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_uc_supported_route_flags2;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (BCM_L3_FLAGS2_RAW_ENTRY | BCM_L3_FLAGS2_SCALE_ROUTE);

    /* Set value */
    define->data = (BCM_L3_FLAGS2_RAW_ENTRY | BCM_L3_FLAGS2_SCALE_ROUTE);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric uc_supported_kbp_route_flags
 * numeric info:
 * Supported L3 unicast KBP route flags.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_uc_supported_kbp_route_flags_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_uc_supported_kbp_route_flags;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (BCM_L3_IP6 | BCM_L3_REPLACE | BCM_L3_ENCAP_SPACE_OPTIMIZED | BCM_L3_SRC_DISCARD);

    /* Set value */
    define->data = (BCM_L3_IP6 | BCM_L3_REPLACE | BCM_L3_ENCAP_SPACE_OPTIMIZED | BCM_L3_SRC_DISCARD);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric uc_supported_kbp_route_flags2
 * numeric info:
 * Supported L3 unicast KBP route flags2.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_uc_supported_kbp_route_flags2_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_uc_supported_kbp_route_flags2;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (BCM_L3_FLAGS2_RAW_ENTRY | BCM_L3_FLAGS2_FWD_ONLY | BCM_L3_FLAGS2_RPF_ONLY | BCM_L3_FLAGS2_NO_PAYLOAD);

    /* Set value */
    define->data = (BCM_L3_FLAGS2_RAW_ENTRY | BCM_L3_FLAGS2_FWD_ONLY | BCM_L3_FLAGS2_RPF_ONLY | BCM_L3_FLAGS2_NO_PAYLOAD);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric ipmc_supported_flags
 * numeric info:
 * Supported flags for the IPMC APIs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_ipmc_supported_flags_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_ipmc_supported_flags;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = BCM_IPMC_REPLACE | BCM_IPMC_IP6 | BCM_IPMC_HIT_CLEAR | BCM_IPMC_TCAM | BCM_IPMC_RAW_ENTRY | BCM_IPMC_L2 | BCM_IPMC_HIT | BCM_IPMC_DEFAULT_ENTRY;

    /* Set value */
    define->data = BCM_IPMC_REPLACE | BCM_IPMC_IP6 | BCM_IPMC_HIT_CLEAR | BCM_IPMC_TCAM | BCM_IPMC_RAW_ENTRY | BCM_IPMC_L2 | BCM_IPMC_HIT | BCM_IPMC_DEFAULT_ENTRY;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric last_kaps_intf_id
 * numeric info:
 * The last valid KAPS interface used in KAPS LPM strength profile configuration
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_last_kaps_intf_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_last_kaps_intf_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_3;

    /* Set value */
    define->data = DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table lpm_profile_to_entry_strength
 * Module - 'l3', Submodule - 'fwd', table - 'lpm_profile_to_entry_strength'
 * LPM profile to entry strength mapping
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_lpm_profile_to_entry_strength_set(
    int unit)
{
    int lpm_profile_index;
    int kaps_intf_index;
    dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int table_index = dnx_data_l3_fwd_table_lpm_profile_to_entry_strength;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 1;
    table->info_get.key_size[0] = 1;
    table->keys[1].size = 4;
    table->info_get.key_size[1] = 4;

    /* Info - default values */
    table->values[0].default_val = "-1,-1,-1,-1,-1,-1,-1";
    table->values[1].default_val = "-1,-1,-1,-1,-1,-1,-1";
    table->values[2].default_val = "1";
    table->values[3].default_val = "-1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fwd_lpm_profile_to_entry_strength_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_l3_fwd_table_lpm_profile_to_entry_strength");

    /* Store Default Values */
    default_data = (dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    SHR_RANGE_VERIFY(7, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
    default_data->prefix_len_non_def[0] = -1;
    default_data->prefix_len_non_def[1] = -1;
    default_data->prefix_len_non_def[2] = -1;
    default_data->prefix_len_non_def[3] = -1;
    default_data->prefix_len_non_def[4] = -1;
    default_data->prefix_len_non_def[5] = -1;
    default_data->prefix_len_non_def[6] = -1;
    SHR_RANGE_VERIFY(7, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
    default_data->prefix_len_def[0] = -1;
    default_data->prefix_len_def[1] = -1;
    default_data->prefix_len_def[2] = -1;
    default_data->prefix_len_def[3] = -1;
    default_data->prefix_len_def[4] = -1;
    default_data->prefix_len_def[5] = -1;
    default_data->prefix_len_def[6] = -1;
    default_data->entry_strength_non_def[0] = 1;
    default_data->entry_strength_def[0] = -1;
    /* Set Default Values */
    for (lpm_profile_index = 0; lpm_profile_index < table->keys[0].size; lpm_profile_index++)
    {
        for (kaps_intf_index = 0; kaps_intf_index < table->keys[1].size; kaps_intf_index++)
        {
            data = (dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *) dnxc_data_mgmt_table_data_get(unit, table, lpm_profile_index, kaps_intf_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_0 < table->keys[1].size)
    {
        data = (dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_0);
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->prefix_len_non_def[0] = 0;
        data->prefix_len_non_def[1] = 160;
        data->prefix_len_non_def[2] = -1;
        data->prefix_len_non_def[3] = -1;
        data->prefix_len_non_def[4] = -1;
        data->prefix_len_non_def[5] = -1;
        data->prefix_len_non_def[6] = -1;
        data->prefix_len_non_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->prefix_len_def[0] = 0;
        data->prefix_len_def[1] = 160;
        data->prefix_len_def[2] = -1;
        data->prefix_len_def[3] = -1;
        data->prefix_len_def[4] = -1;
        data->prefix_len_def[5] = -1;
        data->prefix_len_def[6] = -1;
        data->prefix_len_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->entry_strength_non_def[0] = 1;
        data->entry_strength_non_def[1] = -1;
        data->entry_strength_non_def[2] = -1;
        data->entry_strength_non_def[3] = -1;
        data->entry_strength_non_def[4] = -1;
        data->entry_strength_non_def[5] = -1;
        data->entry_strength_non_def[6] = -1;
        data->entry_strength_non_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->entry_strength_def[0] = 0;
        data->entry_strength_def[1] = -1;
        data->entry_strength_def[2] = -1;
        data->entry_strength_def[3] = -1;
        data->entry_strength_def[4] = -1;
        data->entry_strength_def[5] = -1;
        data->entry_strength_def[6] = -1;
        data->entry_strength_def[7] = -1;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_1 < table->keys[1].size)
    {
        data = (dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_1);
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->prefix_len_non_def[0] = 0;
        data->prefix_len_non_def[1] = 51;
        data->prefix_len_non_def[2] = 63;
        data->prefix_len_non_def[3] = 64;
        data->prefix_len_non_def[4] = 96;
        data->prefix_len_non_def[5] = 160;
        data->prefix_len_non_def[6] = -1;
        data->prefix_len_non_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->prefix_len_def[0] = 0;
        data->prefix_len_def[1] = 160;
        data->prefix_len_def[2] = -1;
        data->prefix_len_def[3] = -1;
        data->prefix_len_def[4] = -1;
        data->prefix_len_def[5] = -1;
        data->prefix_len_def[6] = -1;
        data->prefix_len_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->entry_strength_non_def[0] = 1;
        data->entry_strength_non_def[1] = 2;
        data->entry_strength_non_def[2] = 3;
        data->entry_strength_non_def[3] = 4;
        data->entry_strength_non_def[4] = 5;
        data->entry_strength_non_def[5] = -1;
        data->entry_strength_non_def[6] = -1;
        data->entry_strength_non_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->entry_strength_def[0] = 0;
        data->entry_strength_def[1] = -1;
        data->entry_strength_def[2] = -1;
        data->entry_strength_def[3] = -1;
        data->entry_strength_def[4] = -1;
        data->entry_strength_def[5] = -1;
        data->entry_strength_def[6] = -1;
        data->entry_strength_def[7] = -1;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_2 < table->keys[1].size)
    {
        data = (dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_2);
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->prefix_len_non_def[0] = 0;
        data->prefix_len_non_def[1] = 160;
        data->prefix_len_non_def[2] = -1;
        data->prefix_len_non_def[3] = -1;
        data->prefix_len_non_def[4] = -1;
        data->prefix_len_non_def[5] = -1;
        data->prefix_len_non_def[6] = -1;
        data->prefix_len_non_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->prefix_len_def[0] = 0;
        data->prefix_len_def[1] = 160;
        data->prefix_len_def[2] = -1;
        data->prefix_len_def[3] = -1;
        data->prefix_len_def[4] = -1;
        data->prefix_len_def[5] = -1;
        data->prefix_len_def[6] = -1;
        data->prefix_len_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->entry_strength_non_def[0] = 1;
        data->entry_strength_non_def[1] = -1;
        data->entry_strength_non_def[2] = -1;
        data->entry_strength_non_def[3] = -1;
        data->entry_strength_non_def[4] = -1;
        data->entry_strength_non_def[5] = -1;
        data->entry_strength_non_def[6] = -1;
        data->entry_strength_non_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->entry_strength_def[0] = 0;
        data->entry_strength_def[1] = -1;
        data->entry_strength_def[2] = -1;
        data->entry_strength_def[3] = -1;
        data->entry_strength_def[4] = -1;
        data->entry_strength_def[5] = -1;
        data->entry_strength_def[6] = -1;
        data->entry_strength_def[7] = -1;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_3 < table->keys[1].size)
    {
        data = (dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_KAPS_INTERFACE_INTERFACE_3);
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->prefix_len_non_def[0] = 0;
        data->prefix_len_non_def[1] = 160;
        data->prefix_len_non_def[2] = -1;
        data->prefix_len_non_def[3] = -1;
        data->prefix_len_non_def[4] = -1;
        data->prefix_len_non_def[5] = -1;
        data->prefix_len_non_def[6] = -1;
        data->prefix_len_non_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->prefix_len_def[0] = 0;
        data->prefix_len_def[1] = 160;
        data->prefix_len_def[2] = -1;
        data->prefix_len_def[3] = -1;
        data->prefix_len_def[4] = -1;
        data->prefix_len_def[5] = -1;
        data->prefix_len_def[6] = -1;
        data->prefix_len_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->entry_strength_non_def[0] = 1;
        data->entry_strength_non_def[1] = -1;
        data->entry_strength_non_def[2] = -1;
        data->entry_strength_non_def[3] = -1;
        data->entry_strength_non_def[4] = -1;
        data->entry_strength_non_def[5] = -1;
        data->entry_strength_non_def[6] = -1;
        data->entry_strength_non_def[7] = -1;
        SHR_RANGE_VERIFY(8, 0, DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES, _SHR_E_INTERNAL, "out of bound access to array")
        data->entry_strength_def[0] = 0;
        data->entry_strength_def[1] = -1;
        data->entry_strength_def[2] = -1;
        data->entry_strength_def[3] = -1;
        data->entry_strength_def[4] = -1;
        data->entry_strength_def[5] = -1;
        data->entry_strength_def[6] = -1;
        data->entry_strength_def[7] = -1;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table routing_tables
 * Module - 'l3', Submodule - 'fwd', table - 'routing_tables'
 * IPv4/IPv6 routing tables information
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_routing_tables_set(
    int unit)
{
    int ip_version_index;
    dnx_data_l3_fwd_routing_tables_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int table_index = dnx_data_l3_fwd_table_routing_tables;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 7;
    table->info_get.key_size[0] = 7;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fwd_routing_tables_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_fwd_table_routing_tables");

    /* Store Default Values */
    default_data = (dnx_data_l3_fwd_routing_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->tables[0] = 0;
    /* Set Default Values */
    for (ip_version_index = 0; ip_version_index < table->keys[0].size; ip_version_index++)
    {
        data = (dnx_data_l3_fwd_routing_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, ip_version_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (L3_IPV4_PROTOCOL_VERSION < table->keys[0].size)
    {
        data = (dnx_data_l3_fwd_routing_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_IPV4_PROTOCOL_VERSION, 0);
        SHR_RANGE_VERIFY(5, 0, L3_MAX_NOF_ROUTING_TABLES_PER_PROTOCOL_VERSION+1, _SHR_E_INTERNAL, "out of bound access to array")
        data->tables[0] = DBAL_TABLE_IPV4_UNICAST_PRIVATE_LPM_FORWARD;
        data->tables[1] = DBAL_TABLE_IPV4_UNICAST_PRIVATE_LPM_FORWARD_2;
        data->tables[2] = DBAL_TABLE_KBP_IPV4_UNICAST_PRIVATE_LPM_FORWARD;
        data->tables[3] = DBAL_TABLE_KBP_IPV4_UNICAST_PRIVATE_LPM_RPF;
        data->tables[4] = DBAL_TABLE_EMPTY;
    }
    if (L3_IPV6_PROTOCOL_VERSION < table->keys[0].size)
    {
        data = (dnx_data_l3_fwd_routing_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_IPV6_PROTOCOL_VERSION, 0);
        SHR_RANGE_VERIFY(5, 0, L3_MAX_NOF_ROUTING_TABLES_PER_PROTOCOL_VERSION+1, _SHR_E_INTERNAL, "out of bound access to array")
        data->tables[0] = DBAL_TABLE_IPV6_UNICAST_PRIVATE_LPM_FORWARD;
        data->tables[1] = DBAL_TABLE_IPV6_UNICAST_PRIVATE_LPM_FORWARD_2;
        data->tables[2] = DBAL_TABLE_KBP_IPV6_UNICAST_PRIVATE_LPM_FORWARD;
        data->tables[3] = DBAL_TABLE_KBP_IPV6_UNICAST_PRIVATE_LPM_RPF;
        data->tables[4] = DBAL_TABLE_EMPTY;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table mc_tables
 * Module - 'l3', Submodule - 'fwd', table - 'mc_tables'
 * IPv4/IPv6 MC tables information
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_mc_tables_set(
    int unit)
{
    int ip_version_index;
    int route_enable_index;
    dnx_data_l3_fwd_mc_tables_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int table_index = dnx_data_l3_fwd_table_mc_tables;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 7;
    table->info_get.key_size[0] = 7;
    table->keys[1].size = 2;
    table->info_get.key_size[1] = 2;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fwd_mc_tables_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_l3_fwd_table_mc_tables");

    /* Store Default Values */
    default_data = (dnx_data_l3_fwd_mc_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->tables[0] = 0;
    default_data->count = 0;
    /* Set Default Values */
    for (ip_version_index = 0; ip_version_index < table->keys[0].size; ip_version_index++)
    {
        for (route_enable_index = 0; route_enable_index < table->keys[1].size; route_enable_index++)
        {
            data = (dnx_data_l3_fwd_mc_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, ip_version_index, route_enable_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    if (L3_IPV4_PROTOCOL_VERSION < table->keys[0].size && 1 < table->keys[1].size)
    {
        data = (dnx_data_l3_fwd_mc_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_IPV4_PROTOCOL_VERSION, 1);
        data->tables[0] = DBAL_TABLE_IPV4_MULTICAST_EM_FORWARD;
        data->tables[1] = DBAL_TABLE_IPV4_MULTICAST_PRIVATE_LPM_FORWARD;
        data->tables[2] = DBAL_TABLE_IPV4_MULTICAST_PUBLIC_LPM_FORWARD;
        data->tables[3] = DBAL_TABLE_IPV4_MULTICAST_TCAM_FORWARD;
        data->tables[4] = DBAL_TABLE_KBP_IPV4_MULTICAST_TCAM_FORWARD;
        data->count = 5;
    }
    if (L3_IPV4_PROTOCOL_VERSION < table->keys[0].size && 0 < table->keys[1].size)
    {
        data = (dnx_data_l3_fwd_mc_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_IPV4_PROTOCOL_VERSION, 0);
        data->tables[0] = DBAL_TABLE_BRIDGE_IPV4_MULTICAST_IVL;
        data->tables[1] = DBAL_TABLE_BRIDGE_IPV4_MULTICAST_SVL;
        data->tables[2] = DBAL_TABLE_BRIDGE_IPV4_MULTICAST_SOURCE_SPECIFIC_SVL;
        data->tables[3] = DBAL_TABLE_BRIDGE_IPV4_MULTICAST_SOURCE_SPECIFIC_IVL;
        data->count = 4;
    }
    if (L3_IPV6_PROTOCOL_VERSION < table->keys[0].size && 1 < table->keys[1].size)
    {
        data = (dnx_data_l3_fwd_mc_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_IPV6_PROTOCOL_VERSION, 1);
        data->tables[0] = DBAL_TABLE_IPV6_MULTICAST_EM_FORWARD;
        data->tables[1] = DBAL_TABLE_IPV6_MULTICAST_PRIVATE_LPM_FORWARD;
        data->tables[2] = DBAL_TABLE_IPV6_MULTICAST_TCAM_FORWARD;
        data->tables[3] = DBAL_TABLE_KBP_IPV6_MULTICAST_TCAM_FORWARD;
        data->count = 4;
    }
    if (L3_IPV6_PROTOCOL_VERSION < table->keys[0].size && 0 < table->keys[1].size)
    {
        data = (dnx_data_l3_fwd_mc_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_IPV6_PROTOCOL_VERSION, 0);
        data->tables[0] = DBAL_TABLE_BRIDGE_IPV6_MULTICAST_SOURCE_SPECIFIC_SVL;
        data->tables[1] = DBAL_TABLE_BRIDGE_IPV6_MULTICAST_SOURCE_SPECIFIC_IVL;
        data->count = 2;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table ipmc_compression_mode
 * Module - 'l3', Submodule - 'fwd', table - 'ipmc_compression_mode'
 * IPv4/IPv6 MC tables information
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_fwd_ipmc_compression_mode_set(
    int unit)
{
    int route_enable_index;
    dnx_data_l3_fwd_ipmc_compression_mode_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int table_index = dnx_data_l3_fwd_table_ipmc_compression_mode;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "DBAL_NOF_TABLES";
    table->values[2].default_val = "DBAL_NOF_PHYSICAL_TABLES";
    table->values[3].default_val = "DBAL_NOF_FIELDS";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_fwd_ipmc_compression_mode_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_fwd_table_ipmc_compression_mode");

    /* Store Default Values */
    default_data = (dnx_data_l3_fwd_ipmc_compression_mode_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->mode = 0;
    default_data->dbal_table = DBAL_NOF_TABLES;
    default_data->physical_table = DBAL_NOF_PHYSICAL_TABLES;
    default_data->result_field = DBAL_NOF_FIELDS;
    /* Set Default Values */
    for (route_enable_index = 0; route_enable_index < table->keys[0].size; route_enable_index++)
    {
        data = (dnx_data_l3_fwd_ipmc_compression_mode_t *) dnxc_data_mgmt_table_data_get(unit, table, route_enable_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_l3_fwd_ipmc_compression_mode_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->mode = IPMC_CONFIG_CMPRS_SIP_INTF;
        data->dbal_table = DBAL_TABLE_IPV6_MULTICAST_SOURCE_AND_INTERFACE;
        data->physical_table = DBAL_PHYSICAL_TABLE_KAPS_2;
        data->result_field = DBAL_FIELD_KAPS_RESULT;
    }
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_l3_fwd_ipmc_compression_mode_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->mode = IPMC_CONFIG_CMPRS_SIP;
        data->dbal_table = DBAL_TABLE_IPV6_MULTICAST_SOURCE;
        data->physical_table = DBAL_PHYSICAL_TABLE_KAPS_2;
        data->result_field = DBAL_FIELD_KAPS_RESULT;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: ecmp
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_ecmp_group_profile_multiple_result_types_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int feature_index = dnx_data_l3_ecmp_ecmp_group_profile_multiple_result_types_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define group_size_multiply_and_divide_nof_bits
 * define info:
 * The NOF bit of the multiply and division group size field.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_group_size_multiply_and_divide_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_group_size_multiply_and_divide_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define group_size_consistent_nof_bits
 * define info:
 * The NOF bit of the consistent group size field.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_group_size_consistent_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_group_size_consistent_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define group_size_nof_bits
 * define info:
 * The max NOF bit of the ECMP group size field.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_group_size_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_group_size_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX(dnx_data_l3.ecmp.group_size_multiply_and_divide_nof_bits_get(unit),dnx_data_l3.ecmp.group_size_consistent_nof_bits_get(unit));

    /* Set value */
    define->data = UTILEX_MAX(dnx_data_l3.ecmp.group_size_multiply_and_divide_nof_bits_get(unit),dnx_data_l3.ecmp.group_size_consistent_nof_bits_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_group_size
 * define info:
 * The maximal size of an ECMP group.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_max_group_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_max_group_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_l3.ecmp.group_size_nof_bits_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_l3.ecmp.group_size_nof_bits_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp_basic_mode
 * define info:
 * Number of ECMP groups that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_ecmp_basic_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp_basic_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x8000;

    /* Set value */
    define->data = 0x8000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define total_nof_ecmp
 * define info:
 * The total number of IDs that are considered to be in the ECMP range.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_total_nof_ecmp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_total_nof_ecmp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xA000;

    /* Set value */
    define->data = 0xA000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_ecmp_basic_mode
 * define info:
 * Maximum ECMP group ID that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_max_ecmp_basic_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_max_ecmp_basic_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.ecmp.nof_ecmp_basic_mode_get(unit)-1;

    /* Set value */
    define->data = dnx_data_l3.ecmp.nof_ecmp_basic_mode_get(unit)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_ecmp_extended_mode
 * define info:
 * Maximum ECMP group ID that can be created in extended mode
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_max_ecmp_extended_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_max_ecmp_extended_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x9FFF;

    /* Set value */
    define->data = 0x9FFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_extended_ecmp_per_failover_bank
 * define info:
 * The upper 8k ECMP (from 32k to 40k) are placed in a memory shared by Failover and ECMP. The memory has 32 banks by 512 lines each.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_extended_ecmp_per_failover_bank_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_extended_ecmp_per_failover_bank;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x200;

    /* Set value */
    define->data = 0x200;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_failover_banks_per_extended_ecmp_bank
 * define info:
 * nof fec protection banks to be used for 1 ecmp extended bank
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_failover_banks_per_extended_ecmp_bank_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_failover_banks_per_extended_ecmp_bank;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.ecmp.ecmp_bank_size_get(unit) / dnx_data_l3.ecmp.nof_extended_ecmp_per_failover_bank_get(unit);

    /* Set value */
    define->data = dnx_data_l3.ecmp.ecmp_bank_size_get(unit) / dnx_data_l3.ecmp.nof_extended_ecmp_per_failover_bank_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_group_profiles_per_hierarchy
 * define info:
 * Number of profiles that are available for each ECMP hierarchy.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_group_profiles_per_hierarchy;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x400;

    /* Set value */
    define->data = 0x400;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define member_table_nof_rows_size_in_bits
 * define info:
 * The NOF bits required to represent the NOF rows in the consistent members memory.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_member_table_nof_rows_size_in_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_member_table_nof_rows_size_in_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 12;

    /* Set value */
    define->data = 12;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define member_table_address_size_in_bits
 * define info:
 * The member table address size in bits when it used by the ECMP profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_member_table_address_size_in_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_member_table_address_size_in_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ecmp_bank_size
 * define info:
 * The number of groups per HW bank. All groups in a bank belong to one hierarchy.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_ecmp_bank_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_ecmp_bank_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x800;

    /* Set value */
    define->data = 0x800;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp_banks_basic
 * define info:
 * The number of ECMP banks in the basic range of IDs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_ecmp_banks_basic_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp_banks_basic;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp_banks_extended
 * define info:
 * The number of ECMP banks in the extended range of IDs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_ecmp_banks_extended_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp_banks_extended;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp
 * define info:
 * Number of ECMPs in the system.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_ecmp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xA000;

    /* Set value */
    define->data = 0xA000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define profile_id_size
 * define info:
 * The size of the profile ID field
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_profile_id_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_profile_id_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 10;

    /* Set value */
    define->data = 10;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define profile_id_offset
 * define info:
 * The offset of the profile ID field
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_profile_id_offset_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_profile_id_offset;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tunnel_priority_support
 * define info:
 * Device has tunnel priority support.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_tunnel_priority_support_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_tunnel_priority_support;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_tunnel_priority_map_profiles
 * define info:
 * The NOF tunnle priority map profiles
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_tunnel_priority_map_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_tunnel_priority_map_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tunnel_priority_field_width
 * define info:
 * The width in bits of the tunnel priority field.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_tunnel_priority_field_width_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_tunnel_priority_field_width;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tunnel_priority_index_field_width
 * define info:
 * The size of the possible TP indexes field.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_tunnel_priority_index_field_width_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_tunnel_priority_index_field_width;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define consistent_mem_row_size_in_bits
 * define info:
 * The size in bits of a row in the consistent members memory.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_consistent_mem_row_size_in_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_consistent_mem_row_size_in_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define consistent_bank_size_in_bits
 * define info:
 * The size of a single bank used for the consistent hashing members tables.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_consistent_bank_size_in_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_consistent_bank_size_in_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x2000;

    /* Set value */
    define->data = 0x2000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ecmp_small_consistent_group_nof_entries
 * define info:
 * The nof entries in small consistent group
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_ecmp_small_consistent_group_nof_entries_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_ecmp_small_consistent_group_nof_entries;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ecmp_small_consistent_group_entry_size_in_bits
 * define info:
 * The nof bits for each entry in consistent small group
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_ecmp_small_consistent_group_entry_size_in_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_ecmp_small_consistent_group_entry_size_in_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_consistent_resources
 * define info:
 * The total number of consistent resources available
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_nof_consistent_resources_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_consistent_resources;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.ecmp.consistent_mem_row_size_in_bits_get(unit) * (1 << dnx_data_l3.ecmp.member_table_nof_rows_size_in_bits_get(unit)) / dnx_data_l3.ecmp.ecmp_small_consistent_group_entry_size_in_bits_get(unit) / dnx_data_l3.ecmp.ecmp_small_consistent_group_nof_entries_get(unit);

    /* Set value */
    define->data = dnx_data_l3.ecmp.consistent_mem_row_size_in_bits_get(unit) * (1 << dnx_data_l3.ecmp.member_table_nof_rows_size_in_bits_get(unit)) / dnx_data_l3.ecmp.ecmp_small_consistent_group_entry_size_in_bits_get(unit) / dnx_data_l3.ecmp.ecmp_small_consistent_group_nof_entries_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table consistent_tables_info
 * Module - 'l3', Submodule - 'ecmp', table - 'consistent_tables_info'
 * information on the different consistent tables sizes
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_ecmp_consistent_tables_info_set(
    int unit)
{
    int table_type_index;
    dnx_data_l3_ecmp_consistent_tables_info_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int table_index = dnx_data_l3_ecmp_table_consistent_tables_info;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DBAL_NOF_ENUM_ECMP_CONSISTENT_TABLE_VALUES;
    table->info_get.key_size[0] = DBAL_NOF_ENUM_ECMP_CONSISTENT_TABLE_VALUES;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_ecmp_consistent_tables_info_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_ecmp_table_consistent_tables_info");

    /* Store Default Values */
    default_data = (dnx_data_l3_ecmp_consistent_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->nof_entries = 0;
    default_data->entry_size_in_bits = 0;
    /* Set Default Values */
    for (table_type_index = 0; table_type_index < table->keys[0].size; table_type_index++)
    {
        data = (dnx_data_l3_ecmp_consistent_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, table_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DBAL_ENUM_FVAL_ECMP_CONSISTENT_TABLE_SMALL_SIZE < table->keys[0].size)
    {
        data = (dnx_data_l3_ecmp_consistent_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_ECMP_CONSISTENT_TABLE_SMALL_SIZE, 0);
        data->nof_entries =  dnx_data_l3.ecmp.ecmp_small_consistent_group_nof_entries_get(unit);
        data->entry_size_in_bits = dnx_data_l3.ecmp.ecmp_small_consistent_group_entry_size_in_bits_get(unit);
    }
    if (DBAL_ENUM_FVAL_ECMP_CONSISTENT_TABLE_MEDIUM_SIZE < table->keys[0].size)
    {
        data = (dnx_data_l3_ecmp_consistent_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_ECMP_CONSISTENT_TABLE_MEDIUM_SIZE, 0);
        data->nof_entries = 256;
        data->entry_size_in_bits = 8;
    }
    if (DBAL_ENUM_FVAL_ECMP_CONSISTENT_TABLE_LARGE_SIZE < table->keys[0].size)
    {
        data = (dnx_data_l3_ecmp_consistent_tables_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_ECMP_CONSISTENT_TABLE_LARGE_SIZE, 0);
        data->nof_entries = 512;
        data->entry_size_in_bits = 8;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: vip_ecmp
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vip_ecmp_supported_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vip_ecmp;
    int feature_index = dnx_data_l3_vip_ecmp_supported;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define nof_vip_ecmp
 * define info:
 * Number of VIP ECMP groups
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vip_ecmp_nof_vip_ecmp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vip_ecmp;
    int define_index = dnx_data_l3_vip_ecmp_define_nof_vip_ecmp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4096;

    /* Set value */
    define->data = 4096;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_vip_ecmp_table_size
 * define info:
 * Maximum number entries per VIP ECMP group
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vip_ecmp_max_vip_ecmp_table_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vip_ecmp;
    int define_index = dnx_data_l3_vip_ecmp_define_max_vip_ecmp_table_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16384;

    /* Set value */
    define->data = 16384;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: source_address_ethernet
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_mymac_prefixes
 * define info:
 * Number of mymac prefixes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_source_address_ethernet;
    int define_index = dnx_data_l3_source_address_ethernet_define_nof_mymac_prefixes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: vrrp
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_protocol_groups
 * define info:
 * Number of L3 protocol groups
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_nof_protocol_groups_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_nof_protocol_groups;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_tcam_entries
 * define info:
 * Size of VRRP TCAM table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_nof_tcam_entries_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_nof_tcam_entries;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_vsi_tcam_entries
 * define info:
 * Number of enries in VRRP TCAM table that can be used by VSI table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_nof_vsi_tcam_entries_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_nof_vsi_tcam_entries;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_tcam_entries_used_by_exem
 * define info:
 * The number of TCAM entries used by the EXEM.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_nof_tcam_entries_used_by_exem_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_nof_tcam_entries_used_by_exem;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_vrid_ipv4_tcam_index
 * define info:
 * TCAM index for EXEM VRRP VRID IPv4 protocol
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_vrid_ipv4_tcam_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_vrid_ipv6_tcam_index
 * define info:
 * TCAM index for EXEM VRRP VRID IPv6 protocol
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_vrid_ipv6_tcam_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 17;

    /* Set value */
    define->data = 17;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_default_tcam_index
 * define info:
 * TCAM index for EXEM VSI LSB, SOURCE PORT or SRC PORT-protocol multiple my mac
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_exem_default_tcam_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_default_tcam_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 18;

    /* Set value */
    define->data = 18;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_default_tcam_index_msb
 * define info:
 * TCAM index for EXEM VSI MSB multiple my mac
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_exem_default_tcam_index_msb_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_default_tcam_index_msb;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vrrp_default_num_entries
 * define info:
 * Number of default VRRP entries in TCAM
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_vrrp_default_num_entries_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_vrrp_default_num_entries;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.vrrp.nof_vsi_tcam_entries_get(unit) - dnx_data_l3.vrrp.nof_tcam_entries_used_by_exem_get(unit);

    /* Set value */
    define->data = dnx_data_l3.vrrp.nof_vsi_tcam_entries_get(unit) - dnx_data_l3.vrrp.nof_tcam_entries_used_by_exem_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define is_multiple_my_mac_da_table_per_msb_bit
 * define info:
 * Indication if the VRRP table PER_VSI_MULTIPLE_MY_MAC_DA_MSB is split
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_is_multiple_my_mac_da_table_per_msb_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_is_multiple_my_mac_da_table_per_msb_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define is_mapped_pp_port_used
 * define info:
 * Indication if mapped pp port is used in VRRP tables or in pp port as a key
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_is_mapped_pp_port_used_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_is_mapped_pp_port_used;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_dbs
 * define info:
 * The number of physical DBs used
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_nof_dbs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_nof_dbs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table vrrp_tables
 * Module - 'l3', Submodule - 'vrrp', table - 'vrrp_tables'
 * VRRP tables
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_vrrp_tables_set(
    int unit)
{
    int table_type_index;
    dnx_data_l3_vrrp_vrrp_tables_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int table_index = dnx_data_l3_vrrp_table_vrrp_tables;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = L3_VRRP_TABLE_NOF_TABLES;
    table->info_get.key_size[0] = L3_VRRP_TABLE_NOF_TABLES;

    /* Info - default values */
    table->values[0].default_val = "DBAL_NOF_TABLES";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_vrrp_vrrp_tables_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_l3_vrrp_table_vrrp_tables");

    /* Store Default Values */
    default_data = (dnx_data_l3_vrrp_vrrp_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->table[0] = DBAL_NOF_TABLES;
    /* Set Default Values */
    for (table_type_index = 0; table_type_index < table->keys[0].size; table_type_index++)
    {
        data = (dnx_data_l3_vrrp_vrrp_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, table_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (L3_VRRP_TABLE_PER_PORT_MY_MAC < table->keys[0].size)
    {
        data = (dnx_data_l3_vrrp_vrrp_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_VRRP_TABLE_PER_PORT_MY_MAC, 0);
        data->table[0] = DBAL_TABLE_EXEM_PER_PORT_MY_MAC;
        data->table[1] = DBAL_TABLE_EXEM3_PER_PORT_MY_MAC;
    }
    if (L3_VRRP_TABLE_PER_VSI_MULTIPLE_MY_MAC_DA_MSB_0 < table->keys[0].size)
    {
        data = (dnx_data_l3_vrrp_vrrp_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_VRRP_TABLE_PER_VSI_MULTIPLE_MY_MAC_DA_MSB_0, 0);
        data->table[0] = DBAL_TABLE_EXEM_PER_VSI_MULTIPLE_MY_MAC_DA_MSB_0;
        data->table[1] = DBAL_TABLE_EXEM3_PER_VSI_MULTIPLE_MY_MAC_DA_MSB_0;
    }
    if (L3_VRRP_TABLE_PER_VSI_MULTIPLE_MY_MAC_DA_MSB_1 < table->keys[0].size)
    {
        data = (dnx_data_l3_vrrp_vrrp_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_VRRP_TABLE_PER_VSI_MULTIPLE_MY_MAC_DA_MSB_1, 0);
        data->table[0] = DBAL_TABLE_EXEM_PER_VSI_MULTIPLE_MY_MAC_DA_MSB_1;
        data->table[1] = DBAL_TABLE_EXEM3_PER_VSI_MULTIPLE_MY_MAC_DA_MSB_1;
    }
    if (L3_VRRP_TABLE_VRID_MY_MAC_WITH_PROTOCOL < table->keys[0].size)
    {
        data = (dnx_data_l3_vrrp_vrrp_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_VRRP_TABLE_VRID_MY_MAC_WITH_PROTOCOL, 0);
        data->table[0] = DBAL_TABLE_EXEM_VRID_MY_MAC_WITH_PROTOCOL;
        data->table[1] = DBAL_TABLE_EXEM3_VRID_MY_MAC_WITH_PROTOCOL;
    }
    if (L3_VRRP_TABLE_PER_PORT_IGNORE_MAC < table->keys[0].size)
    {
        data = (dnx_data_l3_vrrp_vrrp_tables_t *) dnxc_data_mgmt_table_data_get(unit, table, L3_VRRP_TABLE_PER_PORT_IGNORE_MAC, 0);
        data->table[0] = DBAL_TABLE_EXEM_PER_PORT_IGNORE_MAC;
        data->table[1] = DBAL_TABLE_EXEM3_PER_PORT_IGNORE_MAC;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table data_bases
 * Module - 'l3', Submodule - 'vrrp', table - 'data_bases'
 * Information about physical DBs used.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_vrrp_data_bases_set(
    int unit)
{
    dnx_data_l3_vrrp_data_bases_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int table_index = dnx_data_l3_vrrp_table_data_bases;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Info - default values */
    table->values[0].default_val = "DBAL_NOF_PHYSICAL_TABLES";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_l3_vrrp_data_bases_t, (1 + 1 /* to store default value */ ), "data of dnx_data_l3_vrrp_table_data_bases");

    /* Store Default Values */
    default_data = (dnx_data_l3_vrrp_data_bases_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->data_base[0] = DBAL_NOF_PHYSICAL_TABLES;
    /* Set Default Values */
    data = (dnx_data_l3_vrrp_data_bases_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    sal_memcpy(data, default_data, table->size_of_values);
    /*
     * Set Values - Entries
     */
    data = (dnx_data_l3_vrrp_data_bases_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    SHR_RANGE_VERIFY(2, 0, DNX_DATA_MAX_L3_VRRP_NOF_DBS, _SHR_E_INTERNAL, "out of bound access to array")
    data->data_base[0] = DBAL_PHYSICAL_TABLE_SEXEM_1;
    data->data_base[1] = DBAL_PHYSICAL_TABLE_SEXEM_3;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: feature
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_ipv6_mc_compatible_dmac_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_ipv6_mc_compatible_dmac;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_fec_hit_bit_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_fec_hit_bit;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_fer_fec_granularity_double_size_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_fer_fec_granularity_double_size;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_mc_bridge_fallback_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_mc_bridge_fallback;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_nat_on_a_stick_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_nat_on_a_stick;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_routed_learning_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_routed_learning;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_ingress_frag_not_first_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_ingress_frag_not_first;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_fec_init_enable_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_fec_init_enable;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_public_routing_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_public_routing_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_separate_fwd_rpf_dbs_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_separate_fwd_rpf_dbs;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_default_fec_limitation_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_default_fec_limitation;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_wcmp_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_wcmp_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_default_kaps_interface_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_default_kaps_interface;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_l3_feature_my_mac_prefix_0_is_invalid_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_feature;
    int feature_index = dnx_data_l3_feature_my_mac_prefix_0_is_invalid;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jr2_a0_data_l3_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_l3;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: egr_pointed
     */
    submodule_index = dnx_data_l3_submodule_egr_pointed;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_egr_pointed_define_first_egr_pointed_id;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_egr_pointed_first_egr_pointed_id_set;
    data_index = dnx_data_l3_egr_pointed_define_nof_egr_pointed_ids;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_egr_pointed_nof_egr_pointed_ids_set;
    data_index = dnx_data_l3_egr_pointed_define_nof_bits_in_egr_pointed_id;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: fec
     */
    submodule_index = dnx_data_l3_submodule_fec;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_fec_define_nof_fecs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_nof_fecs_set;
    data_index = dnx_data_l3_fec_define_first_valid_fec_ecmp_id;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_first_valid_fec_ecmp_id_set;
    data_index = dnx_data_l3_fec_define_max_fec_id_for_single_dhb_cluster_pair_granularity;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_max_fec_id_for_single_dhb_cluster_pair_granularity_set;
    data_index = dnx_data_l3_fec_define_max_fec_id_for_double_dhb_cluster_pair_granularity;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_max_fec_id_for_double_dhb_cluster_pair_granularity_set;
    data_index = dnx_data_l3_fec_define_max_default_fec;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_max_default_fec_set;
    data_index = dnx_data_l3_fec_define_bank_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_bank_size_set;
    data_index = dnx_data_l3_fec_define_bank_size_round_up;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_bank_size_round_up_set;
    data_index = dnx_data_l3_fec_define_max_nof_super_fecs_per_bank;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_max_nof_super_fecs_per_bank_set;
    data_index = dnx_data_l3_fec_define_nof_physical_fecs_per_bank;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_nof_physical_fecs_per_bank_set;
    data_index = dnx_data_l3_fec_define_bank_nof_physical_rows;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_bank_nof_physical_rows_set;
    data_index = dnx_data_l3_fec_define_super_fec_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_super_fec_size_set;
    data_index = dnx_data_l3_fec_define_max_nof_banks;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_max_nof_banks_set;
    data_index = dnx_data_l3_fec_define_first_bank_without_id_alloc;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_first_bank_without_id_alloc_set;
    data_index = dnx_data_l3_fec_define_first_shared_bank;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_first_shared_bank_set;
    data_index = dnx_data_l3_fec_define_max_super_fec_id;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_max_super_fec_id_set;
    data_index = dnx_data_l3_fec_define_nof_fec_directions;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_nof_fec_directions_set;
    data_index = dnx_data_l3_fec_define_nof_dpc_fec_db;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_nof_dpc_fec_db_set;
    data_index = dnx_data_l3_fec_define_nof_fec_dbs_all_cores;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_nof_fec_dbs_all_cores_set;
    data_index = dnx_data_l3_fec_define_nof_fec_result_types;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_nof_fec_result_types_set;
    data_index = dnx_data_l3_fec_define_fer_hw_version;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_fer_hw_version_set;
    data_index = dnx_data_l3_fec_define_fec_property_supported_flags;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fec_fec_property_supported_flags_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_fec_separate_fwd_rpf_dbs;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fec_separate_fwd_rpf_dbs_set;
    data_index = dnx_data_l3_fec_uneven_bank_sizes;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fec_uneven_bank_sizes_set;
    data_index = dnx_data_l3_fec_mc_rpf_sip_based_supported;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fec_mc_rpf_sip_based_supported_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_l3_fec_table_fec_resource_info;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fec_fec_resource_info_set;
    data_index = dnx_data_l3_fec_table_super_fec_result_types_map;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fec_super_fec_result_types_map_set;
    data_index = dnx_data_l3_fec_table_fec_result_type_fields;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fec_fec_result_type_fields_set;
    data_index = dnx_data_l3_fec_table_fec_physical_db;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fec_fec_physical_db_set;
    data_index = dnx_data_l3_fec_table_fec_tables_info;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fec_fec_tables_info_set;
    /*
     * Attach submodule: fer
     */
    submodule_index = dnx_data_l3_submodule_fer;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_fer_define_mdb_granularity_ratio;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fer_mdb_granularity_ratio_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_fer_mux_connection_supported;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fer_mux_connection_supported_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: source_address
     */
    submodule_index = dnx_data_l3_submodule_source_address;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_source_address_define_source_address_table_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_source_address_source_address_table_size_set;
    data_index = dnx_data_l3_source_address_define_custom_sa_use_dual_homing;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_source_address_custom_sa_use_dual_homing_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_l3_source_address_table_address_type_info;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_source_address_address_type_info_set;
    /*
     * Attach submodule: vrf
     */
    submodule_index = dnx_data_l3_submodule_vrf;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_vrf_define_nof_vrf;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrf_nof_vrf_set;
    data_index = dnx_data_l3_vrf_define_nof_vrf_ipv6;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrf_nof_vrf_ipv6_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: routing_enablers
     */
    submodule_index = dnx_data_l3_submodule_routing_enablers;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_routing_enablers_define_routing_enable_vector_length;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_routing_enablers_routing_enable_vector_length_set;
    data_index = dnx_data_l3_routing_enablers_define_routing_enable_action_support;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_routing_enablers_routing_enable_action_support_set;
    data_index = dnx_data_l3_routing_enablers_define_routing_enable_action_profile_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_routing_enablers_routing_enable_action_profile_size_set;
    data_index = dnx_data_l3_routing_enablers_define_routing_enable_indication_nof_bits_per_layer;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_routing_enablers_routing_enable_indication_nof_bits_per_layer_set;
    data_index = dnx_data_l3_routing_enablers_define_routing_enable_nof_profiles_per_layer;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_routing_enablers_routing_enable_nof_profiles_per_layer_set;
    data_index = dnx_data_l3_routing_enablers_define_routing_enabled_action_profile_id;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_routing_enablers_routing_enabled_action_profile_id_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_routing_enablers_ptc_routing_enable_profile_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_routing_enablers_ptc_routing_enable_profile_support_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_l3_routing_enablers_table_layer_enablers_by_id;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_routing_enablers_layer_enablers_by_id_set;
    data_index = dnx_data_l3_routing_enablers_table_layer_enablers;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_routing_enablers_layer_enablers_set;
    /*
     * Attach submodule: rif
     */
    submodule_index = dnx_data_l3_submodule_rif;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_rif_define_max_nof_rifs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_rif_max_nof_rifs_set;
    data_index = dnx_data_l3_rif_define_nof_rifs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_rif_nof_rifs_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_rif_out_rif_part_of_lif_mngr;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_rif_out_rif_part_of_lif_mngr_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: fwd
     */
    submodule_index = dnx_data_l3_submodule_fwd;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_fwd_define_flp_fragment_support;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_flp_fragment_support_set;
    data_index = dnx_data_l3_fwd_define_max_mc_group_lpm;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_max_mc_group_lpm_set;
    data_index = dnx_data_l3_fwd_define_max_mc_group_em;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_max_mc_group_em_set;
    data_index = dnx_data_l3_fwd_define_nof_my_mac_prefixes;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_nof_my_mac_prefixes_set;
    data_index = dnx_data_l3_fwd_define_compressed_sip_svl_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_compressed_sip_svl_size_set;
    data_index = dnx_data_l3_fwd_define_nof_compressed_svl_sip;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_nof_compressed_svl_sip_set;
    data_index = dnx_data_l3_fwd_define_lpm_strength_profiles_support;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_lpm_strength_profiles_support_set;
    data_index = dnx_data_l3_fwd_define_nof_lpm_strength_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_nof_lpm_strength_profiles_set;
    data_index = dnx_data_l3_fwd_define_compressed_sip_ivl_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_compressed_sip_ivl_size_set;
    data_index = dnx_data_l3_fwd_define_nof_compressed_ivl_sip;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_nof_compressed_ivl_sip_set;
    data_index = dnx_data_l3_fwd_define_uc_supported_route_flags;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_uc_supported_route_flags_set;
    data_index = dnx_data_l3_fwd_define_uc_supported_route_flags2;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_uc_supported_route_flags2_set;
    data_index = dnx_data_l3_fwd_define_uc_supported_kbp_route_flags;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_uc_supported_kbp_route_flags_set;
    data_index = dnx_data_l3_fwd_define_uc_supported_kbp_route_flags2;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_uc_supported_kbp_route_flags2_set;
    data_index = dnx_data_l3_fwd_define_ipmc_supported_flags;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_ipmc_supported_flags_set;
    data_index = dnx_data_l3_fwd_define_last_kaps_intf_id;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_fwd_last_kaps_intf_id_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_fwd_ipmc_rif_key_participation;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fwd_ipmc_rif_key_participation_set;
    data_index = dnx_data_l3_fwd_host_entry_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fwd_host_entry_support_set;
    data_index = dnx_data_l3_fwd_tcam_entry_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fwd_tcam_entry_support_set;
    data_index = dnx_data_l3_fwd_ipmc_config_cmprs_vrf_group;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fwd_ipmc_config_cmprs_vrf_group_set;
    data_index = dnx_data_l3_fwd_lpm_default_entry_set_by_prefix;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fwd_lpm_default_entry_set_by_prefix_set;
    data_index = dnx_data_l3_fwd_kaps_lpm_strength_profile_map_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_fwd_kaps_lpm_strength_profile_map_support_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_l3_fwd_table_lpm_profile_to_entry_strength;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fwd_lpm_profile_to_entry_strength_set;
    data_index = dnx_data_l3_fwd_table_routing_tables;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fwd_routing_tables_set;
    data_index = dnx_data_l3_fwd_table_mc_tables;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fwd_mc_tables_set;
    data_index = dnx_data_l3_fwd_table_ipmc_compression_mode;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_fwd_ipmc_compression_mode_set;
    /*
     * Attach submodule: ecmp
     */
    submodule_index = dnx_data_l3_submodule_ecmp;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_ecmp_define_group_size_multiply_and_divide_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_group_size_multiply_and_divide_nof_bits_set;
    data_index = dnx_data_l3_ecmp_define_group_size_consistent_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_group_size_consistent_nof_bits_set;
    data_index = dnx_data_l3_ecmp_define_group_size_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_group_size_nof_bits_set;
    data_index = dnx_data_l3_ecmp_define_max_group_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_max_group_size_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp_basic_mode;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_ecmp_basic_mode_set;
    data_index = dnx_data_l3_ecmp_define_total_nof_ecmp;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_total_nof_ecmp_set;
    data_index = dnx_data_l3_ecmp_define_max_ecmp_basic_mode;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_max_ecmp_basic_mode_set;
    data_index = dnx_data_l3_ecmp_define_max_ecmp_extended_mode;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_max_ecmp_extended_mode_set;
    data_index = dnx_data_l3_ecmp_define_nof_extended_ecmp_per_failover_bank;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_extended_ecmp_per_failover_bank_set;
    data_index = dnx_data_l3_ecmp_define_nof_failover_banks_per_extended_ecmp_bank;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_failover_banks_per_extended_ecmp_bank_set;
    data_index = dnx_data_l3_ecmp_define_nof_group_profiles_per_hierarchy;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_set;
    data_index = dnx_data_l3_ecmp_define_member_table_nof_rows_size_in_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_member_table_nof_rows_size_in_bits_set;
    data_index = dnx_data_l3_ecmp_define_member_table_address_size_in_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_member_table_address_size_in_bits_set;
    data_index = dnx_data_l3_ecmp_define_ecmp_bank_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_ecmp_bank_size_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp_banks_basic;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_ecmp_banks_basic_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp_banks_extended;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_ecmp_banks_extended_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_ecmp_set;
    data_index = dnx_data_l3_ecmp_define_profile_id_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_profile_id_size_set;
    data_index = dnx_data_l3_ecmp_define_profile_id_offset;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_profile_id_offset_set;
    data_index = dnx_data_l3_ecmp_define_tunnel_priority_support;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_tunnel_priority_support_set;
    data_index = dnx_data_l3_ecmp_define_nof_tunnel_priority_map_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_tunnel_priority_map_profiles_set;
    data_index = dnx_data_l3_ecmp_define_tunnel_priority_field_width;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_tunnel_priority_field_width_set;
    data_index = dnx_data_l3_ecmp_define_tunnel_priority_index_field_width;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_tunnel_priority_index_field_width_set;
    data_index = dnx_data_l3_ecmp_define_consistent_mem_row_size_in_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_consistent_mem_row_size_in_bits_set;
    data_index = dnx_data_l3_ecmp_define_consistent_bank_size_in_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_consistent_bank_size_in_bits_set;
    data_index = dnx_data_l3_ecmp_define_ecmp_small_consistent_group_nof_entries;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_ecmp_small_consistent_group_nof_entries_set;
    data_index = dnx_data_l3_ecmp_define_ecmp_small_consistent_group_entry_size_in_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_ecmp_small_consistent_group_entry_size_in_bits_set;
    data_index = dnx_data_l3_ecmp_define_nof_consistent_resources;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_ecmp_nof_consistent_resources_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_ecmp_ecmp_group_profile_multiple_result_types_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_ecmp_ecmp_group_profile_multiple_result_types_support_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_l3_ecmp_table_consistent_tables_info;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_ecmp_consistent_tables_info_set;
    /*
     * Attach submodule: vip_ecmp
     */
    submodule_index = dnx_data_l3_submodule_vip_ecmp;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_vip_ecmp_define_nof_vip_ecmp;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vip_ecmp_nof_vip_ecmp_set;
    data_index = dnx_data_l3_vip_ecmp_define_max_vip_ecmp_table_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vip_ecmp_max_vip_ecmp_table_size_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_vip_ecmp_supported;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_vip_ecmp_supported_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: source_address_ethernet
     */
    submodule_index = dnx_data_l3_submodule_source_address_ethernet;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_source_address_ethernet_define_nof_mymac_prefixes;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: vrrp
     */
    submodule_index = dnx_data_l3_submodule_vrrp;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_vrrp_define_nof_protocol_groups;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_nof_protocol_groups_set;
    data_index = dnx_data_l3_vrrp_define_nof_tcam_entries;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_nof_tcam_entries_set;
    data_index = dnx_data_l3_vrrp_define_nof_vsi_tcam_entries;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_nof_vsi_tcam_entries_set;
    data_index = dnx_data_l3_vrrp_define_nof_tcam_entries_used_by_exem;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_nof_tcam_entries_used_by_exem_set;
    data_index = dnx_data_l3_vrrp_define_exem_vrid_ipv4_tcam_index;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_set;
    data_index = dnx_data_l3_vrrp_define_exem_vrid_ipv6_tcam_index;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_set;
    data_index = dnx_data_l3_vrrp_define_exem_default_tcam_index;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_exem_default_tcam_index_set;
    data_index = dnx_data_l3_vrrp_define_exem_default_tcam_index_msb;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_exem_default_tcam_index_msb_set;
    data_index = dnx_data_l3_vrrp_define_vrrp_default_num_entries;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_vrrp_default_num_entries_set;
    data_index = dnx_data_l3_vrrp_define_is_multiple_my_mac_da_table_per_msb_bit;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_is_multiple_my_mac_da_table_per_msb_bit_set;
    data_index = dnx_data_l3_vrrp_define_is_mapped_pp_port_used;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_is_mapped_pp_port_used_set;
    data_index = dnx_data_l3_vrrp_define_nof_dbs;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_l3_vrrp_nof_dbs_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_l3_vrrp_table_vrrp_tables;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_vrrp_vrrp_tables_set;
    data_index = dnx_data_l3_vrrp_table_data_bases;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_l3_vrrp_data_bases_set;
    /*
     * Attach submodule: feature
     */
    submodule_index = dnx_data_l3_submodule_feature;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_feature_ipv6_mc_compatible_dmac;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_ipv6_mc_compatible_dmac_set;
    data_index = dnx_data_l3_feature_fec_hit_bit;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_fec_hit_bit_set;
    data_index = dnx_data_l3_feature_fer_fec_granularity_double_size;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_fer_fec_granularity_double_size_set;
    data_index = dnx_data_l3_feature_mc_bridge_fallback;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_mc_bridge_fallback_set;
    data_index = dnx_data_l3_feature_nat_on_a_stick;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_nat_on_a_stick_set;
    data_index = dnx_data_l3_feature_routed_learning;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_routed_learning_set;
    data_index = dnx_data_l3_feature_ingress_frag_not_first;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_ingress_frag_not_first_set;
    data_index = dnx_data_l3_feature_fec_init_enable;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_fec_init_enable_set;
    data_index = dnx_data_l3_feature_public_routing_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_public_routing_support_set;
    data_index = dnx_data_l3_feature_separate_fwd_rpf_dbs;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_separate_fwd_rpf_dbs_set;
    data_index = dnx_data_l3_feature_default_fec_limitation;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_default_fec_limitation_set;
    data_index = dnx_data_l3_feature_wcmp_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_wcmp_support_set;
    data_index = dnx_data_l3_feature_default_kaps_interface;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_default_kaps_interface_set;
    data_index = dnx_data_l3_feature_my_mac_prefix_0_is_invalid;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_l3_feature_my_mac_prefix_0_is_invalid_set;

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
#undef BSL_LOG_MODULE
/* *INDENT-ON* */
