/** \file dnx_data_internal_crps.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_CRPS_H_
/*{*/
#define _DNX_DATA_INTERNAL_CRPS_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_crps.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_crps_submodule_engine,
    dnx_data_crps_submodule_eviction,
    dnx_data_crps_submodule_expansion,
    dnx_data_crps_submodule_src_interface,
    dnx_data_crps_submodule_latency,

    /**
     * Must be last one!
     */
    _dnx_data_crps_submodule_nof
} dnx_data_crps_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE ENGINE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_crps_engine_feature_get(
    int unit,
    dnx_data_crps_engine_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_crps_engine_define_nof_engines,
    dnx_data_crps_engine_define_nof_mid_engines,
    dnx_data_crps_engine_define_nof_big_engines,
    dnx_data_crps_engine_define_nof_databases,
    dnx_data_crps_engine_define_data_mapping_table_size,
    dnx_data_crps_engine_define_max_counter_set_size,
    dnx_data_crps_engine_define_oam_counter_set_size,
    dnx_data_crps_engine_define_max_nof_counter_sets,
    dnx_data_crps_engine_define_last_address_nof_bits,
    dnx_data_crps_engine_define_counter_format_nof_bits,
    dnx_data_crps_engine_define_nof_small_meter_sherd_engines,
    dnx_data_crps_engine_define_nof_mid_meter_sherd_engines,
    dnx_data_crps_engine_define_nof_big_meter_sherd_engines,

    /**
     * Must be last one!
     */
    _dnx_data_crps_engine_define_nof
} dnx_data_crps_engine_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_engines'
 * Number of counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_nof_engines_get(
    int unit);

/**
 * \brief returns define data of nof_mid_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_mid_engines'
 * Number of mid counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mid_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_nof_mid_engines_get(
    int unit);

/**
 * \brief returns define data of nof_big_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_big_engines'
 * Number of big counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_nof_big_engines_get(
    int unit);

/**
 * \brief returns define data of nof_databases
 * Module - 'crps', Submodule - 'engine', data - 'nof_databases'
 * Number of counter databases per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_databases - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_nof_databases_get(
    int unit);

/**
 * \brief returns define data of data_mapping_table_size
 * Module - 'crps', Submodule - 'engine', data - 'data_mapping_table_size'
 * Number of entries in data mappnig table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_mapping_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_data_mapping_table_size_get(
    int unit);

/**
 * \brief returns define data of max_counter_set_size
 * Module - 'crps', Submodule - 'engine', data - 'max_counter_set_size'
 * max size of the counter set
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_counter_set_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_max_counter_set_size_get(
    int unit);

/**
 * \brief returns define data of oam_counter_set_size
 * Module - 'crps', Submodule - 'engine', data - 'oam_counter_set_size'
 * size of the counter set for OAM sources
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_counter_set_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_oam_counter_set_size_get(
    int unit);

/**
 * \brief returns define data of max_nof_counter_sets
 * Module - 'crps', Submodule - 'engine', data - 'max_nof_counter_sets'
 * number of different counter sets supported per engine
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_counter_sets - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_max_nof_counter_sets_get(
    int unit);

/**
 * \brief returns define data of last_address_nof_bits
 * Module - 'crps', Submodule - 'engine', data - 'last_address_nof_bits'
 * number of bits of last address admitted per engine
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     last_address_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_last_address_nof_bits_get(
    int unit);

/**
 * \brief returns define data of counter_format_nof_bits
 * Module - 'crps', Submodule - 'engine', data - 'counter_format_nof_bits'
 * number of bits to describe the engine counter format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counter_format_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_counter_format_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_small_meter_sherd_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_small_meter_sherd_engines'
 * number of small engines can allocate for the meter used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_meter_sherd_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_nof_small_meter_sherd_engines_get(
    int unit);

/**
 * \brief returns define data of nof_mid_meter_sherd_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_mid_meter_sherd_engines'
 * number of medium engines can allocate for the meter used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mid_meter_sherd_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_nof_mid_meter_sherd_engines_get(
    int unit);

/**
 * \brief returns define data of nof_big_meter_sherd_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_big_meter_sherd_engines'
 * number of big engines can allocate for the meter used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_meter_sherd_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_engine_nof_big_meter_sherd_engines_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_crps_engine_table_engines_info,
    dnx_data_crps_engine_table_source_base,
    dnx_data_crps_engine_table_counter_format_types,

    /**
     * Must be last one!
     */
    _dnx_data_crps_engine_table_nof
} dnx_data_crps_engine_table_e;

/* Get Data */
/**
 * \brief get table engines_info entry 
 * size of each counter engine and indication if it is shared with meter
 * 
 * \param [in] unit - unit #
 * \param [in] engine_id - engine id {0..(nof_counter_engines-1)}
 * 
 * \return
 *     engines_info - returns the relevant entry values grouped in struct - see dnx_data_crps_engine_engines_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_crps_engine_engines_info_t * dnx_data_crps_engine_engines_info_get(
    int unit,
    int engine_id);

/**
 * \brief get table source_base entry 
 * defines the base value for the source which is connected to the engine
 * 
 * \param [in] unit - unit #
 * \param [in] source - source id {according to API enum}
 * 
 * \return
 *     source_base - returns the relevant entry values grouped in struct - see dnx_data_crps_engine_source_base_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_crps_engine_source_base_t * dnx_data_crps_engine_source_base_get(
    int unit,
    int source);

/**
 * \brief get table counter_format_types entry 
 * Holds for each counter format rather or not it supported
 * 
 * \param [in] unit - unit #
 * \param [in] format_type - The counter format type
 * 
 * \return
 *     counter_format_types - returns the relevant entry values grouped in struct - see dnx_data_crps_engine_counter_format_types_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_crps_engine_counter_format_types_t * dnx_data_crps_engine_counter_format_types_get(
    int unit,
    int format_type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'crps', Submodule - 'engine', table - 'engines_info'
 * size of each counter engine and indication if it is shared with meter
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_engine_engines_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'crps', Submodule - 'engine', table - 'source_base'
 * defines the base value for the source which is connected to the engine
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_engine_source_base_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'crps', Submodule - 'engine', table - 'counter_format_types'
 * Holds for each counter format rather or not it supported
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_engine_counter_format_types_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)engines_info info
 * size of each counter engine and indication if it is shared with meter
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     engines_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_crps_engine_engines_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)source_base info
 * defines the base value for the source which is connected to the engine
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_base - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_crps_engine_source_base_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)counter_format_types info
 * Holds for each counter format rather or not it supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counter_format_types - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_crps_engine_counter_format_types_info_get(
    int unit);

/*
 * SUBMODULE EVICTION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_crps_eviction_feature_get(
    int unit,
    dnx_data_crps_eviction_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_crps_eviction_define_counters_fifo_depth,
    dnx_data_crps_eviction_define_nof_counters_fifo,
    dnx_data_crps_eviction_define_dma_record_entry_nof_bits,
    dnx_data_crps_eviction_define_bubble_before_request_timeout,
    dnx_data_crps_eviction_define_bubble_after_request_timeout,
    dnx_data_crps_eviction_define_seq_address_nof_bits,
    dnx_data_crps_eviction_define_nof_eviction_destination_types,
    dnx_data_crps_eviction_define_nof_crps_network_channels,
    dnx_data_crps_eviction_define_bg_thread_enable,

    /**
     * Must be last one!
     */
    _dnx_data_crps_eviction_define_nof
} dnx_data_crps_eviction_define_e;

/* Get Data */
/**
 * \brief returns define data of counters_fifo_depth
 * Module - 'crps', Submodule - 'eviction', data - 'counters_fifo_depth'
 * Indicates the FIFO depth in the host
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counters_fifo_depth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_counters_fifo_depth_get(
    int unit);

/**
 * \brief returns define data of nof_counters_fifo
 * Module - 'crps', Submodule - 'eviction', data - 'nof_counters_fifo'
 * Indicates the number of FIFOs available for CRPS (for each core)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_counters_fifo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_nof_counters_fifo_get(
    int unit);

/**
 * \brief returns define data of dma_record_entry_nof_bits
 * Module - 'crps', Submodule - 'eviction', data - 'dma_record_entry_nof_bits'
 * size (in bits) of one record that is copied by the DMA-FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_record_entry_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_dma_record_entry_nof_bits_get(
    int unit);

/**
 * \brief returns define data of bubble_before_request_timeout
 * Module - 'crps', Submodule - 'eviction', data - 'bubble_before_request_timeout'
 * The waiting period in clocks until requesting bubble, if EnginenScanBubbleRequestEnable=1
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bubble_before_request_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_bubble_before_request_timeout_get(
    int unit);

/**
 * \brief returns define data of bubble_after_request_timeout
 * Module - 'crps', Submodule - 'eviction', data - 'bubble_after_request_timeout'
 * The waiting period, after bubble reuest before forcing bubble (if force enable)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bubble_after_request_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_bubble_after_request_timeout_get(
    int unit);

/**
 * \brief returns define data of seq_address_nof_bits
 * Module - 'crps', Submodule - 'eviction', data - 'seq_address_nof_bits'
 * nof bit for sequential address (start/end)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     seq_address_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_seq_address_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_eviction_destination_types
 * Module - 'crps', Submodule - 'eviction', data - 'nof_eviction_destination_types'
 * number of supported diffrante destinations for eviction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eviction_destination_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_nof_eviction_destination_types_get(
    int unit);

/**
 * \brief returns define data of nof_crps_network_channels
 * Module - 'crps', Submodule - 'eviction', data - 'nof_crps_network_channels'
 * number of channels from CRPS to the IRE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_crps_network_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_nof_crps_network_channels_get(
    int unit);

/**
 * \brief returns numeric data of bg_thread_enable
 * Module - 'crps', Submodule - 'eviction', data - 'bg_thread_enable'
 * enable/disable counters bg thread operation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bg_thread_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_eviction_bg_thread_enable_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_crps_eviction_table_phy_record_format,
    dnx_data_crps_eviction_table_condional_action_valid,
    dnx_data_crps_eviction_table_supported_eviction_destination,

    /**
     * Must be last one!
     */
    _dnx_data_crps_eviction_table_nof
} dnx_data_crps_eviction_table_e;

/* Get Data */
/**
 * \brief get table phy_record_format entry 
 * holds the format of the physical record that is copied by the DMA from CRPS FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_record_format - returns the relevant entry values grouped in struct - see dnx_data_crps_eviction_phy_record_format_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_crps_eviction_phy_record_format_t * dnx_data_crps_eviction_phy_record_format_get(
    int unit);

/**
 * \brief get table condional_action_valid entry 
 * holds which action is valid
 * 
 * \param [in] unit - unit #
 * \param [in] action_idx - action idx flag {according to API flags}
 * 
 * \return
 *     condional_action_valid - returns the relevant entry values grouped in struct - see dnx_data_crps_eviction_condional_action_valid_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_crps_eviction_condional_action_valid_t * dnx_data_crps_eviction_condional_action_valid_get(
    int unit,
    int action_idx);

/**
 * \brief get table supported_eviction_destination entry 
 * Holds for each counter format rather or not it supported
 * 
 * \param [in] unit - unit #
 * \param [in] destination_type - The destination of the counters eviction
 * 
 * \return
 *     supported_eviction_destination - returns the relevant entry values grouped in struct - see dnx_data_crps_eviction_supported_eviction_destination_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_crps_eviction_supported_eviction_destination_t * dnx_data_crps_eviction_supported_eviction_destination_get(
    int unit,
    int destination_type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'crps', Submodule - 'eviction', table - 'phy_record_format'
 * holds the format of the physical record that is copied by the DMA from CRPS FIFO
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_eviction_phy_record_format_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'crps', Submodule - 'eviction', table - 'condional_action_valid'
 * holds which action is valid
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_eviction_condional_action_valid_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'crps', Submodule - 'eviction', table - 'supported_eviction_destination'
 * Holds for each counter format rather or not it supported
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_eviction_supported_eviction_destination_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)phy_record_format info
 * holds the format of the physical record that is copied by the DMA from CRPS FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_record_format - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_crps_eviction_phy_record_format_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)condional_action_valid info
 * holds which action is valid
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     condional_action_valid - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_crps_eviction_condional_action_valid_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_eviction_destination info
 * Holds for each counter format rather or not it supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_eviction_destination - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_crps_eviction_supported_eviction_destination_info_get(
    int unit);

/*
 * SUBMODULE EXPANSION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_crps_expansion_feature_get(
    int unit,
    dnx_data_crps_expansion_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_crps_expansion_define_expansion_size,

    /**
     * Must be last one!
     */
    _dnx_data_crps_expansion_define_nof
} dnx_data_crps_expansion_define_e;

/* Get Data */
/**
 * \brief returns define data of expansion_size
 * Module - 'crps', Submodule - 'expansion', data - 'expansion_size'
 * define the size of the expansion (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     expansion_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_expansion_expansion_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_crps_expansion_table_source_type,

    /**
     * Must be last one!
     */
    _dnx_data_crps_expansion_table_nof
} dnx_data_crps_expansion_table_e;

/* Get Data */
/**
 * \brief get table source_type entry 
 * Describes the metadata types supports for each crps source
 * 
 * \param [in] unit - unit #
 * \param [in] source - The crps interface that send the metadata
 * \param [in] metadata_type - The data type
 * 
 * \return
 *     source_type - returns the relevant entry values grouped in struct - see dnx_data_crps_expansion_source_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_crps_expansion_source_type_t * dnx_data_crps_expansion_source_type_get(
    int unit,
    int source,
    int metadata_type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'crps', Submodule - 'expansion', table - 'source_type'
 * Describes the metadata types supports for each crps source
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_expansion_source_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)source_type info
 * Describes the metadata types supports for each crps source
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_crps_expansion_source_type_info_get(
    int unit);

/*
 * SUBMODULE SRC_INTERFACE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_crps_src_interface_feature_get(
    int unit,
    dnx_data_crps_src_interface_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_crps_src_interface_define_nof
} dnx_data_crps_src_interface_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_crps_src_interface_table_command_id,

    /**
     * Must be last one!
     */
    _dnx_data_crps_src_interface_table_nof
} dnx_data_crps_src_interface_table_e;

/* Get Data */
/**
 * \brief get table command_id entry 
 * command_id data - possible values per source
 * 
 * \param [in] unit - unit #
 * \param [in] source - interface source
 * 
 * \return
 *     command_id - returns the relevant entry values grouped in struct - see dnx_data_crps_src_interface_command_id_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_crps_src_interface_command_id_t * dnx_data_crps_src_interface_command_id_get(
    int unit,
    int source);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'crps', Submodule - 'src_interface', table - 'command_id'
 * command_id data - possible values per source
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_src_interface_command_id_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)command_id info
 * command_id data - possible values per source
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_id - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_crps_src_interface_command_id_info_get(
    int unit);

/*
 * SUBMODULE LATENCY:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_crps_latency_feature_get(
    int unit,
    dnx_data_crps_latency_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_crps_latency_define_etpp_command_id,
    dnx_data_crps_latency_define_stat_id_port_offset,
    dnx_data_crps_latency_define_stat_id_tc_offset,
    dnx_data_crps_latency_define_stat_id_multicast_offset,

    /**
     * Must be last one!
     */
    _dnx_data_crps_latency_define_nof
} dnx_data_crps_latency_define_e;

/* Get Data */
/**
 * \brief returns define data of etpp_command_id
 * Module - 'crps', Submodule - 'latency', data - 'etpp_command_id'
 * etpp command id that can be used for latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     etpp_command_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_latency_etpp_command_id_get(
    int unit);

/**
 * \brief returns define data of stat_id_port_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_port_offset'
 * offset of the port in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_port_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_latency_stat_id_port_offset_get(
    int unit);

/**
 * \brief returns define data of stat_id_tc_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_tc_offset'
 * offset of the traffic class in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_tc_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_latency_stat_id_tc_offset_get(
    int unit);

/**
 * \brief returns define data of stat_id_multicast_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_multicast_offset'
 * offset of the multicast in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_multicast_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_crps_latency_stat_id_multicast_offset_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_crps_latency_table_nof
} dnx_data_crps_latency_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_crps_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_CRPS_H_*/
/* *INDENT-ON* */
