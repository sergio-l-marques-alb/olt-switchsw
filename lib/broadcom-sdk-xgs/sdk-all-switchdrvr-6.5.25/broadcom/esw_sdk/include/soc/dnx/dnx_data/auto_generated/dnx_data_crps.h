/** \file dnx_data_crps.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_CRPS_H_
/*{*/
#define _DNX_DATA_CRPS_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <bcm/stat.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_crps.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_crps
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_crps_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - ENGINE:
 * counters engine data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule engine table engines_info
 * Table info:
 * size of each counter engine and indication if it is shared with meter
 */
typedef struct
{
    /**
     * number of entries per engine
     */
    int nof_entries;
    /**
     * is engine is memory shared with meter
     */
    int meter_shared;
} dnx_data_crps_engine_engines_info_t;

/**
 * \brief Holds values of submodule engine table source_base
 * Table info:
 * defines the base value for the source which is connected to the engine
 */
typedef struct
{
    /**
     * the base value for the input source, in order to configure CRPS_ENGINE_SOURCE_SELECT field
     */
    int base_val;
} dnx_data_crps_engine_source_base_t;

/**
 * \brief Holds values of submodule engine table counter_format_types
 * Table info:
 * Holds for each counter format rather or not it supported
 */
typedef struct
{
    /**
     * validation for the counter format type
     */
    int valid;
    /**
     * number of bits for packets counting
     */
    int nof_bits_for_packets;
    /**
     * number of bits for bytes counting
     */
    int nof_bits_for_bytes;
    /**
     * number of counters form the current type in one engine entry
     */
    int nof_counters_per_entry;
    /**
     * The possible destinations the counter type can be evicted
     */
    bcm_eviction_destination_type_t valid_eviction_destinations[DNX_DATA_MAX_CRPS_EVICTION_NOF_EVICTION_DESTINATION_TYPES];
} dnx_data_crps_engine_counter_format_types_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is correct address admission supported for both double mode and not double mode?
     */
    dnx_data_crps_engine_valid_address_admission_is_supported,
    /**
     * Is diagnostic presenting last input command towards crps supported?
     */
    dnx_data_crps_engine_last_input_command_is_supported,
    /**
     * Is counter fill rate calculation supported
     */
    dnx_data_crps_engine_rate_calculation_is_supported,
    /**
     * Is crpas database can contain multi counter's set
     */
    dnx_data_crps_engine_multi_sets_is_supported,

    /**
     * Must be last one!
     */
    _dnx_data_crps_engine_feature_nof
} dnx_data_crps_engine_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_engine_feature_get_f) (
    int unit,
    dnx_data_crps_engine_feature_e feature);

/**
 * \brief returns define data of nof_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_engines'
 * Number of counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_engines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_mid_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_mid_engines'
 * Number of mid counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mid_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_mid_engines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_big_engines'
 * Number of big counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_big_engines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_databases
 * Module - 'crps', Submodule - 'engine', data - 'nof_databases'
 * Number of counter databases per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_databases - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_databases_get_f) (
    int unit);

/**
 * \brief returns define data of data_mapping_table_size
 * Module - 'crps', Submodule - 'engine', data - 'data_mapping_table_size'
 * Number of entries in data mappnig table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_mapping_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_data_mapping_table_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_counter_set_size
 * Module - 'crps', Submodule - 'engine', data - 'max_counter_set_size'
 * max size of the counter set
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_counter_set_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_max_counter_set_size_get_f) (
    int unit);

/**
 * \brief returns define data of oam_counter_set_size
 * Module - 'crps', Submodule - 'engine', data - 'oam_counter_set_size'
 * size of the counter set for OAM sources
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_counter_set_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_oam_counter_set_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_counter_sets
 * Module - 'crps', Submodule - 'engine', data - 'max_nof_counter_sets'
 * number of different counter sets supported per engine
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_counter_sets - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_max_nof_counter_sets_get_f) (
    int unit);

/**
 * \brief returns define data of last_address_nof_bits
 * Module - 'crps', Submodule - 'engine', data - 'last_address_nof_bits'
 * number of bits of last address admitted per engine
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     last_address_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_last_address_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of counter_format_nof_bits
 * Module - 'crps', Submodule - 'engine', data - 'counter_format_nof_bits'
 * number of bits to describe the engine counter format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counter_format_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_counter_format_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_small_meter_sherd_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_small_meter_sherd_engines'
 * number of small engines can allocate for the meter used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_meter_sherd_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_small_meter_sherd_engines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_mid_meter_sherd_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_mid_meter_sherd_engines'
 * number of medium engines can allocate for the meter used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mid_meter_sherd_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_mid_meter_sherd_engines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_meter_sherd_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_big_meter_sherd_engines'
 * number of big engines can allocate for the meter used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_meter_sherd_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_big_meter_sherd_engines_get_f) (
    int unit);

/**
 * \brief get table engines_info entry 
 * size of each counter engine and indication if it is shared with meter
 * 
 * \param [in] unit - unit #
 * \param [in] engine_id - engine id {0..(nof_counter_engines-1)}
 * 
 * \return
 *     engines_info - returns the relevant entry values grouped in struct - see dnx_data_crps_engine_engines_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_engine_engines_info_t *(
    *dnx_data_crps_engine_engines_info_get_f) (
    int unit,
    int engine_id);

/**
 * \brief get table source_base entry 
 * defines the base value for the source which is connected to the engine
 * 
 * \param [in] unit - unit #
 * \param [in] source - source id {according to API enum}
 * 
 * \return
 *     source_base - returns the relevant entry values grouped in struct - see dnx_data_crps_engine_source_base_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_engine_source_base_t *(
    *dnx_data_crps_engine_source_base_get_f) (
    int unit,
    int source);

/**
 * \brief get table counter_format_types entry 
 * Holds for each counter format rather or not it supported
 * 
 * \param [in] unit - unit #
 * \param [in] format_type - The counter format type
 * 
 * \return
 *     counter_format_types - returns the relevant entry values grouped in struct - see dnx_data_crps_engine_counter_format_types_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_engine_counter_format_types_t *(
    *dnx_data_crps_engine_counter_format_types_get_f) (
    int unit,
    int format_type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - ENGINE:
 * {
 */
/**
 * \brief Interface for crps engine data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_engine_feature_get_f feature_get;
    /**
     * returns define data of nof_engines
     */
    dnx_data_crps_engine_nof_engines_get_f nof_engines_get;
    /**
     * returns define data of nof_mid_engines
     */
    dnx_data_crps_engine_nof_mid_engines_get_f nof_mid_engines_get;
    /**
     * returns define data of nof_big_engines
     */
    dnx_data_crps_engine_nof_big_engines_get_f nof_big_engines_get;
    /**
     * returns define data of nof_databases
     */
    dnx_data_crps_engine_nof_databases_get_f nof_databases_get;
    /**
     * returns define data of data_mapping_table_size
     */
    dnx_data_crps_engine_data_mapping_table_size_get_f data_mapping_table_size_get;
    /**
     * returns define data of max_counter_set_size
     */
    dnx_data_crps_engine_max_counter_set_size_get_f max_counter_set_size_get;
    /**
     * returns define data of oam_counter_set_size
     */
    dnx_data_crps_engine_oam_counter_set_size_get_f oam_counter_set_size_get;
    /**
     * returns define data of max_nof_counter_sets
     */
    dnx_data_crps_engine_max_nof_counter_sets_get_f max_nof_counter_sets_get;
    /**
     * returns define data of last_address_nof_bits
     */
    dnx_data_crps_engine_last_address_nof_bits_get_f last_address_nof_bits_get;
    /**
     * returns define data of counter_format_nof_bits
     */
    dnx_data_crps_engine_counter_format_nof_bits_get_f counter_format_nof_bits_get;
    /**
     * returns define data of nof_small_meter_sherd_engines
     */
    dnx_data_crps_engine_nof_small_meter_sherd_engines_get_f nof_small_meter_sherd_engines_get;
    /**
     * returns define data of nof_mid_meter_sherd_engines
     */
    dnx_data_crps_engine_nof_mid_meter_sherd_engines_get_f nof_mid_meter_sherd_engines_get;
    /**
     * returns define data of nof_big_meter_sherd_engines
     */
    dnx_data_crps_engine_nof_big_meter_sherd_engines_get_f nof_big_meter_sherd_engines_get;
    /**
     * get table engines_info entry 
     */
    dnx_data_crps_engine_engines_info_get_f engines_info_get;
    /**
     * get general info table about table (for example key size)engines_info info
     */
    dnxc_data_table_info_get_f engines_info_info_get;
    /**
     * get table source_base entry 
     */
    dnx_data_crps_engine_source_base_get_f source_base_get;
    /**
     * get general info table about table (for example key size)source_base info
     */
    dnxc_data_table_info_get_f source_base_info_get;
    /**
     * get table counter_format_types entry 
     */
    dnx_data_crps_engine_counter_format_types_get_f counter_format_types_get;
    /**
     * get general info table about table (for example key size)counter_format_types info
     */
    dnxc_data_table_info_get_f counter_format_types_info_get;
} dnx_data_if_crps_engine_t;

/*
 * }
 */

/*
 * SUBMODULE  - EVICTION:
 * counters eviction parameters
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule eviction table phy_record_format
 * Table info:
 * holds the format of the physical record that is copied by the DMA from CRPS FIFO
 */
typedef struct
{
    /**
     * size 'obj_type' field base on its size
     */
    uint32 obj_type_size;
    /**
     * offset in the record for obj_type field
     */
    uint32 obj_type_offset;
    /**
     * size 'reserved0' field base on its size
     */
    int reserved0_size;
    /**
     * offset in the record for 'reserved0' field
     */
    int reserved0_offset;
    /**
     * 'opcode' type field base on its size
     */
    uint32 opcode_size;
    /**
     * offset in the record for 'opcode' field
     */
    uint32 opcode_offset;
    /**
     * size 'error indication' field base on its size
     */
    uint32 err_ind_size;
    /**
     * offset in the record for 'error indication' field
     */
    uint32 err_ind_offset;
    /**
     * size 'reserved1' field base on its size
     */
    int reserved1_size;
    /**
     * offset in the record for 'reserved1' field
     */
    int reserved1_offset;
    /**
     * size 'core id' field base on its size
     */
    uint32 core_id_size;
    /**
     * offset in the record for 'core id' field
     */
    uint32 core_id_offset;
    /**
     * size 'engine id' field base on its size
     */
    uint32 engine_id_size;
    /**
     * offset in the record for 'engine id' field
     */
    uint32 engine_id_offset;
    /**
     * size 'local counter id' field base on its size
     */
    uint32 local_ctr_id_size;
    /**
     * offset in the record for 'local counter id' field
     */
    uint32 local_ctr_id_offset;
    /**
     * size 'counter value' field base on its size
     */
    uint32 ctr_value_size;
    /**
     * offset in the record for 'counter value' field
     */
    uint32 ctr_value_offset;
    /**
     * size 'is probabilistic scan' field base on its size
     */
    int is_probabilistic_size;
    /**
     * offset in the record for 'is probabilistic scan' field
     */
    int is_probabilistic_offset;
} dnx_data_crps_eviction_phy_record_format_t;

/**
 * \brief Holds values of submodule eviction table condional_action_valid
 * Table info:
 * holds which action is valid
 */
typedef struct
{
    /**
     * condional action valid
     */
    uint32 valid;
} dnx_data_crps_eviction_condional_action_valid_t;

/**
 * \brief Holds values of submodule eviction table supported_eviction_destination
 * Table info:
 * Holds for each counter format rather or not it supported
 */
typedef struct
{
    /**
     * validation for the eviction destination
     */
    int valid;
} dnx_data_crps_eviction_supported_eviction_destination_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is algorithmic scan mode supported?
     */
    dnx_data_crps_eviction_algorithmic_is_supported,
    /**
     * Is probabilistic scan mode supported?
     */
    dnx_data_crps_eviction_probabilistic_is_supported,
    /**
     * Is probabilistic scan perform eviction in low/high rate
     */
    dnx_data_crps_eviction_low_rate_probabilistic_eviction,
    /**
     * Is conditional action scan is supported
     */
    dnx_data_crps_eviction_conditional_action_is_supported,
    /**
     * Indication to read entries from memory. Valid only for simulation.
     */
    dnx_data_crps_eviction_eviction_from_memory_is_supported,
    /**
     * Is sequential scan speed up supported
     */
    dnx_data_crps_eviction_sequential_scan_speedup_is_supported,
    /**
     * Is The probabilistic scan has configurable thresholds
     */
    dnx_data_crps_eviction_probabilistic_eviction_thresholds_is_supported,

    /**
     * Must be last one!
     */
    _dnx_data_crps_eviction_feature_nof
} dnx_data_crps_eviction_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_eviction_feature_get_f) (
    int unit,
    dnx_data_crps_eviction_feature_e feature);

/**
 * \brief returns define data of counters_fifo_depth
 * Module - 'crps', Submodule - 'eviction', data - 'counters_fifo_depth'
 * Indicates the FIFO depth in the host
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counters_fifo_depth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_counters_fifo_depth_get_f) (
    int unit);

/**
 * \brief returns define data of nof_counters_fifo
 * Module - 'crps', Submodule - 'eviction', data - 'nof_counters_fifo'
 * Indicates the number of FIFOs available for CRPS (for each core)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_counters_fifo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_nof_counters_fifo_get_f) (
    int unit);

/**
 * \brief returns define data of dma_record_entry_nof_bits
 * Module - 'crps', Submodule - 'eviction', data - 'dma_record_entry_nof_bits'
 * size (in bits) of one record that is copied by the DMA-FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_record_entry_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_dma_record_entry_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of bubble_before_request_timeout
 * Module - 'crps', Submodule - 'eviction', data - 'bubble_before_request_timeout'
 * The waiting period in clocks until requesting bubble, if EnginenScanBubbleRequestEnable=1
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bubble_before_request_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_bubble_before_request_timeout_get_f) (
    int unit);

/**
 * \brief returns define data of bubble_after_request_timeout
 * Module - 'crps', Submodule - 'eviction', data - 'bubble_after_request_timeout'
 * The waiting period, after bubble reuest before forcing bubble (if force enable)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bubble_after_request_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_bubble_after_request_timeout_get_f) (
    int unit);

/**
 * \brief returns define data of seq_address_nof_bits
 * Module - 'crps', Submodule - 'eviction', data - 'seq_address_nof_bits'
 * nof bit for sequential address (start/end)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     seq_address_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_seq_address_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_eviction_destination_types
 * Module - 'crps', Submodule - 'eviction', data - 'nof_eviction_destination_types'
 * number of supported diffrante destinations for eviction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eviction_destination_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_nof_eviction_destination_types_get_f) (
    int unit);

/**
 * \brief returns define data of nof_crps_network_channels
 * Module - 'crps', Submodule - 'eviction', data - 'nof_crps_network_channels'
 * number of channels from CRPS to the IRE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_crps_network_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_nof_crps_network_channels_get_f) (
    int unit);

/**
 * \brief returns numeric data of bg_thread_enable
 * Module - 'crps', Submodule - 'eviction', data - 'bg_thread_enable'
 * enable/disable counters bg thread operation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bg_thread_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_bg_thread_enable_get_f) (
    int unit);

/**
 * \brief get table phy_record_format entry 
 * holds the format of the physical record that is copied by the DMA from CRPS FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_record_format - returns the relevant entry values grouped in struct - see dnx_data_crps_eviction_phy_record_format_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_eviction_phy_record_format_t *(
    *dnx_data_crps_eviction_phy_record_format_get_f) (
    int unit);

/**
 * \brief get table condional_action_valid entry 
 * holds which action is valid
 * 
 * \param [in] unit - unit #
 * \param [in] action_idx - action idx flag {according to API flags}
 * 
 * \return
 *     condional_action_valid - returns the relevant entry values grouped in struct - see dnx_data_crps_eviction_condional_action_valid_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_eviction_condional_action_valid_t *(
    *dnx_data_crps_eviction_condional_action_valid_get_f) (
    int unit,
    int action_idx);

/**
 * \brief get table supported_eviction_destination entry 
 * Holds for each counter format rather or not it supported
 * 
 * \param [in] unit - unit #
 * \param [in] destination_type - The destination of the counters eviction
 * 
 * \return
 *     supported_eviction_destination - returns the relevant entry values grouped in struct - see dnx_data_crps_eviction_supported_eviction_destination_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_eviction_supported_eviction_destination_t *(
    *dnx_data_crps_eviction_supported_eviction_destination_get_f) (
    int unit,
    int destination_type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - EVICTION:
 * {
 */
/**
 * \brief Interface for crps eviction data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_eviction_feature_get_f feature_get;
    /**
     * returns define data of counters_fifo_depth
     */
    dnx_data_crps_eviction_counters_fifo_depth_get_f counters_fifo_depth_get;
    /**
     * returns define data of nof_counters_fifo
     */
    dnx_data_crps_eviction_nof_counters_fifo_get_f nof_counters_fifo_get;
    /**
     * returns define data of dma_record_entry_nof_bits
     */
    dnx_data_crps_eviction_dma_record_entry_nof_bits_get_f dma_record_entry_nof_bits_get;
    /**
     * returns define data of bubble_before_request_timeout
     */
    dnx_data_crps_eviction_bubble_before_request_timeout_get_f bubble_before_request_timeout_get;
    /**
     * returns define data of bubble_after_request_timeout
     */
    dnx_data_crps_eviction_bubble_after_request_timeout_get_f bubble_after_request_timeout_get;
    /**
     * returns define data of seq_address_nof_bits
     */
    dnx_data_crps_eviction_seq_address_nof_bits_get_f seq_address_nof_bits_get;
    /**
     * returns define data of nof_eviction_destination_types
     */
    dnx_data_crps_eviction_nof_eviction_destination_types_get_f nof_eviction_destination_types_get;
    /**
     * returns define data of nof_crps_network_channels
     */
    dnx_data_crps_eviction_nof_crps_network_channels_get_f nof_crps_network_channels_get;
    /**
     * returns numeric data of bg_thread_enable
     */
    dnx_data_crps_eviction_bg_thread_enable_get_f bg_thread_enable_get;
    /**
     * get table phy_record_format entry 
     */
    dnx_data_crps_eviction_phy_record_format_get_f phy_record_format_get;
    /**
     * get general info table about table (for example key size)phy_record_format info
     */
    dnxc_data_table_info_get_f phy_record_format_info_get;
    /**
     * get table condional_action_valid entry 
     */
    dnx_data_crps_eviction_condional_action_valid_get_f condional_action_valid_get;
    /**
     * get general info table about table (for example key size)condional_action_valid info
     */
    dnxc_data_table_info_get_f condional_action_valid_info_get;
    /**
     * get table supported_eviction_destination entry 
     */
    dnx_data_crps_eviction_supported_eviction_destination_get_f supported_eviction_destination_get;
    /**
     * get general info table about table (for example key size)supported_eviction_destination info
     */
    dnxc_data_table_info_get_f supported_eviction_destination_info_get;
} dnx_data_if_crps_eviction_t;

/*
 * }
 */

/*
 * SUBMODULE  - EXPANSION:
 * counters expansion parameters
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule expansion table source_type
 * Table info:
 * Describes the metadata types supports for each crps source
 */
typedef struct
{
    /**
     * The offset of the data type in the metadata record
     */
    int offset;
    /**
     * The maximum number of bits needed for the specific data type
     */
    int nof_bits;
} dnx_data_crps_expansion_source_type_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_crps_expansion_feature_nof
} dnx_data_crps_expansion_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_expansion_feature_get_f) (
    int unit,
    dnx_data_crps_expansion_feature_e feature);

/**
 * \brief returns define data of expansion_size
 * Module - 'crps', Submodule - 'expansion', data - 'expansion_size'
 * define the size of the expansion (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     expansion_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_expansion_expansion_size_get_f) (
    int unit);

/**
 * \brief get table source_type entry 
 * Describes the metadata types supports for each crps source
 * 
 * \param [in] unit - unit #
 * \param [in] source - The crps interface that send the metadata
 * \param [in] metadata_type - The data type
 * 
 * \return
 *     source_type - returns the relevant entry values grouped in struct - see dnx_data_crps_expansion_source_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_expansion_source_type_t *(
    *dnx_data_crps_expansion_source_type_get_f) (
    int unit,
    int source,
    int metadata_type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - EXPANSION:
 * {
 */
/**
 * \brief Interface for crps expansion data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_expansion_feature_get_f feature_get;
    /**
     * returns define data of expansion_size
     */
    dnx_data_crps_expansion_expansion_size_get_f expansion_size_get;
    /**
     * get table source_type entry 
     */
    dnx_data_crps_expansion_source_type_get_f source_type_get;
    /**
     * get general info table about table (for example key size)source_type info
     */
    dnxc_data_table_info_get_f source_type_info_get;
} dnx_data_if_crps_expansion_t;

/*
 * }
 */

/*
 * SUBMODULE  - SRC_INTERFACE:
 * source interface
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule src_interface table command_id
 * Table info:
 * command_id data - possible values per source
 */
typedef struct
{
    /**
     * maximum possible value for command_id for this source
     */
    uint32 size;
    /**
     * the base value - minimum value of the command_id
     */
    uint32 base;
} dnx_data_crps_src_interface_command_id_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_crps_src_interface_feature_nof
} dnx_data_crps_src_interface_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_src_interface_feature_get_f) (
    int unit,
    dnx_data_crps_src_interface_feature_e feature);

/**
 * \brief get table command_id entry 
 * command_id data - possible values per source
 * 
 * \param [in] unit - unit #
 * \param [in] source - interface source
 * 
 * \return
 *     command_id - returns the relevant entry values grouped in struct - see dnx_data_crps_src_interface_command_id_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_src_interface_command_id_t *(
    *dnx_data_crps_src_interface_command_id_get_f) (
    int unit,
    int source);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - SRC_INTERFACE:
 * {
 */
/**
 * \brief Interface for crps src_interface data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_src_interface_feature_get_f feature_get;
    /**
     * get table command_id entry 
     */
    dnx_data_crps_src_interface_command_id_get_f command_id_get;
    /**
     * get general info table about table (for example key size)command_id info
     */
    dnxc_data_table_info_get_f command_id_info_get;
} dnx_data_if_crps_src_interface_t;

/*
 * }
 */

/*
 * SUBMODULE  - LATENCY:
 * latency stat id definitions
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * can latency be measured per pp flow profile
     */
    dnx_data_crps_latency_valid_flow_profile,
    /**
     * can end to end aqm profile be created 
     */
    dnx_data_crps_latency_valid_end_to_end_aqm_profile,
    /**
     * is the probibalistic mark cni/drop mechanism supported (ingress deqeue latency marking)
     */
    dnx_data_crps_latency_drop_probabilistic_mechanism_support,

    /**
     * Must be last one!
     */
    _dnx_data_crps_latency_feature_nof
} dnx_data_crps_latency_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_latency_feature_get_f) (
    int unit,
    dnx_data_crps_latency_feature_e feature);

/**
 * \brief returns define data of etpp_command_id
 * Module - 'crps', Submodule - 'latency', data - 'etpp_command_id'
 * etpp command id that can be used for latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     etpp_command_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_latency_etpp_command_id_get_f) (
    int unit);

/**
 * \brief returns define data of stat_id_port_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_port_offset'
 * offset of the port in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_port_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_latency_stat_id_port_offset_get_f) (
    int unit);

/**
 * \brief returns define data of stat_id_tc_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_tc_offset'
 * offset of the traffic class in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_tc_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_latency_stat_id_tc_offset_get_f) (
    int unit);

/**
 * \brief returns define data of stat_id_multicast_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_multicast_offset'
 * offset of the multicast in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_multicast_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_latency_stat_id_multicast_offset_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - LATENCY:
 * {
 */
/**
 * \brief Interface for crps latency data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_latency_feature_get_f feature_get;
    /**
     * returns define data of etpp_command_id
     */
    dnx_data_crps_latency_etpp_command_id_get_f etpp_command_id_get;
    /**
     * returns define data of stat_id_port_offset
     */
    dnx_data_crps_latency_stat_id_port_offset_get_f stat_id_port_offset_get;
    /**
     * returns define data of stat_id_tc_offset
     */
    dnx_data_crps_latency_stat_id_tc_offset_get_f stat_id_tc_offset_get;
    /**
     * returns define data of stat_id_multicast_offset
     */
    dnx_data_crps_latency_stat_id_multicast_offset_get_f stat_id_multicast_offset_get;
} dnx_data_if_crps_latency_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_CRPS:
 * {
 */
/**
 * \brief Interface for crps data
 */
typedef struct
{
    /**
     * Interface for crps engine data
     */
    dnx_data_if_crps_engine_t engine;
    /**
     * Interface for crps eviction data
     */
    dnx_data_if_crps_eviction_t eviction;
    /**
     * Interface for crps expansion data
     */
    dnx_data_if_crps_expansion_t expansion;
    /**
     * Interface for crps src_interface data
     */
    dnx_data_if_crps_src_interface_t src_interface;
    /**
     * Interface for crps latency data
     */
    dnx_data_if_crps_latency_t latency;
} dnx_data_if_crps_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_crps_t dnx_data_crps;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_CRPS_H_*/
/* *INDENT-ON* */
