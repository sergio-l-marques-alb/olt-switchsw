/** \file dnx_data_internal_dram.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_DRAM_H_
/*{*/
#define _DNX_DATA_INTERNAL_DRAM_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_dram.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_dram_submodule_hbm,
    dnx_data_dram_submodule_gddr6,
    dnx_data_dram_submodule_general_info,
    dnx_data_dram_submodule_address_translation,
    dnx_data_dram_submodule_buffers,
    dnx_data_dram_submodule_dram_block,
    dnx_data_dram_submodule_dbal,
    dnx_data_dram_submodule_firmware,
    dnx_data_dram_submodule_apd_phy,
    dnx_data_dram_submodule_ctests,

    /**
     * Must be last one!
     */
    _dnx_data_dram_submodule_nof
} dnx_data_dram_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE HBM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_hbm_feature_get(
    int unit,
    dnx_data_dram_hbm_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_hbm_define_burst_length,
    dnx_data_dram_hbm_define_stop_traffic_temp_threshold,
    dnx_data_dram_hbm_define_stop_traffic_low_temp_threshold,
    dnx_data_dram_hbm_define_restore_traffic_temp_threshold,
    dnx_data_dram_hbm_define_restore_traffic_low_temp_threshold,
    dnx_data_dram_hbm_define_usec_between_temp_samples,
    dnx_data_dram_hbm_define_power_down_temp_threshold,
    dnx_data_dram_hbm_define_power_down_low_temp_threshold,
    dnx_data_dram_hbm_define_dram_temp_monitor_enable,
    dnx_data_dram_hbm_define_start_disabled,
    dnx_data_dram_hbm_define_output_enable_length,
    dnx_data_dram_hbm_define_output_enable_delay,
    dnx_data_dram_hbm_define_driver_strength,
    dnx_data_dram_hbm_define_t_rdlat_offset,
    dnx_data_dram_hbm_define_default_model_part_num,
    dnx_data_dram_hbm_define_nof_channel_dwords,
    dnx_data_dram_hbm_define_wds_size,

    /**
     * Must be last one!
     */
    _dnx_data_dram_hbm_define_nof
} dnx_data_dram_hbm_define_e;

/* Get Data */
/**
 * \brief returns numeric data of burst_length
 * Module - 'dram', Submodule - 'hbm', data - 'burst_length'
 * burst length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_burst_length_get(
    int unit);

/**
 * \brief returns numeric data of stop_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_temp_threshold'
 * temperature threshold (C degrees) above which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_stop_traffic_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of stop_traffic_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_low_temp_threshold'
 * Low temperature threshold (C degrees) below which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_stop_traffic_low_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of restore_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_temp_threshold'
 * temperature threshold (C degrees) below which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_restore_traffic_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of restore_traffic_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_low_temp_threshold'
 * Low temperature threshold (C degrees) above which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_restore_traffic_low_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of usec_between_temp_samples
 * Module - 'dram', Submodule - 'hbm', data - 'usec_between_temp_samples'
 * time in usecs to wait between HBM temperature sampling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     usec_between_temp_samples - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_usec_between_temp_samples_get(
    int unit);

/**
 * \brief returns numeric data of power_down_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_temp_threshold'
 * temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_power_down_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of power_down_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_low_temp_threshold'
 * Low temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_power_down_low_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of dram_temp_monitor_enable
 * Module - 'dram', Submodule - 'hbm', data - 'dram_temp_monitor_enable'
 * enable/disable driver temperature monitoring
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_temp_monitor_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_dram_temp_monitor_enable_get(
    int unit);

/**
 * \brief returns numeric data of start_disabled
 * Module - 'dram', Submodule - 'hbm', data - 'start_disabled'
 * do not start DRAM during BCM init
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     start_disabled - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_start_disabled_get(
    int unit);

/**
 * \brief returns numeric data of output_enable_length
 * Module - 'dram', Submodule - 'hbm', data - 'output_enable_length'
 * Output enable length pipeline param
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     output_enable_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_output_enable_length_get(
    int unit);

/**
 * \brief returns numeric data of output_enable_delay
 * Module - 'dram', Submodule - 'hbm', data - 'output_enable_delay'
 * Output enable delay pipeline param
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     output_enable_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_output_enable_delay_get(
    int unit);

/**
 * \brief returns numeric data of driver_strength
 * Module - 'dram', Submodule - 'hbm', data - 'driver_strength'
 * nominal driver strength
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     driver_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_driver_strength_get(
    int unit);

/**
 * \brief returns numeric data of t_rdlat_offset
 * Module - 'dram', Submodule - 'hbm', data - 't_rdlat_offset'
 * PHY FIFO read latency param
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     t_rdlat_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_t_rdlat_offset_get(
    int unit);

/**
 * \brief returns define data of default_model_part_num
 * Module - 'dram', Submodule - 'hbm', data - 'default_model_part_num'
 * default model part number
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_model_part_num - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_default_model_part_num_get(
    int unit);

/**
 * \brief returns define data of nof_channel_dwords
 * Module - 'dram', Submodule - 'hbm', data - 'nof_channel_dwords'
 * Number of DWORDs in a channel
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channel_dwords - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_nof_channel_dwords_get(
    int unit);

/**
 * \brief returns define data of wds_size
 * Module - 'dram', Submodule - 'hbm', data - 'wds_size'
 * Size of the Write Data Storage memory
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wds_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_wds_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_hbm_table_channel_symmetric_regs,
    dnx_data_dram_hbm_table_channel_not_symmetric_regs,
    dnx_data_dram_hbm_table_controller_symmetric_regs,
    dnx_data_dram_hbm_table_controller_not_symmetric_regs,
    dnx_data_dram_hbm_table_channel_interrupt_regs,
    dnx_data_dram_hbm_table_controller_interrupt_regs,
    dnx_data_dram_hbm_table_channel_debug_regs,
    dnx_data_dram_hbm_table_channel_counter_regs,
    dnx_data_dram_hbm_table_channel_type_regs,
    dnx_data_dram_hbm_table_controller_info_regs,
    dnx_data_dram_hbm_table_bist,
    dnx_data_dram_hbm_table_hbc_last_in_chain,
    dnx_data_dram_hbm_table_hbc_sbus_chain,
    dnx_data_dram_hbm_table_dll_and_qc_conf_vals_per_freq_range,

    /**
     * Must be last one!
     */
    _dnx_data_dram_hbm_table_nof
} dnx_data_dram_hbm_table_e;

/* Get Data */
/**
 * \brief get table channel_symmetric_regs entry 
 * per channel list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_symmetric_regs_t * dnx_data_dram_hbm_channel_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_not_symmetric_regs entry 
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_not_symmetric_regs_t * dnx_data_dram_hbm_channel_not_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_symmetric_regs entry 
 * per controller list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_symmetric_regs_t * dnx_data_dram_hbm_controller_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_not_symmetric_regs entry 
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_not_symmetric_regs_t * dnx_data_dram_hbm_controller_not_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_interrupt_regs_t * dnx_data_dram_hbm_channel_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per controller list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_interrupt_regs_t * dnx_data_dram_hbm_controller_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_debug_regs_t * dnx_data_dram_hbm_channel_debug_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_counter_regs_t * dnx_data_dram_hbm_channel_counter_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_type_regs_t * dnx_data_dram_hbm_channel_type_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_info_regs_t * dnx_data_dram_hbm_controller_info_regs_get(
    int unit,
    int index);

/**
 * \brief get table bist entry 
 * BIST configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_bist_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_bist_t * dnx_data_dram_hbm_bist_get(
    int unit);

/**
 * \brief get table hbc_last_in_chain entry 
 * Mark the last HBC block in SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] dram_bitmap - active drams bitmap
 * \param [in] dram_index - dram index
 * 
 * \return
 *     hbc_last_in_chain - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_hbc_last_in_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_hbc_last_in_chain_t * dnx_data_dram_hbm_hbc_last_in_chain_get(
    int unit,
    int dram_bitmap,
    int dram_index);

/**
 * \brief get table hbc_sbus_chain entry 
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] channel - hbc channel
 * 
 * \return
 *     hbc_sbus_chain - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_hbc_sbus_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_hbc_sbus_chain_t * dnx_data_dram_hbm_hbc_sbus_chain_get(
    int unit,
    int channel);

/**
 * \brief get table dll_and_qc_conf_vals_per_freq_range entry 
 * Table to match DLL and QC Delay configuration values to frequency range. See HBM2e PHY spec for details
 * 
 * \param [in] unit - unit #
 * \param [in] index - index
 * 
 * \return
 *     dll_and_qc_conf_vals_per_freq_range - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_dll_and_qc_conf_vals_per_freq_range_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_dll_and_qc_conf_vals_per_freq_range_t * dnx_data_dram_hbm_dll_and_qc_conf_vals_per_freq_range_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_symmetric_regs'
 * per channel list of symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_not_symmetric_regs'
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_not_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_symmetric_regs'
 * per controller list of symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_not_symmetric_regs'
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_not_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_interrupt_regs'
 * per channel list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_interrupt_regs'
 * per controller list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_debug_regs'
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_debug_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_counter_regs'
 * per channel list of counter registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_counter_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_type_regs'
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_type_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_info_regs'
 * per contorller list of info registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_info_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'bist'
 * BIST configuration
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_bist_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'hbc_last_in_chain'
 * Mark the last HBC block in SBUS chain
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_hbc_last_in_chain_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'hbc_sbus_chain'
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_hbc_sbus_chain_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'dll_and_qc_conf_vals_per_freq_range'
 * Table to match DLL and QC Delay configuration values to frequency range. See HBM2e PHY spec for details
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_dll_and_qc_conf_vals_per_freq_range_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)channel_symmetric_regs info
 * per channel list of symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_not_symmetric_regs info
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_not_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_not_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_symmetric_regs info
 * per controller list of symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_not_symmetric_regs info
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_not_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_not_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_interrupt_regs info
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_interrupt_regs info
 * per controller list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_debug_regs info
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_debug_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_debug_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_counter_regs info
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_counter_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_counter_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_type_regs info
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_type_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_type_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_info_regs info
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_info_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_info_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)bist info
 * BIST configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_bist_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)hbc_last_in_chain info
 * Mark the last HBC block in SBUS chain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbc_last_in_chain - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_hbc_last_in_chain_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)hbc_sbus_chain info
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbc_sbus_chain - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_hbc_sbus_chain_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dll_and_qc_conf_vals_per_freq_range info
 * Table to match DLL and QC Delay configuration values to frequency range. See HBM2e PHY spec for details
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dll_and_qc_conf_vals_per_freq_range - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_dll_and_qc_conf_vals_per_freq_range_info_get(
    int unit);

/*
 * SUBMODULE GDDR6:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_gddr6_feature_get(
    int unit,
    dnx_data_dram_gddr6_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_gddr6_define_nof_ca_bits,
    dnx_data_dram_gddr6_define_bytes_per_channel,
    dnx_data_dram_gddr6_define_training_fifo_depth,
    dnx_data_dram_gddr6_define_readout_to_readout_prd,
    dnx_data_dram_gddr6_define_refresh_to_readout_prd,
    dnx_data_dram_gddr6_define_readout_done_to_done_prd,
    dnx_data_dram_gddr6_define_refresh_mechanism_enable,
    dnx_data_dram_gddr6_define_bist_enable,
    dnx_data_dram_gddr6_define_dynamic_calibration_enable,
    dnx_data_dram_gddr6_define_cdr_enable,
    dnx_data_dram_gddr6_define_write_recovery,
    dnx_data_dram_gddr6_define_cabi,
    dnx_data_dram_gddr6_define_dram_mode,
    dnx_data_dram_gddr6_define_cal_termination,
    dnx_data_dram_gddr6_define_cah_termination,
    dnx_data_dram_gddr6_define_command_pipe_extra_delay,
    dnx_data_dram_gddr6_define_use_11bits_ca,
    dnx_data_dram_gddr6_define_ck_odt,
    dnx_data_dram_gddr6_define_dynamic_calibration_period,
    dnx_data_dram_gddr6_define_ck_termination,
    dnx_data_dram_gddr6_define_wck_granularity,
    dnx_data_dram_gddr6_define_ref_clk_bitmap,

    /**
     * Must be last one!
     */
    _dnx_data_dram_gddr6_define_nof
} dnx_data_dram_gddr6_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ca_bits
 * Module - 'dram', Submodule - 'gddr6', data - 'nof_ca_bits'
 * number of command address bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ca_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_nof_ca_bits_get(
    int unit);

/**
 * \brief returns define data of bytes_per_channel
 * Module - 'dram', Submodule - 'gddr6', data - 'bytes_per_channel'
 * bytes per channel in GDDR6 dram
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_per_channel - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_bytes_per_channel_get(
    int unit);

/**
 * \brief returns define data of training_fifo_depth
 * Module - 'dram', Submodule - 'gddr6', data - 'training_fifo_depth'
 * the depth of the training fifo in GDDR6 dram
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     training_fifo_depth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_training_fifo_depth_get(
    int unit);

/**
 * \brief returns define data of readout_to_readout_prd
 * Module - 'dram', Submodule - 'gddr6', data - 'readout_to_readout_prd'
 * Number of AB (all-banks) refresh to wait between consecutive temperature readout iterations
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     readout_to_readout_prd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_readout_to_readout_prd_get(
    int unit);

/**
 * \brief returns define data of refresh_to_readout_prd
 * Module - 'dram', Submodule - 'gddr6', data - 'refresh_to_readout_prd'
 * Period between AB (all-banks) refresh to MRS command triggering the temperature readout
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_to_readout_prd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_refresh_to_readout_prd_get(
    int unit);

/**
 * \brief returns define data of readout_done_to_done_prd
 * Module - 'dram', Submodule - 'gddr6', data - 'readout_done_to_done_prd'
 * Period between vendor_id engine done till readout engine done
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     readout_done_to_done_prd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_readout_done_to_done_prd_get(
    int unit);

/**
 * \brief returns numeric data of refresh_mechanism_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'refresh_mechanism_enable'
 * TSM refresh mechanism enable
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_mechanism_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_refresh_mechanism_enable_get(
    int unit);

/**
 * \brief returns numeric data of bist_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'bist_enable'
 * DRAM bist enable
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_bist_enable_get(
    int unit);

/**
 * \brief returns numeric data of dynamic_calibration_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'dynamic_calibration_enable'
 * Enable dynamic calibration on init
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dynamic_calibration_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_dynamic_calibration_enable_get(
    int unit);

/**
 * \brief returns numeric data of cdr_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'cdr_enable'
 * Enable CDR step when running dram tune on init
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_cdr_enable_get(
    int unit);

/**
 * \brief returns numeric data of write_recovery
 * Module - 'dram', Submodule - 'gddr6', data - 'write_recovery'
 * write recovery
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_recovery - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_write_recovery_get(
    int unit);

/**
 * \brief returns numeric data of cabi
 * Module - 'dram', Submodule - 'gddr6', data - 'cabi'
 * enable cabi
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cabi - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_cabi_get(
    int unit);

/**
 * \brief returns numeric data of dram_mode
 * Module - 'dram', Submodule - 'gddr6', data - 'dram_mode'
 * dram mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_dram_mode_get(
    int unit);

/**
 * \brief returns numeric data of cal_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'cal_termination'
 * CAL Termination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_cal_termination_get(
    int unit);

/**
 * \brief returns numeric data of cah_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'cah_termination'
 * CAH Termination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cah_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_cah_termination_get(
    int unit);

/**
 * \brief returns numeric data of command_pipe_extra_delay
 * Module - 'dram', Submodule - 'gddr6', data - 'command_pipe_extra_delay'
 * command pipe extra delay
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_pipe_extra_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_command_pipe_extra_delay_get(
    int unit);

/**
 * \brief returns numeric data of use_11bits_ca
 * Module - 'dram', Submodule - 'gddr6', data - 'use_11bits_ca'
 * use 11bits for command address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     use_11bits_ca - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_use_11bits_ca_get(
    int unit);

/**
 * \brief returns numeric data of ck_odt
 * Module - 'dram', Submodule - 'gddr6', data - 'ck_odt'
 * CK ODT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ck_odt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_ck_odt_get(
    int unit);

/**
 * \brief returns numeric data of dynamic_calibration_period
 * Module - 'dram', Submodule - 'gddr6', data - 'dynamic_calibration_period'
 * time between 2 iterations of dynamic calibration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dynamic_calibration_period - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_dynamic_calibration_period_get(
    int unit);

/**
 * \brief returns numeric data of ck_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'ck_termination'
 * Determines CK line termination. See GDDR JEDEC for details
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ck_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_ck_termination_get(
    int unit);

/**
 * \brief returns numeric data of wck_granularity
 * Module - 'dram', Submodule - 'gddr6', data - 'wck_granularity'
 * Data bandwidth for each WCK (byte or 2 bytes), see GDDR JEDEC for details
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wck_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_wck_granularity_get(
    int unit);

/**
 * \brief returns numeric data of ref_clk_bitmap
 * Module - 'dram', Submodule - 'gddr6', data - 'ref_clk_bitmap'
 * Indicates which DRAM is master in relation to reference clock (that is, which PHY interface is connected to reference clock)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ref_clk_bitmap - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_gddr6_ref_clk_bitmap_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_gddr6_table_refresh_intervals,
    dnx_data_dram_gddr6_table_dq_map,
    dnx_data_dram_gddr6_table_dq_channel_swap,
    dnx_data_dram_gddr6_table_dq_byte_map,
    dnx_data_dram_gddr6_table_ca_map,
    dnx_data_dram_gddr6_table_cadt_byte_map,
    dnx_data_dram_gddr6_table_channel_regs,
    dnx_data_dram_gddr6_table_controller_regs,
    dnx_data_dram_gddr6_table_channel_interrupt_regs,
    dnx_data_dram_gddr6_table_controller_interrupt_regs,
    dnx_data_dram_gddr6_table_channel_debug_regs,
    dnx_data_dram_gddr6_table_channel_counter_regs,
    dnx_data_dram_gddr6_table_channel_type_regs,
    dnx_data_dram_gddr6_table_controller_info_regs,
    dnx_data_dram_gddr6_table_master_phy,

    /**
     * Must be last one!
     */
    _dnx_data_dram_gddr6_table_nof
} dnx_data_dram_gddr6_table_e;

/* Get Data */
/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_refresh_intervals_t * dnx_data_dram_gddr6_refresh_intervals_get(
    int unit);

/**
 * \brief get table dq_map entry 
 * DQ swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] byte - bit on dram
 * 
 * \return
 *     dq_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_dq_map_t * dnx_data_dram_gddr6_dq_map_get(
    int unit,
    int dram_index,
    int byte);

/**
 * \brief get table dq_channel_swap entry 
 * DQ channel swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * 
 * \return
 *     dq_channel_swap - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_channel_swap_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_dq_channel_swap_t * dnx_data_dram_gddr6_dq_channel_swap_get(
    int unit,
    int dram_index);

/**
 * \brief get table dq_byte_map entry 
 * DQ bytes swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] byte - byte on dram
 * 
 * \return
 *     dq_byte_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_byte_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_dq_byte_map_t * dnx_data_dram_gddr6_dq_byte_map_get(
    int unit,
    int dram_index,
    int byte);

/**
 * \brief get table ca_map entry 
 * command address bit swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] channel - command address bit
 * 
 * \return
 *     ca_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_ca_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_ca_map_t * dnx_data_dram_gddr6_ca_map_get(
    int unit,
    int dram_index,
    int channel);

/**
 * \brief get table cadt_byte_map entry 
 * bytes swapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] channel - dram controller channel
 * 
 * \return
 *     cadt_byte_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_cadt_byte_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_cadt_byte_map_t * dnx_data_dram_gddr6_cadt_byte_map_get(
    int unit,
    int dram_index,
    int channel);

/**
 * \brief get table channel_regs entry 
 * per channel list of registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_regs_t * dnx_data_dram_gddr6_channel_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_regs entry 
 * per phy controller list of registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_controller_regs_t * dnx_data_dram_gddr6_controller_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_interrupt_regs_t * dnx_data_dram_gddr6_channel_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per phy list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_controller_interrupt_regs_t * dnx_data_dram_gddr6_controller_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_debug_regs_t * dnx_data_dram_gddr6_channel_debug_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_counter_regs_t * dnx_data_dram_gddr6_channel_counter_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_channel_type_regs_t * dnx_data_dram_gddr6_channel_type_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_controller_info_regs_t * dnx_data_dram_gddr6_controller_info_regs_get(
    int unit,
    int index);

/**
 * \brief get table master_phy entry 
 * The resistors for ZQ calibration are connected only to one of the drams, which we denote as master phy. The other dram is denoted as slave phy
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - index of dram
 * 
 * \return
 *     master_phy - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_master_phy_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_gddr6_master_phy_t * dnx_data_dram_gddr6_master_phy_get(
    int unit,
    int dram_index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'refresh_intervals'
 * refresh intervals timing parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_refresh_intervals_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'dq_map'
 * DQ swap mapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_dq_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'dq_channel_swap'
 * DQ channel swap mapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_dq_channel_swap_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'dq_byte_map'
 * DQ bytes swap mapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_dq_byte_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'ca_map'
 * command address bit swap mapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_ca_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'cadt_byte_map'
 * bytes swapping on boards
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_cadt_byte_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_regs'
 * per channel list of registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'controller_regs'
 * per phy controller list of registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_controller_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_interrupt_regs'
 * per channel list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'controller_interrupt_regs'
 * per phy list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_controller_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_debug_regs'
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_debug_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_counter_regs'
 * per channel list of counter registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_counter_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'channel_type_regs'
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_channel_type_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'controller_info_regs'
 * per contorller list of info registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_controller_info_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'gddr6', table - 'master_phy'
 * The resistors for ZQ calibration are connected only to one of the drams, which we denote as master phy. The other dram is denoted as slave phy
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_gddr6_master_phy_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)refresh_intervals info
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_refresh_intervals_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dq_map info
 * DQ swap mapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_dq_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dq_channel_swap info
 * DQ channel swap mapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_channel_swap - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_dq_channel_swap_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dq_byte_map info
 * DQ bytes swap mapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_byte_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_dq_byte_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ca_map info
 * command address bit swap mapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ca_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_ca_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)cadt_byte_map info
 * bytes swapping on boards
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cadt_byte_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_cadt_byte_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_regs info
 * per channel list of registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_regs info
 * per phy controller list of registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_controller_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_interrupt_regs info
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_interrupt_regs info
 * per phy list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_controller_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_debug_regs info
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_debug_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_debug_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_counter_regs info
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_counter_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_counter_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_type_regs info
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_type_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_channel_type_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_info_regs info
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_info_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_controller_info_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)master_phy info
 * The resistors for ZQ calibration are connected only to one of the drams, which we denote as master phy. The other dram is denoted as slave phy
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     master_phy - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_gddr6_master_phy_info_get(
    int unit);

/*
 * SUBMODULE GENERAL_INFO:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_general_info_feature_get(
    int unit,
    dnx_data_dram_general_info_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_general_info_define_otp_restore_version,
    dnx_data_dram_general_info_define_max_nof_drams,
    dnx_data_dram_general_info_define_nof_channels,
    dnx_data_dram_general_info_define_mr_mask,
    dnx_data_dram_general_info_define_nof_mrs,
    dnx_data_dram_general_info_define_phy_address_mask,
    dnx_data_dram_general_info_define_max_dram_index,
    dnx_data_dram_general_info_define_min_dram_index,
    dnx_data_dram_general_info_define_frequency,
    dnx_data_dram_general_info_define_buffer_size,
    dnx_data_dram_general_info_define_command_address_parity,
    dnx_data_dram_general_info_define_dq_write_parity,
    dnx_data_dram_general_info_define_dq_read_parity,
    dnx_data_dram_general_info_define_dbi_read,
    dnx_data_dram_general_info_define_dbi_write,
    dnx_data_dram_general_info_define_write_latency,
    dnx_data_dram_general_info_define_write_latency_hbm2e,
    dnx_data_dram_general_info_define_read_latency,
    dnx_data_dram_general_info_define_read_latency_hbm2e,
    dnx_data_dram_general_info_define_read_data_enable_delay,
    dnx_data_dram_general_info_define_read_data_enable_length,
    dnx_data_dram_general_info_define_parity_latency,
    dnx_data_dram_general_info_define_actual_parity_latency,
    dnx_data_dram_general_info_define_tune_mode_on_init,
    dnx_data_dram_general_info_define_command_parity_latency,
    dnx_data_dram_general_info_define_crc_write_latency,
    dnx_data_dram_general_info_define_crc_read_latency,
    dnx_data_dram_general_info_define_crc_write,
    dnx_data_dram_general_info_define_crc_read,
    dnx_data_dram_general_info_define_device_size,
    dnx_data_dram_general_info_define_supported_dram_bitmap,
    dnx_data_dram_general_info_define_dram_bitmap_internal,

    /**
     * Must be last one!
     */
    _dnx_data_dram_general_info_define_nof
} dnx_data_dram_general_info_define_e;

/* Get Data */
/**
 * \brief returns define data of otp_restore_version
 * Module - 'dram', Submodule - 'general_info', data - 'otp_restore_version'
 * when restoring from OTP the tune data, do it according to the given version format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     otp_restore_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_otp_restore_version_get(
    int unit);

/**
 * \brief returns define data of max_nof_drams
 * Module - 'dram', Submodule - 'general_info', data - 'max_nof_drams'
 * max number of drams supported for this device - in other words the size of the dram bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_drams - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_max_nof_drams_get(
    int unit);

/**
 * \brief returns define data of nof_channels
 * Module - 'dram', Submodule - 'general_info', data - 'nof_channels'
 * max number of dram channels supported for this device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_nof_channels_get(
    int unit);

/**
 * \brief returns define data of mr_mask
 * Module - 'dram', Submodule - 'general_info', data - 'mr_mask'
 * mode register bit mask
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mr_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_mr_mask_get(
    int unit);

/**
 * \brief returns define data of nof_mrs
 * Module - 'dram', Submodule - 'general_info', data - 'nof_mrs'
 * number of mode registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mrs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_nof_mrs_get(
    int unit);

/**
 * \brief returns define data of phy_address_mask
 * Module - 'dram', Submodule - 'general_info', data - 'phy_address_mask'
 * bit mask to describe the relevant bits in phy register address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_address_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_phy_address_mask_get(
    int unit);

/**
 * \brief returns numeric data of max_dram_index
 * Module - 'dram', Submodule - 'general_info', data - 'max_dram_index'
 * max dram index from bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_dram_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_max_dram_index_get(
    int unit);

/**
 * \brief returns numeric data of min_dram_index
 * Module - 'dram', Submodule - 'general_info', data - 'min_dram_index'
 * min dram index from bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_dram_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_min_dram_index_get(
    int unit);

/**
 * \brief returns numeric data of frequency
 * Module - 'dram', Submodule - 'general_info', data - 'frequency'
 * dram frequency (in MHZ), used to calculated data_rate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     frequency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_frequency_get(
    int unit);

/**
 * \brief returns numeric data of buffer_size
 * Module - 'dram', Submodule - 'general_info', data - 'buffer_size'
 * dram buffer size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     buffer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_buffer_size_get(
    int unit);

/**
 * \brief returns numeric data of command_address_parity
 * Module - 'dram', Submodule - 'general_info', data - 'command_address_parity'
 * command address parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_address_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_command_address_parity_get(
    int unit);

/**
 * \brief returns numeric data of dq_write_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_write_parity'
 * dq write parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_write_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dq_write_parity_get(
    int unit);

/**
 * \brief returns numeric data of dq_read_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_read_parity'
 * dq read parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_read_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dq_read_parity_get(
    int unit);

/**
 * \brief returns numeric data of dbi_read
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_read'
 * dbi read
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dbi_read_get(
    int unit);

/**
 * \brief returns numeric data of dbi_write
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_write'
 * dbi write
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dbi_write_get(
    int unit);

/**
 * \brief returns numeric data of write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'write_latency'
 * write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_write_latency_get(
    int unit);

/**
 * \brief returns numeric data of write_latency_hbm2e
 * Module - 'dram', Submodule - 'general_info', data - 'write_latency_hbm2e'
 * write latency for HBM2E DRAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_latency_hbm2e - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_write_latency_hbm2e_get(
    int unit);

/**
 * \brief returns numeric data of read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'read_latency'
 * read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_read_latency_get(
    int unit);

/**
 * \brief returns numeric data of read_latency_hbm2e
 * Module - 'dram', Submodule - 'general_info', data - 'read_latency_hbm2e'
 * read latency for HBM2E DRAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_latency_hbm2e - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_read_latency_hbm2e_get(
    int unit);

/**
 * \brief returns numeric data of read_data_enable_delay
 * Module - 'dram', Submodule - 'general_info', data - 'read_data_enable_delay'
 * read data enable delay
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_data_enable_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_read_data_enable_delay_get(
    int unit);

/**
 * \brief returns numeric data of read_data_enable_length
 * Module - 'dram', Submodule - 'general_info', data - 'read_data_enable_length'
 * read data enable length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_data_enable_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_read_data_enable_length_get(
    int unit);

/**
 * \brief returns numeric data of parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'parity_latency'
 * parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_parity_latency_get(
    int unit);

/**
 * \brief returns numeric data of actual_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'actual_parity_latency'
 * parity latency to be used after factoring in the effect of other numerics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     actual_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_actual_parity_latency_get(
    int unit);

/**
 * \brief returns numeric data of tune_mode_on_init
 * Module - 'dram', Submodule - 'general_info', data - 'tune_mode_on_init'
 * tune mode during init sequence
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tune_mode_on_init - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_tune_mode_on_init_get(
    int unit);

/**
 * \brief returns numeric data of command_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'command_parity_latency'
 * command parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_command_parity_latency_get(
    int unit);

/**
 * \brief returns numeric data of crc_write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'crc_write_latency'
 * crc write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_crc_write_latency_get(
    int unit);

/**
 * \brief returns numeric data of crc_read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'crc_read_latency'
 * crc read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_crc_read_latency_get(
    int unit);

/**
 * \brief returns numeric data of crc_write
 * Module - 'dram', Submodule - 'general_info', data - 'crc_write'
 * write crc
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_crc_write_get(
    int unit);

/**
 * \brief returns numeric data of crc_read
 * Module - 'dram', Submodule - 'general_info', data - 'crc_read'
 * read crc
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_crc_read_get(
    int unit);

/**
 * \brief returns numeric data of device_size
 * Module - 'dram', Submodule - 'general_info', data - 'device_size'
 * device size for each dram die
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_device_size_get(
    int unit);

/**
 * \brief returns numeric data of supported_dram_bitmap
 * Module - 'dram', Submodule - 'general_info', data - 'supported_dram_bitmap'
 * bitmap indicating which dram indexes are supported for the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_dram_bitmap - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_supported_dram_bitmap_get(
    int unit);

/**
 * \brief returns numeric data of dram_bitmap_internal
 * Module - 'dram', Submodule - 'general_info', data - 'dram_bitmap_internal'
 * bitmap of currently available drams
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_bitmap_internal - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dram_bitmap_internal_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_general_info_table_mr_defaults,
    dnx_data_dram_general_info_table_dram_info,
    dnx_data_dram_general_info_table_timing_params,
    dnx_data_dram_general_info_table_refresh_intervals,

    /**
     * Must be last one!
     */
    _dnx_data_dram_general_info_table_nof
} dnx_data_dram_general_info_table_e;

/* Get Data */
/**
 * \brief get table mr_defaults entry 
 * mode registers default values
 * 
 * \param [in] unit - unit #
 * \param [in] index - mode register index
 * 
 * \return
 *     mr_defaults - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_mr_defaults_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_mr_defaults_t * dnx_data_dram_general_info_mr_defaults_get(
    int unit,
    int index);

/**
 * \brief get table dram_info entry 
 * general information regarding the dram in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_info - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_dram_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_dram_info_t * dnx_data_dram_general_info_dram_info_get(
    int unit);

/**
 * \brief get table timing_params entry 
 * timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     timing_params - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_timing_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_timing_params_t * dnx_data_dram_general_info_timing_params_get(
    int unit);

/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * \param [in] temp_index - temperature index
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_refresh_intervals_t * dnx_data_dram_general_info_refresh_intervals_get(
    int unit,
    int temp_index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'mr_defaults'
 * mode registers default values
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_mr_defaults_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'dram_info'
 * general information regarding the dram in the system
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_dram_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'timing_params'
 * timing parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_timing_params_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'refresh_intervals'
 * refresh intervals timing parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_refresh_intervals_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)mr_defaults info
 * mode registers default values
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mr_defaults - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_mr_defaults_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dram_info info
 * general information regarding the dram in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_dram_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)timing_params info
 * timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     timing_params - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_timing_params_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)refresh_intervals info
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_refresh_intervals_info_get(
    int unit);

/*
 * SUBMODULE ADDRESS_TRANSLATION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_address_translation_feature_get(
    int unit,
    dnx_data_dram_address_translation_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_address_translation_define_matrix_column_size,
    dnx_data_dram_address_translation_define_physical_address_transaction_size,
    dnx_data_dram_address_translation_define_nof_atms,
    dnx_data_dram_address_translation_define_nof_tdus_per_dram,
    dnx_data_dram_address_translation_define_max_tdu_index,

    /**
     * Must be last one!
     */
    _dnx_data_dram_address_translation_define_nof
} dnx_data_dram_address_translation_define_e;

/* Get Data */
/**
 * \brief returns define data of matrix_column_size
 * Module - 'dram', Submodule - 'address_translation', data - 'matrix_column_size'
 * the number of rows in the ATM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     matrix_column_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_matrix_column_size_get(
    int unit);

/**
 * \brief returns define data of physical_address_transaction_size
 * Module - 'dram', Submodule - 'address_translation', data - 'physical_address_transaction_size'
 * nof bytes in each read/write from/to physical address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_transaction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_physical_address_transaction_size_get(
    int unit);

/**
 * \brief returns define data of nof_atms
 * Module - 'dram', Submodule - 'address_translation', data - 'nof_atms'
 * number of address translation matrix
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_atms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_nof_atms_get(
    int unit);

/**
 * \brief returns define data of nof_tdus_per_dram
 * Module - 'dram', Submodule - 'address_translation', data - 'nof_tdus_per_dram'
 * number of TDU blocks per DRAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tdus_per_dram - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_nof_tdus_per_dram_get(
    int unit);

/**
 * \brief returns define data of max_tdu_index
 * Module - 'dram', Submodule - 'address_translation', data - 'max_tdu_index'
 * Maximum TDU index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tdu_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_max_tdu_index_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_address_translation_table_tdu_map,
    dnx_data_dram_address_translation_table_matrix_configuration,
    dnx_data_dram_address_translation_table_interrupt_regs,
    dnx_data_dram_address_translation_table_counter_regs,

    /**
     * Must be last one!
     */
    _dnx_data_dram_address_translation_table_nof
} dnx_data_dram_address_translation_table_e;

/* Get Data */
/**
 * \brief get table tdu_map entry 
 * Map between TDU and its data source
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - DRAM index
 * \param [in] tdu_index - TDU index
 * 
 * \return
 *     tdu_map - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_tdu_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_tdu_map_t * dnx_data_dram_address_translation_tdu_map_get(
    int unit,
    int dram_index,
    int tdu_index);

/**
 * \brief get table matrix_configuration entry 
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - unit #
 * \param [in] matrix_option - matrix selector
 * 
 * \return
 *     matrix_configuration - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_matrix_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_matrix_configuration_t * dnx_data_dram_address_translation_matrix_configuration_get(
    int unit,
    int matrix_option);

/**
 * \brief get table interrupt_regs entry 
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_interrupt_regs_t * dnx_data_dram_address_translation_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table counter_regs entry 
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_counter_regs_t * dnx_data_dram_address_translation_counter_regs_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'tdu_map'
 * Map between TDU and its data source
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_tdu_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'matrix_configuration'
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_matrix_configuration_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'interrupt_regs'
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'counter_regs'
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_counter_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)tdu_map info
 * Map between TDU and its data source
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdu_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_tdu_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)matrix_configuration info
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     matrix_configuration - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_matrix_configuration_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)interrupt_regs info
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)counter_regs info
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counter_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_counter_regs_info_get(
    int unit);

/*
 * SUBMODULE BUFFERS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_buffers_feature_get(
    int unit,
    dnx_data_dram_buffers_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_buffers_define_allowed_errors,
    dnx_data_dram_buffers_define_nof_bdbs,
    dnx_data_dram_buffers_define_nof_fpc_banks,

    /**
     * Must be last one!
     */
    _dnx_data_dram_buffers_define_nof
} dnx_data_dram_buffers_define_e;

/* Get Data */
/**
 * \brief returns numeric data of allowed_errors
 * Module - 'dram', Submodule - 'buffers', data - 'allowed_errors'
 * number of times a buffer is allowed into the quarantine FIFO before it is deleted instead of restored
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     allowed_errors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_allowed_errors_get(
    int unit);

/**
 * \brief returns define data of nof_bdbs
 * Module - 'dram', Submodule - 'buffers', data - 'nof_bdbs'
 * number of BDBs per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_nof_bdbs_get(
    int unit);

/**
 * \brief returns define data of nof_fpc_banks
 * Module - 'dram', Submodule - 'buffers', data - 'nof_fpc_banks'
 * number of free pointer controler banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fpc_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_nof_fpc_banks_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_buffers_table_deleted_buffers_info,

    /**
     * Must be last one!
     */
    _dnx_data_dram_buffers_table_nof
} dnx_data_dram_buffers_table_e;

/* Get Data */
/**
 * \brief get table deleted_buffers_info entry 
 * deleted buffers info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     deleted_buffers_info - returns the relevant entry values grouped in struct - see dnx_data_dram_buffers_deleted_buffers_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_buffers_deleted_buffers_info_t * dnx_data_dram_buffers_deleted_buffers_info_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'buffers', table - 'deleted_buffers_info'
 * deleted buffers info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_buffers_deleted_buffers_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)deleted_buffers_info info
 * deleted buffers info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     deleted_buffers_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_buffers_deleted_buffers_info_info_get(
    int unit);

/*
 * SUBMODULE DRAM_BLOCK:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_dram_block_feature_get(
    int unit,
    dnx_data_dram_dram_block_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_dram_block_define_leaky_bucket_window_size,
    dnx_data_dram_dram_block_define_wmr_reset_on_deassert,
    dnx_data_dram_dram_block_define_wmr_full_size,
    dnx_data_dram_dram_block_define_average_read_inflights_assert_threshold,
    dnx_data_dram_dram_block_define_average_read_inflights_full_size,
    dnx_data_dram_dram_block_define_wmr_decrement_thr_factor,
    dnx_data_dram_dram_block_define_wpr_increment_thr_factor,

    /**
     * Must be last one!
     */
    _dnx_data_dram_dram_block_define_nof
} dnx_data_dram_dram_block_define_e;

/* Get Data */
/**
 * \brief returns define data of leaky_bucket_window_size
 * Module - 'dram', Submodule - 'dram_block', data - 'leaky_bucket_window_size'
 * window size for DRAM block calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     leaky_bucket_window_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_leaky_bucket_window_size_get(
    int unit);

/**
 * \brief returns define data of wmr_reset_on_deassert
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_reset_on_deassert'
 * indication whether to reset on deassert of write-minus-read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_reset_on_deassert - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_wmr_reset_on_deassert_get(
    int unit);

/**
 * \brief returns define data of wmr_full_size
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_full_size'
 * write-minus-read leaky bucket full size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_full_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_wmr_full_size_get(
    int unit);

/**
 * \brief returns define data of average_read_inflights_assert_threshold
 * Module - 'dram', Submodule - 'dram_block', data - 'average_read_inflights_assert_threshold'
 * average-read-inflights leaky bucket assert threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_read_inflights_assert_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_average_read_inflights_assert_threshold_get(
    int unit);

/**
 * \brief returns define data of average_read_inflights_full_size
 * Module - 'dram', Submodule - 'dram_block', data - 'average_read_inflights_full_size'
 * average-read-inflights leaky bucket full size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_read_inflights_full_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_average_read_inflights_full_size_get(
    int unit);

/**
 * \brief returns numeric data of wmr_decrement_thr_factor
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_decrement_thr_factor'
 * factor for calculating decrement threshold for write_minus_read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_decrement_thr_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_wmr_decrement_thr_factor_get(
    int unit);

/**
 * \brief returns numeric data of wpr_increment_thr_factor
 * Module - 'dram', Submodule - 'dram_block', data - 'wpr_increment_thr_factor'
 * factor for calculating increment threshold for write-plus-read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wpr_increment_thr_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dram_block_wpr_increment_thr_factor_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_dram_block_table_wpr_leaky_bucket_increment_th,
    dnx_data_dram_dram_block_table_write_leaky_bucket_increment_th,
    dnx_data_dram_dram_block_table_gddr6_average_read_inflights_leaky_bucket_config_params,

    /**
     * Must be last one!
     */
    _dnx_data_dram_dram_block_table_nof
} dnx_data_dram_dram_block_table_e;

/* Get Data */
/**
 * \brief get table wpr_leaky_bucket_increment_th entry 
 * Write-plus-read leaky bucket increment thresholds
 * 
 * \param [in] unit - unit #
 * \param [in] index - threshold index
 * 
 * \return
 *     wpr_leaky_bucket_increment_th - returns the relevant entry values grouped in struct - see dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_t * dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_get(
    int unit,
    int index);

/**
 * \brief get table write_leaky_bucket_increment_th entry 
 * Write leaky bucket increment thresholds
 * 
 * \param [in] unit - unit #
 * \param [in] index - threshold index
 * 
 * \return
 *     write_leaky_bucket_increment_th - returns the relevant entry values grouped in struct - see dnx_data_dram_dram_block_write_leaky_bucket_increment_th_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_dram_block_write_leaky_bucket_increment_th_t * dnx_data_dram_dram_block_write_leaky_bucket_increment_th_get(
    int unit,
    int index);

/**
 * \brief get table gddr6_average_read_inflights_leaky_bucket_config_params entry 
 * Configuration params for the inflight average read inflights DRAM block setting
 * 
 * \param [in] unit - unit #
 * \param [in] index - param index
 * 
 * \return
 *     gddr6_average_read_inflights_leaky_bucket_config_params - returns the relevant entry values grouped in struct - see dnx_data_dram_dram_block_gddr6_average_read_inflights_leaky_bucket_config_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_dram_block_gddr6_average_read_inflights_leaky_bucket_config_params_t * dnx_data_dram_dram_block_gddr6_average_read_inflights_leaky_bucket_config_params_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'dram_block', table - 'wpr_leaky_bucket_increment_th'
 * Write-plus-read leaky bucket increment thresholds
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'dram_block', table - 'write_leaky_bucket_increment_th'
 * Write leaky bucket increment thresholds
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_dram_block_write_leaky_bucket_increment_th_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'dram_block', table - 'gddr6_average_read_inflights_leaky_bucket_config_params'
 * Configuration params for the inflight average read inflights DRAM block setting
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_dram_block_gddr6_average_read_inflights_leaky_bucket_config_params_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)wpr_leaky_bucket_increment_th info
 * Write-plus-read leaky bucket increment thresholds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wpr_leaky_bucket_increment_th - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)write_leaky_bucket_increment_th info
 * Write leaky bucket increment thresholds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_leaky_bucket_increment_th - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_dram_block_write_leaky_bucket_increment_th_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)gddr6_average_read_inflights_leaky_bucket_config_params info
 * Configuration params for the inflight average read inflights DRAM block setting
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     gddr6_average_read_inflights_leaky_bucket_config_params - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_dram_block_gddr6_average_read_inflights_leaky_bucket_config_params_info_get(
    int unit);

/*
 * SUBMODULE DBAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_dbal_feature_get(
    int unit,
    dnx_data_dram_dbal_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_dbal_define_hbm_trc_nof_bits,
    dnx_data_dram_dbal_define_wpr_increment_threshold_nof_bits,
    dnx_data_dram_dbal_define_average_read_inflights_increment_threshold_nof_bits,
    dnx_data_dram_dbal_define_average_read_inflights_decrement_threshold_nof_bits,
    dnx_data_dram_dbal_define_hbm_pll_pdiv_nof_bits,
    dnx_data_dram_dbal_define_hbm_pll_ch_mdiv_nof_bits,
    dnx_data_dram_dbal_define_hbm_pll_frefeff_info_nof_bits,
    dnx_data_dram_dbal_define_hbm_pll_aux_post_enableb_nof_bits,
    dnx_data_dram_dbal_define_hbm_pll_ch_enableb_nof_bits,
    dnx_data_dram_dbal_define_hbm_pll_aux_post_diffcmos_en_nof_bits,
    dnx_data_dram_dbal_define_dram_bist_mode_nof_bits,
    dnx_data_dram_dbal_define_hbm_write_latency_nof_bits,
    dnx_data_dram_dbal_define_hbm_output_enable_delay_nof_bits,
    dnx_data_dram_dbal_define_hbm_rd_data_en_delay_nof_bits,
    dnx_data_dram_dbal_define_hbm_c_u_nof_bits,
    dnx_data_dram_dbal_define_hbm_r_u_nof_bits,
    dnx_data_dram_dbal_define_hbmc_index_nof_bits,
    dnx_data_dram_dbal_define_hbmc_tdu_index_nof_bits,

    /**
     * Must be last one!
     */
    _dnx_data_dram_dbal_define_nof
} dnx_data_dram_dbal_define_e;

/* Get Data */
/**
 * \brief returns define data of hbm_trc_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_trc_nof_bits'
 * Number of bits in HBM_TRC field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_trc_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_trc_nof_bits_get(
    int unit);

/**
 * \brief returns define data of wpr_increment_threshold_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'wpr_increment_threshold_nof_bits'
 * Number of bits in DRAM_BLOCKED_WRITE_PLUS_READ_LEAKY_BUCKET_INCREMENT_SIZE fields
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wpr_increment_threshold_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_wpr_increment_threshold_nof_bits_get(
    int unit);

/**
 * \brief returns define data of average_read_inflights_increment_threshold_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'average_read_inflights_increment_threshold_nof_bits'
 * Number of bits in DRAM_BLOCKED_AVERAGE_READ_INFLIGHTS_LEAKY_BUCKET_INCREMENT_SIZE fields
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_read_inflights_increment_threshold_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_average_read_inflights_increment_threshold_nof_bits_get(
    int unit);

/**
 * \brief returns define data of average_read_inflights_decrement_threshold_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'average_read_inflights_decrement_threshold_nof_bits'
 * Number of bits in DRAM_BLOCKED_AVERAGE_READ_INFLIGHTS_LEAKY_BUCKET_DECREMENT_SIZE fields
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_read_inflights_decrement_threshold_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_average_read_inflights_decrement_threshold_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_pll_pdiv_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_pdiv_nof_bits'
 * Number of bits in HBM_PLL_PDIV field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_pdiv_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_pll_pdiv_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_pll_ch_mdiv_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_ch_mdiv_nof_bits'
 * Number of bits in HBM_PLL_CH_0_MDIV field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_ch_mdiv_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_pll_ch_mdiv_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_pll_frefeff_info_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_frefeff_info_nof_bits'
 * Number of bits in HBM_PLL_FREFEFF_INFO field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_frefeff_info_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_pll_frefeff_info_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_pll_aux_post_enableb_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_aux_post_enableb_nof_bits'
 * Number of bits in HBM_PLL_AUX_POST_ENABLEB field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_aux_post_enableb_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_pll_aux_post_enableb_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_pll_ch_enableb_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_ch_enableb_nof_bits'
 * Number of bits in HBM_PLL_CH_ENABLEB field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_ch_enableb_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_pll_ch_enableb_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_pll_aux_post_diffcmos_en_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_aux_post_diffcmos_en_nof_bits'
 * Number of bits in HBM_PLL_AUX_POST_DIFFCMOS_EN field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_aux_post_diffcmos_en_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_pll_aux_post_diffcmos_en_nof_bits_get(
    int unit);

/**
 * \brief returns define data of dram_bist_mode_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'dram_bist_mode_nof_bits'
 * Number of bits in dram bist DATA_MODE field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_bist_mode_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_dram_bist_mode_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_write_latency_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_write_latency_nof_bits'
 * Number of bits in HBM_WRITE_LATENCY field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_write_latency_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_write_latency_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_output_enable_delay_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_output_enable_delay_nof_bits'
 * Number of bits in OUTPUT_ENABLE_DELAY field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_output_enable_delay_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_output_enable_delay_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_rd_data_en_delay_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_rd_data_en_delay_nof_bits'
 * Number of bits in RD_DATA_EN_DELAY field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_rd_data_en_delay_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_rd_data_en_delay_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_c_u_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_c_u_nof_bits'
 * Number of bits in C_UI_0/1 field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_c_u_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_c_u_nof_bits_get(
    int unit);

/**
 * \brief returns define data of hbm_r_u_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_r_u_nof_bits'
 * Number of bits in R_UI_0/1 field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_r_u_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbm_r_u_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of hbmc_index_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbmc_index_nof_bits'
 * The size (number of bits) of HBMC_INDEX dbal field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbmc_index_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbmc_index_nof_bits_get(
    int unit);

/**
 * \brief returns numeric data of hbmc_tdu_index_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbmc_tdu_index_nof_bits'
 * The size (number of bits) of HBMC_TDU_INDEX dbal field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbmc_tdu_index_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_dbal_hbmc_tdu_index_nof_bits_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_dbal_table_nof
} dnx_data_dram_dbal_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FIRMWARE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_firmware_feature_get(
    int unit,
    dnx_data_dram_firmware_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_firmware_define_nof_hbm_spare_data_results,
    dnx_data_dram_firmware_define_sbus_clock_divider,
    dnx_data_dram_firmware_define_snap_state_init_done,

    /**
     * Must be last one!
     */
    _dnx_data_dram_firmware_define_nof
} dnx_data_dram_firmware_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_hbm_spare_data_results
 * Module - 'dram', Submodule - 'firmware', data - 'nof_hbm_spare_data_results'
 * Number of HBM spare data results
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hbm_spare_data_results - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_firmware_nof_hbm_spare_data_results_get(
    int unit);

/**
 * \brief returns define data of sbus_clock_divider
 * Module - 'dram', Submodule - 'firmware', data - 'sbus_clock_divider'
 * Divide sbus_ctrl_clk with this value to create the SBus clock. Max clock after division should be 200MHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_clock_divider - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_firmware_sbus_clock_divider_get(
    int unit);

/**
 * \brief returns define data of snap_state_init_done
 * Module - 'dram', Submodule - 'firmware', data - 'snap_state_init_done'
 * The value which indicates that the SNaP initialization is done
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     snap_state_init_done - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_firmware_snap_state_init_done_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_firmware_table_rom,
    dnx_data_dram_firmware_table_operation_status,
    dnx_data_dram_firmware_table_operation_result_error_code,
    dnx_data_dram_firmware_table_operation_result_last_operation,

    /**
     * Must be last one!
     */
    _dnx_data_dram_firmware_table_nof
} dnx_data_dram_firmware_table_e;

/* Get Data */
/**
 * \brief get table rom entry 
 * Firmaware ROM info
 * 
 * \param [in] unit - unit #
 * \param [in] hbm_generation - HBM generation (for example: HBM, HBM2E)
 * 
 * \return
 *     rom - returns the relevant entry values grouped in struct - see dnx_data_dram_firmware_rom_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_firmware_rom_t * dnx_data_dram_firmware_rom_get(
    int unit,
    int hbm_generation);

/**
 * \brief get table operation_status entry 
 * Indications on the firmware operation status. The values are taken from the HBM PHY Firmware programming guide.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     operation_status - returns the relevant entry values grouped in struct - see dnx_data_dram_firmware_operation_status_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_firmware_operation_status_t * dnx_data_dram_firmware_operation_status_get(
    int unit);

/**
 * \brief get table operation_result_error_code entry 
 * Error codes that can be encountered when using the Get Operation Result interrupt code
 * 
 * \param [in] unit - unit #
 * \param [in] error_code - the resulted error code
 * 
 * \return
 *     operation_result_error_code - returns the relevant entry values grouped in struct - see dnx_data_dram_firmware_operation_result_error_code_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_firmware_operation_result_error_code_t * dnx_data_dram_firmware_operation_result_error_code_get(
    int unit,
    int error_code);

/**
 * \brief get table operation_result_last_operation entry 
 * When operation resulted with an error, the operation is saved. This table shows the meaning of the failing operation code.
 * 
 * \param [in] unit - unit #
 * \param [in] operation_code - the operation code
 * 
 * \return
 *     operation_result_last_operation - returns the relevant entry values grouped in struct - see dnx_data_dram_firmware_operation_result_last_operation_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_firmware_operation_result_last_operation_t * dnx_data_dram_firmware_operation_result_last_operation_get(
    int unit,
    int operation_code);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'firmware', table - 'rom'
 * Firmaware ROM info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_firmware_rom_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'firmware', table - 'operation_status'
 * Indications on the firmware operation status. The values are taken from the HBM PHY Firmware programming guide.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_firmware_operation_status_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'firmware', table - 'operation_result_error_code'
 * Error codes that can be encountered when using the Get Operation Result interrupt code
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_firmware_operation_result_error_code_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'firmware', table - 'operation_result_last_operation'
 * When operation resulted with an error, the operation is saved. This table shows the meaning of the failing operation code.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_firmware_operation_result_last_operation_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)rom info
 * Firmaware ROM info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rom - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_firmware_rom_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)operation_status info
 * Indications on the firmware operation status. The values are taken from the HBM PHY Firmware programming guide.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     operation_status - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_firmware_operation_status_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)operation_result_error_code info
 * Error codes that can be encountered when using the Get Operation Result interrupt code
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     operation_result_error_code - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_firmware_operation_result_error_code_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)operation_result_last_operation info
 * When operation resulted with an error, the operation is saved. This table shows the meaning of the failing operation code.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     operation_result_last_operation - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_firmware_operation_result_last_operation_info_get(
    int unit);

/*
 * SUBMODULE APD_PHY:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_apd_phy_feature_get(
    int unit,
    dnx_data_dram_apd_phy_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_apd_phy_define_nof
} dnx_data_dram_apd_phy_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_apd_phy_table_pll,

    /**
     * Must be last one!
     */
    _dnx_data_dram_apd_phy_table_nof
} dnx_data_dram_apd_phy_table_e;

/* Get Data */
/**
 * \brief get table pll entry 
 * PLL parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pll - returns the relevant entry values grouped in struct - see dnx_data_dram_apd_phy_pll_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_apd_phy_pll_t * dnx_data_dram_apd_phy_pll_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'apd_phy', table - 'pll'
 * PLL parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_apd_phy_pll_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)pll info
 * PLL parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pll - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_apd_phy_pll_info_get(
    int unit);

/*
 * SUBMODULE CTESTS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_ctests_feature_get(
    int unit,
    dnx_data_dram_ctests_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_ctests_define_nof
} dnx_data_dram_ctests_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_ctests_table_rate,

    /**
     * Must be last one!
     */
    _dnx_data_dram_ctests_table_nof
} dnx_data_dram_ctests_table_e;

/* Get Data */
/**
 * \brief get table rate entry 
 * parameters for rate ctest
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate - returns the relevant entry values grouped in struct - see dnx_data_dram_ctests_rate_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_ctests_rate_t * dnx_data_dram_ctests_rate_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'ctests', table - 'rate'
 * parameters for rate ctest
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_ctests_rate_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)rate info
 * parameters for rate ctest
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_ctests_rate_info_get(
    int unit);

/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_DRAM_H_*/
/* *INDENT-ON* */
