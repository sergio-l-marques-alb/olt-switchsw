/** \file dnx_data_internal_nif.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_NIF_H_
/*{*/
#define _DNX_DATA_INTERNAL_NIF_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_nif.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_nif_submodule_global,
    dnx_data_nif_submodule_phys,
    dnx_data_nif_submodule_ilkn,
    dnx_data_nif_submodule_eth,
    dnx_data_nif_submodule_simulator,
    dnx_data_nif_submodule_flexe,
    dnx_data_nif_submodule_prd,
    dnx_data_nif_submodule_portmod,
    dnx_data_nif_submodule_scheduler,
    dnx_data_nif_submodule_dbal,
    dnx_data_nif_submodule_features,
    dnx_data_nif_submodule_arb,
    dnx_data_nif_submodule_ofr,
    dnx_data_nif_submodule_oft,

    /**
     * Must be last one!
     */
    _dnx_data_nif_submodule_nof
} dnx_data_nif_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GLOBAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_global_feature_get(
    int unit,
    dnx_data_nif_global_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_global_define_nof_lcplls,
    dnx_data_nif_global_define_max_core_access_per_port,
    dnx_data_nif_global_define_nof_nif_interfaces_per_core,
    dnx_data_nif_global_define_nif_interface_id_to_unit_id_granularity,
    dnx_data_nif_global_define_nof_nif_units_per_core,
    dnx_data_nif_global_define_reassembler_fifo_threshold,
    dnx_data_nif_global_define_last_port_led_scan,
    dnx_data_nif_global_define_start_tx_threshold_global,
    dnx_data_nif_global_define_l1_only_mode,

    /**
     * Must be last one!
     */
    _dnx_data_nif_global_define_nof
} dnx_data_nif_global_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_lcplls
 * Module - 'nif', Submodule - 'global', data - 'nof_lcplls'
 * number of lcplls supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lcplls - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_nof_lcplls_get(
    int unit);

/**
 * \brief returns define data of max_core_access_per_port
 * Module - 'nif', Submodule - 'global', data - 'max_core_access_per_port'
 * The max of core access per port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_core_access_per_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_max_core_access_per_port_get(
    int unit);

/**
 * \brief returns define data of nof_nif_interfaces_per_core
 * Module - 'nif', Submodule - 'global', data - 'nof_nif_interfaces_per_core'
 * Number of Nif ports/interfaces per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_nif_interfaces_per_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_nof_nif_interfaces_per_core_get(
    int unit);

/**
 * \brief returns define data of nif_interface_id_to_unit_id_granularity
 * Module - 'nif', Submodule - 'global', data - 'nif_interface_id_to_unit_id_granularity'
 * Granularity of the nif_interface_id_to_unit_id table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_interface_id_to_unit_id_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_nif_interface_id_to_unit_id_granularity_get(
    int unit);

/**
 * \brief returns define data of nof_nif_units_per_core
 * Module - 'nif', Submodule - 'global', data - 'nof_nif_units_per_core'
 * Number of NIF units per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_nif_units_per_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_nof_nif_units_per_core_get(
    int unit);

/**
 * \brief returns define data of reassembler_fifo_threshold
 * Module - 'nif', Submodule - 'global', data - 'reassembler_fifo_threshold'
 * Default value of reassembler FIFO threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reassembler_fifo_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_reassembler_fifo_threshold_get(
    int unit);

/**
 * \brief returns define data of last_port_led_scan
 * Module - 'nif', Submodule - 'global', data - 'last_port_led_scan'
 * the last port of led scan chain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     last_port_led_scan - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_last_port_led_scan_get(
    int unit);

/**
 * \brief returns numeric data of start_tx_threshold_global
 * Module - 'nif', Submodule - 'global', data - 'start_tx_threshold_global'
 * Global start TX threshold. This value overrides TX threshold table values
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     start_tx_threshold_global - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_start_tx_threshold_global_get(
    int unit);

/**
 * \brief returns numeric data of l1_only_mode
 * Module - 'nif', Submodule - 'global', data - 'l1_only_mode'
 * Enable/disable power optimization for L1 only, and set its mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l1_only_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_global_l1_only_mode_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_nif_global_table_pll_phys,
    dnx_data_nif_global_table_nif_interface_id_to_unit_id,

    /**
     * Must be last one!
     */
    _dnx_data_nif_global_table_nof
} dnx_data_nif_global_table_e;

/* Get Data */
/**
 * \brief get table pll_phys entry 
 * phys controlled by each lcpll
 * 
 * \param [in] unit - unit #
 * \param [in] lcpll - LCPLL index
 * 
 * \return
 *     pll_phys - returns the relevant entry values grouped in struct - see dnx_data_nif_global_pll_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_global_pll_phys_t * dnx_data_nif_global_pll_phys_get(
    int unit,
    int lcpll);

/**
 * \brief get table nif_interface_id_to_unit_id entry 
 * map the nif port to nif unit id, in granularity of nif_interface_id_to_unit_id_granularity (2).
 * 
 * \param [in] unit - unit #
 * \param [in] nif_interface_id - Port number.
 * 
 * \return
 *     nif_interface_id_to_unit_id - returns the relevant entry values grouped in struct - see dnx_data_nif_global_nif_interface_id_to_unit_id_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_global_nif_interface_id_to_unit_id_t * dnx_data_nif_global_nif_interface_id_to_unit_id_get(
    int unit,
    int nif_interface_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'global', table - 'pll_phys'
 * phys controlled by each lcpll
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_global_pll_phys_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'global', table - 'nif_interface_id_to_unit_id'
 * map the nif port to nif unit id, in granularity of nif_interface_id_to_unit_id_granularity (2).
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_global_nif_interface_id_to_unit_id_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)pll_phys info
 * phys controlled by each lcpll
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pll_phys - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_global_pll_phys_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)nif_interface_id_to_unit_id info
 * map the nif port to nif unit id, in granularity of nif_interface_id_to_unit_id_granularity (2).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_interface_id_to_unit_id - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_global_nif_interface_id_to_unit_id_info_get(
    int unit);

/*
 * SUBMODULE PHYS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_phys_feature_get(
    int unit,
    dnx_data_nif_phys_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_phys_define_nof_phys,
    dnx_data_nif_phys_define_max_phys_in_core,
    dnx_data_nif_phys_define_pm8x50_gen,
    dnx_data_nif_phys_define_is_pam4_speed_supported,
    dnx_data_nif_phys_define_first_mgmt_phy,
    dnx_data_nif_phys_define_nof_mgmt_phys,

    /**
     * Must be last one!
     */
    _dnx_data_nif_phys_define_nof
} dnx_data_nif_phys_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_phys
 * Module - 'nif', Submodule - 'phys', data - 'nof_phys'
 * number of phys supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_phys_nof_phys_get(
    int unit);

/**
 * \brief returns define data of max_phys_in_core
 * Module - 'nif', Submodule - 'phys', data - 'max_phys_in_core'
 * max number of phys in core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_phys_in_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_phys_max_phys_in_core_get(
    int unit);

/**
 * \brief returns define data of pm8x50_gen
 * Module - 'nif', Submodule - 'phys', data - 'pm8x50_gen'
 * The generation of Blackhalk PM that the device uses. IIf older generation some abilities are not supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pm8x50_gen - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_phys_pm8x50_gen_get(
    int unit);

/**
 * \brief returns define data of is_pam4_speed_supported
 * Module - 'nif', Submodule - 'phys', data - 'is_pam4_speed_supported'
 * If PAM4 speed supported in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     is_pam4_speed_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_phys_is_pam4_speed_supported_get(
    int unit);

/**
 * \brief returns define data of first_mgmt_phy
 * Module - 'nif', Submodule - 'phys', data - 'first_mgmt_phy'
 * First PHY for management ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_mgmt_phy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_phys_first_mgmt_phy_get(
    int unit);

/**
 * \brief returns define data of nof_mgmt_phys
 * Module - 'nif', Submodule - 'phys', data - 'nof_mgmt_phys'
 * Number of PHYs for management ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mgmt_phys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_phys_nof_mgmt_phys_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_nif_phys_table_general,
    dnx_data_nif_phys_table_polarity,
    dnx_data_nif_phys_table_core_phys_map,
    dnx_data_nif_phys_table_vco_div,
    dnx_data_nif_phys_table_nof_phys_per_core,

    /**
     * Must be last one!
     */
    _dnx_data_nif_phys_table_nof
} dnx_data_nif_phys_table_e;

/* Get Data */
/**
 * \brief get table general entry 
 * general data about phys
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     general - returns the relevant entry values grouped in struct - see dnx_data_nif_phys_general_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_phys_general_t * dnx_data_nif_phys_general_get(
    int unit);

/**
 * \brief get table polarity entry 
 * rx and tx polarity per lane
 * 
 * \param [in] unit - unit #
 * \param [in] lane_index - lane index (0-based)
 * 
 * \return
 *     polarity - returns the relevant entry values grouped in struct - see dnx_data_nif_phys_polarity_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_phys_polarity_t * dnx_data_nif_phys_polarity_get(
    int unit,
    int lane_index);

/**
 * \brief get table core_phys_map entry 
 * map pipeline core to connected PHYs
 * 
 * \param [in] unit - unit #
 * \param [in] core_index - Core number.
 * 
 * \return
 *     core_phys_map - returns the relevant entry values grouped in struct - see dnx_data_nif_phys_core_phys_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_phys_core_phys_map_t * dnx_data_nif_phys_core_phys_map_get(
    int unit,
    int core_index);

/**
 * \brief get table vco_div entry 
 * VCO divider per ethu_id
 * 
 * \param [in] unit - unit #
 * \param [in] ethu_index - ethu instance number.
 * 
 * \return
 *     vco_div - returns the relevant entry values grouped in struct - see dnx_data_nif_phys_vco_div_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_phys_vco_div_t * dnx_data_nif_phys_vco_div_get(
    int unit,
    int ethu_index);

/**
 * \brief get table nof_phys_per_core entry 
 * number of phys per core
 * 
 * \param [in] unit - unit #
 * \param [in] core_index - core instance number.
 * 
 * \return
 *     nof_phys_per_core - returns the relevant entry values grouped in struct - see dnx_data_nif_phys_nof_phys_per_core_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_phys_nof_phys_per_core_t * dnx_data_nif_phys_nof_phys_per_core_get(
    int unit,
    int core_index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'phys', table - 'general'
 * general data about phys
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_phys_general_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'phys', table - 'polarity'
 * rx and tx polarity per lane
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_phys_polarity_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'phys', table - 'core_phys_map'
 * map pipeline core to connected PHYs
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_phys_core_phys_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'phys', table - 'vco_div'
 * VCO divider per ethu_id
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_phys_vco_div_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'phys', table - 'nof_phys_per_core'
 * number of phys per core
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_phys_nof_phys_per_core_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)general info
 * general data about phys
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     general - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_phys_general_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)polarity info
 * rx and tx polarity per lane
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     polarity - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_phys_polarity_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)core_phys_map info
 * map pipeline core to connected PHYs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     core_phys_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_phys_core_phys_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)vco_div info
 * VCO divider per ethu_id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vco_div - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_phys_vco_div_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)nof_phys_per_core info
 * number of phys per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phys_per_core - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_phys_nof_phys_per_core_info_get(
    int unit);

/*
 * SUBMODULE ILKN:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_ilkn_feature_get(
    int unit,
    dnx_data_nif_ilkn_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_ilkn_define_ilu_nof,
    dnx_data_nif_ilkn_define_ilkn_unit_nof,
    dnx_data_nif_ilkn_define_ilkn_unit_if_nof,
    dnx_data_nif_ilkn_define_ilkn_if_nof,
    dnx_data_nif_ilkn_define_fec_units_per_core_nof,
    dnx_data_nif_ilkn_define_nof_lanes_per_fec_unit,
    dnx_data_nif_ilkn_define_lanes_max_nof,
    dnx_data_nif_ilkn_define_lanes_max_nof_using_fec,
    dnx_data_nif_ilkn_define_lanes_allowed_nof,
    dnx_data_nif_ilkn_define_ilkn_over_eth_pms_max,
    dnx_data_nif_ilkn_define_segments_max_nof,
    dnx_data_nif_ilkn_define_segments_half_nof,
    dnx_data_nif_ilkn_define_pms_nof,
    dnx_data_nif_ilkn_define_fmac_bus_size,
    dnx_data_nif_ilkn_define_ilkn_rx_hrf_nof,
    dnx_data_nif_ilkn_define_ilkn_tx_hrf_nof,
    dnx_data_nif_ilkn_define_data_rx_hrf_size,
    dnx_data_nif_ilkn_define_tdm_rx_hrf_size,
    dnx_data_nif_ilkn_define_tx_hrf_credits,
    dnx_data_nif_ilkn_define_nof_rx_hrf_per_port,
    dnx_data_nif_ilkn_define_watermark_high_elk,
    dnx_data_nif_ilkn_define_watermark_low_elk,
    dnx_data_nif_ilkn_define_watermark_high_data,
    dnx_data_nif_ilkn_define_watermark_low_data,
    dnx_data_nif_ilkn_define_pad_size,
    dnx_data_nif_ilkn_define_burst_max_range_max,
    dnx_data_nif_ilkn_define_burst_min,
    dnx_data_nif_ilkn_define_burst_short,
    dnx_data_nif_ilkn_define_burst_min_range_max,
    dnx_data_nif_ilkn_define_max_nof_ifs,
    dnx_data_nif_ilkn_define_max_nof_elk_ifs,
    dnx_data_nif_ilkn_define_port_0_status_intr_id,
    dnx_data_nif_ilkn_define_port_1_status_intr_id,
    dnx_data_nif_ilkn_define_link_stable_wait,
    dnx_data_nif_ilkn_define_interleaved_error_drop_single_context,

    /**
     * Must be last one!
     */
    _dnx_data_nif_ilkn_define_nof
} dnx_data_nif_ilkn_define_e;

/* Get Data */
/**
 * \brief returns define data of ilu_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilu_nof'
 * Number of ILU instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilu_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_ilu_nof_get(
    int unit);

/**
 * \brief returns define data of ilkn_unit_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_unit_nof'
 * Number of ILKN units in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_unit_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_ilkn_unit_nof_get(
    int unit);

/**
 * \brief returns define data of ilkn_unit_if_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_unit_if_nof'
 * Number of ILKN Interfaces in each ILKN unit
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_unit_if_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_ilkn_unit_if_nof_get(
    int unit);

/**
 * \brief returns define data of ilkn_if_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_if_nof'
 * Number of ILKN Interfaces in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_if_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_ilkn_if_nof_get(
    int unit);

/**
 * \brief returns define data of fec_units_per_core_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'fec_units_per_core_nof'
 * Number of ILKN FEC units per core in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_units_per_core_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_fec_units_per_core_nof_get(
    int unit);

/**
 * \brief returns define data of nof_lanes_per_fec_unit
 * Module - 'nif', Submodule - 'ilkn', data - 'nof_lanes_per_fec_unit'
 * Number of ilkn lanes per ILKN FEC unit in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lanes_per_fec_unit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_nof_lanes_per_fec_unit_get(
    int unit);

/**
 * \brief returns define data of lanes_max_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'lanes_max_nof'
 * Max number of lanes for ILKN port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lanes_max_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_lanes_max_nof_get(
    int unit);

/**
 * \brief returns define data of lanes_max_nof_using_fec
 * Module - 'nif', Submodule - 'ilkn', data - 'lanes_max_nof_using_fec'
 * Max number of lanes for ILKN port interface when FEC is enabled
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lanes_max_nof_using_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_lanes_max_nof_using_fec_get(
    int unit);

/**
 * \brief returns define data of lanes_allowed_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'lanes_allowed_nof'
 * The allowed lanes for each ILKN port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lanes_allowed_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_lanes_allowed_nof_get(
    int unit);

/**
 * \brief returns define data of ilkn_over_eth_pms_max
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_over_eth_pms_max'
 * Max number eth pms ilkn lanes is part of
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_over_eth_pms_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_ilkn_over_eth_pms_max_get(
    int unit);

/**
 * \brief returns define data of segments_max_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'segments_max_nof'
 * Max number of segments in ILKN protocol. (Segment is a resource of ILKN which is shared between all ports of the ILKN unit)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     segments_max_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_segments_max_nof_get(
    int unit);

/**
 * \brief returns define data of segments_half_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'segments_half_nof'
 * Min number of segments in ILKN protocol. (Segment is a resource of ILKN which is shared between all ports of the ILKN unit)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     segments_half_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_segments_half_nof_get(
    int unit);

/**
 * \brief returns define data of pms_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'pms_nof'
 * Maximal number of PMs connectted to the ILKN unit
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pms_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_pms_nof_get(
    int unit);

/**
 * \brief returns define data of fmac_bus_size
 * Module - 'nif', Submodule - 'ilkn', data - 'fmac_bus_size'
 * Fabric MAC bus size [bits], relevant for ILKN over fabric ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_bus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_fmac_bus_size_get(
    int unit);

/**
 * \brief returns define data of ilkn_rx_hrf_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_rx_hrf_nof'
 * Number of High Rate Fifo queues in RX
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_rx_hrf_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_ilkn_rx_hrf_nof_get(
    int unit);

/**
 * \brief returns define data of ilkn_tx_hrf_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_tx_hrf_nof'
 * Number of High Rate Fifo queues in TX
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_tx_hrf_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_ilkn_tx_hrf_nof_get(
    int unit);

/**
 * \brief returns define data of data_rx_hrf_size
 * Module - 'nif', Submodule - 'ilkn', data - 'data_rx_hrf_size'
 * Number of entries in High Rate Fifo for data
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_rx_hrf_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_data_rx_hrf_size_get(
    int unit);

/**
 * \brief returns define data of tdm_rx_hrf_size
 * Module - 'nif', Submodule - 'ilkn', data - 'tdm_rx_hrf_size'
 * Number of entries in High Rate Fifo for tdm
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_rx_hrf_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_tdm_rx_hrf_size_get(
    int unit);

/**
 * \brief returns define data of tx_hrf_credits
 * Module - 'nif', Submodule - 'ilkn', data - 'tx_hrf_credits'
 * Number of credits needed per High Rate Fifo for tx
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_hrf_credits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_tx_hrf_credits_get(
    int unit);

/**
 * \brief returns define data of nof_rx_hrf_per_port
 * Module - 'nif', Submodule - 'ilkn', data - 'nof_rx_hrf_per_port'
 * Number of High Rate Fifo queues in RX per port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rx_hrf_per_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_nof_rx_hrf_per_port_get(
    int unit);

/**
 * \brief returns define data of watermark_high_elk
 * Module - 'nif', Submodule - 'ilkn', data - 'watermark_high_elk'
 * High Watermark value for ILKN ELK
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     watermark_high_elk - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_watermark_high_elk_get(
    int unit);

/**
 * \brief returns define data of watermark_low_elk
 * Module - 'nif', Submodule - 'ilkn', data - 'watermark_low_elk'
 * Low Watermark value for ILKN ELK
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     watermark_low_elk - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_watermark_low_elk_get(
    int unit);

/**
 * \brief returns define data of watermark_high_data
 * Module - 'nif', Submodule - 'ilkn', data - 'watermark_high_data'
 * High Watermark value for ILKN Data
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     watermark_high_data - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_watermark_high_data_get(
    int unit);

/**
 * \brief returns define data of watermark_low_data
 * Module - 'nif', Submodule - 'ilkn', data - 'watermark_low_data'
 * Low Watermark value for ILKN Data
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     watermark_low_data - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_watermark_low_data_get(
    int unit);

/**
 * \brief returns define data of pad_size
 * Module - 'nif', Submodule - 'ilkn', data - 'pad_size'
 * Packet size for ILKN. Packet will be to this size if packet is smaller than this size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pad_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_pad_size_get(
    int unit);

/**
 * \brief returns define data of burst_max_range_max
 * Module - 'nif', Submodule - 'ilkn', data - 'burst_max_range_max'
 * ILKN burst max range max value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_max_range_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_burst_max_range_max_get(
    int unit);

/**
 * \brief returns define data of burst_min
 * Module - 'nif', Submodule - 'ilkn', data - 'burst_min'
 * ILKN burst min default value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_burst_min_get(
    int unit);

/**
 * \brief returns define data of burst_short
 * Module - 'nif', Submodule - 'ilkn', data - 'burst_short'
 * ILKN burst short default value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_short - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_burst_short_get(
    int unit);

/**
 * \brief returns define data of burst_min_range_max
 * Module - 'nif', Submodule - 'ilkn', data - 'burst_min_range_max'
 * ILKN burst min range max value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_min_range_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_burst_min_range_max_get(
    int unit);

/**
 * \brief returns numeric data of max_nof_ifs
 * Module - 'nif', Submodule - 'ilkn', data - 'max_nof_ifs'
 * Max of supported ILKN interfaces, if set to  -1, there is no limitation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_ifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_max_nof_ifs_get(
    int unit);

/**
 * \brief returns numeric data of max_nof_elk_ifs
 * Module - 'nif', Submodule - 'ilkn', data - 'max_nof_elk_ifs'
 * Max of supported ILKN interfaces for ELK(KBP), if set to  -1, there is no limitation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_elk_ifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_max_nof_elk_ifs_get(
    int unit);

/**
 * \brief returns numeric data of port_0_status_intr_id
 * Module - 'nif', Submodule - 'ilkn', data - 'port_0_status_intr_id'
 * ILKN port 0 status change interrupt ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_0_status_intr_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_port_0_status_intr_id_get(
    int unit);

/**
 * \brief returns numeric data of port_1_status_intr_id
 * Module - 'nif', Submodule - 'ilkn', data - 'port_1_status_intr_id'
 * ILKN port 1 status change interrupt ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_1_status_intr_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_port_1_status_intr_id_get(
    int unit);

/**
 * \brief returns numeric data of link_stable_wait
 * Module - 'nif', Submodule - 'ilkn', data - 'link_stable_wait'
 * how long to wait to make sure the link is stable (usec)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     link_stable_wait - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_link_stable_wait_get(
    int unit);

/**
 * \brief returns numeric data of interleaved_error_drop_single_context
 * Module - 'nif', Submodule - 'ilkn', data - 'interleaved_error_drop_single_context'
 * Configure IRE to treat ILKN ports as non-channelized
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interleaved_error_drop_single_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ilkn_interleaved_error_drop_single_context_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_nif_ilkn_table_phys,
    dnx_data_nif_ilkn_table_supported_phys,
    dnx_data_nif_ilkn_table_supported_interfaces,
    dnx_data_nif_ilkn_table_ilkn_cores,
    dnx_data_nif_ilkn_table_ilkn_cores_clup_facing,
    dnx_data_nif_ilkn_table_supported_device_core,
    dnx_data_nif_ilkn_table_properties,
    dnx_data_nif_ilkn_table_nif_pms,
    dnx_data_nif_ilkn_table_fabric_pms,
    dnx_data_nif_ilkn_table_nif_lanes_map,
    dnx_data_nif_ilkn_table_fabric_lanes_map,
    dnx_data_nif_ilkn_table_start_tx_threshold_table,
    dnx_data_nif_ilkn_table_connectivity_options,

    /**
     * Must be last one!
     */
    _dnx_data_nif_ilkn_table_nof
} dnx_data_nif_ilkn_table_e;

/* Get Data */
/**
 * \brief get table phys entry 
 * phys bitmap for ports added by soc property
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     phys - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_phys_t * dnx_data_nif_ilkn_phys_get(
    int unit,
    int ilkn_id);

/**
 * \brief get table supported_phys entry 
 * supported phys per ILKN id
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     supported_phys - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_supported_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_supported_phys_t * dnx_data_nif_ilkn_supported_phys_get(
    int unit,
    int ilkn_id);

/**
 * \brief get table supported_interfaces entry 
 * table with all supported by the device ILKN speeds
 * 
 * \param [in] unit - unit #
 * \param [in] index - entry index
 * 
 * \return
 *     supported_interfaces - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_supported_interfaces_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_supported_interfaces_t * dnx_data_nif_ilkn_supported_interfaces_get(
    int unit,
    int index);

/**
 * \brief get table ilkn_cores entry 
 * Ilkn core properties
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_core_id - ilkn core id
 * 
 * \return
 *     ilkn_cores - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_ilkn_cores_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_ilkn_cores_t * dnx_data_nif_ilkn_ilkn_cores_get(
    int unit,
    int ilkn_core_id);

/**
 * \brief get table ilkn_cores_clup_facing entry 
 * Facing clup id per ilkn core (For J2C ILKN Mux)
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_core_id - ilkn core id
 * 
 * \return
 *     ilkn_cores_clup_facing - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_ilkn_cores_clup_facing_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_ilkn_cores_clup_facing_t * dnx_data_nif_ilkn_ilkn_cores_clup_facing_get(
    int unit,
    int ilkn_core_id);

/**
 * \brief get table supported_device_core entry 
 * supported device core per ILKN id
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     supported_device_core - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_supported_device_core_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_supported_device_core_t * dnx_data_nif_ilkn_supported_device_core_get(
    int unit,
    int ilkn_id);

/**
 * \brief get table properties entry 
 * ILKN properties per ILKN id - added using soc property.
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     properties - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_properties_t * dnx_data_nif_ilkn_properties_get(
    int unit,
    int ilkn_id);

/**
 * \brief get table nif_pms entry 
 * ILKN PM table over NIF
 * 
 * \param [in] unit - unit #
 * \param [in] pm_id - Port Macro identifier
 * 
 * \return
 *     nif_pms - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_nif_pms_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_nif_pms_t * dnx_data_nif_ilkn_nif_pms_get(
    int unit,
    int pm_id);

/**
 * \brief get table fabric_pms entry 
 * ILKN PM table over Fabric
 * 
 * \param [in] unit - unit #
 * \param [in] pm_id - Port Macro identifier
 * 
 * \return
 *     fabric_pms - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_fabric_pms_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_fabric_pms_t * dnx_data_nif_ilkn_fabric_pms_get(
    int unit,
    int pm_id);

/**
 * \brief get table nif_lanes_map entry 
 * ILKN lanes map table
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_core - Ilkn Core id
 * \param [in] range_id - Ilkn lanes range id
 * 
 * \return
 *     nif_lanes_map - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_nif_lanes_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_nif_lanes_map_t * dnx_data_nif_ilkn_nif_lanes_map_get(
    int unit,
    int ilkn_core,
    int range_id);

/**
 * \brief get table fabric_lanes_map entry 
 * ILKN lanes map table
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_core - Ilkn Core id
 * \param [in] range_id - Ilkn lanes range id
 * 
 * \return
 *     fabric_lanes_map - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_fabric_lanes_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_fabric_lanes_map_t * dnx_data_nif_ilkn_fabric_lanes_map_get(
    int unit,
    int ilkn_core,
    int range_id);

/**
 * \brief get table start_tx_threshold_table entry 
 * TX threshold table of values per speed range
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Entry index
 * 
 * \return
 *     start_tx_threshold_table - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_start_tx_threshold_table_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_start_tx_threshold_table_t * dnx_data_nif_ilkn_start_tx_threshold_table_get(
    int unit,
    int idx);

/**
 * \brief get table connectivity_options entry 
 * ILKN interface connectivity options
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ILKN interface ID
 * \param [in] connectivity_mode - ILKN connectivity mode
 * 
 * \return
 *     connectivity_options - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_connectivity_options_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_ilkn_connectivity_options_t * dnx_data_nif_ilkn_connectivity_options_get(
    int unit,
    int ilkn_id,
    int connectivity_mode);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'phys'
 * phys bitmap for ports added by soc property
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_phys_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'supported_phys'
 * supported phys per ILKN id
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_supported_phys_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'supported_interfaces'
 * table with all supported by the device ILKN speeds
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_supported_interfaces_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'ilkn_cores'
 * Ilkn core properties
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_ilkn_cores_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'ilkn_cores_clup_facing'
 * Facing clup id per ilkn core (For J2C ILKN Mux)
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_ilkn_cores_clup_facing_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'supported_device_core'
 * supported device core per ILKN id
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_supported_device_core_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'properties'
 * ILKN properties per ILKN id - added using soc property.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'nif_pms'
 * ILKN PM table over NIF
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_nif_pms_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'fabric_pms'
 * ILKN PM table over Fabric
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_fabric_pms_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'nif_lanes_map'
 * ILKN lanes map table
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_nif_lanes_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'fabric_lanes_map'
 * ILKN lanes map table
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_fabric_lanes_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'start_tx_threshold_table'
 * TX threshold table of values per speed range
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_start_tx_threshold_table_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'ilkn', table - 'connectivity_options'
 * ILKN interface connectivity options
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_ilkn_connectivity_options_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)phys info
 * phys bitmap for ports added by soc property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phys - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_phys_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_phys info
 * supported phys per ILKN id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_phys - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_supported_phys_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_interfaces info
 * table with all supported by the device ILKN speeds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_interfaces - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_supported_interfaces_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ilkn_cores info
 * Ilkn core properties
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_cores - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_ilkn_cores_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ilkn_cores_clup_facing info
 * Facing clup id per ilkn core (For J2C ILKN Mux)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_cores_clup_facing - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_ilkn_cores_clup_facing_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_device_core info
 * supported device core per ILKN id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_device_core - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_supported_device_core_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)properties info
 * ILKN properties per ILKN id - added using soc property.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     properties - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_properties_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)nif_pms info
 * ILKN PM table over NIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_pms - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_nif_pms_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fabric_pms info
 * ILKN PM table over Fabric
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_pms - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_fabric_pms_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)nif_lanes_map info
 * ILKN lanes map table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_lanes_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_nif_lanes_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fabric_lanes_map info
 * ILKN lanes map table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_lanes_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_fabric_lanes_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)start_tx_threshold_table info
 * TX threshold table of values per speed range
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     start_tx_threshold_table - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_start_tx_threshold_table_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)connectivity_options info
 * ILKN interface connectivity options
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     connectivity_options - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_ilkn_connectivity_options_info_get(
    int unit);

/*
 * SUBMODULE ETH:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_eth_feature_get(
    int unit,
    dnx_data_nif_eth_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_eth_define_cdu_nof,
    dnx_data_nif_eth_define_clu_nof,
    dnx_data_nif_eth_define_nbu_nof,
    dnx_data_nif_eth_define_mgu_nof,
    dnx_data_nif_eth_define_cdum_nof,
    dnx_data_nif_eth_define_nof_pms_in_cdu,
    dnx_data_nif_eth_define_nof_pms_in_clu,
    dnx_data_nif_eth_define_nof_pms_in_nbu,
    dnx_data_nif_eth_define_nof_pms_in_mgu,
    dnx_data_nif_eth_define_total_nof_ethu_pms_in_device,
    dnx_data_nif_eth_define_nof_cdu_lanes_in_pm,
    dnx_data_nif_eth_define_nof_clu_lanes_in_pm,
    dnx_data_nif_eth_define_nof_cdu_pms,
    dnx_data_nif_eth_define_nof_clu_pms,
    dnx_data_nif_eth_define_nof_nbu_lanes_in_pm,
    dnx_data_nif_eth_define_nof_mgu_lanes_in_pm,
    dnx_data_nif_eth_define_nof_nbu_pms,
    dnx_data_nif_eth_define_nof_mgu_pms,
    dnx_data_nif_eth_define_ethu_nof,
    dnx_data_nif_eth_define_ethu_nof_per_core,
    dnx_data_nif_eth_define_cdu_nof_per_core,
    dnx_data_nif_eth_define_clu_nof_per_core,
    dnx_data_nif_eth_define_nof_lanes_in_cdu,
    dnx_data_nif_eth_define_nof_lanes_in_clu,
    dnx_data_nif_eth_define_nof_lanes_in_nbu,
    dnx_data_nif_eth_define_nof_lanes_in_mgu,
    dnx_data_nif_eth_define_max_nof_lanes_in_ethu,
    dnx_data_nif_eth_define_total_nof_cdu_lanes_in_device,
    dnx_data_nif_eth_define_total_nof_nbu_lanes_in_device,
    dnx_data_nif_eth_define_cdu_mac_mode_config_nof,
    dnx_data_nif_eth_define_nbu_mac_mode_config_nof,
    dnx_data_nif_eth_define_mac_mode_config_lanes_nof,
    dnx_data_nif_eth_define_cdu_mac_nof,
    dnx_data_nif_eth_define_nbu_mac_nof,
    dnx_data_nif_eth_define_mac_lanes_nof,
    dnx_data_nif_eth_define_ethu_logical_fifo_nof,
    dnx_data_nif_eth_define_cdu_memory_entries_nof,
    dnx_data_nif_eth_define_clu_memory_entries_nof,
    dnx_data_nif_eth_define_nbu_memory_entries_nof,
    dnx_data_nif_eth_define_mgu_memory_entries_nof,
    dnx_data_nif_eth_define_priority_group_nof_entries_min,
    dnx_data_nif_eth_define_priority_groups_nof,
    dnx_data_nif_eth_define_pad_size_min,
    dnx_data_nif_eth_define_pad_size_max,
    dnx_data_nif_eth_define_packet_size_max,
    dnx_data_nif_eth_define_an_max_nof_abilities,
    dnx_data_nif_eth_define_phy_map_granularity,
    dnx_data_nif_eth_define_is_400G_supported,

    /**
     * Must be last one!
     */
    _dnx_data_nif_eth_define_nof
} dnx_data_nif_eth_define_e;

/* Get Data */
/**
 * \brief returns define data of cdu_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_nof'
 * Number of CDU instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_cdu_nof_get(
    int unit);

/**
 * \brief returns define data of clu_nof
 * Module - 'nif', Submodule - 'eth', data - 'clu_nof'
 * Number of CLU instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     clu_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_clu_nof_get(
    int unit);

/**
 * \brief returns define data of nbu_nof
 * Module - 'nif', Submodule - 'eth', data - 'nbu_nof'
 * Number of NBU instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nbu_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nbu_nof_get(
    int unit);

/**
 * \brief returns define data of mgu_nof
 * Module - 'nif', Submodule - 'eth', data - 'mgu_nof'
 * Number of MGU instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mgu_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_mgu_nof_get(
    int unit);

/**
 * \brief returns define data of cdum_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdum_nof'
 * Number of CDUM instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdum_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_cdum_nof_get(
    int unit);

/**
 * \brief returns define data of nof_pms_in_cdu
 * Module - 'nif', Submodule - 'eth', data - 'nof_pms_in_cdu'
 * Number of pms in each CDU in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms_in_cdu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_pms_in_cdu_get(
    int unit);

/**
 * \brief returns define data of nof_pms_in_clu
 * Module - 'nif', Submodule - 'eth', data - 'nof_pms_in_clu'
 * Number of pms in each CLU in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms_in_clu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_pms_in_clu_get(
    int unit);

/**
 * \brief returns define data of nof_pms_in_nbu
 * Module - 'nif', Submodule - 'eth', data - 'nof_pms_in_nbu'
 * Number of pms in each NBU in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms_in_nbu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_pms_in_nbu_get(
    int unit);

/**
 * \brief returns define data of nof_pms_in_mgu
 * Module - 'nif', Submodule - 'eth', data - 'nof_pms_in_mgu'
 * Number of pms in each MGU in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms_in_mgu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_pms_in_mgu_get(
    int unit);

/**
 * \brief returns define data of total_nof_ethu_pms_in_device
 * Module - 'nif', Submodule - 'eth', data - 'total_nof_ethu_pms_in_device'
 * Maximum number of ETHU pms in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_ethu_pms_in_device - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_total_nof_ethu_pms_in_device_get(
    int unit);

/**
 * \brief returns define data of nof_cdu_lanes_in_pm
 * Module - 'nif', Submodule - 'eth', data - 'nof_cdu_lanes_in_pm'
 * Number of lanes in pm in CDU unit in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cdu_lanes_in_pm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_cdu_lanes_in_pm_get(
    int unit);

/**
 * \brief returns define data of nof_clu_lanes_in_pm
 * Module - 'nif', Submodule - 'eth', data - 'nof_clu_lanes_in_pm'
 * Number of lanes in pm in CLU unit in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_clu_lanes_in_pm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_clu_lanes_in_pm_get(
    int unit);

/**
 * \brief returns define data of nof_cdu_pms
 * Module - 'nif', Submodule - 'eth', data - 'nof_cdu_pms'
 * Number of CDU pms in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cdu_pms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_cdu_pms_get(
    int unit);

/**
 * \brief returns define data of nof_clu_pms
 * Module - 'nif', Submodule - 'eth', data - 'nof_clu_pms'
 * Number of CLU pms in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_clu_pms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_clu_pms_get(
    int unit);

/**
 * \brief returns define data of nof_nbu_lanes_in_pm
 * Module - 'nif', Submodule - 'eth', data - 'nof_nbu_lanes_in_pm'
 * Number of lanes in pm in NBU unit in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_nbu_lanes_in_pm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_nbu_lanes_in_pm_get(
    int unit);

/**
 * \brief returns define data of nof_mgu_lanes_in_pm
 * Module - 'nif', Submodule - 'eth', data - 'nof_mgu_lanes_in_pm'
 * Number of lanes in pm in MGU unit in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mgu_lanes_in_pm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_mgu_lanes_in_pm_get(
    int unit);

/**
 * \brief returns define data of nof_nbu_pms
 * Module - 'nif', Submodule - 'eth', data - 'nof_nbu_pms'
 * Number of NBU pms in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_nbu_pms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_nbu_pms_get(
    int unit);

/**
 * \brief returns define data of nof_mgu_pms
 * Module - 'nif', Submodule - 'eth', data - 'nof_mgu_pms'
 * Number of MGU pms in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mgu_pms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_mgu_pms_get(
    int unit);

/**
 * \brief returns define data of ethu_nof
 * Module - 'nif', Submodule - 'eth', data - 'ethu_nof'
 * Maximum number of ETHU in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ethu_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_ethu_nof_get(
    int unit);

/**
 * \brief returns define data of ethu_nof_per_core
 * Module - 'nif', Submodule - 'eth', data - 'ethu_nof_per_core'
 * Maximum number of ETHU in each device core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ethu_nof_per_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_ethu_nof_per_core_get(
    int unit);

/**
 * \brief returns define data of cdu_nof_per_core
 * Module - 'nif', Submodule - 'eth', data - 'cdu_nof_per_core'
 * Number of CDU instances in each device core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_nof_per_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_cdu_nof_per_core_get(
    int unit);

/**
 * \brief returns define data of clu_nof_per_core
 * Module - 'nif', Submodule - 'eth', data - 'clu_nof_per_core'
 * Number of CLU instances in each device core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     clu_nof_per_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_clu_nof_per_core_get(
    int unit);

/**
 * \brief returns define data of nof_lanes_in_cdu
 * Module - 'nif', Submodule - 'eth', data - 'nof_lanes_in_cdu'
 * Number of lanes in each CDU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lanes_in_cdu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_lanes_in_cdu_get(
    int unit);

/**
 * \brief returns define data of nof_lanes_in_clu
 * Module - 'nif', Submodule - 'eth', data - 'nof_lanes_in_clu'
 * Number of lanes in each CLU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lanes_in_clu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_lanes_in_clu_get(
    int unit);

/**
 * \brief returns define data of nof_lanes_in_nbu
 * Module - 'nif', Submodule - 'eth', data - 'nof_lanes_in_nbu'
 * Number of lanes in each NBU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lanes_in_nbu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_lanes_in_nbu_get(
    int unit);

/**
 * \brief returns define data of nof_lanes_in_mgu
 * Module - 'nif', Submodule - 'eth', data - 'nof_lanes_in_mgu'
 * Number of lanes in each MGU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lanes_in_mgu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nof_lanes_in_mgu_get(
    int unit);

/**
 * \brief returns define data of max_nof_lanes_in_ethu
 * Module - 'nif', Submodule - 'eth', data - 'max_nof_lanes_in_ethu'
 * Maximal number of lanes in ethernet unit (maximum between CLU and CDU)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_lanes_in_ethu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_max_nof_lanes_in_ethu_get(
    int unit);

/**
 * \brief returns define data of total_nof_cdu_lanes_in_device
 * Module - 'nif', Submodule - 'eth', data - 'total_nof_cdu_lanes_in_device'
 * Number of CDU lanes in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_cdu_lanes_in_device - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_total_nof_cdu_lanes_in_device_get(
    int unit);

/**
 * \brief returns define data of total_nof_nbu_lanes_in_device
 * Module - 'nif', Submodule - 'eth', data - 'total_nof_nbu_lanes_in_device'
 * Number of NBU lanes in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_nbu_lanes_in_device - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_total_nof_nbu_lanes_in_device_get(
    int unit);

/**
 * \brief returns define data of cdu_mac_mode_config_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_mac_mode_config_nof'
 * Number of MAC mode config units per CDU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_mac_mode_config_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_cdu_mac_mode_config_nof_get(
    int unit);

/**
 * \brief returns define data of nbu_mac_mode_config_nof
 * Module - 'nif', Submodule - 'eth', data - 'nbu_mac_mode_config_nof'
 * Number of MAC mode config units per NBU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nbu_mac_mode_config_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nbu_mac_mode_config_nof_get(
    int unit);

/**
 * \brief returns define data of mac_mode_config_lanes_nof
 * Module - 'nif', Submodule - 'eth', data - 'mac_mode_config_lanes_nof'
 * Number of lanes in each MAC mode config
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_mode_config_lanes_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_mac_mode_config_lanes_nof_get(
    int unit);

/**
 * \brief returns define data of cdu_mac_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_mac_nof'
 * Number of MAC units per CDU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_mac_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_cdu_mac_nof_get(
    int unit);

/**
 * \brief returns define data of nbu_mac_nof
 * Module - 'nif', Submodule - 'eth', data - 'nbu_mac_nof'
 * Number of MAC units per NBU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nbu_mac_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nbu_mac_nof_get(
    int unit);

/**
 * \brief returns define data of mac_lanes_nof
 * Module - 'nif', Submodule - 'eth', data - 'mac_lanes_nof'
 * Number of lanes in each MAC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_lanes_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_mac_lanes_nof_get(
    int unit);

/**
 * \brief returns define data of ethu_logical_fifo_nof
 * Module - 'nif', Submodule - 'eth', data - 'ethu_logical_fifo_nof'
 * number of logical fifos in the CDU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ethu_logical_fifo_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_ethu_logical_fifo_nof_get(
    int unit);

/**
 * \brief returns define data of cdu_memory_entries_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_memory_entries_nof'
 * number of entries in the CDU memory, to be shared between all logical FIFOs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_memory_entries_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_cdu_memory_entries_nof_get(
    int unit);

/**
 * \brief returns define data of clu_memory_entries_nof
 * Module - 'nif', Submodule - 'eth', data - 'clu_memory_entries_nof'
 * number of entries in the CLU memory, to be shared between all logical FIFOs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     clu_memory_entries_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_clu_memory_entries_nof_get(
    int unit);

/**
 * \brief returns define data of nbu_memory_entries_nof
 * Module - 'nif', Submodule - 'eth', data - 'nbu_memory_entries_nof'
 * number of entries in the NBU memory, to be shared between all logical FIFOs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nbu_memory_entries_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_nbu_memory_entries_nof_get(
    int unit);

/**
 * \brief returns define data of mgu_memory_entries_nof
 * Module - 'nif', Submodule - 'eth', data - 'mgu_memory_entries_nof'
 * number of entries in the MGU memory, to be shared between all logical FIFOs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mgu_memory_entries_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_mgu_memory_entries_nof_get(
    int unit);

/**
 * \brief returns define data of priority_group_nof_entries_min
 * Module - 'nif', Submodule - 'eth', data - 'priority_group_nof_entries_min'
 * minimum number of entries to allocate to a priority group (priority group = RMC)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     priority_group_nof_entries_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_priority_group_nof_entries_min_get(
    int unit);

/**
 * \brief returns define data of priority_groups_nof
 * Module - 'nif', Submodule - 'eth', data - 'priority_groups_nof'
 * number of allowed priority groups per port (priority group = RMC)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     priority_groups_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_priority_groups_nof_get(
    int unit);

/**
 * \brief returns define data of pad_size_min
 * Module - 'nif', Submodule - 'eth', data - 'pad_size_min'
 * min padding size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pad_size_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_pad_size_min_get(
    int unit);

/**
 * \brief returns define data of pad_size_max
 * Module - 'nif', Submodule - 'eth', data - 'pad_size_max'
 * max padding size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pad_size_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_pad_size_max_get(
    int unit);

/**
 * \brief returns define data of packet_size_max
 * Module - 'nif', Submodule - 'eth', data - 'packet_size_max'
 * max packet size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     packet_size_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_packet_size_max_get(
    int unit);

/**
 * \brief returns define data of an_max_nof_abilities
 * Module - 'nif', Submodule - 'eth', data - 'an_max_nof_abilities'
 * max auto-negotiation abilities
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     an_max_nof_abilities - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_an_max_nof_abilities_get(
    int unit);

/**
 * \brief returns define data of phy_map_granularity
 * Module - 'nif', Submodule - 'eth', data - 'phy_map_granularity'
 * Phy granularity of phy_map table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_map_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_phy_map_granularity_get(
    int unit);

/**
 * \brief returns define data of is_400G_supported
 * Module - 'nif', Submodule - 'eth', data - 'is_400G_supported'
 * Marks if 400G speed port is supported for the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     is_400G_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_eth_is_400G_supported_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_nif_eth_table_start_tx_threshold_table,
    dnx_data_nif_eth_table_pm_properties,
    dnx_data_nif_eth_table_ethu_properties,
    dnx_data_nif_eth_table_phy_map,
    dnx_data_nif_eth_table_max_speed,
    dnx_data_nif_eth_table_supported_interfaces,
    dnx_data_nif_eth_table_ethu_per_core,
    dnx_data_nif_eth_table_nif_cores_ethus,
    dnx_data_nif_eth_table_supported_clu_an_abilities,

    /**
     * Must be last one!
     */
    _dnx_data_nif_eth_table_nof
} dnx_data_nif_eth_table_e;

/* Get Data */
/**
 * \brief get table start_tx_threshold_table entry 
 * TX threshold table of values per speed range
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Entry index
 * 
 * \return
 *     start_tx_threshold_table - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_start_tx_threshold_table_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_start_tx_threshold_table_t * dnx_data_nif_eth_start_tx_threshold_table_get(
    int unit,
    int idx);

/**
 * \brief get table pm_properties entry 
 * PM properties per PM
 * 
 * \param [in] unit - unit #
 * \param [in] pm_index - PM instance number.
 * 
 * \return
 *     pm_properties - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_pm_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_pm_properties_t * dnx_data_nif_eth_pm_properties_get(
    int unit,
    int pm_index);

/**
 * \brief get table ethu_properties entry 
 * map ethu to PM instance
 * 
 * \param [in] unit - unit #
 * \param [in] ethu_index - ethu instance number.
 * 
 * \return
 *     ethu_properties - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_ethu_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_ethu_properties_t * dnx_data_nif_eth_ethu_properties_get(
    int unit,
    int ethu_index);

/**
 * \brief get table phy_map entry 
 * Map phy index to ETHU index and PM index. Phy index granularity is defined by phy_map_granularity
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Entry Index
 * 
 * \return
 *     phy_map - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_phy_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_phy_map_t * dnx_data_nif_eth_phy_map_get(
    int unit,
    int idx);

/**
 * \brief get table max_speed entry 
 * Max speed for each ethernet interface type.
 * 
 * \param [in] unit - unit #
 * \param [in] lane_num - number of lanes for the given interface type.
 * 
 * \return
 *     max_speed - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_max_speed_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_max_speed_t * dnx_data_nif_eth_max_speed_get(
    int unit,
    int lane_num);

/**
 * \brief get table supported_interfaces entry 
 * Table with all the supported Ethernet interfaces for the device.
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Running index
 * 
 * \return
 *     supported_interfaces - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_supported_interfaces_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_supported_interfaces_t * dnx_data_nif_eth_supported_interfaces_get(
    int unit,
    int idx);

/**
 * \brief get table ethu_per_core entry 
 * Table which mapps each ETH unit id nif core.
 * 
 * \param [in] unit - unit #
 * \param [in] ethu_index - ethu instance number.
 * 
 * \return
 *     ethu_per_core - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_ethu_per_core_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_ethu_per_core_t * dnx_data_nif_eth_ethu_per_core_get(
    int unit,
    int ethu_index);

/**
 * \brief get table nif_cores_ethus entry 
 * Table describes the ETHU ids in each NIF core
 * 
 * \param [in] unit - unit #
 * \param [in] core_id - NIF core index
 * 
 * \return
 *     nif_cores_ethus - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_nif_cores_ethus_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_nif_cores_ethus_t * dnx_data_nif_eth_nif_cores_ethus_get(
    int unit,
    int core_id);

/**
 * \brief get table supported_clu_an_abilities entry 
 * Table with all the supported AN ability for legacy PMs.
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Running index
 * 
 * \return
 *     supported_clu_an_abilities - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_supported_clu_an_abilities_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_eth_supported_clu_an_abilities_t * dnx_data_nif_eth_supported_clu_an_abilities_get(
    int unit,
    int idx);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'start_tx_threshold_table'
 * TX threshold table of values per speed range
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_start_tx_threshold_table_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'pm_properties'
 * PM properties per PM
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_pm_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'ethu_properties'
 * map ethu to PM instance
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_ethu_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'phy_map'
 * Map phy index to ETHU index and PM index. Phy index granularity is defined by phy_map_granularity
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_phy_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'max_speed'
 * Max speed for each ethernet interface type.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_max_speed_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'supported_interfaces'
 * Table with all the supported Ethernet interfaces for the device.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_supported_interfaces_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'ethu_per_core'
 * Table which mapps each ETH unit id nif core.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_ethu_per_core_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'nif_cores_ethus'
 * Table describes the ETHU ids in each NIF core
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_nif_cores_ethus_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'eth', table - 'supported_clu_an_abilities'
 * Table with all the supported AN ability for legacy PMs.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_eth_supported_clu_an_abilities_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)start_tx_threshold_table info
 * TX threshold table of values per speed range
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     start_tx_threshold_table - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_start_tx_threshold_table_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)pm_properties info
 * PM properties per PM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pm_properties - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_pm_properties_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ethu_properties info
 * map ethu to PM instance
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ethu_properties - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_ethu_properties_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)phy_map info
 * Map phy index to ETHU index and PM index. Phy index granularity is defined by phy_map_granularity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_phy_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)max_speed info
 * Max speed for each ethernet interface type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_speed - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_max_speed_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_interfaces info
 * Table with all the supported Ethernet interfaces for the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_interfaces - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_supported_interfaces_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ethu_per_core info
 * Table which mapps each ETH unit id nif core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ethu_per_core - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_ethu_per_core_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)nif_cores_ethus info
 * Table describes the ETHU ids in each NIF core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_cores_ethus - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_nif_cores_ethus_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_clu_an_abilities info
 * Table with all the supported AN ability for legacy PMs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_clu_an_abilities - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_eth_supported_clu_an_abilities_info_get(
    int unit);

/*
 * SUBMODULE SIMULATOR:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_simulator_feature_get(
    int unit,
    dnx_data_nif_simulator_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_simulator_define_cdu_type,
    dnx_data_nif_simulator_define_clu_type,
    dnx_data_nif_simulator_define_nbu_type,
    dnx_data_nif_simulator_define_mgu_type,

    /**
     * Must be last one!
     */
    _dnx_data_nif_simulator_define_nof
} dnx_data_nif_simulator_define_e;

/* Get Data */
/**
 * \brief returns numeric data of cdu_type
 * Module - 'nif', Submodule - 'simulator', data - 'cdu_type'
 * Type of CDU phy simulator
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_type - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_simulator_cdu_type_get(
    int unit);

/**
 * \brief returns numeric data of clu_type
 * Module - 'nif', Submodule - 'simulator', data - 'clu_type'
 * Type of CLU phy simulator
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     clu_type - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_simulator_clu_type_get(
    int unit);

/**
 * \brief returns numeric data of nbu_type
 * Module - 'nif', Submodule - 'simulator', data - 'nbu_type'
 * Type of NBU phy simulator
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nbu_type - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_simulator_nbu_type_get(
    int unit);

/**
 * \brief returns numeric data of mgu_type
 * Module - 'nif', Submodule - 'simulator', data - 'mgu_type'
 * Type of MGU phy simulator
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mgu_type - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_simulator_mgu_type_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_simulator_table_nof
} dnx_data_nif_simulator_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FLEXE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_flexe_feature_get(
    int unit,
    dnx_data_nif_flexe_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_flexe_define_feu_nof,
    dnx_data_nif_flexe_define_nof_clients,
    dnx_data_nif_flexe_define_nof_flexe_clients,
    dnx_data_nif_flexe_define_nof_special_clients,
    dnx_data_nif_flexe_define_nof_groups,
    dnx_data_nif_flexe_define_max_group_id,
    dnx_data_nif_flexe_define_min_group_id,
    dnx_data_nif_flexe_define_nb_tx_delay,
    dnx_data_nif_flexe_define_nb_tx_fifo_th_for_first_read,
    dnx_data_nif_flexe_define_nof_pcs,
    dnx_data_nif_flexe_define_nof_phy_speeds,
    dnx_data_nif_flexe_define_phy_speed_granularity,
    dnx_data_nif_flexe_define_max_flexe_core_speed,
    dnx_data_nif_flexe_define_flexe_core_clock_source_pm,
    dnx_data_nif_flexe_define_nof_logical_fifos,
    dnx_data_nif_flexe_define_sar_channel_base,
    dnx_data_nif_flexe_define_mac_channel_base,
    dnx_data_nif_flexe_define_client_speed_granularity,
    dnx_data_nif_flexe_define_nof_sb_rx_fifos,
    dnx_data_nif_flexe_define_oam_client_channel,
    dnx_data_nif_flexe_define_ptp_client_channel,
    dnx_data_nif_flexe_define_oam_tx_cal_slot,
    dnx_data_nif_flexe_define_ptp_tx_cal_slot,
    dnx_data_nif_flexe_define_priority_groups_nof,
    dnx_data_nif_flexe_define_max_nof_slots,
    dnx_data_nif_flexe_define_min_client_id,
    dnx_data_nif_flexe_define_max_client_id,
    dnx_data_nif_flexe_define_ptp_channel_max_bandwidth,
    dnx_data_nif_flexe_define_oam_channel_max_bandwidth,
    dnx_data_nif_flexe_define_nof_mem_entries_per_slot,
    dnx_data_nif_flexe_define_ptp_oam_fifo_entries_in_sb_rx,
    dnx_data_nif_flexe_define_nof_flexe_instances,
    dnx_data_nif_flexe_define_nof_flexe_lphys,
    dnx_data_nif_flexe_define_nof_sar_timeslots,
    dnx_data_nif_flexe_define_nof_mac_timeslots,
    dnx_data_nif_flexe_define_distributed_ilu_id,
    dnx_data_nif_flexe_define_max_nif_rate_centralized,
    dnx_data_nif_flexe_define_rmc_cal_nof_slots,
    dnx_data_nif_flexe_define_max_nif_rate_distributed,
    dnx_data_nif_flexe_define_max_ilu_rate_distributed,
    dnx_data_nif_flexe_define_ilkn_burst_size_in_feu,
    dnx_data_nif_flexe_define_average_ipg_for_l1,
    dnx_data_nif_flexe_define_mac_tx_threshold,
    dnx_data_nif_flexe_define_sar_jitter_tolerance_max_level,
    dnx_data_nif_flexe_define_mac_pad_size,
    dnx_data_nif_flexe_define_flexe_mode,
    dnx_data_nif_flexe_define_nof_pms_per_feu,
    dnx_data_nif_flexe_define_nb_tdm_slot_allocation_mode,

    /**
     * Must be last one!
     */
    _dnx_data_nif_flexe_define_nof
} dnx_data_nif_flexe_define_e;

/* Get Data */
/**
 * \brief returns define data of feu_nof
 * Module - 'nif', Submodule - 'flexe', data - 'feu_nof'
 * Number of FEU instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     feu_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_feu_nof_get(
    int unit);

/**
 * \brief returns define data of nof_clients
 * Module - 'nif', Submodule - 'flexe', data - 'nof_clients'
 * Number of total clients, including 1588 and OAM channel
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_clients - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_clients_get(
    int unit);

/**
 * \brief returns define data of nof_flexe_clients
 * Module - 'nif', Submodule - 'flexe', data - 'nof_flexe_clients'
 * Number of FlexE clients
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_flexe_clients - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_flexe_clients_get(
    int unit);

/**
 * \brief returns define data of nof_special_clients
 * Module - 'nif', Submodule - 'flexe', data - 'nof_special_clients'
 * Number of special clients for 1588 and OAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_special_clients - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_special_clients_get(
    int unit);

/**
 * \brief returns define data of nof_groups
 * Module - 'nif', Submodule - 'flexe', data - 'nof_groups'
 * Number of FlexE groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_groups_get(
    int unit);

/**
 * \brief returns define data of max_group_id
 * Module - 'nif', Submodule - 'flexe', data - 'max_group_id'
 * MAX FlexE group ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_group_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_max_group_id_get(
    int unit);

/**
 * \brief returns define data of min_group_id
 * Module - 'nif', Submodule - 'flexe', data - 'min_group_id'
 * MIN FlexE group ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_group_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_min_group_id_get(
    int unit);

/**
 * \brief returns define data of nb_tx_delay
 * Module - 'nif', Submodule - 'flexe', data - 'nb_tx_delay'
 * The TX delay in NB interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nb_tx_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nb_tx_delay_get(
    int unit);

/**
 * \brief returns define data of nb_tx_fifo_th_for_first_read
 * Module - 'nif', Submodule - 'flexe', data - 'nb_tx_fifo_th_for_first_read'
 * first read from fifo will start only after data has accumulated in the fifo.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nb_tx_fifo_th_for_first_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nb_tx_fifo_th_for_first_read_get(
    int unit);

/**
 * \brief returns define data of nof_pcs
 * Module - 'nif', Submodule - 'flexe', data - 'nof_pcs'
 * Number of FlexE pcs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pcs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_pcs_get(
    int unit);

/**
 * \brief returns define data of nof_phy_speeds
 * Module - 'nif', Submodule - 'flexe', data - 'nof_phy_speeds'
 * Number of PHY speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phy_speeds - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_phy_speeds_get(
    int unit);

/**
 * \brief returns define data of phy_speed_granularity
 * Module - 'nif', Submodule - 'flexe', data - 'phy_speed_granularity'
 * The granularity for PHY speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_phy_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of max_flexe_core_speed
 * Module - 'nif', Submodule - 'flexe', data - 'max_flexe_core_speed'
 * The max capacity for FlexE core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_flexe_core_speed - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_max_flexe_core_speed_get(
    int unit);

/**
 * \brief returns define data of flexe_core_clock_source_pm
 * Module - 'nif', Submodule - 'flexe', data - 'flexe_core_clock_source_pm'
 * Define the clock source PM id for flexe core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flexe_core_clock_source_pm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_flexe_core_clock_source_pm_get(
    int unit);

/**
 * \brief returns define data of nof_logical_fifos
 * Module - 'nif', Submodule - 'flexe', data - 'nof_logical_fifos'
 * Number of FlexE client logical fifos
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_logical_fifos - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_logical_fifos_get(
    int unit);

/**
 * \brief returns define data of sar_channel_base
 * Module - 'nif', Submodule - 'flexe', data - 'sar_channel_base'
 * base number for SAR channel
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sar_channel_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_sar_channel_base_get(
    int unit);

/**
 * \brief returns define data of mac_channel_base
 * Module - 'nif', Submodule - 'flexe', data - 'mac_channel_base'
 * base number for MAC channel
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_channel_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_mac_channel_base_get(
    int unit);

/**
 * \brief returns define data of client_speed_granularity
 * Module - 'nif', Submodule - 'flexe', data - 'client_speed_granularity'
 * The FlexE client speed granularity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     client_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_client_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of nof_sb_rx_fifos
 * Module - 'nif', Submodule - 'flexe', data - 'nof_sb_rx_fifos'
 * Number of SB RX fifos
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_sb_rx_fifos - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_sb_rx_fifos_get(
    int unit);

/**
 * \brief returns define data of oam_client_channel
 * Module - 'nif', Submodule - 'flexe', data - 'oam_client_channel'
 * Client channel ID for OAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_client_channel - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_oam_client_channel_get(
    int unit);

/**
 * \brief returns define data of ptp_client_channel
 * Module - 'nif', Submodule - 'flexe', data - 'ptp_client_channel'
 * Client channel ID for 1588
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ptp_client_channel - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_ptp_client_channel_get(
    int unit);

/**
 * \brief returns define data of oam_tx_cal_slot
 * Module - 'nif', Submodule - 'flexe', data - 'oam_tx_cal_slot'
 * TMC Calendar slot for OAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_tx_cal_slot - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_oam_tx_cal_slot_get(
    int unit);

/**
 * \brief returns define data of ptp_tx_cal_slot
 * Module - 'nif', Submodule - 'flexe', data - 'ptp_tx_cal_slot'
 * TMC Calendar slot for 1588
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ptp_tx_cal_slot - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_ptp_tx_cal_slot_get(
    int unit);

/**
 * \brief returns define data of priority_groups_nof
 * Module - 'nif', Submodule - 'flexe', data - 'priority_groups_nof'
 * number of allowed priority groups per port (priority group = RMC)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     priority_groups_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_priority_groups_nof_get(
    int unit);

/**
 * \brief returns define data of max_nof_slots
 * Module - 'nif', Submodule - 'flexe', data - 'max_nof_slots'
 * Define the MAX number of time slots
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_slots - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_max_nof_slots_get(
    int unit);

/**
 * \brief returns define data of min_client_id
 * Module - 'nif', Submodule - 'flexe', data - 'min_client_id'
 * Define the Min client ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_client_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_min_client_id_get(
    int unit);

/**
 * \brief returns define data of max_client_id
 * Module - 'nif', Submodule - 'flexe', data - 'max_client_id'
 * Define the MAX client ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_client_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_max_client_id_get(
    int unit);

/**
 * \brief returns define data of ptp_channel_max_bandwidth
 * Module - 'nif', Submodule - 'flexe', data - 'ptp_channel_max_bandwidth'
 * Max bandwidth for PTP channel
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ptp_channel_max_bandwidth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_ptp_channel_max_bandwidth_get(
    int unit);

/**
 * \brief returns define data of oam_channel_max_bandwidth
 * Module - 'nif', Submodule - 'flexe', data - 'oam_channel_max_bandwidth'
 * Max bandwidth for OAM channel
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_channel_max_bandwidth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_oam_channel_max_bandwidth_get(
    int unit);

/**
 * \brief returns define data of nof_mem_entries_per_slot
 * Module - 'nif', Submodule - 'flexe', data - 'nof_mem_entries_per_slot'
 * Nof memory entries per RMC slots
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mem_entries_per_slot - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_mem_entries_per_slot_get(
    int unit);

/**
 * \brief returns define data of ptp_oam_fifo_entries_in_sb_rx
 * Module - 'nif', Submodule - 'flexe', data - 'ptp_oam_fifo_entries_in_sb_rx'
 * Nof FIFO entries for PTP OAM client in SB RX FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ptp_oam_fifo_entries_in_sb_rx - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_ptp_oam_fifo_entries_in_sb_rx_get(
    int unit);

/**
 * \brief returns define data of nof_flexe_instances
 * Module - 'nif', Submodule - 'flexe', data - 'nof_flexe_instances'
 * Number of FlexE instances
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_flexe_instances - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_flexe_instances_get(
    int unit);

/**
 * \brief returns define data of nof_flexe_lphys
 * Module - 'nif', Submodule - 'flexe', data - 'nof_flexe_lphys'
 * Number of FlexE logical PHYs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_flexe_lphys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_flexe_lphys_get(
    int unit);

/**
 * \brief returns define data of nof_sar_timeslots
 * Module - 'nif', Submodule - 'flexe', data - 'nof_sar_timeslots'
 * Number of FlexE SAR timeslots
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_sar_timeslots - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_sar_timeslots_get(
    int unit);

/**
 * \brief returns define data of nof_mac_timeslots
 * Module - 'nif', Submodule - 'flexe', data - 'nof_mac_timeslots'
 * Number of FlexE MAC timeslots
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mac_timeslots - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_mac_timeslots_get(
    int unit);

/**
 * \brief returns define data of distributed_ilu_id
 * Module - 'nif', Submodule - 'flexe', data - 'distributed_ilu_id'
 * ILKN CORE ID for FlexE distributed mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     distributed_ilu_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_distributed_ilu_id_get(
    int unit);

/**
 * \brief returns define data of max_nif_rate_centralized
 * Module - 'nif', Submodule - 'flexe', data - 'max_nif_rate_centralized'
 * Max NIF capacity when flexe is enabled in centralized mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nif_rate_centralized - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_max_nif_rate_centralized_get(
    int unit);

/**
 * \brief returns define data of rmc_cal_nof_slots
 * Module - 'nif', Submodule - 'flexe', data - 'rmc_cal_nof_slots'
 * Nof slots for RMC calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rmc_cal_nof_slots - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_rmc_cal_nof_slots_get(
    int unit);

/**
 * \brief returns define data of max_nif_rate_distributed
 * Module - 'nif', Submodule - 'flexe', data - 'max_nif_rate_distributed'
 * Max NIF capacity when flexe is enabled in distributed mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nif_rate_distributed - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_max_nif_rate_distributed_get(
    int unit);

/**
 * \brief returns define data of max_ilu_rate_distributed
 * Module - 'nif', Submodule - 'flexe', data - 'max_ilu_rate_distributed'
 * Max ILU capacity for flexe distributed interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ilu_rate_distributed - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_max_ilu_rate_distributed_get(
    int unit);

/**
 * \brief returns define data of ilkn_burst_size_in_feu
 * Module - 'nif', Submodule - 'flexe', data - 'ilkn_burst_size_in_feu'
 * Burst size for ILKN in FEU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_burst_size_in_feu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_ilkn_burst_size_in_feu_get(
    int unit);

/**
 * \brief returns define data of average_ipg_for_l1
 * Module - 'nif', Submodule - 'flexe', data - 'average_ipg_for_l1'
 * Average IPG in bits for L1 ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_ipg_for_l1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_average_ipg_for_l1_get(
    int unit);

/**
 * \brief returns define data of mac_tx_threshold
 * Module - 'nif', Submodule - 'flexe', data - 'mac_tx_threshold'
 * Tx threshold in Tiny MAC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_tx_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_mac_tx_threshold_get(
    int unit);

/**
 * \brief returns define data of sar_jitter_tolerance_max_level
 * Module - 'nif', Submodule - 'flexe', data - 'sar_jitter_tolerance_max_level'
 * Max jitter tolerance level for SAR Rx fifo
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sar_jitter_tolerance_max_level - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_sar_jitter_tolerance_max_level_get(
    int unit);

/**
 * \brief returns define data of mac_pad_size
 * Module - 'nif', Submodule - 'flexe', data - 'mac_pad_size'
 * Default pad size in Tiny MAC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_pad_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_mac_pad_size_get(
    int unit);

/**
 * \brief returns numeric data of flexe_mode
 * Module - 'nif', Submodule - 'flexe', data - 'flexe_mode'
 * FlexE mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flexe_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_flexe_mode_get(
    int unit);

/**
 * \brief returns numeric data of nof_pms_per_feu
 * Module - 'nif', Submodule - 'flexe', data - 'nof_pms_per_feu'
 * Number of PMs for each FEU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms_per_feu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nof_pms_per_feu_get(
    int unit);

/**
 * \brief returns numeric data of nb_tdm_slot_allocation_mode
 * Module - 'nif', Submodule - 'flexe', data - 'nb_tdm_slot_allocation_mode'
 * The NB TDM slot allocation mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nb_tdm_slot_allocation_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_flexe_nb_tdm_slot_allocation_mode_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_nif_flexe_table_phy_info,
    dnx_data_nif_flexe_table_start_tx_threshold_table,
    dnx_data_nif_flexe_table_supported_pms,
    dnx_data_nif_flexe_table_l1_mismatch_rate_table,
    dnx_data_nif_flexe_table_sar_cell_mode_to_size,
    dnx_data_nif_flexe_table_sar_jitter_fifo_levels,

    /**
     * Must be last one!
     */
    _dnx_data_nif_flexe_table_nof
} dnx_data_nif_flexe_table_e;

/* Get Data */
/**
 * \brief get table phy_info entry 
 * The PHY info for flexe physical interface
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Entry Index
 * 
 * \return
 *     phy_info - returns the relevant entry values grouped in struct - see dnx_data_nif_flexe_phy_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_flexe_phy_info_t * dnx_data_nif_flexe_phy_info_get(
    int unit,
    int idx);

/**
 * \brief get table start_tx_threshold_table entry 
 * TX threshold table of values per speed
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Entry index
 * 
 * \return
 *     start_tx_threshold_table - returns the relevant entry values grouped in struct - see dnx_data_nif_flexe_start_tx_threshold_table_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_flexe_start_tx_threshold_table_t * dnx_data_nif_flexe_start_tx_threshold_table_get(
    int unit,
    int idx);

/**
 * \brief get table supported_pms entry 
 * Supported PMs for each FEU
 * 
 * \param [in] unit - unit #
 * \param [in] feu_idx - FEU index
 * 
 * \return
 *     supported_pms - returns the relevant entry values grouped in struct - see dnx_data_nif_flexe_supported_pms_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_flexe_supported_pms_t * dnx_data_nif_flexe_supported_pms_get(
    int unit,
    int feu_idx);

/**
 * \brief get table l1_mismatch_rate_table entry 
 * Info for L1 mismatch rate feature
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Entry index
 * 
 * \return
 *     l1_mismatch_rate_table - returns the relevant entry values grouped in struct - see dnx_data_nif_flexe_l1_mismatch_rate_table_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_flexe_l1_mismatch_rate_table_t * dnx_data_nif_flexe_l1_mismatch_rate_table_get(
    int unit,
    int idx);

/**
 * \brief get table sar_cell_mode_to_size entry 
 * Convert SAR cell mode to packet size
 * 
 * \param [in] unit - unit #
 * \param [in] cell_mode - SAR cell mode
 * 
 * \return
 *     sar_cell_mode_to_size - returns the relevant entry values grouped in struct - see dnx_data_nif_flexe_sar_cell_mode_to_size_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_flexe_sar_cell_mode_to_size_t * dnx_data_nif_flexe_sar_cell_mode_to_size_get(
    int unit,
    int cell_mode);

/**
 * \brief get table sar_jitter_fifo_levels entry 
 * The high and low fifo levels for each tolerance level
 * 
 * \param [in] unit - unit #
 * \param [in] tolerance_level - tolerance level
 * 
 * \return
 *     sar_jitter_fifo_levels - returns the relevant entry values grouped in struct - see dnx_data_nif_flexe_sar_jitter_fifo_levels_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_flexe_sar_jitter_fifo_levels_t * dnx_data_nif_flexe_sar_jitter_fifo_levels_get(
    int unit,
    int tolerance_level);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'flexe', table - 'phy_info'
 * The PHY info for flexe physical interface
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_flexe_phy_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'flexe', table - 'start_tx_threshold_table'
 * TX threshold table of values per speed
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_flexe_start_tx_threshold_table_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'flexe', table - 'supported_pms'
 * Supported PMs for each FEU
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_flexe_supported_pms_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'flexe', table - 'l1_mismatch_rate_table'
 * Info for L1 mismatch rate feature
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_flexe_l1_mismatch_rate_table_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'flexe', table - 'sar_cell_mode_to_size'
 * Convert SAR cell mode to packet size
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_flexe_sar_cell_mode_to_size_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'flexe', table - 'sar_jitter_fifo_levels'
 * The high and low fifo levels for each tolerance level
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_flexe_sar_jitter_fifo_levels_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)phy_info info
 * The PHY info for flexe physical interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_flexe_phy_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)start_tx_threshold_table info
 * TX threshold table of values per speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     start_tx_threshold_table - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_flexe_start_tx_threshold_table_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_pms info
 * Supported PMs for each FEU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_pms - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_flexe_supported_pms_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)l1_mismatch_rate_table info
 * Info for L1 mismatch rate feature
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l1_mismatch_rate_table - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_flexe_l1_mismatch_rate_table_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)sar_cell_mode_to_size info
 * Convert SAR cell mode to packet size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sar_cell_mode_to_size - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_flexe_sar_cell_mode_to_size_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)sar_jitter_fifo_levels info
 * The high and low fifo levels for each tolerance level
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sar_jitter_fifo_levels - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_flexe_sar_jitter_fifo_levels_info_get(
    int unit);

/*
 * SUBMODULE PRD:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_prd_feature_get(
    int unit,
    dnx_data_nif_prd_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_prd_define_nof_control_frames,
    dnx_data_nif_prd_define_nof_ether_type_codes,
    dnx_data_nif_prd_define_nof_tcam_entries,
    dnx_data_nif_prd_define_tcam_key_offset_size,
    dnx_data_nif_prd_define_nof_mpls_special_labels,
    dnx_data_nif_prd_define_nof_priorities,
    dnx_data_nif_prd_define_custom_ether_type_code_min,
    dnx_data_nif_prd_define_custom_ether_type_code_max,
    dnx_data_nif_prd_define_ether_type_code_max,
    dnx_data_nif_prd_define_ether_type_max,
    dnx_data_nif_prd_define_rmc_threshold_max,
    dnx_data_nif_prd_define_cdu_rmc_threshold_max,
    dnx_data_nif_prd_define_hrf_threshold_max,
    dnx_data_nif_prd_define_mpls_special_label_max,
    dnx_data_nif_prd_define_flex_key_offset_key_max,
    dnx_data_nif_prd_define_flex_key_offset_result_max,
    dnx_data_nif_prd_define_tpid_max,
    dnx_data_nif_prd_define_nof_clu_port_profiles,
    dnx_data_nif_prd_define_nof_feu_port_profiles,
    dnx_data_nif_prd_define_nof_ofr_port_profiles,
    dnx_data_nif_prd_define_rmc_fifo_2_threshold_resolution,
    dnx_data_nif_prd_define_nof_ofr_nif_interfaces,

    /**
     * Must be last one!
     */
    _dnx_data_nif_prd_define_nof
} dnx_data_nif_prd_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_control_frames
 * Module - 'nif', Submodule - 'prd', data - 'nof_control_frames'
 * Number of control frame properties to which each packet is compared in order to be recognized as control frame in the PRD parser
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_control_frames - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_control_frames_get(
    int unit);

/**
 * \brief returns define data of nof_ether_type_codes
 * Module - 'nif', Submodule - 'prd', data - 'nof_ether_type_codes'
 * Number of ether types supported by the PRD Parser
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ether_type_codes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_ether_type_codes_get(
    int unit);

/**
 * \brief returns define data of nof_tcam_entries
 * Module - 'nif', Submodule - 'prd', data - 'nof_tcam_entries'
 * Number of entries in PRD Parser soft stage TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_tcam_entries_get(
    int unit);

/**
 * \brief returns define data of tcam_key_offset_size
 * Module - 'nif', Submodule - 'prd', data - 'tcam_key_offset_size'
 * Size of offset in bits for tcam key segment
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_key_offset_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_tcam_key_offset_size_get(
    int unit);

/**
 * \brief returns define data of nof_mpls_special_labels
 * Module - 'nif', Submodule - 'prd', data - 'nof_mpls_special_labels'
 * Number of MPLS special labels recognized by the PRD parser
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mpls_special_labels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_mpls_special_labels_get(
    int unit);

/**
 * \brief returns define data of nof_priorities
 * Module - 'nif', Submodule - 'prd', data - 'nof_priorities'
 * Number of PRD Priorities
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_priorities - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_priorities_get(
    int unit);

/**
 * \brief returns define data of custom_ether_type_code_min
 * Module - 'nif', Submodule - 'prd', data - 'custom_ether_type_code_min'
 * Min value of the configurable ether type codes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     custom_ether_type_code_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_custom_ether_type_code_min_get(
    int unit);

/**
 * \brief returns define data of custom_ether_type_code_max
 * Module - 'nif', Submodule - 'prd', data - 'custom_ether_type_code_max'
 * Max value of the configurable ether type codes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     custom_ether_type_code_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_custom_ether_type_code_max_get(
    int unit);

/**
 * \brief returns define data of ether_type_code_max
 * Module - 'nif', Submodule - 'prd', data - 'ether_type_code_max'
 * Max value of the  ether type code
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ether_type_code_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_ether_type_code_max_get(
    int unit);

/**
 * \brief returns define data of ether_type_max
 * Module - 'nif', Submodule - 'prd', data - 'ether_type_max'
 * Max value of the  ether type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ether_type_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_ether_type_max_get(
    int unit);

/**
 * \brief returns define data of rmc_threshold_max
 * Module - 'nif', Submodule - 'prd', data - 'rmc_threshold_max'
 * Max value of the ingress port drop threshold for RMC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rmc_threshold_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_rmc_threshold_max_get(
    int unit);

/**
 * \brief returns define data of cdu_rmc_threshold_max
 * Module - 'nif', Submodule - 'prd', data - 'cdu_rmc_threshold_max'
 * Max value of the ingress CDU port drop threshold for RMC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_rmc_threshold_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_cdu_rmc_threshold_max_get(
    int unit);

/**
 * \brief returns define data of hrf_threshold_max
 * Module - 'nif', Submodule - 'prd', data - 'hrf_threshold_max'
 * Max value of the ingress port drop threshold for HRF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hrf_threshold_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_hrf_threshold_max_get(
    int unit);

/**
 * \brief returns define data of mpls_special_label_max
 * Module - 'nif', Submodule - 'prd', data - 'mpls_special_label_max'
 * Max value of the  MPLS special label
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mpls_special_label_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_mpls_special_label_max_get(
    int unit);

/**
 * \brief returns define data of flex_key_offset_key_max
 * Module - 'nif', Submodule - 'prd', data - 'flex_key_offset_key_max'
 * Max value of the  FLEX Key offset key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_key_offset_key_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_flex_key_offset_key_max_get(
    int unit);

/**
 * \brief returns define data of flex_key_offset_result_max
 * Module - 'nif', Submodule - 'prd', data - 'flex_key_offset_result_max'
 * Max value of the  FLEX Key offset result
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_key_offset_result_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_flex_key_offset_result_max_get(
    int unit);

/**
 * \brief returns define data of tpid_max
 * Module - 'nif', Submodule - 'prd', data - 'tpid_max'
 * Max value of the  tpid
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tpid_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_tpid_max_get(
    int unit);

/**
 * \brief returns define data of nof_clu_port_profiles
 * Module - 'nif', Submodule - 'prd', data - 'nof_clu_port_profiles'
 * Number of prd porfiles per CLU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_clu_port_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_clu_port_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_feu_port_profiles
 * Module - 'nif', Submodule - 'prd', data - 'nof_feu_port_profiles'
 * Number of prd porfiles per FEU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_feu_port_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_feu_port_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_ofr_port_profiles
 * Module - 'nif', Submodule - 'prd', data - 'nof_ofr_port_profiles'
 * Number of prd porfiles per OFR
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ofr_port_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_ofr_port_profiles_get(
    int unit);

/**
 * \brief returns define data of rmc_fifo_2_threshold_resolution
 * Module - 'nif', Submodule - 'prd', data - 'rmc_fifo_2_threshold_resolution'
 * The resolution between rmc FIFO size and PRD threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rmc_fifo_2_threshold_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_rmc_fifo_2_threshold_resolution_get(
    int unit);

/**
 * \brief returns define data of nof_ofr_nif_interfaces
 * Module - 'nif', Submodule - 'prd', data - 'nof_ofr_nif_interfaces'
 * Number of PRD NIF interfaces in OFR
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ofr_nif_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_prd_nof_ofr_nif_interfaces_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_nif_prd_table_ether_type,
    dnx_data_nif_prd_table_port_profile_map,

    /**
     * Must be last one!
     */
    _dnx_data_nif_prd_table_nof
} dnx_data_nif_prd_table_e;

/* Get Data */
/**
 * \brief get table ether_type entry 
 * Ether type codes and sizes for fixed ether types.
 * 
 * \param [in] unit - unit #
 * \param [in] ether_type_code - Ether type code in PRD parser
 * 
 * \return
 *     ether_type - returns the relevant entry values grouped in struct - see dnx_data_nif_prd_ether_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_prd_ether_type_t * dnx_data_nif_prd_ether_type_get(
    int unit,
    int ether_type_code);

/**
 * \brief get table port_profile_map entry 
 * Prd profiles information per IMB type
 * 
 * \param [in] unit - unit #
 * \param [in] type - IMB type
 * 
 * \return
 *     port_profile_map - returns the relevant entry values grouped in struct - see dnx_data_nif_prd_port_profile_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_prd_port_profile_map_t * dnx_data_nif_prd_port_profile_map_get(
    int unit,
    int type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'prd', table - 'ether_type'
 * Ether type codes and sizes for fixed ether types.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_prd_ether_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'prd', table - 'port_profile_map'
 * Prd profiles information per IMB type
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_prd_port_profile_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)ether_type info
 * Ether type codes and sizes for fixed ether types.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ether_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_prd_ether_type_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)port_profile_map info
 * Prd profiles information per IMB type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_profile_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_prd_port_profile_map_info_get(
    int unit);

/*
 * SUBMODULE PORTMOD:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_portmod_feature_get(
    int unit,
    dnx_data_nif_portmod_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_portmod_define_pm_types_nof,

    /**
     * Must be last one!
     */
    _dnx_data_nif_portmod_define_nof
} dnx_data_nif_portmod_define_e;

/* Get Data */
/**
 * \brief returns define data of pm_types_nof
 * Module - 'nif', Submodule - 'portmod', data - 'pm_types_nof'
 * Number of pm types
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pm_types_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_portmod_pm_types_nof_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_nif_portmod_table_pm_types_and_interfaces,

    /**
     * Must be last one!
     */
    _dnx_data_nif_portmod_table_nof
} dnx_data_nif_portmod_table_e;

/* Get Data */
/**
 * \brief get table pm_types_and_interfaces entry 
 * fixed types and interfaces per device
 * 
 * \param [in] unit - unit #
 * \param [in] index - pm type index
 * 
 * \return
 *     pm_types_and_interfaces - returns the relevant entry values grouped in struct - see dnx_data_nif_portmod_pm_types_and_interfaces_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_nif_portmod_pm_types_and_interfaces_t * dnx_data_nif_portmod_pm_types_and_interfaces_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'nif', Submodule - 'portmod', table - 'pm_types_and_interfaces'
 * fixed types and interfaces per device
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_portmod_pm_types_and_interfaces_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)pm_types_and_interfaces info
 * fixed types and interfaces per device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pm_types_and_interfaces - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_nif_portmod_pm_types_and_interfaces_info_get(
    int unit);

/*
 * SUBMODULE SCHEDULER:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_scheduler_feature_get(
    int unit,
    dnx_data_nif_scheduler_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_scheduler_define_rate_per_ethu_bit,
    dnx_data_nif_scheduler_define_rate_per_ilu_bit,
    dnx_data_nif_scheduler_define_rate_per_cdu_rmc_bit,
    dnx_data_nif_scheduler_define_rate_per_clu_rmc_bit,
    dnx_data_nif_scheduler_define_nof_weight_bits,
    dnx_data_nif_scheduler_define_nof_rmc_bits,

    /**
     * Must be last one!
     */
    _dnx_data_nif_scheduler_define_nof
} dnx_data_nif_scheduler_define_e;

/* Get Data */
/**
 * \brief returns define data of rate_per_ethu_bit
 * Module - 'nif', Submodule - 'scheduler', data - 'rate_per_ethu_bit'
 * The Rate equivalent to 1 weight bit of ETHU scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate_per_ethu_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_scheduler_rate_per_ethu_bit_get(
    int unit);

/**
 * \brief returns define data of rate_per_ilu_bit
 * Module - 'nif', Submodule - 'scheduler', data - 'rate_per_ilu_bit'
 * The Rate equivalent to 1 weight bit of ILU scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate_per_ilu_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_scheduler_rate_per_ilu_bit_get(
    int unit);

/**
 * \brief returns define data of rate_per_cdu_rmc_bit
 * Module - 'nif', Submodule - 'scheduler', data - 'rate_per_cdu_rmc_bit'
 * The Rate equivalent to 1 bit of CDU RMC scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate_per_cdu_rmc_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_scheduler_rate_per_cdu_rmc_bit_get(
    int unit);

/**
 * \brief returns define data of rate_per_clu_rmc_bit
 * Module - 'nif', Submodule - 'scheduler', data - 'rate_per_clu_rmc_bit'
 * The Rate equivalent to 1 bit of CLU RMC scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate_per_clu_rmc_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_scheduler_rate_per_clu_rmc_bit_get(
    int unit);

/**
 * \brief returns define data of nof_weight_bits
 * Module - 'nif', Submodule - 'scheduler', data - 'nof_weight_bits'
 * Number of weight bits in UNIT scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_weight_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_scheduler_nof_weight_bits_get(
    int unit);

/**
 * \brief returns define data of nof_rmc_bits
 * Module - 'nif', Submodule - 'scheduler', data - 'nof_rmc_bits'
 * Number of bits in RMC scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rmc_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_scheduler_nof_rmc_bits_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_scheduler_table_nof
} dnx_data_nif_scheduler_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DBAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_dbal_feature_get(
    int unit,
    dnx_data_nif_dbal_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_dbal_define_cdu_rx_rmc_entry_size,
    dnx_data_nif_dbal_define_clu_rx_rmc_entry_size,
    dnx_data_nif_dbal_define_cdu_tx_start_threshold_entry_size,
    dnx_data_nif_dbal_define_clu_tx_start_threshold_entry_size,
    dnx_data_nif_dbal_define_ilu_burst_min_entry_size,
    dnx_data_nif_dbal_define_ethu_rx_rmc_counter_entry_size,
    dnx_data_nif_dbal_define_cdu_lane_fifo_level_and_occupancy_entry_size,
    dnx_data_nif_dbal_define_clu_lane_fifo_level_and_occupancy_entry_size,
    dnx_data_nif_dbal_define_sch_cnt_dec_threshold_bit_size,
    dnx_data_nif_dbal_define_tx_credits_bits,

    /**
     * Must be last one!
     */
    _dnx_data_nif_dbal_define_nof
} dnx_data_nif_dbal_define_e;

/* Get Data */
/**
 * \brief returns define data of cdu_rx_rmc_entry_size
 * Module - 'nif', Submodule - 'dbal', data - 'cdu_rx_rmc_entry_size'
 * size of the cdu rmc fifo entry size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_rx_rmc_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_cdu_rx_rmc_entry_size_get(
    int unit);

/**
 * \brief returns define data of clu_rx_rmc_entry_size
 * Module - 'nif', Submodule - 'dbal', data - 'clu_rx_rmc_entry_size'
 * size of the clu rmc fifo entry size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     clu_rx_rmc_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_clu_rx_rmc_entry_size_get(
    int unit);

/**
 * \brief returns define data of cdu_tx_start_threshold_entry_size
 * Module - 'nif', Submodule - 'dbal', data - 'cdu_tx_start_threshold_entry_size'
 * size of the cdu tx start threshold entry size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_tx_start_threshold_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_cdu_tx_start_threshold_entry_size_get(
    int unit);

/**
 * \brief returns define data of clu_tx_start_threshold_entry_size
 * Module - 'nif', Submodule - 'dbal', data - 'clu_tx_start_threshold_entry_size'
 * size of the clu tx start threshold entry size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     clu_tx_start_threshold_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_clu_tx_start_threshold_entry_size_get(
    int unit);

/**
 * \brief returns define data of ilu_burst_min_entry_size
 * Module - 'nif', Submodule - 'dbal', data - 'ilu_burst_min_entry_size'
 * size of the ilu burst min entry size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilu_burst_min_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_ilu_burst_min_entry_size_get(
    int unit);

/**
 * \brief returns define data of ethu_rx_rmc_counter_entry_size
 * Module - 'nif', Submodule - 'dbal', data - 'ethu_rx_rmc_counter_entry_size'
 * ethu rx rmc counter entry size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ethu_rx_rmc_counter_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_ethu_rx_rmc_counter_entry_size_get(
    int unit);

/**
 * \brief returns define data of cdu_lane_fifo_level_and_occupancy_entry_size
 * Module - 'nif', Submodule - 'dbal', data - 'cdu_lane_fifo_level_and_occupancy_entry_size'
 * cdu nif status fifo level and occupancy entry size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_lane_fifo_level_and_occupancy_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_cdu_lane_fifo_level_and_occupancy_entry_size_get(
    int unit);

/**
 * \brief returns define data of clu_lane_fifo_level_and_occupancy_entry_size
 * Module - 'nif', Submodule - 'dbal', data - 'clu_lane_fifo_level_and_occupancy_entry_size'
 * clu nif status fifo level and occupancy entry size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     clu_lane_fifo_level_and_occupancy_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_clu_lane_fifo_level_and_occupancy_entry_size_get(
    int unit);

/**
 * \brief returns define data of sch_cnt_dec_threshold_bit_size
 * Module - 'nif', Submodule - 'dbal', data - 'sch_cnt_dec_threshold_bit_size'
 * nof bits in SCH_CNT_DEC_THRESHOLD field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sch_cnt_dec_threshold_bit_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_sch_cnt_dec_threshold_bit_size_get(
    int unit);

/**
 * \brief returns define data of tx_credits_bits
 * Module - 'nif', Submodule - 'dbal', data - 'tx_credits_bits'
 * nof bits in TX credit value field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_credits_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_dbal_tx_credits_bits_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_dbal_table_nof
} dnx_data_nif_dbal_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FEATURES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_features_feature_get(
    int unit,
    dnx_data_nif_features_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_features_define_nof
} dnx_data_nif_features_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_features_table_nof
} dnx_data_nif_features_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ARB:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_arb_feature_get(
    int unit,
    dnx_data_nif_arb_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_arb_define_nof_contexts,
    dnx_data_nif_arb_define_nof_rx_qpms,
    dnx_data_nif_arb_define_nof_rx_ppms_in_qpm,
    dnx_data_nif_arb_define_nof_lanes_in_qpm,
    dnx_data_nif_arb_define_nof_map_destinations,
    dnx_data_nif_arb_define_max_calendar_length,
    dnx_data_nif_arb_define_nof_rx_sources,
    dnx_data_nif_arb_define_rx_sch_calendar_nof_modes,
    dnx_data_nif_arb_define_rx_qpm_calendar_length,
    dnx_data_nif_arb_define_rx_sch_calendar_length,
    dnx_data_nif_arb_define_cdpm_calendar_length,
    dnx_data_nif_arb_define_tmac_calendar_length,
    dnx_data_nif_arb_define_rx_qpm_calendar_nof_clients,
    dnx_data_nif_arb_define_rx_sch_calendar_nof_clients,
    dnx_data_nif_arb_define_rx_qpm_port_speed_granularity,
    dnx_data_nif_arb_define_rx_sch_port_speed_granularity,
    dnx_data_nif_arb_define_tx_eth_port_speed_granularity,
    dnx_data_nif_arb_define_tx_tmac_port_speed_granularity,
    dnx_data_nif_arb_define_tx_tmac_nof_sections,
    dnx_data_nif_arb_define_tx_tmac_link_list_speed_granularity,
    dnx_data_nif_arb_define_nof_entries_in_memory_row_for_rx_calendar,
    dnx_data_nif_arb_define_nof_bit_per_entry_in_rx_calendar,
    dnx_data_nif_arb_define_nof_entries_in_tmac_calendar,
    dnx_data_nif_arb_define_nof_bit_per_entry_in_tmac_calendar,
    dnx_data_nif_arb_define_nof_bit_per_entry_in_ppm_calendar,
    dnx_data_nif_arb_define_min_port_speed_for_link_list_section,
    dnx_data_nif_arb_define_link_list_sections_denominator,

    /**
     * Must be last one!
     */
    _dnx_data_nif_arb_define_nof
} dnx_data_nif_arb_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_contexts
 * Module - 'nif', Submodule - 'arb', data - 'nof_contexts'
 * Number of arbiter contexts (Eth+Framer)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_rx_qpms
 * Module - 'nif', Submodule - 'arb', data - 'nof_rx_qpms'
 * Number of rx qpms
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rx_qpms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_rx_qpms_get(
    int unit);

/**
 * \brief returns define data of nof_rx_ppms_in_qpm
 * Module - 'nif', Submodule - 'arb', data - 'nof_rx_ppms_in_qpm'
 * Number of ppms in qpm
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rx_ppms_in_qpm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_rx_ppms_in_qpm_get(
    int unit);

/**
 * \brief returns define data of nof_lanes_in_qpm
 * Module - 'nif', Submodule - 'arb', data - 'nof_lanes_in_qpm'
 * Number of lanes in qpm
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lanes_in_qpm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_lanes_in_qpm_get(
    int unit);

/**
 * \brief returns define data of nof_map_destinations
 * Module - 'nif', Submodule - 'arb', data - 'nof_map_destinations'
 * Number of map destinations (MacSec0, MacSec1 or Bypass)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_map_destinations - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_map_destinations_get(
    int unit);

/**
 * \brief returns define data of max_calendar_length
 * Module - 'nif', Submodule - 'arb', data - 'max_calendar_length'
 * Maximum length of calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_calendar_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_max_calendar_length_get(
    int unit);

/**
 * \brief returns define data of nof_rx_sources
 * Module - 'nif', Submodule - 'arb', data - 'nof_rx_sources'
 * Nof rx sources
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rx_sources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_rx_sources_get(
    int unit);

/**
 * \brief returns define data of rx_sch_calendar_nof_modes
 * Module - 'nif', Submodule - 'arb', data - 'rx_sch_calendar_nof_modes'
 * Nof rx scheduler modes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_sch_calendar_nof_modes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_rx_sch_calendar_nof_modes_get(
    int unit);

/**
 * \brief returns define data of rx_qpm_calendar_length
 * Module - 'nif', Submodule - 'arb', data - 'rx_qpm_calendar_length'
 * Length of qpm calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_qpm_calendar_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_rx_qpm_calendar_length_get(
    int unit);

/**
 * \brief returns define data of rx_sch_calendar_length
 * Module - 'nif', Submodule - 'arb', data - 'rx_sch_calendar_length'
 * Length of scheduler calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_sch_calendar_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_rx_sch_calendar_length_get(
    int unit);

/**
 * \brief returns define data of cdpm_calendar_length
 * Module - 'nif', Submodule - 'arb', data - 'cdpm_calendar_length'
 * Length of CDPM calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdpm_calendar_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_cdpm_calendar_length_get(
    int unit);

/**
 * \brief returns define data of tmac_calendar_length
 * Module - 'nif', Submodule - 'arb', data - 'tmac_calendar_length'
 * Length of TMAC calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tmac_calendar_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_tmac_calendar_length_get(
    int unit);

/**
 * \brief returns define data of rx_qpm_calendar_nof_clients
 * Module - 'nif', Submodule - 'arb', data - 'rx_qpm_calendar_nof_clients'
 * Number of clients in qpm calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_qpm_calendar_nof_clients - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_rx_qpm_calendar_nof_clients_get(
    int unit);

/**
 * \brief returns define data of rx_sch_calendar_nof_clients
 * Module - 'nif', Submodule - 'arb', data - 'rx_sch_calendar_nof_clients'
 * Number of clients in scheduler calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_sch_calendar_nof_clients - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_rx_sch_calendar_nof_clients_get(
    int unit);

/**
 * \brief returns define data of rx_qpm_port_speed_granularity
 * Module - 'nif', Submodule - 'arb', data - 'rx_qpm_port_speed_granularity'
 * Granularity of qpm port speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_qpm_port_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_rx_qpm_port_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of rx_sch_port_speed_granularity
 * Module - 'nif', Submodule - 'arb', data - 'rx_sch_port_speed_granularity'
 * Granularity of scheduler port speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_sch_port_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_rx_sch_port_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of tx_eth_port_speed_granularity
 * Module - 'nif', Submodule - 'arb', data - 'tx_eth_port_speed_granularity'
 * Granularity of eth port speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_eth_port_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_tx_eth_port_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of tx_tmac_port_speed_granularity
 * Module - 'nif', Submodule - 'arb', data - 'tx_tmac_port_speed_granularity'
 * Granularity of tmac port speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_tmac_port_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_tx_tmac_port_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of tx_tmac_nof_sections
 * Module - 'nif', Submodule - 'arb', data - 'tx_tmac_nof_sections'
 * Number of TMAC list sections
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_tmac_nof_sections - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_tx_tmac_nof_sections_get(
    int unit);

/**
 * \brief returns define data of tx_tmac_link_list_speed_granularity
 * Module - 'nif', Submodule - 'arb', data - 'tx_tmac_link_list_speed_granularity'
 * Granularity of TMAC link list speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_tmac_link_list_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_tx_tmac_link_list_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of nof_entries_in_memory_row_for_rx_calendar
 * Module - 'nif', Submodule - 'arb', data - 'nof_entries_in_memory_row_for_rx_calendar'
 * nof_entries_in_rx_cal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_in_memory_row_for_rx_calendar - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_entries_in_memory_row_for_rx_calendar_get(
    int unit);

/**
 * \brief returns define data of nof_bit_per_entry_in_rx_calendar
 * Module - 'nif', Submodule - 'arb', data - 'nof_bit_per_entry_in_rx_calendar'
 * nof_bit_per_entry_in_rx_calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bit_per_entry_in_rx_calendar - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_bit_per_entry_in_rx_calendar_get(
    int unit);

/**
 * \brief returns define data of nof_entries_in_tmac_calendar
 * Module - 'nif', Submodule - 'arb', data - 'nof_entries_in_tmac_calendar'
 * nof_entries_in_tmac_cal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_in_tmac_calendar - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_entries_in_tmac_calendar_get(
    int unit);

/**
 * \brief returns define data of nof_bit_per_entry_in_tmac_calendar
 * Module - 'nif', Submodule - 'arb', data - 'nof_bit_per_entry_in_tmac_calendar'
 * nof_bit_per_entry_in_tmac_calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bit_per_entry_in_tmac_calendar - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_bit_per_entry_in_tmac_calendar_get(
    int unit);

/**
 * \brief returns define data of nof_bit_per_entry_in_ppm_calendar
 * Module - 'nif', Submodule - 'arb', data - 'nof_bit_per_entry_in_ppm_calendar'
 * nof_bit_per_entry_in_ppm_calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bit_per_entry_in_ppm_calendar - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_nof_bit_per_entry_in_ppm_calendar_get(
    int unit);

/**
 * \brief returns define data of min_port_speed_for_link_list_section
 * Module - 'nif', Submodule - 'arb', data - 'min_port_speed_for_link_list_section'
 * minimal speed for allocating link list section
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_port_speed_for_link_list_section - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_min_port_speed_for_link_list_section_get(
    int unit);

/**
 * \brief returns define data of link_list_sections_denominator
 * Module - 'nif', Submodule - 'arb', data - 'link_list_sections_denominator'
 * denominator for calculating link list nof_sections
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     link_list_sections_denominator - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_arb_link_list_sections_denominator_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_arb_table_nof
} dnx_data_nif_arb_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE OFR:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_ofr_feature_get(
    int unit,
    dnx_data_nif_ofr_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_ofr_define_nof_contexts,
    dnx_data_nif_ofr_define_nof_rmc_per_priority_group,
    dnx_data_nif_ofr_define_nof_total_rmcs,
    dnx_data_nif_ofr_define_nof_rx_mem_sections_per_group,
    dnx_data_nif_ofr_define_nof_rx_memory_groups,
    dnx_data_nif_ofr_define_nof_rx_memory_sections,
    dnx_data_nif_ofr_define_nof_rx_memory_entries_per_section,
    dnx_data_nif_ofr_define_rx_memory_link_list_speed_granularity,
    dnx_data_nif_ofr_define_rx_sch_granularity,

    /**
     * Must be last one!
     */
    _dnx_data_nif_ofr_define_nof
} dnx_data_nif_ofr_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_contexts
 * Module - 'nif', Submodule - 'ofr', data - 'nof_contexts'
 * Number of OFR contexts (Eth+Framer)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_rmc_per_priority_group
 * Module - 'nif', Submodule - 'ofr', data - 'nof_rmc_per_priority_group'
 * Number of RMCs per priority group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rmc_per_priority_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_nof_rmc_per_priority_group_get(
    int unit);

/**
 * \brief returns define data of nof_total_rmcs
 * Module - 'nif', Submodule - 'ofr', data - 'nof_total_rmcs'
 * total Number of RMCs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_total_rmcs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_nof_total_rmcs_get(
    int unit);

/**
 * \brief returns define data of nof_rx_mem_sections_per_group
 * Module - 'nif', Submodule - 'ofr', data - 'nof_rx_mem_sections_per_group'
 * Number of RX memory sections per group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rx_mem_sections_per_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_nof_rx_mem_sections_per_group_get(
    int unit);

/**
 * \brief returns define data of nof_rx_memory_groups
 * Module - 'nif', Submodule - 'ofr', data - 'nof_rx_memory_groups'
 * Number of RX memory groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rx_memory_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_nof_rx_memory_groups_get(
    int unit);

/**
 * \brief returns define data of nof_rx_memory_sections
 * Module - 'nif', Submodule - 'ofr', data - 'nof_rx_memory_sections'
 * Number of RX memory sections
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rx_memory_sections - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_nof_rx_memory_sections_get(
    int unit);

/**
 * \brief returns define data of nof_rx_memory_entries_per_section
 * Module - 'nif', Submodule - 'ofr', data - 'nof_rx_memory_entries_per_section'
 * Number of RX memory entries per section
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rx_memory_entries_per_section - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_nof_rx_memory_entries_per_section_get(
    int unit);

/**
 * \brief returns define data of rx_memory_link_list_speed_granularity
 * Module - 'nif', Submodule - 'ofr', data - 'rx_memory_link_list_speed_granularity'
 * RX memory Link list speed granularty
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_memory_link_list_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_rx_memory_link_list_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of rx_sch_granularity
 * Module - 'nif', Submodule - 'ofr', data - 'rx_sch_granularity'
 * RX schedhuler speed granularity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_sch_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_ofr_rx_sch_granularity_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_ofr_table_nof
} dnx_data_nif_ofr_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE OFT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_nif_oft_feature_get(
    int unit,
    dnx_data_nif_oft_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_nif_oft_define_calendar_length,
    dnx_data_nif_oft_define_nof_sections,
    dnx_data_nif_oft_define_nof_internal_calendar_entries,
    dnx_data_nif_oft_define_nof_bit_per_internal_entry_in_calendar,
    dnx_data_nif_oft_define_nof_contexts,
    dnx_data_nif_oft_define_port_speed_granularity,
    dnx_data_nif_oft_define_calendar_speed_granularity,

    /**
     * Must be last one!
     */
    _dnx_data_nif_oft_define_nof
} dnx_data_nif_oft_define_e;

/* Get Data */
/**
 * \brief returns define data of calendar_length
 * Module - 'nif', Submodule - 'oft', data - 'calendar_length'
 * Length of OFT calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     calendar_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_oft_calendar_length_get(
    int unit);

/**
 * \brief returns define data of nof_sections
 * Module - 'nif', Submodule - 'oft', data - 'nof_sections'
 * Number of OFT list sections
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_sections - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_oft_nof_sections_get(
    int unit);

/**
 * \brief returns define data of nof_internal_calendar_entries
 * Module - 'nif', Submodule - 'oft', data - 'nof_internal_calendar_entries'
 * Number of internal entries in oft calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_internal_calendar_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_oft_nof_internal_calendar_entries_get(
    int unit);

/**
 * \brief returns define data of nof_bit_per_internal_entry_in_calendar
 * Module - 'nif', Submodule - 'oft', data - 'nof_bit_per_internal_entry_in_calendar'
 * Number of bit in internal entry in oft calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bit_per_internal_entry_in_calendar - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_oft_nof_bit_per_internal_entry_in_calendar_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'nif', Submodule - 'oft', data - 'nof_contexts'
 * Number of OFR contexts (Eth+Framer)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_oft_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of port_speed_granularity
 * Module - 'nif', Submodule - 'oft', data - 'port_speed_granularity'
 * Granularity of OFT port speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_oft_port_speed_granularity_get(
    int unit);

/**
 * \brief returns define data of calendar_speed_granularity
 * Module - 'nif', Submodule - 'oft', data - 'calendar_speed_granularity'
 * Granularity of OFT calendar entry speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     calendar_speed_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_nif_oft_calendar_speed_granularity_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_oft_table_nof
} dnx_data_nif_oft_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_nif_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_NIF_H_*/
/* *INDENT-ON* */
