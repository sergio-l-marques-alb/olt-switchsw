/** \file dnx_data_l2.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_L2_H_
/*{*/
#define _DNX_DATA_L2_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_tables.h>
#include <bcm_int/dnx/l2/l2_addr.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_result_types.h>
#include <bcm/l2.h>
#include <soc/dnx/dbal/dbal_external_defines.h>
#include <bcm_int/dnx/l2/l2.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_l2.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_l2
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_l2_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL:
 * General L2 properties
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule general table mact_result_type_map
 * Table info:
 * This table maps MACT result types for each table
 */
typedef struct
{
    uint32 dest_lif_stat;
    uint32 dest_stat;
    uint32 double_outlif;
    uint32 eei;
    uint32 no_outlif;
    uint32 single_outlif;
} dnx_data_l2_general_mact_result_type_map_t;

/**
 * \brief Holds values of submodule general table scan_data_bases_info
 * Table info:
 * Age scan, and scan cycles lem data bases
 */
typedef struct
{
    /**
     * age scan data bases
     */
    dbal_tables_e age_scan;
    /**
     * scan cycles data bases
     */
    dbal_tables_e scan_cycles;
} dnx_data_l2_general_scan_data_bases_info_t;

/**
 * \brief Holds values of submodule general table fwd_mact_info
 * Table info:
 * fwd mact info
 */
typedef struct
{
    /**
     * Holds the dbal logical table id
     */
    dbal_tables_e logical_data_base;
    /**
     * Holds the dbal physical table id
     */
    dbal_physical_tables_e physical_data_base;
} dnx_data_l2_general_fwd_mact_info_t;

/**
 * \brief Holds values of submodule general table lem_table_map_l2_action
 * Table info:
 * Mapping from logical dbal table to L2 action
 */
typedef struct
{
    /**
     * The action type of the MACT according to the enum dnx_l2_action_type_t
     */
    dnx_l2_action_type_t l2_action_type;
} dnx_data_l2_general_lem_table_map_l2_action_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * If set, learn events to MACT will be generated with INSERT command
     */
    dnx_data_l2_general_learning_use_insert_cmd,
    /**
     * Indicate if flush machine is supported
     */
    dnx_data_l2_general_flush_machine_support,
    /**
     * Indicate if iterating over dynamic entries is supported
     */
    dnx_data_l2_general_dynamic_entries_iteration_support,
    /**
     * Indicate if l2 counters are supported
     */
    dnx_data_l2_general_counters_support,
    /**
     * Indicate if aging of l2 entries is supported
     */
    dnx_data_l2_general_aging_support,
    dnx_data_l2_general_transplant_over_stronger_support,
    /**
     * IVL is not supported due to VTT1 No PEM resource
     */
    dnx_data_l2_general_ivl_feature_support,
    /**
     * Indicates if DMA is supported
     */
    dnx_data_l2_general_dma_support,
    /**
     * The farwarding MACT and learning MACT are separated
     */
    dnx_data_l2_general_separate_fwd_learn_mact,
    /**
     * support Elastic-State Load Balancer
     */
    dnx_data_l2_general_SLLB_v1_support,
    /**
     * support enhancement of learn key generation
     */
    dnx_data_l2_general_enhanced_learn_key_generation,

    /**
     * Must be last one!
     */
    _dnx_data_l2_general_feature_nof
} dnx_data_l2_general_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_general_feature_get_f) (
    int unit,
    dnx_data_l2_general_feature_e feature);

/**
 * \brief returns define data of vsi_offset_shift
 * Module - 'l2', Submodule - 'general', data - 'vsi_offset_shift'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsi_offset_shift - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_vsi_offset_shift_get_f) (
    int unit);

/**
 * \brief returns define data of lif_offset_shift
 * Module - 'l2', Submodule - 'general', data - 'lif_offset_shift'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lif_offset_shift - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_lif_offset_shift_get_f) (
    int unit);

/**
 * \brief returns define data of lem_nof_dbs
 * Module - 'l2', Submodule - 'general', data - 'lem_nof_dbs'
 * The number of lem DBs used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lem_nof_dbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_lem_nof_dbs_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_learn_limit_mode
 * Module - 'l2', Submodule - 'general', data - 'l2_learn_limit_mode'
 * MACT learning limit mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_learn_limit_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_learn_limit_mode_get_f) (
    int unit);

/**
 * \brief returns numeric data of jr_mode_nof_fec_bits
 * Module - 'l2', Submodule - 'general', data - 'jr_mode_nof_fec_bits'
 * NOF FEC bits in Jericho DSP learning message
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     jr_mode_nof_fec_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_jr_mode_nof_fec_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of arad_plus_mode_nof_fec_bits
 * Module - 'l2', Submodule - 'general', data - 'arad_plus_mode_nof_fec_bits'
 * NOF FEC bits in Arad+ DSP learning message
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     arad_plus_mode_nof_fec_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_arad_plus_mode_nof_fec_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_egress_max_extention_size_bytes
 * Module - 'l2', Submodule - 'general', data - 'l2_egress_max_extention_size_bytes'
 * Maximum size in bytes of RCH extensiuon. The limit comes from parser limitations
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_egress_max_extention_size_bytes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_egress_max_extention_size_bytes_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_egress_max_additional_termination_size_bytes
 * Module - 'l2', Submodule - 'general', data - 'l2_egress_max_additional_termination_size_bytes'
 * Maximum size in bytes of additional termination on Egress to Parsing Start Offset
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_egress_max_additional_termination_size_bytes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_egress_max_additional_termination_size_bytes_get_f) (
    int unit);

/**
 * \brief returns numeric data of mact_mngmnt_fid_exceed_limit_int
 * Module - 'l2', Submodule - 'general', data - 'mact_mngmnt_fid_exceed_limit_int'
 * mact management fid exceed limit interrupt
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_mngmnt_fid_exceed_limit_int - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_mact_mngmnt_fid_exceed_limit_int_get_f) (
    int unit);

/**
 * \brief returns numeric data of mact_lela_fid_exceed_limit_int
 * Module - 'l2', Submodule - 'general', data - 'mact_lela_fid_exceed_limit_int'
 * mact lela fid exceed limit interrupt
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_lela_fid_exceed_limit_int - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_mact_lela_fid_exceed_limit_int_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_api_supported_flags2
 * Module - 'l2', Submodule - 'general', data - 'l2_api_supported_flags2'
 * Supported L2 API flags2.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_api_supported_flags2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_api_supported_flags2_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_traverse_api_supported_flags
 * Module - 'l2', Submodule - 'general', data - 'l2_traverse_api_supported_flags'
 * Supported L2 traverse API flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_traverse_api_supported_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_traverse_api_supported_flags_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_delete_api_supported_flags
 * Module - 'l2', Submodule - 'general', data - 'l2_delete_api_supported_flags'
 * Supported L2 delete API flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_delete_api_supported_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_delete_api_supported_flags_get_f) (
    int unit);

/**
 * \brief get table mact_result_type_map entry 
 * This table maps MACT result types for each table
 * 
 * \param [in] unit - unit #
 * \param [in] forward_learning_db - 
 * \param [in] vlan_learning_mode - 
 * 
 * \return
 *     mact_result_type_map - returns the relevant entry values grouped in struct - see dnx_data_l2_general_mact_result_type_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_general_mact_result_type_map_t *(
    *dnx_data_l2_general_mact_result_type_map_get_f) (
    int unit,
    int forward_learning_db,
    int vlan_learning_mode);

/**
 * \brief get table scan_data_bases_info entry 
 * Age scan, and scan cycles lem data bases
 * 
 * \param [in] unit - unit #
 * \param [in] data_base - 
 * 
 * \return
 *     scan_data_bases_info - returns the relevant entry values grouped in struct - see dnx_data_l2_general_scan_data_bases_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_general_scan_data_bases_info_t *(
    *dnx_data_l2_general_scan_data_bases_info_get_f) (
    int unit,
    int data_base);

/**
 * \brief get table fwd_mact_info entry 
 * fwd mact info
 * 
 * \param [in] unit - unit #
 * \param [in] l2_action_type - 
 * \param [in] is_ivl - 
 * 
 * \return
 *     fwd_mact_info - returns the relevant entry values grouped in struct - see dnx_data_l2_general_fwd_mact_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_general_fwd_mact_info_t *(
    *dnx_data_l2_general_fwd_mact_info_get_f) (
    int unit,
    int l2_action_type,
    int is_ivl);

/**
 * \brief get table lem_table_map_l2_action entry 
 * Mapping from logical dbal table to L2 action
 * 
 * \param [in] unit - unit #
 * \param [in] logical_data_base - 
 * 
 * \return
 *     lem_table_map_l2_action - returns the relevant entry values grouped in struct - see dnx_data_l2_general_lem_table_map_l2_action_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_general_lem_table_map_l2_action_t *(
    *dnx_data_l2_general_lem_table_map_l2_action_get_f) (
    int unit,
    int logical_data_base);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - GENERAL:
 * {
 */
/**
 * \brief Interface for l2 general data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_general_feature_get_f feature_get;
    /**
     * returns define data of vsi_offset_shift
     */
    dnx_data_l2_general_vsi_offset_shift_get_f vsi_offset_shift_get;
    /**
     * returns define data of lif_offset_shift
     */
    dnx_data_l2_general_lif_offset_shift_get_f lif_offset_shift_get;
    /**
     * returns define data of lem_nof_dbs
     */
    dnx_data_l2_general_lem_nof_dbs_get_f lem_nof_dbs_get;
    /**
     * returns numeric data of l2_learn_limit_mode
     */
    dnx_data_l2_general_l2_learn_limit_mode_get_f l2_learn_limit_mode_get;
    /**
     * returns numeric data of jr_mode_nof_fec_bits
     */
    dnx_data_l2_general_jr_mode_nof_fec_bits_get_f jr_mode_nof_fec_bits_get;
    /**
     * returns numeric data of arad_plus_mode_nof_fec_bits
     */
    dnx_data_l2_general_arad_plus_mode_nof_fec_bits_get_f arad_plus_mode_nof_fec_bits_get;
    /**
     * returns numeric data of l2_egress_max_extention_size_bytes
     */
    dnx_data_l2_general_l2_egress_max_extention_size_bytes_get_f l2_egress_max_extention_size_bytes_get;
    /**
     * returns numeric data of l2_egress_max_additional_termination_size_bytes
     */
    dnx_data_l2_general_l2_egress_max_additional_termination_size_bytes_get_f l2_egress_max_additional_termination_size_bytes_get;
    /**
     * returns numeric data of mact_mngmnt_fid_exceed_limit_int
     */
    dnx_data_l2_general_mact_mngmnt_fid_exceed_limit_int_get_f mact_mngmnt_fid_exceed_limit_int_get;
    /**
     * returns numeric data of mact_lela_fid_exceed_limit_int
     */
    dnx_data_l2_general_mact_lela_fid_exceed_limit_int_get_f mact_lela_fid_exceed_limit_int_get;
    /**
     * returns numeric data of l2_api_supported_flags2
     */
    dnx_data_l2_general_l2_api_supported_flags2_get_f l2_api_supported_flags2_get;
    /**
     * returns numeric data of l2_traverse_api_supported_flags
     */
    dnx_data_l2_general_l2_traverse_api_supported_flags_get_f l2_traverse_api_supported_flags_get;
    /**
     * returns numeric data of l2_delete_api_supported_flags
     */
    dnx_data_l2_general_l2_delete_api_supported_flags_get_f l2_delete_api_supported_flags_get;
    /**
     * get table mact_result_type_map entry 
     */
    dnx_data_l2_general_mact_result_type_map_get_f mact_result_type_map_get;
    /**
     * get general info table about table (for example key size)mact_result_type_map info
     */
    dnxc_data_table_info_get_f mact_result_type_map_info_get;
    /**
     * get table scan_data_bases_info entry 
     */
    dnx_data_l2_general_scan_data_bases_info_get_f scan_data_bases_info_get;
    /**
     * get general info table about table (for example key size)scan_data_bases_info info
     */
    dnxc_data_table_info_get_f scan_data_bases_info_info_get;
    /**
     * get table fwd_mact_info entry 
     */
    dnx_data_l2_general_fwd_mact_info_get_f fwd_mact_info_get;
    /**
     * get general info table about table (for example key size)fwd_mact_info info
     */
    dnxc_data_table_info_get_f fwd_mact_info_info_get;
    /**
     * get table lem_table_map_l2_action entry 
     */
    dnx_data_l2_general_lem_table_map_l2_action_get_f lem_table_map_l2_action_get;
    /**
     * get general info table about table (for example key size)lem_table_map_l2_action info
     */
    dnxc_data_table_info_get_f lem_table_map_l2_action_info_get;
} dnx_data_if_l2_general_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURE:
 * 
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Age out and refresh distribution is always taken from the default profile
     */
    dnx_data_l2_feature_age_out_and_refresh_profile_selection,
    /**
     * Age machine stops working after flush runs
     */
    dnx_data_l2_feature_age_machine_pause_after_flush,
    /**
     * Age state of l2 entries is not updated
     */
    dnx_data_l2_feature_age_state_not_updated,
    /**
     * AppDB ID is wrongly taken from the 4 MSBs like in Jericho
     */
    dnx_data_l2_feature_appdb_id_for_olp,
    /**
     * Parser Ethernet qualifier is_mc is set correctly
     */
    dnx_data_l2_feature_eth_qual_is_mc,
    dnx_data_l2_feature_bc_same_as_unknown_mc,
    dnx_data_l2_feature_fid_mgmt_ecc_error,
    /**
     * No interrupt is raised for fid limit cross
     */
    dnx_data_l2_feature_wrong_limit_interrupt_handling,
    /**
     * Transplant event is created instead of refresh event
     */
    dnx_data_l2_feature_transplant_instead_of_refresh,
    /**
     * Static mac entries age out and deleted
     */
    dnx_data_l2_feature_static_mac_age_out,
    /**
     * For limit check the vmv is taken from the wrong side of the mdb entry
     */
    dnx_data_l2_feature_vmv_for_limit_in_wrong_location,
    /**
     * L2 limit causes supression of events related to existing entries (eg transplant/refresh)
     */
    dnx_data_l2_feature_learn_limit,
    dnx_data_l2_feature_limit_per_lif_counters,
    dnx_data_l2_feature_learn_events_wrong_command,
    dnx_data_l2_feature_opportunistic_learning_always_transplant,
    dnx_data_l2_feature_exceed_limit_interrupt_by_insert_cmd,
    dnx_data_l2_feature_refresh_events_wrong_key_msbs,
    dnx_data_l2_feature_ignore_limit_check,
    dnx_data_l2_feature_no_trap_for_unknown_destination,
    dnx_data_l2_feature_mact_access_by_opportunistic_learning,
    dnx_data_l2_feature_opportunistic_rejected,
    dnx_data_l2_feature_flush_drop_stuck,
    dnx_data_l2_feature_lif_flood_profile_always_update,
    dnx_data_l2_feature_olp_always_enters_source_cpu,
    dnx_data_l2_feature_learn_payload_compatible_jr1,
    dnx_data_l2_feature_unified_vsi_info_db,
    dnx_data_l2_feature_ingress_opportunistic_learning_support,
    dnx_data_l2_feature_age_refresh_mode_support,
    dnx_data_l2_feature_learn_payload_native_update_enable,

    /**
     * Must be last one!
     */
    _dnx_data_l2_feature_feature_nof
} dnx_data_l2_feature_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_feature_feature_get_f) (
    int unit,
    dnx_data_l2_feature_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - FEATURE:
 * {
 */
/**
 * \brief Interface for l2 feature data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_feature_feature_get_f feature_get;
} dnx_data_if_l2_feature_t;

/*
 * }
 */

/*
 * SUBMODULE  - VSI:
 * VSI data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l2_vsi_feature_nof
} dnx_data_l2_vsi_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_vsi_feature_get_f) (
    int unit,
    dnx_data_l2_vsi_feature_e feature);

/**
 * \brief returns define data of nof_vsi_aging_profiles
 * Module - 'l2', Submodule - 'vsi', data - 'nof_vsi_aging_profiles'
 * Number of VSI aging profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vsi_aging_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vsi_nof_vsi_aging_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_event_forwarding_profiles
 * Module - 'l2', Submodule - 'vsi', data - 'nof_event_forwarding_profiles'
 * Number of event forwarding profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_event_forwarding_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vsi_nof_event_forwarding_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_vsi_learning_profiles
 * Module - 'l2', Submodule - 'vsi', data - 'nof_vsi_learning_profiles'
 * Number of VSI learning profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vsi_learning_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vsi_nof_vsi_learning_profiles_get_f) (
    int unit);

/**
 * \brief returns numeric data of vsi_table
 * Module - 'l2', Submodule - 'vsi', data - 'vsi_table'
 * The ID of the VSI DBAL table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsi_table - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vsi_vsi_table_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - VSI:
 * {
 */
/**
 * \brief Interface for l2 vsi data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_vsi_feature_get_f feature_get;
    /**
     * returns define data of nof_vsi_aging_profiles
     */
    dnx_data_l2_vsi_nof_vsi_aging_profiles_get_f nof_vsi_aging_profiles_get;
    /**
     * returns define data of nof_event_forwarding_profiles
     */
    dnx_data_l2_vsi_nof_event_forwarding_profiles_get_f nof_event_forwarding_profiles_get;
    /**
     * returns define data of nof_vsi_learning_profiles
     */
    dnx_data_l2_vsi_nof_vsi_learning_profiles_get_f nof_vsi_learning_profiles_get;
    /**
     * returns numeric data of vsi_table
     */
    dnx_data_l2_vsi_vsi_table_get_f vsi_table_get;
} dnx_data_if_l2_vsi_t;

/*
 * }
 */

/*
 * SUBMODULE  - VLAN_DOMAIN:
 * vlan domain
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l2_vlan_domain_feature_nof
} dnx_data_l2_vlan_domain_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_vlan_domain_feature_get_f) (
    int unit,
    dnx_data_l2_vlan_domain_feature_e feature);

/**
 * \brief returns define data of nof_vlan_domains
 * Module - 'l2', Submodule - 'vlan_domain', data - 'nof_vlan_domains'
 * Number of supported vlan domains
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vlan_domains - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vlan_domain_nof_vlan_domains_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_next_layer_network_domain
 * Module - 'l2', Submodule - 'vlan_domain', data - 'nof_bits_next_layer_network_domain'
 * Number of bits for next layer network domain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_next_layer_network_domain - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vlan_domain_nof_bits_next_layer_network_domain_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - VLAN_DOMAIN:
 * {
 */
/**
 * \brief Interface for l2 vlan_domain data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_vlan_domain_feature_get_f feature_get;
    /**
     * returns define data of nof_vlan_domains
     */
    dnx_data_l2_vlan_domain_nof_vlan_domains_get_f nof_vlan_domains_get;
    /**
     * returns define data of nof_bits_next_layer_network_domain
     */
    dnx_data_l2_vlan_domain_nof_bits_next_layer_network_domain_get_f nof_bits_next_layer_network_domain_get;
} dnx_data_if_l2_vlan_domain_t;

/*
 * }
 */

/*
 * SUBMODULE  - DMA:
 * dma
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l2_dma_feature_nof
} dnx_data_l2_dma_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_dma_feature_get_f) (
    int unit,
    dnx_data_l2_dma_feature_e feature);

/**
 * \brief returns define data of flush_nof_dma_entries
 * Module - 'l2', Submodule - 'dma', data - 'flush_nof_dma_entries'
 * Number of flush DMA entries that the host can hold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_nof_dma_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_nof_dma_entries_get_f) (
    int unit);

/**
 * \brief returns define data of flush_db_nof_dma_rules
 * Module - 'l2', Submodule - 'dma', data - 'flush_db_nof_dma_rules'
 * Number of flush DMA rules
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_db_nof_dma_rules - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_db_nof_dma_rules_get_f) (
    int unit);

/**
 * \brief returns define data of flush_db_nof_dma_rules_per_table
 * Module - 'l2', Submodule - 'dma', data - 'flush_db_nof_dma_rules_per_table'
 * Number of flush DMA rules in a table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_db_nof_dma_rules_per_table - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_db_nof_dma_rules_per_table_get_f) (
    int unit);

/**
 * \brief returns define data of flush_db_rule_size
 * Module - 'l2', Submodule - 'dma', data - 'flush_db_rule_size'
 * Size in bytes of a flush DB rule
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_db_rule_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_db_rule_size_get_f) (
    int unit);

/**
 * \brief returns define data of flush_db_data_size
 * Module - 'l2', Submodule - 'dma', data - 'flush_db_data_size'
 * Size in bytes of a flush DB action data
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_db_data_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_db_data_size_get_f) (
    int unit);

/**
 * \brief returns define data of flush_group_size
 * Module - 'l2', Submodule - 'dma', data - 'flush_group_size'
 * the size of flush group field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_group_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_group_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of learning_fifo_dma_buffer_size
 * Module - 'l2', Submodule - 'dma', data - 'learning_fifo_dma_buffer_size'
 * learning fifo dma buffer size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learning_fifo_dma_buffer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_learning_fifo_dma_buffer_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of learning_fifo_dma_timeout
 * Module - 'l2', Submodule - 'dma', data - 'learning_fifo_dma_timeout'
 * learning fifo dma timeout in microseconds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learning_fifo_dma_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_learning_fifo_dma_timeout_get_f) (
    int unit);

/**
 * \brief returns numeric data of learning_fifo_dma_threshold
 * Module - 'l2', Submodule - 'dma', data - 'learning_fifo_dma_threshold'
 * learning fifo dma threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learning_fifo_dma_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_learning_fifo_dma_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_dma_cpu_learn_thread_priority
 * Module - 'l2', Submodule - 'dma', data - 'l2_dma_cpu_learn_thread_priority'
 * cpu learning thread priority
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_dma_cpu_learn_thread_priority - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_l2_dma_cpu_learn_thread_priority_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - DMA:
 * {
 */
/**
 * \brief Interface for l2 dma data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_dma_feature_get_f feature_get;
    /**
     * returns define data of flush_nof_dma_entries
     */
    dnx_data_l2_dma_flush_nof_dma_entries_get_f flush_nof_dma_entries_get;
    /**
     * returns define data of flush_db_nof_dma_rules
     */
    dnx_data_l2_dma_flush_db_nof_dma_rules_get_f flush_db_nof_dma_rules_get;
    /**
     * returns define data of flush_db_nof_dma_rules_per_table
     */
    dnx_data_l2_dma_flush_db_nof_dma_rules_per_table_get_f flush_db_nof_dma_rules_per_table_get;
    /**
     * returns define data of flush_db_rule_size
     */
    dnx_data_l2_dma_flush_db_rule_size_get_f flush_db_rule_size_get;
    /**
     * returns define data of flush_db_data_size
     */
    dnx_data_l2_dma_flush_db_data_size_get_f flush_db_data_size_get;
    /**
     * returns define data of flush_group_size
     */
    dnx_data_l2_dma_flush_group_size_get_f flush_group_size_get;
    /**
     * returns numeric data of learning_fifo_dma_buffer_size
     */
    dnx_data_l2_dma_learning_fifo_dma_buffer_size_get_f learning_fifo_dma_buffer_size_get;
    /**
     * returns numeric data of learning_fifo_dma_timeout
     */
    dnx_data_l2_dma_learning_fifo_dma_timeout_get_f learning_fifo_dma_timeout_get;
    /**
     * returns numeric data of learning_fifo_dma_threshold
     */
    dnx_data_l2_dma_learning_fifo_dma_threshold_get_f learning_fifo_dma_threshold_get;
    /**
     * returns numeric data of l2_dma_cpu_learn_thread_priority
     */
    dnx_data_l2_dma_l2_dma_cpu_learn_thread_priority_get_f l2_dma_cpu_learn_thread_priority_get;
} dnx_data_if_l2_dma_t;

/*
 * }
 */

/*
 * SUBMODULE  - AGE_AND_FLUSH_MACHINE:
 * Scan machine used for flush and age operations.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule age_and_flush_machine table flush_pulse
 * Table info:
 * Flush machine pulse reg maping
 */
typedef struct
{
    /**
     * Pulse the flush machine to start scanning.
     */
    soc_reg_t flush_pulse_reg;
} dnx_data_l2_age_and_flush_machine_flush_pulse_t;

/**
 * \brief Holds values of submodule age_and_flush_machine table age
 * Table info:
 * Age machine related HW
 */
typedef struct
{
    /**
     * Age configuration register
     */
    soc_reg_t age_config;
    /**
     * Disable aging.
     */
    soc_field_t disable_aging;
    /**
     * Pulse the scan machine to start scanning.
     */
    soc_reg_t scan_pulse;
} dnx_data_l2_age_and_flush_machine_age_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    dnx_data_l2_age_and_flush_machine_flush_init_enable,

    /**
     * Must be last one!
     */
    _dnx_data_l2_age_and_flush_machine_feature_nof
} dnx_data_l2_age_and_flush_machine_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_age_and_flush_machine_feature_get_f) (
    int unit,
    dnx_data_l2_age_and_flush_machine_feature_e feature);

/**
 * \brief returns define data of max_age_states
 * Module - 'l2', Submodule - 'age_and_flush_machine', data - 'max_age_states'
 * The maximal NOF age states that an entry can have before aging out.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_age_states - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_age_and_flush_machine_max_age_states_get_f) (
    int unit);

/**
 * \brief returns numeric data of flush_buffer_nof_entries
 * Module - 'l2', Submodule - 'age_and_flush_machine', data - 'flush_buffer_nof_entries'
 * Size of flush buffer in number of entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_buffer_nof_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_age_and_flush_machine_flush_buffer_nof_entries_get_f) (
    int unit);

/**
 * \brief returns numeric data of traverse_thread_priority
 * Module - 'l2', Submodule - 'age_and_flush_machine', data - 'traverse_thread_priority'
 * L2 flush match traverse non-blocking thread priority.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     traverse_thread_priority - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_age_and_flush_machine_traverse_thread_priority_get_f) (
    int unit);

/**
 * \brief get table flush_pulse entry 
 * Flush machine pulse reg maping
 * 
 * \param [in] unit - unit #
 * \param [in] l2_action_type - 
 * 
 * \return
 *     flush_pulse - returns the relevant entry values grouped in struct - see dnx_data_l2_age_and_flush_machine_flush_pulse_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_age_and_flush_machine_flush_pulse_t *(
    *dnx_data_l2_age_and_flush_machine_flush_pulse_get_f) (
    int unit,
    int l2_action_type);

/**
 * \brief get table age entry 
 * Age machine related HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age - returns the relevant entry values grouped in struct - see dnx_data_l2_age_and_flush_machine_age_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_age_and_flush_machine_age_t *(
    *dnx_data_l2_age_and_flush_machine_age_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - AGE_AND_FLUSH_MACHINE:
 * {
 */
/**
 * \brief Interface for l2 age_and_flush_machine data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_age_and_flush_machine_feature_get_f feature_get;
    /**
     * returns define data of max_age_states
     */
    dnx_data_l2_age_and_flush_machine_max_age_states_get_f max_age_states_get;
    /**
     * returns numeric data of flush_buffer_nof_entries
     */
    dnx_data_l2_age_and_flush_machine_flush_buffer_nof_entries_get_f flush_buffer_nof_entries_get;
    /**
     * returns numeric data of traverse_thread_priority
     */
    dnx_data_l2_age_and_flush_machine_traverse_thread_priority_get_f traverse_thread_priority_get;
    /**
     * get table flush_pulse entry 
     */
    dnx_data_l2_age_and_flush_machine_flush_pulse_get_f flush_pulse_get;
    /**
     * get general info table about table (for example key size)flush_pulse info
     */
    dnxc_data_table_info_get_f flush_pulse_info_get;
    /**
     * get table age entry 
     */
    dnx_data_l2_age_and_flush_machine_age_get_f age_get;
    /**
     * get general info table about table (for example key size)age info
     */
    dnxc_data_table_info_get_f age_info_get;
} dnx_data_if_l2_age_and_flush_machine_t;

/*
 * }
 */

/*
 * SUBMODULE  - OLP:
 * Data for OLP configuration
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicate if refresh events are supported
     */
    dnx_data_l2_olp_refresh_events_support,
    /**
     * Indicate if olp learn payload initial value can be read from the register
     */
    dnx_data_l2_olp_olp_learn_payload_initial_value_supported,
    /**
     * Indicate if OLP can create DSP messages
     */
    dnx_data_l2_olp_dsp_messages_support,

    /**
     * Must be last one!
     */
    _dnx_data_l2_olp_feature_nof
} dnx_data_l2_olp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_olp_feature_get_f) (
    int unit,
    dnx_data_l2_olp_feature_e feature);

/**
 * \brief returns define data of lpkgv_shift
 * Module - 'l2', Submodule - 'olp', data - 'lpkgv_shift'
 * Learn_Payload_Key_Gen_Var shift in learn payload msb
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpkgv_shift - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_lpkgv_shift_get_f) (
    int unit);

/**
 * \brief returns define data of lpkgv_mask
 * Module - 'l2', Submodule - 'olp', data - 'lpkgv_mask'
 * Learn_Payload_Key_Gen_Var mask in learn payload msb
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpkgv_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_lpkgv_mask_get_f) (
    int unit);

/**
 * \brief returns define data of lpkgv_with_outlif
 * Module - 'l2', Submodule - 'olp', data - 'lpkgv_with_outlif'
 * Learn_Payload_Key_Gen_Var for outlif is valid in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpkgv_with_outlif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_lpkgv_with_outlif_get_f) (
    int unit);

/**
 * \brief returns define data of lpkgv_wo_outlif
 * Module - 'l2', Submodule - 'olp', data - 'lpkgv_wo_outlif'
 * Learn_Payload_Key_Gen_Var for outlif is invalid in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpkgv_wo_outlif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_lpkgv_wo_outlif_get_f) (
    int unit);

/**
 * \brief returns define data of destination_offset
 * Module - 'l2', Submodule - 'olp', data - 'destination_offset'
 * destination offset in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     destination_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_destination_offset_get_f) (
    int unit);

/**
 * \brief returns define data of outlif_offset
 * Module - 'l2', Submodule - 'olp', data - 'outlif_offset'
 * outlif offset in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_outlif_offset_get_f) (
    int unit);

/**
 * \brief returns define data of eei_offset
 * Module - 'l2', Submodule - 'olp', data - 'eei_offset'
 * eei offset in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     eei_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_eei_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fec_offset
 * Module - 'l2', Submodule - 'olp', data - 'fec_offset'
 * fec offset in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_fec_offset_get_f) (
    int unit);

/**
 * \brief returns define data of jr_mode_enhanced_performance_enable
 * Module - 'l2', Submodule - 'olp', data - 'jr_mode_enhanced_performance_enable'
 * Enhance performance in jr mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     jr_mode_enhanced_performance_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_jr_mode_enhanced_performance_enable_get_f) (
    int unit);

/**
 * \brief returns define data of olp_learning_block_id
 * Module - 'l2', Submodule - 'olp', data - 'olp_learning_block_id'
 * The block ID of the learning OLP block
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     olp_learning_block_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_olp_learning_block_id_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - OLP:
 * {
 */
/**
 * \brief Interface for l2 olp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_olp_feature_get_f feature_get;
    /**
     * returns define data of lpkgv_shift
     */
    dnx_data_l2_olp_lpkgv_shift_get_f lpkgv_shift_get;
    /**
     * returns define data of lpkgv_mask
     */
    dnx_data_l2_olp_lpkgv_mask_get_f lpkgv_mask_get;
    /**
     * returns define data of lpkgv_with_outlif
     */
    dnx_data_l2_olp_lpkgv_with_outlif_get_f lpkgv_with_outlif_get;
    /**
     * returns define data of lpkgv_wo_outlif
     */
    dnx_data_l2_olp_lpkgv_wo_outlif_get_f lpkgv_wo_outlif_get;
    /**
     * returns define data of destination_offset
     */
    dnx_data_l2_olp_destination_offset_get_f destination_offset_get;
    /**
     * returns define data of outlif_offset
     */
    dnx_data_l2_olp_outlif_offset_get_f outlif_offset_get;
    /**
     * returns define data of eei_offset
     */
    dnx_data_l2_olp_eei_offset_get_f eei_offset_get;
    /**
     * returns define data of fec_offset
     */
    dnx_data_l2_olp_fec_offset_get_f fec_offset_get;
    /**
     * returns define data of jr_mode_enhanced_performance_enable
     */
    dnx_data_l2_olp_jr_mode_enhanced_performance_enable_get_f jr_mode_enhanced_performance_enable_get;
    /**
     * returns define data of olp_learning_block_id
     */
    dnx_data_l2_olp_olp_learning_block_id_get_f olp_learning_block_id_get;
} dnx_data_if_l2_olp_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_L2:
 * {
 */
/**
 * \brief Interface for l2 data
 */
typedef struct
{
    /**
     * Interface for l2 general data
     */
    dnx_data_if_l2_general_t general;
    /**
     * Interface for l2 feature data
     */
    dnx_data_if_l2_feature_t feature;
    /**
     * Interface for l2 vsi data
     */
    dnx_data_if_l2_vsi_t vsi;
    /**
     * Interface for l2 vlan_domain data
     */
    dnx_data_if_l2_vlan_domain_t vlan_domain;
    /**
     * Interface for l2 dma data
     */
    dnx_data_if_l2_dma_t dma;
    /**
     * Interface for l2 age_and_flush_machine data
     */
    dnx_data_if_l2_age_and_flush_machine_t age_and_flush_machine;
    /**
     * Interface for l2 olp data
     */
    dnx_data_if_l2_olp_t olp;
} dnx_data_if_l2_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_l2_t dnx_data_l2;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_L2_H_*/
/* *INDENT-ON* */
