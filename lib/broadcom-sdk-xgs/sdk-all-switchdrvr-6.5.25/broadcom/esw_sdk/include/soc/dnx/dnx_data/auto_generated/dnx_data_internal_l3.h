/** \file dnx_data_internal_l3.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_L3_H_
/*{*/
#define _DNX_DATA_INTERNAL_L3_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_l3.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_l3_submodule_egr_pointed,
    dnx_data_l3_submodule_fec,
    dnx_data_l3_submodule_fer,
    dnx_data_l3_submodule_source_address,
    dnx_data_l3_submodule_vrf,
    dnx_data_l3_submodule_routing_enablers,
    dnx_data_l3_submodule_rif,
    dnx_data_l3_submodule_fwd,
    dnx_data_l3_submodule_ecmp,
    dnx_data_l3_submodule_vip_ecmp,
    dnx_data_l3_submodule_wcmp,
    dnx_data_l3_submodule_source_address_ethernet,
    dnx_data_l3_submodule_vrrp,
    dnx_data_l3_submodule_feature,

    /**
     * Must be last one!
     */
    _dnx_data_l3_submodule_nof
} dnx_data_l3_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE EGR_POINTED:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_egr_pointed_feature_get(
    int unit,
    dnx_data_l3_egr_pointed_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_egr_pointed_define_first_egr_pointed_id,
    dnx_data_l3_egr_pointed_define_nof_egr_pointed_ids,
    dnx_data_l3_egr_pointed_define_nof_bits_in_egr_pointed_id,

    /**
     * Must be last one!
     */
    _dnx_data_l3_egr_pointed_define_nof
} dnx_data_l3_egr_pointed_define_e;

/* Get Data */
/**
 * \brief returns define data of first_egr_pointed_id
 * Module - 'l3', Submodule - 'egr_pointed', data - 'first_egr_pointed_id'
 * Identifier of very first virtual egress pointed object.                            Range is from 'first_egr_pointed_id' to 'nof_egr_pointed_ids - 1'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_egr_pointed_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_egr_pointed_first_egr_pointed_id_get(
    int unit);

/**
 * \brief returns numeric data of nof_egr_pointed_ids
 * Module - 'l3', Submodule - 'egr_pointed', data - 'nof_egr_pointed_ids'
 * Number of virtual egress pointed object ids
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_pointed_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_egr_pointed_nof_egr_pointed_ids_get(
    int unit);

/**
 * \brief returns numeric data of nof_bits_in_egr_pointed_id
 * Module - 'l3', Submodule - 'egr_pointed', data - 'nof_bits_in_egr_pointed_id'
 * Number of bits representing one virtual egress pointed object id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_egr_pointed_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_egr_pointed_table_nof
} dnx_data_l3_egr_pointed_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FEC:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_fec_feature_get(
    int unit,
    dnx_data_l3_fec_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_fec_define_nof_fecs,
    dnx_data_l3_fec_define_first_valid_fec_ecmp_id,
    dnx_data_l3_fec_define_max_fec_id_for_single_dhb_cluster_pair_granularity,
    dnx_data_l3_fec_define_max_fec_id_for_double_dhb_cluster_pair_granularity,
    dnx_data_l3_fec_define_max_default_fec,
    dnx_data_l3_fec_define_bank_size,
    dnx_data_l3_fec_define_bank_size_round_up,
    dnx_data_l3_fec_define_max_nof_super_fecs_per_bank,
    dnx_data_l3_fec_define_nof_physical_fecs_per_bank,
    dnx_data_l3_fec_define_bank_nof_physical_rows,
    dnx_data_l3_fec_define_super_fec_size,
    dnx_data_l3_fec_define_max_nof_banks,
    dnx_data_l3_fec_define_first_bank_without_id_alloc,
    dnx_data_l3_fec_define_first_shared_bank,
    dnx_data_l3_fec_define_max_super_fec_id,
    dnx_data_l3_fec_define_nof_fec_directions,
    dnx_data_l3_fec_define_fec_z_max_fec_id,
    dnx_data_l3_fec_define_nof_dpc_fec_db,
    dnx_data_l3_fec_define_nof_fec_dbs_all_cores,
    dnx_data_l3_fec_define_nof_fec_result_types,
    dnx_data_l3_fec_define_fer_hw_version,
    dnx_data_l3_fec_define_fec_property_supported_flags,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fec_define_nof
} dnx_data_l3_fec_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_fecs
 * Module - 'l3', Submodule - 'fec', data - 'nof_fecs'
 * The maximal number of FECs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fecs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_nof_fecs_get(
    int unit);

/**
 * \brief returns define data of first_valid_fec_ecmp_id
 * Module - 'l3', Submodule - 'fec', data - 'first_valid_fec_ecmp_id'
 * The ID of the first valid FEC/ECMP group which can be created.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_valid_fec_ecmp_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_first_valid_fec_ecmp_id_get(
    int unit);

/**
 * \brief returns define data of max_fec_id_for_single_dhb_cluster_pair_granularity
 * Module - 'l3', Submodule - 'fec', data - 'max_fec_id_for_single_dhb_cluster_pair_granularity'
 * The maximal FEC ID that support a single DHB cluasters pair.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fec_id_for_single_dhb_cluster_pair_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_fec_id_for_single_dhb_cluster_pair_granularity_get(
    int unit);

/**
 * \brief returns define data of max_fec_id_for_double_dhb_cluster_pair_granularity
 * Module - 'l3', Submodule - 'fec', data - 'max_fec_id_for_double_dhb_cluster_pair_granularity'
 * The maximal FEC ID that requiere an even number of DHB clusters pairs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fec_id_for_double_dhb_cluster_pair_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_fec_id_for_double_dhb_cluster_pair_granularity_get(
    int unit);

/**
 * \brief returns define data of max_default_fec
 * Module - 'l3', Submodule - 'fec', data - 'max_default_fec'
 * The maximal FEC id that can be used for default route.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_default_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_default_fec_get(
    int unit);

/**
 * \brief returns define data of bank_size
 * Module - 'l3', Submodule - 'fec', data - 'bank_size'
 * The smallest number of FECs which belong to the same hierarchy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_bank_size_get(
    int unit);

/**
 * \brief returns define data of bank_size_round_up
 * Module - 'l3', Submodule - 'fec', data - 'bank_size_round_up'
 * In some cases FEC bank size contains extra FECs due to round up which results from physical to logical translation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_size_round_up - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_bank_size_round_up_get(
    int unit);

/**
 * \brief returns define data of max_nof_super_fecs_per_bank
 * Module - 'l3', Submodule - 'fec', data - 'max_nof_super_fecs_per_bank'
 * The max NOF SUPER FEC IDs per resource manager bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_super_fecs_per_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_nof_super_fecs_per_bank_get(
    int unit);

/**
 * \brief returns define data of nof_physical_fecs_per_bank
 * Module - 'l3', Submodule - 'fec', data - 'nof_physical_fecs_per_bank'
 * The number of physical FEC IDs per bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_physical_fecs_per_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_nof_physical_fecs_per_bank_get(
    int unit);

/**
 * \brief returns define data of bank_nof_physical_rows
 * Module - 'l3', Submodule - 'fec', data - 'bank_nof_physical_rows'
 * The NOF rows that a FEC bank has.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_nof_physical_rows - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_bank_nof_physical_rows_get(
    int unit);

/**
 * \brief returns define data of super_fec_size
 * Module - 'l3', Submodule - 'fec', data - 'super_fec_size'
 * The number of bits of a single super FEC in the MDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     super_fec_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_super_fec_size_get(
    int unit);

/**
 * \brief returns define data of max_nof_banks
 * Module - 'l3', Submodule - 'fec', data - 'max_nof_banks'
 * The maximal NOF possible banks in the device (not MDB profile dependent).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_nof_banks_get(
    int unit);

/**
 * \brief returns define data of first_bank_without_id_alloc
 * Module - 'l3', Submodule - 'fec', data - 'first_bank_without_id_alloc'
 * the first fec allocation bank that can be used for allocating FECs without an ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_bank_without_id_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_first_bank_without_id_alloc_get(
    int unit);

/**
 * \brief returns define data of first_shared_bank
 * Module - 'l3', Submodule - 'fec', data - 'first_shared_bank'
 * The first FEC bank id index which has values in the ECMP and the FEC ranges.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_shared_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_first_shared_bank_get(
    int unit);

/**
 * \brief returns define data of max_super_fec_id
 * Module - 'l3', Submodule - 'fec', data - 'max_super_fec_id'
 * The max ID of the super FEC.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_super_fec_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_super_fec_id_get(
    int unit);

/**
 * \brief returns define data of nof_fec_directions
 * Module - 'l3', Submodule - 'fec', data - 'nof_fec_directions'
 * The number of FEC directions.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_directions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_nof_fec_directions_get(
    int unit);

/**
 * \brief returns define data of fec_z_max_fec_id
 * Module - 'l3', Submodule - 'fec', data - 'fec_z_max_fec_id'
 * The maximal FEC ID that is supported for FEC_Z.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_z_max_fec_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_fec_z_max_fec_id_get(
    int unit);

/**
 * \brief returns define data of nof_dpc_fec_db
 * Module - 'l3', Submodule - 'fec', data - 'nof_dpc_fec_db'
 * The number of DPC FEC DBs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dpc_fec_db - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_nof_dpc_fec_db_get(
    int unit);

/**
 * \brief returns define data of nof_fec_dbs_all_cores
 * Module - 'l3', Submodule - 'fec', data - 'nof_fec_dbs_all_cores'
 * The number of FEC DBs for all cores.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_dbs_all_cores - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_nof_fec_dbs_all_cores_get(
    int unit);

/**
 * \brief returns define data of nof_fec_result_types
 * Module - 'l3', Submodule - 'fec', data - 'nof_fec_result_types'
 * The number of result types in fec_result_type_fields
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_result_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_nof_fec_result_types_get(
    int unit);

/**
 * \brief returns numeric data of fer_hw_version
 * Module - 'l3', Submodule - 'fec', data - 'fer_hw_version'
 * This value indicates the HW version of the FER
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fer_hw_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_fer_hw_version_get(
    int unit);

/**
 * \brief returns numeric data of fec_property_supported_flags
 * Module - 'l3', Submodule - 'fec', data - 'fec_property_supported_flags'
 * Supported BCM_SWITCH_FEC_PROPERTY_* flags to verify the bcm_switch_fec_property_get API.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_property_supported_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_fec_property_supported_flags_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_fec_table_fec_resource_info,
    dnx_data_l3_fec_table_super_fec_result_types_map,
    dnx_data_l3_fec_table_fec_result_type_fields,
    dnx_data_l3_fec_table_fec_physical_db,
    dnx_data_l3_fec_table_fec_tables_info,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fec_table_nof
} dnx_data_l3_fec_table_e;

/* Get Data */
/**
 * \brief get table fec_resource_info entry 
 * FEC recource types information
 * 
 * \param [in] unit - unit #
 * \param [in] resource_type - FEC resouce type.
 * 
 * \return
 *     fec_resource_info - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_fec_resource_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fec_fec_resource_info_t * dnx_data_l3_fec_fec_resource_info_get(
    int unit,
    int resource_type);

/**
 * \brief get table super_fec_result_types_map entry 
 * Map FEC dbal result type to an actual FEC type and FEC recource type.
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_result_type - DBAL FEC result type.
 * 
 * \return
 *     super_fec_result_types_map - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_super_fec_result_types_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fec_super_fec_result_types_map_t * dnx_data_l3_fec_super_fec_result_types_map_get(
    int unit,
    int dbal_result_type);

/**
 * \brief get table fec_result_type_fields entry 
 * FEC table result type information.
 * 
 * \param [in] unit - unit #
 * \param [in] result_type - FEC table result types.
 * 
 * \return
 *     fec_result_type_fields - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_fec_result_type_fields_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fec_fec_result_type_fields_t * dnx_data_l3_fec_fec_result_type_fields_get(
    int unit,
    int result_type);

/**
 * \brief get table fec_physical_db entry 
 * A list with FEC physical DBs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_physical_db - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_fec_physical_db_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fec_fec_physical_db_t * dnx_data_l3_fec_fec_physical_db_get(
    int unit);

/**
 * \brief get table fec_tables_info entry 
 * FEC tables Information.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - MDB FEC physical tables.
 * 
 * \return
 *     fec_tables_info - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_fec_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fec_fec_tables_info_t * dnx_data_l3_fec_fec_tables_info_get(
    int unit,
    int mdb_table);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fec', table - 'fec_resource_info'
 * FEC recource types information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fec_fec_resource_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fec', table - 'super_fec_result_types_map'
 * Map FEC dbal result type to an actual FEC type and FEC recource type.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fec_super_fec_result_types_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fec', table - 'fec_result_type_fields'
 * FEC table result type information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fec_fec_result_type_fields_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fec', table - 'fec_physical_db'
 * A list with FEC physical DBs
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fec_fec_physical_db_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fec', table - 'fec_tables_info'
 * FEC tables Information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fec_fec_tables_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)fec_resource_info info
 * FEC recource types information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_resource_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fec_fec_resource_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)super_fec_result_types_map info
 * Map FEC dbal result type to an actual FEC type and FEC recource type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     super_fec_result_types_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fec_super_fec_result_types_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fec_result_type_fields info
 * FEC table result type information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_result_type_fields - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fec_fec_result_type_fields_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fec_physical_db info
 * A list with FEC physical DBs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_physical_db - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fec_fec_physical_db_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fec_tables_info info
 * FEC tables Information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_tables_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fec_fec_tables_info_info_get(
    int unit);

/*
 * SUBMODULE FER:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_fer_feature_get(
    int unit,
    dnx_data_l3_fer_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_fer_define_mdb_granularity_ratio,
    dnx_data_l3_fer_define_nof_fer_sort_to_mdb_table_muxes,
    dnx_data_l3_fer_define_max_nof_sorting_blocks_per_fec_db,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fer_define_nof
} dnx_data_l3_fer_define_e;

/* Get Data */
/**
 * \brief returns define data of mdb_granularity_ratio
 * Module - 'l3', Submodule - 'fer', data - 'mdb_granularity_ratio'
 * This value indicate the ratio between the FER FEC granularity relative to the MDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_granularity_ratio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fer_mdb_granularity_ratio_get(
    int unit);

/**
 * \brief returns define data of nof_fer_sort_to_mdb_table_muxes
 * Module - 'l3', Submodule - 'fer', data - 'nof_fer_sort_to_mdb_table_muxes'
 * The number of muxes that selects between FER stages sorting blocks to MDB physical tables
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fer_sort_to_mdb_table_muxes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fer_nof_fer_sort_to_mdb_table_muxes_get(
    int unit);

/**
 * \brief returns define data of max_nof_sorting_blocks_per_fec_db
 * Module - 'l3', Submodule - 'fer', data - 'max_nof_sorting_blocks_per_fec_db'
 * The maximal number of FEC sorting blocks for a signle FEC DB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_sorting_blocks_per_fec_db - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fer_max_nof_sorting_blocks_per_fec_db_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_fer_table_mux_configuration,
    dnx_data_l3_fer_table_mux_connection,
    dnx_data_l3_fer_table_sorting_stages_info,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fer_table_nof
} dnx_data_l3_fer_table_e;

/* Get Data */
/**
 * \brief get table mux_configuration entry 
 * Configuration of FER MUX connectivity
 * 
 * \param [in] unit - unit #
 * \param [in] mux_id - The ID of the FER MUX.
 * 
 * \return
 *     mux_configuration - returns the relevant entry values grouped in struct - see dnx_data_l3_fer_mux_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fer_mux_configuration_t * dnx_data_l3_fer_mux_configuration_get(
    int unit,
    int mux_id);

/**
 * \brief get table mux_connection entry 
 * Information about the MUX connected to each FEC DB
 * 
 * \param [in] unit - unit #
 * \param [in] physical_db - The physical FEC database
 * 
 * \return
 *     mux_connection - returns the relevant entry values grouped in struct - see dnx_data_l3_fer_mux_connection_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fer_mux_connection_t * dnx_data_l3_fer_mux_connection_get(
    int unit,
    int physical_db);

/**
 * \brief get table sorting_stages_info entry 
 * FER sorting stages information
 * 
 * \param [in] unit - unit #
 * \param [in] sorting_stage - The FER sorting stage
 * 
 * \return
 *     sorting_stages_info - returns the relevant entry values grouped in struct - see dnx_data_l3_fer_sorting_stages_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fer_sorting_stages_info_t * dnx_data_l3_fer_sorting_stages_info_get(
    int unit,
    int sorting_stage);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fer', table - 'mux_configuration'
 * Configuration of FER MUX connectivity
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fer_mux_configuration_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fer', table - 'mux_connection'
 * Information about the MUX connected to each FEC DB
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fer_mux_connection_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fer', table - 'sorting_stages_info'
 * FER sorting stages information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fer_sorting_stages_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)mux_configuration info
 * Configuration of FER MUX connectivity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mux_configuration - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fer_mux_configuration_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mux_connection info
 * Information about the MUX connected to each FEC DB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mux_connection - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fer_mux_connection_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)sorting_stages_info info
 * FER sorting stages information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sorting_stages_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fer_sorting_stages_info_info_get(
    int unit);

/*
 * SUBMODULE SOURCE_ADDRESS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_source_address_feature_get(
    int unit,
    dnx_data_l3_source_address_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_source_address_define_source_address_table_size,
    dnx_data_l3_source_address_define_custom_sa_use_dual_homing,

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_define_nof
} dnx_data_l3_source_address_define_e;

/* Get Data */
/**
 * \brief returns define data of source_address_table_size
 * Module - 'l3', Submodule - 'source_address', data - 'source_address_table_size'
 * The number of entries in the source address table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_address_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_source_address_source_address_table_size_get(
    int unit);

/**
 * \brief returns define data of custom_sa_use_dual_homing
 * Module - 'l3', Submodule - 'source_address', data - 'custom_sa_use_dual_homing'
 * Indication whether ARP custom sa feature is using EEDB dual homing field or full mac address from source address table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     custom_sa_use_dual_homing - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_source_address_custom_sa_use_dual_homing_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_source_address_table_address_type_info,

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_table_nof
} dnx_data_l3_source_address_table_e;

/* Get Data */
/**
 * \brief get table address_type_info entry 
 * Information about how many entries each address type takes in source_address_map table.
 * 
 * \param [in] unit - unit #
 * \param [in] address_type - Address type.
 * 
 * \return
 *     address_type_info - returns the relevant entry values grouped in struct - see dnx_data_l3_source_address_address_type_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_source_address_address_type_info_t * dnx_data_l3_source_address_address_type_info_get(
    int unit,
    int address_type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'source_address', table - 'address_type_info'
 * Information about how many entries each address type takes in source_address_map table.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_source_address_address_type_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)address_type_info info
 * Information about how many entries each address type takes in source_address_map table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_type_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_source_address_address_type_info_info_get(
    int unit);

/*
 * SUBMODULE VRF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_vrf_feature_get(
    int unit,
    dnx_data_l3_vrf_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_vrf_define_nof_vrf,
    dnx_data_l3_vrf_define_nof_vrf_ipv6,

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrf_define_nof
} dnx_data_l3_vrf_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_vrf
 * Module - 'l3', Submodule - 'vrf', data - 'nof_vrf'
 * The maximal number of VRFs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vrf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrf_nof_vrf_get(
    int unit);

/**
 * \brief returns define data of nof_vrf_ipv6
 * Module - 'l3', Submodule - 'vrf', data - 'nof_vrf_ipv6'
 * The maximal number of VRFs supported by the device for an IPv6 MC table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vrf_ipv6 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrf_nof_vrf_ipv6_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrf_table_nof
} dnx_data_l3_vrf_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ROUTING_ENABLERS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_routing_enablers_feature_get(
    int unit,
    dnx_data_l3_routing_enablers_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_routing_enablers_define_routing_enable_vector_length,
    dnx_data_l3_routing_enablers_define_routing_enable_action_support,
    dnx_data_l3_routing_enablers_define_routing_enable_action_profile_size,
    dnx_data_l3_routing_enablers_define_routing_enable_indication_nof_bits_per_layer,
    dnx_data_l3_routing_enablers_define_routing_enable_nof_profiles_per_layer,
    dnx_data_l3_routing_enablers_define_routing_enabled_action_profile_id,

    /**
     * Must be last one!
     */
    _dnx_data_l3_routing_enablers_define_nof
} dnx_data_l3_routing_enablers_define_e;

/* Get Data */
/**
 * \brief returns define data of routing_enable_vector_length
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_vector_length'
 * The length in bits of the routing enablers vector.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_vector_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_routing_enablers_routing_enable_vector_length_get(
    int unit);

/**
 * \brief returns define data of routing_enable_action_support
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_action_support'
 * Indication whether routing enable action profiles are used to determine layer termination.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_action_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_routing_enablers_routing_enable_action_support_get(
    int unit);

/**
 * \brief returns define data of routing_enable_action_profile_size
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_action_profile_size'
 * Size in bits of the routing enable action profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_action_profile_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_routing_enablers_routing_enable_action_profile_size_get(
    int unit);

/**
 * \brief returns define data of routing_enable_indication_nof_bits_per_layer
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_indication_nof_bits_per_layer'
 * Number of bits in the routing enable vector responsible for a single uc/mc indication per layer type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_indication_nof_bits_per_layer - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_routing_enablers_routing_enable_indication_nof_bits_per_layer_get(
    int unit);

/**
 * \brief returns define data of routing_enable_nof_profiles_per_layer
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_nof_profiles_per_layer'
 * Number of routing enabled indications (UC/MC) per layer type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_nof_profiles_per_layer - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_routing_enablers_routing_enable_nof_profiles_per_layer_get(
    int unit);

/**
 * \brief returns define data of routing_enabled_action_profile_id
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enabled_action_profile_id'
 * The ID of the action profile which indicates that layer termination is enabled
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enabled_action_profile_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_routing_enablers_routing_enabled_action_profile_id_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_routing_enablers_table_layer_enablers_by_id,
    dnx_data_l3_routing_enablers_table_layer_enablers,

    /**
     * Must be last one!
     */
    _dnx_data_l3_routing_enablers_table_nof
} dnx_data_l3_routing_enablers_table_e;

/* Get Data */
/**
 * \brief get table layer_enablers_by_id entry 
 * List of layer types based on index
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Table entry index
 * 
 * \return
 *     layer_enablers_by_id - returns the relevant entry values grouped in struct - see dnx_data_l3_routing_enablers_layer_enablers_by_id_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_routing_enablers_layer_enablers_by_id_t * dnx_data_l3_routing_enablers_layer_enablers_by_id_get(
    int unit,
    int idx);

/**
 * \brief get table layer_enablers entry 
 * Map layer type to routing enabled/disabled indication
 * 
 * \param [in] unit - unit #
 * \param [in] layer_type - Layer type protocol
 * 
 * \return
 *     layer_enablers - returns the relevant entry values grouped in struct - see dnx_data_l3_routing_enablers_layer_enablers_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_routing_enablers_layer_enablers_t * dnx_data_l3_routing_enablers_layer_enablers_get(
    int unit,
    int layer_type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'routing_enablers', table - 'layer_enablers_by_id'
 * List of layer types based on index
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_routing_enablers_layer_enablers_by_id_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'routing_enablers', table - 'layer_enablers'
 * Map layer type to routing enabled/disabled indication
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_routing_enablers_layer_enablers_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)layer_enablers_by_id info
 * List of layer types based on index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_enablers_by_id - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_routing_enablers_layer_enablers_by_id_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)layer_enablers info
 * Map layer type to routing enabled/disabled indication
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_enablers - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_routing_enablers_layer_enablers_info_get(
    int unit);

/*
 * SUBMODULE RIF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_rif_feature_get(
    int unit,
    dnx_data_l3_rif_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_rif_define_max_nof_rifs,
    dnx_data_l3_rif_define_nof_rifs,

    /**
     * Must be last one!
     */
    _dnx_data_l3_rif_define_nof
} dnx_data_l3_rif_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_rifs
 * Module - 'l3', Submodule - 'rif', data - 'max_nof_rifs'
 * Maximum number of rifs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_rifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_rif_max_nof_rifs_get(
    int unit);

/**
 * \brief returns numeric data of nof_rifs
 * Module - 'l3', Submodule - 'rif', data - 'nof_rifs'
 * Number of rifs available in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_rif_nof_rifs_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_rif_table_nof
} dnx_data_l3_rif_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FWD:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_fwd_feature_get(
    int unit,
    dnx_data_l3_fwd_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_fwd_define_flp_fragment_support,
    dnx_data_l3_fwd_define_max_mc_group_lpm,
    dnx_data_l3_fwd_define_max_mc_group_em,
    dnx_data_l3_fwd_define_nof_my_mac_prefixes,
    dnx_data_l3_fwd_define_compressed_sip_svl_size,
    dnx_data_l3_fwd_define_nof_compressed_svl_sip,
    dnx_data_l3_fwd_define_lpm_strength_profiles_support,
    dnx_data_l3_fwd_define_nof_lpm_strength_profiles,
    dnx_data_l3_fwd_define_compressed_sip_ivl_size,
    dnx_data_l3_fwd_define_nof_compressed_ivl_sip,
    dnx_data_l3_fwd_define_uc_supported_route_flags,
    dnx_data_l3_fwd_define_uc_supported_route_flags2,
    dnx_data_l3_fwd_define_uc_supported_kbp_route_flags,
    dnx_data_l3_fwd_define_uc_supported_kbp_route_flags2,
    dnx_data_l3_fwd_define_ipmc_supported_flags,
    dnx_data_l3_fwd_define_last_kaps_intf_id,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fwd_define_nof
} dnx_data_l3_fwd_define_e;

/* Get Data */
/**
 * \brief returns define data of flp_fragment_support
 * Module - 'l3', Submodule - 'fwd', data - 'flp_fragment_support'
 * Indicate whether the LB fragmentation is handled by the FLP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flp_fragment_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_flp_fragment_support_get(
    int unit);

/**
 * \brief returns define data of max_mc_group_lpm
 * Module - 'l3', Submodule - 'fwd', data - 'max_mc_group_lpm'
 * The maximum number of MC group ID for IPMC route entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mc_group_lpm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_max_mc_group_lpm_get(
    int unit);

/**
 * \brief returns define data of max_mc_group_em
 * Module - 'l3', Submodule - 'fwd', data - 'max_mc_group_em'
 * The maximum number of MC group ID for IPMC host entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mc_group_em - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_max_mc_group_em_get(
    int unit);

/**
 * \brief returns define data of nof_my_mac_prefixes
 * Module - 'l3', Submodule - 'fwd', data - 'nof_my_mac_prefixes'
 * The number of my MACs prefixes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_my_mac_prefixes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_my_mac_prefixes_get(
    int unit);

/**
 * \brief returns define data of compressed_sip_svl_size
 * Module - 'l3', Submodule - 'fwd', data - 'compressed_sip_svl_size'
 * The size in bits of the IPMC IP6 compressed SIP for SVL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compressed_sip_svl_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_compressed_sip_svl_size_get(
    int unit);

/**
 * \brief returns define data of nof_compressed_svl_sip
 * Module - 'l3', Submodule - 'fwd', data - 'nof_compressed_svl_sip'
 * Number of supported IPMC compressed SIPs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compressed_svl_sip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_compressed_svl_sip_get(
    int unit);

/**
 * \brief returns define data of lpm_strength_profiles_support
 * Module - 'l3', Submodule - 'fwd', data - 'lpm_strength_profiles_support'
 * Indicates whether the KAPS strength mapping is different per LPM profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpm_strength_profiles_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_lpm_strength_profiles_support_get(
    int unit);

/**
 * \brief returns define data of nof_lpm_strength_profiles
 * Module - 'l3', Submodule - 'fwd', data - 'nof_lpm_strength_profiles'
 * The number of LPM strength profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lpm_strength_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_lpm_strength_profiles_get(
    int unit);

/**
 * \brief returns define data of compressed_sip_ivl_size
 * Module - 'l3', Submodule - 'fwd', data - 'compressed_sip_ivl_size'
 * The size in bits of the IPMC IP6 compressed SIP for IVL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compressed_sip_ivl_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_compressed_sip_ivl_size_get(
    int unit);

/**
 * \brief returns define data of nof_compressed_ivl_sip
 * Module - 'l3', Submodule - 'fwd', data - 'nof_compressed_ivl_sip'
 * Number of supported IPMC compressed SIPs for IVL table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compressed_ivl_sip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_compressed_ivl_sip_get(
    int unit);

/**
 * \brief returns numeric data of uc_supported_route_flags
 * Module - 'l3', Submodule - 'fwd', data - 'uc_supported_route_flags'
 * Supported L3 unicast route flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uc_supported_route_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_uc_supported_route_flags_get(
    int unit);

/**
 * \brief returns numeric data of uc_supported_route_flags2
 * Module - 'l3', Submodule - 'fwd', data - 'uc_supported_route_flags2'
 * Supported L3 unicast route flags2.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uc_supported_route_flags2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_uc_supported_route_flags2_get(
    int unit);

/**
 * \brief returns numeric data of uc_supported_kbp_route_flags
 * Module - 'l3', Submodule - 'fwd', data - 'uc_supported_kbp_route_flags'
 * Supported L3 unicast KBP route flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uc_supported_kbp_route_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_uc_supported_kbp_route_flags_get(
    int unit);

/**
 * \brief returns numeric data of uc_supported_kbp_route_flags2
 * Module - 'l3', Submodule - 'fwd', data - 'uc_supported_kbp_route_flags2'
 * Supported L3 unicast KBP route flags2.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uc_supported_kbp_route_flags2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_uc_supported_kbp_route_flags2_get(
    int unit);

/**
 * \brief returns numeric data of ipmc_supported_flags
 * Module - 'l3', Submodule - 'fwd', data - 'ipmc_supported_flags'
 * Supported flags for the IPMC APIs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmc_supported_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_ipmc_supported_flags_get(
    int unit);

/**
 * \brief returns numeric data of last_kaps_intf_id
 * Module - 'l3', Submodule - 'fwd', data - 'last_kaps_intf_id'
 * The last valid KAPS interface used in KAPS LPM strength profile configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     last_kaps_intf_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_last_kaps_intf_id_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_fwd_table_lpm_profile_to_entry_strength,
    dnx_data_l3_fwd_table_routing_tables,
    dnx_data_l3_fwd_table_mc_tables,
    dnx_data_l3_fwd_table_ipmc_compression_mode,
    dnx_data_l3_fwd_table_lpm_default_prefix_length_info,
    dnx_data_l3_fwd_table_lpm_app_db_to_strength_profile,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fwd_table_nof
} dnx_data_l3_fwd_table_e;

/* Get Data */
/**
 * \brief get table lpm_profile_to_entry_strength entry 
 * LPM profile to entry strength mapping
 * 
 * \param [in] unit - unit #
 * \param [in] lpm_profile - LPM profile.
 * \param [in] kaps_intf - KAPS interface.
 * 
 * \return
 *     lpm_profile_to_entry_strength - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_lpm_profile_to_entry_strength_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fwd_lpm_profile_to_entry_strength_t * dnx_data_l3_fwd_lpm_profile_to_entry_strength_get(
    int unit,
    int lpm_profile,
    int kaps_intf);

/**
 * \brief get table routing_tables entry 
 * IPv4/IPv6 routing tables information
 * 
 * \param [in] unit - unit #
 * \param [in] ip_version - Internet protocol version(IPv4 or IPv6)
 * 
 * \return
 *     routing_tables - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_routing_tables_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fwd_routing_tables_t * dnx_data_l3_fwd_routing_tables_get(
    int unit,
    int ip_version);

/**
 * \brief get table mc_tables entry 
 * IPv4/IPv6 MC tables information
 * 
 * \param [in] unit - unit #
 * \param [in] ip_version - Internet protocol version(IPv4 or IPv6)
 * \param [in] route_enable - Indicates whether the tables are routing tables or bridge tables
 * 
 * \return
 *     mc_tables - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_mc_tables_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fwd_mc_tables_t * dnx_data_l3_fwd_mc_tables_get(
    int unit,
    int ip_version,
    int route_enable);

/**
 * \brief get table ipmc_compression_mode entry 
 * IPv4/IPv6 MC tables information
 * 
 * \param [in] unit - unit #
 * \param [in] route_enable - Indicates whether the tables are routing tables or bridge tables
 * 
 * \return
 *     ipmc_compression_mode - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_ipmc_compression_mode_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fwd_ipmc_compression_mode_t * dnx_data_l3_fwd_ipmc_compression_mode_get(
    int unit,
    int route_enable);

/**
 * \brief get table lpm_default_prefix_length_info entry 
 * LPM default prefix length information
 * 
 * \param [in] unit - unit #
 * \param [in] physical_db_id - LPM physical table ID
 * 
 * \return
 *     lpm_default_prefix_length_info - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_lpm_default_prefix_length_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fwd_lpm_default_prefix_length_info_t * dnx_data_l3_fwd_lpm_default_prefix_length_info_get(
    int unit,
    int physical_db_id);

/**
 * \brief get table lpm_app_db_to_strength_profile entry 
 * LPM APP DB to entry strength profile mapping
 * 
 * \param [in] unit - unit #
 * \param [in] kaps_intf - KAPS interface
 * 
 * \return
 *     lpm_app_db_to_strength_profile - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_lpm_app_db_to_strength_profile_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fwd_lpm_app_db_to_strength_profile_t * dnx_data_l3_fwd_lpm_app_db_to_strength_profile_get(
    int unit,
    int kaps_intf);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fwd', table - 'lpm_profile_to_entry_strength'
 * LPM profile to entry strength mapping
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fwd_lpm_profile_to_entry_strength_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fwd', table - 'routing_tables'
 * IPv4/IPv6 routing tables information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fwd_routing_tables_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fwd', table - 'mc_tables'
 * IPv4/IPv6 MC tables information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fwd_mc_tables_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fwd', table - 'ipmc_compression_mode'
 * IPv4/IPv6 MC tables information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fwd_ipmc_compression_mode_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fwd', table - 'lpm_default_prefix_length_info'
 * LPM default prefix length information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fwd_lpm_default_prefix_length_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fwd', table - 'lpm_app_db_to_strength_profile'
 * LPM APP DB to entry strength profile mapping
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fwd_lpm_app_db_to_strength_profile_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)lpm_profile_to_entry_strength info
 * LPM profile to entry strength mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpm_profile_to_entry_strength - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fwd_lpm_profile_to_entry_strength_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)routing_tables info
 * IPv4/IPv6 routing tables information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_tables - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fwd_routing_tables_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mc_tables info
 * IPv4/IPv6 MC tables information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mc_tables - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fwd_mc_tables_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ipmc_compression_mode info
 * IPv4/IPv6 MC tables information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmc_compression_mode - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fwd_ipmc_compression_mode_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)lpm_default_prefix_length_info info
 * LPM default prefix length information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpm_default_prefix_length_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fwd_lpm_default_prefix_length_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)lpm_app_db_to_strength_profile info
 * LPM APP DB to entry strength profile mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpm_app_db_to_strength_profile - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fwd_lpm_app_db_to_strength_profile_info_get(
    int unit);

/*
 * SUBMODULE ECMP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_ecmp_feature_get(
    int unit,
    dnx_data_l3_ecmp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_ecmp_define_group_size_multiply_and_divide_nof_bits,
    dnx_data_l3_ecmp_define_group_size_consistent_nof_bits,
    dnx_data_l3_ecmp_define_group_size_nof_bits,
    dnx_data_l3_ecmp_define_max_group_size,
    dnx_data_l3_ecmp_define_nof_ecmp_basic_mode,
    dnx_data_l3_ecmp_define_total_nof_ecmp,
    dnx_data_l3_ecmp_define_max_ecmp_basic_mode,
    dnx_data_l3_ecmp_define_max_ecmp_extended_mode,
    dnx_data_l3_ecmp_define_nof_extended_ecmp_per_failover_bank,
    dnx_data_l3_ecmp_define_nof_failover_banks_per_extended_ecmp_bank,
    dnx_data_l3_ecmp_define_nof_group_profiles_per_hierarchy,
    dnx_data_l3_ecmp_define_member_table_nof_rows_size_in_bits,
    dnx_data_l3_ecmp_define_member_table_address_size_in_bits,
    dnx_data_l3_ecmp_define_ecmp_bank_size,
    dnx_data_l3_ecmp_define_nof_ecmp_banks_basic,
    dnx_data_l3_ecmp_define_nof_ecmp_banks_extended,
    dnx_data_l3_ecmp_define_nof_ecmp,
    dnx_data_l3_ecmp_define_profile_id_size,
    dnx_data_l3_ecmp_define_profile_id_offset,
    dnx_data_l3_ecmp_define_tunnel_priority_support,
    dnx_data_l3_ecmp_define_nof_tunnel_priority_map_profiles,
    dnx_data_l3_ecmp_define_tunnel_priority_field_width,
    dnx_data_l3_ecmp_define_tunnel_priority_index_field_width,
    dnx_data_l3_ecmp_define_consistent_mem_row_size_in_bits,
    dnx_data_l3_ecmp_define_consistent_bank_size_in_bits,
    dnx_data_l3_ecmp_define_ecmp_small_consistent_group_nof_entries,
    dnx_data_l3_ecmp_define_ecmp_small_consistent_group_entry_size_in_bits,
    dnx_data_l3_ecmp_define_nof_consistent_resources,

    /**
     * Must be last one!
     */
    _dnx_data_l3_ecmp_define_nof
} dnx_data_l3_ecmp_define_e;

/* Get Data */
/**
 * \brief returns define data of group_size_multiply_and_divide_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_multiply_and_divide_nof_bits'
 * The NOF bit of the multiply and division group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_multiply_and_divide_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_group_size_multiply_and_divide_nof_bits_get(
    int unit);

/**
 * \brief returns define data of group_size_consistent_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_consistent_nof_bits'
 * The NOF bit of the consistent group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_consistent_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_group_size_consistent_nof_bits_get(
    int unit);

/**
 * \brief returns define data of group_size_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_nof_bits'
 * The max NOF bit of the ECMP group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_group_size_nof_bits_get(
    int unit);

/**
 * \brief returns define data of max_group_size
 * Module - 'l3', Submodule - 'ecmp', data - 'max_group_size'
 * The maximal size of an ECMP group.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_group_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_max_group_size_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp_basic_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_basic_mode'
 * Number of ECMP groups that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_basic_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_basic_mode_get(
    int unit);

/**
 * \brief returns define data of total_nof_ecmp
 * Module - 'l3', Submodule - 'ecmp', data - 'total_nof_ecmp'
 * The total number of IDs that are considered to be in the ECMP range.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_total_nof_ecmp_get(
    int unit);

/**
 * \brief returns define data of max_ecmp_basic_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'max_ecmp_basic_mode'
 * Maximum ECMP group ID that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ecmp_basic_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_max_ecmp_basic_mode_get(
    int unit);

/**
 * \brief returns define data of max_ecmp_extended_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'max_ecmp_extended_mode'
 * Maximum ECMP group ID that can be created in extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ecmp_extended_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_max_ecmp_extended_mode_get(
    int unit);

/**
 * \brief returns define data of nof_extended_ecmp_per_failover_bank
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_extended_ecmp_per_failover_bank'
 * The upper 8k ECMP (from 32k to 40k) are placed in a memory shared by Failover and ECMP. The memory has 32 banks by 512 lines each.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_extended_ecmp_per_failover_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_extended_ecmp_per_failover_bank_get(
    int unit);

/**
 * \brief returns define data of nof_failover_banks_per_extended_ecmp_bank
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_failover_banks_per_extended_ecmp_bank'
 * nof fec protection banks to be used for 1 ecmp extended bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_failover_banks_per_extended_ecmp_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_failover_banks_per_extended_ecmp_bank_get(
    int unit);

/**
 * \brief returns define data of nof_group_profiles_per_hierarchy
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_group_profiles_per_hierarchy'
 * Number of profiles that are available for each ECMP hierarchy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_group_profiles_per_hierarchy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_get(
    int unit);

/**
 * \brief returns define data of member_table_nof_rows_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_nof_rows_size_in_bits'
 * The NOF bits required to represent the NOF rows in the consistent members memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_nof_rows_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_member_table_nof_rows_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of member_table_address_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_address_size_in_bits'
 * The member table address size in bits when it used by the ECMP profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_address_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_member_table_address_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of ecmp_bank_size
 * Module - 'l3', Submodule - 'ecmp', data - 'ecmp_bank_size'
 * The number of groups per HW bank. All groups in a bank belong to one hierarchy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecmp_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_ecmp_bank_size_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp_banks_basic
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_banks_basic'
 * The number of ECMP banks in the basic range of IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_banks_basic - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_banks_basic_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp_banks_extended
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_banks_extended'
 * The number of ECMP banks in the extended range of IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_banks_extended - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_banks_extended_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp'
 * Number of ECMPs in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_get(
    int unit);

/**
 * \brief returns define data of profile_id_size
 * Module - 'l3', Submodule - 'ecmp', data - 'profile_id_size'
 * The size of the profile ID field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     profile_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_profile_id_size_get(
    int unit);

/**
 * \brief returns define data of profile_id_offset
 * Module - 'l3', Submodule - 'ecmp', data - 'profile_id_offset'
 * The offset of the profile ID field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     profile_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_profile_id_offset_get(
    int unit);

/**
 * \brief returns define data of tunnel_priority_support
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_support'
 * Device has tunnel priority support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_tunnel_priority_support_get(
    int unit);

/**
 * \brief returns define data of nof_tunnel_priority_map_profiles
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_tunnel_priority_map_profiles'
 * The NOF tunnle priority map profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tunnel_priority_map_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_tunnel_priority_map_profiles_get(
    int unit);

/**
 * \brief returns define data of tunnel_priority_field_width
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_field_width'
 * The width in bits of the tunnel priority field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_field_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_tunnel_priority_field_width_get(
    int unit);

/**
 * \brief returns define data of tunnel_priority_index_field_width
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_index_field_width'
 * The size of the possible TP indexes field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_index_field_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_tunnel_priority_index_field_width_get(
    int unit);

/**
 * \brief returns define data of consistent_mem_row_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'consistent_mem_row_size_in_bits'
 * The size in bits of a row in the consistent members memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_mem_row_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_consistent_mem_row_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of consistent_bank_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'consistent_bank_size_in_bits'
 * The size of a single bank used for the consistent hashing members tables.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_bank_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_consistent_bank_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of ecmp_small_consistent_group_nof_entries
 * Module - 'l3', Submodule - 'ecmp', data - 'ecmp_small_consistent_group_nof_entries'
 * The nof entries in small consistent group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecmp_small_consistent_group_nof_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_ecmp_small_consistent_group_nof_entries_get(
    int unit);

/**
 * \brief returns define data of ecmp_small_consistent_group_entry_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'ecmp_small_consistent_group_entry_size_in_bits'
 * The nof bits for each entry in consistent small group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecmp_small_consistent_group_entry_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_ecmp_small_consistent_group_entry_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of nof_consistent_resources
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_consistent_resources'
 * The total number of consistent resources available
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_consistent_resources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_consistent_resources_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_ecmp_table_consistent_tables_info,

    /**
     * Must be last one!
     */
    _dnx_data_l3_ecmp_table_nof
} dnx_data_l3_ecmp_table_e;

/* Get Data */
/**
 * \brief get table consistent_tables_info entry 
 * information on the different consistent tables sizes
 * 
 * \param [in] unit - unit #
 * \param [in] table_type - The table type.
 * 
 * \return
 *     consistent_tables_info - returns the relevant entry values grouped in struct - see dnx_data_l3_ecmp_consistent_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_ecmp_consistent_tables_info_t * dnx_data_l3_ecmp_consistent_tables_info_get(
    int unit,
    int table_type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'ecmp', table - 'consistent_tables_info'
 * information on the different consistent tables sizes
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_ecmp_consistent_tables_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)consistent_tables_info info
 * information on the different consistent tables sizes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_tables_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_ecmp_consistent_tables_info_info_get(
    int unit);

/*
 * SUBMODULE VIP_ECMP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_vip_ecmp_feature_get(
    int unit,
    dnx_data_l3_vip_ecmp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_vip_ecmp_define_nof_vip_ecmp,
    dnx_data_l3_vip_ecmp_define_max_vip_ecmp_table_size,

    /**
     * Must be last one!
     */
    _dnx_data_l3_vip_ecmp_define_nof
} dnx_data_l3_vip_ecmp_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_vip_ecmp
 * Module - 'l3', Submodule - 'vip_ecmp', data - 'nof_vip_ecmp'
 * Number of VIP ECMP groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vip_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vip_ecmp_nof_vip_ecmp_get(
    int unit);

/**
 * \brief returns define data of max_vip_ecmp_table_size
 * Module - 'l3', Submodule - 'vip_ecmp', data - 'max_vip_ecmp_table_size'
 * Maximum number entries per VIP ECMP group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_vip_ecmp_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vip_ecmp_max_vip_ecmp_table_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vip_ecmp_table_nof
} dnx_data_l3_vip_ecmp_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE WCMP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_wcmp_feature_get(
    int unit,
    dnx_data_l3_wcmp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_wcmp_define_group_size_nof_bits,
    dnx_data_l3_wcmp_define_max_member_weight,
    dnx_data_l3_wcmp_define_member_weight_quant_factor,

    /**
     * Must be last one!
     */
    _dnx_data_l3_wcmp_define_nof
} dnx_data_l3_wcmp_define_e;

/* Get Data */
/**
 * \brief returns define data of group_size_nof_bits
 * Module - 'l3', Submodule - 'wcmp', data - 'group_size_nof_bits'
 * The max NOF bits of the WCMP group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_wcmp_group_size_nof_bits_get(
    int unit);

/**
 * \brief returns define data of max_member_weight
 * Module - 'l3', Submodule - 'wcmp', data - 'max_member_weight'
 * The max weight that can be assigned to a member of a WCMP group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_member_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_wcmp_max_member_weight_get(
    int unit);

/**
 * \brief returns define data of member_weight_quant_factor
 * Module - 'l3', Submodule - 'wcmp', data - 'member_weight_quant_factor'
 * Quantization factor used in the conversion of member's weight to HW units
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_weight_quant_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_wcmp_member_weight_quant_factor_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_wcmp_table_nof
} dnx_data_l3_wcmp_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE SOURCE_ADDRESS_ETHERNET:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_source_address_ethernet_feature_get(
    int unit,
    dnx_data_l3_source_address_ethernet_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_source_address_ethernet_define_nof_mymac_prefixes,

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_ethernet_define_nof
} dnx_data_l3_source_address_ethernet_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_mymac_prefixes
 * Module - 'l3', Submodule - 'source_address_ethernet', data - 'nof_mymac_prefixes'
 * Number of mymac prefixes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mymac_prefixes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_ethernet_table_nof
} dnx_data_l3_source_address_ethernet_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE VRRP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_vrrp_feature_get(
    int unit,
    dnx_data_l3_vrrp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_vrrp_define_nof_protocol_groups,
    dnx_data_l3_vrrp_define_nof_tcam_entries,
    dnx_data_l3_vrrp_define_nof_vsi_tcam_entries,
    dnx_data_l3_vrrp_define_nof_tcam_entries_used_by_exem,
    dnx_data_l3_vrrp_define_exem_vrid_ipv4_tcam_index,
    dnx_data_l3_vrrp_define_exem_vrid_ipv6_tcam_index,
    dnx_data_l3_vrrp_define_exem_default_tcam_index,
    dnx_data_l3_vrrp_define_exem_default_tcam_index_msb,
    dnx_data_l3_vrrp_define_vrrp_default_num_entries,
    dnx_data_l3_vrrp_define_is_multiple_my_mac_da_table_per_msb_bit,
    dnx_data_l3_vrrp_define_is_mapped_pp_port_used,
    dnx_data_l3_vrrp_define_nof_dbs,

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrrp_define_nof
} dnx_data_l3_vrrp_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_protocol_groups
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_protocol_groups'
 * Number of L3 protocol groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_protocol_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_nof_protocol_groups_get(
    int unit);

/**
 * \brief returns define data of nof_tcam_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_tcam_entries'
 * Size of VRRP TCAM table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_nof_tcam_entries_get(
    int unit);

/**
 * \brief returns define data of nof_vsi_tcam_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_vsi_tcam_entries'
 * Number of enries in VRRP TCAM table that can be used by VSI table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vsi_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_nof_vsi_tcam_entries_get(
    int unit);

/**
 * \brief returns define data of nof_tcam_entries_used_by_exem
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_tcam_entries_used_by_exem'
 * The number of TCAM entries used by the EXEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_entries_used_by_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_nof_tcam_entries_used_by_exem_get(
    int unit);

/**
 * \brief returns define data of exem_vrid_ipv4_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_vrid_ipv4_tcam_index'
 * TCAM index for EXEM VRRP VRID IPv4 protocol
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vrid_ipv4_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_get(
    int unit);

/**
 * \brief returns define data of exem_vrid_ipv6_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_vrid_ipv6_tcam_index'
 * TCAM index for EXEM VRRP VRID IPv6 protocol
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vrid_ipv6_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_get(
    int unit);

/**
 * \brief returns define data of exem_default_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_default_tcam_index'
 * TCAM index for EXEM VSI LSB, SOURCE PORT or SRC PORT-protocol multiple my mac
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_default_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_exem_default_tcam_index_get(
    int unit);

/**
 * \brief returns define data of exem_default_tcam_index_msb
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_default_tcam_index_msb'
 * TCAM index for EXEM VSI MSB multiple my mac
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_default_tcam_index_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_exem_default_tcam_index_msb_get(
    int unit);

/**
 * \brief returns define data of vrrp_default_num_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'vrrp_default_num_entries'
 * Number of default VRRP entries in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vrrp_default_num_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_vrrp_default_num_entries_get(
    int unit);

/**
 * \brief returns define data of is_multiple_my_mac_da_table_per_msb_bit
 * Module - 'l3', Submodule - 'vrrp', data - 'is_multiple_my_mac_da_table_per_msb_bit'
 * Indication if the VRRP table PER_VSI_MULTIPLE_MY_MAC_DA_MSB is split
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     is_multiple_my_mac_da_table_per_msb_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_is_multiple_my_mac_da_table_per_msb_bit_get(
    int unit);

/**
 * \brief returns define data of is_mapped_pp_port_used
 * Module - 'l3', Submodule - 'vrrp', data - 'is_mapped_pp_port_used'
 * Indication if mapped pp port is used in VRRP tables or in pp port as a key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     is_mapped_pp_port_used - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_is_mapped_pp_port_used_get(
    int unit);

/**
 * \brief returns define data of nof_dbs
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_dbs'
 * The number of physical DBs used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_nof_dbs_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_vrrp_table_vrrp_tables,
    dnx_data_l3_vrrp_table_data_bases,

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrrp_table_nof
} dnx_data_l3_vrrp_table_e;

/* Get Data */
/**
 * \brief get table vrrp_tables entry 
 * VRRP tables
 * 
 * \param [in] unit - unit #
 * \param [in] table_type - Table type.
 * 
 * \return
 *     vrrp_tables - returns the relevant entry values grouped in struct - see dnx_data_l3_vrrp_vrrp_tables_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_vrrp_vrrp_tables_t * dnx_data_l3_vrrp_vrrp_tables_get(
    int unit,
    int table_type);

/**
 * \brief get table data_bases entry 
 * Information about physical DBs used.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_bases - returns the relevant entry values grouped in struct - see dnx_data_l3_vrrp_data_bases_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_vrrp_data_bases_t * dnx_data_l3_vrrp_data_bases_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'vrrp', table - 'vrrp_tables'
 * VRRP tables
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_vrrp_vrrp_tables_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'vrrp', table - 'data_bases'
 * Information about physical DBs used.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_vrrp_data_bases_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)vrrp_tables info
 * VRRP tables
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vrrp_tables - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_vrrp_vrrp_tables_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)data_bases info
 * Information about physical DBs used.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_bases - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_vrrp_data_bases_info_get(
    int unit);

/*
 * SUBMODULE FEATURE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_feature_feature_get(
    int unit,
    dnx_data_l3_feature_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_feature_define_nof
} dnx_data_l3_feature_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_feature_table_nof
} dnx_data_l3_feature_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_L3_H_*/
/* *INDENT-ON* */
