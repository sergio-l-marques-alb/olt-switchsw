/** \file dnx_data_internal_sch.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_SCH_H_
/*{*/
#define _DNX_DATA_INTERNAL_SCH_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_sch.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_sch_submodule_general,
    dnx_data_sch_submodule_ps,
    dnx_data_sch_submodule_flow,
    dnx_data_sch_submodule_se,
    dnx_data_sch_submodule_interface,
    dnx_data_sch_submodule_device,
    dnx_data_sch_submodule_sch_alloc,
    dnx_data_sch_submodule_dbal,
    dnx_data_sch_submodule_features,
    dnx_data_sch_submodule_fc,

    /**
     * Must be last one!
     */
    _dnx_data_sch_submodule_nof
} dnx_data_sch_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GENERAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_general_feature_get(
    int unit,
    dnx_data_sch_general_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_sch_general_define_nof_slow_profiles,
    dnx_data_sch_general_define_nof_slow_levels,
    dnx_data_sch_general_define_cycles_per_credit_token,
    dnx_data_sch_general_define_nof_fmq_class,
    dnx_data_sch_general_define_port_priority_propagation_version,
    dnx_data_sch_general_define_port_priority_propagation_enable,

    /**
     * Must be last one!
     */
    _dnx_data_sch_general_define_nof
} dnx_data_sch_general_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_slow_profiles
 * Module - 'sch', Submodule - 'general', data - 'nof_slow_profiles'
 * Number of slow profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_slow_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_general_nof_slow_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_slow_levels
 * Module - 'sch', Submodule - 'general', data - 'nof_slow_levels'
 * Number of slow levels
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_slow_levels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_general_nof_slow_levels_get(
    int unit);

/**
 * \brief returns define data of cycles_per_credit_token
 * Module - 'sch', Submodule - 'general', data - 'cycles_per_credit_token'
 * Number of of cycles between credit tokens of the same flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cycles_per_credit_token - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_general_cycles_per_credit_token_get(
    int unit);

/**
 * \brief returns define data of nof_fmq_class
 * Module - 'sch', Submodule - 'general', data - 'nof_fmq_class'
 * Number of FMQ class
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fmq_class - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_general_nof_fmq_class_get(
    int unit);

/**
 * \brief returns numeric data of port_priority_propagation_version
 * Module - 'sch', Submodule - 'general', data - 'port_priority_propagation_version'
 * Port priority propagation version
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_priority_propagation_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_general_port_priority_propagation_version_get(
    int unit);

/**
 * \brief returns numeric data of port_priority_propagation_enable
 * Module - 'sch', Submodule - 'general', data - 'port_priority_propagation_enable'
 * Enable ports to be created with port priority propagation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_priority_propagation_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_general_port_priority_propagation_enable_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_sch_general_table_low_rate_factor_to_dbal_enum,
    dnx_data_sch_general_table_dbal_enum_to_low_rate_factor,
    dnx_data_sch_general_table_slow_rate_max_bucket,

    /**
     * Must be last one!
     */
    _dnx_data_sch_general_table_nof
} dnx_data_sch_general_table_e;

/* Get Data */
/**
 * \brief get table low_rate_factor_to_dbal_enum entry 
 * mapping low rate factor to dbal enum
 * 
 * \param [in] unit - unit #
 * \param [in] low_rate_factor - low rate factor
 * 
 * \return
 *     low_rate_factor_to_dbal_enum - returns the relevant entry values grouped in struct - see dnx_data_sch_general_low_rate_factor_to_dbal_enum_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_general_low_rate_factor_to_dbal_enum_t * dnx_data_sch_general_low_rate_factor_to_dbal_enum_get(
    int unit,
    int low_rate_factor);

/**
 * \brief get table dbal_enum_to_low_rate_factor entry 
 * mapping dbal enum to low rate factor
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_enum - low rate factor dbal enum
 * 
 * \return
 *     dbal_enum_to_low_rate_factor - returns the relevant entry values grouped in struct - see dnx_data_sch_general_dbal_enum_to_low_rate_factor_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_general_dbal_enum_to_low_rate_factor_t * dnx_data_sch_general_dbal_enum_to_low_rate_factor_get(
    int unit,
    int dbal_enum);

/**
 * \brief get table slow_rate_max_bucket entry 
 * Max token bucket values per slow rate
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * 
 * \return
 *     slow_rate_max_bucket - returns the relevant entry values grouped in struct - see dnx_data_sch_general_slow_rate_max_bucket_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_general_slow_rate_max_bucket_t * dnx_data_sch_general_slow_rate_max_bucket_get(
    int unit,
    int idx);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'general', table - 'low_rate_factor_to_dbal_enum'
 * mapping low rate factor to dbal enum
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_general_low_rate_factor_to_dbal_enum_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'general', table - 'dbal_enum_to_low_rate_factor'
 * mapping dbal enum to low rate factor
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_general_dbal_enum_to_low_rate_factor_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'general', table - 'slow_rate_max_bucket'
 * Max token bucket values per slow rate
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_general_slow_rate_max_bucket_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)low_rate_factor_to_dbal_enum info
 * mapping low rate factor to dbal enum
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     low_rate_factor_to_dbal_enum - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_general_low_rate_factor_to_dbal_enum_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dbal_enum_to_low_rate_factor info
 * mapping dbal enum to low rate factor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbal_enum_to_low_rate_factor - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_general_dbal_enum_to_low_rate_factor_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)slow_rate_max_bucket info
 * Max token bucket values per slow rate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     slow_rate_max_bucket - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_general_slow_rate_max_bucket_info_get(
    int unit);

/*
 * SUBMODULE PS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_ps_feature_get(
    int unit,
    dnx_data_sch_ps_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_sch_ps_define_min_priority_for_tcg,
    dnx_data_sch_ps_define_max_nof_tcg,
    dnx_data_sch_ps_define_nof_hrs_in_ps,
    dnx_data_sch_ps_define_max_tcg_weight,
    dnx_data_sch_ps_define_tc_tcg_calendar_access_period,
    dnx_data_sch_ps_define_max_port_rate_mbps,
    dnx_data_sch_ps_define_max_burst,
    dnx_data_sch_ps_define_assigned_credit_worth_multiplier,

    /**
     * Must be last one!
     */
    _dnx_data_sch_ps_define_nof
} dnx_data_sch_ps_define_e;

/* Get Data */
/**
 * \brief returns define data of min_priority_for_tcg
 * Module - 'sch', Submodule - 'ps', data - 'min_priority_for_tcg'
 * Minimal port priority supporting tcg
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_priority_for_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_ps_min_priority_for_tcg_get(
    int unit);

/**
 * \brief returns define data of max_nof_tcg
 * Module - 'sch', Submodule - 'ps', data - 'max_nof_tcg'
 * Maximal number of TCGs in a port scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_ps_max_nof_tcg_get(
    int unit);

/**
 * \brief returns define data of nof_hrs_in_ps
 * Module - 'sch', Submodule - 'ps', data - 'nof_hrs_in_ps'
 * Number of HRs in port scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hrs_in_ps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_ps_nof_hrs_in_ps_get(
    int unit);

/**
 * \brief returns define data of max_tcg_weight
 * Module - 'sch', Submodule - 'ps', data - 'max_tcg_weight'
 * Maximal TCG EIR weight
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tcg_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_ps_max_tcg_weight_get(
    int unit);

/**
 * \brief returns define data of tc_tcg_calendar_access_period
 * Module - 'sch', Submodule - 'ps', data - 'tc_tcg_calendar_access_period'
 * Access period of TC/TCG calendars
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tc_tcg_calendar_access_period - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_ps_tc_tcg_calendar_access_period_get(
    int unit);

/**
 * \brief returns numeric data of max_port_rate_mbps
 * Module - 'sch', Submodule - 'ps', data - 'max_port_rate_mbps'
 * maximal rate an port can drive (in MBits/sec)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_port_rate_mbps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_ps_max_port_rate_mbps_get(
    int unit);

/**
 * \brief returns numeric data of max_burst
 * Module - 'sch', Submodule - 'ps', data - 'max_burst'
 * Maximal burst of TC/TCG port shapers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_burst - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_ps_max_burst_get(
    int unit);

/**
 * \brief returns numeric data of assigned_credit_worth_multiplier
 * Module - 'sch', Submodule - 'ps', data - 'assigned_credit_worth_multiplier'
 * Used when calculating minimal max burst allowed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     assigned_credit_worth_multiplier - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_ps_assigned_credit_worth_multiplier_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_ps_table_nof
} dnx_data_sch_ps_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FLOW:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_flow_feature_get(
    int unit,
    dnx_data_sch_flow_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_sch_flow_define_nof_hr,
    dnx_data_sch_flow_define_nof_cl,
    dnx_data_sch_flow_define_nof_se,
    dnx_data_sch_flow_define_nof_flows,
    dnx_data_sch_flow_define_region_size,
    dnx_data_sch_flow_define_nof_regions,
    dnx_data_sch_flow_define_nof_hr_regions,
    dnx_data_sch_flow_define_nof_connectors_only_regions,
    dnx_data_sch_flow_define_flow_in_region_mask,
    dnx_data_sch_flow_define_min_connector_bundle_size,
    dnx_data_sch_flow_define_conn_idx_interdig_flow,
    dnx_data_sch_flow_define_shaper_flipflops_nof,
    dnx_data_sch_flow_define_nof_flows_in_quartet_order_group,
    dnx_data_sch_flow_define_nof_regions_in_quartet_order_group,
    dnx_data_sch_flow_define_nof_quartet_order_groups,
    dnx_data_sch_flow_define_erp_hr,
    dnx_data_sch_flow_define_reserved_hr,
    dnx_data_sch_flow_define_max_se,
    dnx_data_sch_flow_define_max_flow,
    dnx_data_sch_flow_define_first_hr_region,
    dnx_data_sch_flow_define_first_se_flow_id,
    dnx_data_sch_flow_define_hr_se_id_min,
    dnx_data_sch_flow_define_hr_se_id_max,
    dnx_data_sch_flow_define_virtual_flow_mapped_queue,
    dnx_data_sch_flow_define_default_credit_source_se_id,
    dnx_data_sch_flow_define_runtime_performance_optimize_enable_sched_allocation,

    /**
     * Must be last one!
     */
    _dnx_data_sch_flow_define_nof
} dnx_data_sch_flow_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_hr
 * Module - 'sch', Submodule - 'flow', data - 'nof_hr'
 * Number of HR elements per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hr - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_hr_get(
    int unit);

/**
 * \brief returns define data of nof_cl
 * Module - 'sch', Submodule - 'flow', data - 'nof_cl'
 * Number of CL elements per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cl - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_cl_get(
    int unit);

/**
 * \brief returns define data of nof_se
 * Module - 'sch', Submodule - 'flow', data - 'nof_se'
 * Number of scheduling elements per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_se - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_se_get(
    int unit);

/**
 * \brief returns define data of nof_flows
 * Module - 'sch', Submodule - 'flow', data - 'nof_flows'
 * Number of flows per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_flows - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_flows_get(
    int unit);

/**
 * \brief returns define data of region_size
 * Module - 'sch', Submodule - 'flow', data - 'region_size'
 * Number of flows in a region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     region_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_region_size_get(
    int unit);

/**
 * \brief returns define data of nof_regions
 * Module - 'sch', Submodule - 'flow', data - 'nof_regions'
 * Number of regions in a core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_regions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_regions_get(
    int unit);

/**
 * \brief returns define data of nof_hr_regions
 * Module - 'sch', Submodule - 'flow', data - 'nof_hr_regions'
 * Number of hr regions in a core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hr_regions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_hr_regions_get(
    int unit);

/**
 * \brief returns define data of nof_connectors_only_regions
 * Module - 'sch', Submodule - 'flow', data - 'nof_connectors_only_regions'
 * Number of connectors-only regions per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_connectors_only_regions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_connectors_only_regions_get(
    int unit);

/**
 * \brief returns define data of flow_in_region_mask
 * Module - 'sch', Submodule - 'flow', data - 'flow_in_region_mask'
 * mask for flows in region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_in_region_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_flow_in_region_mask_get(
    int unit);

/**
 * \brief returns define data of min_connector_bundle_size
 * Module - 'sch', Submodule - 'flow', data - 'min_connector_bundle_size'
 * minimal number of connectors in bundle
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_connector_bundle_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_min_connector_bundle_size_get(
    int unit);

/**
 * \brief returns define data of conn_idx_interdig_flow
 * Module - 'sch', Submodule - 'flow', data - 'conn_idx_interdig_flow'
 * first connector index in an interdigitated flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     conn_idx_interdig_flow - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_conn_idx_interdig_flow_get(
    int unit);

/**
 * \brief returns define data of shaper_flipflops_nof
 * Module - 'sch', Submodule - 'flow', data - 'shaper_flipflops_nof'
 * number of Flip-Flops in flow shaper implementation in HW.                     if exp greater than (shaper_flipflops_nof - nof_manthissa_bits)) then mantissa[exp-(shaper_flipflops_nof-nof_mantissa_bits)-1: 0] == 0
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shaper_flipflops_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_shaper_flipflops_nof_get(
    int unit);

/**
 * \brief returns define data of nof_flows_in_quartet_order_group
 * Module - 'sch', Submodule - 'flow', data - 'nof_flows_in_quartet_order_group'
 * Number of flows in a quartet order group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_flows_in_quartet_order_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_flows_in_quartet_order_group_get(
    int unit);

/**
 * \brief returns define data of nof_regions_in_quartet_order_group
 * Module - 'sch', Submodule - 'flow', data - 'nof_regions_in_quartet_order_group'
 * Number of regions in a quartet order group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_regions_in_quartet_order_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_regions_in_quartet_order_group_get(
    int unit);

/**
 * \brief returns define data of nof_quartet_order_groups
 * Module - 'sch', Submodule - 'flow', data - 'nof_quartet_order_groups'
 * Number of quartet order groups in a core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_quartet_order_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_nof_quartet_order_groups_get(
    int unit);

/**
 * \brief returns numeric data of erp_hr
 * Module - 'sch', Submodule - 'flow', data - 'erp_hr'
 * HR id of first ERP HR
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     erp_hr - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_erp_hr_get(
    int unit);

/**
 * \brief returns numeric data of reserved_hr
 * Module - 'sch', Submodule - 'flow', data - 'reserved_hr'
 * reserved HR allocated for returned credits in LAG scheduling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved_hr - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_reserved_hr_get(
    int unit);

/**
 * \brief returns numeric data of max_se
 * Module - 'sch', Submodule - 'flow', data - 'max_se'
 * Maximal Scheduling element id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_se - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_max_se_get(
    int unit);

/**
 * \brief returns numeric data of max_flow
 * Module - 'sch', Submodule - 'flow', data - 'max_flow'
 * Maximal flow id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_flow - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_max_flow_get(
    int unit);

/**
 * \brief returns numeric data of first_hr_region
 * Module - 'sch', Submodule - 'flow', data - 'first_hr_region'
 * First HR region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_hr_region - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_first_hr_region_get(
    int unit);

/**
 * \brief returns numeric data of first_se_flow_id
 * Module - 'sch', Submodule - 'flow', data - 'first_se_flow_id'
 * Flow ID of first scheduling element
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_se_flow_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_first_se_flow_id_get(
    int unit);

/**
 * \brief returns numeric data of hr_se_id_min
 * Module - 'sch', Submodule - 'flow', data - 'hr_se_id_min'
 * min hr se id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hr_se_id_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_hr_se_id_min_get(
    int unit);

/**
 * \brief returns numeric data of hr_se_id_max
 * Module - 'sch', Submodule - 'flow', data - 'hr_se_id_max'
 * max hr se id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hr_se_id_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_hr_se_id_max_get(
    int unit);

/**
 * \brief returns numeric data of virtual_flow_mapped_queue
 * Module - 'sch', Submodule - 'flow', data - 'virtual_flow_mapped_queue'
 * VOQ that virtual flows should be mapped to
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     virtual_flow_mapped_queue - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_virtual_flow_mapped_queue_get(
    int unit);

/**
 * \brief returns numeric data of default_credit_source_se_id
 * Module - 'sch', Submodule - 'flow', data - 'default_credit_source_se_id'
 * SE ID of default credit source. used to mark unattached flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_credit_source_se_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_default_credit_source_se_id_get(
    int unit);

/**
 * \brief returns numeric data of runtime_performance_optimize_enable_sched_allocation
 * Module - 'sch', Submodule - 'flow', data - 'runtime_performance_optimize_enable_sched_allocation'
 * enable flow properties access optimization
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     runtime_performance_optimize_enable_sched_allocation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_flow_runtime_performance_optimize_enable_sched_allocation_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_sch_flow_table_region_type,
    dnx_data_sch_flow_table_nof_remote_cores,
    dnx_data_sch_flow_table_quartet_type,
    dnx_data_sch_flow_table_quartet_index_conversion,

    /**
     * Must be last one!
     */
    _dnx_data_sch_flow_table_nof
} dnx_data_sch_flow_table_e;

/* Get Data */
/**
 * \brief get table region_type entry 
 * flow region type
 * 
 * \param [in] unit - unit #
 * \param [in] core - see table doc
 * \param [in] region - see table doc
 * 
 * \return
 *     region_type - returns the relevant entry values grouped in struct - see dnx_data_sch_flow_region_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_flow_region_type_t * dnx_data_sch_flow_region_type_get(
    int unit,
    int core,
    int region);

/**
 * \brief get table nof_remote_cores entry 
 * flow region type
 * 
 * \param [in] unit - unit #
 * \param [in] core - see table doc
 * \param [in] region - see table doc
 * 
 * \return
 *     nof_remote_cores - returns the relevant entry values grouped in struct - see dnx_data_sch_flow_nof_remote_cores_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_flow_nof_remote_cores_t * dnx_data_sch_flow_nof_remote_cores_get(
    int unit,
    int core,
    int region);

/**
 * \brief get table quartet_type entry 
 * quartet type per group
 * 
 * \param [in] unit - unit #
 * \param [in] core - see table doc
 * \param [in] group - see table doc
 * 
 * \return
 *     quartet_type - returns the relevant entry values grouped in struct - see dnx_data_sch_flow_quartet_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_flow_quartet_type_t * dnx_data_sch_flow_quartet_type_get(
    int unit,
    int core,
    int group);

/**
 * \brief get table quartet_index_conversion entry 
 * conversion of quartet index
 * 
 * \param [in] unit - unit #
 * \param [in] quartet_type - quartet type
 * 
 * \return
 *     quartet_index_conversion - returns the relevant entry values grouped in struct - see dnx_data_sch_flow_quartet_index_conversion_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_flow_quartet_index_conversion_t * dnx_data_sch_flow_quartet_index_conversion_get(
    int unit,
    int quartet_type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'flow', table - 'region_type'
 * flow region type
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_flow_region_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'flow', table - 'nof_remote_cores'
 * flow region type
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_flow_nof_remote_cores_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'flow', table - 'quartet_type'
 * quartet type per group
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_flow_quartet_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'flow', table - 'quartet_index_conversion'
 * conversion of quartet index
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_flow_quartet_index_conversion_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)region_type info
 * flow region type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     region_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_flow_region_type_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)nof_remote_cores info
 * flow region type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_remote_cores - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_flow_nof_remote_cores_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)quartet_type info
 * quartet type per group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     quartet_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_flow_quartet_type_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)quartet_index_conversion info
 * conversion of quartet index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     quartet_index_conversion - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_flow_quartet_index_conversion_info_get(
    int unit);

/*
 * SUBMODULE SE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_se_feature_get(
    int unit,
    dnx_data_sch_se_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_sch_se_define_default_cos,
    dnx_data_sch_se_define_nof_color_group,
    dnx_data_sch_se_define_max_hr_weight,
    dnx_data_sch_se_define_cl_class_profile_nof,

    /**
     * Must be last one!
     */
    _dnx_data_sch_se_define_nof
} dnx_data_sch_se_define_e;

/* Get Data */
/**
 * \brief returns define data of default_cos
 * Module - 'sch', Submodule - 'se', data - 'default_cos'
 * default parameter of credit source COS. Used for FQ
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_cos - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_se_default_cos_get(
    int unit);

/**
 * \brief returns define data of nof_color_group
 * Module - 'sch', Submodule - 'se', data - 'nof_color_group'
 * number of colors (groups)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_color_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_se_nof_color_group_get(
    int unit);

/**
 * \brief returns define data of max_hr_weight
 * Module - 'sch', Submodule - 'se', data - 'max_hr_weight'
 * maximal weight in HR WFQ
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_hr_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_se_max_hr_weight_get(
    int unit);

/**
 * \brief returns define data of cl_class_profile_nof
 * Module - 'sch', Submodule - 'se', data - 'cl_class_profile_nof'
 * number of profiles for CL class
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cl_class_profile_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_se_cl_class_profile_nof_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_sch_se_table_quartet_offset_to_cl_num,

    /**
     * Must be last one!
     */
    _dnx_data_sch_se_table_nof
} dnx_data_sch_se_table_e;

/* Get Data */
/**
 * \brief get table quartet_offset_to_cl_num entry 
 * mapping quartet index to CL number
 * 
 * \param [in] unit - unit #
 * \param [in] quartet_offset - quartet offset
 * 
 * \return
 *     quartet_offset_to_cl_num - returns the relevant entry values grouped in struct - see dnx_data_sch_se_quartet_offset_to_cl_num_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_se_quartet_offset_to_cl_num_t * dnx_data_sch_se_quartet_offset_to_cl_num_get(
    int unit,
    int quartet_offset);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'se', table - 'quartet_offset_to_cl_num'
 * mapping quartet index to CL number
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_se_quartet_offset_to_cl_num_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)quartet_offset_to_cl_num info
 * mapping quartet index to CL number
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     quartet_offset_to_cl_num - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_se_quartet_offset_to_cl_num_info_get(
    int unit);

/*
 * SUBMODULE INTERFACE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_interface_feature_get(
    int unit,
    dnx_data_sch_interface_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_sch_interface_define_nof_big_calendars,
    dnx_data_sch_interface_define_nof_channelized_calendars,
    dnx_data_sch_interface_define_max_calendar_size,
    dnx_data_sch_interface_define_nof_sch_interfaces,
    dnx_data_sch_interface_define_cal_speed_resolution,
    dnx_data_sch_interface_define_reserved,
    dnx_data_sch_interface_define_max_if_rate_mbps,

    /**
     * Must be last one!
     */
    _dnx_data_sch_interface_define_nof
} dnx_data_sch_interface_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_big_calendars
 * Module - 'sch', Submodule - 'interface', data - 'nof_big_calendars'
 * Number of big calendars per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_interface_nof_big_calendars_get(
    int unit);

/**
 * \brief returns define data of nof_channelized_calendars
 * Module - 'sch', Submodule - 'interface', data - 'nof_channelized_calendars'
 * Number of channelized calendars per core (both big and regular)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channelized_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_interface_nof_channelized_calendars_get(
    int unit);

/**
 * \brief returns define data of max_calendar_size
 * Module - 'sch', Submodule - 'interface', data - 'max_calendar_size'
 * Max size of calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_interface_max_calendar_size_get(
    int unit);

/**
 * \brief returns define data of nof_sch_interfaces
 * Module - 'sch', Submodule - 'interface', data - 'nof_sch_interfaces'
 * Number of sch interfaces per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_sch_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_interface_nof_sch_interfaces_get(
    int unit);

/**
 * \brief returns define data of cal_speed_resolution
 * Module - 'sch', Submodule - 'interface', data - 'cal_speed_resolution'
 * Resolution of interface calendar processing speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_speed_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_interface_cal_speed_resolution_get(
    int unit);

/**
 * \brief returns define data of reserved
 * Module - 'sch', Submodule - 'interface', data - 'reserved'
 * Reserved SCH interface to disable interface level FC in case of LAG scheduling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_interface_reserved_get(
    int unit);

/**
 * \brief returns numeric data of max_if_rate_mbps
 * Module - 'sch', Submodule - 'interface', data - 'max_if_rate_mbps'
 * maximal rate an interface can drive (in MBits/sec)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_if_rate_mbps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_interface_max_if_rate_mbps_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_sch_interface_table_shaper_resolution,

    /**
     * Must be last one!
     */
    _dnx_data_sch_interface_table_nof
} dnx_data_sch_interface_table_e;

/* Get Data */
/**
 * \brief get table shaper_resolution entry 
 * shaper resolution for channelized/non channelized interface
 * 
 * \param [in] unit - unit #
 * \param [in] channelized - is interface channelized
 * 
 * \return
 *     shaper_resolution - returns the relevant entry values grouped in struct - see dnx_data_sch_interface_shaper_resolution_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_interface_shaper_resolution_t * dnx_data_sch_interface_shaper_resolution_get(
    int unit,
    int channelized);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'interface', table - 'shaper_resolution'
 * shaper resolution for channelized/non channelized interface
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_interface_shaper_resolution_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)shaper_resolution info
 * shaper resolution for channelized/non channelized interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shaper_resolution - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_interface_shaper_resolution_info_get(
    int unit);

/*
 * SUBMODULE DEVICE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_device_feature_get(
    int unit,
    dnx_data_sch_device_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_sch_device_define_drm_resolution,

    /**
     * Must be last one!
     */
    _dnx_data_sch_device_define_nof
} dnx_data_sch_device_define_e;

/* Get Data */
/**
 * \brief returns define data of drm_resolution
 * Module - 'sch', Submodule - 'device', data - 'drm_resolution'
 * resolution of DRM rate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     drm_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_device_drm_resolution_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_device_table_nof
} dnx_data_sch_device_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE SCH_ALLOC:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_sch_alloc_feature_get(
    int unit,
    dnx_data_sch_sch_alloc_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_sch_sch_alloc_define_tag_aggregate_se_2,
    dnx_data_sch_sch_alloc_define_tag_aggregate_se_4,
    dnx_data_sch_sch_alloc_define_tag_aggregate_se_8,
    dnx_data_sch_sch_alloc_define_shared_shaper_max_tag_value,
    dnx_data_sch_sch_alloc_define_tag_size_aggregate_se,
    dnx_data_sch_sch_alloc_define_tag_size_con,
    dnx_data_sch_sch_alloc_define_type_con_reg_start,
    dnx_data_sch_sch_alloc_define_alloc_invalid_flow,
    dnx_data_sch_sch_alloc_define_dealloc_flow_ids,
    dnx_data_sch_sch_alloc_define_type_con_reg_end,
    dnx_data_sch_sch_alloc_define_type_hr_reg_start,

    /**
     * Must be last one!
     */
    _dnx_data_sch_sch_alloc_define_nof
} dnx_data_sch_sch_alloc_define_e;

/* Get Data */
/**
 * \brief returns define data of tag_aggregate_se_2
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_aggregate_se_2'
 * 2 SE aggregate tag
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_aggregate_se_2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_tag_aggregate_se_2_get(
    int unit);

/**
 * \brief returns define data of tag_aggregate_se_4
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_aggregate_se_4'
 * 4 SE aggregate tag
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_aggregate_se_4 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_tag_aggregate_se_4_get(
    int unit);

/**
 * \brief returns define data of tag_aggregate_se_8
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_aggregate_se_8'
 * 8 SE aggregate tag
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_aggregate_se_8 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_tag_aggregate_se_8_get(
    int unit);

/**
 * \brief returns define data of shared_shaper_max_tag_value
 * Module - 'sch', Submodule - 'sch_alloc', data - 'shared_shaper_max_tag_value'
 * max tag value for shared shaper
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shared_shaper_max_tag_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_shared_shaper_max_tag_value_get(
    int unit);

/**
 * \brief returns define data of tag_size_aggregate_se
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_size_aggregate_se'
 * tag size for SE aggregate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_size_aggregate_se - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_tag_size_aggregate_se_get(
    int unit);

/**
 * \brief returns define data of tag_size_con
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_size_con'
 * tag size for connectors - modid
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_size_con - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_tag_size_con_get(
    int unit);

/**
 * \brief returns define data of type_con_reg_start
 * Module - 'sch', Submodule - 'sch_alloc', data - 'type_con_reg_start'
 * start of the connectors only region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_con_reg_start - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_type_con_reg_start_get(
    int unit);

/**
 * \brief returns define data of alloc_invalid_flow
 * Module - 'sch', Submodule - 'sch_alloc', data - 'alloc_invalid_flow'
 * invalid flow define
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     alloc_invalid_flow - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_alloc_invalid_flow_get(
    int unit);

/**
 * \brief returns define data of dealloc_flow_ids
 * Module - 'sch', Submodule - 'sch_alloc', data - 'dealloc_flow_ids'
 * max number of flows to deallocate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dealloc_flow_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_dealloc_flow_ids_get(
    int unit);

/**
 * \brief returns numeric data of type_con_reg_end
 * Module - 'sch', Submodule - 'sch_alloc', data - 'type_con_reg_end'
 * end of the connectors only region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_con_reg_end - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_type_con_reg_end_get(
    int unit);

/**
 * \brief returns numeric data of type_hr_reg_start
 * Module - 'sch', Submodule - 'sch_alloc', data - 'type_hr_reg_start'
 * searching start of the HR region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_hr_reg_start - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_sch_alloc_type_hr_reg_start_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_sch_sch_alloc_table_region,
    dnx_data_sch_sch_alloc_table_connector,
    dnx_data_sch_sch_alloc_table_se_per_region_type,
    dnx_data_sch_sch_alloc_table_se,
    dnx_data_sch_sch_alloc_table_composite_se_per_region_type,
    dnx_data_sch_sch_alloc_table_composite_se,

    /**
     * Must be last one!
     */
    _dnx_data_sch_sch_alloc_table_nof
} dnx_data_sch_sch_alloc_table_e;

/* Get Data */
/**
 * \brief get table region entry 
 * content of quartet in each region type
 * 
 * \param [in] unit - unit #
 * \param [in] quartet_type - quartet type
 * \param [in] region_type - region type
 * 
 * \return
 *     region - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_region_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_sch_alloc_region_t * dnx_data_sch_sch_alloc_region_get(
    int unit,
    int quartet_type,
    int region_type);

/**
 * \brief get table connector entry 
 * allocation info for VOQ connectors
 * 
 * \param [in] unit - unit #
 * \param [in] composite - is composite connector
 * \param [in] interdigitated - is interdigitated
 * 
 * \return
 *     connector - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_connector_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_sch_alloc_connector_t * dnx_data_sch_sch_alloc_connector_get(
    int unit,
    int composite,
    int interdigitated);

/**
 * \brief get table se_per_region_type entry 
 * allocation info for scheduling elements per region type
 * 
 * \param [in] unit - unit #
 * \param [in] flow_type - type of element
 * \param [in] region_type - type of region
 * 
 * \return
 *     se_per_region_type - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_se_per_region_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_sch_alloc_se_per_region_type_t * dnx_data_sch_sch_alloc_se_per_region_type_get(
    int unit,
    int flow_type,
    int region_type);

/**
 * \brief get table se entry 
 * allocation info for scheduling elements
 * 
 * \param [in] unit - unit #
 * \param [in] flow_type - type of element
 * 
 * \return
 *     se - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_se_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_sch_alloc_se_t * dnx_data_sch_sch_alloc_se_get(
    int unit,
    int flow_type);

/**
 * \brief get table composite_se_per_region_type entry 
 * allocation info for composite scheduling elements per region type
 * 
 * \param [in] unit - unit #
 * \param [in] flow_type - type of element
 * \param [in] region_type - type of region
 * 
 * \return
 *     composite_se_per_region_type - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_composite_se_per_region_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_sch_alloc_composite_se_per_region_type_t * dnx_data_sch_sch_alloc_composite_se_per_region_type_get(
    int unit,
    int flow_type,
    int region_type);

/**
 * \brief get table composite_se entry 
 * allocation info for composite scheduling elements
 * 
 * \param [in] unit - unit #
 * \param [in] flow_type - type of element
 * \param [in] odd_even_mode - odd or even region
 * 
 * \return
 *     composite_se - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_composite_se_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_sch_sch_alloc_composite_se_t * dnx_data_sch_sch_alloc_composite_se_get(
    int unit,
    int flow_type,
    int odd_even_mode);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'sch_alloc', table - 'region'
 * content of quartet in each region type
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_sch_alloc_region_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'sch_alloc', table - 'connector'
 * allocation info for VOQ connectors
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_sch_alloc_connector_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'sch_alloc', table - 'se_per_region_type'
 * allocation info for scheduling elements per region type
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_sch_alloc_se_per_region_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'sch_alloc', table - 'se'
 * allocation info for scheduling elements
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_sch_alloc_se_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'sch_alloc', table - 'composite_se_per_region_type'
 * allocation info for composite scheduling elements per region type
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_sch_alloc_composite_se_per_region_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'sch', Submodule - 'sch_alloc', table - 'composite_se'
 * allocation info for composite scheduling elements
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_sch_alloc_composite_se_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)region info
 * content of quartet in each region type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     region - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_sch_alloc_region_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)connector info
 * allocation info for VOQ connectors
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     connector - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_sch_alloc_connector_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)se_per_region_type info
 * allocation info for scheduling elements per region type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     se_per_region_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_sch_alloc_se_per_region_type_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)se info
 * allocation info for scheduling elements
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     se - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_sch_alloc_se_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)composite_se_per_region_type info
 * allocation info for composite scheduling elements per region type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     composite_se_per_region_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_sch_alloc_composite_se_per_region_type_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)composite_se info
 * allocation info for composite scheduling elements
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     composite_se - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_sch_sch_alloc_composite_se_info_get(
    int unit);

/*
 * SUBMODULE DBAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_dbal_feature_get(
    int unit,
    dnx_data_sch_dbal_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_sch_dbal_define_scheduler_enable_grouping_factor,
    dnx_data_sch_dbal_define_scheduler_enable_dbal_mult_factor,
    dnx_data_sch_dbal_define_flow_bits,
    dnx_data_sch_dbal_define_se_bits,
    dnx_data_sch_dbal_define_cl_bits,
    dnx_data_sch_dbal_define_hr_bits,
    dnx_data_sch_dbal_define_interface_bits,
    dnx_data_sch_dbal_define_calendar_bits,
    dnx_data_sch_dbal_define_flow_shaper_mant_bits,
    dnx_data_sch_dbal_define_ps_shaper_quanta_bits,
    dnx_data_sch_dbal_define_ps_shaper_max_burst_bits,
    dnx_data_sch_dbal_define_drm_nof_links_max,
    dnx_data_sch_dbal_define_token_count_default,
    dnx_data_sch_dbal_define_priority_propagation_if_group_max,
    dnx_data_sch_dbal_define_max_sch_interfaces_with_fc,
    dnx_data_sch_dbal_define_scheduler_enable_key_size,
    dnx_data_sch_dbal_define_flow_id_pair_key_size,
    dnx_data_sch_dbal_define_flow_id_pair_max,
    dnx_data_sch_dbal_define_ps_bits,
    dnx_data_sch_dbal_define_flow_shaper_descr_bits,
    dnx_data_sch_dbal_define_ps_shaper_bits,
    dnx_data_sch_dbal_define_cl_profile_bits,
    dnx_data_sch_dbal_define_priority_propagation_if_group_nof_bits,

    /**
     * Must be last one!
     */
    _dnx_data_sch_dbal_define_nof
} dnx_data_sch_dbal_define_e;

/* Get Data */
/**
 * \brief returns define data of scheduler_enable_grouping_factor
 * Module - 'sch', Submodule - 'dbal', data - 'scheduler_enable_grouping_factor'
 * size of group of sched elements sharing the same HW field 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     scheduler_enable_grouping_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_scheduler_enable_grouping_factor_get(
    int unit);

/**
 * \brief returns define data of scheduler_enable_dbal_mult_factor
 * Module - 'sch', Submodule - 'dbal', data - 'scheduler_enable_dbal_mult_factor'
 * DBAL multiplication factor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     scheduler_enable_dbal_mult_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_scheduler_enable_dbal_mult_factor_get(
    int unit);

/**
 * \brief returns define data of flow_bits
 * Module - 'sch', Submodule - 'dbal', data - 'flow_bits'
 * Number of bits in flow id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_flow_bits_get(
    int unit);

/**
 * \brief returns define data of se_bits
 * Module - 'sch', Submodule - 'dbal', data - 'se_bits'
 * Number of bits in Scheduling element id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     se_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_se_bits_get(
    int unit);

/**
 * \brief returns define data of cl_bits
 * Module - 'sch', Submodule - 'dbal', data - 'cl_bits'
 * Number of bits in CL id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cl_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_cl_bits_get(
    int unit);

/**
 * \brief returns define data of hr_bits
 * Module - 'sch', Submodule - 'dbal', data - 'hr_bits'
 * Number of bits in HR id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hr_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_hr_bits_get(
    int unit);

/**
 * \brief returns define data of interface_bits
 * Module - 'sch', Submodule - 'dbal', data - 'interface_bits'
 * Number of bits in interface id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interface_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_interface_bits_get(
    int unit);

/**
 * \brief returns define data of calendar_bits
 * Module - 'sch', Submodule - 'dbal', data - 'calendar_bits'
 * Number of bits in calendar id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     calendar_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_calendar_bits_get(
    int unit);

/**
 * \brief returns define data of flow_shaper_mant_bits
 * Module - 'sch', Submodule - 'dbal', data - 'flow_shaper_mant_bits'
 * Number of bits in flow shaper mantissa
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_shaper_mant_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_flow_shaper_mant_bits_get(
    int unit);

/**
 * \brief returns define data of ps_shaper_quanta_bits
 * Module - 'sch', Submodule - 'dbal', data - 'ps_shaper_quanta_bits'
 * number of bits in PS shaper quanta
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ps_shaper_quanta_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_ps_shaper_quanta_bits_get(
    int unit);

/**
 * \brief returns define data of ps_shaper_max_burst_bits
 * Module - 'sch', Submodule - 'dbal', data - 'ps_shaper_max_burst_bits'
 * number of bits in PS shaper max burst
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ps_shaper_max_burst_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_ps_shaper_max_burst_bits_get(
    int unit);

/**
 * \brief returns define data of drm_nof_links_max
 * Module - 'sch', Submodule - 'dbal', data - 'drm_nof_links_max'
 * maximal value of number of links for DRM table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     drm_nof_links_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_drm_nof_links_max_get(
    int unit);

/**
 * \brief returns define data of token_count_default
 * Module - 'sch', Submodule - 'dbal', data - 'token_count_default'
 * default value of token count
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     token_count_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_token_count_default_get(
    int unit);

/**
 * \brief returns define data of priority_propagation_if_group_max
 * Module - 'sch', Submodule - 'dbal', data - 'priority_propagation_if_group_max'
 * Max value for interface groups used for prioririty propagation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     priority_propagation_if_group_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_priority_propagation_if_group_max_get(
    int unit);

/**
 * \brief returns define data of max_sch_interfaces_with_fc
 * Module - 'sch', Submodule - 'dbal', data - 'max_sch_interfaces_with_fc'
 * Max number of scheduler inerfaces that supports flow control
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_sch_interfaces_with_fc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_max_sch_interfaces_with_fc_get(
    int unit);

/**
 * \brief returns numeric data of scheduler_enable_key_size
 * Module - 'sch', Submodule - 'dbal', data - 'scheduler_enable_key_size'
 * size in bits of key in scheduler enable DBAL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     scheduler_enable_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_scheduler_enable_key_size_get(
    int unit);

/**
 * \brief returns numeric data of flow_id_pair_key_size
 * Module - 'sch', Submodule - 'dbal', data - 'flow_id_pair_key_size'
 * size in bits of half flow id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_id_pair_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_flow_id_pair_key_size_get(
    int unit);

/**
 * \brief returns numeric data of flow_id_pair_max
 * Module - 'sch', Submodule - 'dbal', data - 'flow_id_pair_max'
 * max value of half flow id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_id_pair_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_flow_id_pair_max_get(
    int unit);

/**
 * \brief returns numeric data of ps_bits
 * Module - 'sch', Submodule - 'dbal', data - 'ps_bits'
 * Number of bits in PS id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ps_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_ps_bits_get(
    int unit);

/**
 * \brief returns numeric data of flow_shaper_descr_bits
 * Module - 'sch', Submodule - 'dbal', data - 'flow_shaper_descr_bits'
 * Number of bits in flow shaper descriptor for one flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_shaper_descr_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_flow_shaper_descr_bits_get(
    int unit);

/**
 * \brief returns numeric data of ps_shaper_bits
 * Module - 'sch', Submodule - 'dbal', data - 'ps_shaper_bits'
 * number of bits in PS shaper
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ps_shaper_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_ps_shaper_bits_get(
    int unit);

/**
 * \brief returns numeric data of cl_profile_bits
 * Module - 'sch', Submodule - 'dbal', data - 'cl_profile_bits'
 * number of bits in CL profile id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cl_profile_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_cl_profile_bits_get(
    int unit);

/**
 * \brief returns numeric data of priority_propagation_if_group_nof_bits
 * Module - 'sch', Submodule - 'dbal', data - 'priority_propagation_if_group_nof_bits'
 * number of bits of interface groups used for prioririty propagation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     priority_propagation_if_group_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_sch_dbal_priority_propagation_if_group_nof_bits_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_dbal_table_nof
} dnx_data_sch_dbal_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FEATURES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_features_feature_get(
    int unit,
    dnx_data_sch_features_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_features_define_nof
} dnx_data_sch_features_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_features_table_nof
} dnx_data_sch_features_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FC:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_sch_fc_feature_get(
    int unit,
    dnx_data_sch_fc_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_fc_define_nof
} dnx_data_sch_fc_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_fc_table_nof
} dnx_data_sch_fc_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_sch_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_SCH_H_*/
/* *INDENT-ON* */
