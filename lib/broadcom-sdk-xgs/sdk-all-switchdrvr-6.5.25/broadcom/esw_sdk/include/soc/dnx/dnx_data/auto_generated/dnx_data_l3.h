/** \file dnx_data_l3.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_L3_H_
/*{*/
#define _DNX_DATA_L3_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/mdb_global.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_enum_field_types.h>
#include <soc/dnx/dbal/dbal_external_defines.h>
#include <bcm/l3.h>
#include <bcm/ipmc.h>
#include <bcm_int/dnx/l3/l3.h>
#include <bcm_int/dnx/algo/l3/source_address_table_allocation.h>
#include <bcm_int/dnx/ipmc/ipmc.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_mdb.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_l3.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_l3
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_l3_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - EGR_POINTED:
 * Virtual egress objects which do not access GLEM
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_egr_pointed_feature_nof
} dnx_data_l3_egr_pointed_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_egr_pointed_feature_get_f) (
    int unit,
    dnx_data_l3_egr_pointed_feature_e feature);

/**
 * \brief returns define data of first_egr_pointed_id
 * Module - 'l3', Submodule - 'egr_pointed', data - 'first_egr_pointed_id'
 * Identifier of very first virtual egress pointed object.                            Range is from 'first_egr_pointed_id' to 'nof_egr_pointed_ids - 1'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_egr_pointed_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_egr_pointed_first_egr_pointed_id_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_egr_pointed_ids
 * Module - 'l3', Submodule - 'egr_pointed', data - 'nof_egr_pointed_ids'
 * Number of virtual egress pointed object ids
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_pointed_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_egr_pointed_nof_egr_pointed_ids_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_bits_in_egr_pointed_id
 * Module - 'l3', Submodule - 'egr_pointed', data - 'nof_bits_in_egr_pointed_id'
 * Number of bits representing one virtual egress pointed object id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_egr_pointed_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - EGR_POINTED:
 * {
 */
/**
 * \brief Interface for l3 egr_pointed data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_egr_pointed_feature_get_f feature_get;
    /**
     * returns define data of first_egr_pointed_id
     */
    dnx_data_l3_egr_pointed_first_egr_pointed_id_get_f first_egr_pointed_id_get;
    /**
     * returns numeric data of nof_egr_pointed_ids
     */
    dnx_data_l3_egr_pointed_nof_egr_pointed_ids_get_f nof_egr_pointed_ids_get;
    /**
     * returns numeric data of nof_bits_in_egr_pointed_id
     */
    dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_get_f nof_bits_in_egr_pointed_id_get;
} dnx_data_if_l3_egr_pointed_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEC:
 * FEC data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule fec table fec_resource_info
 * Table info:
 * FEC recource types information
 */
typedef struct
{
    /**
     * FEC protection state information.
     */
    uint8 is_protection_type;
    /**
     * FEC statistic state information.
     */
    uint8 is_statistic_type;
} dnx_data_l3_fec_fec_resource_info_t;

/**
 * \brief Holds values of submodule fec table super_fec_result_types_map
 * Table info:
 * Map FEC dbal result type to an actual FEC type and FEC recource type.
 */
typedef struct
{
    /**
     * FEC type in Super FEC.
     */
    dbal_fields_e fec_type_in_super_fec;
    /**
     * FEC resource type.
     */
    uint32 fec_resource_type;
} dnx_data_l3_fec_super_fec_result_types_map_t;

/**
 * \brief Holds values of submodule fec table fec_result_type_fields
 * Table info:
 * FEC table result type information.
 */
typedef struct
{
    /**
     * Indication if GLOBAL_OUT_LIF field exists in this result type.
     */
    uint8 has_global_outlif;
    /**
     * Indication if GLOBAL_OUT_LIF_2ND field exists in this result type.
     */
    uint8 has_global_outlif_second;
    /**
     * Indication if MC_RPF_MODE field exists in this result type.
     */
    uint8 has_mc_rpf;
    /**
     * Indication if EEI field exists in this result type.
     */
    uint8 has_eei;
    /**
     * Indication if HIERARCHICAL_TM_FLOW field exists in this result type.
     */
    uint8 has_htm;
} dnx_data_l3_fec_fec_result_type_fields_t;

/**
 * \brief Holds values of submodule fec table fec_physical_db
 * Table info:
 * A list with FEC physical DBs
 */
typedef struct
{
    /**
     * An array of FEC physical DBs.
     */
    mdb_physical_table_e physical_table[6];
} dnx_data_l3_fec_fec_physical_db_t;

/**
 * \brief Holds values of submodule fec table fec_tables_info
 * Table info:
 * FEC tables Information.
 */
typedef struct
{
    /**
     * The FEC DBAL table name that should be used for the given key.
     */
    dbal_tables_e dbal_table;
    /**
     * Hierarchy information.
     */
    uint32 hierarchy;
    /**
     * Consecutive indexes of the FEC physical databases.
     */
    int index;
} dnx_data_l3_fec_fec_tables_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * FWD and RPF entries are placed in separate DBs.
     */
    dnx_data_l3_fec_separate_fwd_rpf_dbs,
    /**
     * FER bank size information.
     */
    dnx_data_l3_fec_uneven_bank_sizes,
    /**
     * Indication if the MC RPF type - SIP-based is supported.
     */
    dnx_data_l3_fec_mc_rpf_sip_based_supported,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fec_feature_nof
} dnx_data_l3_fec_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_fec_feature_get_f) (
    int unit,
    dnx_data_l3_fec_feature_e feature);

/**
 * \brief returns define data of nof_fecs
 * Module - 'l3', Submodule - 'fec', data - 'nof_fecs'
 * The maximal number of FECs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fecs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_nof_fecs_get_f) (
    int unit);

/**
 * \brief returns define data of first_valid_fec_ecmp_id
 * Module - 'l3', Submodule - 'fec', data - 'first_valid_fec_ecmp_id'
 * The ID of the first valid FEC/ECMP group which can be created.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_valid_fec_ecmp_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_first_valid_fec_ecmp_id_get_f) (
    int unit);

/**
 * \brief returns define data of max_fec_id_for_single_dhb_cluster_pair_granularity
 * Module - 'l3', Submodule - 'fec', data - 'max_fec_id_for_single_dhb_cluster_pair_granularity'
 * The maximal FEC ID that support a single DHB cluasters pair.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fec_id_for_single_dhb_cluster_pair_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_fec_id_for_single_dhb_cluster_pair_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of max_fec_id_for_double_dhb_cluster_pair_granularity
 * Module - 'l3', Submodule - 'fec', data - 'max_fec_id_for_double_dhb_cluster_pair_granularity'
 * The maximal FEC ID that requiere an even number of DHB clusters pairs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fec_id_for_double_dhb_cluster_pair_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_fec_id_for_double_dhb_cluster_pair_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of max_default_fec
 * Module - 'l3', Submodule - 'fec', data - 'max_default_fec'
 * The maximal FEC id that can be used for default route.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_default_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_default_fec_get_f) (
    int unit);

/**
 * \brief returns define data of bank_size
 * Module - 'l3', Submodule - 'fec', data - 'bank_size'
 * The smallest number of FECs which belong to the same hierarchy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_bank_size_get_f) (
    int unit);

/**
 * \brief returns define data of bank_size_round_up
 * Module - 'l3', Submodule - 'fec', data - 'bank_size_round_up'
 * In some cases FEC bank size contains extra FECs due to round up which results from physical to logical translation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_size_round_up - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_bank_size_round_up_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_super_fecs_per_bank
 * Module - 'l3', Submodule - 'fec', data - 'max_nof_super_fecs_per_bank'
 * The max NOF SUPER FEC IDs per resource manager bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_super_fecs_per_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_nof_super_fecs_per_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_physical_fecs_per_bank
 * Module - 'l3', Submodule - 'fec', data - 'nof_physical_fecs_per_bank'
 * The number of physical FEC IDs per bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_physical_fecs_per_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_nof_physical_fecs_per_bank_get_f) (
    int unit);

/**
 * \brief returns define data of bank_nof_physical_rows
 * Module - 'l3', Submodule - 'fec', data - 'bank_nof_physical_rows'
 * The NOF rows that a FEC bank has.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_nof_physical_rows - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_bank_nof_physical_rows_get_f) (
    int unit);

/**
 * \brief returns define data of super_fec_size
 * Module - 'l3', Submodule - 'fec', data - 'super_fec_size'
 * The number of bits of a single super FEC in the MDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     super_fec_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_super_fec_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_banks
 * Module - 'l3', Submodule - 'fec', data - 'max_nof_banks'
 * The maximal NOF possible banks in the device (not MDB profile dependent).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_nof_banks_get_f) (
    int unit);

/**
 * \brief returns define data of first_bank_without_id_alloc
 * Module - 'l3', Submodule - 'fec', data - 'first_bank_without_id_alloc'
 * the first fec allocation bank that can be used for allocating FECs without an ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_bank_without_id_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_first_bank_without_id_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of first_shared_bank
 * Module - 'l3', Submodule - 'fec', data - 'first_shared_bank'
 * The first FEC bank id index which has values in the ECMP and the FEC ranges.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_shared_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_first_shared_bank_get_f) (
    int unit);

/**
 * \brief returns define data of max_super_fec_id
 * Module - 'l3', Submodule - 'fec', data - 'max_super_fec_id'
 * The max ID of the super FEC.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_super_fec_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_max_super_fec_id_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fec_directions
 * Module - 'l3', Submodule - 'fec', data - 'nof_fec_directions'
 * The number of FEC directions.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_directions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_nof_fec_directions_get_f) (
    int unit);

/**
 * \brief returns define data of fec_z_max_fec_id
 * Module - 'l3', Submodule - 'fec', data - 'fec_z_max_fec_id'
 * The maximal FEC ID that is supported for FEC_Z.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_z_max_fec_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_fec_z_max_fec_id_get_f) (
    int unit);

/**
 * \brief returns define data of nof_dpc_fec_db
 * Module - 'l3', Submodule - 'fec', data - 'nof_dpc_fec_db'
 * The number of DPC FEC DBs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dpc_fec_db - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_nof_dpc_fec_db_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fec_dbs_all_cores
 * Module - 'l3', Submodule - 'fec', data - 'nof_fec_dbs_all_cores'
 * The number of FEC DBs for all cores.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_dbs_all_cores - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_nof_fec_dbs_all_cores_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fec_result_types
 * Module - 'l3', Submodule - 'fec', data - 'nof_fec_result_types'
 * The number of result types in fec_result_type_fields
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_result_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_nof_fec_result_types_get_f) (
    int unit);

/**
 * \brief returns numeric data of fer_hw_version
 * Module - 'l3', Submodule - 'fec', data - 'fer_hw_version'
 * This value indicates the HW version of the FER
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fer_hw_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_fer_hw_version_get_f) (
    int unit);

/**
 * \brief returns numeric data of fec_property_supported_flags
 * Module - 'l3', Submodule - 'fec', data - 'fec_property_supported_flags'
 * Supported BCM_SWITCH_FEC_PROPERTY_* flags to verify the bcm_switch_fec_property_get API.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_property_supported_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fec_fec_property_supported_flags_get_f) (
    int unit);

/**
 * \brief get table fec_resource_info entry 
 * FEC recource types information
 * 
 * \param [in] unit - unit #
 * \param [in] resource_type - FEC resouce type.
 * 
 * \return
 *     fec_resource_info - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_fec_resource_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fec_fec_resource_info_t *(
    *dnx_data_l3_fec_fec_resource_info_get_f) (
    int unit,
    int resource_type);

/**
 * \brief get table super_fec_result_types_map entry 
 * Map FEC dbal result type to an actual FEC type and FEC recource type.
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_result_type - DBAL FEC result type.
 * 
 * \return
 *     super_fec_result_types_map - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_super_fec_result_types_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fec_super_fec_result_types_map_t *(
    *dnx_data_l3_fec_super_fec_result_types_map_get_f) (
    int unit,
    int dbal_result_type);

/**
 * \brief get table fec_result_type_fields entry 
 * FEC table result type information.
 * 
 * \param [in] unit - unit #
 * \param [in] result_type - FEC table result types.
 * 
 * \return
 *     fec_result_type_fields - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_fec_result_type_fields_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fec_fec_result_type_fields_t *(
    *dnx_data_l3_fec_fec_result_type_fields_get_f) (
    int unit,
    int result_type);

/**
 * \brief get table fec_physical_db entry 
 * A list with FEC physical DBs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_physical_db - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_fec_physical_db_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fec_fec_physical_db_t *(
    *dnx_data_l3_fec_fec_physical_db_get_f) (
    int unit);

/**
 * \brief get table fec_tables_info entry 
 * FEC tables Information.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - MDB FEC physical tables.
 * 
 * \return
 *     fec_tables_info - returns the relevant entry values grouped in struct - see dnx_data_l3_fec_fec_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fec_fec_tables_info_t *(
    *dnx_data_l3_fec_fec_tables_info_get_f) (
    int unit,
    int mdb_table);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - FEC:
 * {
 */
/**
 * \brief Interface for l3 fec data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_fec_feature_get_f feature_get;
    /**
     * returns define data of nof_fecs
     */
    dnx_data_l3_fec_nof_fecs_get_f nof_fecs_get;
    /**
     * returns define data of first_valid_fec_ecmp_id
     */
    dnx_data_l3_fec_first_valid_fec_ecmp_id_get_f first_valid_fec_ecmp_id_get;
    /**
     * returns define data of max_fec_id_for_single_dhb_cluster_pair_granularity
     */
    dnx_data_l3_fec_max_fec_id_for_single_dhb_cluster_pair_granularity_get_f max_fec_id_for_single_dhb_cluster_pair_granularity_get;
    /**
     * returns define data of max_fec_id_for_double_dhb_cluster_pair_granularity
     */
    dnx_data_l3_fec_max_fec_id_for_double_dhb_cluster_pair_granularity_get_f max_fec_id_for_double_dhb_cluster_pair_granularity_get;
    /**
     * returns define data of max_default_fec
     */
    dnx_data_l3_fec_max_default_fec_get_f max_default_fec_get;
    /**
     * returns define data of bank_size
     */
    dnx_data_l3_fec_bank_size_get_f bank_size_get;
    /**
     * returns define data of bank_size_round_up
     */
    dnx_data_l3_fec_bank_size_round_up_get_f bank_size_round_up_get;
    /**
     * returns define data of max_nof_super_fecs_per_bank
     */
    dnx_data_l3_fec_max_nof_super_fecs_per_bank_get_f max_nof_super_fecs_per_bank_get;
    /**
     * returns define data of nof_physical_fecs_per_bank
     */
    dnx_data_l3_fec_nof_physical_fecs_per_bank_get_f nof_physical_fecs_per_bank_get;
    /**
     * returns define data of bank_nof_physical_rows
     */
    dnx_data_l3_fec_bank_nof_physical_rows_get_f bank_nof_physical_rows_get;
    /**
     * returns define data of super_fec_size
     */
    dnx_data_l3_fec_super_fec_size_get_f super_fec_size_get;
    /**
     * returns define data of max_nof_banks
     */
    dnx_data_l3_fec_max_nof_banks_get_f max_nof_banks_get;
    /**
     * returns define data of first_bank_without_id_alloc
     */
    dnx_data_l3_fec_first_bank_without_id_alloc_get_f first_bank_without_id_alloc_get;
    /**
     * returns define data of first_shared_bank
     */
    dnx_data_l3_fec_first_shared_bank_get_f first_shared_bank_get;
    /**
     * returns define data of max_super_fec_id
     */
    dnx_data_l3_fec_max_super_fec_id_get_f max_super_fec_id_get;
    /**
     * returns define data of nof_fec_directions
     */
    dnx_data_l3_fec_nof_fec_directions_get_f nof_fec_directions_get;
    /**
     * returns define data of fec_z_max_fec_id
     */
    dnx_data_l3_fec_fec_z_max_fec_id_get_f fec_z_max_fec_id_get;
    /**
     * returns define data of nof_dpc_fec_db
     */
    dnx_data_l3_fec_nof_dpc_fec_db_get_f nof_dpc_fec_db_get;
    /**
     * returns define data of nof_fec_dbs_all_cores
     */
    dnx_data_l3_fec_nof_fec_dbs_all_cores_get_f nof_fec_dbs_all_cores_get;
    /**
     * returns define data of nof_fec_result_types
     */
    dnx_data_l3_fec_nof_fec_result_types_get_f nof_fec_result_types_get;
    /**
     * returns numeric data of fer_hw_version
     */
    dnx_data_l3_fec_fer_hw_version_get_f fer_hw_version_get;
    /**
     * returns numeric data of fec_property_supported_flags
     */
    dnx_data_l3_fec_fec_property_supported_flags_get_f fec_property_supported_flags_get;
    /**
     * get table fec_resource_info entry 
     */
    dnx_data_l3_fec_fec_resource_info_get_f fec_resource_info_get;
    /**
     * get general info table about table (for example key size)fec_resource_info info
     */
    dnxc_data_table_info_get_f fec_resource_info_info_get;
    /**
     * get table super_fec_result_types_map entry 
     */
    dnx_data_l3_fec_super_fec_result_types_map_get_f super_fec_result_types_map_get;
    /**
     * get general info table about table (for example key size)super_fec_result_types_map info
     */
    dnxc_data_table_info_get_f super_fec_result_types_map_info_get;
    /**
     * get table fec_result_type_fields entry 
     */
    dnx_data_l3_fec_fec_result_type_fields_get_f fec_result_type_fields_get;
    /**
     * get general info table about table (for example key size)fec_result_type_fields info
     */
    dnxc_data_table_info_get_f fec_result_type_fields_info_get;
    /**
     * get table fec_physical_db entry 
     */
    dnx_data_l3_fec_fec_physical_db_get_f fec_physical_db_get;
    /**
     * get general info table about table (for example key size)fec_physical_db info
     */
    dnxc_data_table_info_get_f fec_physical_db_info_get;
    /**
     * get table fec_tables_info entry 
     */
    dnx_data_l3_fec_fec_tables_info_get_f fec_tables_info_get;
    /**
     * get general info table about table (for example key size)fec_tables_info info
     */
    dnxc_data_table_info_get_f fec_tables_info_info_get;
} dnx_data_if_l3_fec_t;

/*
 * }
 */

/*
 * SUBMODULE  - FER:
 * FER block data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule fer table mux_configuration
 * Table info:
 * Configuration of FER MUX connectivity
 */
typedef struct
{
    /**
     * The FEC direction(FWD or RPF) for which the MUX is configured.
     */
    uint32 direction;
    /**
     * The FEC hierarchy for which the MUX is configured.
     */
    uint32 hierarchy;
} dnx_data_l3_fer_mux_configuration_t;

/**
 * \brief Holds values of submodule fer table mux_connection
 * Table info:
 * Information about the MUX connected to each FEC DB
 */
typedef struct
{
    /**
     * The ID(s) of the MUX(es) that each FEC DB is connected to
     */
    uint32 mux_ids[3];
    /**
     * Number of muxes connected to the physical FEC DB
     */
    uint32 nof_muxes;
} dnx_data_l3_fer_mux_connection_t;

/**
 * \brief Holds values of submodule fer table sorting_stages_info
 * Table info:
 * FER sorting stages information
 */
typedef struct
{
    /**
     * FEC bank mapping table for the FER stage
     */
    dbal_tables_e bank_mapping_table;
    /**
     * The FEC direction(FWD or RPF) of the FER stage.
     */
    uint32 direction;
    /**
     * The FEC hierarchy associated with the FER stage.
     */
    uint32 hierarchy;
} dnx_data_l3_fer_sorting_stages_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Allows different FER mux connectivity.
     */
    dnx_data_l3_fer_mux_connection_supported,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fer_feature_nof
} dnx_data_l3_fer_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_fer_feature_get_f) (
    int unit,
    dnx_data_l3_fer_feature_e feature);

/**
 * \brief returns define data of mdb_granularity_ratio
 * Module - 'l3', Submodule - 'fer', data - 'mdb_granularity_ratio'
 * This value indicate the ratio between the FER FEC granularity relative to the MDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_granularity_ratio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fer_mdb_granularity_ratio_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fer_sort_to_mdb_table_muxes
 * Module - 'l3', Submodule - 'fer', data - 'nof_fer_sort_to_mdb_table_muxes'
 * The number of muxes that selects between FER stages sorting blocks to MDB physical tables
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fer_sort_to_mdb_table_muxes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fer_nof_fer_sort_to_mdb_table_muxes_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_sorting_blocks_per_fec_db
 * Module - 'l3', Submodule - 'fer', data - 'max_nof_sorting_blocks_per_fec_db'
 * The maximal number of FEC sorting blocks for a signle FEC DB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_sorting_blocks_per_fec_db - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fer_max_nof_sorting_blocks_per_fec_db_get_f) (
    int unit);

/**
 * \brief get table mux_configuration entry 
 * Configuration of FER MUX connectivity
 * 
 * \param [in] unit - unit #
 * \param [in] mux_id - The ID of the FER MUX.
 * 
 * \return
 *     mux_configuration - returns the relevant entry values grouped in struct - see dnx_data_l3_fer_mux_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fer_mux_configuration_t *(
    *dnx_data_l3_fer_mux_configuration_get_f) (
    int unit,
    int mux_id);

/**
 * \brief get table mux_connection entry 
 * Information about the MUX connected to each FEC DB
 * 
 * \param [in] unit - unit #
 * \param [in] physical_db - The physical FEC database
 * 
 * \return
 *     mux_connection - returns the relevant entry values grouped in struct - see dnx_data_l3_fer_mux_connection_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fer_mux_connection_t *(
    *dnx_data_l3_fer_mux_connection_get_f) (
    int unit,
    int physical_db);

/**
 * \brief get table sorting_stages_info entry 
 * FER sorting stages information
 * 
 * \param [in] unit - unit #
 * \param [in] sorting_stage - The FER sorting stage
 * 
 * \return
 *     sorting_stages_info - returns the relevant entry values grouped in struct - see dnx_data_l3_fer_sorting_stages_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fer_sorting_stages_info_t *(
    *dnx_data_l3_fer_sorting_stages_info_get_f) (
    int unit,
    int sorting_stage);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - FER:
 * {
 */
/**
 * \brief Interface for l3 fer data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_fer_feature_get_f feature_get;
    /**
     * returns define data of mdb_granularity_ratio
     */
    dnx_data_l3_fer_mdb_granularity_ratio_get_f mdb_granularity_ratio_get;
    /**
     * returns define data of nof_fer_sort_to_mdb_table_muxes
     */
    dnx_data_l3_fer_nof_fer_sort_to_mdb_table_muxes_get_f nof_fer_sort_to_mdb_table_muxes_get;
    /**
     * returns define data of max_nof_sorting_blocks_per_fec_db
     */
    dnx_data_l3_fer_max_nof_sorting_blocks_per_fec_db_get_f max_nof_sorting_blocks_per_fec_db_get;
    /**
     * get table mux_configuration entry 
     */
    dnx_data_l3_fer_mux_configuration_get_f mux_configuration_get;
    /**
     * get general info table about table (for example key size)mux_configuration info
     */
    dnxc_data_table_info_get_f mux_configuration_info_get;
    /**
     * get table mux_connection entry 
     */
    dnx_data_l3_fer_mux_connection_get_f mux_connection_get;
    /**
     * get general info table about table (for example key size)mux_connection info
     */
    dnxc_data_table_info_get_f mux_connection_info_get;
    /**
     * get table sorting_stages_info entry 
     */
    dnx_data_l3_fer_sorting_stages_info_get_f sorting_stages_info_get;
    /**
     * get general info table about table (for example key size)sorting_stages_info info
     */
    dnxc_data_table_info_get_f sorting_stages_info_info_get;
} dnx_data_if_l3_fer_t;

/*
 * }
 */

/*
 * SUBMODULE  - SOURCE_ADDRESS:
 * Source address data.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule source_address table address_type_info
 * Table info:
 * Information about how many entries each address type takes in source_address_map table.
 */
typedef struct
{
    /**
     * The number of entries.
     */
    uint32 nof_entries;
} dnx_data_l3_source_address_address_type_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_feature_nof
} dnx_data_l3_source_address_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_source_address_feature_get_f) (
    int unit,
    dnx_data_l3_source_address_feature_e feature);

/**
 * \brief returns define data of source_address_table_size
 * Module - 'l3', Submodule - 'source_address', data - 'source_address_table_size'
 * The number of entries in the source address table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_address_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_source_address_source_address_table_size_get_f) (
    int unit);

/**
 * \brief returns define data of custom_sa_use_dual_homing
 * Module - 'l3', Submodule - 'source_address', data - 'custom_sa_use_dual_homing'
 * Indication whether ARP custom sa feature is using EEDB dual homing field or full mac address from source address table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     custom_sa_use_dual_homing - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_source_address_custom_sa_use_dual_homing_get_f) (
    int unit);

/**
 * \brief get table address_type_info entry 
 * Information about how many entries each address type takes in source_address_map table.
 * 
 * \param [in] unit - unit #
 * \param [in] address_type - Address type.
 * 
 * \return
 *     address_type_info - returns the relevant entry values grouped in struct - see dnx_data_l3_source_address_address_type_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_source_address_address_type_info_t *(
    *dnx_data_l3_source_address_address_type_info_get_f) (
    int unit,
    int address_type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - SOURCE_ADDRESS:
 * {
 */
/**
 * \brief Interface for l3 source_address data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_source_address_feature_get_f feature_get;
    /**
     * returns define data of source_address_table_size
     */
    dnx_data_l3_source_address_source_address_table_size_get_f source_address_table_size_get;
    /**
     * returns define data of custom_sa_use_dual_homing
     */
    dnx_data_l3_source_address_custom_sa_use_dual_homing_get_f custom_sa_use_dual_homing_get;
    /**
     * get table address_type_info entry 
     */
    dnx_data_l3_source_address_address_type_info_get_f address_type_info_get;
    /**
     * get general info table about table (for example key size)address_type_info info
     */
    dnxc_data_table_info_get_f address_type_info_info_get;
} dnx_data_if_l3_source_address_t;

/*
 * }
 */

/*
 * SUBMODULE  - VRF:
 * vrf data.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrf_feature_nof
} dnx_data_l3_vrf_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_vrf_feature_get_f) (
    int unit,
    dnx_data_l3_vrf_feature_e feature);

/**
 * \brief returns define data of nof_vrf
 * Module - 'l3', Submodule - 'vrf', data - 'nof_vrf'
 * The maximal number of VRFs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vrf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrf_nof_vrf_get_f) (
    int unit);

/**
 * \brief returns define data of nof_vrf_ipv6
 * Module - 'l3', Submodule - 'vrf', data - 'nof_vrf_ipv6'
 * The maximal number of VRFs supported by the device for an IPv6 MC table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vrf_ipv6 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrf_nof_vrf_ipv6_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - VRF:
 * {
 */
/**
 * \brief Interface for l3 vrf data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_vrf_feature_get_f feature_get;
    /**
     * returns define data of nof_vrf
     */
    dnx_data_l3_vrf_nof_vrf_get_f nof_vrf_get;
    /**
     * returns define data of nof_vrf_ipv6
     */
    dnx_data_l3_vrf_nof_vrf_ipv6_get_f nof_vrf_ipv6_get;
} dnx_data_if_l3_vrf_t;

/*
 * }
 */

/*
 * SUBMODULE  - ROUTING_ENABLERS:
 * routing enablers data.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule routing_enablers table layer_enablers_by_id
 * Table info:
 * List of layer types based on index
 */
typedef struct
{
    /**
     * Layer type protocol
     */
    uint32 layer_type;
} dnx_data_l3_routing_enablers_layer_enablers_by_id_t;

/**
 * \brief Holds values of submodule routing_enablers table layer_enablers
 * Table info:
 * Map layer type to routing enabled/disabled indication
 */
typedef struct
{
    /**
     * UC enable value.
     */
    uint8 uc_enable;
    /**
     * MC enable value.
     */
    uint8 mc_enable;
    /**
     * Profile when routing is disabled.
     */
    uint8 disable_profile;
} dnx_data_l3_routing_enablers_layer_enablers_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * determine if need to consider the ptc routing enable profile, when configure the routing enable profile
     */
    dnx_data_l3_routing_enablers_ptc_routing_enable_profile_support,

    /**
     * Must be last one!
     */
    _dnx_data_l3_routing_enablers_feature_nof
} dnx_data_l3_routing_enablers_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_routing_enablers_feature_get_f) (
    int unit,
    dnx_data_l3_routing_enablers_feature_e feature);

/**
 * \brief returns define data of routing_enable_vector_length
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_vector_length'
 * The length in bits of the routing enablers vector.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_vector_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_routing_enablers_routing_enable_vector_length_get_f) (
    int unit);

/**
 * \brief returns define data of routing_enable_action_support
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_action_support'
 * Indication whether routing enable action profiles are used to determine layer termination.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_action_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_routing_enablers_routing_enable_action_support_get_f) (
    int unit);

/**
 * \brief returns define data of routing_enable_action_profile_size
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_action_profile_size'
 * Size in bits of the routing enable action profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_action_profile_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_routing_enablers_routing_enable_action_profile_size_get_f) (
    int unit);

/**
 * \brief returns define data of routing_enable_indication_nof_bits_per_layer
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_indication_nof_bits_per_layer'
 * Number of bits in the routing enable vector responsible for a single uc/mc indication per layer type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_indication_nof_bits_per_layer - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_routing_enablers_routing_enable_indication_nof_bits_per_layer_get_f) (
    int unit);

/**
 * \brief returns define data of routing_enable_nof_profiles_per_layer
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enable_nof_profiles_per_layer'
 * Number of routing enabled indications (UC/MC) per layer type.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enable_nof_profiles_per_layer - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_routing_enablers_routing_enable_nof_profiles_per_layer_get_f) (
    int unit);

/**
 * \brief returns define data of routing_enabled_action_profile_id
 * Module - 'l3', Submodule - 'routing_enablers', data - 'routing_enabled_action_profile_id'
 * The ID of the action profile which indicates that layer termination is enabled
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     routing_enabled_action_profile_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_routing_enablers_routing_enabled_action_profile_id_get_f) (
    int unit);

/**
 * \brief get table layer_enablers_by_id entry 
 * List of layer types based on index
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Table entry index
 * 
 * \return
 *     layer_enablers_by_id - returns the relevant entry values grouped in struct - see dnx_data_l3_routing_enablers_layer_enablers_by_id_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_routing_enablers_layer_enablers_by_id_t *(
    *dnx_data_l3_routing_enablers_layer_enablers_by_id_get_f) (
    int unit,
    int idx);

/**
 * \brief get table layer_enablers entry 
 * Map layer type to routing enabled/disabled indication
 * 
 * \param [in] unit - unit #
 * \param [in] layer_type - Layer type protocol
 * 
 * \return
 *     layer_enablers - returns the relevant entry values grouped in struct - see dnx_data_l3_routing_enablers_layer_enablers_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_routing_enablers_layer_enablers_t *(
    *dnx_data_l3_routing_enablers_layer_enablers_get_f) (
    int unit,
    int layer_type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - ROUTING_ENABLERS:
 * {
 */
/**
 * \brief Interface for l3 routing_enablers data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_routing_enablers_feature_get_f feature_get;
    /**
     * returns define data of routing_enable_vector_length
     */
    dnx_data_l3_routing_enablers_routing_enable_vector_length_get_f routing_enable_vector_length_get;
    /**
     * returns define data of routing_enable_action_support
     */
    dnx_data_l3_routing_enablers_routing_enable_action_support_get_f routing_enable_action_support_get;
    /**
     * returns define data of routing_enable_action_profile_size
     */
    dnx_data_l3_routing_enablers_routing_enable_action_profile_size_get_f routing_enable_action_profile_size_get;
    /**
     * returns define data of routing_enable_indication_nof_bits_per_layer
     */
    dnx_data_l3_routing_enablers_routing_enable_indication_nof_bits_per_layer_get_f routing_enable_indication_nof_bits_per_layer_get;
    /**
     * returns define data of routing_enable_nof_profiles_per_layer
     */
    dnx_data_l3_routing_enablers_routing_enable_nof_profiles_per_layer_get_f routing_enable_nof_profiles_per_layer_get;
    /**
     * returns define data of routing_enabled_action_profile_id
     */
    dnx_data_l3_routing_enablers_routing_enabled_action_profile_id_get_f routing_enabled_action_profile_id_get;
    /**
     * get table layer_enablers_by_id entry 
     */
    dnx_data_l3_routing_enablers_layer_enablers_by_id_get_f layer_enablers_by_id_get;
    /**
     * get general info table about table (for example key size)layer_enablers_by_id info
     */
    dnxc_data_table_info_get_f layer_enablers_by_id_info_get;
    /**
     * get table layer_enablers entry 
     */
    dnx_data_l3_routing_enablers_layer_enablers_get_f layer_enablers_get;
    /**
     * get general info table about table (for example key size)layer_enablers info
     */
    dnxc_data_table_info_get_f layer_enablers_info_get;
} dnx_data_if_l3_routing_enablers_t;

/*
 * }
 */

/*
 * SUBMODULE  - RIF:
 * Routing interface
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indication that the Out-RIF handling is part of the LIF manager.
     */
    dnx_data_l3_rif_out_rif_part_of_lif_mngr,

    /**
     * Must be last one!
     */
    _dnx_data_l3_rif_feature_nof
} dnx_data_l3_rif_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_rif_feature_get_f) (
    int unit,
    dnx_data_l3_rif_feature_e feature);

/**
 * \brief returns define data of max_nof_rifs
 * Module - 'l3', Submodule - 'rif', data - 'max_nof_rifs'
 * Maximum number of rifs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_rifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_rif_max_nof_rifs_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_rifs
 * Module - 'l3', Submodule - 'rif', data - 'nof_rifs'
 * Number of rifs available in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_rif_nof_rifs_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - RIF:
 * {
 */
/**
 * \brief Interface for l3 rif data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_rif_feature_get_f feature_get;
    /**
     * returns define data of max_nof_rifs
     */
    dnx_data_l3_rif_max_nof_rifs_get_f max_nof_rifs_get;
    /**
     * returns numeric data of nof_rifs
     */
    dnx_data_l3_rif_nof_rifs_get_f nof_rifs_get;
} dnx_data_if_l3_rif_t;

/*
 * }
 */

/*
 * SUBMODULE  - FWD:
 * Forwarding data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule fwd table lpm_profile_to_entry_strength
 * Table info:
 * LPM profile to entry strength mapping
 */
typedef struct
{
    /**
     * Prefix length ranges for non-default entries.The value in each array cell is the highest value of the range.
     */
    int prefix_len_non_def[DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES];
    /**
     * Prefix length ranges for non-default entries.The value in each array cell is the highest value of the range.
     */
    int prefix_len_def[DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES];
    /**
     * Entry strength.
     */
    int entry_strength_non_def[DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES];
    /**
     * Default entry strength.
     */
    int entry_strength_def[DNX_DATA_MAX_L3_FWD_NOF_LPM_STRENGTH_PROFILES];
} dnx_data_l3_fwd_lpm_profile_to_entry_strength_t;

/**
 * \brief Holds values of submodule fwd table routing_tables
 * Table info:
 * IPv4/IPv6 routing tables information
 */
typedef struct
{
    /**
     * An array of routing tables
     */
    dbal_tables_e tables[L3_MAX_NOF_ROUTING_TABLES_PER_PROTOCOL_VERSION+1];
} dnx_data_l3_fwd_routing_tables_t;

/**
 * \brief Holds values of submodule fwd table mc_tables
 * Table info:
 * IPv4/IPv6 MC tables information
 */
typedef struct
{
    /**
     * An array of tables
     */
    dbal_tables_e tables[6];
    /**
     * The number of tables in the array
     */
    uint32 count;
} dnx_data_l3_fwd_mc_tables_t;

/**
 * \brief Holds values of submodule fwd table ipmc_compression_mode
 * Table info:
 * IPv4/IPv6 MC tables information
 */
typedef struct
{
    /**
     * The IPMC configuration compression mode.
     */
    dnx_ipmc_config_compression_mode_e mode;
    /**
     * The DBAL tabled used by this mode.
     */
    dbal_tables_e dbal_table;
    /**
     * The physical table that is accessed.
     */
    dbal_physical_tables_e physical_table;
    /**
     * The result field in the dbal table.
     */
    dbal_fields_e result_field;
} dnx_data_l3_fwd_ipmc_compression_mode_t;

/**
 * \brief Holds values of submodule fwd table lpm_default_prefix_length_info
 * Table info:
 * LPM default prefix length information
 */
typedef struct
{
    /**
     * The IPv4/IPv6 UC/MC routing table APP DB ID
     */
    uint32 dbal_table[DNX_DATA_MAX_MDB_KAPS_NOF_APP_IDS];
    /**
     * The associated LPM default prefix length
     */
    uint32 default_prefix_length[DNX_DATA_MAX_MDB_KAPS_NOF_APP_IDS];
} dnx_data_l3_fwd_lpm_default_prefix_length_info_t;

/**
 * \brief Holds values of submodule fwd table lpm_app_db_to_strength_profile
 * Table info:
 * LPM APP DB to entry strength profile mapping
 */
typedef struct
{
    /**
     * LPM APP DB ID
     */
    uint32 dbal_table[DNX_DATA_MAX_MDB_KAPS_NOF_APP_IDS];
    /**
     * LPM strength profile
     */
    dnx_l3_kaps_lpm_strength_profiles_e lpm_profile[DNX_DATA_MAX_MDB_KAPS_NOF_APP_IDS];
} dnx_data_l3_fwd_lpm_app_db_to_strength_profile_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicates whether the RIF participates in key entry construction.
     */
    dnx_data_l3_fwd_ipmc_rif_key_participation,
    /**
     * Indicates whether the EM tables are used in forwarding.
     */
    dnx_data_l3_fwd_host_entry_support,
    /**
     * Indicates whether the TCAM is used in forwarding.
     */
    dnx_data_l3_fwd_tcam_entry_support,
    /**
     * Indicates whether compressed VRF + group entries are supported
     */
    dnx_data_l3_fwd_ipmc_config_cmprs_vrf_group,
    /**
     * Indicates if LPM default prefix map is used for default route indication
     */
    dnx_data_l3_fwd_lpm_default_entry_set_by_prefix,
    /**
     * Indicates whether different LPM strength profile mapping is supported per KAPS application
     */
    dnx_data_l3_fwd_kaps_lpm_strength_profile_map_support,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fwd_feature_nof
} dnx_data_l3_fwd_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_fwd_feature_get_f) (
    int unit,
    dnx_data_l3_fwd_feature_e feature);

/**
 * \brief returns define data of flp_fragment_support
 * Module - 'l3', Submodule - 'fwd', data - 'flp_fragment_support'
 * Indicate whether the LB fragmentation is handled by the FLP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flp_fragment_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_flp_fragment_support_get_f) (
    int unit);

/**
 * \brief returns define data of max_mc_group_lpm
 * Module - 'l3', Submodule - 'fwd', data - 'max_mc_group_lpm'
 * The maximum number of MC group ID for IPMC route entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mc_group_lpm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_max_mc_group_lpm_get_f) (
    int unit);

/**
 * \brief returns define data of max_mc_group_em
 * Module - 'l3', Submodule - 'fwd', data - 'max_mc_group_em'
 * The maximum number of MC group ID for IPMC host entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mc_group_em - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_max_mc_group_em_get_f) (
    int unit);

/**
 * \brief returns define data of nof_my_mac_prefixes
 * Module - 'l3', Submodule - 'fwd', data - 'nof_my_mac_prefixes'
 * The number of my MACs prefixes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_my_mac_prefixes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_nof_my_mac_prefixes_get_f) (
    int unit);

/**
 * \brief returns define data of compressed_sip_svl_size
 * Module - 'l3', Submodule - 'fwd', data - 'compressed_sip_svl_size'
 * The size in bits of the IPMC IP6 compressed SIP for SVL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compressed_sip_svl_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_compressed_sip_svl_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compressed_svl_sip
 * Module - 'l3', Submodule - 'fwd', data - 'nof_compressed_svl_sip'
 * Number of supported IPMC compressed SIPs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compressed_svl_sip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_nof_compressed_svl_sip_get_f) (
    int unit);

/**
 * \brief returns define data of lpm_strength_profiles_support
 * Module - 'l3', Submodule - 'fwd', data - 'lpm_strength_profiles_support'
 * Indicates whether the KAPS strength mapping is different per LPM profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpm_strength_profiles_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_lpm_strength_profiles_support_get_f) (
    int unit);

/**
 * \brief returns define data of nof_lpm_strength_profiles
 * Module - 'l3', Submodule - 'fwd', data - 'nof_lpm_strength_profiles'
 * The number of LPM strength profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lpm_strength_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_nof_lpm_strength_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of compressed_sip_ivl_size
 * Module - 'l3', Submodule - 'fwd', data - 'compressed_sip_ivl_size'
 * The size in bits of the IPMC IP6 compressed SIP for IVL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compressed_sip_ivl_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_compressed_sip_ivl_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compressed_ivl_sip
 * Module - 'l3', Submodule - 'fwd', data - 'nof_compressed_ivl_sip'
 * Number of supported IPMC compressed SIPs for IVL table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compressed_ivl_sip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_nof_compressed_ivl_sip_get_f) (
    int unit);

/**
 * \brief returns numeric data of uc_supported_route_flags
 * Module - 'l3', Submodule - 'fwd', data - 'uc_supported_route_flags'
 * Supported L3 unicast route flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uc_supported_route_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_uc_supported_route_flags_get_f) (
    int unit);

/**
 * \brief returns numeric data of uc_supported_route_flags2
 * Module - 'l3', Submodule - 'fwd', data - 'uc_supported_route_flags2'
 * Supported L3 unicast route flags2.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uc_supported_route_flags2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_uc_supported_route_flags2_get_f) (
    int unit);

/**
 * \brief returns numeric data of uc_supported_kbp_route_flags
 * Module - 'l3', Submodule - 'fwd', data - 'uc_supported_kbp_route_flags'
 * Supported L3 unicast KBP route flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uc_supported_kbp_route_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_uc_supported_kbp_route_flags_get_f) (
    int unit);

/**
 * \brief returns numeric data of uc_supported_kbp_route_flags2
 * Module - 'l3', Submodule - 'fwd', data - 'uc_supported_kbp_route_flags2'
 * Supported L3 unicast KBP route flags2.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uc_supported_kbp_route_flags2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_uc_supported_kbp_route_flags2_get_f) (
    int unit);

/**
 * \brief returns numeric data of ipmc_supported_flags
 * Module - 'l3', Submodule - 'fwd', data - 'ipmc_supported_flags'
 * Supported flags for the IPMC APIs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmc_supported_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_ipmc_supported_flags_get_f) (
    int unit);

/**
 * \brief returns numeric data of last_kaps_intf_id
 * Module - 'l3', Submodule - 'fwd', data - 'last_kaps_intf_id'
 * The last valid KAPS interface used in KAPS LPM strength profile configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     last_kaps_intf_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_fwd_last_kaps_intf_id_get_f) (
    int unit);

/**
 * \brief get table lpm_profile_to_entry_strength entry 
 * LPM profile to entry strength mapping
 * 
 * \param [in] unit - unit #
 * \param [in] lpm_profile - LPM profile.
 * \param [in] kaps_intf - KAPS interface.
 * 
 * \return
 *     lpm_profile_to_entry_strength - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_lpm_profile_to_entry_strength_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fwd_lpm_profile_to_entry_strength_t *(
    *dnx_data_l3_fwd_lpm_profile_to_entry_strength_get_f) (
    int unit,
    int lpm_profile,
    int kaps_intf);

/**
 * \brief get table routing_tables entry 
 * IPv4/IPv6 routing tables information
 * 
 * \param [in] unit - unit #
 * \param [in] ip_version - Internet protocol version(IPv4 or IPv6)
 * 
 * \return
 *     routing_tables - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_routing_tables_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fwd_routing_tables_t *(
    *dnx_data_l3_fwd_routing_tables_get_f) (
    int unit,
    int ip_version);

/**
 * \brief get table mc_tables entry 
 * IPv4/IPv6 MC tables information
 * 
 * \param [in] unit - unit #
 * \param [in] ip_version - Internet protocol version(IPv4 or IPv6)
 * \param [in] route_enable - Indicates whether the tables are routing tables or bridge tables
 * 
 * \return
 *     mc_tables - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_mc_tables_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fwd_mc_tables_t *(
    *dnx_data_l3_fwd_mc_tables_get_f) (
    int unit,
    int ip_version,
    int route_enable);

/**
 * \brief get table ipmc_compression_mode entry 
 * IPv4/IPv6 MC tables information
 * 
 * \param [in] unit - unit #
 * \param [in] route_enable - Indicates whether the tables are routing tables or bridge tables
 * 
 * \return
 *     ipmc_compression_mode - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_ipmc_compression_mode_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fwd_ipmc_compression_mode_t *(
    *dnx_data_l3_fwd_ipmc_compression_mode_get_f) (
    int unit,
    int route_enable);

/**
 * \brief get table lpm_default_prefix_length_info entry 
 * LPM default prefix length information
 * 
 * \param [in] unit - unit #
 * \param [in] physical_db_id - LPM physical table ID
 * 
 * \return
 *     lpm_default_prefix_length_info - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_lpm_default_prefix_length_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fwd_lpm_default_prefix_length_info_t *(
    *dnx_data_l3_fwd_lpm_default_prefix_length_info_get_f) (
    int unit,
    int physical_db_id);

/**
 * \brief get table lpm_app_db_to_strength_profile entry 
 * LPM APP DB to entry strength profile mapping
 * 
 * \param [in] unit - unit #
 * \param [in] kaps_intf - KAPS interface
 * 
 * \return
 *     lpm_app_db_to_strength_profile - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_lpm_app_db_to_strength_profile_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_fwd_lpm_app_db_to_strength_profile_t *(
    *dnx_data_l3_fwd_lpm_app_db_to_strength_profile_get_f) (
    int unit,
    int kaps_intf);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - FWD:
 * {
 */
/**
 * \brief Interface for l3 fwd data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_fwd_feature_get_f feature_get;
    /**
     * returns define data of flp_fragment_support
     */
    dnx_data_l3_fwd_flp_fragment_support_get_f flp_fragment_support_get;
    /**
     * returns define data of max_mc_group_lpm
     */
    dnx_data_l3_fwd_max_mc_group_lpm_get_f max_mc_group_lpm_get;
    /**
     * returns define data of max_mc_group_em
     */
    dnx_data_l3_fwd_max_mc_group_em_get_f max_mc_group_em_get;
    /**
     * returns define data of nof_my_mac_prefixes
     */
    dnx_data_l3_fwd_nof_my_mac_prefixes_get_f nof_my_mac_prefixes_get;
    /**
     * returns define data of compressed_sip_svl_size
     */
    dnx_data_l3_fwd_compressed_sip_svl_size_get_f compressed_sip_svl_size_get;
    /**
     * returns define data of nof_compressed_svl_sip
     */
    dnx_data_l3_fwd_nof_compressed_svl_sip_get_f nof_compressed_svl_sip_get;
    /**
     * returns define data of lpm_strength_profiles_support
     */
    dnx_data_l3_fwd_lpm_strength_profiles_support_get_f lpm_strength_profiles_support_get;
    /**
     * returns define data of nof_lpm_strength_profiles
     */
    dnx_data_l3_fwd_nof_lpm_strength_profiles_get_f nof_lpm_strength_profiles_get;
    /**
     * returns define data of compressed_sip_ivl_size
     */
    dnx_data_l3_fwd_compressed_sip_ivl_size_get_f compressed_sip_ivl_size_get;
    /**
     * returns define data of nof_compressed_ivl_sip
     */
    dnx_data_l3_fwd_nof_compressed_ivl_sip_get_f nof_compressed_ivl_sip_get;
    /**
     * returns numeric data of uc_supported_route_flags
     */
    dnx_data_l3_fwd_uc_supported_route_flags_get_f uc_supported_route_flags_get;
    /**
     * returns numeric data of uc_supported_route_flags2
     */
    dnx_data_l3_fwd_uc_supported_route_flags2_get_f uc_supported_route_flags2_get;
    /**
     * returns numeric data of uc_supported_kbp_route_flags
     */
    dnx_data_l3_fwd_uc_supported_kbp_route_flags_get_f uc_supported_kbp_route_flags_get;
    /**
     * returns numeric data of uc_supported_kbp_route_flags2
     */
    dnx_data_l3_fwd_uc_supported_kbp_route_flags2_get_f uc_supported_kbp_route_flags2_get;
    /**
     * returns numeric data of ipmc_supported_flags
     */
    dnx_data_l3_fwd_ipmc_supported_flags_get_f ipmc_supported_flags_get;
    /**
     * returns numeric data of last_kaps_intf_id
     */
    dnx_data_l3_fwd_last_kaps_intf_id_get_f last_kaps_intf_id_get;
    /**
     * get table lpm_profile_to_entry_strength entry 
     */
    dnx_data_l3_fwd_lpm_profile_to_entry_strength_get_f lpm_profile_to_entry_strength_get;
    /**
     * get general info table about table (for example key size)lpm_profile_to_entry_strength info
     */
    dnxc_data_table_info_get_f lpm_profile_to_entry_strength_info_get;
    /**
     * get table routing_tables entry 
     */
    dnx_data_l3_fwd_routing_tables_get_f routing_tables_get;
    /**
     * get general info table about table (for example key size)routing_tables info
     */
    dnxc_data_table_info_get_f routing_tables_info_get;
    /**
     * get table mc_tables entry 
     */
    dnx_data_l3_fwd_mc_tables_get_f mc_tables_get;
    /**
     * get general info table about table (for example key size)mc_tables info
     */
    dnxc_data_table_info_get_f mc_tables_info_get;
    /**
     * get table ipmc_compression_mode entry 
     */
    dnx_data_l3_fwd_ipmc_compression_mode_get_f ipmc_compression_mode_get;
    /**
     * get general info table about table (for example key size)ipmc_compression_mode info
     */
    dnxc_data_table_info_get_f ipmc_compression_mode_info_get;
    /**
     * get table lpm_default_prefix_length_info entry 
     */
    dnx_data_l3_fwd_lpm_default_prefix_length_info_get_f lpm_default_prefix_length_info_get;
    /**
     * get general info table about table (for example key size)lpm_default_prefix_length_info info
     */
    dnxc_data_table_info_get_f lpm_default_prefix_length_info_info_get;
    /**
     * get table lpm_app_db_to_strength_profile entry 
     */
    dnx_data_l3_fwd_lpm_app_db_to_strength_profile_get_f lpm_app_db_to_strength_profile_get;
    /**
     * get general info table about table (for example key size)lpm_app_db_to_strength_profile info
     */
    dnxc_data_table_info_get_f lpm_app_db_to_strength_profile_info_get;
} dnx_data_if_l3_fwd_t;

/*
 * }
 */

/*
 * SUBMODULE  - ECMP:
 * ECMP data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule ecmp table consistent_tables_info
 * Table info:
 * information on the different consistent tables sizes
 */
typedef struct
{
    /**
     * The NOF entries this tables holds
     */
    uint32 nof_entries;
    /**
     * A single table entry size in bits.
     */
    uint32 entry_size_in_bits;
} dnx_data_l3_ecmp_consistent_tables_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicates whether different ECMP group profile result types are supported
     */
    dnx_data_l3_ecmp_ecmp_group_profile_multiple_result_types_support,

    /**
     * Must be last one!
     */
    _dnx_data_l3_ecmp_feature_nof
} dnx_data_l3_ecmp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_ecmp_feature_get_f) (
    int unit,
    dnx_data_l3_ecmp_feature_e feature);

/**
 * \brief returns define data of group_size_multiply_and_divide_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_multiply_and_divide_nof_bits'
 * The NOF bit of the multiply and division group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_multiply_and_divide_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_group_size_multiply_and_divide_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of group_size_consistent_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_consistent_nof_bits'
 * The NOF bit of the consistent group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_consistent_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_group_size_consistent_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of group_size_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_nof_bits'
 * The max NOF bit of the ECMP group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_group_size_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of max_group_size
 * Module - 'l3', Submodule - 'ecmp', data - 'max_group_size'
 * The maximal size of an ECMP group.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_group_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_max_group_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp_basic_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_basic_mode'
 * Number of ECMP groups that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_basic_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_basic_mode_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_ecmp
 * Module - 'l3', Submodule - 'ecmp', data - 'total_nof_ecmp'
 * The total number of IDs that are considered to be in the ECMP range.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_total_nof_ecmp_get_f) (
    int unit);

/**
 * \brief returns define data of max_ecmp_basic_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'max_ecmp_basic_mode'
 * Maximum ECMP group ID that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ecmp_basic_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_max_ecmp_basic_mode_get_f) (
    int unit);

/**
 * \brief returns define data of max_ecmp_extended_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'max_ecmp_extended_mode'
 * Maximum ECMP group ID that can be created in extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ecmp_extended_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_max_ecmp_extended_mode_get_f) (
    int unit);

/**
 * \brief returns define data of nof_extended_ecmp_per_failover_bank
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_extended_ecmp_per_failover_bank'
 * The upper 8k ECMP (from 32k to 40k) are placed in a memory shared by Failover and ECMP. The memory has 32 banks by 512 lines each.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_extended_ecmp_per_failover_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_extended_ecmp_per_failover_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_failover_banks_per_extended_ecmp_bank
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_failover_banks_per_extended_ecmp_bank'
 * nof fec protection banks to be used for 1 ecmp extended bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_failover_banks_per_extended_ecmp_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_failover_banks_per_extended_ecmp_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_group_profiles_per_hierarchy
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_group_profiles_per_hierarchy'
 * Number of profiles that are available for each ECMP hierarchy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_group_profiles_per_hierarchy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_get_f) (
    int unit);

/**
 * \brief returns define data of member_table_nof_rows_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_nof_rows_size_in_bits'
 * The NOF bits required to represent the NOF rows in the consistent members memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_nof_rows_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_member_table_nof_rows_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of member_table_address_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_address_size_in_bits'
 * The member table address size in bits when it used by the ECMP profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_address_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_member_table_address_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ecmp_bank_size
 * Module - 'l3', Submodule - 'ecmp', data - 'ecmp_bank_size'
 * The number of groups per HW bank. All groups in a bank belong to one hierarchy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecmp_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_ecmp_bank_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp_banks_basic
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_banks_basic'
 * The number of ECMP banks in the basic range of IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_banks_basic - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_banks_basic_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp_banks_extended
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_banks_extended'
 * The number of ECMP banks in the extended range of IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_banks_extended - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_banks_extended_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ecmp
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp'
 * Number of ECMPs in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_ecmp_get_f) (
    int unit);

/**
 * \brief returns define data of profile_id_size
 * Module - 'l3', Submodule - 'ecmp', data - 'profile_id_size'
 * The size of the profile ID field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     profile_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_profile_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of profile_id_offset
 * Module - 'l3', Submodule - 'ecmp', data - 'profile_id_offset'
 * The offset of the profile ID field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     profile_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_profile_id_offset_get_f) (
    int unit);

/**
 * \brief returns define data of tunnel_priority_support
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_support'
 * Device has tunnel priority support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_tunnel_priority_support_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tunnel_priority_map_profiles
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_tunnel_priority_map_profiles'
 * The NOF tunnle priority map profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tunnel_priority_map_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_tunnel_priority_map_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of tunnel_priority_field_width
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_field_width'
 * The width in bits of the tunnel priority field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_field_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_tunnel_priority_field_width_get_f) (
    int unit);

/**
 * \brief returns define data of tunnel_priority_index_field_width
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_index_field_width'
 * The size of the possible TP indexes field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_index_field_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_tunnel_priority_index_field_width_get_f) (
    int unit);

/**
 * \brief returns define data of consistent_mem_row_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'consistent_mem_row_size_in_bits'
 * The size in bits of a row in the consistent members memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_mem_row_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_consistent_mem_row_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of consistent_bank_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'consistent_bank_size_in_bits'
 * The size of a single bank used for the consistent hashing members tables.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_bank_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_consistent_bank_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ecmp_small_consistent_group_nof_entries
 * Module - 'l3', Submodule - 'ecmp', data - 'ecmp_small_consistent_group_nof_entries'
 * The nof entries in small consistent group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecmp_small_consistent_group_nof_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_ecmp_small_consistent_group_nof_entries_get_f) (
    int unit);

/**
 * \brief returns define data of ecmp_small_consistent_group_entry_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'ecmp_small_consistent_group_entry_size_in_bits'
 * The nof bits for each entry in consistent small group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecmp_small_consistent_group_entry_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_ecmp_small_consistent_group_entry_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_consistent_resources
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_consistent_resources'
 * The total number of consistent resources available
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_consistent_resources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_ecmp_nof_consistent_resources_get_f) (
    int unit);

/**
 * \brief get table consistent_tables_info entry 
 * information on the different consistent tables sizes
 * 
 * \param [in] unit - unit #
 * \param [in] table_type - The table type.
 * 
 * \return
 *     consistent_tables_info - returns the relevant entry values grouped in struct - see dnx_data_l3_ecmp_consistent_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_ecmp_consistent_tables_info_t *(
    *dnx_data_l3_ecmp_consistent_tables_info_get_f) (
    int unit,
    int table_type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - ECMP:
 * {
 */
/**
 * \brief Interface for l3 ecmp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_ecmp_feature_get_f feature_get;
    /**
     * returns define data of group_size_multiply_and_divide_nof_bits
     */
    dnx_data_l3_ecmp_group_size_multiply_and_divide_nof_bits_get_f group_size_multiply_and_divide_nof_bits_get;
    /**
     * returns define data of group_size_consistent_nof_bits
     */
    dnx_data_l3_ecmp_group_size_consistent_nof_bits_get_f group_size_consistent_nof_bits_get;
    /**
     * returns define data of group_size_nof_bits
     */
    dnx_data_l3_ecmp_group_size_nof_bits_get_f group_size_nof_bits_get;
    /**
     * returns define data of max_group_size
     */
    dnx_data_l3_ecmp_max_group_size_get_f max_group_size_get;
    /**
     * returns define data of nof_ecmp_basic_mode
     */
    dnx_data_l3_ecmp_nof_ecmp_basic_mode_get_f nof_ecmp_basic_mode_get;
    /**
     * returns define data of total_nof_ecmp
     */
    dnx_data_l3_ecmp_total_nof_ecmp_get_f total_nof_ecmp_get;
    /**
     * returns define data of max_ecmp_basic_mode
     */
    dnx_data_l3_ecmp_max_ecmp_basic_mode_get_f max_ecmp_basic_mode_get;
    /**
     * returns define data of max_ecmp_extended_mode
     */
    dnx_data_l3_ecmp_max_ecmp_extended_mode_get_f max_ecmp_extended_mode_get;
    /**
     * returns define data of nof_extended_ecmp_per_failover_bank
     */
    dnx_data_l3_ecmp_nof_extended_ecmp_per_failover_bank_get_f nof_extended_ecmp_per_failover_bank_get;
    /**
     * returns define data of nof_failover_banks_per_extended_ecmp_bank
     */
    dnx_data_l3_ecmp_nof_failover_banks_per_extended_ecmp_bank_get_f nof_failover_banks_per_extended_ecmp_bank_get;
    /**
     * returns define data of nof_group_profiles_per_hierarchy
     */
    dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_get_f nof_group_profiles_per_hierarchy_get;
    /**
     * returns define data of member_table_nof_rows_size_in_bits
     */
    dnx_data_l3_ecmp_member_table_nof_rows_size_in_bits_get_f member_table_nof_rows_size_in_bits_get;
    /**
     * returns define data of member_table_address_size_in_bits
     */
    dnx_data_l3_ecmp_member_table_address_size_in_bits_get_f member_table_address_size_in_bits_get;
    /**
     * returns define data of ecmp_bank_size
     */
    dnx_data_l3_ecmp_ecmp_bank_size_get_f ecmp_bank_size_get;
    /**
     * returns define data of nof_ecmp_banks_basic
     */
    dnx_data_l3_ecmp_nof_ecmp_banks_basic_get_f nof_ecmp_banks_basic_get;
    /**
     * returns define data of nof_ecmp_banks_extended
     */
    dnx_data_l3_ecmp_nof_ecmp_banks_extended_get_f nof_ecmp_banks_extended_get;
    /**
     * returns define data of nof_ecmp
     */
    dnx_data_l3_ecmp_nof_ecmp_get_f nof_ecmp_get;
    /**
     * returns define data of profile_id_size
     */
    dnx_data_l3_ecmp_profile_id_size_get_f profile_id_size_get;
    /**
     * returns define data of profile_id_offset
     */
    dnx_data_l3_ecmp_profile_id_offset_get_f profile_id_offset_get;
    /**
     * returns define data of tunnel_priority_support
     */
    dnx_data_l3_ecmp_tunnel_priority_support_get_f tunnel_priority_support_get;
    /**
     * returns define data of nof_tunnel_priority_map_profiles
     */
    dnx_data_l3_ecmp_nof_tunnel_priority_map_profiles_get_f nof_tunnel_priority_map_profiles_get;
    /**
     * returns define data of tunnel_priority_field_width
     */
    dnx_data_l3_ecmp_tunnel_priority_field_width_get_f tunnel_priority_field_width_get;
    /**
     * returns define data of tunnel_priority_index_field_width
     */
    dnx_data_l3_ecmp_tunnel_priority_index_field_width_get_f tunnel_priority_index_field_width_get;
    /**
     * returns define data of consistent_mem_row_size_in_bits
     */
    dnx_data_l3_ecmp_consistent_mem_row_size_in_bits_get_f consistent_mem_row_size_in_bits_get;
    /**
     * returns define data of consistent_bank_size_in_bits
     */
    dnx_data_l3_ecmp_consistent_bank_size_in_bits_get_f consistent_bank_size_in_bits_get;
    /**
     * returns define data of ecmp_small_consistent_group_nof_entries
     */
    dnx_data_l3_ecmp_ecmp_small_consistent_group_nof_entries_get_f ecmp_small_consistent_group_nof_entries_get;
    /**
     * returns define data of ecmp_small_consistent_group_entry_size_in_bits
     */
    dnx_data_l3_ecmp_ecmp_small_consistent_group_entry_size_in_bits_get_f ecmp_small_consistent_group_entry_size_in_bits_get;
    /**
     * returns define data of nof_consistent_resources
     */
    dnx_data_l3_ecmp_nof_consistent_resources_get_f nof_consistent_resources_get;
    /**
     * get table consistent_tables_info entry 
     */
    dnx_data_l3_ecmp_consistent_tables_info_get_f consistent_tables_info_get;
    /**
     * get general info table about table (for example key size)consistent_tables_info info
     */
    dnxc_data_table_info_get_f consistent_tables_info_info_get;
} dnx_data_if_l3_ecmp_t;

/*
 * }
 */

/*
 * SUBMODULE  - VIP_ECMP:
 * VIRTUAL IP ECMP group data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicates whether the ECMP VIP is supported in the device.
     */
    dnx_data_l3_vip_ecmp_supported,

    /**
     * Must be last one!
     */
    _dnx_data_l3_vip_ecmp_feature_nof
} dnx_data_l3_vip_ecmp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_vip_ecmp_feature_get_f) (
    int unit,
    dnx_data_l3_vip_ecmp_feature_e feature);

/**
 * \brief returns define data of nof_vip_ecmp
 * Module - 'l3', Submodule - 'vip_ecmp', data - 'nof_vip_ecmp'
 * Number of VIP ECMP groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vip_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vip_ecmp_nof_vip_ecmp_get_f) (
    int unit);

/**
 * \brief returns define data of max_vip_ecmp_table_size
 * Module - 'l3', Submodule - 'vip_ecmp', data - 'max_vip_ecmp_table_size'
 * Maximum number entries per VIP ECMP group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_vip_ecmp_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vip_ecmp_max_vip_ecmp_table_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - VIP_ECMP:
 * {
 */
/**
 * \brief Interface for l3 vip_ecmp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_vip_ecmp_feature_get_f feature_get;
    /**
     * returns define data of nof_vip_ecmp
     */
    dnx_data_l3_vip_ecmp_nof_vip_ecmp_get_f nof_vip_ecmp_get;
    /**
     * returns define data of max_vip_ecmp_table_size
     */
    dnx_data_l3_vip_ecmp_max_vip_ecmp_table_size_get_f max_vip_ecmp_table_size_get;
} dnx_data_if_l3_vip_ecmp_t;

/*
 * }
 */

/*
 * SUBMODULE  - WCMP:
 * 
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_wcmp_feature_nof
} dnx_data_l3_wcmp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_wcmp_feature_get_f) (
    int unit,
    dnx_data_l3_wcmp_feature_e feature);

/**
 * \brief returns define data of group_size_nof_bits
 * Module - 'l3', Submodule - 'wcmp', data - 'group_size_nof_bits'
 * The max NOF bits of the WCMP group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_wcmp_group_size_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of max_member_weight
 * Module - 'l3', Submodule - 'wcmp', data - 'max_member_weight'
 * The max weight that can be assigned to a member of a WCMP group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_member_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_wcmp_max_member_weight_get_f) (
    int unit);

/**
 * \brief returns define data of member_weight_quant_factor
 * Module - 'l3', Submodule - 'wcmp', data - 'member_weight_quant_factor'
 * Quantization factor used in the conversion of member's weight to HW units
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_weight_quant_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_wcmp_member_weight_quant_factor_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - WCMP:
 * {
 */
/**
 * \brief Interface for l3 wcmp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_wcmp_feature_get_f feature_get;
    /**
     * returns define data of group_size_nof_bits
     */
    dnx_data_l3_wcmp_group_size_nof_bits_get_f group_size_nof_bits_get;
    /**
     * returns define data of max_member_weight
     */
    dnx_data_l3_wcmp_max_member_weight_get_f max_member_weight_get;
    /**
     * returns define data of member_weight_quant_factor
     */
    dnx_data_l3_wcmp_member_weight_quant_factor_get_f member_weight_quant_factor_get;
} dnx_data_if_l3_wcmp_t;

/*
 * }
 */

/*
 * SUBMODULE  - SOURCE_ADDRESS_ETHERNET:
 * SOURCE_ADDRESS_ETHERNET data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_ethernet_feature_nof
} dnx_data_l3_source_address_ethernet_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_source_address_ethernet_feature_get_f) (
    int unit,
    dnx_data_l3_source_address_ethernet_feature_e feature);

/**
 * \brief returns define data of nof_mymac_prefixes
 * Module - 'l3', Submodule - 'source_address_ethernet', data - 'nof_mymac_prefixes'
 * Number of mymac prefixes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mymac_prefixes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - SOURCE_ADDRESS_ETHERNET:
 * {
 */
/**
 * \brief Interface for l3 source_address_ethernet data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_source_address_ethernet_feature_get_f feature_get;
    /**
     * returns define data of nof_mymac_prefixes
     */
    dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_get_f nof_mymac_prefixes_get;
} dnx_data_if_l3_source_address_ethernet_t;

/*
 * }
 */

/*
 * SUBMODULE  - VRRP:
 * VRRP (multiple my mac) data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule vrrp table vrrp_tables
 * Table info:
 * VRRP tables
 */
typedef struct
{
    /**
     * An array of tables
     */
    dbal_tables_e table[2];
} dnx_data_l3_vrrp_vrrp_tables_t;

/**
 * \brief Holds values of submodule vrrp table data_bases
 * Table info:
 * Information about physical DBs used.
 */
typedef struct
{
    /**
     * An array of physical data bases
     */
    dbal_physical_tables_e data_base[DNX_DATA_MAX_L3_VRRP_NOF_DBS];
} dnx_data_l3_vrrp_data_bases_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrrp_feature_nof
} dnx_data_l3_vrrp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_vrrp_feature_get_f) (
    int unit,
    dnx_data_l3_vrrp_feature_e feature);

/**
 * \brief returns define data of nof_protocol_groups
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_protocol_groups'
 * Number of L3 protocol groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_protocol_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_nof_protocol_groups_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tcam_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_tcam_entries'
 * Size of VRRP TCAM table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_nof_tcam_entries_get_f) (
    int unit);

/**
 * \brief returns define data of nof_vsi_tcam_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_vsi_tcam_entries'
 * Number of enries in VRRP TCAM table that can be used by VSI table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vsi_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_nof_vsi_tcam_entries_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tcam_entries_used_by_exem
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_tcam_entries_used_by_exem'
 * The number of TCAM entries used by the EXEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_entries_used_by_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_nof_tcam_entries_used_by_exem_get_f) (
    int unit);

/**
 * \brief returns define data of exem_vrid_ipv4_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_vrid_ipv4_tcam_index'
 * TCAM index for EXEM VRRP VRID IPv4 protocol
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vrid_ipv4_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_get_f) (
    int unit);

/**
 * \brief returns define data of exem_vrid_ipv6_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_vrid_ipv6_tcam_index'
 * TCAM index for EXEM VRRP VRID IPv6 protocol
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vrid_ipv6_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_get_f) (
    int unit);

/**
 * \brief returns define data of exem_default_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_default_tcam_index'
 * TCAM index for EXEM VSI LSB, SOURCE PORT or SRC PORT-protocol multiple my mac
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_default_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_exem_default_tcam_index_get_f) (
    int unit);

/**
 * \brief returns define data of exem_default_tcam_index_msb
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_default_tcam_index_msb'
 * TCAM index for EXEM VSI MSB multiple my mac
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_default_tcam_index_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_exem_default_tcam_index_msb_get_f) (
    int unit);

/**
 * \brief returns define data of vrrp_default_num_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'vrrp_default_num_entries'
 * Number of default VRRP entries in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vrrp_default_num_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_vrrp_default_num_entries_get_f) (
    int unit);

/**
 * \brief returns define data of is_multiple_my_mac_da_table_per_msb_bit
 * Module - 'l3', Submodule - 'vrrp', data - 'is_multiple_my_mac_da_table_per_msb_bit'
 * Indication if the VRRP table PER_VSI_MULTIPLE_MY_MAC_DA_MSB is split
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     is_multiple_my_mac_da_table_per_msb_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_is_multiple_my_mac_da_table_per_msb_bit_get_f) (
    int unit);

/**
 * \brief returns define data of is_mapped_pp_port_used
 * Module - 'l3', Submodule - 'vrrp', data - 'is_mapped_pp_port_used'
 * Indication if mapped pp port is used in VRRP tables or in pp port as a key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     is_mapped_pp_port_used - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_is_mapped_pp_port_used_get_f) (
    int unit);

/**
 * \brief returns define data of nof_dbs
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_dbs'
 * The number of physical DBs used
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l3_vrrp_nof_dbs_get_f) (
    int unit);

/**
 * \brief get table vrrp_tables entry 
 * VRRP tables
 * 
 * \param [in] unit - unit #
 * \param [in] table_type - Table type.
 * 
 * \return
 *     vrrp_tables - returns the relevant entry values grouped in struct - see dnx_data_l3_vrrp_vrrp_tables_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_vrrp_vrrp_tables_t *(
    *dnx_data_l3_vrrp_vrrp_tables_get_f) (
    int unit,
    int table_type);

/**
 * \brief get table data_bases entry 
 * Information about physical DBs used.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_bases - returns the relevant entry values grouped in struct - see dnx_data_l3_vrrp_data_bases_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l3_vrrp_data_bases_t *(
    *dnx_data_l3_vrrp_data_bases_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - VRRP:
 * {
 */
/**
 * \brief Interface for l3 vrrp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_vrrp_feature_get_f feature_get;
    /**
     * returns define data of nof_protocol_groups
     */
    dnx_data_l3_vrrp_nof_protocol_groups_get_f nof_protocol_groups_get;
    /**
     * returns define data of nof_tcam_entries
     */
    dnx_data_l3_vrrp_nof_tcam_entries_get_f nof_tcam_entries_get;
    /**
     * returns define data of nof_vsi_tcam_entries
     */
    dnx_data_l3_vrrp_nof_vsi_tcam_entries_get_f nof_vsi_tcam_entries_get;
    /**
     * returns define data of nof_tcam_entries_used_by_exem
     */
    dnx_data_l3_vrrp_nof_tcam_entries_used_by_exem_get_f nof_tcam_entries_used_by_exem_get;
    /**
     * returns define data of exem_vrid_ipv4_tcam_index
     */
    dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_get_f exem_vrid_ipv4_tcam_index_get;
    /**
     * returns define data of exem_vrid_ipv6_tcam_index
     */
    dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_get_f exem_vrid_ipv6_tcam_index_get;
    /**
     * returns define data of exem_default_tcam_index
     */
    dnx_data_l3_vrrp_exem_default_tcam_index_get_f exem_default_tcam_index_get;
    /**
     * returns define data of exem_default_tcam_index_msb
     */
    dnx_data_l3_vrrp_exem_default_tcam_index_msb_get_f exem_default_tcam_index_msb_get;
    /**
     * returns define data of vrrp_default_num_entries
     */
    dnx_data_l3_vrrp_vrrp_default_num_entries_get_f vrrp_default_num_entries_get;
    /**
     * returns define data of is_multiple_my_mac_da_table_per_msb_bit
     */
    dnx_data_l3_vrrp_is_multiple_my_mac_da_table_per_msb_bit_get_f is_multiple_my_mac_da_table_per_msb_bit_get;
    /**
     * returns define data of is_mapped_pp_port_used
     */
    dnx_data_l3_vrrp_is_mapped_pp_port_used_get_f is_mapped_pp_port_used_get;
    /**
     * returns define data of nof_dbs
     */
    dnx_data_l3_vrrp_nof_dbs_get_f nof_dbs_get;
    /**
     * get table vrrp_tables entry 
     */
    dnx_data_l3_vrrp_vrrp_tables_get_f vrrp_tables_get;
    /**
     * get general info table about table (for example key size)vrrp_tables info
     */
    dnxc_data_table_info_get_f vrrp_tables_info_get;
    /**
     * get table data_bases entry 
     */
    dnx_data_l3_vrrp_data_bases_get_f data_bases_get;
    /**
     * get general info table about table (for example key size)data_bases info
     */
    dnxc_data_table_info_get_f data_bases_info_get;
} dnx_data_if_l3_vrrp_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURE:
 * 
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * IPv6 compatible MC destination MAC is considered UC
     */
    dnx_data_l3_feature_ipv6_mc_compatible_dmac,
    /**
     * Hit bit retrieval for FEC is not supported.
     */
    dnx_data_l3_feature_fec_hit_bit,
    /**
     * The FER granularity is double the size of the MDB granularity.
     */
    dnx_data_l3_feature_fer_fec_granularity_double_size,
    /**
     * Multicast bridge fallback is not supported.
     */
    dnx_data_l3_feature_mc_bridge_fallback,
    /**
     * NAT on a stick feature
     */
    dnx_data_l3_feature_nat_on_a_stick,
    /**
     * Routed learning with pipe SA lookup and hasn't host lookup
     */
    dnx_data_l3_feature_routed_learning,
    /**
     * IPv4 fragmented but not first bit on layer qualifier, for ingress pipe
     */
    dnx_data_l3_feature_ingress_frag_not_first,
    dnx_data_l3_feature_fec_init_enable,
    /**
     * Indication if public routing is supported.
     */
    dnx_data_l3_feature_public_routing_support,
    /**
     * FWD and RPF entries are placed in separate DBs.
     */
    dnx_data_l3_feature_separate_fwd_rpf_dbs,
    /**
     * Default FEC ID range limitation due to LPM table destination encoding.
     */
    dnx_data_l3_feature_default_fec_limitation,
    /**
     * Indication if WCMP is supported
     */
    dnx_data_l3_feature_wcmp_support,
    /**
     * Default KAPS interface indication.
     */
    dnx_data_l3_feature_default_kaps_interface,
    /**
     * Indicates that not all parts of the init procedure are ready
     */
    dnx_data_l3_feature_init_skip,
    /**
     * my mac prefix 0 is invalid
     */
    dnx_data_l3_feature_my_mac_prefix_0_is_invalid,

    /**
     * Must be last one!
     */
    _dnx_data_l3_feature_feature_nof
} dnx_data_l3_feature_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l3_feature_feature_get_f) (
    int unit,
    dnx_data_l3_feature_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L3 - FEATURE:
 * {
 */
/**
 * \brief Interface for l3 feature data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l3_feature_feature_get_f feature_get;
} dnx_data_if_l3_feature_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_L3:
 * {
 */
/**
 * \brief Interface for l3 data
 */
typedef struct
{
    /**
     * Interface for l3 egr_pointed data
     */
    dnx_data_if_l3_egr_pointed_t egr_pointed;
    /**
     * Interface for l3 fec data
     */
    dnx_data_if_l3_fec_t fec;
    /**
     * Interface for l3 fer data
     */
    dnx_data_if_l3_fer_t fer;
    /**
     * Interface for l3 source_address data
     */
    dnx_data_if_l3_source_address_t source_address;
    /**
     * Interface for l3 vrf data
     */
    dnx_data_if_l3_vrf_t vrf;
    /**
     * Interface for l3 routing_enablers data
     */
    dnx_data_if_l3_routing_enablers_t routing_enablers;
    /**
     * Interface for l3 rif data
     */
    dnx_data_if_l3_rif_t rif;
    /**
     * Interface for l3 fwd data
     */
    dnx_data_if_l3_fwd_t fwd;
    /**
     * Interface for l3 ecmp data
     */
    dnx_data_if_l3_ecmp_t ecmp;
    /**
     * Interface for l3 vip_ecmp data
     */
    dnx_data_if_l3_vip_ecmp_t vip_ecmp;
    /**
     * Interface for l3 wcmp data
     */
    dnx_data_if_l3_wcmp_t wcmp;
    /**
     * Interface for l3 source_address_ethernet data
     */
    dnx_data_if_l3_source_address_ethernet_t source_address_ethernet;
    /**
     * Interface for l3 vrrp data
     */
    dnx_data_if_l3_vrrp_t vrrp;
    /**
     * Interface for l3 feature data
     */
    dnx_data_if_l3_feature_t feature;
} dnx_data_if_l3_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_l3_t dnx_data_l3;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_L3_H_*/
/* *INDENT-ON* */
