/** \file dnxf_data_device.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNXF_DATA_DEVICE_H_
/*{*/
#define _DNXF_DATA_DEVICE_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/property.h>
#include <sal/limits.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnxf/dnxf_data/dnxf_data_verify.h>
#include <soc/types.h>
#include <soc/chip.h>
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_max_device.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNXF_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnxf_data_if_device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_if_device_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL:
 * General attributes
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule general table ctest_full_file_indentifier
 * Table info:
 * Indicates what is the suffix of tcl/tlist files generated by ctest export full command.
 */
typedef struct
{
    /**
     * Should be DNXF.
     */
    char *family_name;
    /**
     * The value can be \0, 3, etc. If the number is \0, define will be counted as NULL. It depends on whether the generated tcl/tlist file names contains number!
     */
    char *family_number;
} dnxf_data_device_general_ctest_full_file_indentifier_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is device in production level quality.
     */
    dnxf_data_device_general_production_ready,
    /**
     * Indicate if SerDes is supported
     */
    dnxf_data_device_general_serdes_support,
    /**
     * Indicate if fabric is supported
     */
    dnxf_data_device_general_fabric_support,
    /**
     * Indicate if there is delay when sending traffic, updating signals, running specific cases
     */
    dnxf_data_device_general_delay_exist,
    /**
     * Indicate if cmic is supported
     */
    dnxf_data_device_general_cmic_support,
    /**
     * Indicate if real interrupts are supported
     */
    dnxf_data_device_general_real_interrupts_support,
    /**
     * Indicate if i2c is supported
     */
    dnxf_data_device_general_i2c_hw_support,
    /**
     * Indicate if hw is supported
     */
    dnxf_data_device_general_hw_support,
    /**
     * Indicate if only some of the virtual devices are active
     */
    dnxf_data_device_general_is_not_all_cores_active,

    /**
     * Must be last one!
     */
    _dnxf_data_device_general_feature_nof
} dnxf_data_device_general_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_general_feature_get_f) (
    int unit,
    dnxf_data_device_general_feature_e feature);

/**
 * \brief returns define data of nof_pvt_monitors
 * Module - 'device', Submodule - 'general', data - 'nof_pvt_monitors'
 * Number of device PVT monitors
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pvt_monitors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_nof_pvt_monitors_get_f) (
    int unit);

/**
 * \brief returns define data of pvt_base
 * Module - 'device', Submodule - 'general', data - 'pvt_base'
 * PVT base. Used for correct calculation of the monitor readings
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pvt_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_general_pvt_base_get_f) (
    int unit);

/**
 * \brief returns define data of pvt_factor
 * Module - 'device', Submodule - 'general', data - 'pvt_factor'
 * PVT factor Used for correct calculation of the monitor readings
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pvt_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_general_pvt_factor_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cores
 * Module - 'device', Submodule - 'general', data - 'nof_cores'
 * Number of cores in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cores - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_nof_cores_get_f) (
    int unit);

/**
 * \brief returns define data of adapter_lib_ver
 * Module - 'device', Submodule - 'general', data - 'adapter_lib_ver'
 * Indicate the adapter lib version
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     adapter_lib_ver - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_adapter_lib_ver_get_f) (
    int unit);

/**
 * \brief returns define data of nof_mesh_topology_links_data
 * Module - 'device', Submodule - 'general', data - 'nof_mesh_topology_links_data'
 * Indicates the nof mesh_topology link data
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mesh_topology_links_data - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_nof_mesh_topology_links_data_get_f) (
    int unit);

/**
 * \brief returns numeric data of hard_reset_disable
 * Module - 'device', Submodule - 'general', data - 'hard_reset_disable'
 * Init device without hard reset.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hard_reset_disable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_hard_reset_disable_get_f) (
    int unit);

/**
 * \brief returns numeric data of core_clock_khz
 * Module - 'device', Submodule - 'general', data - 'core_clock_khz'
 * Specifies system core clock speed in kHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     core_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_core_clock_khz_get_f) (
    int unit);

/**
 * \brief returns numeric data of system_ref_core_clock_khz
 * Module - 'device', Submodule - 'general', data - 'system_ref_core_clock_khz'
 * Specifies system reference clock speed in kHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     system_ref_core_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_system_ref_core_clock_khz_get_f) (
    int unit);

/**
 * \brief returns numeric data of device_id
 * Module - 'device', Submodule - 'general', data - 'device_id'
 * BCM Device ID (8XXX)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_general_device_id_get_f) (
    int unit);

/**
 * \brief get table ctest_full_file_indentifier entry 
 * Indicates what is the suffix of tcl/tlist files generated by ctest export full command.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ctest_full_file_indentifier - returns the relevant entry values grouped in struct - see dnxf_data_device_general_ctest_full_file_indentifier_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_general_ctest_full_file_indentifier_t *(
    *dnxf_data_device_general_ctest_full_file_indentifier_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - GENERAL:
 * {
 */
/**
 * \brief Interface for device general data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_general_feature_get_f feature_get;
    /**
     * returns define data of nof_pvt_monitors
     */
    dnxf_data_device_general_nof_pvt_monitors_get_f nof_pvt_monitors_get;
    /**
     * returns define data of pvt_base
     */
    dnxf_data_device_general_pvt_base_get_f pvt_base_get;
    /**
     * returns define data of pvt_factor
     */
    dnxf_data_device_general_pvt_factor_get_f pvt_factor_get;
    /**
     * returns define data of nof_cores
     */
    dnxf_data_device_general_nof_cores_get_f nof_cores_get;
    /**
     * returns define data of adapter_lib_ver
     */
    dnxf_data_device_general_adapter_lib_ver_get_f adapter_lib_ver_get;
    /**
     * returns define data of nof_mesh_topology_links_data
     */
    dnxf_data_device_general_nof_mesh_topology_links_data_get_f nof_mesh_topology_links_data_get;
    /**
     * returns numeric data of hard_reset_disable
     */
    dnxf_data_device_general_hard_reset_disable_get_f hard_reset_disable_get;
    /**
     * returns numeric data of core_clock_khz
     */
    dnxf_data_device_general_core_clock_khz_get_f core_clock_khz_get;
    /**
     * returns numeric data of system_ref_core_clock_khz
     */
    dnxf_data_device_general_system_ref_core_clock_khz_get_f system_ref_core_clock_khz_get;
    /**
     * returns numeric data of device_id
     */
    dnxf_data_device_general_device_id_get_f device_id_get;
    /**
     * get table ctest_full_file_indentifier entry 
     */
    dnxf_data_device_general_ctest_full_file_indentifier_get_f ctest_full_file_indentifier_get;
    /**
     * get general info table about table (for example key size)ctest_full_file_indentifier info
     */
    dnxc_data_table_info_get_f ctest_full_file_indentifier_info_get;
} dnxf_data_if_device_general_t;

/*
 * }
 */

/*
 * SUBMODULE  - ACCESS:
 * General access attributes
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_access_feature_nof
} dnxf_data_device_access_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_access_feature_get_f) (
    int unit,
    dnxf_data_device_access_feature_e feature);

/**
 * \brief returns numeric data of table_dma_enable
 * Module - 'device', Submodule - 'access', data - 'table_dma_enable'
 * Enable/disable table DMA operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_table_dma_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of tdma_timeout_usec
 * Module - 'device', Submodule - 'access', data - 'tdma_timeout_usec'
 * Table DMA operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdma_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tdma_timeout_usec_get_f) (
    int unit);

/**
 * \brief returns numeric data of tdma_intr_enable
 * Module - 'device', Submodule - 'access', data - 'tdma_intr_enable'
 * Table DMA done is interrupt driven or by polling.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdma_intr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tdma_intr_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of tslam_dma_enable
 * Module - 'device', Submodule - 'access', data - 'tslam_dma_enable'
 * Enable/disable tslam DMA operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tslam_dma_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of tslam_timeout_usec
 * Module - 'device', Submodule - 'access', data - 'tslam_timeout_usec'
 * Tslam DMA operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tslam_timeout_usec_get_f) (
    int unit);

/**
 * \brief returns numeric data of tslam_int_enable
 * Module - 'device', Submodule - 'access', data - 'tslam_int_enable'
 * Tslam DMA done is interrupt driven or by polling.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_int_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_tslam_int_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdio_int_divisor
 * Module - 'device', Submodule - 'access', data - 'mdio_int_divisor'
 * mdio_int_divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_int_divisor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mdio_int_divisor_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdio_ext_divisor
 * Module - 'device', Submodule - 'access', data - 'mdio_ext_divisor'
 * mdio_ext_divisor.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_ext_divisor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mdio_ext_divisor_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdio_int_div_out_delay
 * Module - 'device', Submodule - 'access', data - 'mdio_int_div_out_delay'
 * number of clock delay between the rising edge of MDC and the starting data of MDIO for internal divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_int_div_out_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mdio_int_div_out_delay_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdio_ext_div_out_delay
 * Module - 'device', Submodule - 'access', data - 'mdio_ext_div_out_delay'
 * number of clock delay between the rising edge of MDC and the starting data of MDIO for external divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_ext_div_out_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mdio_ext_div_out_delay_get_f) (
    int unit);

/**
 * \brief returns numeric data of bist_enable
 * Module - 'device', Submodule - 'access', data - 'bist_enable'
 * Determines if to run Memory Built-In Self-Test (MBIST) of internal memory (tables) during startup.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_bist_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of sbus_dma_interval
 * Module - 'device', Submodule - 'access', data - 'sbus_dma_interval'
 * sbus DMA operation interval.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_dma_interval - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_sbus_dma_interval_get_f) (
    int unit);

/**
 * \brief returns numeric data of sbus_dma_intr_enable
 * Module - 'device', Submodule - 'access', data - 'sbus_dma_intr_enable'
 * sbus DMA interrupt enable.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_dma_intr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_sbus_dma_intr_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of mem_clear_chunk_size
 * Module - 'device', Submodule - 'access', data - 'mem_clear_chunk_size'
 * sbus DMA chunk size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mem_clear_chunk_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_access_mem_clear_chunk_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - ACCESS:
 * {
 */
/**
 * \brief Interface for device access data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_access_feature_get_f feature_get;
    /**
     * returns numeric data of table_dma_enable
     */
    dnxf_data_device_access_table_dma_enable_get_f table_dma_enable_get;
    /**
     * returns numeric data of tdma_timeout_usec
     */
    dnxf_data_device_access_tdma_timeout_usec_get_f tdma_timeout_usec_get;
    /**
     * returns numeric data of tdma_intr_enable
     */
    dnxf_data_device_access_tdma_intr_enable_get_f tdma_intr_enable_get;
    /**
     * returns numeric data of tslam_dma_enable
     */
    dnxf_data_device_access_tslam_dma_enable_get_f tslam_dma_enable_get;
    /**
     * returns numeric data of tslam_timeout_usec
     */
    dnxf_data_device_access_tslam_timeout_usec_get_f tslam_timeout_usec_get;
    /**
     * returns numeric data of tslam_int_enable
     */
    dnxf_data_device_access_tslam_int_enable_get_f tslam_int_enable_get;
    /**
     * returns numeric data of mdio_int_divisor
     */
    dnxf_data_device_access_mdio_int_divisor_get_f mdio_int_divisor_get;
    /**
     * returns numeric data of mdio_ext_divisor
     */
    dnxf_data_device_access_mdio_ext_divisor_get_f mdio_ext_divisor_get;
    /**
     * returns numeric data of mdio_int_div_out_delay
     */
    dnxf_data_device_access_mdio_int_div_out_delay_get_f mdio_int_div_out_delay_get;
    /**
     * returns numeric data of mdio_ext_div_out_delay
     */
    dnxf_data_device_access_mdio_ext_div_out_delay_get_f mdio_ext_div_out_delay_get;
    /**
     * returns numeric data of bist_enable
     */
    dnxf_data_device_access_bist_enable_get_f bist_enable_get;
    /**
     * returns numeric data of sbus_dma_interval
     */
    dnxf_data_device_access_sbus_dma_interval_get_f sbus_dma_interval_get;
    /**
     * returns numeric data of sbus_dma_intr_enable
     */
    dnxf_data_device_access_sbus_dma_intr_enable_get_f sbus_dma_intr_enable_get;
    /**
     * returns numeric data of mem_clear_chunk_size
     */
    dnxf_data_device_access_mem_clear_chunk_size_get_f mem_clear_chunk_size_get;
} dnxf_data_if_device_access_t;

/*
 * }
 */

/*
 * SUBMODULE  - BLOCKS:
 * General block information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule blocks table override
 * Table info:
 * blocks enable/disable override
 */
typedef struct
{
    /**
     * See soc_block_type_t
     */
    char *block_type;
    /**
     * instance ID within block type
     */
    int block_instance;
    /**
     * The value to override
     */
    int value;
} dnxf_data_device_blocks_override_t;

/**
 * \brief Holds values of submodule blocks table fsrd_sbus_chain
 * Table info:
 * The order of FSRDs in the SBUS chain
 */
typedef struct
{
    /**
     * The index of the FSRD in the SBUS chain
     */
    int index;
} dnxf_data_device_blocks_fsrd_sbus_chain_t;

/**
 * \brief Holds values of submodule blocks table fmac_sbus_chain
 * Table info:
 * The order of FMACs in the SBUS chain
 */
typedef struct
{
    /**
     * The index of the FMAC in the SBUS chain
     */
    int index;
} dnxf_data_device_blocks_fmac_sbus_chain_t;

/**
 * \brief Holds values of submodule blocks table fmac_lane_to_block_map
 * Table info:
 * Maps FMAC lane to other block instances. Some devices intruduce a complex mapping of FMAC lane to core links.
 */
typedef struct
{
    /**
     * rtp_link. holds rtp_link of all cores, 0-nof_links
     */
    int rtp_link;
} dnxf_data_device_blocks_fmac_lane_to_block_map_t;

/**
 * \brief Holds values of submodule blocks table dch_instances_to_device_stage
 * Table info:
 * Describres which DCH blocks are facing FAP and which face FE2. information is relevant only for FE13 mode. From this RX infotmation we can deduce what are the values for DCML blocks - they are the oposite.
 */
typedef struct
{
    /**
     * a bitmap of the CDR instanceds facing specific device type
     */
    soc_pbmp_t dch_instance_bmp;
} dnxf_data_device_blocks_dch_instances_to_device_stage_t;

/**
 * \brief Holds values of submodule blocks table power_down_per_rtp
 * Table info:
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 */
typedef struct
{
    /**
     * Reg per block of type block_SPECIAL_CLOCK_CONTROLSr to stop the clock to the block
     */
    int clock_reg;
    /**
     * Field inside ECI_BLOCKS_SOFT_INIT to put the block in reset
     */
    uint32 soft_init_fields[DNXF_DATA_MAX_DEVICE_BLOCKS_NOF_INSTANCES_RTP];
} dnxf_data_device_blocks_power_down_per_rtp_t;

/**
 * \brief Holds values of submodule blocks table power_down_per_dch
 * Table info:
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 */
typedef struct
{
    /**
     * Reg per block of type block_SPECIAL_CLOCK_CONTROLSr to stop the clock to the block
     */
    int clock_reg;
    /**
     * Field inside ECI_BLOCKS_SOFT_INIT to put the block in reset
     */
    uint32 soft_init_fields[DNXF_DATA_MAX_DEVICE_BLOCKS_NOF_INSTANCES_DCH];
} dnxf_data_device_blocks_power_down_per_dch_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    dnxf_data_device_blocks_dch_reset_restore_support,

    /**
     * Must be last one!
     */
    _dnxf_data_device_blocks_feature_nof
} dnxf_data_device_blocks_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_blocks_feature_get_f) (
    int unit,
    dnxf_data_device_blocks_feature_e feature);

/**
 * \brief returns define data of nof_all_blocks
 * Module - 'device', Submodule - 'blocks', data - 'nof_all_blocks'
 * Number of block instances in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_all_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_all_blocks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_fmac
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_fmac'
 * Number of FMAC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_fmac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_fmac_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_fmac
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_fmac'
 * Number of links for each FMAC block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_fmac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_fmac_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_fsrd'
 * Number of FSRD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_fsrd_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fsrd'
 * Number of BRoaDCast FSRD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_fsrd_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_dch'
 * Number of DCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_dch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dch'
 * Number of links for each DCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_dch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_dch_link_groups
 * Module - 'device', Submodule - 'blocks', data - 'nof_dch_link_groups'
 * Number of link groups for each DCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dch_link_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_dch_link_groups_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_cch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_cch'
 * Number of CCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_cch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_cch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_cch
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_cch'
 * Number of links for each CCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_cch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_cch_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_dcq
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dcq'
 * Number of links for each DCQ block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dcq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_dcq_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_rtp
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_rtp'
 * Number of RTP instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_rtp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_rtp_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_rtp
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_rtp'
 * Number of links for each RTP block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_rtp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_rtp_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_occg
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_occg'
 * Number of OCCG instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_occg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_occg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_eci
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_eci'
 * Number of ECI instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_eci - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_eci_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_cmic
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_cmic'
 * Number of CMIC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_cmic - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_cmic_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_mesh_topology
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_mesh_topology'
 * Number of MESH Topology instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_mesh_topology - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_mesh_topology_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmach
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmach'
 * Number of BRoaDCast FMACH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmach - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_fmach_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmacl
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmacl'
 * Number of BRoaDCast FMACL instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmacl - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_brdc_fmacl_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_lcm
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_lcm'
 * Number of LCM instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_lcm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_lcm_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_mct
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_mct'
 * Number of MCT instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_mct - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_mct_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_qrh
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_qrh'
 * Number of QRH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_qrh - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_qrh_get_f) (
    int unit);

/**
 * \brief returns define data of nof_instances_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_dcml'
 * Number of DCML instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_instances_dcml_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dcml'
 * Number of links for each DCML block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_dcml_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_lcm
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_lcm'
 * Number of links for each LCM block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_lcm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_lcm_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_qrh
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_qrh'
 * Number of links for each QRH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_qrh - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_qrh_get_f) (
    int unit);

/**
 * \brief returns define data of nof_dtm_fifos
 * Module - 'device', Submodule - 'blocks', data - 'nof_dtm_fifos'
 * Number of FIFOs for each DTM block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dtm_fifos - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_dtm_fifos_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_fsrd'
 * Number of links for each FSRD block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_fsrd_get_f) (
    int unit);

/**
 * \brief returns define data of nof_links_in_phy_core
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_phy_core'
 * Number of links in each PHY core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_phy_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_links_in_phy_core_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fmacs_in_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_fmacs_in_fsrd'
 * Number of FMAC blocks for each FSRD block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fmacs_in_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_blocks_nof_fmacs_in_fsrd_get_f) (
    int unit);

/**
 * \brief get table override entry 
 * blocks enable/disable override
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     override - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_override_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_blocks_override_t *(
    *dnxf_data_device_blocks_override_get_f) (
    int unit,
    int index);

/**
 * \brief get table fsrd_sbus_chain entry 
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] fsrd_id - FSRD ID
 * 
 * \return
 *     fsrd_sbus_chain - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_fsrd_sbus_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_blocks_fsrd_sbus_chain_t *(
    *dnxf_data_device_blocks_fsrd_sbus_chain_get_f) (
    int unit,
    int fsrd_id);

/**
 * \brief get table fmac_sbus_chain entry 
 * The order of FMACs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] fmac_id - FMAC ID
 * 
 * \return
 *     fmac_sbus_chain - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_fmac_sbus_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_blocks_fmac_sbus_chain_t *(
    *dnxf_data_device_blocks_fmac_sbus_chain_get_f) (
    int unit,
    int fmac_id);

/**
 * \brief get table fmac_lane_to_block_map entry 
 * Maps FMAC lane to other block instances. Some devices intruduce a complex mapping of FMAC lane to core links.
 * 
 * \param [in] unit - unit #
 * \param [in] fmac_lane - Table entry index
 * 
 * \return
 *     fmac_lane_to_block_map - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_fmac_lane_to_block_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_blocks_fmac_lane_to_block_map_t *(
    *dnxf_data_device_blocks_fmac_lane_to_block_map_get_f) (
    int unit,
    int fmac_lane);

/**
 * \brief get table dch_instances_to_device_stage entry 
 * Describres which DCH blocks are facing FAP and which face FE2. information is relevant only for FE13 mode. From this RX infotmation we can deduce what are the values for DCML blocks - they are the oposite.
 * 
 * \param [in] unit - unit #
 * \param [in] device_stage - Device mode of type soc_dnxf_block_mapping_stage_type_t, 0 - FE1, 1 - FE3
 * 
 * \return
 *     dch_instances_to_device_stage - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_dch_instances_to_device_stage_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_blocks_dch_instances_to_device_stage_t *(
    *dnxf_data_device_blocks_dch_instances_to_device_stage_get_f) (
    int unit,
    int device_stage);

/**
 * \brief get table power_down_per_rtp entry 
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 * 
 * \param [in] unit - unit #
 * \param [in] index - Running index
 * 
 * \return
 *     power_down_per_rtp - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_power_down_per_rtp_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_blocks_power_down_per_rtp_t *(
    *dnxf_data_device_blocks_power_down_per_rtp_get_f) (
    int unit,
    int index);

/**
 * \brief get table power_down_per_dch entry 
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 * 
 * \param [in] unit - unit #
 * \param [in] index - Running index
 * 
 * \return
 *     power_down_per_dch - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_power_down_per_dch_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_blocks_power_down_per_dch_t *(
    *dnxf_data_device_blocks_power_down_per_dch_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - BLOCKS:
 * {
 */
/**
 * \brief Interface for device blocks data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_blocks_feature_get_f feature_get;
    /**
     * returns define data of nof_all_blocks
     */
    dnxf_data_device_blocks_nof_all_blocks_get_f nof_all_blocks_get;
    /**
     * returns define data of nof_instances_fmac
     */
    dnxf_data_device_blocks_nof_instances_fmac_get_f nof_instances_fmac_get;
    /**
     * returns define data of nof_links_in_fmac
     */
    dnxf_data_device_blocks_nof_links_in_fmac_get_f nof_links_in_fmac_get;
    /**
     * returns define data of nof_instances_fsrd
     */
    dnxf_data_device_blocks_nof_instances_fsrd_get_f nof_instances_fsrd_get;
    /**
     * returns define data of nof_instances_brdc_fsrd
     */
    dnxf_data_device_blocks_nof_instances_brdc_fsrd_get_f nof_instances_brdc_fsrd_get;
    /**
     * returns define data of nof_instances_dch
     */
    dnxf_data_device_blocks_nof_instances_dch_get_f nof_instances_dch_get;
    /**
     * returns define data of nof_links_in_dch
     */
    dnxf_data_device_blocks_nof_links_in_dch_get_f nof_links_in_dch_get;
    /**
     * returns define data of nof_dch_link_groups
     */
    dnxf_data_device_blocks_nof_dch_link_groups_get_f nof_dch_link_groups_get;
    /**
     * returns define data of nof_instances_cch
     */
    dnxf_data_device_blocks_nof_instances_cch_get_f nof_instances_cch_get;
    /**
     * returns define data of nof_links_in_cch
     */
    dnxf_data_device_blocks_nof_links_in_cch_get_f nof_links_in_cch_get;
    /**
     * returns define data of nof_links_in_dcq
     */
    dnxf_data_device_blocks_nof_links_in_dcq_get_f nof_links_in_dcq_get;
    /**
     * returns define data of nof_instances_rtp
     */
    dnxf_data_device_blocks_nof_instances_rtp_get_f nof_instances_rtp_get;
    /**
     * returns define data of nof_links_in_rtp
     */
    dnxf_data_device_blocks_nof_links_in_rtp_get_f nof_links_in_rtp_get;
    /**
     * returns define data of nof_instances_occg
     */
    dnxf_data_device_blocks_nof_instances_occg_get_f nof_instances_occg_get;
    /**
     * returns define data of nof_instances_eci
     */
    dnxf_data_device_blocks_nof_instances_eci_get_f nof_instances_eci_get;
    /**
     * returns define data of nof_instances_cmic
     */
    dnxf_data_device_blocks_nof_instances_cmic_get_f nof_instances_cmic_get;
    /**
     * returns define data of nof_instances_mesh_topology
     */
    dnxf_data_device_blocks_nof_instances_mesh_topology_get_f nof_instances_mesh_topology_get;
    /**
     * returns define data of nof_instances_brdc_fmach
     */
    dnxf_data_device_blocks_nof_instances_brdc_fmach_get_f nof_instances_brdc_fmach_get;
    /**
     * returns define data of nof_instances_brdc_fmacl
     */
    dnxf_data_device_blocks_nof_instances_brdc_fmacl_get_f nof_instances_brdc_fmacl_get;
    /**
     * returns define data of nof_instances_lcm
     */
    dnxf_data_device_blocks_nof_instances_lcm_get_f nof_instances_lcm_get;
    /**
     * returns define data of nof_instances_mct
     */
    dnxf_data_device_blocks_nof_instances_mct_get_f nof_instances_mct_get;
    /**
     * returns define data of nof_instances_qrh
     */
    dnxf_data_device_blocks_nof_instances_qrh_get_f nof_instances_qrh_get;
    /**
     * returns define data of nof_instances_dcml
     */
    dnxf_data_device_blocks_nof_instances_dcml_get_f nof_instances_dcml_get;
    /**
     * returns define data of nof_links_in_dcml
     */
    dnxf_data_device_blocks_nof_links_in_dcml_get_f nof_links_in_dcml_get;
    /**
     * returns define data of nof_links_in_lcm
     */
    dnxf_data_device_blocks_nof_links_in_lcm_get_f nof_links_in_lcm_get;
    /**
     * returns define data of nof_links_in_qrh
     */
    dnxf_data_device_blocks_nof_links_in_qrh_get_f nof_links_in_qrh_get;
    /**
     * returns define data of nof_dtm_fifos
     */
    dnxf_data_device_blocks_nof_dtm_fifos_get_f nof_dtm_fifos_get;
    /**
     * returns define data of nof_links_in_fsrd
     */
    dnxf_data_device_blocks_nof_links_in_fsrd_get_f nof_links_in_fsrd_get;
    /**
     * returns define data of nof_links_in_phy_core
     */
    dnxf_data_device_blocks_nof_links_in_phy_core_get_f nof_links_in_phy_core_get;
    /**
     * returns define data of nof_fmacs_in_fsrd
     */
    dnxf_data_device_blocks_nof_fmacs_in_fsrd_get_f nof_fmacs_in_fsrd_get;
    /**
     * get table override entry 
     */
    dnxf_data_device_blocks_override_get_f override_get;
    /**
     * get general info table about table (for example key size)override info
     */
    dnxc_data_table_info_get_f override_info_get;
    /**
     * get table fsrd_sbus_chain entry 
     */
    dnxf_data_device_blocks_fsrd_sbus_chain_get_f fsrd_sbus_chain_get;
    /**
     * get general info table about table (for example key size)fsrd_sbus_chain info
     */
    dnxc_data_table_info_get_f fsrd_sbus_chain_info_get;
    /**
     * get table fmac_sbus_chain entry 
     */
    dnxf_data_device_blocks_fmac_sbus_chain_get_f fmac_sbus_chain_get;
    /**
     * get general info table about table (for example key size)fmac_sbus_chain info
     */
    dnxc_data_table_info_get_f fmac_sbus_chain_info_get;
    /**
     * get table fmac_lane_to_block_map entry 
     */
    dnxf_data_device_blocks_fmac_lane_to_block_map_get_f fmac_lane_to_block_map_get;
    /**
     * get general info table about table (for example key size)fmac_lane_to_block_map info
     */
    dnxc_data_table_info_get_f fmac_lane_to_block_map_info_get;
    /**
     * get table dch_instances_to_device_stage entry 
     */
    dnxf_data_device_blocks_dch_instances_to_device_stage_get_f dch_instances_to_device_stage_get;
    /**
     * get general info table about table (for example key size)dch_instances_to_device_stage info
     */
    dnxc_data_table_info_get_f dch_instances_to_device_stage_info_get;
    /**
     * get table power_down_per_rtp entry 
     */
    dnxf_data_device_blocks_power_down_per_rtp_get_f power_down_per_rtp_get;
    /**
     * get general info table about table (for example key size)power_down_per_rtp info
     */
    dnxc_data_table_info_get_f power_down_per_rtp_info_get;
    /**
     * get table power_down_per_dch entry 
     */
    dnxf_data_device_blocks_power_down_per_dch_get_f power_down_per_dch_get;
    /**
     * get general info table about table (for example key size)power_down_per_dch info
     */
    dnxc_data_table_info_get_f power_down_per_dch_info_get;
} dnxf_data_if_device_blocks_t;

/*
 * }
 */

/*
 * SUBMODULE  - INTERRUPTS:
 * General interrupts information
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_interrupts_feature_nof
} dnxf_data_device_interrupts_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_interrupts_feature_get_f) (
    int unit,
    dnxf_data_device_interrupts_feature_e feature);

/**
 * \brief returns numeric data of nof_interrupts
 * Module - 'device', Submodule - 'interrupts', data - 'nof_interrupts'
 * Number of interrupts.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_interrupts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_interrupts_nof_interrupts_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - INTERRUPTS:
 * {
 */
/**
 * \brief Interface for device interrupts data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_interrupts_feature_get_f feature_get;
    /**
     * returns numeric data of nof_interrupts
     */
    dnxf_data_device_interrupts_nof_interrupts_get_f nof_interrupts_get;
} dnxf_data_if_device_interrupts_t;

/*
 * }
 */

/*
 * SUBMODULE  - CUSTOM_FEATURES:
 * Custom features
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_custom_features_feature_nof
} dnxf_data_device_custom_features_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_custom_features_feature_get_f) (
    int unit,
    dnxf_data_device_custom_features_feature_e feature);

/**
 * \brief returns numeric data of mesh_topology_size
 * Module - 'device', Submodule - 'custom_features', data - 'mesh_topology_size'
 * To determine if there is a multiple pipe device in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_topology_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_custom_features_mesh_topology_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of mesh_topology_fast
 * Module - 'device', Submodule - 'custom_features', data - 'mesh_topology_fast'
 * Device is in mesh topology fast mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_topology_fast - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_custom_features_mesh_topology_fast_get_f) (
    int unit);

/**
 * \brief returns numeric data of active_core
 * Module - 'device', Submodule - 'custom_features', data - 'active_core'
 * The index of the active core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     active_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_custom_features_active_core_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - CUSTOM_FEATURES:
 * {
 */
/**
 * \brief Interface for device custom_features data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_custom_features_feature_get_f feature_get;
    /**
     * returns numeric data of mesh_topology_size
     */
    dnxf_data_device_custom_features_mesh_topology_size_get_f mesh_topology_size_get;
    /**
     * returns numeric data of mesh_topology_fast
     */
    dnxf_data_device_custom_features_mesh_topology_fast_get_f mesh_topology_fast_get;
    /**
     * returns numeric data of active_core
     */
    dnxf_data_device_custom_features_active_core_get_f active_core_get;
} dnxf_data_if_device_custom_features_t;

/*
 * }
 */

/*
 * SUBMODULE  - PROPERTIES:
 * used to store information related to soc properties
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule properties table unsupported
 * Table info:
 * unsupported soc properties
 */
typedef struct
{
    /**
     * soc property name
     */
    char *property;
    
    char *suffix;
    /**
     * max number of index to check in case using suffix_num method
     */
    int num_max;
    /**
     * 1 if the soc property might be read per port
     */
    int per_port;
    /**
     * detailed error message with instructions what to do instead
     */
    char *err_msg;
} dnxf_data_device_properties_unsupported_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_properties_feature_nof
} dnxf_data_device_properties_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_properties_feature_get_f) (
    int unit,
    dnxf_data_device_properties_feature_e feature);

/**
 * \brief get table unsupported entry 
 * unsupported soc properties
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     unsupported - returns the relevant entry values grouped in struct - see dnxf_data_device_properties_unsupported_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_device_properties_unsupported_t *(
    *dnxf_data_device_properties_unsupported_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - PROPERTIES:
 * {
 */
/**
 * \brief Interface for device properties data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_properties_feature_get_f feature_get;
    /**
     * get table unsupported entry 
     */
    dnxf_data_device_properties_unsupported_get_f unsupported_get;
    /**
     * get general info table about table (for example key size)unsupported info
     */
    dnxc_data_table_info_get_f unsupported_info_get;
} dnxf_data_if_device_properties_t;

/*
 * }
 */

/*
 * SUBMODULE  - EMULATION:
 * Emulation attributes
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_emulation_feature_nof
} dnxf_data_device_emulation_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_device_emulation_feature_get_f) (
    int unit,
    dnxf_data_device_emulation_feature_e feature);

/**
 * \brief returns numeric data of emulation_system
 * Module - 'device', Submodule - 'emulation', data - 'emulation_system'
 * Checking if the device is ran on emulation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     emulation_system - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_device_emulation_emulation_system_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_DEVICE - EMULATION:
 * {
 */
/**
 * \brief Interface for device emulation data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_device_emulation_feature_get_f feature_get;
    /**
     * returns numeric data of emulation_system
     */
    dnxf_data_device_emulation_emulation_system_get_f emulation_system_get;
} dnxf_data_if_device_emulation_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNXF_DATA_IF_DEVICE:
 * {
 */
/**
 * \brief Interface for device data
 */
typedef struct
{
    /**
     * Interface for device general data
     */
    dnxf_data_if_device_general_t general;
    /**
     * Interface for device access data
     */
    dnxf_data_if_device_access_t access;
    /**
     * Interface for device blocks data
     */
    dnxf_data_if_device_blocks_t blocks;
    /**
     * Interface for device interrupts data
     */
    dnxf_data_if_device_interrupts_t interrupts;
    /**
     * Interface for device custom_features data
     */
    dnxf_data_if_device_custom_features_t custom_features;
    /**
     * Interface for device properties data
     */
    dnxf_data_if_device_properties_t properties;
    /**
     * Interface for device emulation data
     */
    dnxf_data_if_device_emulation_t emulation;
} dnxf_data_if_device_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnxf_data_if_device_t dnxf_data_device;
/*
 * }
 */
/*}*/
#endif /*_DNXF_DATA_DEVICE_H_*/
/* *INDENT-ON* */
