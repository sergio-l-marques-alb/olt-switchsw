/** \file dnxf_data_internal_port.h
 * 
 * MODULE DEVICE DATA - DNXF_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNXF_DATA_INTERNAL_PORT_H_
/*{*/
#define _DNXF_DATA_INTERNAL_PORT_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_internal.h>
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_port.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNXF_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnxf_data_port_submodule_general,
    dnxf_data_port_submodule_stat,
    dnxf_data_port_submodule_static_add,
    dnxf_data_port_submodule_lane_map,
    dnxf_data_port_submodule_pll,
    dnxf_data_port_submodule_synce,
    dnxf_data_port_submodule_retimer,
    dnxf_data_port_submodule_regression,

    /**
     * Must be last one!
     */
    _dnxf_data_port_submodule_nof
} dnxf_data_port_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GENERAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_general_feature_get(
    int unit,
    dnxf_data_port_general_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_general_define_nof_links,
    dnxf_data_port_general_define_nof_pms,
    dnxf_data_port_general_define_max_bucket_fill_rate,
    dnxf_data_port_general_define_link_mask,
    dnxf_data_port_general_define_aldwp_max_val,
    dnxf_data_port_general_define_fmac_clock_khz,
    dnxf_data_port_general_define_speed_max,
    dnxf_data_port_general_define_fmac_tx_padding_min_port_speed,
    dnxf_data_port_general_define_fw_load_method,
    dnxf_data_port_general_define_fw_crc_check,
    dnxf_data_port_general_define_fw_load_verify,
    dnxf_data_port_general_define_mac_bucket_fill_rate,

    /**
     * Must be last one!
     */
    _dnxf_data_port_general_define_nof
} dnxf_data_port_general_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_links
 * Module - 'port', Submodule - 'general', data - 'nof_links'
 * Number of links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_nof_links_get(
    int unit);

/**
 * \brief returns define data of nof_pms
 * Module - 'port', Submodule - 'general', data - 'nof_pms'
 * Number of port macros.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_nof_pms_get(
    int unit);

/**
 * \brief returns define data of max_bucket_fill_rate
 * Module - 'port', Submodule - 'general', data - 'max_bucket_fill_rate'
 * Max bucket fill rate.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_bucket_fill_rate - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_max_bucket_fill_rate_get(
    int unit);

/**
 * \brief returns define data of link_mask
 * Module - 'port', Submodule - 'general', data - 'link_mask'
 * Mask adjusted to number of links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     link_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_link_mask_get(
    int unit);

/**
 * \brief returns define data of aldwp_max_val
 * Module - 'port', Submodule - 'general', data - 'aldwp_max_val'
 * Maximum value of ALDWP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aldwp_max_val - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_aldwp_max_val_get(
    int unit);

/**
 * \brief returns define data of fmac_clock_khz
 * Module - 'port', Submodule - 'general', data - 'fmac_clock_khz'
 * FMAC clock frequency [KHz]
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fmac_clock_khz_get(
    int unit);

/**
 * \brief returns define data of speed_max
 * Module - 'port', Submodule - 'general', data - 'speed_max'
 * Maximum speed of a port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     speed_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_speed_max_get(
    int unit);

/**
 * \brief returns define data of fmac_tx_padding_min_port_speed
 * Module - 'port', Submodule - 'general', data - 'fmac_tx_padding_min_port_speed'
 * Minimum port speed requred to enable FMAC Tx Padding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_tx_padding_min_port_speed - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fmac_tx_padding_min_port_speed_get(
    int unit);

/**
 * \brief returns numeric data of fw_load_method
 * Module - 'port', Submodule - 'general', data - 'fw_load_method'
 * The method of the firmware load.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_load_method - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fw_load_method_get(
    int unit);

/**
 * \brief returns numeric data of fw_crc_check
 * Module - 'port', Submodule - 'general', data - 'fw_crc_check'
 * Enable firmware CRC check.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_crc_check - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fw_crc_check_get(
    int unit);

/**
 * \brief returns numeric data of fw_load_verify
 * Module - 'port', Submodule - 'general', data - 'fw_load_verify'
 * Enable firmware load verification.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_load_verify - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fw_load_verify_get(
    int unit);

/**
 * \brief returns numeric data of mac_bucket_fill_rate
 * Module - 'port', Submodule - 'general', data - 'mac_bucket_fill_rate'
 * Mac bucket fill rate.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_bucket_fill_rate - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_mac_bucket_fill_rate_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_general_table_supported_phys,
    dnxf_data_port_general_table_fmac_bus_size,
    dnxf_data_port_general_table_supported_interfaces,
    dnxf_data_port_general_table_default_fec,
    dnxf_data_port_general_table_supported_fec_controls,
    dnxf_data_port_general_table_supported_fmac_tx_padding_sizes,

    /**
     * Must be last one!
     */
    _dnxf_data_port_general_table_nof
} dnxf_data_port_general_table_e;

/* Get Data */
/**
 * \brief get table supported_phys entry 
 * general data about phys
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_phys - returns the relevant entry values grouped in struct - see dnxf_data_port_general_supported_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_general_supported_phys_t * dnxf_data_port_general_supported_phys_get(
    int unit);

/**
 * \brief get table fmac_bus_size entry 
 * Fabric MAC bus size [bits]
 * 
 * \param [in] unit - unit #
 * \param [in] mode - Fabric MAC mode (FEC type)
 * 
 * \return
 *     fmac_bus_size - returns the relevant entry values grouped in struct - see dnxf_data_port_general_fmac_bus_size_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_general_fmac_bus_size_t * dnxf_data_port_general_fmac_bus_size_get(
    int unit,
    int mode);

/**
 * \brief get table supported_interfaces entry 
 * table with all supported by the device speeds
 * 
 * \param [in] unit - unit #
 * \param [in] index - entry index
 * 
 * \return
 *     supported_interfaces - returns the relevant entry values grouped in struct - see dnxf_data_port_general_supported_interfaces_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_general_supported_interfaces_t * dnxf_data_port_general_supported_interfaces_get(
    int unit,
    int index);

/**
 * \brief get table default_fec entry 
 * table with the default FEC type per speed
 * 
 * \param [in] unit - unit #
 * \param [in] speed - Fabric lane serdes speed.
 * 
 * \return
 *     default_fec - returns the relevant entry values grouped in struct - see dnxf_data_port_general_default_fec_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_general_default_fec_t * dnxf_data_port_general_default_fec_get(
    int unit,
    int speed);

/**
 * \brief get table supported_fec_controls entry 
 * table with supported combinations of FEC type and FEC controls
 * 
 * \param [in] unit - unit #
 * \param [in] index - entry_index
 * 
 * \return
 *     supported_fec_controls - returns the relevant entry values grouped in struct - see dnxf_data_port_general_supported_fec_controls_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_general_supported_fec_controls_t * dnxf_data_port_general_supported_fec_controls_get(
    int unit,
    int index);

/**
 * \brief get table supported_fmac_tx_padding_sizes entry 
 * table with all supported FMAC Tx padding sizes
 * 
 * \param [in] unit - unit #
 * \param [in] index - FMAC Tx Padding size
 * 
 * \return
 *     supported_fmac_tx_padding_sizes - returns the relevant entry values grouped in struct - see dnxf_data_port_general_supported_fmac_tx_padding_sizes_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_general_supported_fmac_tx_padding_sizes_t * dnxf_data_port_general_supported_fmac_tx_padding_sizes_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'supported_phys'
 * general data about phys
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_general_supported_phys_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'fmac_bus_size'
 * Fabric MAC bus size [bits]
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_general_fmac_bus_size_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'supported_interfaces'
 * table with all supported by the device speeds
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_general_supported_interfaces_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'default_fec'
 * table with the default FEC type per speed
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_general_default_fec_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'supported_fec_controls'
 * table with supported combinations of FEC type and FEC controls
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_general_supported_fec_controls_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'supported_fmac_tx_padding_sizes'
 * table with all supported FMAC Tx padding sizes
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_general_supported_fmac_tx_padding_sizes_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)supported_phys info
 * general data about phys
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_phys - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_general_supported_phys_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fmac_bus_size info
 * Fabric MAC bus size [bits]
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_bus_size - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_general_fmac_bus_size_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_interfaces info
 * table with all supported by the device speeds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_interfaces - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_general_supported_interfaces_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)default_fec info
 * table with the default FEC type per speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_fec - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_general_default_fec_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_fec_controls info
 * table with supported combinations of FEC type and FEC controls
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_fec_controls - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_general_supported_fec_controls_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)supported_fmac_tx_padding_sizes info
 * table with all supported FMAC Tx padding sizes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_fmac_tx_padding_sizes - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_general_supported_fmac_tx_padding_sizes_info_get(
    int unit);

/*
 * SUBMODULE STAT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_stat_feature_get(
    int unit,
    dnxf_data_port_stat_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_stat_define_thread_interval,
    dnxf_data_port_stat_define_thread_flags,
    dnxf_data_port_stat_define_thread_counter_pri,
    dnxf_data_port_stat_define_thread_timeout,

    /**
     * Must be last one!
     */
    _dnxf_data_port_stat_define_nof
} dnxf_data_port_stat_define_e;

/* Get Data */
/**
 * \brief returns numeric data of thread_interval
 * Module - 'port', Submodule - 'stat', data - 'thread_interval'
 * Statistics thread interval in microseconds.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_interval - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_stat_thread_interval_get(
    int unit);

/**
 * \brief returns numeric data of thread_flags
 * Module - 'port', Submodule - 'stat', data - 'thread_flags'
 * Statistics thread flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_stat_thread_flags_get(
    int unit);

/**
 * \brief returns numeric data of thread_counter_pri
 * Module - 'port', Submodule - 'stat', data - 'thread_counter_pri'
 * Counter thread priority.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_counter_pri - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_stat_thread_counter_pri_get(
    int unit);

/**
 * \brief returns numeric data of thread_timeout
 * Module - 'port', Submodule - 'stat', data - 'thread_timeout'
 * Statistics thread sync operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_stat_thread_timeout_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_stat_table_nof
} dnxf_data_port_stat_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE STATIC_ADD:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_static_add_feature_get(
    int unit,
    dnxf_data_port_static_add_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_static_add_define_nof
} dnxf_data_port_static_add_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_static_add_table_port_info,
    dnxf_data_port_static_add_table_serdes_lane_config,
    dnxf_data_port_static_add_table_serdes_tx_taps,
    dnxf_data_port_static_add_table_quad_info,
    dnxf_data_port_static_add_table_cable_swap_info,

    /**
     * Must be last one!
     */
    _dnxf_data_port_static_add_table_nof
} dnxf_data_port_static_add_table_e;

/* Get Data */
/**
 * \brief get table port_info entry 
 * General port info
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     port_info - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_port_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_port_info_t * dnxf_data_port_static_add_port_info_get(
    int unit,
    int port);

/**
 * \brief get table serdes_lane_config entry 
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     serdes_lane_config - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_serdes_lane_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_serdes_lane_config_t * dnxf_data_port_static_add_serdes_lane_config_get(
    int unit,
    int port);

/**
 * \brief get table serdes_tx_taps entry 
 * TX FIR parameters
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     serdes_tx_taps - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_serdes_tx_taps_t * dnxf_data_port_static_add_serdes_tx_taps_get(
    int unit,
    int port);

/**
 * \brief get table quad_info entry 
 * General quad info
 * 
 * \param [in] unit - unit #
 * \param [in] quad - Quad ID.
 * 
 * \return
 *     quad_info - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_quad_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_quad_info_t * dnxf_data_port_static_add_quad_info_get(
    int unit,
    int quad);

/**
 * \brief get table cable_swap_info entry 
 * Cable swap info
 * 
 * \param [in] unit - unit #
 * \param [in] pm - PM ID
 * 
 * \return
 *     cable_swap_info - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_cable_swap_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_cable_swap_info_t * dnxf_data_port_static_add_cable_swap_info_get(
    int unit,
    int pm);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'port_info'
 * General port info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_port_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'serdes_lane_config'
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_serdes_lane_config_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'serdes_tx_taps'
 * TX FIR parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_serdes_tx_taps_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'quad_info'
 * General quad info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_quad_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'cable_swap_info'
 * Cable swap info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_cable_swap_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)port_info info
 * General port info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_port_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)serdes_lane_config info
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     serdes_lane_config - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_serdes_lane_config_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)serdes_tx_taps info
 * TX FIR parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     serdes_tx_taps - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_serdes_tx_taps_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)quad_info info
 * General quad info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     quad_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_quad_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)cable_swap_info info
 * Cable swap info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cable_swap_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_cable_swap_info_info_get(
    int unit);

/*
 * SUBMODULE LANE_MAP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_lane_map_feature_get(
    int unit,
    dnxf_data_port_lane_map_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_lane_map_define_lane_map_bound,

    /**
     * Must be last one!
     */
    _dnxf_data_port_lane_map_define_nof
} dnxf_data_port_lane_map_define_e;

/* Get Data */
/**
 * \brief returns define data of lane_map_bound
 * Module - 'port', Submodule - 'lane_map', data - 'lane_map_bound'
 * Lane swapping is allowed within this nof links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lane_map_bound - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_lane_map_lane_map_bound_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_lane_map_table_info,

    /**
     * Must be last one!
     */
    _dnxf_data_port_lane_map_table_nof
} dnxf_data_port_lane_map_table_e;

/* Get Data */
/**
 * \brief get table info entry 
 * Shows the DB for the mapping between the lanes and the serdeses.
 * 
 * \param [in] unit - unit #
 * \param [in] lane - Use lane as a key to return its serdes mapping values
 * 
 * \return
 *     info - returns the relevant entry values grouped in struct - see dnxf_data_port_lane_map_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_lane_map_info_t * dnxf_data_port_lane_map_info_get(
    int unit,
    int lane);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'lane_map', table - 'info'
 * Shows the DB for the mapping between the lanes and the serdeses.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_lane_map_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)info info
 * Shows the DB for the mapping between the lanes and the serdeses.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_lane_map_info_info_get(
    int unit);

/*
 * SUBMODULE PLL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_pll_feature_get(
    int unit,
    dnxf_data_port_pll_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_pll_define_nof_lcpll,
    dnxf_data_port_pll_define_nof_port_in_lcpll,
    dnxf_data_port_pll_define_fabric_clock_freq_in_default,
    dnxf_data_port_pll_define_fabric_clock_freq_out_default,
    dnxf_data_port_pll_define_nof_plls_per_pm,
    dnxf_data_port_pll_define_nof_config_words,

    /**
     * Must be last one!
     */
    _dnxf_data_port_pll_define_nof
} dnxf_data_port_pll_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_lcpll
 * Module - 'port', Submodule - 'pll', data - 'nof_lcpll'
 * Number of LCPLL.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lcpll - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_nof_lcpll_get(
    int unit);

/**
 * \brief returns define data of nof_port_in_lcpll
 * Module - 'port', Submodule - 'pll', data - 'nof_port_in_lcpll'
 * Number of ports for each LCPLL.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_port_in_lcpll - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_nof_port_in_lcpll_get(
    int unit);

/**
 * \brief returns define data of fabric_clock_freq_in_default
 * Module - 'port', Submodule - 'pll', data - 'fabric_clock_freq_in_default'
 * Fabric Clock freq in default.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_clock_freq_in_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_fabric_clock_freq_in_default_get(
    int unit);

/**
 * \brief returns define data of fabric_clock_freq_out_default
 * Module - 'port', Submodule - 'pll', data - 'fabric_clock_freq_out_default'
 * Fabric Clock freq out default.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_clock_freq_out_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_fabric_clock_freq_out_default_get(
    int unit);

/**
 * \brief returns define data of nof_plls_per_pm
 * Module - 'port', Submodule - 'pll', data - 'nof_plls_per_pm'
 * Number of PLLs per port macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_plls_per_pm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_nof_plls_per_pm_get(
    int unit);

/**
 * \brief returns define data of nof_config_words
 * Module - 'port', Submodule - 'pll', data - 'nof_config_words'
 * Number of PLL configuration words
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_config_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_nof_config_words_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_pll_table_info,
    dnxf_data_port_pll_table_force_single_pll,
    dnxf_data_port_pll_table_config,

    /**
     * Must be last one!
     */
    _dnxf_data_port_pll_table_nof
} dnxf_data_port_pll_table_e;

/* Get Data */
/**
 * \brief get table info entry 
 * General PLL info
 * 
 * \param [in] unit - unit #
 * \param [in] pll - PLL ID.
 * 
 * \return
 *     info - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_pll_info_t * dnxf_data_port_pll_info_get(
    int unit,
    int pll);

/**
 * \brief get table force_single_pll entry 
 * 
 * \param [in] unit - unit #
 * \param [in] pm - pm id
 * 
 * \return
 *     force_single_pll - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_force_single_pll_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_pll_force_single_pll_t * dnxf_data_port_pll_force_single_pll_get(
    int unit,
    int pm);

/**
 * \brief get table config entry 
 * PLL configuration
 * 
 * \param [in] unit - unit #
 * \param [in] fabric_ref_clk_in - PLL Input Reference Clock
 * \param [in] fabric_ref_clk_out - PLL Output Reference Clock
 * 
 * \return
 *     config - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_pll_config_t * dnxf_data_port_pll_config_get(
    int unit,
    int fabric_ref_clk_in,
    int fabric_ref_clk_out);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'pll', table - 'info'
 * General PLL info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_pll_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'pll', table - 'force_single_pll'
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_pll_force_single_pll_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'pll', table - 'config'
 * PLL configuration
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_pll_config_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)info info
 * General PLL info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_pll_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)force_single_pll info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     force_single_pll - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_pll_force_single_pll_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)config info
 * PLL configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     config - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_pll_config_info_get(
    int unit);

/*
 * SUBMODULE SYNCE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_synce_feature_get(
    int unit,
    dnxf_data_port_synce_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_synce_define_fabric_div_min,
    dnxf_data_port_synce_define_fabric_div_max,

    /**
     * Must be last one!
     */
    _dnxf_data_port_synce_define_nof
} dnxf_data_port_synce_define_e;

/* Get Data */
/**
 * \brief returns define data of fabric_div_min
 * Module - 'port', Submodule - 'synce', data - 'fabric_div_min'
 * Min value for the fabric synce output clk.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_div_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_synce_fabric_div_min_get(
    int unit);

/**
 * \brief returns define data of fabric_div_max
 * Module - 'port', Submodule - 'synce', data - 'fabric_div_max'
 * Max value for the fabric synce output clk.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_div_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_synce_fabric_div_max_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_synce_table_cfg,
    dnxf_data_port_synce_table_pm_to_ipw_mapping,
    dnxf_data_port_synce_table_ipw_info,

    /**
     * Must be last one!
     */
    _dnxf_data_port_synce_table_nof
} dnxf_data_port_synce_table_e;

/* Get Data */
/**
 * \brief get table cfg entry 
 * Fabric Sync Ethernet information.
 * 
 * \param [in] unit - unit #
 * \param [in] synce_index - SYNCE clock index.
 * 
 * \return
 *     cfg - returns the relevant entry values grouped in struct - see dnxf_data_port_synce_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_synce_cfg_t * dnxf_data_port_synce_cfg_get(
    int unit,
    int synce_index);

/**
 * \brief get table pm_to_ipw_mapping entry 
 * serdes to ipw mapping
 * 
 * \param [in] unit - unit #
 * \param [in] pm_idx - pm index
 * 
 * \return
 *     pm_to_ipw_mapping - returns the relevant entry values grouped in struct - see dnxf_data_port_synce_pm_to_ipw_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_synce_pm_to_ipw_mapping_t * dnxf_data_port_synce_pm_to_ipw_mapping_get(
    int unit,
    int pm_idx);

/**
 * \brief get table ipw_info entry 
 * The first pm index for each ipw
 * 
 * \param [in] unit - unit #
 * \param [in] ipw - ipw index
 * 
 * \return
 *     ipw_info - returns the relevant entry values grouped in struct - see dnxf_data_port_synce_ipw_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_synce_ipw_info_t * dnxf_data_port_synce_ipw_info_get(
    int unit,
    int ipw);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'synce', table - 'cfg'
 * Fabric Sync Ethernet information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_synce_cfg_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'synce', table - 'pm_to_ipw_mapping'
 * serdes to ipw mapping
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_synce_pm_to_ipw_mapping_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'synce', table - 'ipw_info'
 * The first pm index for each ipw
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_synce_ipw_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)cfg info
 * Fabric Sync Ethernet information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cfg - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_synce_cfg_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)pm_to_ipw_mapping info
 * serdes to ipw mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pm_to_ipw_mapping - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_synce_pm_to_ipw_mapping_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)ipw_info info
 * The first pm index for each ipw
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipw_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_synce_ipw_info_info_get(
    int unit);

/*
 * SUBMODULE RETIMER:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_retimer_feature_get(
    int unit,
    dnxf_data_port_retimer_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_retimer_define_nof
} dnxf_data_port_retimer_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_retimer_table_links_connection,

    /**
     * Must be last one!
     */
    _dnxf_data_port_retimer_table_nof
} dnxf_data_port_retimer_table_e;

/* Get Data */
/**
 * \brief get table links_connection entry 
 * Link pairs for pass-through retimer
 * 
 * \param [in] unit - unit #
 * \param [in] link - link id
 * 
 * \return
 *     links_connection - returns the relevant entry values grouped in struct - see dnxf_data_port_retimer_links_connection_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_retimer_links_connection_t * dnxf_data_port_retimer_links_connection_get(
    int unit,
    int link);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'retimer', table - 'links_connection'
 * Link pairs for pass-through retimer
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_retimer_links_connection_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)links_connection info
 * Link pairs for pass-through retimer
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     links_connection - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_retimer_links_connection_info_get(
    int unit);

/*
 * SUBMODULE REGRESSION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_regression_feature_get(
    int unit,
    dnxf_data_port_regression_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_regression_define_nof
} dnxf_data_port_regression_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_regression_table_nof
} dnxf_data_port_regression_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNXF_DATA_INTERNAL_PORT_H_*/
/* *INDENT-ON* */
