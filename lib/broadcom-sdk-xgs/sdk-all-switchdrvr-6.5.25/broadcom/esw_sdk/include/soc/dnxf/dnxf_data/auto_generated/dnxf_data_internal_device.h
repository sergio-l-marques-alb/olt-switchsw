/** \file dnxf_data_internal_device.h
 * 
 * MODULE DEVICE DATA - DNXF_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2021 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNXF_DATA_INTERNAL_DEVICE_H_
/*{*/
#define _DNXF_DATA_INTERNAL_DEVICE_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_internal.h>
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_device.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNXF_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnxf_data_device_submodule_general,
    dnxf_data_device_submodule_access,
    dnxf_data_device_submodule_blocks,
    dnxf_data_device_submodule_interrupts,
    dnxf_data_device_submodule_custom_features,
    dnxf_data_device_submodule_properties,
    dnxf_data_device_submodule_emulation,

    /**
     * Must be last one!
     */
    _dnxf_data_device_submodule_nof
} dnxf_data_device_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GENERAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_general_feature_get(
    int unit,
    dnxf_data_device_general_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_general_define_nof_pvt_monitors,
    dnxf_data_device_general_define_pvt_base,
    dnxf_data_device_general_define_pvt_factor,
    dnxf_data_device_general_define_nof_cores,
    dnxf_data_device_general_define_adapter_lib_ver,
    dnxf_data_device_general_define_nof_mesh_topology_links_data,
    dnxf_data_device_general_define_hard_reset_disable,
    dnxf_data_device_general_define_core_clock_khz,
    dnxf_data_device_general_define_system_ref_core_clock_khz,
    dnxf_data_device_general_define_device_id,

    /**
     * Must be last one!
     */
    _dnxf_data_device_general_define_nof
} dnxf_data_device_general_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_pvt_monitors
 * Module - 'device', Submodule - 'general', data - 'nof_pvt_monitors'
 * Number of device PVT monitors
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pvt_monitors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_nof_pvt_monitors_get(
    int unit);

/**
 * \brief returns define data of pvt_base
 * Module - 'device', Submodule - 'general', data - 'pvt_base'
 * PVT base. Used for correct calculation of the monitor readings
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pvt_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_general_pvt_base_get(
    int unit);

/**
 * \brief returns define data of pvt_factor
 * Module - 'device', Submodule - 'general', data - 'pvt_factor'
 * PVT factor Used for correct calculation of the monitor readings
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pvt_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_general_pvt_factor_get(
    int unit);

/**
 * \brief returns define data of nof_cores
 * Module - 'device', Submodule - 'general', data - 'nof_cores'
 * Number of cores in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cores - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_nof_cores_get(
    int unit);

/**
 * \brief returns define data of adapter_lib_ver
 * Module - 'device', Submodule - 'general', data - 'adapter_lib_ver'
 * Indicate the adapter lib version
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     adapter_lib_ver - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_adapter_lib_ver_get(
    int unit);

/**
 * \brief returns define data of nof_mesh_topology_links_data
 * Module - 'device', Submodule - 'general', data - 'nof_mesh_topology_links_data'
 * Indicates the nof mesh_topology link data
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mesh_topology_links_data - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_nof_mesh_topology_links_data_get(
    int unit);

/**
 * \brief returns numeric data of hard_reset_disable
 * Module - 'device', Submodule - 'general', data - 'hard_reset_disable'
 * Init device without hard reset.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hard_reset_disable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_hard_reset_disable_get(
    int unit);

/**
 * \brief returns numeric data of core_clock_khz
 * Module - 'device', Submodule - 'general', data - 'core_clock_khz'
 * Specifies system core clock speed in kHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     core_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_core_clock_khz_get(
    int unit);

/**
 * \brief returns numeric data of system_ref_core_clock_khz
 * Module - 'device', Submodule - 'general', data - 'system_ref_core_clock_khz'
 * Specifies system reference clock speed in kHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     system_ref_core_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_system_ref_core_clock_khz_get(
    int unit);

/**
 * \brief returns numeric data of device_id
 * Module - 'device', Submodule - 'general', data - 'device_id'
 * BCM Device ID (8XXX)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_device_id_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_device_general_table_ctest_full_file_indentifier,

    /**
     * Must be last one!
     */
    _dnxf_data_device_general_table_nof
} dnxf_data_device_general_table_e;

/* Get Data */
/**
 * \brief get table ctest_full_file_indentifier entry 
 * Indicates what is the suffix of tcl/tlist files generated by ctest export full command.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ctest_full_file_indentifier - returns the relevant entry values grouped in struct - see dnxf_data_device_general_ctest_full_file_indentifier_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_general_ctest_full_file_indentifier_t * dnxf_data_device_general_ctest_full_file_indentifier_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'general', table - 'ctest_full_file_indentifier'
 * Indicates what is the suffix of tcl/tlist files generated by ctest export full command.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_general_ctest_full_file_indentifier_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)ctest_full_file_indentifier info
 * Indicates what is the suffix of tcl/tlist files generated by ctest export full command.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ctest_full_file_indentifier - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_general_ctest_full_file_indentifier_info_get(
    int unit);

/*
 * SUBMODULE ACCESS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_access_feature_get(
    int unit,
    dnxf_data_device_access_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_access_define_table_dma_enable,
    dnxf_data_device_access_define_tdma_timeout_usec,
    dnxf_data_device_access_define_tdma_intr_enable,
    dnxf_data_device_access_define_tslam_dma_enable,
    dnxf_data_device_access_define_tslam_timeout_usec,
    dnxf_data_device_access_define_tslam_int_enable,
    dnxf_data_device_access_define_mdio_int_divisor,
    dnxf_data_device_access_define_mdio_ext_divisor,
    dnxf_data_device_access_define_mdio_int_div_out_delay,
    dnxf_data_device_access_define_mdio_ext_div_out_delay,
    dnxf_data_device_access_define_bist_enable,
    dnxf_data_device_access_define_sbus_dma_interval,
    dnxf_data_device_access_define_sbus_dma_intr_enable,
    dnxf_data_device_access_define_mem_clear_chunk_size,

    /**
     * Must be last one!
     */
    _dnxf_data_device_access_define_nof
} dnxf_data_device_access_define_e;

/* Get Data */
/**
 * \brief returns numeric data of table_dma_enable
 * Module - 'device', Submodule - 'access', data - 'table_dma_enable'
 * Enable/disable table DMA operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_table_dma_enable_get(
    int unit);

/**
 * \brief returns numeric data of tdma_timeout_usec
 * Module - 'device', Submodule - 'access', data - 'tdma_timeout_usec'
 * Table DMA operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdma_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tdma_timeout_usec_get(
    int unit);

/**
 * \brief returns numeric data of tdma_intr_enable
 * Module - 'device', Submodule - 'access', data - 'tdma_intr_enable'
 * Table DMA done is interrupt driven or by polling.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdma_intr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tdma_intr_enable_get(
    int unit);

/**
 * \brief returns numeric data of tslam_dma_enable
 * Module - 'device', Submodule - 'access', data - 'tslam_dma_enable'
 * Enable/disable tslam DMA operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tslam_dma_enable_get(
    int unit);

/**
 * \brief returns numeric data of tslam_timeout_usec
 * Module - 'device', Submodule - 'access', data - 'tslam_timeout_usec'
 * Tslam DMA operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tslam_timeout_usec_get(
    int unit);

/**
 * \brief returns numeric data of tslam_int_enable
 * Module - 'device', Submodule - 'access', data - 'tslam_int_enable'
 * Tslam DMA done is interrupt driven or by polling.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_int_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tslam_int_enable_get(
    int unit);

/**
 * \brief returns numeric data of mdio_int_divisor
 * Module - 'device', Submodule - 'access', data - 'mdio_int_divisor'
 * mdio_int_divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_int_divisor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mdio_int_divisor_get(
    int unit);

/**
 * \brief returns numeric data of mdio_ext_divisor
 * Module - 'device', Submodule - 'access', data - 'mdio_ext_divisor'
 * mdio_ext_divisor.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_ext_divisor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mdio_ext_divisor_get(
    int unit);

/**
 * \brief returns numeric data of mdio_int_div_out_delay
 * Module - 'device', Submodule - 'access', data - 'mdio_int_div_out_delay'
 * number of clock delay between the rising edge of MDC and the starting data of MDIO for internal divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_int_div_out_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mdio_int_div_out_delay_get(
    int unit);

/**
 * \brief returns numeric data of mdio_ext_div_out_delay
 * Module - 'device', Submodule - 'access', data - 'mdio_ext_div_out_delay'
 * number of clock delay between the rising edge of MDC and the starting data of MDIO for external divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_ext_div_out_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mdio_ext_div_out_delay_get(
    int unit);

/**
 * \brief returns numeric data of bist_enable
 * Module - 'device', Submodule - 'access', data - 'bist_enable'
 * Determines if to run Memory Built-In Self-Test (MBIST) of internal memory (tables) during startup.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_bist_enable_get(
    int unit);

/**
 * \brief returns numeric data of sbus_dma_interval
 * Module - 'device', Submodule - 'access', data - 'sbus_dma_interval'
 * sbus DMA operation interval.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_dma_interval - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_sbus_dma_interval_get(
    int unit);

/**
 * \brief returns numeric data of sbus_dma_intr_enable
 * Module - 'device', Submodule - 'access', data - 'sbus_dma_intr_enable'
 * sbus DMA interrupt enable.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_dma_intr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_sbus_dma_intr_enable_get(
    int unit);

/**
 * \brief returns numeric data of mem_clear_chunk_size
 * Module - 'device', Submodule - 'access', data - 'mem_clear_chunk_size'
 * sbus DMA chunk size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mem_clear_chunk_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mem_clear_chunk_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_access_table_nof
} dnxf_data_device_access_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BLOCKS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_blocks_feature_get(
    int unit,
    dnxf_data_device_blocks_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_blocks_define_nof_all_blocks,
    dnxf_data_device_blocks_define_nof_instances_fmac,
    dnxf_data_device_blocks_define_nof_links_in_fmac,
    dnxf_data_device_blocks_define_nof_instances_fsrd,
    dnxf_data_device_blocks_define_nof_instances_brdc_fsrd,
    dnxf_data_device_blocks_define_nof_instances_dch,
    dnxf_data_device_blocks_define_nof_links_in_dch,
    dnxf_data_device_blocks_define_nof_dch_link_groups,
    dnxf_data_device_blocks_define_nof_instances_cch,
    dnxf_data_device_blocks_define_nof_links_in_cch,
    dnxf_data_device_blocks_define_nof_links_in_dcq,
    dnxf_data_device_blocks_define_nof_instances_rtp,
    dnxf_data_device_blocks_define_nof_links_in_rtp,
    dnxf_data_device_blocks_define_nof_instances_occg,
    dnxf_data_device_blocks_define_nof_instances_eci,
    dnxf_data_device_blocks_define_nof_instances_cmic,
    dnxf_data_device_blocks_define_nof_instances_mesh_topology,
    dnxf_data_device_blocks_define_nof_instances_brdc_fmach,
    dnxf_data_device_blocks_define_nof_instances_brdc_fmacl,
    dnxf_data_device_blocks_define_nof_instances_lcm,
    dnxf_data_device_blocks_define_nof_instances_mct,
    dnxf_data_device_blocks_define_nof_instances_qrh,
    dnxf_data_device_blocks_define_nof_instances_dcml,
    dnxf_data_device_blocks_define_nof_links_in_dcml,
    dnxf_data_device_blocks_define_nof_links_in_lcm,
    dnxf_data_device_blocks_define_nof_links_in_qrh,
    dnxf_data_device_blocks_define_nof_dtm_fifos,
    dnxf_data_device_blocks_define_nof_links_in_fsrd,
    dnxf_data_device_blocks_define_nof_links_in_phy_core,
    dnxf_data_device_blocks_define_nof_fmacs_in_fsrd,

    /**
     * Must be last one!
     */
    _dnxf_data_device_blocks_define_nof
} dnxf_data_device_blocks_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_all_blocks
 * Module - 'device', Submodule - 'blocks', data - 'nof_all_blocks'
 * Number of block instances in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_all_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_all_blocks_get(
    int unit);

/**
 * \brief returns define data of nof_instances_fmac
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_fmac'
 * Number of FMAC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_fmac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_fmac_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_fmac
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_fmac'
 * Number of links for each FMAC block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_fmac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_fmac_get(
    int unit);

/**
 * \brief returns define data of nof_instances_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_fsrd'
 * Number of FSRD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_fsrd_get(
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fsrd'
 * Number of BRoaDCast FSRD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_brdc_fsrd_get(
    int unit);

/**
 * \brief returns define data of nof_instances_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_dch'
 * Number of DCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_dch_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dch'
 * Number of links for each DCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_dch_get(
    int unit);

/**
 * \brief returns define data of nof_dch_link_groups
 * Module - 'device', Submodule - 'blocks', data - 'nof_dch_link_groups'
 * Number of link groups for each DCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dch_link_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_dch_link_groups_get(
    int unit);

/**
 * \brief returns define data of nof_instances_cch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_cch'
 * Number of CCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_cch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_cch_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_cch
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_cch'
 * Number of links for each CCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_cch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_cch_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_dcq
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dcq'
 * Number of links for each DCQ block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dcq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_dcq_get(
    int unit);

/**
 * \brief returns define data of nof_instances_rtp
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_rtp'
 * Number of RTP instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_rtp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_rtp_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_rtp
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_rtp'
 * Number of links for each RTP block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_rtp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_rtp_get(
    int unit);

/**
 * \brief returns define data of nof_instances_occg
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_occg'
 * Number of OCCG instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_occg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_occg_get(
    int unit);

/**
 * \brief returns define data of nof_instances_eci
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_eci'
 * Number of ECI instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_eci - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_eci_get(
    int unit);

/**
 * \brief returns define data of nof_instances_cmic
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_cmic'
 * Number of CMIC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_cmic - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_cmic_get(
    int unit);

/**
 * \brief returns define data of nof_instances_mesh_topology
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_mesh_topology'
 * Number of MESH Topology instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_mesh_topology - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_mesh_topology_get(
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmach
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmach'
 * Number of BRoaDCast FMACH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmach - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_brdc_fmach_get(
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmacl
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmacl'
 * Number of BRoaDCast FMACL instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmacl - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_brdc_fmacl_get(
    int unit);

/**
 * \brief returns define data of nof_instances_lcm
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_lcm'
 * Number of LCM instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_lcm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_lcm_get(
    int unit);

/**
 * \brief returns define data of nof_instances_mct
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_mct'
 * Number of MCT instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_mct - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_mct_get(
    int unit);

/**
 * \brief returns define data of nof_instances_qrh
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_qrh'
 * Number of QRH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_qrh - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_qrh_get(
    int unit);

/**
 * \brief returns define data of nof_instances_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_dcml'
 * Number of DCML instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_dcml_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dcml'
 * Number of links for each DCML block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_dcml_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_lcm
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_lcm'
 * Number of links for each LCM block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_lcm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_lcm_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_qrh
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_qrh'
 * Number of links for each QRH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_qrh - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_qrh_get(
    int unit);

/**
 * \brief returns define data of nof_dtm_fifos
 * Module - 'device', Submodule - 'blocks', data - 'nof_dtm_fifos'
 * Number of FIFOs for each DTM block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dtm_fifos - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_dtm_fifos_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_fsrd'
 * Number of links for each FSRD block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_fsrd_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_phy_core
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_phy_core'
 * Number of links in each PHY core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_phy_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_phy_core_get(
    int unit);

/**
 * \brief returns define data of nof_fmacs_in_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_fmacs_in_fsrd'
 * Number of FMAC blocks for each FSRD block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fmacs_in_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_fmacs_in_fsrd_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_device_blocks_table_override,
    dnxf_data_device_blocks_table_fsrd_sbus_chain,
    dnxf_data_device_blocks_table_fmac_sbus_chain,
    dnxf_data_device_blocks_table_fmac_lane_to_block_map,
    dnxf_data_device_blocks_table_dch_instances_to_device_stage,
    dnxf_data_device_blocks_table_power_down_per_rtp,
    dnxf_data_device_blocks_table_power_down_per_dch,

    /**
     * Must be last one!
     */
    _dnxf_data_device_blocks_table_nof
} dnxf_data_device_blocks_table_e;

/* Get Data */
/**
 * \brief get table override entry 
 * blocks enable/disable override
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     override - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_override_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_override_t * dnxf_data_device_blocks_override_get(
    int unit,
    int index);

/**
 * \brief get table fsrd_sbus_chain entry 
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] fsrd_id - FSRD ID
 * 
 * \return
 *     fsrd_sbus_chain - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_fsrd_sbus_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_fsrd_sbus_chain_t * dnxf_data_device_blocks_fsrd_sbus_chain_get(
    int unit,
    int fsrd_id);

/**
 * \brief get table fmac_sbus_chain entry 
 * The order of FMACs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] fmac_id - FMAC ID
 * 
 * \return
 *     fmac_sbus_chain - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_fmac_sbus_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_fmac_sbus_chain_t * dnxf_data_device_blocks_fmac_sbus_chain_get(
    int unit,
    int fmac_id);

/**
 * \brief get table fmac_lane_to_block_map entry 
 * Maps FMAC lane to other block instances. Some devices intruduce a complex mapping of FMAC lane to core links.
 * 
 * \param [in] unit - unit #
 * \param [in] fmac_lane - Table entry index
 * 
 * \return
 *     fmac_lane_to_block_map - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_fmac_lane_to_block_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_fmac_lane_to_block_map_t * dnxf_data_device_blocks_fmac_lane_to_block_map_get(
    int unit,
    int fmac_lane);

/**
 * \brief get table dch_instances_to_device_stage entry 
 * Describres which DCH blocks are facing FAP and which face FE2. information is relevant only for FE13 mode. From this RX infotmation we can deduce what are the values for DCML blocks - they are the oposite.
 * 
 * \param [in] unit - unit #
 * \param [in] device_stage - Device mode of type soc_dnxf_block_mapping_stage_type_t, 0 - FE1, 1 - FE3
 * 
 * \return
 *     dch_instances_to_device_stage - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_dch_instances_to_device_stage_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_dch_instances_to_device_stage_t * dnxf_data_device_blocks_dch_instances_to_device_stage_get(
    int unit,
    int device_stage);

/**
 * \brief get table power_down_per_rtp entry 
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 * 
 * \param [in] unit - unit #
 * \param [in] index - Running index
 * 
 * \return
 *     power_down_per_rtp - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_power_down_per_rtp_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_power_down_per_rtp_t * dnxf_data_device_blocks_power_down_per_rtp_get(
    int unit,
    int index);

/**
 * \brief get table power_down_per_dch entry 
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 * 
 * \param [in] unit - unit #
 * \param [in] index - Running index
 * 
 * \return
 *     power_down_per_dch - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_power_down_per_dch_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_power_down_per_dch_t * dnxf_data_device_blocks_power_down_per_dch_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'override'
 * blocks enable/disable override
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_override_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'fsrd_sbus_chain'
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_fsrd_sbus_chain_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'fmac_sbus_chain'
 * The order of FMACs in the SBUS chain
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_fmac_sbus_chain_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'fmac_lane_to_block_map'
 * Maps FMAC lane to other block instances. Some devices intruduce a complex mapping of FMAC lane to core links.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_fmac_lane_to_block_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'dch_instances_to_device_stage'
 * Describres which DCH blocks are facing FAP and which face FE2. information is relevant only for FE13 mode. From this RX infotmation we can deduce what are the values for DCML blocks - they are the oposite.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_dch_instances_to_device_stage_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'power_down_per_rtp'
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_power_down_per_rtp_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'power_down_per_dch'
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_power_down_per_dch_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)override info
 * blocks enable/disable override
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     override - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_override_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fsrd_sbus_chain info
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fsrd_sbus_chain - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_fsrd_sbus_chain_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fmac_sbus_chain info
 * The order of FMACs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_sbus_chain - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_fmac_sbus_chain_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fmac_lane_to_block_map info
 * Maps FMAC lane to other block instances. Some devices intruduce a complex mapping of FMAC lane to core links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_lane_to_block_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_fmac_lane_to_block_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)dch_instances_to_device_stage info
 * Describres which DCH blocks are facing FAP and which face FE2. information is relevant only for FE13 mode. From this RX infotmation we can deduce what are the values for DCML blocks - they are the oposite.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dch_instances_to_device_stage - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_dch_instances_to_device_stage_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)power_down_per_rtp info
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_per_rtp - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_power_down_per_rtp_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)power_down_per_dch info
 * Table with registry and fields needed to power down unused per VD blocks. Each block corresponds to a DCH
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_per_dch - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_power_down_per_dch_info_get(
    int unit);

/*
 * SUBMODULE INTERRUPTS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_interrupts_feature_get(
    int unit,
    dnxf_data_device_interrupts_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_interrupts_define_nof_interrupts,

    /**
     * Must be last one!
     */
    _dnxf_data_device_interrupts_define_nof
} dnxf_data_device_interrupts_define_e;

/* Get Data */
/**
 * \brief returns numeric data of nof_interrupts
 * Module - 'device', Submodule - 'interrupts', data - 'nof_interrupts'
 * Number of interrupts.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_interrupts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_interrupts_nof_interrupts_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_interrupts_table_nof
} dnxf_data_device_interrupts_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE CUSTOM_FEATURES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_custom_features_feature_get(
    int unit,
    dnxf_data_device_custom_features_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_custom_features_define_mesh_topology_size,
    dnxf_data_device_custom_features_define_mesh_topology_fast,
    dnxf_data_device_custom_features_define_active_core,

    /**
     * Must be last one!
     */
    _dnxf_data_device_custom_features_define_nof
} dnxf_data_device_custom_features_define_e;

/* Get Data */
/**
 * \brief returns numeric data of mesh_topology_size
 * Module - 'device', Submodule - 'custom_features', data - 'mesh_topology_size'
 * To determine if there is a multiple pipe device in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_topology_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_custom_features_mesh_topology_size_get(
    int unit);

/**
 * \brief returns numeric data of mesh_topology_fast
 * Module - 'device', Submodule - 'custom_features', data - 'mesh_topology_fast'
 * Device is in mesh topology fast mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_topology_fast - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_custom_features_mesh_topology_fast_get(
    int unit);

/**
 * \brief returns numeric data of active_core
 * Module - 'device', Submodule - 'custom_features', data - 'active_core'
 * The index of the active core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     active_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_custom_features_active_core_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_custom_features_table_nof
} dnxf_data_device_custom_features_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE PROPERTIES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_properties_feature_get(
    int unit,
    dnxf_data_device_properties_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_properties_define_nof
} dnxf_data_device_properties_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_device_properties_table_unsupported,

    /**
     * Must be last one!
     */
    _dnxf_data_device_properties_table_nof
} dnxf_data_device_properties_table_e;

/* Get Data */
/**
 * \brief get table unsupported entry 
 * unsupported soc properties
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     unsupported - returns the relevant entry values grouped in struct - see dnxf_data_device_properties_unsupported_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_properties_unsupported_t * dnxf_data_device_properties_unsupported_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'properties', table - 'unsupported'
 * unsupported soc properties
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_properties_unsupported_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)unsupported info
 * unsupported soc properties
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     unsupported - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_properties_unsupported_info_get(
    int unit);

/*
 * SUBMODULE EMULATION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_emulation_feature_get(
    int unit,
    dnxf_data_device_emulation_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_emulation_define_emulation_system,

    /**
     * Must be last one!
     */
    _dnxf_data_device_emulation_define_nof
} dnxf_data_device_emulation_define_e;

/* Get Data */
/**
 * \brief returns numeric data of emulation_system
 * Module - 'device', Submodule - 'emulation', data - 'emulation_system'
 * Checking if the device is ran on emulation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     emulation_system - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_emulation_emulation_system_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_emulation_table_nof
} dnxf_data_device_emulation_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNXF_DATA_INTERNAL_DEVICE_H_*/
/* *INDENT-ON* */
