diff -rpN -u6 sdk-all-6.5.20/src/soc/dpp/ARAD/arad_drv.c sdk-all-6.5.20_mod/src/soc/dpp/ARAD/arad_drv.c
--- sdk-all-6.5.20/src/soc/dpp/ARAD/arad_drv.c	2020-07-15 12:38:48.000000000 +0100
+++ sdk-all-6.5.20_mod/src/soc/dpp/ARAD/arad_drv.c	2020-09-11 18:01:43.156678144 +0100
@@ -6369,14 +6369,42 @@ soc_arad_info_config(int unit)
             rv = soc_dpp_drc_combo28_info_config_default(unit, &(dpp_arad->init.drc_info));
             SOCDNX_IF_ERR_EXIT(rv);
 
             /* Adjust Dram Bitmap */
             if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
                 dram_bitmap = soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "dram_bitamp", 0x0);
+                printf("%s(%d) dram_bitmap=0x%x\r\n", __FUNCTION__, __LINE__, dram_bitmap);
                 if (dram_bitmap != 0) {
                     SHR_BITCOPY_RANGE(dpp_arad->init.drc_info.dram_bitmap, 0, &dram_bitmap, 0, SOC_DPP_DEFS_GET(unit, hw_dram_interfaces_max));
+
+                    /* Ref CLK: A is the master of B, C is the master of D, F is the master of E, H is the master of G. */
+                    SHR_BITSET(dpp_arad->init.drc_info.ref_clk_bitmap, 0);
+                    SHR_BITSET(dpp_arad->init.drc_info.ref_clk_bitmap, 2);
+                    SHR_BITSET(dpp_arad->init.drc_info.ref_clk_bitmap, 5);
+                    SHR_BITSET(dpp_arad->init.drc_info.ref_clk_bitmap, 7);
+
+                    /* 
+                     * Jericho ZQ calibration mapping:
+                     * A slave of C
+                     * B slave of C
+                     * C is Master
+                     * D slave of C
+                     * E slave of F
+                     * F is Master
+                     * G slave of F
+                     * H slave of F
+                     */
+                    dpp_arad->init.drc_info.zq_calib_map[0] = 2;
+                    dpp_arad->init.drc_info.zq_calib_map[1] = 2;
+                    dpp_arad->init.drc_info.zq_calib_map[2] = 2;
+                    dpp_arad->init.drc_info.zq_calib_map[3] = 2;
+                    dpp_arad->init.drc_info.zq_calib_map[4] = 5;
+                    dpp_arad->init.drc_info.zq_calib_map[5] = 5;
+                    dpp_arad->init.drc_info.zq_calib_map[6] = 5;
+                    dpp_arad->init.drc_info.zq_calib_map[7] = 5;
+
                 } else {
 
                     /* Allowed values for Jericho/88675:
                      *  0
                      *  2  (Dram's A, C)
                      *  3  (Dram's A, B, C)
@@ -6394,12 +6422,13 @@ soc_arad_info_config(int unit)
                         break;
                     case 3:
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 0);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 1);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 2);
                         break;
+                    case 4:
                     case 41:
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 0);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 1);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 2);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 3);
                         break;
diff -rpN -u6 sdk-all-6.5.20/src/soc/dpp/DRC/drc_combo28_init.c sdk-all-6.5.20_mod/src/soc/dpp/DRC/drc_combo28_init.c
--- sdk-all-6.5.20/src/soc/dpp/DRC/drc_combo28_init.c	2020-07-15 12:38:50.000000000 +0100
+++ sdk-all-6.5.20_mod/src/soc/dpp/DRC/drc_combo28_init.c	2020-09-11 18:01:43.161678093 +0100
@@ -1971,28 +1971,28 @@ int soc_dpp_drc_combo28_init_check_bist_
     SOCDNX_NULL_CHECK(combo28_bist_err_cnt);
 
     is_gddr5 = (drc_info->dram_type == SHMOO_COMBO28_DRAM_TYPE_GDDR5);
     is_crc   = ((drc_info->write_crc == 1) && (drc_info->read_crc == 1));
 
     /* Print Result */
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "\nDRAM index: %u \nResults:\n"), dram_ndx));
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "\nDRAM index: %u \nResults:\n"), dram_ndx));
     /* Mapping of bits with errors : 0x%x (bit N stands for an error in bits N, N+32, ... N+224) */
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_err_occur));
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_err_occur));
     /* Number of errors occoured in bits that are not masked by bist full mask: %d */
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of errors occoured (bist full mask): %d\n"), combo28_bist_err_cnt->bist_full_err_cnt)); 
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of errors occoured (bist full mask): %d\n"), combo28_bist_err_cnt->bist_full_err_cnt)); 
     /* Number of errors occoured in bits that are not masked by bist single bit mask: %d */
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of errors occoured (bist single mask): %d\n"), combo28_bist_err_cnt->bist_single_err_cnt)); 
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of global errors: %d\n"), combo28_bist_err_cnt->bist_global_err_cnt));
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of DBI errors: %d\n"), combo28_bist_err_cnt->bist_dbi_global_err_cnt));
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of errors occoured (bist single mask): %d\n"), combo28_bist_err_cnt->bist_single_err_cnt)); 
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of global errors: %d\n"), combo28_bist_err_cnt->bist_global_err_cnt));
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of DBI errors: %d\n"), combo28_bist_err_cnt->bist_dbi_global_err_cnt));
     /* Mapping of DBI bits with errors : 0x%x (bit N stands for an error in bits N, N+8, ... N+24) */
     LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of DBI bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_dbi_err_occur));
     if ((is_gddr5 == 1) && (is_crc == 1))
     {
-        LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of EDC errors: %d\n"), combo28_bist_err_cnt->bist_edc_global_err_cnt));
+        LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of EDC errors: %d\n"), combo28_bist_err_cnt->bist_edc_global_err_cnt));
         /* Mapping of EDC bits with errors : 0x%x (bit N stands for an error in bits N, N+8, ... N+24) */
-        LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of EDC bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_edc_err_occur));
+        LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of EDC bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_edc_err_occur));
     }
 
     /* Check BIST resault */
     if ((combo28_bist_err_cnt->bist_err_occur != 0x0)          || (combo28_bist_err_cnt->bist_full_err_cnt != 0x0)   || 
         (combo28_bist_err_cnt->bist_single_err_cnt != 0x0)     || (combo28_bist_err_cnt->bist_global_err_cnt != 0x0) ||
         (combo28_bist_err_cnt->bist_dbi_global_err_cnt != 0x0) || (combo28_bist_err_cnt->bist_dbi_err_occur != 0x0)  || 
diff -rpN -u6 sdk-all-6.5.20/systems/bde/linux/kernel/linux_dma.c sdk-all-6.5.20_mod/systems/bde/linux/kernel/linux_dma.c
--- sdk-all-6.5.20/systems/bde/linux/kernel/linux_dma.c	2020-07-15 12:39:30.000000000 +0100
+++ sdk-all-6.5.20_mod/systems/bde/linux/kernel/linux_dma.c	2020-09-11 18:01:47.773631085 +0100
@@ -177,13 +177,13 @@ MODULE_PARM_DESC(himemaddr,
 #define ONE_GB (1024*1024*1024)
 
 /* Default DMA memory size */
 #ifdef SAL_BDE_DMA_MEM_DEFAULT
 #define DMA_MEM_DEFAULT (SAL_BDE_DMA_MEM_DEFAULT * ONE_MB)
 #else
-#define DMA_MEM_DEFAULT (8 * ONE_MB)
+#define DMA_MEM_DEFAULT (16 * ONE_MB)
 #endif
 
 #ifdef BDE_EDK_SUPPORT
 typedef struct {
     phys_addr_t  cpu_pbase; /* CPU physical base address of the DMA pool */
     phys_addr_t  dma_pbase; /* Bus base address of the DMA pool */
@@ -692,6 +692,9 @@
 #ifdef REMAP_DMA_NONCACHED
     _dma_vbase = ioremap(dma_pbase, size);
 #endif
+    if (dma_debug >= 1)
+      gprintk("%s (himem=1 ?): _dma_vbase:%p pbase:%lx  allocated:%lx\n",
+              __FUNCTION__, _dma_vbase, pbase, (unsigned long)size);
     _edk_dma_pool[dev_id].cpu_pbase = cpu_pbase;
     _edk_dma_pool[dev_id].dma_pbase = dma_pbase;
     _edk_dma_pool[dev_id].dma_vbase = dma_vbase;
@@ -953,10 +953,12 @@ _dma_per_device_init(size_t size)
 #if _SIMPLE_MEMORY_ALLOCATION_
     if (_dma_pool_alloc_state == DMA_POOL_INITIALIZED && dmaalloc == ALLOC_TYPE_API) {
         /* allocate the DMA buffer pool and map it to the device, uses CMA */
+        dma_addr = 0;
         _dma_vbase = dma_alloc_coherent(dev, _dma_mem_size, &dma_addr, GFP_KERNEL);
-        if (!_dma_vbase) {
+        if (!_dma_vbase || !dma_addr) {
             _dma_pool_alloc_state = DMA_POOL_FAILED;
-            gprintk("Failed to allocate coherent memory pool of size 0x%x\n", _dma_mem_size);
+            gprintk("%s: failed to allocate coherent memory pool of size 0x%x (_dma_vbase=0x%08lx dma_addr=0x%08llx)\n",
+                    __FUNCTION__, _dma_mem_size, (unsigned long) _dma_vbase, (unsigned long long) dma_addr);
             return;
         }
         _dma_alloc_coherent_device = dev;
@@ -964,6 +966,7 @@
         /* Set the host physical address of the DMA buffer pool */
         _cpu_pbase = HOST_PHYS_ADDR(dev, dma_addr, _dma_vbase);

+        gprintk("%s: _SIMPLE_MEMORY_ALLOCATION_ successfull\n", __FUNCTION__);
     } else
 #endif /* _SIMPLE_MEMORY_ALLOCATION_ */

diff -rpN -u6 sdk-all-6.5.20/systems/bde/linux/kernel/linux-kernel-bde.c sdk-all-6.5.20_mod/systems/bde/linux/kernel/linux-kernel-bde.c
--- sdk-all-6.5.20/systems/bde/linux/kernel/linux-kernel-bde.c	2020-07-15 12:39:30.000000000 +0100
+++ sdk-all-6.5.20_mod/systems/bde/linux/kernel/linux-kernel-bde.c	2020-09-11 18:01:47.773631085 +0100
@@ -64,23 +64,32 @@
 #endif
 #define msi_control_reg(base)         (base + PCI_MSI_FLAGS)
 #endif
 #endif
 MODULE_AUTHOR("Broadcom Corporation");
 MODULE_DESCRIPTION("Kernel BDE");
+#ifdef __arm__
+MODULE_LICENSE("Proprietary");
+#else
 MODULE_LICENSE("GPL");
+#endif
 
 /*
  * PCIe max payload size in bytes.
  * The default value if not specified to the kernel module by maxpayload is historically 256.
  * The default value may be changed using the BDE_PCIE_MAXPAYLOAD_DEFAULT macro.
  */
 #ifndef BDE_PCIE_MAXPAYLOAD_DEFAULT
 #define BDE_PCIE_MAXPAYLOAD_DEFAULT 256
 #endif
-int maxpayload = BDE_PCIE_MAXPAYLOAD_DEFAULT;
+//int maxpayload = BDE_PCIE_MAXPAYLOAD_DEFAULT;     //PTin modified
+#if defined (__arm__)     /* PTin added: PCI */
+int maxpayload = 256;
+#else
+int maxpayload = 128;     /* PTin modified: Max payload limited to 128B */
+#endif
 LKM_MOD_PARAM(maxpayload, "i", int, 0);
 MODULE_PARM_DESC(maxpayload,
 "Limit maximum payload size and request size on PCIe devices");
 
 /* Use MSI or MSIX interrupts */
 int usemsi = -1;
@@ -387,18 +396,21 @@ static void *cpu_address = NULL;
 #define PCI_DEVID_PI7C9X130   0xE130
 #define DEV_CTRL_REG           0xb8
 
 #define MAX_PAYLOAD_256B       (1 << 5)
 #define MAX_PAYLOAD_512B       (2 << 5)
 #define MAX_READ_REQ_256B      (1 << 12)
-
+#define MAX_READ_REQ_512B      (2 << 12)          /* PTin added: PCI */
 
 /* Freescale 8548 PCI-E  host Bridge */
 #define FSL_VENDOR_ID                   0x1957
 #define FSL8548PCIE_DEVICE_ID           0x0013
 #define FSL2020EPCIE_DEVICE_ID          0x0070
+#define FSL8544PCIE_DEVICE_ID           0x0033    /* PTin added: PCI PQ3 8544 */
+#define FSL2040EPCIE_DEVICE_ID          0x0411    /* PTin added: PCI P2040 */
+#define FSL2040SECEPCIE_DEVICE_ID       0x0410    /* PTin added: PCI P2040 */
 #define FSL8548PCIE_DEV_CTRL_REG        0x54
 
 /* 4716 PCI-E  host Bridge */
 #define BCM4716_VENDOR_ID               0x14e4
 #define BCM4716PCIE_DEVICE_ID           0x4716
 #define BCM4716PCIE_DEV_CAP_REG         0xd4
@@ -441,12 +453,23 @@ static void *cpu_address = NULL;
 #define BCM58522_PCI_DEVICE_ID     0x8022
 
 /* Broadcom BCM58712 */
 #define BCM58712_PCI_VENDOR_ID     0x14E4
 #define BCM58712_PCI_DEVICE_ID     0x168E
 
+/* PTin added: PCI high speed switches */
+#if 1
+/* Broadcom BCM56640 */
+#define BCM56640_PCI_VENDOR_ID     0x14E4
+#define BCM56640_PCI_DEVICE_ID     0xb640
+
+/* Broadcom BCM56846 */
+#define BCM56846_PCI_VENDOR_ID     0x14E4
+#define BCM56846_PCI_DEVICE_ID     0xb846
+#endif
+
 /* Default gicd address if not available in DTB */
 #define IHOST_GICD_REG_ADDR        0x10781100
 #define IHOST_GICD_REG_REMAP_LEN   0x100
 
 #define IHOST_GICD_REG_ADDR_VALID(d, addr) \
     (_devices[d].bde_dev.base_address1 && \
@@ -599,12 +622,16 @@ _eb_device_create(resource_size_t paddr,
 
 static int
 sand_device_create(void)
 {
     bde_ctrl_t* ctrl;
 
+    /* Do not execute this function. Otherwise linux-kerbel-bde.ko insertion will fail! */
+    gprintk("%s not executed!\r\n", __FUNCTION__);
+    return 0;
+
     ctrl = _devices; 
 
 #ifndef __DUNE_LINUX_BCM_CPU_PCIE__
     ctrl->dev_type |= BDE_PCI_DEV_TYPE | BDE_SWITCH_DEV_TYPE;
     ctrl->pci_device = NULL; /* No PCI bus */
 
@@ -1838,22 +1865,38 @@ p2p_bridge(void)
          * Writes to the PCIE capability device control register
          */
         pci_write_config_dword(dev, DEV_CTRL_REG,
                                MAX_PAYLOAD_256B | MAX_READ_REQ_256B);
     }
 
-    if ((dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL8548PCIE_DEVICE_ID, NULL)) != NULL ||
+    if ((dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL8544PCIE_DEVICE_ID, NULL)) != NULL ||     /* PTin added: PCI PQ3-8544*/
+        (dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL8548PCIE_DEVICE_ID, NULL)) != NULL ||
         (dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL2020EPCIE_DEVICE_ID, NULL)) != NULL) {
         /*
          * Configure the PCIE cap: Max payload size: 256, Max Read
          * Request size: 256, disabling relax ordering.
          * Writes to the PCIE capability device control register
          */
         pci_write_config_dword(dev, FSL8548PCIE_DEV_CTRL_REG,
                                MAX_PAYLOAD_256B | MAX_READ_REQ_256B);
     }
+    /* PTin added: PCI P2040 */
+    #if 0
+    else if ((dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL2040EPCIE_DEVICE_ID, NULL)) != NULL ||
+             (dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL2040SECEPCIE_DEVICE_ID, NULL)) != NULL)
+    {
+        /*
+         * Configure the PCIE cap: Max payload size: 512, Max Read
+         * Request size: 512, disabling relax ordering.
+         * Writes to the PCIE capability device control register
+         */
+        pci_write_config_dword(dev, FSL8548PCIE_DEV_CTRL_REG,
+                               MAX_PAYLOAD_512B | MAX_READ_REQ_512B);
+    }
+    #endif
+
     if ((dev = PCI_FIND_DEV(BCM4716_VENDOR_ID, BCM4716PCIE_DEVICE_ID, NULL)) != NULL ||
         (dev = PCI_FIND_DEV(BCM53000_VENDOR_ID, BCM53000PCIE_DEVICE_ID, NULL)) != NULL) {
         uint32 tmp, maxpayld, device_bmp=0, mask;
         unsigned long addr;
         uint16 tmp16, tmp161;
         int i, bus0 = -1, bus1 = -1, port;        
@@ -2421,12 +2464,17 @@ _pci_probe(struct pci_dev *dev, const st
 
         if (debug >= 4) {gprintk("Enabling PCI device : vendor_id=0x%x, device_id=0x%x\n", dev->vendor, dev->device);}
         if (pci_enable_device(dev)) {
             gprintk("Cannot enable PCI device : vendor_id = %x, device_id = %x\n",
                     dev->vendor, dev->device);
         }
+/* PTin added */
+        else {
+            gprintk("LTX: Enabled pci device : vendor_id = %x, device_id = %x\n",dev->vendor, dev->device);
+        }
+/* PTin end */
 
         
         /*
          * These are workarounds to get around some existing
          * kernel problems :(
          */
@@ -2435,15 +2483,17 @@ _pci_probe(struct pci_dev *dev, const st
          * While probing we determine the overall limits for the PCI
          * memory windows across all devices. These limits are used
          * later on by the PCI-PCI bridge  code.
          */
         if (pci_resource_start(dev, baroff) < _pci_mem_start) {
             _pci_mem_start = pci_resource_start(dev, baroff);
+            gprintk("LTX: Adjusted _pci_mem_start\n");
         }
         if (pci_resource_end(dev, baroff) > _pci_mem_end) {
             _pci_mem_end = pci_resource_end(dev, baroff);
+            gprintk("LTX: Adjusted _pci_mem_end\n");
         }
 
 #ifdef CONFIG_SANDPOINT
         /*
          * Something wrong with the PCI subsystem in the mousse kernel.
          * The device is programmed correctly, but the irq in the pci
@@ -2535,12 +2585,29 @@ _pci_probe(struct pci_dev *dev, const st
             /* BCM58525/BCM58712 CPU boards support 128 Max payload size */
             if (maxpayload && maxpayload != 128) {
                 maxpayload = 128;
                 if (debug >= 1) gprintk("force max payload size to 128\n");
             }
         }
+        /* PTin added: PCI */
+        #if 1
+        else if ((PCI_FIND_DEV(BCM56846_PCI_VENDOR_ID, BCM56846_PCI_DEVICE_ID, NULL)) != NULL) {
+            /* BCM58525 CPU boards support 128 Max payload size */
+            if (maxpayload) {
+                maxpayload = 256;
+                if (debug >= 1) gprintk("force max payload size to 256\n");
+            }
+        }
+        else if ((PCI_FIND_DEV(BCM56640_PCI_VENDOR_ID, BCM56640_PCI_DEVICE_ID, NULL)) != NULL) {
+            /* BCM58525 CPU boards support 128 Max payload size */
+            if (maxpayload) {
+                maxpayload = 512;
+                if (debug >= 1) gprintk("force max payload size to 512\n");
+            }
+        }
+        #endif
 
         if (forceirq > 0 && dev->irq != (uint32) forceirq) {
             if (forceirqubm & (1U << (_ndevices - 1))) {
                 dev->irq = forceirq;
                 if (debug >= 1) gprintk("force irq to %d\n", forceirq);
             }
@@ -2549,12 +2616,13 @@ _pci_probe(struct pci_dev *dev, const st
         ctrl->iLine = dev->irq;
         if (unlikely(debug > 1))
             gprintk("%s:irq = %d\n",__func__, ctrl->iLine);
 
         if (shbde_pci_is_pcie(shbde, dev)) {
             /* Set PCIe max payload */
+            gprintk("%s: Setting maxpayload %d\n",__func__, maxpayload);
             shbde_pci_max_payload_set(shbde, dev, maxpayload);
         } else {
             /* Set PCI retry to infinite on non-PCIe switch device */
             pci_write_config_word(dev, 0x40, 0x0080);
             if (debug >= 1) gprintk("set DMA retry to infinite on switch device\n");
         }
@@ -2589,12 +2657,48 @@ _pci_probe(struct pci_dev *dev, const st
         break;
     default:
         break;
     }
 #endif /* BCM_DFE_SUPPORT */
 
+#ifndef __arm__
+    if (debug >= 1) {
+        uint8 aux8;
+        uint32 aux32;
+
+        gprintk("***********PCI Conf registers: api 5.9.2**********\n");
+        pci_read_config_dword(dev, 0x0, &aux32);
+        gprintk("* Vendor ID | Device ID :  0x%08X *\n", aux32);
+        pci_read_config_dword(dev, 0x4, &aux32);
+        gprintk("* Class Code| rev ID    :  0x%08X *\n", aux32);
+        pci_read_config_byte(dev, 0xC, &aux8);
+        gprintk("* Cache line syze       :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0xD, &aux8);
+        gprintk("* Latency Timer         :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0xE, &aux8);
+        gprintk("* Header Type           :  0x%02X       *\n", aux8);
+        pci_read_config_dword(dev, 0x10, &aux32);
+        gprintk("* BASE ADDRESS LOW      :  0x%08X *\n", aux32);
+        pci_read_config_dword(dev, 0x14, &aux32);
+        gprintk("* BASE ADDRESS HIGH     :  0x%08X *\n", aux32);
+        pci_read_config_byte(dev, 0x3C, &aux8);
+        gprintk("* Interrupt Line        :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x3D, &aux8);
+        gprintk("* Interrupt Pin         :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x3E, &aux8);
+        gprintk("* Minimum Grant         :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x3F, &aux8);
+        gprintk("* Maximum Latency       :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x40, &aux8);
+        gprintk("* Retry Count           :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x41, &aux8);
+        gprintk("* TRDY Timeout          :  0x%02X       *\n", aux8);
+        gprintk("****************************\n");
+    }
+#endif
+
     /* Prevent compiler warning */
     if (ctrl == NULL) {
         return 0;
     }
 
     ctrl->be_pio = 0;
@@ -3546,12 +3650,14 @@ _interrupt_connect(int d,
     bde_ctrl_t *ctrl;
     unsigned long irq_flags;
     int isr2_dev;
     int isr_active;
     int ret = 0;
 
+    gprintk("Setting IRQ...\n");
+
     isr2_dev = d & LKBDE_ISR2_DEV;
     d &= ~LKBDE_ISR2_DEV;
 
     if (!VALID_DEVICE(d)) {
         gprintk("_interrupt_connect: Invalid device index %d\n", d);
         return -1;
@@ -3591,14 +3697,22 @@ _interrupt_connect(int d,
         }
     }

+    gprintk("irq to be used: %d\n",ctrl->iLine);
+
     if (ctrl->iLine != -1) {
         irq_flags = IRQF_SHARED;
 #ifdef CONFIG_PCI_MSI
+        gprintk ("LTX: Trying to enable MSI\n");
         if (ctrl->use_msi >= PCI_USE_INT_MSI) {
             ret = _msi_connect(ctrl);
             if(ret != 0)
                 goto msi_exit;
+            gprintk ("LTX: Success enabling MSI\n");
         }
+        else
+        {
+            gprintk ("LTX: MSI not enabled\n");
+        }
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,84))
         if (ctrl->use_msi == PCI_USE_INT_MSIX) {
             int i;
@@ -3662,12 +3776,13 @@ _interrupt_connect(int d,
 
                 if (unlikely(debug >= 1))
                     gprintk("%s(%d):device# = %d, irq_flags = %lu, irq = %d\n",
                          __func__, __LINE__, d,
                          irq_flags, ctrl->pci_device ? ctrl->pci_device->irq : ctrl->iLine);
             }
+            gprintk("Success requesting irq %d\n", ctrl->iLine);
         }
     }
     return 0;
 
 err_disable_msi:
 #ifdef CONFIG_PCI_MSI
diff -rpN -u6 sdk-all-6.5.20/systems/bde/linux/user/linux-user-bde.c sdk-all-6.5.20_mod/systems/bde/linux/user/linux-user-bde.c
--- sdk-all-6.5.20/systems/bde/linux/user/linux-user-bde.c	2020-07-15 12:39:30.000000000 +0100
+++ sdk-all-6.5.20_mod/systems/bde/linux/user/linux-user-bde.c	2020-09-11 18:01:47.772631095 +0100
@@ -279,12 +279,13 @@ typedef uint64 phys_addr_t;
 
 #else /* SAL_BDE_32BIT_USER_64BIT_KERNEL */
 
 #ifdef PHYS_ADDRS_ARE_64BITS
 #include <sys/mman.h>
 #ifdef SAL_BDE_USE_MMAP64
+extern void * mmap64 (void *addr, size_t len, int prot, int flags, int fd, unsigned long long offset);
 #define MMAP    mmap64
 #else
 #define MMAP    mmap
 #endif
 typedef uint64 phys_addr_t;
 #else 
