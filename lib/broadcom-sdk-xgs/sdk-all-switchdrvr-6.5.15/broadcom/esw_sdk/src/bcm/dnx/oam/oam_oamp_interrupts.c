/** \file oam_oamp_interrupts.c
 * $Id$
 *
 * OAMP Interrupt handling procedures for DNX.
 *
 */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */

#ifdef BSL_LOG_MODULE
#  error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_OAM

 /*
  * Include files.
  * {
  */
#include <src/bcm/dnx/oam/oam_oamp.h>
#include <src/bcm/dnx/oam/oam_internal.h>
#include <src/bcm/dnx/bfd/bfd_internal.h>
#include "include/bcm/bfd.h"
#include <soc/dnx/dbal/dbal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_oam.h>
#include <bcm_int/dnx/algo/oam/algo_oam.h>
#include <shared/hash_tbl.h>

/*
 * }
 */

/*
 * DEFINEs
 * {
 */

/* Maximum number of events that can stored in SW */
#define DNX_OAM_OAMP_FIFO_MAX_NUMBER_OF_EVENTS_IN_SW 1024

/*
 * Max number of JR2 format events is 13 since 640 bits/48 bits = 13.
 */
#define DNX_OAM_OAMP_MAX_JR2_FORMAT_EVENTS 13

/** JR2 EVENT FORMAT */
typedef struct dnx_oam_oamp_interrupt_jr2_event_data_s
{
    /** Pointer to the OAMP_RMEP_DB for the RMEP for which event was raised */
    uint16 rmep_db_ptr;
    /** 00 - No LOC event 01 - LOC event 10 - Almost LOC event 11 - LOC Clear event */
    dbal_enum_value_field_loc_event_e loc_evt;
    /** Indicates RDI set event */
    uint8 rdi_set;
    /** Indicates RDI clear event */
    uint8 rdi_clear;
    /** Indicates there is a change in RMEP state */
    uint8 rmep_state_change;
    /** Indicates if the event is valid or not */
    uint8 is_valid;
    /** If RMEP_STATE_CHANGE is true, this gives the changed RMEP STATE for OAM/BFD */
    union
    {
        dnx_oam_oamp_oam_state_t eth_state;

        dnx_oam_oamp_bfd_state_t bfd_state;
    } rmep_state;
    /** Indicates if the event is oam or not */
    uint8 is_oam;
} dnx_oam_oamp_interrupt_jr2_event_data_t;

/** The interrupt event data. Format and the data array */
typedef struct dnx_oam_interrupt_event_data_s
{
    /*
     * The actual event data (in JR2 event format). Valid if
     * event format is 1. 48 bits size.
     */
    dnx_oam_oamp_interrupt_jr2_event_data_t jr2_event_data[DNX_OAM_OAMP_MAX_JR2_FORMAT_EVENTS];
} dnx_oam_interrupt_event_data_t;

/*Struct preserving all "global" data associated with an interrupt.*/
typedef struct
{
    /*
     * Field represents the freshest copy of the interrupt message. Only this should be processed directly.
     */
    dnx_oam_interrupt_event_data_t interrupt_message;

   /** Used only when using DMA interrupts */
    /*
     * Upon entering an interrupt a "chunk of memory should be copy from the "host memeory" (shared by the DMA) to this 
     * memory 
     */
    uint32 *buffer_copied_from_dma_host_memory;
    uint8 internal_buffer_is_allocated;
    /*
     * Represents amount of valid entries in buffer_copied_from_dma_host_memory 
     */
    int num_entries_available_in_local_buffer;
    /*
     * Pointer to current location in buffer_copied_from_dma_host_memory
     */
    int num_entries_read_in_local_buffer;
} dnx_oam_oamp_interrupt_global_data_t;
/* OAM event types generated by OAMP */
typedef enum
{
    DNX_OAM_OAMP_DMA_EVENT_TYPE_EVENT,
    DNX_OAM_OAMP_DMA_EVENT_TYPE_STAT_EVENT,
    DNX_OAM_OAMP_DMA_EVENT_TYPE_NOF
} dnx_oam_oamp_dma_event_type_t;

/*Used to store data on all events. from the FIFO.*/
typedef struct
{
    uint16 mep_or_rmep_indx;    /* index in the (R)MEP DB (not the actual (R)MEP ID) */
    uint8 is_oam;
    uint8 event_number;         /* number from the bcm_bfd/oam_event_type_t enum */
} dnx_oam_event_and_rmep_info;

/*
The following structs are used for event fifo implementation. 
The implementation is as such: 
    The hash table is used to store the multi-event indication and potentially reference counter
    The following linked list is then itereated on in the end.
When an event is encounter, look for it in the hash table. 
    if it exists, update the reference counter in the hash table and set the multi event indication
    else insert it into the linked list and the hash table.
 
In the end the events are popped one by one (fifo) from the list and the reference counter and multi-event indication is gotten from the hash table
*/
typedef struct dnx_oam_oamp_eventt_Node_s
{
    dnx_oam_event_and_rmep_info eventt;
    struct dnx_oam_oamp_eventt_Node_s *next;
} dnx_oam_oamp_eventt_Node_t;

typedef struct
{
    dnx_oam_oamp_eventt_Node_t *head;
    dnx_oam_oamp_eventt_Node_t *tail;
} dnx_oam_oamp_eventt_list_t;

/*
 * }
 */

/*
 * MACROs
 * {
 */

/** Macro to indicate maximum state change events possible in RMEP state */
#define DNX_OAM_OAMP_MAX_STATE_CHANGE_EVENTS_POSSIBLE 2

/** Macros to differentiate BFD and OAM RMEPs based on RMEP name */
#define DNX_BFD_RMEP_SW_INFO_NAME_IS_BFD(rmep_name) (rmep_name == DNX_BFD_RMEP_SW_INFO_NAME_CONST)
#define DNX_BFD_RMEP_SW_INFO_NAME_IS_OAM(rmep_name) (!(DNX_BFD_RMEP_SW_INFO_NAME_IS_BFD(rmep_name)))

/** Macros to parse the RMEP state of OAM/BFD RMEPs from the oamp_event.rmep_state */
#define DNX_OAM_BFD_RMEP_STATE_DIAG_PROF_GET(rmep_state) (rmep_state & 0xf)
#define DNX_OAM_BFD_RMEP_STATE_STATE_GET(rmep_state) ((rmep_state >> 4) & 0x3)
#define DNX_OAM_BFD_RMEP_STATE_FLAGS_PROF_GET(rmep_state) ((rmep_state >> 6) & 0xf)
#define DNX_OAM_BFD_RMEP_STATE_DETECT_MULT_GET(rmep_state) ((rmep_state >> 10) & 0xff)

#define DNX_OAM_BFD_RMEP_STATE_INTF_STATUS_GET(rmep_state) (rmep_state & 0x7)
#define DNX_OAM_BFD_RMEP_STATE_PORT_STATUS_GET(rmep_state) ((rmep_state >> 3) & 0x3)

#define DNX_OAM_OAMP_EVENT_PORT_BLOCKED(_port_status_) \
  ((_port_status_) == 1)

#define DNX_OAM_OAMP_EVENT_PORT_UP(_port_status_) \
  ((_port_status_) == 2)

#define DNX_OAM_OAMP_EVENT_INTERFACE_UP(_intf_status_) \
  ((_intf_status_) == 1)

#define DNX_OAM_OAMP_EVENT_INTERFACE_DOWN(_intf_status_) \
  ((_intf_status_) == 2)

#define DNX_OAM_OAMP_EVENT_INTERFACE_TESTING(_intf_status_) \
  ((_intf_status_) == 3)

#define DNX_OAM_OAMP_EVENT_INTERFACE_UNKNOWN(_intf_status_) \
  ((_intf_status_) == 4)

#define DNX_OAM_OAMP_EVENT_INTERFACE_DORMANT(_intf_status_) \
  ((_intf_status_) == 5)

#define DNX_OAM_OAMP_EVENT_INTERFACE_NOT_PRESENT(_intf_status_) \
  ((_intf_status_) == 6)

#define DNX_OAM_OAMP_EVENT_INTERFACE_LL_DOWN(_intf_status_) \
  ((_intf_status_ & 7) == 7)

/*
 * }
 */

/*
 * Global and Static
 * {
 */

/*
 * }
 */

 /**
 * \brief -  Function that pushes an entry to the end 
 *           of the linked list (fifo). 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] event_list - linked list to be initialized. 
 *   
 * \return
 *   shr_error_e
 */
void
dnx_oam_oamp_eventt_list_init(
    int unit,
    dnx_oam_oamp_eventt_list_t * event_list)
{
    event_list->head = event_list->tail = NULL;
}

/**
 * \brief -  Function that pushes an entry to the end 
 *           of the linked list (fifo). 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] event_list - linked list where event is pushed. 
 * \param [out] eventt - entry to get pushed. 
 *   
 * \return
 *   shr_error_e
 */
static shr_error_e
dnx_oam_oamp_eventt_list_push(
    int unit,
    dnx_oam_oamp_eventt_list_t * event_list,
    const dnx_oam_event_and_rmep_info * eventt)
{
    dnx_oam_oamp_eventt_Node_t *new_node = sal_alloc(sizeof(dnx_oam_oamp_eventt_Node_t), "oam event fifo");
    if (new_node == NULL)
    {
        return _SHR_E_MEMORY;
    }
    new_node->next = NULL;
    new_node->eventt = *eventt;
    if (event_list->head != NULL)
    {
        event_list->tail->next = new_node;
        event_list->tail = new_node;
    }
    else
    {
        event_list->head = event_list->tail = new_node;
    }
    return _SHR_E_NONE;
}

/**
 * \brief -  Function that pops an event from the front of
 *           the linked list (fifo). 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] event_list - linked list where event to be popped. 
 * \param [out] eventt - event is set here. 
 *   
 * \return
 *   shr_error_e
 */
static shr_error_e
dnx_oam_oamp_eventt_list_pop(
    int unit,
    dnx_oam_oamp_eventt_list_t * event_list,
    dnx_oam_event_and_rmep_info * eventt)
{
    if (event_list->head)
    {
        dnx_oam_oamp_eventt_Node_t *temp_head = event_list->head;
        *eventt = event_list->head->eventt;
        if (event_list->head == event_list->tail)
        {
            event_list->head = event_list->tail = NULL;
        }
        else
        {
            event_list->head = event_list->head->next;
        }
        sal_free(temp_head);
        return _SHR_E_NONE;
    }
    else
    {
        return _SHR_E_EMPTY;
    }
}

/**
 * \brief - This function gets the OAMP interrupt data in jr2 event format.
 *
 * \param [in] unit - Number of hardware unit used.
 * \param [out] event - Event data information.
 * \param [in,out] valid_event_exist - pointer to event valid existance indication.
 *
 * \return
 *   shr_error_e
 *
 * \remark
 *   This function gets the interrupt data from OAMP_INTERRUPT_MESSAGE register.
 *
 * \see
 *   * None
 */
static shr_error_e
dnx_oam_oamp_interrupt_event_data_jr2_format_get(
    int unit,
    dnx_oam_interrupt_event_data_t * event,
    uint8 *valid_event_exist)
{
    uint32 entry_handle_id;
    int instance, rv;
    uint32 event_data[DBAL_FIELD_ARRAY_MAX_SIZE_IN_WORDS];
    uint32 rmep_db_ptr;
    uint32 loc_evt;
    uint32 rdi_set;
    uint32 rdi_clear;
    uint32 rmep_state_change;
    uint32 reserved_1;
    uint32 rmep_state;
    uint32 reserved_2;
    dnx_oam_remote_endpoint_info_t sw_rmep_info;

    SHR_FUNC_INIT_VARS(unit);
    DBAL_FUNC_INIT_VARS(unit);

    *valid_event_exist = 0;

    SHR_IF_ERR_EXIT(DBAL_HANDLE_ALLOC(unit, DBAL_TABLE_OAMP_INTERRUPT_DATA, &entry_handle_id));
    /** Read DBAL to get the interrupt message data from OAMP */
    SHR_IF_ERR_EXIT(dbal_entry_get(unit, entry_handle_id, DBAL_GET_ALL_FIELDS));

    for (instance = 0; instance < DNX_OAM_OAMP_MAX_JR2_FORMAT_EVENTS; instance++)
    {
        /** Update SW structure with OAMP event data */
        SHR_IF_ERR_EXIT(dbal_entry_handle_value_field_arr32_get
                        (unit, entry_handle_id, DBAL_FIELD_JR2_OAMP_EVENT, instance, event_data));
        SHR_IF_ERR_EXIT(dbal_fields_struct_field_decode
                        (unit, DBAL_FIELD_JR2_OAMP_EVENT_FORMAT, DBAL_FIELD_RESERVED_1, &(reserved_1), event_data));

        /** reserved_1 is indicator of logical not of valid bit*/
        if (reserved_1)
        {
            continue;
        }

        SHR_IF_ERR_EXIT(dbal_fields_struct_field_decode(unit, DBAL_FIELD_JR2_OAMP_EVENT_FORMAT,
                                                        DBAL_FIELD_RMEP_INDEX, &(rmep_db_ptr), event_data));
        SHR_IF_ERR_EXIT(dbal_fields_struct_field_decode(unit, DBAL_FIELD_JR2_OAMP_EVENT_FORMAT,
                                                        DBAL_FIELD_LOC_EVENT, &(loc_evt), event_data));
        SHR_IF_ERR_EXIT(dbal_fields_struct_field_decode(unit, DBAL_FIELD_JR2_OAMP_EVENT_FORMAT,
                                                        DBAL_FIELD_RDI_SET, &(rdi_set), event_data));
        SHR_IF_ERR_EXIT(dbal_fields_struct_field_decode(unit, DBAL_FIELD_JR2_OAMP_EVENT_FORMAT,
                                                        DBAL_FIELD_RDI_CLEAR, &(rdi_clear), event_data));
        SHR_IF_ERR_EXIT(dbal_fields_struct_field_decode(unit, DBAL_FIELD_JR2_OAMP_EVENT_FORMAT,
                                                        DBAL_FIELD_RMEP_STATE_CHANGE, &(rmep_state_change),
                                                        event_data));
        SHR_IF_ERR_EXIT(dbal_fields_struct_field_decode
                        (unit, DBAL_FIELD_JR2_OAMP_EVENT_FORMAT, DBAL_FIELD_RMEP_STATE, &(rmep_state), event_data));
        SHR_IF_ERR_EXIT(dbal_fields_struct_field_decode
                        (unit, DBAL_FIELD_JR2_OAMP_EVENT_FORMAT, DBAL_FIELD_RESERVED_2, &(reserved_2), event_data));

        /** Update RMEP Index in event data */
        event->jr2_event_data[instance].rmep_db_ptr = rmep_db_ptr;
        sal_memset(&sw_rmep_info, 0, sizeof(sw_rmep_info));
        rv = dnx_oam_sw_state_remote_endpoint_info_get(unit, rmep_db_ptr, &sw_rmep_info);
        if (rv != _SHR_E_NONE)
        {
            /** Don't process the event if SW does not have the EP context */
            /** Update the entry as invalid */
            event->jr2_event_data[instance].is_valid = 0;
            continue;
        }
        event->jr2_event_data[instance].loc_evt = loc_evt;
        event->jr2_event_data[instance].rdi_set = rdi_set;
        event->jr2_event_data[instance].rdi_clear = rdi_clear;
        event->jr2_event_data[instance].rmep_state_change = rmep_state_change;
        event->jr2_event_data[instance].is_valid = !reserved_1;
        /** Update valid entry existance to the caller */
        if (event->jr2_event_data[instance].is_valid)
        {
            *valid_event_exist = 1;
        }
        /** Using the RMEP name to identify if it is BFD or OAM RMEP */
        if (DNX_BFD_RMEP_SW_INFO_NAME_IS_BFD(sw_rmep_info.rmep_id))
        {   /** Update RMEP state */
            event->jr2_event_data[instance].rmep_state.bfd_state.flags_profile =
                DNX_OAM_BFD_RMEP_STATE_FLAGS_PROF_GET(rmep_state);
            event->jr2_event_data[instance].rmep_state.bfd_state.state = DNX_OAM_BFD_RMEP_STATE_STATE_GET(rmep_state);
            event->jr2_event_data[instance].rmep_state.bfd_state.diag_profile =
                DNX_OAM_BFD_RMEP_STATE_DIAG_PROF_GET(rmep_state);
            event->jr2_event_data[instance].rmep_state.bfd_state.detect_multiplier =
                DNX_OAM_BFD_RMEP_STATE_DETECT_MULT_GET(rmep_state);
            event->jr2_event_data[instance].is_oam = 0;
        }
        else
        {   /** Update RMEP state */
            event->jr2_event_data[instance].rmep_state.eth_state.interface_status =
                DNX_OAM_BFD_RMEP_STATE_INTF_STATUS_GET(rmep_state);
            event->jr2_event_data[instance].rmep_state.eth_state.port_status =
                DNX_OAM_BFD_RMEP_STATE_PORT_STATUS_GET(rmep_state);
            event->jr2_event_data[instance].is_oam = 1;
        }
    }

exit:
    DBAL_FUNC_FREE_VARS;
    SHR_FUNC_EXIT;
}

/**
 * \brief - This function reads data from HW intterupt message and update
 *  software events data structure. 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] event_type - type of event generated by OAMP.
 * \param [in,out] valid_event_exist - pointer to event valid existance indication.
 * \param [in] interrupt_data - "global" data used by soc layer.
 *                       The reason this is not used as a global
 *                       variable is so that the interrupts will
 *                       be reentrable. The data is only global
 *                       per interrupt.
 *   
 * \return
 *   shr_error_e
 */
static shr_error_e
dnx_oam_oamp_event_fifo_read(
    int unit,
    int event_type,
    uint8 *valid_event_exist,
    dnx_oam_oamp_interrupt_global_data_t * interrupt_data)
{
    uint8 oam_use_event_fifo_dma = 0;   /* Currently Hard coding to zero, when DMA is implemented, update accordingly */
    SHR_FUNC_INIT_VARS(unit);

    /*
     * Choose the handler function according whether DMA is used or not 
     */
    if (oam_use_event_fifo_dma)
    {   /* use DMA: Add code changes as part of DMA implementation JIRA */
    }
    else        /* without DMA */
    {
        /*
         * Use DBAL interface to read interrupt message data and update the interrupt_data structure
         */
        /** We currently only support JR2 format. */
        SHR_IF_ERR_EXIT(dnx_oam_oamp_interrupt_event_data_jr2_format_get
                        (unit, &interrupt_data->interrupt_message, valid_event_exist));
    }

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief - This function converts the OAMP event to BCM OAM event type. 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] event_data - OAMP event data to which bcm event type has to be derived.
 * \param [in] event_type - Array of bcm event type(s) corresponding to an OAMP event(s).
 *   
 * \return
 *   shr_error_e
 */
static shr_error_e
dnx_oam_oamp_event_to_bcm_oam_event_type(
    int unit,
    dnx_oam_oamp_interrupt_jr2_event_data_t * event_data,
    bcm_oam_event_type_t * event_type)
{
    SHR_FUNC_INIT_VARS(unit);

    if (event_data->rdi_set)
    {
        event_type[0] = bcmOAMEventEndpointRemote;
    }
    else if (event_data->rdi_clear)
    {
        event_type[0] = bcmOAMEventEndpointRemoteUp;
    }
    else if (event_data->loc_evt)
    {
        switch (event_data->loc_evt)
        {
            case DBAL_ENUM_FVAL_LOC_EVENT_LOC_EVENT:
                event_type[0] = bcmOAMEventEndpointCCMTimeout;
                break;
            case DBAL_ENUM_FVAL_LOC_EVENT_LOC_CLEAR_EVENT:
                event_type[0] = bcmOAMEventEndpointCCMTimein;
                break;
            case DBAL_ENUM_FVAL_LOC_EVENT_ALMOST_LOC_EVENT:
                event_type[0] = bcmOAMEventEndpointCCMTimeoutEarly;
                break;
            default:
                SHR_IF_ERR_EXIT_WITH_LOG(_SHR_E_PARAM, "Error: Illegal OAM LOC event %d \n%s%s", event_data->loc_evt,
                                         EMPTY, EMPTY);

        }
    }
    else if (event_data->rmep_state_change)
    {
        dnx_oam_oamp_oam_state_t rmep_state;
        rmep_state = event_data->rmep_state.eth_state;
        /*
         * Check port status 
         */
        if (DNX_OAM_OAMP_EVENT_PORT_BLOCKED(rmep_state.port_status))
        {
            event_type[0] = bcmOAMEventEndpointPortDown;
        }
        else if (DNX_OAM_OAMP_EVENT_PORT_UP(rmep_state.port_status))
        {
            event_type[0] = bcmOAMEventEndpointPortUp;
        }

        /*
         * Check interfase status 
         */
        if (DNX_OAM_OAMP_EVENT_INTERFACE_UP(rmep_state.interface_status))
        {
            event_type[1] = bcmOAMEventEndpointInterfaceUp;
        }
        else if (DNX_OAM_OAMP_EVENT_INTERFACE_DOWN(rmep_state.interface_status))
        {
            event_type[1] = bcmOAMEventEndpointInterfaceDown;
        }
        else if (DNX_OAM_OAMP_EVENT_INTERFACE_TESTING(rmep_state.interface_status))
        {
            event_type[1] = bcmOAMEventEndpointInterfaceTesting;
        }
        else if (DNX_OAM_OAMP_EVENT_INTERFACE_UNKNOWN(rmep_state.interface_status))
        {
            event_type[1] = bcmOAMEventEndpointInterfaceUnkonwn;
        }
        else if (DNX_OAM_OAMP_EVENT_INTERFACE_DORMANT(rmep_state.interface_status))
        {
            event_type[1] = bcmOAMEventEndpointInterfaceDormant;
        }
        else if (DNX_OAM_OAMP_EVENT_INTERFACE_NOT_PRESENT(rmep_state.interface_status))
        {
            event_type[1] = bcmOAMEventEndpointInterfaceNotPresent;
        }
        else if (DNX_OAM_OAMP_EVENT_INTERFACE_LL_DOWN(rmep_state.interface_status))
        {
            event_type[1] = bcmOAMEventEndpointInterfaceLLDown;
        }
    }
    else
    {
        SHR_IF_ERR_EXIT_WITH_LOG(_SHR_E_PARAM, "Error: Illegal OAMP OAM event \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief - This function converts the OAMP event to BCM BFD event type. 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] event_data - OAMP event data to which bcm BFD event type has to be derived.
 * \param [in] event_type - bcm BFD event type corresponding to an event.
 *   
 * \return
 *   shr_error_e
 */
static shr_error_e
dnx_oam_oamp_event_to_bcm_bfd_event_type(
    int unit,
    dnx_oam_oamp_interrupt_jr2_event_data_t * event_data,
    bcm_bfd_event_type_t * event_type)
{
    SHR_FUNC_INIT_VARS(unit);

    if (event_data->rdi_set)
    {
        *event_type = bcmBFDEventEndpointRemote;
    }
    else if (event_data->rdi_clear)
    {
        *event_type = bcmBFDEventEndpointRemoteUp;
    }
    else if (event_data->loc_evt)
    {
        switch (event_data->loc_evt)
        {
            case DBAL_ENUM_FVAL_LOC_EVENT_LOC_EVENT:
                *event_type = bcmBFDEventEndpointTimeout;
                break;
            case DBAL_ENUM_FVAL_LOC_EVENT_LOC_CLEAR_EVENT:
                *event_type = bcmBFDEventEndpointTimein;
                break;
            case DBAL_ENUM_FVAL_LOC_EVENT_ALMOST_LOC_EVENT:
                *event_type = bcmBFDEventEndpointTimeoutEarly;
                break;
            default:
                SHR_IF_ERR_EXIT_WITH_LOG(_SHR_E_PARAM, "Error: Illegal BFD LOC event %d \n%s%s", event_data->loc_evt,
                                         EMPTY, EMPTY);

        }
    }
    else if (event_data->rmep_state_change)
    {
        *event_type = bcmBFDEventStateChange;
    }
    else
    {
        SHR_IF_ERR_EXIT_WITH_LOG(_SHR_E_PARAM, "Error: Illegal OAMP BFD event \n%s%s%s", EMPTY, EMPTY, EMPTY);
    }

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief - This function inserts an event to the event hash table. 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] htbl - Pointer to hash table.
 * \param [in] event_list - Pointer to event list.
 * \param [in] eventt - Pointer to event data.
 *   
 * \return
 *   shr_error_e
 */
static shr_error_e
dnx_oam_oamp_insert_event_into_htbl_and_fifo(
    int unit,
    shr_htb_hash_table_t htbl,
    dnx_oam_oamp_eventt_list_t * event_list,
    dnx_oam_event_and_rmep_info * eventt)
{
    int rv, count_enable = 0;
    SHR_FUNC_INIT_VARS(unit);

    count_enable = dnx_data_oam.property.oam_multiple_event_count_enable_get(unit);

    rv = shr_htb_insert(htbl, (shr_htb_key_t) eventt, (shr_htb_data_t) 0);

    if ((count_enable == 2) && eventt->is_oam)
    {
        /** In this special case add event to the Event FIFO in any case.*/
        /** The event was already inserted in the hash-table,
         *  We don't care about the event count, so just insert
         *  event to list to make sure the event is recorded
         */
        if (rv != _SHR_E_EXISTS)
        {
            SHR_IF_ERR_EXIT(rv);
        }
        SHR_IF_ERR_EXIT(dnx_oam_oamp_eventt_list_push(unit, event_list, eventt));
    }
    else if (rv == _SHR_E_EXISTS)
    {
        /*
         * Normal case, adding a second event. update the existing event
         */
        shr_htb_data_t data;
        int count = 0;

        SHR_IF_ERR_EXIT(shr_htb_find(htbl, (shr_htb_key_t) eventt, &data, 1 /* remove */ ));
        count = PTR_TO_INT(data);
        if (count_enable)
        {
            count = (count >> 16) + 1;
        }
        else
        {
            count = 0;
        }
        SHR_IF_ERR_EXIT(shr_htb_insert(htbl, (shr_htb_key_t) eventt,
                                       INT_TO_PTR((count << 16) | BCM_OAM_EVENT_FLAGS_MULTIPLE)));
    }
    else
    {
        SHR_IF_ERR_EXIT(rv);
        /*
         * Normal case, adding first event. Insert event to FIFO as well
         */
        SHR_IF_ERR_EXIT(dnx_oam_oamp_eventt_list_push(unit, event_list, eventt));
    }
exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief - This function updates the OAMP event into 
 *          SW strcutures(hash and FIFO) maintained 
 *          by doing the necessary conversions. 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] htbl - Pointer to hash table.
 * \param [in] event_list - Pointer to event list.
 * \param [in] event_data - Pointer to event data.
 *   
 * \return
 *   shr_error_e
 */
static shr_error_e
dnx_oam_oamp_event_update_sw(
    int unit,
    shr_htb_hash_table_t htbl,
    dnx_oam_oamp_eventt_list_t * event_list,
    dnx_oam_oamp_interrupt_jr2_event_data_t * event_data)
{
    int event_idx = 0;
    dnx_oam_event_and_rmep_info event_found;
    bcm_bfd_event_type_t bfd_event_type = bcmBFDEventCount;
    bcm_oam_event_type_t oam_event_type[DNX_OAM_OAMP_MAX_STATE_CHANGE_EVENTS_POSSIBLE] =
        { bcmOAMEventCount, bcmOAMEventCount };
    SHR_FUNC_INIT_VARS(unit);
    sal_memset(&event_found, 0, sizeof(dnx_oam_event_and_rmep_info));

    event_found.mep_or_rmep_indx = event_data->rmep_db_ptr;

    if (event_data->is_oam)
    {
        /*
         * OAM event
         */
        event_found.is_oam = 1;
        /** Convert OAMP event(s) to bcm event type(s) */
        SHR_IF_ERR_EXIT(dnx_oam_oamp_event_to_bcm_oam_event_type(unit, event_data, oam_event_type));

        if (event_data->rmep_state_change)
        {   /** if there are two status events from OAMP, add both the events */
            for (event_idx = 0; event_idx < DNX_OAM_OAMP_MAX_STATE_CHANGE_EVENTS_POSSIBLE; event_idx++)
            {
                if (oam_event_type[event_idx] != bcmOAMEventCount)
                {
                    event_found.event_number = oam_event_type[event_idx];
                    /** Add the event to Hash table and event FIFO */
                    SHR_IF_ERR_EXIT(dnx_oam_oamp_insert_event_into_htbl_and_fifo(unit, htbl, event_list, &event_found));
                }
            }
        }
        else
        {
            event_found.event_number = oam_event_type[event_idx];
            /** Add the event to Hash table and event FIFO */
            SHR_IF_ERR_EXIT(dnx_oam_oamp_insert_event_into_htbl_and_fifo(unit, htbl, event_list, &event_found));
        }
    }
    else
    {   /* BFD event */
        event_found.is_oam = 0;
        /** Convert OAMP event to bcm event type */
        SHR_IF_ERR_EXIT(dnx_oam_oamp_event_to_bcm_bfd_event_type(unit, event_data, &bfd_event_type));
        if (bfd_event_type != bcmBFDEventCount)
        {
            event_found.event_number = (uint8) bfd_event_type;
            /** Add the event to Hash table and event FIFO */
            SHR_IF_ERR_EXIT(dnx_oam_oamp_insert_event_into_htbl_and_fifo(unit, htbl, event_list, &event_found));
        }
    }
exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief - This function  gets information on each 
 * stored event and calls the proper call back with that 
 * information. 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] event_info - Pointer to event data.
 * \param [in] really_the_flags - "global" data used by soc layer.
 *                       The reason this is not used as a global
 *                       variable is so that the interrupts will
 *                       be reentrable. The data is only global
 *                       per interrupt.
 *   
 * \return
 *   shr_error_e
 */
static shr_error_e
dnx_oam_oamp_fifo_interrupt_handle_user_callback(
    int unit,
    dnx_oam_event_and_rmep_info * event_info,
    shr_htb_data_t really_the_flags)
{
    int rmeb_db_ndx = 0, rv;
    dnx_oam_remote_endpoint_info_t rmep_info;
    dnx_oam_endpoint_info_t mep_info;
    int flags = PTR_TO_INT(really_the_flags);
    bcm_bfd_event_types_t event_types;

    SHR_FUNC_INIT_VARS(unit);

    rv = dnx_oam_sw_state_remote_endpoint_info_get(unit, event_info->mep_or_rmep_indx, &rmep_info);
    if (rv != _SHR_E_NONE)
    {
        LOG_WARN(BSL_LS_BCM_OAM, (BSL_META_U(unit, "Warning: Remote Endpoint already destroyed.\n")));
        SHR_EXIT();
    }
    if (event_info->is_oam)
    {
        /*
         * OAM event
         */
        DNX_OAM_REMOTE_MEP_INDEX_FROM_INTERNAL(event_info->mep_or_rmep_indx, rmeb_db_ndx);
        if (_g_oam_event_cb[unit][event_info->event_number])
        {
            /** Fetch EP information for Group information */
            rv = dnx_oam_sw_state_endpoint_info_get(unit, rmep_info.oam_id, &mep_info);
            if (rv != _SHR_E_NONE)
            {
                LOG_WARN(BSL_LS_BCM_OAM, (BSL_META_U(unit, "Warning: Endpoint already destroyed.\n")));
                SHR_EXIT();
            }
            /*
             * finally, the callback
             */
            _g_oam_event_cb[unit][event_info->event_number] (unit, flags, event_info->event_number, mep_info.group,
                                                             rmeb_db_ndx,
                                                             _g_oam_event_ud[unit][event_info->event_number]);
        }
    }
    else
    {   /** bfd event*/
        if (_g_bfd_event_cb[unit][event_info->event_number])
        {

            BCM_BFD_EVENT_TYPE_CLEAR_ALL(event_types);
            BCM_BFD_EVENT_TYPE_SET(event_types, event_info->event_number);
            /*
             * finally, the callback
             */
            _g_bfd_event_cb[unit][event_info->event_number] (unit, flags, event_types, rmep_info.oam_id,
                                                             _g_bfd_event_ud[unit][event_info->event_number]);
        }
    }

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief - This function handles the intterupts generated by OAMP.
 * Should not be called directly, rather through callback in soc 
 * layer. 
 * 
 * \param [in] unit - Number of hardware unit used.
 * \param [in] event_type - type of event generated by OAMP.
 * \param [in] interrupt_data - "global" data used by soc layer.
 *                       The reason this is not used as a global
 *                       variable is so that the interrupts will
 *                       be reentrable. The data is only global
 *                       per interrupt.
 *   
 * \return
 *   Error value
 */
static shr_error_e
dnx_oam_fifo_interrupt_handler(
    int unit,
    dnx_oam_oamp_dma_event_type_t event_type,
    dnx_oam_oamp_interrupt_global_data_t * interrupt_data)
{
    int rv;
    uint32 event_index;
    uint8 valid_event_exist = 0;
    dnx_oam_event_and_rmep_info event_found;
    dnx_oam_oamp_interrupt_jr2_event_data_t event_data;
    shr_htb_data_t data;

    shr_htb_hash_table_t event_htbl = NULL;
    int fifo_read_counter = 0;
    dnx_oam_oamp_eventt_list_t event_list;
    SHR_FUNC_INIT_VARS(unit);
    sal_memset(&event_found, 0, sizeof(dnx_oam_event_and_rmep_info));

    /*
     * Create event_list 
     */
    dnx_oam_oamp_eventt_list_init(unit, &event_list);

    SHR_IF_ERR_EXIT(dnx_oam_oamp_event_fifo_read(unit, event_type, &valid_event_exist, interrupt_data));

    SHR_IF_ERR_EXIT(shr_htb_create(&event_htbl,
                                   DNX_OAM_OAMP_FIFO_MAX_NUMBER_OF_EVENTS_IN_SW,
                                   sizeof(dnx_oam_event_and_rmep_info), "OAM event hash table."));
    while (valid_event_exist)
    {
        for (event_index = 0; event_index < DNX_OAM_OAMP_MAX_JR2_FORMAT_EVENTS; event_index++)
        {
            event_data = interrupt_data->interrupt_message.jr2_event_data[event_index];
            /** If not valid no need to put in SW database */
            if (event_data.is_valid)
            {
                rv = dnx_oam_oamp_event_update_sw(unit, event_htbl, &event_list, &event_data);
                if (rv != _SHR_E_NONE)
                {
                    LOG_WARN(BSL_LS_BCM_OAM, (BSL_META_U(unit, "Warning: Error in updating event SW data.\n")));
                    continue;
                }
            }
        }
        /*
         * Bailout condition - Preventing the while loop to run forever in case of interrupts arriving at a very high
         * rate 
         */
        if (++fifo_read_counter >= DNX_OAM_OAMP_FIFO_MAX_NUMBER_OF_EVENTS_IN_SW)
        {
            LOG_WARN(BSL_LS_BCM_OAM, (BSL_META_U(unit, "Warning: Too many OAMP interrupts .\n")));
            break;
        }

        SHR_IF_ERR_EXIT(dnx_oam_oamp_event_fifo_read(unit, event_type, &valid_event_exist, interrupt_data));
    }

    /*
     * Empty the data bases where events were stored and call user callbacks.
     */
    /*
     * For complete implementation details see comment above dnx_oam_oamp_eventt_Node_t
     */
    rv = dnx_oam_oamp_eventt_list_pop(unit, &event_list, &event_found);
    while (rv != _SHR_E_EMPTY)
    {
        SHR_IF_ERR_EXIT(shr_htb_find(event_htbl, &event_found, &data, 0 /* don't remove */ ));
        SHR_IF_ERR_EXIT(dnx_oam_oamp_fifo_interrupt_handle_user_callback(unit, &event_found, data));
        rv = dnx_oam_oamp_eventt_list_pop(unit, &event_list, &event_found);
    }

exit:
    if (event_htbl)
    {
        /*
         * Empty event_htbl in case of error 
         */
        rv = dnx_oam_oamp_eventt_list_pop(unit, &event_list, &event_found);
        while (rv != BCM_E_EMPTY)
        {
            SHR_IF_ERR_EXIT(shr_htb_find(event_htbl, &event_found, &data, 1 /* remove */ ));
            rv = dnx_oam_oamp_eventt_list_pop(unit, &event_list, &event_found);
        }
        SHR_IF_ERR_EXIT_WITH_LOG(shr_htb_destroy(&event_htbl, NULL), "shr_htb_destroy failed\n%s%s%s", EMPTY, EMPTY,
                                 EMPTY);
    }
    SHR_FUNC_EXIT;
}

/**
 * \brief - This is the call back function used in sal_dpc call.
 * 
 * \param [in] unit_ptr - pointer to hardware unit used.
 *   
 * \return
 *   void
 */
void
dnx_oam_oamp_dma_event_handler(
    void *unit_ptr)
{
    int unit = BSL_UNIT_UNKNOWN;
    dnx_oam_oamp_dma_event_type_t event_type = DNX_OAM_OAMP_DMA_EVENT_TYPE_EVENT;
    dnx_oam_oamp_interrupt_global_data_t interrupt_data;
    SHR_FUNC_INIT_VARS(unit);

    unit = PTR_TO_INT(unit_ptr);
    sal_memset(&interrupt_data, 0, sizeof(dnx_oam_oamp_interrupt_global_data_t));

    SHR_IF_ERR_EXIT(dnx_oam_fifo_interrupt_handler(unit, event_type, &interrupt_data));

exit:
    SHR_VOID_FUNC_EXIT;
}
