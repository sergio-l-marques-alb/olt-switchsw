/** \file dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db.c
 * Logical DB enums \n 
 * DO NOT EDIT THIS FILE!\n 
 * This file is auto-generated.\n 
 * Edits to this file will be lost when it is regenerated.\n 
 * \n 
 */
/*
 * $Id: $
 $Copyright: (c) 2018 Broadcom.
 Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 */
#ifdef BSL_LOG_MODULE
#  error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SOCDNX_DBALDNX

#include <src/soc/dnx/dbal/dbal_internal.h>

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_programs_tcam_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_PE_PROGRAMS_TCAM" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "TCAM_DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OAMP_PE_PROG_TCAM" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OAMP_PE_PROGRAM" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "VALID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    {
        int access_counter = 0;
        table_db_access_params_struct_t * access_params;
        int map_idx;
        map_idx = 0;
        access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
        access_counter++;
        /** set hard logic access type  */
        SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
        /** set access information  */
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "KEY" /* field name*/, 0 /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 1 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
        /** set register/memory information for current access  */
        {
            int regMemHwEntityId = INVALIDm;
            int fieldHwEntityId = INVALIDf;
            /** set reg/mem hw Entity id  */
            /** set field hw Entity id  */
            fieldHwEntityId = KEYf;
            SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, "OAMP_PE_PROG_TCAM" /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
        }
        access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
        access_counter++;
        /** set hard logic access type  */
        SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
        /** set access information  */
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "KEY_MASK" /* field name*/, 0 /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 1 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
        /** set register/memory information for current access  */
        {
            int regMemHwEntityId = INVALIDm;
            int fieldHwEntityId = INVALIDf;
            /** set reg/mem hw Entity id  */
            /** set field hw Entity id  */
            fieldHwEntityId = MASKf;
            SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, "OAMP_PE_PROG_TCAM" /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
        }
        access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
        access_counter++;
        /** set hard logic access type  */
        SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
        /** set access information  */
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "RESULT" /* field name*/, 0 /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 1 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
        /** set register/memory information for current access  */
        {
            int regMemHwEntityId = INVALIDm;
            int fieldHwEntityId = INVALIDf;
            /** set reg/mem hw Entity id  */
            /** set field hw Entity id  */
            fieldHwEntityId = DATf;
            SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, "OAMP_PE_PROG_TCAM" /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
        }
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_instructions_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_PE_INSTRUCTIONS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OAMP_PE_INSTRUCT_INDEX" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IN_FIFO_RD" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FEM1_SEL" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FEM2_SEL" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MUX1_SRC" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "MUX_SRC" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MERGE_INST" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SHIFT1_SRC" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BUFF_SIZE_SRC" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SHIFT2_SRC" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BUFF_SIZE_SRC" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FDBK_FF_WR_BIT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BUFF_WR" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BUFF_SIZE_SRC" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OP1_SEL" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "OP_SEL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OP2_SEL" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "OP_SEL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ALU_ACT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CMP1_ACT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "CMP_ACT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ALU_DST" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BUF_EOP" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "INST_CONST" /* name*/, NULL /* Valid*/, "11" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FDBK_FF_RD_BIT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OP3_SEL" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CMP2_ACT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "CMP_ACT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "INST_SRC" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MUX2_SRC" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "MUX_SRC" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BUFF2_SIZE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: IN_FIFO_RD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IN_FIFO_RD" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "0" /* data offset*/, 0 /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: FEM1_SEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "FEM1_SEL" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: FEM2_SEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "FEM2_SEL" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MUX1_SRC  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MUX1_SRC" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MERGE_INST  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MERGE_INST" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL+MUX1_SRC" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: SHIFT1_SRC  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SHIFT1_SRC" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL+MUX1_SRC+MERGE_INST" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: SHIFT2_SRC  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SHIFT2_SRC" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL+MUX1_SRC+MERGE_INST+SHIFT1_SRC" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: FDBK_FF_WR_BIT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "FDBK_FF_WR_BIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL+MUX1_SRC+MERGE_INST+SHIFT1_SRC+SHIFT2_SRC" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BUFF_WR  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BUFF_WR" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL+MUX1_SRC+MERGE_INST+SHIFT1_SRC+SHIFT2_SRC+FDBK_FF_WR_BIT" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BUFF_SIZE_SRC  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BUFF_SIZE_SRC" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL+MUX1_SRC+MERGE_INST+SHIFT1_SRC+SHIFT2_SRC+FDBK_FF_WR_BIT+BUFF_WR" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OP1_SEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OP1_SEL" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL+MUX1_SRC+MERGE_INST+SHIFT1_SRC+SHIFT2_SRC+FDBK_FF_WR_BIT+BUFF_WR+BUFF_SIZE_SRC" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OP2_SEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OP2_SEL" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "IN_FIFO_RD+FEM1_SEL+FEM2_SEL+MUX1_SRC+MERGE_INST+SHIFT1_SRC+SHIFT2_SRC+FDBK_FF_WR_BIT+BUFF_WR+BUFF_SIZE_SRC+OP1_SEL" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: ALU_ACT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ALU_ACT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC-CMP2_ACT-OP3_SEL-FDBK_FF_RD_BIT-INST_CONST-BUF_EOP-ALU_DST-CMP1_ACT-ALU_ACT" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CMP1_ACT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CMP1_ACT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC-CMP2_ACT-OP3_SEL-FDBK_FF_RD_BIT-INST_CONST-BUF_EOP-ALU_DST-CMP1_ACT" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: ALU_DST  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ALU_DST" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC-CMP2_ACT-OP3_SEL-FDBK_FF_RD_BIT-INST_CONST-BUF_EOP-ALU_DST" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BUF_EOP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BUF_EOP" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC-CMP2_ACT-OP3_SEL-FDBK_FF_RD_BIT-INST_CONST-BUF_EOP" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: INST_CONST  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "INST_CONST" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC-CMP2_ACT-OP3_SEL-FDBK_FF_RD_BIT-INST_CONST" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: FDBK_FF_RD_BIT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "FDBK_FF_RD_BIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC-CMP2_ACT-OP3_SEL-FDBK_FF_RD_BIT" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OP3_SEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OP3_SEL" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC-CMP2_ACT-OP3_SEL" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CMP2_ACT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CMP2_ACT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC-CMP2_ACT" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: INST_SRC  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "INST_SRC" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC-INST_SRC" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MUX2_SRC  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MUX2_SRC" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE-MUX2_SRC" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BUFF2_SIZE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BUFF2_SIZE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROGRAMm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PROG_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "RESULT-BUFF2_SIZE" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_programs_properties_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_PE_PROGRAMS_PROPERTIES" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OAMP_PE_PROGRAM_INDEX" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CONST_VALUE" /* name*/, NULL /* Valid*/, "32" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROGRAM_ADRESS" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "OAMP_PE_INSTRUCT_INDEX" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: CONST_VALUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CONST_VALUE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_CONSTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PE_CONST_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, "OAMP_PE_PROGRAM_INDEX" /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: PROGRAM_ADRESS  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PROGRAM_ADRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PE_PTR_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, "OAMP_PE_PROGRAM_INDEX" /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_fems_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_PE_FEMS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OAM_PE_FEM_INDEX" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, "30" /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FEM_OP" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, "16" /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: FEM_OP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                /** access with instance index all: loop on all instanceIndex  */
                {
                    int field_instance = 0;
                    /** below, 0 is the result field index, found according to to field mapping field name  */
                    table_db_field_params_struct_t result_field = cur_table_param->results_set[map_idx].result_fields[0];
                    for (field_instance = 0; field_instance < result_field.nof_instances_dnx_data.int_val; field_instance++)
                    {
                        access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                        access_counter++;
                        /** set hard logic access type  */
                        SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                        /** set access information  */
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "FEM_OP" /* field name*/, field_instance /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                        /** set register/memory information for current access  */
                        {
                            int regMemHwEntityId = INVALIDr;
                            int fieldHwEntityId = INVALIDf;
                            /** set reg/mem hw Entity id  */
                            regMemHwEntityId = OAMP_PE_FEM_MAPr;
                            /** set field hw Entity id  */
                            fieldHwEntityId = PE_FEM_MAPf;
                            SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, "OAM_PE_FEM_INDEX" /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "FEM_OP*INSTANCE" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                        }
                    }
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_mep_pe_profiles_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_MEP_PE_PROFILES" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MEP_PE_PROFILE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BYTE_0_OFFSET" /* name*/, NULL /* Valid*/, "6" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BYTE_1_OFFSET" /* name*/, NULL /* Valid*/, "6" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "WORD_0_OFFSET" /* name*/, NULL /* Valid*/, "6" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "WORD_1_OFFSET" /* name*/, NULL /* Valid*/, "6" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MEP_INSERT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: BYTE_0_OFFSET  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BYTE_0_OFFSET" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROFr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PE_VAR_8_NIBBLE_SELECT_0_PROF_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, "MEP_PE_PROFILE" /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BYTE_1_OFFSET  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BYTE_1_OFFSET" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROFr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PE_VAR_8_NIBBLE_SELECT_1_PROF_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, "MEP_PE_PROFILE" /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: WORD_0_OFFSET  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "WORD_0_OFFSET" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROFr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PE_VAR_16_NIBBLE_SELECT_0_PROF_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, "MEP_PE_PROFILE" /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: WORD_1_OFFSET  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "WORD_1_OFFSET" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROFr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PE_VAR_16_NIBBLE_SELECT_1_PROF_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, "MEP_PE_PROFILE" /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MEP_INSERT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MEP_INSERT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_PROFr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PE_MEP_INSERT_PROF_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, "MEP_PE_PROFILE" /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_instruction_general_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_PE_INSTRUCTION_GENERAL" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DEFAULT_INST_ADDR" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "OAMP_PE_INSTRUCT_INDEX" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MAX_INST" /* name*/, NULL /* Valid*/, "13" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DEBUG_MODE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_packed_field(unit, access_params, "0" /* field size*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_INSTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DEFAULT_INST_ADDRf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_status_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_PE_STATUS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CORE_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OAMP_PE_LAST_KEY" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "OAMP_PE_PROG_TCAM" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LAST_PROG_IDX" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "OAMP_PE_PROGRAM" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LAST_TCAM_IDX" /* name*/, NULL /* Valid*/, "6" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LAST_TCAM_HIT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LAST_PKT_VARS" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "DPC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: OAMP_PE_LAST_KEY  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OAMP_PE_LAST_KEY" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "0" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_KEY_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OAMP_PE_LAST_KEY" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_KEY_2f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAST_PROG_IDX  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_PROG_IDX" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "0" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_PROG_IDX_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_PROG_IDX" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_PROG_IDX_2f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAST_TCAM_IDX  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_TCAM_IDX" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "0" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_TCAM_IDX_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_TCAM_IDX" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_TCAM_IDX_2f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAST_TCAM_HIT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_TCAM_HIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "0" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_TCAM_HIT_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_TCAM_HIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_TCAM_HIT_2f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAST_PKT_VARS  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_PKT_VARS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "0" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_PKT_VARS_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_PKT_VARS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CORE_ID" /* field*/, "1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_PE_STATUS_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_PKT_VARS_2f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_init(
int unit,
table_db_struct_t* cur_table_param,
dbal_logical_table_t * table_info)
{
    SHR_FUNC_INIT_VARS(unit);
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_programs_tcam_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_instructions_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_programs_properties_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_fems_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_mep_pe_profiles_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_instruction_general_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_pe_db_oamp_pe_status_init(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}
