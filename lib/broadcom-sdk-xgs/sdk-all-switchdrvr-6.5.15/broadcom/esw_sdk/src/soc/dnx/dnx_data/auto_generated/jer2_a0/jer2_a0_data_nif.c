/** \file jer2_a0_data_nif.c
 * 
 * DEVICE DATA - NIF
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_PORT
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_nif.h>
#include <bcm/port.h>
#include <soc/portmod/portmod.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_fabric.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
#include <soc/dnxc/legacy/dnxc_port.h>
/*
 * }
 */

/*
 * EXTERN FUNCTIONS:
 * {
 */
/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: global
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_lcplls
 * define info:
 * number of lcplls supported
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_global_nof_lcplls_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_global;
    int define_index = dnx_data_nif_global_define_nof_lcplls;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric start_tx_threshold_global
 * numeric info:
 * Global start TX threshold. This value overrides TX threshold table values
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_global_start_tx_threshold_global_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_global;
    int define_index = dnx_data_nif_global_define_start_tx_threshold_global;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = -1;

    /* Set value */
    define->data = -1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_CUSTOM_FEATURE;
    define->property.doc = 
        "\n"
        "Start TX threshold controls how many 64B words will be accumulated in the MLF before starting to transmit\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "start_tx_threshold";
    define->property.range_min = 0;
    define->property.range_max = 0x3fff;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table pll_phys
 * Module - 'nif', Submodule - 'global', table - 'pll_phys'
 * phys controlled by each lcpll
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_global_pll_phys_set(
    int unit)
{
    int lcpll_index;
    dnx_data_nif_global_pll_phys_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_global;
    int table_index = dnx_data_nif_global_table_pll_phys;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_nif.global.nof_lcplls_get(unit);
    table->info_get.key_size[0] = dnx_data_nif.global.nof_lcplls_get(unit);

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_global_pll_phys_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_global_table_pll_phys");

    /* Store Default Values */
    default_data = (dnx_data_nif_global_pll_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->min_phy_id = 0;
    default_data->max_phy_id = 0;
    /* Set Default Values */
    for (lcpll_index = 0; lcpll_index < table->keys[0].size; lcpll_index++)
    {
        data = (dnx_data_nif_global_pll_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, lcpll_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_global_pll_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->min_phy_id = 0;
    data->max_phy_id = 47;
    data = (dnx_data_nif_global_pll_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->min_phy_id = 48;
    data->max_phy_id = 95;

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table start_tx_threshold_table
 * Module - 'nif', Submodule - 'global', table - 'start_tx_threshold_table'
 * TX threshold table of values per speed
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_global_start_tx_threshold_table_set(
    int unit)
{
    int idx_index;
    dnx_data_nif_global_start_tx_threshold_table_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_global;
    int table_index = dnx_data_nif_global_table_start_tx_threshold_table;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 8;
    table->info_get.key_size[0] = 8;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_global_start_tx_threshold_table_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_global_table_start_tx_threshold_table");

    /* Store Default Values */
    default_data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->speed = 0;
    default_data->start_thr = 0;
    /* Set Default Values */
    for (idx_index = 0; idx_index < table->keys[0].size; idx_index++)
    {
        data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, idx_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->speed = 10000;
    data->start_thr = 8;
    data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->speed = 20000;
    data->start_thr = 8;
    data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->speed = 25000;
    data->start_thr = 8;
    data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->speed = 40000;
    data->start_thr = 8;
    data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->speed = 50000;
    data->start_thr = 8;
    data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    data->speed = 100000;
    data->start_thr = 8;
    data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->speed = 200000;
    data->start_thr = 10;
    data = (dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->speed = 400000;
    data->start_thr = 10;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: phys
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_phys
 * define info:
 * number of phys supported
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_phys_nof_phys_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_phys;
    int define_index = dnx_data_nif_phys_define_nof_phys;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 96;

    /* Set value */
    define->data = 96;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_phys_per_core
 * define info:
 * number of phys per core supported
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_phys_nof_phys_per_core_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_phys;
    int define_index = dnx_data_nif_phys_define_nof_phys_per_core;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_nif.phys.nof_phys_get(unit)/dnx_data_device.general.max_nof_cores_get(unit);

    /* Set value */
    define->data = dnx_data_nif.phys.nof_phys_get(unit)/dnx_data_device.general.max_nof_cores_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_pms
 * define info:
 * number of PMs supported
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_phys_nof_pms_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_phys;
    int define_index = dnx_data_nif_phys_define_nof_pms;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 12;

    /* Set value */
    define->data = 12;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vco_div
 * define info:
 * VCO divider
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_phys_vco_div_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_phys;
    int define_index = dnx_data_nif_phys_define_vco_div;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table general
 * Module - 'nif', Submodule - 'phys', table - 'general'
 * general data about phys
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_phys_general_set(
    int unit)
{
    dnx_data_nif_phys_general_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_phys;
    int table_index = dnx_data_nif_phys_table_general;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Info - default values */
    table->values[0].default_val = "0xffffffff, 0xffffffff, 0xffffffff";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_phys_general_t, (1 + 1 /* to store default value */ ), "data of dnx_data_nif_phys_table_general");

    /* Store Default Values */
    default_data = (dnx_data_nif_phys_general_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    _SHR_PBMP_WORD_SET(default_data->supported_phys, 0, 0xffffffff);
    _SHR_PBMP_WORD_SET(default_data->supported_phys, 1, 0xffffffff);
    _SHR_PBMP_WORD_SET(default_data->supported_phys, 2, 0xffffffff);
    /* Set Default Values */
    data = (dnx_data_nif_phys_general_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    sal_memcpy(data, default_data, table->size_of_values);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table polarity
 * Module - 'nif', Submodule - 'phys', table - 'polarity'
 * rx and tx polarity per lane
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_phys_polarity_set(
    int unit)
{
    int lane_index_index;
    dnx_data_nif_phys_polarity_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_phys;
    int table_index = dnx_data_nif_phys_table_polarity;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_nif.phys.nof_phys_get(unit);
    table->info_get.key_size[0] = dnx_data_nif.phys.nof_phys_get(unit);

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_phys_polarity_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_phys_table_polarity");

    /* Store Default Values */
    default_data = (dnx_data_nif_phys_polarity_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->tx_polarity = 0;
    default_data->rx_polarity = 0;
    /* Set Default Values */
    for (lane_index_index = 0; lane_index_index < table->keys[0].size; lane_index_index++)
    {
        data = (dnx_data_nif_phys_polarity_t *) dnxc_data_mgmt_table_data_get(unit, table, lane_index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - tx_polarity
     */
    table->values[0].property.name = spn_PHY_TX_POLARITY_FLIP;
    table->values[0].property.doc =
        "\n"
        "Flips PHY TX polarity if enabled\n"
        "phy_tx_polarity_flip_#lane# = 0 / 1\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_suffix_enable;
    table->values[0].property.method_str = "suffix_enable";
    table->values[0].property.suffix = "phy";
    for (lane_index_index = 0; lane_index_index < table->keys[0].size; lane_index_index++)
    {
        data = (dnx_data_nif_phys_polarity_t *) dnxc_data_mgmt_table_data_get(unit, table, lane_index_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, lane_index_index, &data->tx_polarity));
    }
    /*
     * Value Property - rx_polarity
     */
    table->values[1].property.name = spn_PHY_RX_POLARITY_FLIP;
    table->values[1].property.doc =
        "\n"
        "Flips PHY RX polarity if enabled\n"
        "phy_tx_polarity_flip_#lane# = 0 / 1\n"
        "\n"
    ;
    table->values[1].property.method = dnxc_data_property_method_suffix_enable;
    table->values[1].property.method_str = "suffix_enable";
    table->values[1].property.suffix = "phy";
    for (lane_index_index = 0; lane_index_index < table->keys[0].size; lane_index_index++)
    {
        data = (dnx_data_nif_phys_polarity_t *) dnxc_data_mgmt_table_data_get(unit, table, lane_index_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[1].property, lane_index_index, &data->rx_polarity));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table core_phys_map
 * Module - 'nif', Submodule - 'phys', table - 'core_phys_map'
 * map pipeline core to connected PHYs
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_phys_core_phys_map_set(
    int unit)
{
    int core_index_index;
    dnx_data_nif_phys_core_phys_map_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_phys;
    int table_index = dnx_data_nif_phys_table_core_phys_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "0x0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_phys_core_phys_map_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_phys_table_core_phys_map");

    /* Store Default Values */
    default_data = (dnx_data_nif_phys_core_phys_map_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    _SHR_PBMP_WORD_SET(default_data->phys, 0, 0x0);
    /* Set Default Values */
    for (core_index_index = 0; core_index_index < table->keys[0].size; core_index_index++)
    {
        data = (dnx_data_nif_phys_core_phys_map_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_phys_core_phys_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0xFFFFFFFF);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x0000FFFF);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data = (dnx_data_nif_phys_core_phys_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0xFFFF0000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0xFFFFFFFF);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: ilkn
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_is_supported_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int feature_index = dnx_data_nif_ilkn_is_supported;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define ilkn_unit_nof
 * define info:
 * Number of ILKN units in the device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_ilkn_unit_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_ilkn_unit_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ilkn_unit_if_nof
 * define info:
 * Number of ILKN Interfaces in each ILKN unit
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_ilkn_unit_if_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_ilkn_unit_if_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ilkn_if_nof
 * define info:
 * Number of ILKN Interfaces in the device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_ilkn_if_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_ilkn_if_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_nif.ilkn.ilkn_unit_nof_get(unit) * dnx_data_nif.ilkn.ilkn_unit_if_nof_get(unit);

    /* Set value */
    define->data = dnx_data_nif.ilkn.ilkn_unit_nof_get(unit) * dnx_data_nif.ilkn.ilkn_unit_if_nof_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define lanes_max_nof
 * define info:
 * Max number of lanes for ILKN port
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_lanes_max_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_lanes_max_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 24;

    /* Set value */
    define->data = 24;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define lanes_allowed_nof
 * define info:
 * The allowed lanes for each ILKN port
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_lanes_allowed_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_lanes_allowed_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ilkn_over_eth_pms_max
 * define info:
 * Max number eth pms ilkn lanes is part of
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_ilkn_over_eth_pms_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_ilkn_over_eth_pms_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define segments_max_nof
 * define info:
 * Max number of segments in ILKN protocol. (Segment is a resource of ILKN which is shared between all ports of the ILKN unit)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_segments_max_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_segments_max_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define watermark_high
 * define info:
 * High Watermark value for ILKN
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_watermark_high_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_watermark_high;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define watermark_low
 * define info:
 * Low Watermark value for ILKN
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_watermark_low_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_watermark_low;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define pms_nof
 * define info:
 * Number of PMs connectted to the ILKN unit
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_pms_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_pms_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmac_bus_size
 * define info:
 * Fabric MAC bus size [bits], relevant for ILKN over fabric ports
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_fmac_bus_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int define_index = dnx_data_nif_ilkn_define_fmac_bus_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 70;

    /* Set value */
    define->data = 70;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table phys
 * Module - 'nif', Submodule - 'ilkn', table - 'phys'
 * phys bitmap for ports added by soc property
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_phys_set(
    int unit)
{
    int ilkn_id_index;
    dnx_data_nif_ilkn_phys_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int table_index = dnx_data_nif_ilkn_table_phys;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_ilkn_phys_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_ilkn_table_phys");

    /* Store Default Values */
    default_data = (dnx_data_nif_ilkn_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    _SHR_PBMP_WORD_SET(default_data->bitmap, 0, 0);
    /* Set Default Values */
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - bitmap
     */
    table->values[0].property.name = spn_ILKN_LANES;
    table->values[0].property.doc =
        "\n"
        "ilkn_lanes_#ilkn_id#=#bitmap#\n"
        "The bitmap parameter is up to 24 bits.\n"
        "When a bit is set, the equivalent lane (PHY) is used for the corresponding port.\n"
        "The ilkn_id parameter is the ILKN interface ID in the range 0-1.\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_suffix_pbmp;
    table->values[0].property.method_str = "suffix_pbmp";
    table->values[0].property.suffix = "";
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, ilkn_id_index, &data->bitmap));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table supported_phys
 * Module - 'nif', Submodule - 'ilkn', table - 'supported_phys'
 * supported phys per ILKN id
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_supported_phys_set(
    int unit)
{
    int ilkn_id_index;
    dnx_data_nif_ilkn_supported_phys_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int table_index = dnx_data_nif_ilkn_table_supported_phys;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_ilkn_supported_phys_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_ilkn_table_supported_phys");

    /* Store Default Values */
    default_data = (dnx_data_nif_ilkn_supported_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->is_supported = 0;
    default_data->max_phys = 0;
    _SHR_PBMP_WORD_SET(default_data->nif_phys, 0, 0);
    _SHR_PBMP_WORD_SET(default_data->fabric_phys, 0, 0);
    /* Set Default Values */
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_supported_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_ilkn_supported_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->is_supported = 1;
    data->max_phys = 24;
    _SHR_PBMP_WORD_SET(data->nif_phys, 0, 0x00ffffff);
    _SHR_PBMP_WORD_SET(data->fabric_phys, 0, 0x00ffffff);
    data = (dnx_data_nif_ilkn_supported_phys_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->is_supported = 1;
    data->max_phys = 24;
    _SHR_PBMP_WORD_SET(data->nif_phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->nif_phys, 1, 0xffff0000);
    _SHR_PBMP_WORD_SET(data->nif_phys, 2, 0x000000ff);
    _SHR_PBMP_WORD_SET(data->fabric_phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->fabric_phys, 1, 0xff000000);
    _SHR_PBMP_WORD_SET(data->fabric_phys, 2, 0x0000ffff);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table supported_core
 * Module - 'nif', Submodule - 'ilkn', table - 'supported_core'
 * supported device core per ILKN id
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_supported_core_set(
    int unit)
{
    int ilkn_id_index;
    dnx_data_nif_ilkn_supported_core_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int table_index = dnx_data_nif_ilkn_table_supported_core;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_ilkn_supported_core_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_ilkn_table_supported_core");

    /* Store Default Values */
    default_data = (dnx_data_nif_ilkn_supported_core_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->core = -1;
    /* Set Default Values */
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_supported_core_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_ilkn_supported_core_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->core = 0;
    data = (dnx_data_nif_ilkn_supported_core_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->core = 1;

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table properties
 * Module - 'nif', Submodule - 'ilkn', table - 'properties'
 * ILKN properties per ILKN id - added using soc property.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_properties_set(
    int unit)
{
    int ilkn_id_index;
    dnx_data_nif_ilkn_properties_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int table_index = dnx_data_nif_ilkn_table_properties;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "256";
    table->values[1].default_val = "32";
    table->values[2].default_val = "32";
    table->values[3].default_val = "2048";
    table->values[4].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_ilkn_properties_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_ilkn_table_properties");

    /* Store Default Values */
    default_data = (dnx_data_nif_ilkn_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->burst_max = 256;
    default_data->burst_short = 32;
    default_data->burst_min = 32;
    default_data->metaframe_period = 2048;
    default_data->is_over_fabric = 0;
    /* Set Default Values */
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - burst_max
     */
    table->values[0].property.name = spn_ILKN_BURST_MAX;
    table->values[0].property.doc =
        "\n"
        "Configure ILKN BurstMax per ILKN id.\n"
        "in Jer2 the only supported value is 256.\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_suffix_range;
    table->values[0].property.method_str = "suffix_range";
    table->values[0].property.suffix = "";
    table->values[0].property.range_min = 256;
    table->values[0].property.range_max = 256;
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, ilkn_id_index, &data->burst_max));
    }
    /*
     * Value Property - burst_short
     */
    table->values[1].property.name = spn_ILKN_BURST_SHORT;
    table->values[1].property.doc =
        "\n"
        "Configure ILKN BurstShort per ILKN id.\n"
        "supported values: 32, 64... BurstMax / 2.\n"
        "default: 32.\n"
        "\n"
    ;
    table->values[1].property.method = dnxc_data_property_method_suffix_range;
    table->values[1].property.method_str = "suffix_range";
    table->values[1].property.suffix = "";
    table->values[1].property.range_min = 32;
    table->values[1].property.range_max = 128;
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[1].property, ilkn_id_index, &data->burst_short));
    }
    /*
     * Value Property - burst_min
     */
    table->values[2].property.name = spn_ILKN_BURST_MIN;
    table->values[2].property.doc =
        "\n"
        "Configure ILKN BurstMin per ILKN id.\n"
        "supported values: BurstShort... BurstMax / 2.\n"
        "default: burstShort.\n"
        "\n"
    ;
    table->values[2].property.method = dnxc_data_property_method_suffix_range;
    table->values[2].property.method_str = "suffix_range";
    table->values[2].property.suffix = "";
    table->values[2].property.range_min = 32;
    table->values[2].property.range_max = 128;
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[2].property, ilkn_id_index, &data->burst_min));
    }
    /*
     * Value Property - metaframe_period
     */
    table->values[3].property.name = spn_ILKN_METAFRAME_SYNC_PERIOD;
    table->values[3].property.doc =
        "\n"
        "Configure ILKN Metaframe priod per ILKN id.\n"
        "supported values: 64 - 16K.\n"
        "default: 2048.\n"
        "\n"
    ;
    table->values[3].property.method = dnxc_data_property_method_suffix_range;
    table->values[3].property.method_str = "suffix_range";
    table->values[3].property.suffix = "";
    table->values[3].property.range_min = 64;
    table->values[3].property.range_max = 16384;
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[3].property, ilkn_id_index, &data->metaframe_period));
    }
    /*
     * Value Property - is_over_fabric
     */
    table->values[4].property.name = spn_USE_FABRIC_LINKS_FOR_ILKN_NIF;
    table->values[4].property.doc =
        "\n"
        "Configure the ILKN IF to work over Fabric links instead of NIF.\n"
        "default = 0;\n"
        "\n"
    ;
    table->values[4].property.method = dnxc_data_property_method_suffix_only_enable;
    table->values[4].property.method_str = "suffix_only_enable";
    table->values[4].property.suffix = "ilkn";
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[4].property, ilkn_id_index, &data->is_over_fabric));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table nif_pms
 * Module - 'nif', Submodule - 'ilkn', table - 'nif_pms'
 * ILKN PM table over NIF
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_nif_pms_set(
    int unit)
{
    int pm_id_index;
    dnx_data_nif_ilkn_nif_pms_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int table_index = dnx_data_nif_ilkn_table_nif_pms;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 12;
    table->info_get.key_size[0] = 12;

    /* Info - default values */
    table->values[0].default_val = "portmodDispatchTypeCount";
    table->values[1].default_val = "-1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_ilkn_nif_pms_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_ilkn_table_nif_pms");

    /* Store Default Values */
    default_data = (dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->dispatch_type = portmodDispatchTypeCount;
    default_data->first_phy = -1;
    /* Set Default Values */
    for (pm_id_index = 0; pm_id_index < table->keys[0].size; pm_id_index++)
    {
        data = (dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, pm_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->dispatch_type = portmodDispatchTypePm8x50;
    data->first_phy = 0;
    data = (dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->dispatch_type = portmodDispatchTypePm8x50;
    data->first_phy = 8;
    data = (dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->dispatch_type = portmodDispatchTypePm8x50;
    data->first_phy = 16;
    data = (dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->dispatch_type = portmodDispatchTypePm8x50;
    data->first_phy = 48;
    data = (dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->dispatch_type = portmodDispatchTypePm8x50;
    data->first_phy = 56;
    data = (dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->dispatch_type = portmodDispatchTypePm8x50;
    data->first_phy = 64;

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table fabric_pms
 * Module - 'nif', Submodule - 'ilkn', table - 'fabric_pms'
 * ILKN PM table over Fabric
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_fabric_pms_set(
    int unit)
{
    int pm_id_index;
    dnx_data_nif_ilkn_fabric_pms_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int table_index = dnx_data_nif_ilkn_table_fabric_pms;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 14;
    table->info_get.key_size[0] = 14;

    /* Info - default values */
    table->values[0].default_val = "portmodDispatchTypeCount";
    table->values[1].default_val = "-1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_ilkn_fabric_pms_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_ilkn_table_fabric_pms");

    /* Store Default Values */
    default_data = (dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->dispatch_type = portmodDispatchTypeCount;
    default_data->first_phy = -1;
    /* Set Default Values */
    for (pm_id_index = 0; pm_id_index < table->keys[0].size; pm_id_index++)
    {
        data = (dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, pm_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->dispatch_type = portmodDispatchTypePm8x50_fabric;
    data->first_phy = 0;
    data = (dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->dispatch_type = portmodDispatchTypePm8x50_fabric;
    data->first_phy = 8;
    data = (dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->dispatch_type = portmodDispatchTypePm8x50_fabric;
    data->first_phy = 16;
    data = (dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->dispatch_type = portmodDispatchTypePm8x50_fabric;
    data->first_phy = 56;
    data = (dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->dispatch_type = portmodDispatchTypePm8x50_fabric;
    data->first_phy = 64;
    data = (dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    data->dispatch_type = portmodDispatchTypePm8x50_fabric;
    data->first_phy = 72;

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table ilkn_pms
 * Module - 'nif', Submodule - 'ilkn', table - 'ilkn_pms'
 * ILKN PM table per ILKN id
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_ilkn_ilkn_pms_set(
    int unit)
{
    int ilkn_id_index;
    dnx_data_nif_ilkn_ilkn_pms_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_ilkn;
    int table_index = dnx_data_nif_ilkn_table_ilkn_pms;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "-1";
    table->values[1].default_val = "-1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_ilkn_ilkn_pms_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_ilkn_table_ilkn_pms");

    /* Store Default Values */
    default_data = (dnx_data_nif_ilkn_ilkn_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->nif_pm_ids[0] = -1;
    default_data->fabric_pm_ids[0] = -1;
    /* Set Default Values */
    for (ilkn_id_index = 0; ilkn_id_index < table->keys[0].size; ilkn_id_index++)
    {
        data = (dnx_data_nif_ilkn_ilkn_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, ilkn_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_ilkn_ilkn_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->nif_pm_ids[0] = 0;
    data->nif_pm_ids[1] = 1;
    data->nif_pm_ids[2] = 2;
    data->fabric_pm_ids[0] = 0;
    data->fabric_pm_ids[1] = 1;
    data->fabric_pm_ids[2] = 2;
    data = (dnx_data_nif_ilkn_ilkn_pms_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->nif_pm_ids[0] = 6;
    data->nif_pm_ids[1] = 7;
    data->nif_pm_ids[2] = 8;
    data->fabric_pm_ids[0] = 7;
    data->fabric_pm_ids[1] = 8;
    data->fabric_pm_ids[2] = 9;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: eth
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define cdu_nof
 * define info:
 * Number of CDU instances in the device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdu_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_cdu_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 12;

    /* Set value */
    define->data = 12;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cdum_nof
 * define info:
 * Number of CDUM instances in the device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdum_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_cdum_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cdu_pms_nof
 * define info:
 * Number of pms in each CDU in the device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdu_pms_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_cdu_pms_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cdu_nof_per_core
 * define info:
 * Number of CDU instances in each device core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdu_nof_per_core_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_cdu_nof_per_core;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cdu_lanes_nof
 * define info:
 * Number of lanes in each CDU
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdu_lanes_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_cdu_lanes_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cdu_mac_nof
 * define info:
 * Number of MAC units per CDU
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdu_mac_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_cdu_mac_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define mac_lanes_nof
 * define info:
 * Number of lanes in each MAC
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_mac_lanes_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_mac_lanes_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cdu_logical_fifo_nof
 * define info:
 * number of logical fifos in the CDU
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdu_logical_fifo_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_cdu_logical_fifo_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cdu_memory_entries_nof
 * define info:
 * number of entries in the CDU memory, to be shared between all logical FIFOs
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdu_memory_entries_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_cdu_memory_entries_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1024;

    /* Set value */
    define->data = 1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define priority_group_nof_entries_min
 * define info:
 * minimum number of entries to allocate to a priority group (priority group = RMC)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_priority_group_nof_entries_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_priority_group_nof_entries_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define priority_groups_nof
 * define info:
 * number of allowed priority groups per port (priority group = RMC)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_priority_groups_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_priority_groups_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define pad_size_min
 * define info:
 * min padding size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_pad_size_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_pad_size_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define pad_size_max
 * define info:
 * max padding size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_pad_size_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_pad_size_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 96;

    /* Set value */
    define->data = 96;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define packet_size_max
 * define info:
 * max packet size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_packet_size_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_packet_size_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x3fff;

    /* Set value */
    define->data = 0x3fff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define an_max_nof_abilities
 * define info:
 * max auto-negotiation abilities
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_an_max_nof_abilities_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int define_index = dnx_data_nif_eth_define_an_max_nof_abilities;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table pm_properties
 * Module - 'nif', Submodule - 'eth', table - 'pm_properties'
 * PM properties per PM
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_pm_properties_set(
    int unit)
{
    int pm_index_index;
    dnx_data_nif_eth_pm_properties_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int table_index = dnx_data_nif_eth_table_pm_properties;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 12;
    table->info_get.key_size[0] = 12;

    /* Info - default values */
    table->values[0].default_val = "0x0";
    table->values[1].default_val = "0x1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_eth_pm_properties_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_eth_table_pm_properties");

    /* Store Default Values */
    default_data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    _SHR_PBMP_WORD_SET(default_data->phys, 0, 0x0);
    default_data->tvco_pll_index = 0x1;
    /* Set Default Values */
    for (pm_index_index = 0; pm_index_index < table->keys[0].size; pm_index_index++)
    {
        data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, pm_index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x000000FF);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x0000FF00);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00FF0000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0xFF000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x000000FF);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x0000FF00);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00FF0000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0xFF000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00000000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x000000FF);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x0000FF00);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0x00FF0000);
    data->tvco_pll_index = 1;
    data = (dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
    _SHR_PBMP_WORD_SET(data->phys, 0, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 1, 0x00000000);
    _SHR_PBMP_WORD_SET(data->phys, 2, 0xFF000000);
    data->tvco_pll_index = 1;

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table cdu_pm_map
 * Module - 'nif', Submodule - 'eth', table - 'cdu_pm_map'
 * map cdu to PM instance
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_cdu_pm_map_set(
    int unit)
{
    int cdu_index_index;
    dnx_data_nif_eth_cdu_pm_map_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int table_index = dnx_data_nif_eth_table_cdu_pm_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 12;
    table->info_get.key_size[0] = 12;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_eth_cdu_pm_map_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_eth_table_cdu_pm_map");

    /* Store Default Values */
    default_data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->pms[0] = -1;
    /* Set Default Values */
    for (cdu_index_index = 0; cdu_index_index < table->keys[0].size; cdu_index_index++)
    {
        data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, cdu_index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->pms[0] = 0;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->pms[0] = 1;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->pms[0] = 2;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->pms[0] = 3;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->pms[0] = 4;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    data->pms[0] = 5;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->pms[0] = 6;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->pms[0] = 7;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->pms[0] = 8;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    data->pms[0] = 9;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
    data->pms[0] = 10;
    data = (dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
    data->pms[0] = 11;

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table max_speed
 * Module - 'nif', Submodule - 'eth', table - 'max_speed'
 * Max speed for each ethernet interface type.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_eth_max_speed_set(
    int unit)
{
    int lane_num_index;
    dnx_data_nif_eth_max_speed_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_eth;
    int table_index = dnx_data_nif_eth_table_max_speed;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 9;
    table->info_get.key_size[0] = 9;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_eth_max_speed_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_eth_table_max_speed");

    /* Store Default Values */
    default_data = (dnx_data_nif_eth_max_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->speed = 0;
    /* Set Default Values */
    for (lane_num_index = 0; lane_num_index < table->keys[0].size; lane_num_index++)
    {
        data = (dnx_data_nif_eth_max_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, lane_num_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_eth_max_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->speed = 50000;
    data = (dnx_data_nif_eth_max_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->speed = 100000;
    data = (dnx_data_nif_eth_max_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->speed = 200000;
    data = (dnx_data_nif_eth_max_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->speed = 400000;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: prd
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_control_frames
 * define info:
 * Number of control frame properties to which each packet is compared in order to be recognized as control frame in the PRD parser
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_prd_nof_control_frames_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_prd;
    int define_index = dnx_data_nif_prd_define_nof_control_frames;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ether_type_codes
 * define info:
 * Number of ether types supported by the PRD Parser
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_prd_nof_ether_type_codes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_prd;
    int define_index = dnx_data_nif_prd_define_nof_ether_type_codes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_tcam_entries
 * define info:
 * Number of entries in PRD Parser soft stage TCAM
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_prd_nof_tcam_entries_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_prd;
    int define_index = dnx_data_nif_prd_define_nof_tcam_entries;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_mpls_special_labels
 * define info:
 * Number of MPLS special labels recognized by the PRD parser
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_prd_nof_mpls_special_labels_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_prd;
    int define_index = dnx_data_nif_prd_define_nof_mpls_special_labels;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_priorities
 * define info:
 * Number of PRD Priorities
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_prd_nof_priorities_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_prd;
    int define_index = dnx_data_nif_prd_define_nof_priorities;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define custom_ether_type_code_min
 * define info:
 * Min value of the configurable ether type codes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_prd_custom_ether_type_code_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_prd;
    int define_index = dnx_data_nif_prd_define_custom_ether_type_code_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define custom_ether_type_code_max
 * define info:
 * Max value of the configurable ether type codes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_prd_custom_ether_type_code_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_prd;
    int define_index = dnx_data_nif_prd_define_custom_ether_type_code_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table ether_type
 * Module - 'nif', Submodule - 'prd', table - 'ether_type'
 * Ether type codes and sizes for fixed ether types.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_prd_ether_type_set(
    int unit)
{
    int ether_type_code_index;
    dnx_data_nif_prd_ether_type_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_prd;
    int table_index = dnx_data_nif_prd_table_ether_type;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 16;
    table->info_get.key_size[0] = 16;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "no name";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_prd_ether_type_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_prd_table_ether_type");

    /* Store Default Values */
    default_data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->ether_type_size = 0;
    default_data->ether_type_name = "no name";
    /* Set Default Values */
    for (ether_type_code_index = 0; ether_type_code_index < table->keys[0].size; ether_type_code_index++)
    {
        data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, ether_type_code_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "No Match";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "Configurable 1";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "Configurable 2";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "Configurable 3";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "Configurable 4";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "Configurable 5";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "Configurable 6";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "Configurable 7";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->ether_type_size = 6;
    data->ether_type_name = "TRILL";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "Control Frame";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
    data->ether_type_size = 28;
    data->ether_type_name = "ARP";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
    data->ether_type_size = 4;
    data->ether_type_name = "CFM";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 12, 0);
    data->ether_type_size = 36;
    data->ether_type_name = "FCoE";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 13, 0);
    data->ether_type_size = 20;
    data->ether_type_name = "IPv4";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 14, 0);
    data->ether_type_size = 40;
    data->ether_type_name = "IPv6";
    data = (dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 15, 0);
    data->ether_type_size = 0;
    data->ether_type_name = "MPLS";

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: portmod
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define pm_types_nof
 * define info:
 * Number of pm types
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_portmod_pm_types_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_portmod;
    int define_index = dnx_data_nif_portmod_define_pm_types_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table pm_types_and_interfaces
 * Module - 'nif', Submodule - 'portmod', table - 'pm_types_and_interfaces'
 * fixed types and interfaces per device
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_portmod_pm_types_and_interfaces_set(
    int unit)
{
    int index_index;
    dnx_data_nif_portmod_pm_types_and_interfaces_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_portmod;
    int table_index = dnx_data_nif_portmod_table_pm_types_and_interfaces;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_DATA_MAX_NIF_PORTMOD_PM_TYPES_NOF;
    table->info_get.key_size[0] = DNX_DATA_MAX_NIF_PORTMOD_PM_TYPES_NOF;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_portmod_pm_types_and_interfaces_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_portmod_table_pm_types_and_interfaces");

    /* Store Default Values */
    default_data = (dnx_data_nif_portmod_pm_types_and_interfaces_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->type = 0;
    default_data->instances = 0;
    /* Set Default Values */
    for (index_index = 0; index_index < table->keys[0].size; index_index++)
    {
        data = (dnx_data_nif_portmod_pm_types_and_interfaces_t *) dnxc_data_mgmt_table_data_get(unit, table, index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_portmod_pm_types_and_interfaces_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->type = portmodDispatchTypePm8x50;
    data->instances = dnx_data_nif.eth.cdu_nof_get(unit);
    data = (dnx_data_nif_portmod_pm_types_and_interfaces_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->type = portmodDispatchTypePmOsILKN_50G;
    data->instances = dnx_data_nif.ilkn.ilkn_unit_nof_get(unit);
    data = (dnx_data_nif_portmod_pm_types_and_interfaces_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->type = portmodDispatchTypePm8x50_fabric;
    data->instances = dnx_data_fabric.blocks.nof_pms_get(unit);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table pm_supported_features
 * Module - 'nif', Submodule - 'portmod', table - 'pm_supported_features'
 * supported features per Port Macro
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_portmod_pm_supported_features_set(
    int unit)
{
    int pm_index_index;
    dnx_data_nif_portmod_pm_supported_features_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_portmod;
    int table_index = dnx_data_nif_portmod_table_pm_supported_features;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 12;
    table->info_get.key_size[0] = 12;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_nif_portmod_pm_supported_features_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_nif_portmod_table_pm_supported_features");

    /* Store Default Values */
    default_data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->is_pam4_support = 0;
    default_data->is_400g_support = 0;
    default_data->is_25g_support = 0;
    /* Set Default Values */
    for (pm_index_index = 0; pm_index_index < table->keys[0].size; pm_index_index++)
    {
        data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, pm_index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;
    data = (dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
    data->is_pam4_support = 1;
    data->is_400g_support = 1;
    data->is_25g_support = 1;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: schedulder
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define rate_per_cdu_bit
 * define info:
 * The Rate equivalent to 1 bit of CDU scheduler
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_schedulder_rate_per_cdu_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_schedulder;
    int define_index = dnx_data_nif_schedulder_define_rate_per_cdu_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 100000;

    /* Set value */
    define->data = 100000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define rate_per_rmc_bit
 * define info:
 * The Rate equivalent to 1 bit of RMC scheduler
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_schedulder_rate_per_rmc_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_schedulder;
    int define_index = dnx_data_nif_schedulder_define_rate_per_rmc_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 50000;

    /* Set value */
    define->data = 50000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_cdu_bits
 * define info:
 * Number of bits in CDU scheduler
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_schedulder_nof_cdu_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_schedulder;
    int define_index = dnx_data_nif_schedulder_define_nof_cdu_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_rmc_bits
 * define info:
 * Number of bits in RMC scheduler
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_nif_schedulder_nof_rmc_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_nif;
    int submodule_index = dnx_data_nif_submodule_schedulder;
    int define_index = dnx_data_nif_schedulder_define_nof_rmc_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jer2_a0_data_nif_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_nif;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: global
     */
    submodule_index = dnx_data_nif_submodule_global;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_nif_global_define_nof_lcplls;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_global_nof_lcplls_set;
    data_index = dnx_data_nif_global_define_start_tx_threshold_global;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_global_start_tx_threshold_global_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_nif_global_table_pll_phys;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_global_pll_phys_set;
    data_index = dnx_data_nif_global_table_start_tx_threshold_table;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_global_start_tx_threshold_table_set;
    /*
     * Attach submodule: phys
     */
    submodule_index = dnx_data_nif_submodule_phys;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_nif_phys_define_nof_phys;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_phys_nof_phys_set;
    data_index = dnx_data_nif_phys_define_nof_phys_per_core;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_phys_nof_phys_per_core_set;
    data_index = dnx_data_nif_phys_define_nof_pms;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_phys_nof_pms_set;
    data_index = dnx_data_nif_phys_define_vco_div;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_phys_vco_div_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_nif_phys_table_general;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_phys_general_set;
    data_index = dnx_data_nif_phys_table_polarity;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_phys_polarity_set;
    data_index = dnx_data_nif_phys_table_core_phys_map;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_phys_core_phys_map_set;
    /*
     * Attach submodule: ilkn
     */
    submodule_index = dnx_data_nif_submodule_ilkn;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_nif_ilkn_define_ilkn_unit_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_ilkn_unit_nof_set;
    data_index = dnx_data_nif_ilkn_define_ilkn_unit_if_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_ilkn_unit_if_nof_set;
    data_index = dnx_data_nif_ilkn_define_ilkn_if_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_ilkn_if_nof_set;
    data_index = dnx_data_nif_ilkn_define_lanes_max_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_lanes_max_nof_set;
    data_index = dnx_data_nif_ilkn_define_lanes_allowed_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_lanes_allowed_nof_set;
    data_index = dnx_data_nif_ilkn_define_ilkn_over_eth_pms_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_ilkn_over_eth_pms_max_set;
    data_index = dnx_data_nif_ilkn_define_segments_max_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_segments_max_nof_set;
    data_index = dnx_data_nif_ilkn_define_watermark_high;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_watermark_high_set;
    data_index = dnx_data_nif_ilkn_define_watermark_low;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_watermark_low_set;
    data_index = dnx_data_nif_ilkn_define_pms_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_pms_nof_set;
    data_index = dnx_data_nif_ilkn_define_fmac_bus_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_ilkn_fmac_bus_size_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_nif_ilkn_is_supported;
    feature = &submodule->features[data_index];
    feature->set = jer2_a0_dnx_data_nif_ilkn_is_supported_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_nif_ilkn_table_phys;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_ilkn_phys_set;
    data_index = dnx_data_nif_ilkn_table_supported_phys;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_ilkn_supported_phys_set;
    data_index = dnx_data_nif_ilkn_table_supported_core;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_ilkn_supported_core_set;
    data_index = dnx_data_nif_ilkn_table_properties;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_ilkn_properties_set;
    data_index = dnx_data_nif_ilkn_table_nif_pms;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_ilkn_nif_pms_set;
    data_index = dnx_data_nif_ilkn_table_fabric_pms;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_ilkn_fabric_pms_set;
    data_index = dnx_data_nif_ilkn_table_ilkn_pms;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_ilkn_ilkn_pms_set;
    /*
     * Attach submodule: eth
     */
    submodule_index = dnx_data_nif_submodule_eth;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_nif_eth_define_cdu_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_cdu_nof_set;
    data_index = dnx_data_nif_eth_define_cdum_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_cdum_nof_set;
    data_index = dnx_data_nif_eth_define_cdu_pms_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_cdu_pms_nof_set;
    data_index = dnx_data_nif_eth_define_cdu_nof_per_core;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_cdu_nof_per_core_set;
    data_index = dnx_data_nif_eth_define_cdu_lanes_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_cdu_lanes_nof_set;
    data_index = dnx_data_nif_eth_define_cdu_mac_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_cdu_mac_nof_set;
    data_index = dnx_data_nif_eth_define_mac_lanes_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_mac_lanes_nof_set;
    data_index = dnx_data_nif_eth_define_cdu_logical_fifo_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_cdu_logical_fifo_nof_set;
    data_index = dnx_data_nif_eth_define_cdu_memory_entries_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_cdu_memory_entries_nof_set;
    data_index = dnx_data_nif_eth_define_priority_group_nof_entries_min;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_priority_group_nof_entries_min_set;
    data_index = dnx_data_nif_eth_define_priority_groups_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_priority_groups_nof_set;
    data_index = dnx_data_nif_eth_define_pad_size_min;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_pad_size_min_set;
    data_index = dnx_data_nif_eth_define_pad_size_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_pad_size_max_set;
    data_index = dnx_data_nif_eth_define_packet_size_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_packet_size_max_set;
    data_index = dnx_data_nif_eth_define_an_max_nof_abilities;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_eth_an_max_nof_abilities_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_nif_eth_table_pm_properties;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_eth_pm_properties_set;
    data_index = dnx_data_nif_eth_table_cdu_pm_map;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_eth_cdu_pm_map_set;
    data_index = dnx_data_nif_eth_table_max_speed;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_eth_max_speed_set;
    /*
     * Attach submodule: prd
     */
    submodule_index = dnx_data_nif_submodule_prd;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_nif_prd_define_nof_control_frames;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_prd_nof_control_frames_set;
    data_index = dnx_data_nif_prd_define_nof_ether_type_codes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_prd_nof_ether_type_codes_set;
    data_index = dnx_data_nif_prd_define_nof_tcam_entries;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_prd_nof_tcam_entries_set;
    data_index = dnx_data_nif_prd_define_nof_mpls_special_labels;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_prd_nof_mpls_special_labels_set;
    data_index = dnx_data_nif_prd_define_nof_priorities;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_prd_nof_priorities_set;
    data_index = dnx_data_nif_prd_define_custom_ether_type_code_min;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_prd_custom_ether_type_code_min_set;
    data_index = dnx_data_nif_prd_define_custom_ether_type_code_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_prd_custom_ether_type_code_max_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_nif_prd_table_ether_type;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_prd_ether_type_set;
    /*
     * Attach submodule: portmod
     */
    submodule_index = dnx_data_nif_submodule_portmod;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_nif_portmod_define_pm_types_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_portmod_pm_types_nof_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_nif_portmod_table_pm_types_and_interfaces;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_portmod_pm_types_and_interfaces_set;
    data_index = dnx_data_nif_portmod_table_pm_supported_features;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_nif_portmod_pm_supported_features_set;
    /*
     * Attach submodule: schedulder
     */
    submodule_index = dnx_data_nif_submodule_schedulder;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_nif_schedulder_define_rate_per_cdu_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_schedulder_rate_per_cdu_bit_set;
    data_index = dnx_data_nif_schedulder_define_rate_per_rmc_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_schedulder_rate_per_rmc_bit_set;
    data_index = dnx_data_nif_schedulder_define_nof_cdu_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_schedulder_nof_cdu_bits_set;
    data_index = dnx_data_nif_schedulder_define_nof_rmc_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_nif_schedulder_nof_rmc_bits_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
