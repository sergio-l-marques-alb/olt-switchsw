/** \file jer2_a0_data_port.c
 * 
 * DEVICE DATA - PORT
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_PORT
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_port.h>
#include <soc/dnxc/legacy/dnxc_port.h>
#include <bcm/port.h>
#include <bcm/switch.h>
#include <bcm_int/dnx/algo/port/algo_port_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_fabric.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_nif.h>
/*
 * }
 */

/*
 * EXTERN FUNCTIONS:
 * {
 */
/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'general', data - 'fabric_port_base'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [out] fabric_port_base - data already set to default and should be modifeid according to property
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_general_fabric_port_base_read(
    int unit,
    uint32 *fabric_port_base);

/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'static_add', table - 'ucode_port'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [in] port - null
 * \param [out] ucode_port - data type already set to default and should be modified according to property
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_static_add_ucode_port_read(
    int unit,
    int port,
    dnx_data_port_static_add_ucode_port_t *ucode_port);

/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'static_add', table - 'ext_stat_speed'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [in] ext_stat_port - null
 * \param [out] ext_stat_speed - data type already set to default and should be modified according to property
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_static_add_ext_stat_speed_read(
    int unit,
    int ext_stat_port,
    dnx_data_port_static_add_ext_stat_speed_t *ext_stat_speed);

/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'static_add', table - 'serdes_tx_taps'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [in] port - null
 * \param [out] serdes_tx_taps - data type already set to default and should be modified according to property
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_static_add_serdes_tx_taps_read(
    int unit,
    int port,
    dnx_data_port_static_add_serdes_tx_taps_t *serdes_tx_taps);

/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'static_add', table - 'fabric_quad_info'
 * General fabric quad info
 * 
 * \param [in] unit - Unit #
 * \param [in] quad - Quad ID
 * \param [out] quad_enable - data type already set to default and should be modified according to property
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_static_add_fabric_quad_info_quad_enable_read(
    int unit,
    int quad,
    int *quad_enable);

/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'static_add', table - 'erp_exist'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [in] core - null
 * \param [out] erp_exist - data type already set to default and should be modified according to property
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_static_add_erp_exist_read(
    int unit,
    int core,
    dnx_data_port_static_add_erp_exist_t *erp_exist);

/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'static_add', data - 'fabric_fw_load_method'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [out] fabric_fw_load_method - data already set to default and should be modifeid according to property
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_static_add_fabric_fw_load_method_read(
    int unit,
    uint32 *fabric_fw_load_method);

/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'static_add', data - 'fabric_fw_load_verify'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [out] fabric_fw_load_verify - data already set to default and should be modifeid according to property
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_static_add_fabric_fw_load_verify_read(
    int unit,
    uint32 *fabric_fw_load_verify);

/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'port', Submodule - 'static_add', data - 'nif_fw_load_method'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [out] nif_fw_load_method - data already set to default and should be modifeid according to property
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_port_static_add_nif_fw_load_method_read(
    int unit,
    uint32 *nif_fw_load_method);

/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: static_add
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define default_speed_for_special_if
 * define info:
 * default speed in kbps for special interfaces (tm ports excluding NIF)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_default_speed_for_special_if_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int define_index = dnx_data_port_static_add_define_default_speed_for_special_if;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 10000;

    /* Set value */
    define->data = 10000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Init only data */
    define->flags |= DNXC_DATA_F_INIT_ONLY;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric fabric_fw_load_method
 * numeric info:
 * Method of the Fabric firmware load
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_fabric_fw_load_method_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int define_index = dnx_data_port_static_add_define_fabric_fw_load_method;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = phymodFirmwareLoadMethodExternal;

    /* Set value */
    define->data = phymodFirmwareLoadMethodExternal;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "load_firmware_fabric";
    define->property.doc = 
        "\n"
        "0x<verify FW><load method>\n"
        "The method of the firmware load (first hexadecimal charcter).\n"
        "2 - fast; 1 - MDIO load; 0 - do not load firmware\n"
        "Verify FW (first hexadecimal charcter).\n"
        "1 - enables firmware CRC verfication\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_custom;
    define->property.method_str = "custom";
    SHR_IF_ERR_EXIT(dnx_data_property_port_static_add_fabric_fw_load_method_read(unit, (uint32 *) &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric fabric_fw_load_verify
 * numeric info:
 * Fabric firmware load verification method
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_fabric_fw_load_verify_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int define_index = dnx_data_port_static_add_define_fabric_fw_load_verify;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "load_firmware_fabric";
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_custom;
    define->property.method_str = "custom";
    SHR_IF_ERR_EXIT(dnx_data_property_port_static_add_fabric_fw_load_verify_read(unit, (uint32 *) &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nif_fw_load_method
 * numeric info:
 * Method of the Nif firmware load
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_nif_fw_load_method_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int define_index = dnx_data_port_static_add_define_nif_fw_load_method;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = phymodFirmwareLoadMethodExternal;

    /* Set value */
    define->data = phymodFirmwareLoadMethodExternal;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "load_firmware_nif";
    define->property.doc = 
        "\n"
        "0x<verify FW><load method>\n"
        "The method of the firmware load (first hexadecimal charcter).\n"
        "2 - fast; 1 - MDIO load; 0 - do not load firmware\n"
        "Verify FW (first hexadecimal charcter).\n"
        "1 - enables firmware CRC verfication\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_custom;
    define->property.method_str = "custom";
    SHR_IF_ERR_EXIT(dnx_data_property_port_static_add_nif_fw_load_method_read(unit, (uint32 *) &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table ucode_port
 * Module - 'port', Submodule - 'static_add', table - 'ucode_port'
 * static port configuration
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_ucode_port_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_ucode_port_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_ucode_port;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "BCM_PORT_IF_NULL";
    table->values[1].default_val = "0";
    table->values[2].default_val = "-1";
    table->values[3].default_val = "-1";
    table->values[4].default_val = "-1";
    table->values[5].default_val = "-1";
    table->values[6].default_val = "0";
    table->values[7].default_val = "0";
    table->values[8].default_val = "DNX_ALGO_PORT_TDM_MODE_NONE";
    table->values[9].default_val = "2";
    table->values[10].default_val = "-1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_ucode_port_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_ucode_port");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_ucode_port_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->interface = BCM_PORT_IF_NULL;
    default_data->nof_lanes = 0;
    default_data->interface_offset = -1;
    default_data->core = -1;
    default_data->tm_port = -1;
    default_data->channel = -1;
    default_data->is_stif = 0;
    default_data->is_kbp = 0;
    default_data->tdm_mode = DNX_ALGO_PORT_TDM_MODE_NONE;
    default_data->num_priorities = 2;
    default_data->base_q_pair = -1;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_ucode_port_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Property
     */
    table->property.name = "ucode_port, port_priorities, otm_base_q_pair";
    table->property.doc =
        "\n"
        "1.\n"
        "To map a physical interface and channel to a local logical port and to a core ID and TM port in the core, use the SOC property:\n"
        "ucode_port_#logical_port_num# = #interface_type##interface_id#[.#channel_num#]:core#core-id#.#tm-port#[:#stat#], where:\n"
        "*    logical_port_num is the logical port index.\n"
        "*    interface_type is the Physical Interface type.\n"
        "*    interface_id is the index of the specific physical interface, if applicable.\n"
        "*    channel_num is the channel number within the physical interface, if applicable (relevant for channelized interfaces).\n"
        "*    core-id is the core index, 0 or 1.\n"
        "*    tm-port is the TM port of the core, in range 0-254 (255 is reserved for ERP).\n"
        "*    stat - add ':stat' to use this logical port as statistics interface (see Statistics Interface section for further details)\n"
        "*    kbp - add ':kbp' to use this logical port as KBP\n"
        "Example: ucode_port_5 = ILKN1.35:core0.2 maps logical port 5 to Interlaken interface number 1 on channel 35, and to core 0 TM port 2.\n"
        "\n"
        "2.\n"
        "To determine the number of OTM queue-pairs for a port, use the following SOC property:\n"
        "port_priorities#port# = 1/2/8.\n"
        "\n"
        "3.\n"
        "Usually queue pairs are automatically allocated for each port.\n"
        "A user can choose to manage the queues explicitly by using the SOC property otm_base_q_pair_#port#=0-254\n"
        "('255' value is reserved and cannot be used).\n"
        "This can be useful for example when dynamic port provisioning is required, to optimize queue pair allocation for the more challenging scenario\n"
        "\n"
        "\n"
    ;
    table->property.method = dnxc_data_property_method_custom;
    table->property.method_str = "custom";
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_ucode_port_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnx_data_property_port_static_add_ucode_port_read(unit, port_index, data));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table speed
 * Module - 'port', Submodule - 'static_add', table - 'speed'
 * per port speed
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_speed_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_speed_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_speed;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "DNXC_PORT_INVALID_SPEED";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_speed_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_speed");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->val = DNXC_PORT_INVALID_SPEED;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - val
     */
    table->values[0].property.name = spn_PORT_INIT_SPEED;
    table->values[0].property.doc =
        "\n"
        "The default port rate is decided according to interface type.\n"
        "To set different port rate (mbps) use:\n"
        "port_init_speed_<port>=#speed#\n"
        "A list of supported rates per interface type can be found in User Manual.\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_port_range_signed;
    table->values[0].property.method_str = "port_range_signed";
    table->values[0].property.range_min = -1;
    table->values[0].property.range_max = 4000000;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, port_index, &data->val));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table ext_stat_speed
 * Module - 'port', Submodule - 'static_add', table - 'ext_stat_speed'
 * per external kbp stat port speed
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_ext_stat_speed_set(
    int unit)
{
    int ext_stat_port_index;
    dnx_data_port_static_add_ext_stat_speed_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_ext_stat_speed;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 4;
    table->info_get.key_size[0] = 4;

    /* Info - default values */
    table->values[0].default_val = "DNXC_PORT_INVALID_SPEED";
    table->values[1].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_ext_stat_speed_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_ext_stat_speed");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_ext_stat_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->speed = DNXC_PORT_INVALID_SPEED;
    default_data->nof_lanes = 0;
    /* Set Default Values */
    for (ext_stat_port_index = 0; ext_stat_port_index < table->keys[0].size; ext_stat_port_index++)
    {
        data = (dnx_data_port_static_add_ext_stat_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, ext_stat_port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Property
     */
    table->property.name = "port_init_speed";
    table->property.doc =
        "\n"
        "ext_stat_speed configure the speed of the external device (kbp) statistic port.\n"
        "The default port rate is invalid. meaning the external kbp port does not exist.\n"
        "In addition, it also determine how many lanes the port has.\n"
        "Use the Soc property ext_stat_speed with suffix ext_stat in order to configure it.\n"
        "Syntax:\n"
        "port_init_speed_ext_stat[ext_stat_port_id]=[speed_MHz].[nof_lanes]lanes\n"
        "Examples:\n"
        "1. port_init_speed_ext_stat0=200000.4lanes - ext stat port_id=0, speed=200GHz, 4 lanes.\n"
        "2. port_init_speed_ext_stat2=100000.2lanes - ext stat port_id=2, speed=100GHz, 2 lanes.\n"
        "\n"
    ;
    table->property.method = dnxc_data_property_method_custom;
    table->property.method_str = "custom";
    for (ext_stat_port_index = 0; ext_stat_port_index < table->keys[0].size; ext_stat_port_index++)
    {
        data = (dnx_data_port_static_add_ext_stat_speed_t *) dnxc_data_mgmt_table_data_get(unit, table, ext_stat_port_index, 0);
        SHR_IF_ERR_EXIT(dnx_data_property_port_static_add_ext_stat_speed_read(unit, ext_stat_port_index, data));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table eth_padding
 * Module - 'port', Submodule - 'static_add', table - 'eth_padding'
 * eth ports padding
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_eth_padding_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_eth_padding_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_eth_padding;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_eth_padding_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_eth_padding");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_eth_padding_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->pad_size = 0;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_eth_padding_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - pad_size
     */
    table->values[0].property.name = spn_PACKET_PADDING_SIZE;
    table->values[0].property.doc =
        "\n"
        "Configure padding size per eth port (min 64 max 96)\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_port_range_signed;
    table->values[0].property.method_str = "port_range_signed";
    table->values[0].property.range_min = -1;
    table->values[0].property.range_max = 96;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_eth_padding_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, port_index, &data->pad_size));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table link_training
 * Module - 'port', Submodule - 'static_add', table - 'link_training'
 * per port link training (CL72)
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_link_training_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_link_training_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_link_training;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "BCM_PORT_RESOURCE_DEFAULT_REQUEST";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_link_training_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_link_training");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_link_training_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->val = BCM_PORT_RESOURCE_DEFAULT_REQUEST;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_link_training_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - val
     */
    table->values[0].property.name = spn_PORT_INIT_CL72;
    table->values[0].property.doc =
        "\n"
        "Enable /Disable CL72\n"
        "port_init_cl72_<port> = 1 / 0\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_port_enable;
    table->values[0].property.method_str = "port_enable";
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_link_training_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, port_index, &data->val));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table ext_stat_link_training
 * Module - 'port', Submodule - 'static_add', table - 'ext_stat_link_training'
 * per external kbp stat port link training (CL72)
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_ext_stat_link_training_set(
    int unit)
{
    int ext_stat_port_index;
    dnx_data_port_static_add_ext_stat_link_training_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_ext_stat_link_training;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 4;
    table->info_get.key_size[0] = 4;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_ext_stat_link_training_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_ext_stat_link_training");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_ext_stat_link_training_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->val = 0;
    /* Set Default Values */
    for (ext_stat_port_index = 0; ext_stat_port_index < table->keys[0].size; ext_stat_port_index++)
    {
        data = (dnx_data_port_static_add_ext_stat_link_training_t *) dnxc_data_mgmt_table_data_get(unit, table, ext_stat_port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - val
     */
    table->values[0].property.name = spn_PORT_INIT_CL72;
    table->values[0].property.doc =
        "\n"
        "Enable /Disable link training (CL72) for external device (kbp) statistic port.\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_suffix_enable;
    table->values[0].property.method_str = "suffix_enable";
    table->values[0].property.suffix = "ext_stat";
    for (ext_stat_port_index = 0; ext_stat_port_index < table->keys[0].size; ext_stat_port_index++)
    {
        data = (dnx_data_port_static_add_ext_stat_link_training_t *) dnxc_data_mgmt_table_data_get(unit, table, ext_stat_port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, ext_stat_port_index, &data->val));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table fec_type
 * Module - 'port', Submodule - 'static_add', table - 'fec_type'
 * per port FEC type
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_fec_type_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_fec_type_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_fec_type;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "BCM_PORT_RESOURCE_DEFAULT_REQUEST";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_fec_type_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_fec_type");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_fec_type_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->val = BCM_PORT_RESOURCE_DEFAULT_REQUEST;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_fec_type_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - val
     */
    table->values[0].property.name = spn_PORT_FEC;
    table->values[0].property.doc =
        "\n"
        "Specifies the FEC type. The types are as follows:\n"
        "0 - no FEC\n"
        "1 - BASE R - 64/66b KR FEC\n"
        "2 - CL91/RS-FEC\n"
        "3 - Rs544, using 1xN RS FEC architecture\n"
        "4 - RS 272, using 1xN RS FEC architecture\n"
        "5 - RS 206 - 64/66b 5T RS FEC\n"
        "6 - RS 108 - 64/66b 5T low latency RS FEC\n"
        "7 - RS 545 - 64/66b 15T RS FEC\n"
        "8 - RS 304 - 64/66b 15T low latency RS FEC\n"
        "9 - Rs544, using 2xN RS FEC architecture\n"
        "10 - Rs272, using 2xN RS FEC architecture\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_port_direct_map;
    table->values[0].property.method_str = "port_direct_map";
    table->values[0].property.nof_mapping = 11;
    DNXC_DATA_ALLOC(table->values[0].property.mapping, dnxc_data_property_map_t, table->values[0].property.nof_mapping, "dnx_data_port_static_add_fec_type_t property mapping");

    table->values[0].property.mapping[0].name = "0";
    table->values[0].property.mapping[0].val = bcmPortPhyFecNone;
    table->values[0].property.mapping[1].name = "1";
    table->values[0].property.mapping[1].val = bcmPortPhyFecBaseR;
    table->values[0].property.mapping[2].name = "2";
    table->values[0].property.mapping[2].val = bcmPortPhyFecRsFec;
    table->values[0].property.mapping[3].name = "3";
    table->values[0].property.mapping[3].val = bcmPortPhyFecRs544;
    table->values[0].property.mapping[4].name = "4";
    table->values[0].property.mapping[4].val = bcmPortPhyFecRs272;
    table->values[0].property.mapping[5].name = "5";
    table->values[0].property.mapping[5].val = bcmPortPhyFecRs206;
    table->values[0].property.mapping[6].name = "6";
    table->values[0].property.mapping[6].val = bcmPortPhyFecRs108;
    table->values[0].property.mapping[7].name = "7";
    table->values[0].property.mapping[7].val = bcmPortPhyFecRs545;
    table->values[0].property.mapping[8].name = "8";
    table->values[0].property.mapping[8].val = bcmPortPhyFecRs304;
    table->values[0].property.mapping[9].name = "9";
    table->values[0].property.mapping[9].val = bcmPortPhyFecRs544_2xN;
    table->values[0].property.mapping[10].name = "10";
    table->values[0].property.mapping[10].val = bcmPortPhyFecRs272_2xN;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_fec_type_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, port_index, &data->val));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table serdes_lane_config
 * Module - 'port', Submodule - 'static_add', table - 'serdes_lane_config'
 * serdes lane configurations, related to firmware
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_serdes_lane_config_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_serdes_lane_config_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_serdes_lane_config;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL";
    table->values[1].default_val = "DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL";
    table->values[2].default_val = "DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL";
    table->values[3].default_val = "DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL";
    table->values[4].default_val = "DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL";
    table->values[5].default_val = "DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_serdes_lane_config_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_serdes_lane_config");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->dfe = DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL;
    default_data->media_type = DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL;
    default_data->unreliable_los = DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL;
    default_data->cl72_auto_polarity_enable = DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL;
    default_data->cl72_restart_timeout_enable = DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL;
    default_data->channel_mode = DNXC_PORT_SERDES_LANE_CONFIG_INVALID_VAL;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - dfe
     */
    table->values[0].property.name = spn_SERDES_LANE_CONFIG;
    table->values[0].property.doc =
        "\n"
        "DFE filter\n"
        "serdes_lane_config_dfe_<port>=on|off|lp\n"
        "on - dfe is on and lp dfe is off\n"
        "off - both dfe and lp dfe are off\n"
        "lp - both dfe and lp dfe are on\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_port_suffix_direct_map;
    table->values[0].property.method_str = "port_suffix_direct_map";
    table->values[0].property.suffix = "dfe";
    table->values[0].property.nof_mapping = 3;
    DNXC_DATA_ALLOC(table->values[0].property.mapping, dnxc_data_property_map_t, table->values[0].property.nof_mapping, "dnx_data_port_static_add_serdes_lane_config_t property mapping");

    table->values[0].property.mapping[0].name = "on";
    table->values[0].property.mapping[0].val = soc_dnxc_port_dfe_on;
    table->values[0].property.mapping[1].name = "off";
    table->values[0].property.mapping[1].val = soc_dnxc_port_dfe_off;
    table->values[0].property.mapping[2].name = "lp";
    table->values[0].property.mapping[2].val = soc_dnxc_port_lp_dfe;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, port_index, &data->dfe));
    }
    /*
     * Value Property - media_type
     */
    table->values[1].property.name = spn_SERDES_LANE_CONFIG;
    table->values[1].property.doc =
        "\n"
        "media type\n"
        "serdes_lane_config_media_type_<port>=backplane|copper|optics\n"
        "\n"
    ;
    table->values[1].property.method = dnxc_data_property_method_port_suffix_direct_map;
    table->values[1].property.method_str = "port_suffix_direct_map";
    table->values[1].property.suffix = "media_type";
    table->values[1].property.nof_mapping = 3;
    DNXC_DATA_ALLOC(table->values[1].property.mapping, dnxc_data_property_map_t, table->values[1].property.nof_mapping, "dnx_data_port_static_add_serdes_lane_config_t property mapping");

    table->values[1].property.mapping[0].name = "backplane";
    table->values[1].property.mapping[0].val = BCM_PORT_RESOURCE_PHY_LANE_CONFIG_MEDIUM_BACKPLANE;
    table->values[1].property.mapping[1].name = "copper";
    table->values[1].property.mapping[1].val = BCM_PORT_RESOURCE_PHY_LANE_CONFIG_MEDIUM_COPPER_CABLE;
    table->values[1].property.mapping[2].name = "optics";
    table->values[1].property.mapping[2].val = BCM_PORT_RESOURCE_PHY_LANE_CONFIG_MEDIUM_OPTICS;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[1].property, port_index, &data->media_type));
    }
    /*
     * Value Property - unreliable_los
     */
    table->values[2].property.name = spn_SERDES_LANE_CONFIG;
    table->values[2].property.doc =
        "\n"
        "unreliable los\n"
        "serdes_lane_config_unreliable_los_<port>=0|1\n"
        "\n"
    ;
    table->values[2].property.method = dnxc_data_property_method_port_suffix_enable;
    table->values[2].property.method_str = "port_suffix_enable";
    table->values[2].property.suffix = "unreliable_los";
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[2].property, port_index, &data->unreliable_los));
    }
    /*
     * Value Property - cl72_auto_polarity_enable
     */
    table->values[3].property.name = spn_SERDES_LANE_CONFIG;
    table->values[3].property.doc =
        "\n"
        "enable cl72 auto polarity\n"
        "serdes_lane_config_cl72_auto_polarity_en_<port>=0|1\n"
        "\n"
    ;
    table->values[3].property.method = dnxc_data_property_method_port_suffix_enable;
    table->values[3].property.method_str = "port_suffix_enable";
    table->values[3].property.suffix = "cl72_auto_polarity_en";
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[3].property, port_index, &data->cl72_auto_polarity_enable));
    }
    /*
     * Value Property - cl72_restart_timeout_enable
     */
    table->values[4].property.name = spn_SERDES_LANE_CONFIG;
    table->values[4].property.doc =
        "\n"
        "enable cl72 restart timeout\n"
        "serdes_lane_config_cl72_restart_timeout_en_<port>=0|1\n"
        "\n"
    ;
    table->values[4].property.method = dnxc_data_property_method_port_suffix_enable;
    table->values[4].property.method_str = "port_suffix_enable";
    table->values[4].property.suffix = "cl72_restart_timeout_en";
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[4].property, port_index, &data->cl72_restart_timeout_enable));
    }
    /*
     * Value Property - channel_mode
     */
    table->values[5].property.name = spn_SERDES_LANE_CONFIG;
    table->values[5].property.doc =
        "\n"
        "channel mode\n"
        "serdes_lane_config_channel_mode_<port>=force_nr|force_er\n"
        "\n"
    ;
    table->values[5].property.method = dnxc_data_property_method_port_suffix_direct_map;
    table->values[5].property.method_str = "port_suffix_direct_map";
    table->values[5].property.suffix = "channel_mode";
    table->values[5].property.nof_mapping = 2;
    DNXC_DATA_ALLOC(table->values[5].property.mapping, dnxc_data_property_map_t, table->values[5].property.nof_mapping, "dnx_data_port_static_add_serdes_lane_config_t property mapping");

    table->values[5].property.mapping[0].name = "force_nr";
    table->values[5].property.mapping[0].val = soc_dnxc_port_force_nr;
    table->values[5].property.mapping[1].name = "force_er";
    table->values[5].property.mapping[1].val = soc_dnxc_port_force_er;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[5].property, port_index, &data->channel_mode));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table serdes_tx_taps
 * Module - 'port', Submodule - 'static_add', table - 'serdes_tx_taps'
 * PHY TX tap configuration
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_serdes_tx_taps_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_serdes_tx_taps_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_serdes_tx_taps;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "DNXC_PORT_TX_FIR_INVALID_MAIN_TAP";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "0";
    table->values[5].default_val = "0";
    table->values[6].default_val = "bcmPortPhyTxTapMode3Tap";
    table->values[7].default_val = "bcmPortPhySignallingModeNRZ";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_serdes_tx_taps_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_serdes_tx_taps");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_serdes_tx_taps_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->pre = 0;
    default_data->main = DNXC_PORT_TX_FIR_INVALID_MAIN_TAP;
    default_data->post = 0;
    default_data->pre2 = 0;
    default_data->post2 = 0;
    default_data->post3 = 0;
    default_data->tx_tap_mode = bcmPortPhyTxTapMode3Tap;
    default_data->signalling_mode = bcmPortPhySignallingModeNRZ;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_tx_taps_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Property
     */
    table->property.name = "serdes_tx_taps";
    table->property.doc =
        "\n"
        "a set of TX FIR parameters for the port.\n"
        "serdes_tx_taps_<port>=signalling_mode:pre:main:post:pre2:post2:post3\n"
        "signalling_mode can be either pam4 or nrz.\n"
        "[pre2:post2:post3] part is optional:\n"
        "- if it is given - this it 6-tap mode.\n"
        "- if it is not given - this is 3-tap mode.\n"
        "main is set to DNXC_PORT_TX_FIR_INVALID_MAIN_TAP by default to distinguish between whether the SoC property was set or not.\n"
        "\n"
    ;
    table->property.method = dnxc_data_property_method_custom;
    table->property.method_str = "custom";
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_serdes_tx_taps_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnx_data_property_port_static_add_serdes_tx_taps_read(unit, port_index, data));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table tx_pam4_precoder
 * Module - 'port', Submodule - 'static_add', table - 'tx_pam4_precoder'
 * is the precoding enabled on TX side
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_tx_pam4_precoder_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_tx_pam4_precoder_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_tx_pam4_precoder;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_tx_pam4_precoder_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_tx_pam4_precoder");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_tx_pam4_precoder_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->val = 0;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_tx_pam4_precoder_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - val
     */
    table->values[0].property.name = spn_PORT_TX_PAM4_PRECODER;
    table->values[0].property.doc =
        "\n"
        "is the precoding enabled on TX side.\n"
        "port_tx_pam4_precoder_<port>=enable/disable\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_port_direct_map;
    table->values[0].property.method_str = "port_direct_map";
    table->values[0].property.nof_mapping = 2;
    DNXC_DATA_ALLOC(table->values[0].property.mapping, dnxc_data_property_map_t, table->values[0].property.nof_mapping, "dnx_data_port_static_add_tx_pam4_precoder_t property mapping");

    table->values[0].property.mapping[0].name = "enable";
    table->values[0].property.mapping[0].val = 1;
    table->values[0].property.mapping[1].name = "disable";
    table->values[0].property.mapping[1].val = 0;
    table->values[0].property.mapping[1].is_default = 1 ;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_tx_pam4_precoder_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, port_index, &data->val));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table lp_tx_precoder
 * Module - 'port', Submodule - 'static_add', table - 'lp_tx_precoder'
 * has the link partner enabled pre-coding on its TX side. In other words - enable the decoding on my RX side.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_lp_tx_precoder_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_lp_tx_precoder_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_lp_tx_precoder;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_lp_tx_precoder_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_lp_tx_precoder");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_lp_tx_precoder_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->val = 0;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_lp_tx_precoder_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - val
     */
    table->values[0].property.name = spn_PORT_LP_TX_PRECODER;
    table->values[0].property.doc =
        "\n"
        "has the link partner enabled pre-coding on its TX side.\n"
        "in other words - enable the decoding on my RX side.\n"
        "port_lp_tx_precoder_<port>=enable/disable\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_port_direct_map;
    table->values[0].property.method_str = "port_direct_map";
    table->values[0].property.nof_mapping = 2;
    DNXC_DATA_ALLOC(table->values[0].property.mapping, dnxc_data_property_map_t, table->values[0].property.nof_mapping, "dnx_data_port_static_add_lp_tx_precoder_t property mapping");

    table->values[0].property.mapping[0].name = "enable";
    table->values[0].property.mapping[0].val = 1;
    table->values[0].property.mapping[1].name = "disable";
    table->values[0].property.mapping[1].val = 0;
    table->values[0].property.mapping[1].is_default = 1 ;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_lp_tx_precoder_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, port_index, &data->val));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table fabric_quad_info
 * Module - 'port', Submodule - 'static_add', table - 'fabric_quad_info'
 * General fabric quad info
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_fabric_quad_info_set(
    int unit)
{
    int quad_index;
    dnx_data_port_static_add_fabric_quad_info_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_fabric_quad_info;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /* Init only data */
    table->flags |= DNXC_DATA_F_INIT_ONLY;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_fabric.links.nof_links_get(unit) / dnx_data_fabric.blocks.nof_links_in_fmac_get(unit);
    table->info_get.key_size[0] = dnx_data_fabric.links.nof_links_get(unit) / dnx_data_fabric.blocks.nof_links_in_fmac_get(unit);

    /* Info - default values */
    table->values[0].default_val = "1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_fabric_quad_info_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_fabric_quad_info");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_fabric_quad_info_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->quad_enable = 1;
    /* Set Default Values */
    for (quad_index = 0; quad_index < table->keys[0].size; quad_index++)
    {
        data = (dnx_data_port_static_add_fabric_quad_info_t *) dnxc_data_mgmt_table_data_get(unit, table, quad_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - quad_enable
     */
    table->values[0].property.name = "serdes_qrtt_active";
    table->values[0].property.doc =
        "\n"
        "Enable / Disable Quad.\n"
        "serdes_qrtt_active_<quad_number>=1/0\n"
        "If there is no quad_number suffix, the enable/disable will be done for all quads.\n"
        "Default - all quads are enabled.\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_custom;
    table->values[0].property.method_str = "custom";
    for (quad_index = 0; quad_index < table->keys[0].size; quad_index++)
    {
        data = (dnx_data_port_static_add_fabric_quad_info_t *) dnxc_data_mgmt_table_data_get(unit, table, quad_index, 0);
        SHR_IF_ERR_EXIT(dnx_data_property_port_static_add_fabric_quad_info_quad_enable_read(unit, quad_index, &data->quad_enable));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table header_type
 * Module - 'port', Submodule - 'static_add', table - 'header_type'
 * header type information
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_header_type_set(
    int unit)
{
    int port_index;
    dnx_data_port_static_add_header_type_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_header_type;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = SOC_MAX_NUM_PORTS;
    table->info_get.key_size[0] = SOC_MAX_NUM_PORTS;

    /* Info - default values */
    table->values[0].default_val = "BCM_SWITCH_PORT_HEADER_TYPE_ETH";
    table->values[1].default_val = "BCM_SWITCH_PORT_HEADER_TYPE_ETH";
    table->values[2].default_val = "BCM_SWITCH_PORT_HEADER_TYPE_ETH";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_header_type_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_header_type");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_header_type_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->header_type_in = BCM_SWITCH_PORT_HEADER_TYPE_ETH;
    default_data->header_type_out = BCM_SWITCH_PORT_HEADER_TYPE_ETH;
    default_data->header_type = BCM_SWITCH_PORT_HEADER_TYPE_ETH;
    /* Set Default Values */
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_header_type_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - header_type_in
     */
    table->values[0].property.name = spn_TM_PORT_HEADER_TYPE;
    table->values[0].property.doc =
        "\n"
        "Header type per incoming port.\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_port_suffix_direct_map;
    table->values[0].property.method_str = "port_suffix_direct_map";
    table->values[0].property.suffix = "in";
    table->values[0].property.nof_mapping = 6;
    DNXC_DATA_ALLOC(table->values[0].property.mapping, dnxc_data_property_map_t, table->values[0].property.nof_mapping, "dnx_data_port_static_add_header_type_t property mapping");

    table->values[0].property.mapping[0].name = "ETH";
    table->values[0].property.mapping[0].val = BCM_SWITCH_PORT_HEADER_TYPE_ETH;
    table->values[0].property.mapping[0].is_default = 1 ;
    table->values[0].property.mapping[1].name = "RAW";
    table->values[0].property.mapping[1].val = BCM_SWITCH_PORT_HEADER_TYPE_RAW;
    table->values[0].property.mapping[2].name = "INJECTED_2_PP";
    table->values[0].property.mapping[2].val = BCM_SWITCH_PORT_HEADER_TYPE_INJECTED_2_PP;
    table->values[0].property.mapping[3].name = "INJECTED_2_PP_JR1_MODE";
    table->values[0].property.mapping[3].val = BCM_SWITCH_PORT_HEADER_TYPE_INJECTED_2_PP_JR1_MODE;
    table->values[0].property.mapping[4].name = "INJECTED_2";
    table->values[0].property.mapping[4].val = BCM_SWITCH_PORT_HEADER_TYPE_INJECTED_2;
    table->values[0].property.mapping[5].name = "INJECTED_2_JR1_MODE";
    table->values[0].property.mapping[5].val = BCM_SWITCH_PORT_HEADER_TYPE_INJECTED_2_JR1_MODE;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_header_type_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, port_index, &data->header_type_in));
    }
    /*
     * Value Property - header_type_out
     */
    table->values[1].property.name = spn_TM_PORT_HEADER_TYPE;
    table->values[1].property.doc =
        "\n"
        "Header type per outgoing port.\n"
        "\n"
    ;
    table->values[1].property.method = dnxc_data_property_method_port_suffix_direct_map;
    table->values[1].property.method_str = "port_suffix_direct_map";
    table->values[1].property.suffix = "out";
    table->values[1].property.nof_mapping = 4;
    DNXC_DATA_ALLOC(table->values[1].property.mapping, dnxc_data_property_map_t, table->values[1].property.nof_mapping, "dnx_data_port_static_add_header_type_t property mapping");

    table->values[1].property.mapping[0].name = "ETH";
    table->values[1].property.mapping[0].val = BCM_SWITCH_PORT_HEADER_TYPE_ETH;
    table->values[1].property.mapping[0].is_default = 1 ;
    table->values[1].property.mapping[1].name = "RAW";
    table->values[1].property.mapping[1].val = BCM_SWITCH_PORT_HEADER_TYPE_RAW;
    table->values[1].property.mapping[2].name = "CPU";
    table->values[1].property.mapping[2].val = BCM_SWITCH_PORT_HEADER_TYPE_CPU;
    table->values[1].property.mapping[3].name = "ENCAP_EXTERNAL_CPU";
    table->values[1].property.mapping[3].val = BCM_SWITCH_PORT_HEADER_TYPE_ENCAP_EXTERNAL_CPU;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_header_type_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[1].property, port_index, &data->header_type_out));
    }
    /*
     * Value Property - header_type
     */
    table->values[2].property.name = spn_TM_PORT_HEADER_TYPE;
    table->values[2].property.doc =
        "\n"
        "Header type per port.\n"
        "\n"
    ;
    table->values[2].property.method = dnxc_data_property_method_port_direct_map;
    table->values[2].property.method_str = "port_direct_map";
    table->values[2].property.nof_mapping = 2;
    DNXC_DATA_ALLOC(table->values[2].property.mapping, dnxc_data_property_map_t, table->values[2].property.nof_mapping, "dnx_data_port_static_add_header_type_t property mapping");

    table->values[2].property.mapping[0].name = "ETH";
    table->values[2].property.mapping[0].val = BCM_SWITCH_PORT_HEADER_TYPE_ETH;
    table->values[2].property.mapping[0].is_default = 1 ;
    table->values[2].property.mapping[1].name = "RAW";
    table->values[2].property.mapping[1].val = BCM_SWITCH_PORT_HEADER_TYPE_RAW;
    for (port_index = 0; port_index < table->keys[0].size; port_index++)
    {
        data = (dnx_data_port_static_add_header_type_t *) dnxc_data_mgmt_table_data_get(unit, table, port_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[2].property, port_index, &data->header_type));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table erp_exist
 * Module - 'port', Submodule - 'static_add', table - 'erp_exist'
 * Is ERP port defined in config file for the core
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_static_add_erp_exist_set(
    int unit)
{
    int core_index;
    dnx_data_port_static_add_erp_exist_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_static_add;
    int table_index = dnx_data_port_static_add_table_erp_exist;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_device.general.nof_cores_get(unit);
    table->info_get.key_size[0] = dnx_data_device.general.nof_cores_get(unit);

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_port_static_add_erp_exist_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_port_static_add_table_erp_exist");

    /* Store Default Values */
    default_data = (dnx_data_port_static_add_erp_exist_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->exist = 0;
    /* Set Default Values */
    for (core_index = 0; core_index < table->keys[0].size; core_index++)
    {
        data = (dnx_data_port_static_add_erp_exist_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Property
     */
    table->property.name = "ucode_port";
    table->property.doc =
        "\n"
        "Is ERP port defined in config file per core\n"
        "\n"
    ;
    table->property.method = dnxc_data_property_method_custom;
    table->property.method_str = "custom";
    for (core_index = 0; core_index < table->keys[0].size; core_index++)
    {
        data = (dnx_data_port_static_add_erp_exist_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index, 0);
        SHR_IF_ERR_EXIT(dnx_data_property_port_static_add_erp_exist_read(unit, core_index, data));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: general
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_tm_ports
 * define info:
 * nof tm ports per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_nof_tm_ports_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_nof_tm_ports;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define erp_tm_port
 * define info:
 * tm port reserved for ERP
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_erp_tm_port_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_erp_tm_port;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 255;

    /* Set value */
    define->data = 255;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define reserved_tm_port
 * define info:
 * tm port reserved for redirection of returned credits in LAG SCH
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_reserved_tm_port_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_reserved_tm_port;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 254;

    /* Set value */
    define->data = 254;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_pp_ports
 * define info:
 * nof pp ports per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_nof_pp_ports_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_nof_pp_ports;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_pms
 * define info:
 * Number of port macros overall in the system
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_nof_pms_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_nof_pms;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 28;

    /* Set value */
    define->data = 28;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_nof_channels
 * define info:
 * max nof channel in an interface
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_max_nof_channels_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_max_nof_channels;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fabric_phys_offset
 * define info:
 * Offset for physical fabric ports
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_fabric_phys_offset_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_fabric_phys_offset;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_nif.phys.nof_phys_get(unit);

    /* Set value */
    define->data = dnx_data_nif.phys.nof_phys_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tm_port_size
 * define info:
 * define the size of the tm port (in bits)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_tm_port_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_tm_port_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define pp_port_size
 * define info:
 * define the size of the pp port (in bits)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_pp_port_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_pp_port_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define pp_dsp_size
 * define info:
 * define the size of the pp dsp (in bits)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_pp_dsp_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_pp_dsp_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define vlan_domain_size
 * define info:
 * define the size of the vlan domain (in bits)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_vlan_domain_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_vlan_domain_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 9;

    /* Set value */
    define->data = 9;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_vlan_membership_if
 * define info:
 * number of vlan_membership_if
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_nof_vlan_membership_if_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_nof_vlan_membership_if;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 512;

    /* Set value */
    define->data = 512;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_instruction_size
 * define info:
 * define the size of the ffc instruction (in bits)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_ffc_instruction_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_ffc_instruction_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric fabric_port_base
 * numeric info:
 * first fabric logical port
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_fabric_port_base_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_fabric_port_base;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "fabric_logical_port_base";
    define->property.doc = 
        "\n"
        "By default fabric logical ports are 256..(256 + nof links)\n"
        "To extend the logical_port_num range so that ports in range 0...511 can be used, use the following SOC property: fabric_logical_port_base=512.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_custom;
    define->property.method_str = "custom";
    SHR_IF_ERR_EXIT(dnx_data_property_port_general_fabric_port_base_read(unit, (uint32 *) &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric dynamic_port_enable
 * numeric info:
 * dynamic port
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_general_dynamic_port_enable_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_general;
    int define_index = dnx_data_port_general_define_dynamic_port_enable;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_CUSTOM_FEATURE;
    define->property.doc = 
        "\n"
        "Enable dynamic port feature\n"
        "In Jericho2 dynamic port must be enabled\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "dynamic_port";
    define->property.range_min = 1;
    define->property.range_max = 1;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: egress
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_ifs
 * define info:
 * nof egress intrfaces per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_port_egress_nof_ifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_port;
    int submodule_index = dnx_data_port_submodule_egress;
    int define_index = dnx_data_port_egress_define_nof_ifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jer2_a0_data_port_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_port;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: static_add
     */
    submodule_index = dnx_data_port_submodule_static_add;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_port_static_add_define_default_speed_for_special_if;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_static_add_default_speed_for_special_if_set;
    data_index = dnx_data_port_static_add_define_fabric_fw_load_method;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_static_add_fabric_fw_load_method_set;
    data_index = dnx_data_port_static_add_define_fabric_fw_load_verify;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_static_add_fabric_fw_load_verify_set;
    data_index = dnx_data_port_static_add_define_nif_fw_load_method;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_static_add_nif_fw_load_method_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_port_static_add_table_ucode_port;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_ucode_port_set;
    data_index = dnx_data_port_static_add_table_speed;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_speed_set;
    data_index = dnx_data_port_static_add_table_ext_stat_speed;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_ext_stat_speed_set;
    data_index = dnx_data_port_static_add_table_eth_padding;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_eth_padding_set;
    data_index = dnx_data_port_static_add_table_link_training;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_link_training_set;
    data_index = dnx_data_port_static_add_table_ext_stat_link_training;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_ext_stat_link_training_set;
    data_index = dnx_data_port_static_add_table_fec_type;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_fec_type_set;
    data_index = dnx_data_port_static_add_table_serdes_lane_config;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_serdes_lane_config_set;
    data_index = dnx_data_port_static_add_table_serdes_tx_taps;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_serdes_tx_taps_set;
    data_index = dnx_data_port_static_add_table_tx_pam4_precoder;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_tx_pam4_precoder_set;
    data_index = dnx_data_port_static_add_table_lp_tx_precoder;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_lp_tx_precoder_set;
    data_index = dnx_data_port_static_add_table_fabric_quad_info;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_fabric_quad_info_set;
    data_index = dnx_data_port_static_add_table_header_type;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_header_type_set;
    data_index = dnx_data_port_static_add_table_erp_exist;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_port_static_add_erp_exist_set;
    /*
     * Attach submodule: general
     */
    submodule_index = dnx_data_port_submodule_general;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_port_general_define_nof_tm_ports;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_nof_tm_ports_set;
    data_index = dnx_data_port_general_define_erp_tm_port;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_erp_tm_port_set;
    data_index = dnx_data_port_general_define_reserved_tm_port;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_reserved_tm_port_set;
    data_index = dnx_data_port_general_define_nof_pp_ports;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_nof_pp_ports_set;
    data_index = dnx_data_port_general_define_nof_pms;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_nof_pms_set;
    data_index = dnx_data_port_general_define_max_nof_channels;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_max_nof_channels_set;
    data_index = dnx_data_port_general_define_fabric_phys_offset;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_fabric_phys_offset_set;
    data_index = dnx_data_port_general_define_tm_port_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_tm_port_size_set;
    data_index = dnx_data_port_general_define_pp_port_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_pp_port_size_set;
    data_index = dnx_data_port_general_define_pp_dsp_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_pp_dsp_size_set;
    data_index = dnx_data_port_general_define_vlan_domain_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_vlan_domain_size_set;
    data_index = dnx_data_port_general_define_nof_vlan_membership_if;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_nof_vlan_membership_if_set;
    data_index = dnx_data_port_general_define_ffc_instruction_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_ffc_instruction_size_set;
    data_index = dnx_data_port_general_define_fabric_port_base;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_fabric_port_base_set;
    data_index = dnx_data_port_general_define_dynamic_port_enable;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_general_dynamic_port_enable_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: egress
     */
    submodule_index = dnx_data_port_submodule_egress;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_port_egress_define_nof_ifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_port_egress_nof_ifs_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
