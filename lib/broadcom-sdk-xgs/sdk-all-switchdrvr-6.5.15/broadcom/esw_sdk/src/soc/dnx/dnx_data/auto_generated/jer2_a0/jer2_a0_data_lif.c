/** \file jer2_a0_data_lif.c
 * 
 * DEVICE DATA - LIF
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_LIF
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_lif.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
/*
 * }
 */

/*
 * EXTERN FUNCTIONS:
 * {
 */
/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: global_lif
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_global_l2_gport_lifs
 * define info:
 * The mpls and vlan ports don't have enough bits to support the full global lif address. Their number is limited by this value.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_global_lif_nof_global_l2_gport_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x100000;

    /* Set value */
    define->data = 0x100000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define glem_rif_optimization_enabled
 * define info:
 * Amount of out RIFs one GLEM entry can hold for optimized GLEM usage is 4.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_global_lif_glem_rif_optimization_enabled_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_glem_rif_optimization_enabled;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_global_in_lifs
 * numeric info:
 * Number of in global lifs in the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_global_lif_nof_global_in_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_nof_global_in_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x300000;

    /* Set value */
    define->data = 0x300000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_SYSTEM_HEADERS_MODE;
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0x40000;
    define->property.mapping[1].name = "1";
    define->property.mapping[1].val = 0x300000;
    define->property.mapping[1].is_default = 1 ;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_global_out_lifs
 * numeric info:
 * Number of out global lifs in the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_global_lif_nof_global_out_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_nof_global_out_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.global_lif.nof_global_in_lifs_get(unit);

    /* Set value */
    define->data = dnx_data_lif.global_lif.nof_global_in_lifs_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_glem_lines
 * numeric info:
 * Number of entries in the GLEM.                     This is the maximum number of egress global lifs in the system.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_global_lif_nof_glem_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_global_lif;
    int define_index = dnx_data_lif_global_lif_define_nof_glem_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x20000;

    /* Set value */
    define->data = 0x20000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "mdb_profile_glem";
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 1;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0x20000;
    define->property.mapping[0].is_default = 1 ;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: in_lif
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define inlif_index_bit_size
 * define info:
 * This is the size of a single index in the inlif table. Divide the entry  bit size by this to get its size in indexes.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_inlif_index_bit_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_inlif_index_bit_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 60;

    /* Set value */
    define->data = 60;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define inlif_minimum_index_size
 * define info:
 * The minimum size in indexes of an inlif entry
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_inlif_minimum_index_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_inlif_minimum_index_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define inlif_resource_tag_size
 * define info:
 * The size of the inlif resource's n-packs. The packs are used to  prevent fragmentation by assigning each pack a fixed entry size. The pack should be  the least common denominator of every possible entry side. See the SDD for full description.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_inlif_resource_tag_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_inlif_resource_tag_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_in_lif_profiles
 * define info:
 * Number of possible in_lif profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_nof_in_lif_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_in_lif_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_used_in_lif_profile_bits
 * define info:
 * Number of used in_lif_profile bits out of 8.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_used_eth_rif_profile_bits
 * define info:
 * Number of used eth_rif_profile bits.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_in_lif_incoming_orientation
 * define info:
 * Number of possible in_lif profile incoming orientation groups.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_eth_rif_profiles
 * define info:
 * Number of possible eth_rif profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_nof_eth_rif_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_eth_rif_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_da_not_found_destination_profiles
 * define info:
 * Number of da_not_found_destination profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_da_not_found_destination_profile
 * define info:
 * Default da_not_found_destination profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_default_da_not_found_destination_profile_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_default_da_not_found_destination_profile;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define drop_in_lif
 * define info:
 * local in_lif id performing trap with drop action.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_drop_in_lif_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_drop_in_lif;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_dpc_local_in_lifs
 * numeric info:
 * Number of duplicate per core local inlifs in the device. This value is per core, so the overall number is twice that.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_nof_dpc_local_in_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_dpc_local_in_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x20000;

    /* Set value */
    define->data = 0x20000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "mdb_profile_dpc_local_in_lifs";
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 1;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0x20000;
    define->property.mapping[0].is_default = 1 ;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric dpc_local_inlif_array_sw_size
 * numeric info:
 * Size of sw array needed for dpc local inlif. This value is for the whole system, and not just per core.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_dpc_local_inlif_array_sw_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_dpc_local_inlif_array_sw_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.in_lif.nof_dpc_local_in_lifs_get(unit) * dnx_data_device.general.max_nof_cores_get(unit);

    /* Set value */
    define->data = dnx_data_lif.in_lif.nof_dpc_local_in_lifs_get(unit) * dnx_data_device.general.max_nof_cores_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric dpc_local_inlif_hash_sw_size
 * numeric info:
 * Size of sw hash table needed for dpc local inlif. This value is for the whole system, and not just per core.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_dpc_local_inlif_hash_sw_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_dpc_local_inlif_hash_sw_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.in_lif.dpc_local_inlif_array_sw_size_get(unit) / dnx_data_lif.in_lif.inlif_minimum_index_size_get(unit);

    /* Set value */
    define->data = dnx_data_lif.in_lif.dpc_local_inlif_array_sw_size_get(unit) / dnx_data_lif.in_lif.inlif_minimum_index_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_sbc_local_in_lifs
 * numeric info:
 * Number of shared by cores local inlifs in the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_nof_sbc_local_in_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_nof_sbc_local_in_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x20000;

    /* Set value */
    define->data = 0x20000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "mdb_profile_sbc_local_in_lifs";
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 1;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0x20000;
    define->property.mapping[0].is_default = 1 ;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sbc_local_inlif_array_sw_size
 * numeric info:
 * Size of sw array needed for sbc local inlif.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_sbc_local_inlif_array_sw_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_sbc_local_inlif_array_sw_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.in_lif.nof_sbc_local_in_lifs_get(unit);

    /* Set value */
    define->data = dnx_data_lif.in_lif.nof_sbc_local_in_lifs_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sbc_local_inlif_hash_sw_size
 * numeric info:
 * Size of sw hash table needed for sbc local inlif.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_sbc_local_inlif_hash_sw_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_sbc_local_inlif_hash_sw_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.in_lif.sbc_local_inlif_array_sw_size_get(unit) / dnx_data_lif.in_lif.inlif_minimum_index_size_get(unit);

    /* Set value */
    define->data = dnx_data_lif.in_lif.sbc_local_inlif_array_sw_size_get(unit) / dnx_data_lif.in_lif.inlif_minimum_index_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric all_local_inlifs_array_sw_size
 * numeric info:
 * Size of sw array needed for dpc + sbc local inlifs. This value is for the whole system, and not just per core.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_all_local_inlifs_array_sw_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_all_local_inlifs_array_sw_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.in_lif.sbc_local_inlif_array_sw_size_get(unit) + dnx_data_lif.in_lif.dpc_local_inlif_array_sw_size_get(unit);

    /* Set value */
    define->data = dnx_data_lif.in_lif.sbc_local_inlif_array_sw_size_get(unit) + dnx_data_lif.in_lif.dpc_local_inlif_array_sw_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric all_local_inlif_hash_sw_size
 * numeric info:
 * Size of sw hash table needed for dpc local inlif. This value is for the whole system, and not just per core.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_all_local_inlif_hash_sw_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_all_local_inlif_hash_sw_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.in_lif.sbc_local_inlif_hash_sw_size_get(unit) + dnx_data_lif.in_lif.dpc_local_inlif_hash_sw_size_get(unit);

    /* Set value */
    define->data = dnx_data_lif.in_lif.sbc_local_inlif_hash_sw_size_get(unit) + dnx_data_lif.in_lif.dpc_local_inlif_hash_sw_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_orientaion
 * numeric info:
 * number of bits needed for egress property in_lif_orientation in in_lif_profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_orientaion_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientaion;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_egress_allocate";
    define->property.doc = 
        "number of values needed for egress property in_lif_orientation in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "orientation";
    define->property.range_min = 0;
    define->property.range_max = 8;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_policer_inner_dp
 * numeric info:
 * number of bits needed for egress property ive_inner_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_egress_allocate";
    define->property.doc = 
        "number of values needed for egress property ive_inner_qos_dp_profile in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "policer_inner_dp";
    define->property.range_min = 0;
    define->property.range_max = 4;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_policer_outer_dp
 * numeric info:
 * number of bits needed for egress property ive_outer_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_egress_allocate";
    define->property.doc = 
        "number of values needed for egress property ive_outer_qos_dp_profile in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "policer_outer_dp";
    define->property.range_min = 0;
    define->property.range_max = 4;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric in_lif_profile_allocate_same_interface_mode
 * numeric info:
 * number of bits needed for egress property in_lif_profile_allocate_same_interface_mode in in_lif_profile.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_in_lif;
    int define_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "in_lif_profile_egress_allocate";
    define->property.doc = 
        "number of values needed for egress property same_interface_mode in in_lif_profile\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_range;
    define->property.method_str = "suffix_range";
    define->property.suffix = "same_interface_mode";
    define->property.range_min = 0;
    define->property.range_max = 3;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: out_lif
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_out_lif_profiles
 * define info:
 * Number of possible out_lif profiles.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_nof_out_lif_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_nof_out_lif_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_out_lif_outgoing_orientation
 * define info:
 * Number of possible out_lif profile outgoing orientation groups.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define outlif_pointer_size
 * define info:
 * The number of bits in the outlif pointer used in the system.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_outlif_pointer_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_outlif_pointer_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define local_outlif_width
 * define info:
 * The number of bits in the local outlif from GLEM.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_local_outlif_width_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_local_outlif_width;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define outlif_profile_width
 * define info:
 * The number of bits in the outlif profile from GLEM.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_outlif_profile_width_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_outlif_profile_width;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.out_lif.glem_result_get(unit)-dnx_data_lif.out_lif.local_outlif_width_get(unit);

    /* Set value */
    define->data = dnx_data_lif.out_lif.glem_result_get(unit)-dnx_data_lif.out_lif.local_outlif_width_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define glem_result
 * define info:
 * The number of bits in GLEM result.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_glem_result_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_glem_result;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 21;

    /* Set value */
    define->data = 21;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_local_out_lifs
 * define info:
 * Number of potential local outlifs in the device. Derived from the pointer size.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_nof_local_out_lifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_nof_local_out_lifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_lif.out_lif.outlif_pointer_size_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_lif.out_lif.outlif_pointer_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define allocation_bank_size
 * define info:
 * Size of the outlif bank used by the outlif allocation algorithm.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_allocation_bank_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_allocation_bank_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8192;

    /* Set value */
    define->data = 8192;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define physical_bank_pointer_size
 * define info:
 * How many bits from the outlif pointer are used to indicate the physical bank.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_physical_bank_pointer_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_physical_bank_pointer_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define physical_bank_size
 * define info:
 * Size of the outlif bank used by the phase map and mags. Derived from the outlif pointer size  and the physical bank pointer size.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_physical_bank_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int define_index = dnx_data_lif_out_lif_define_physical_bank_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << (dnx_data_lif.out_lif.outlif_pointer_size_get(unit) - dnx_data_lif.out_lif.physical_bank_pointer_size_get(unit));

    /* Set value */
    define->data = 1 << (dnx_data_lif.out_lif.outlif_pointer_size_get(unit) - dnx_data_lif.out_lif.physical_bank_pointer_size_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table logical_to_physical_phase_map
 * Module - 'lif', Submodule - 'out_lif', table - 'logical_to_physical_phase_map'
 * Map outlif logical phase to physical phase.  The reverse mapping is implied from this.
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_out_lif_logical_to_physical_phase_map_set(
    int unit)
{
    int logical_phase_index;
    dnx_data_lif_out_lif_logical_to_physical_phase_map_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_out_lif;
    int table_index = dnx_data_lif_out_lif_table_logical_to_physical_phase_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 9;
    table->info_get.key_size[0] = 9;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_lif_out_lif_logical_to_physical_phase_map_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_lif_out_lif_table_logical_to_physical_phase_map");

    /* Store Default Values */
    default_data = (dnx_data_lif_out_lif_logical_to_physical_phase_map_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->physical_phase = -1;
    /* Set Default Values */
    for (logical_phase_index = 0; logical_phase_index < table->keys[0].size; logical_phase_index++)
    {
        data = (dnx_data_lif_out_lif_logical_to_physical_phase_map_t *) dnxc_data_mgmt_table_data_get(unit, table, logical_phase_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Value Property - physical_phase
     */
    table->values[0].property.name = spn_OUTLIF_LOGICAL_TO_PHYSICAL_PHASE_MAP;
    table->values[0].property.doc =
        "\n"
        "Map outlif logical phase to physical phase.\n"
        "The suffix for this property is the logical phase, and the value is the physical phase.\n"
        "Every logical phase and every physical phase must be configured.\n"
        "\n"
    ;
    table->values[0].property.method = dnxc_data_property_method_suffix_direct_map;
    table->values[0].property.method_str = "suffix_direct_map";
    table->values[0].property.suffix = "";
    table->values[0].property.nof_mapping = 8;
    DNXC_DATA_ALLOC(table->values[0].property.mapping, dnxc_data_property_map_t, table->values[0].property.nof_mapping, "dnx_data_lif_out_lif_logical_to_physical_phase_map_t property mapping");

    table->values[0].property.mapping[0].name = "XL";
    table->values[0].property.mapping[0].val = 0;
    table->values[0].property.mapping[1].name = "L1";
    table->values[0].property.mapping[1].val = 2;
    table->values[0].property.mapping[2].name = "L2";
    table->values[0].property.mapping[2].val = 4;
    table->values[0].property.mapping[3].name = "M1";
    table->values[0].property.mapping[3].val = 6;
    table->values[0].property.mapping[4].name = "M2";
    table->values[0].property.mapping[4].val = 7;
    table->values[0].property.mapping[5].name = "M3";
    table->values[0].property.mapping[5].val = 5;
    table->values[0].property.mapping[6].name = "S1";
    table->values[0].property.mapping[6].val = 3;
    table->values[0].property.mapping[7].name = "S2";
    table->values[0].property.mapping[7].val = 1;
    for (logical_phase_index = 0; logical_phase_index < table->keys[0].size; logical_phase_index++)
    {
        data = (dnx_data_lif_out_lif_logical_to_physical_phase_map_t *) dnxc_data_mgmt_table_data_get(unit, table, logical_phase_index, 0);
        SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &table->values[0].property, logical_phase_index, &data->physical_phase));
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: lif_table_manager
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_nof_lif_tables
 * define info:
 * Maximal number of logical lif tables (inlif + outlif)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_lif_table_manager_max_nof_lif_tables_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_lif_table_manager;
    int define_index = dnx_data_lif_lif_table_manager_define_max_nof_lif_tables;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 100;

    /* Set value */
    define->data = 100;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_nof_result_types
 * define info:
 * Maximal number of result types in lif table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_lif_table_manager_max_nof_result_types_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_lif_table_manager;
    int define_index = dnx_data_lif_lif_table_manager_define_max_nof_result_types;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 30;

    /* Set value */
    define->data = 30;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fields_per_result_type
 * define info:
 * Maximal number of fields for one result types in lif table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_lif_lif_table_manager_max_fields_per_result_type_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_lif;
    int submodule_index = dnx_data_lif_submodule_lif_table_manager;
    int define_index = dnx_data_lif_lif_table_manager_define_max_fields_per_result_type;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jer2_a0_data_lif_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_lif;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: global_lif
     */
    submodule_index = dnx_data_lif_submodule_global_lif;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_global_lif_nof_global_l2_gport_lifs_set;
    data_index = dnx_data_lif_global_lif_define_glem_rif_optimization_enabled;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_global_lif_glem_rif_optimization_enabled_set;
    data_index = dnx_data_lif_global_lif_define_nof_global_in_lifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_global_lif_nof_global_in_lifs_set;
    data_index = dnx_data_lif_global_lif_define_nof_global_out_lifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_global_lif_nof_global_out_lifs_set;
    data_index = dnx_data_lif_global_lif_define_nof_glem_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_global_lif_nof_glem_lines_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: in_lif
     */
    submodule_index = dnx_data_lif_submodule_in_lif;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_lif_in_lif_define_inlif_index_bit_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_inlif_index_bit_size_set;
    data_index = dnx_data_lif_in_lif_define_inlif_minimum_index_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_inlif_minimum_index_size_set;
    data_index = dnx_data_lif_in_lif_define_inlif_resource_tag_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_inlif_resource_tag_size_set;
    data_index = dnx_data_lif_in_lif_define_nof_in_lif_profiles;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_nof_in_lif_profiles_set;
    data_index = dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_set;
    data_index = dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_set;
    data_index = dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_set;
    data_index = dnx_data_lif_in_lif_define_nof_eth_rif_profiles;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_nof_eth_rif_profiles_set;
    data_index = dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_set;
    data_index = dnx_data_lif_in_lif_define_default_da_not_found_destination_profile;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_default_da_not_found_destination_profile_set;
    data_index = dnx_data_lif_in_lif_define_drop_in_lif;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_drop_in_lif_set;
    data_index = dnx_data_lif_in_lif_define_nof_dpc_local_in_lifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_nof_dpc_local_in_lifs_set;
    data_index = dnx_data_lif_in_lif_define_dpc_local_inlif_array_sw_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_dpc_local_inlif_array_sw_size_set;
    data_index = dnx_data_lif_in_lif_define_dpc_local_inlif_hash_sw_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_dpc_local_inlif_hash_sw_size_set;
    data_index = dnx_data_lif_in_lif_define_nof_sbc_local_in_lifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_nof_sbc_local_in_lifs_set;
    data_index = dnx_data_lif_in_lif_define_sbc_local_inlif_array_sw_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_sbc_local_inlif_array_sw_size_set;
    data_index = dnx_data_lif_in_lif_define_sbc_local_inlif_hash_sw_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_sbc_local_inlif_hash_sw_size_set;
    data_index = dnx_data_lif_in_lif_define_all_local_inlifs_array_sw_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_all_local_inlifs_array_sw_size_set;
    data_index = dnx_data_lif_in_lif_define_all_local_inlif_hash_sw_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_all_local_inlif_hash_sw_size_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientaion;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_orientaion_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_set;
    data_index = dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: out_lif
     */
    submodule_index = dnx_data_lif_submodule_out_lif;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_lif_out_lif_define_nof_out_lif_profiles;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_nof_out_lif_profiles_set;
    data_index = dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_set;
    data_index = dnx_data_lif_out_lif_define_outlif_pointer_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_outlif_pointer_size_set;
    data_index = dnx_data_lif_out_lif_define_local_outlif_width;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_local_outlif_width_set;
    data_index = dnx_data_lif_out_lif_define_outlif_profile_width;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_outlif_profile_width_set;
    data_index = dnx_data_lif_out_lif_define_glem_result;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_glem_result_set;
    data_index = dnx_data_lif_out_lif_define_nof_local_out_lifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_nof_local_out_lifs_set;
    data_index = dnx_data_lif_out_lif_define_allocation_bank_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_allocation_bank_size_set;
    data_index = dnx_data_lif_out_lif_define_physical_bank_pointer_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_physical_bank_pointer_size_set;
    data_index = dnx_data_lif_out_lif_define_physical_bank_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_out_lif_physical_bank_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_lif_out_lif_table_logical_to_physical_phase_map;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_lif_out_lif_logical_to_physical_phase_map_set;
    /*
     * Attach submodule: lif_table_manager
     */
    submodule_index = dnx_data_lif_submodule_lif_table_manager;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_lif_lif_table_manager_define_max_nof_lif_tables;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_lif_table_manager_max_nof_lif_tables_set;
    data_index = dnx_data_lif_lif_table_manager_define_max_nof_result_types;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_lif_table_manager_max_nof_result_types_set;
    data_index = dnx_data_lif_lif_table_manager_define_max_fields_per_result_type;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_lif_lif_table_manager_max_fields_per_result_type_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
