/** \file dnx_data_lif.c
 * 
 * MODULE DEVICE DATA - LIF
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_LIF
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_lif.h>
/*
 * }
 */

/*
 * Extern per device attach function
 */
extern shr_error_e jer2_a0_data_lif_attach(
    int unit);
/*
 * SUBMODULE - GLOBAL_LIF:
 * {
 */
/*
 * global_lif init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_lif_global_lif_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "global_lif";
    submodule_data->doc = "Global lif attributes";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_lif_global_lif_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data lif global_lif features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_lif_global_lif_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data lif global_lif defines");

    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs].name = "nof_global_l2_gport_lifs";
    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs].doc = "The mpls and vlan ports don't have enough bits to support the full global lif address. Their number is limited by this value.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_global_lif_define_glem_rif_optimization_enabled].name = "glem_rif_optimization_enabled";
    submodule_data->defines[dnx_data_lif_global_lif_define_glem_rif_optimization_enabled].doc = "Amount of out RIFs one GLEM entry can hold for optimized GLEM usage is 4.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_global_lif_define_glem_rif_optimization_enabled].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_in_lifs].name = "nof_global_in_lifs";
    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_in_lifs].doc = "Number of in global lifs in the device.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_in_lifs].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_out_lifs].name = "nof_global_out_lifs";
    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_out_lifs].doc = "Number of out global lifs in the device.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_global_lif_define_nof_global_out_lifs].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_global_lif_define_nof_glem_lines].name = "nof_glem_lines";
    submodule_data->defines[dnx_data_lif_global_lif_define_nof_glem_lines].doc = "Number of entries in the GLEM.                     This is the maximum number of egress global lifs in the system.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_global_lif_define_nof_glem_lines].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_lif_global_lif_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data lif global_lif tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * global_lif features
 */
int
dnx_data_lif_global_lif_feature_get(
    int unit,
    dnx_data_lif_global_lif_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_global_lif, feature);
}

/*
 * global_lif defines
 */
uint32
dnx_data_lif_global_lif_nof_global_l2_gport_lifs_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_global_lif, dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs);
}

uint32
dnx_data_lif_global_lif_glem_rif_optimization_enabled_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_global_lif, dnx_data_lif_global_lif_define_glem_rif_optimization_enabled);
}

uint32
dnx_data_lif_global_lif_nof_global_in_lifs_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_global_lif, dnx_data_lif_global_lif_define_nof_global_in_lifs);
}

uint32
dnx_data_lif_global_lif_nof_global_out_lifs_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_global_lif, dnx_data_lif_global_lif_define_nof_global_out_lifs);
}

uint32
dnx_data_lif_global_lif_nof_glem_lines_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_global_lif, dnx_data_lif_global_lif_define_nof_glem_lines);
}

/*
 * global_lif tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - IN_LIF:
 * {
 */
/*
 * in_lif init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_lif_in_lif_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "in_lif";
    submodule_data->doc = "In lif attributes";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_lif_in_lif_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data lif in_lif features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_lif_in_lif_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data lif in_lif defines");

    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_index_bit_size].name = "inlif_index_bit_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_index_bit_size].doc = "This is the size of a single index in the inlif table. Divide the entry  bit size by this to get its size in indexes.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_index_bit_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_minimum_index_size].name = "inlif_minimum_index_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_minimum_index_size].doc = "The minimum size in indexes of an inlif entry";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_minimum_index_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_resource_tag_size].name = "inlif_resource_tag_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_resource_tag_size].doc = "The size of the inlif resource's n-packs. The packs are used to  prevent fragmentation by assigning each pack a fixed entry size. The pack should be  the least common denominator of every possible entry side. See the SDD for full description.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_inlif_resource_tag_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_nof_in_lif_profiles].name = "nof_in_lif_profiles";
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_in_lif_profiles].doc = "Number of possible in_lif profiles.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_in_lif_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits].name = "nof_used_in_lif_profile_bits";
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits].doc = "Number of used in_lif_profile bits out of 8.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits].name = "nof_used_eth_rif_profile_bits";
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits].doc = "Number of used eth_rif_profile bits.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation].name = "nof_in_lif_incoming_orientation";
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation].doc = "Number of possible in_lif profile incoming orientation groups.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_nof_eth_rif_profiles].name = "nof_eth_rif_profiles";
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_eth_rif_profiles].doc = "Number of possible eth_rif profiles.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_eth_rif_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles].name = "nof_da_not_found_destination_profiles";
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles].doc = "Number of da_not_found_destination profiles.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_default_da_not_found_destination_profile].name = "default_da_not_found_destination_profile";
    submodule_data->defines[dnx_data_lif_in_lif_define_default_da_not_found_destination_profile].doc = "Default da_not_found_destination profile.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_default_da_not_found_destination_profile].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_drop_in_lif].name = "drop_in_lif";
    submodule_data->defines[dnx_data_lif_in_lif_define_drop_in_lif].doc = "local in_lif id performing trap with drop action.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_drop_in_lif].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_in_lif_define_nof_dpc_local_in_lifs].name = "nof_dpc_local_in_lifs";
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_dpc_local_in_lifs].doc = "Number of duplicate per core local inlifs in the device. This value is per core, so the overall number is twice that.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_dpc_local_in_lifs].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_dpc_local_inlif_array_sw_size].name = "dpc_local_inlif_array_sw_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_dpc_local_inlif_array_sw_size].doc = "Size of sw array needed for dpc local inlif. This value is for the whole system, and not just per core.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_dpc_local_inlif_array_sw_size].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_dpc_local_inlif_hash_sw_size].name = "dpc_local_inlif_hash_sw_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_dpc_local_inlif_hash_sw_size].doc = "Size of sw hash table needed for dpc local inlif. This value is for the whole system, and not just per core.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_dpc_local_inlif_hash_sw_size].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_nof_sbc_local_in_lifs].name = "nof_sbc_local_in_lifs";
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_sbc_local_in_lifs].doc = "Number of shared by cores local inlifs in the device.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_nof_sbc_local_in_lifs].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_sbc_local_inlif_array_sw_size].name = "sbc_local_inlif_array_sw_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_sbc_local_inlif_array_sw_size].doc = "Size of sw array needed for sbc local inlif.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_sbc_local_inlif_array_sw_size].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_sbc_local_inlif_hash_sw_size].name = "sbc_local_inlif_hash_sw_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_sbc_local_inlif_hash_sw_size].doc = "Size of sw hash table needed for sbc local inlif.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_sbc_local_inlif_hash_sw_size].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_all_local_inlifs_array_sw_size].name = "all_local_inlifs_array_sw_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_all_local_inlifs_array_sw_size].doc = "Size of sw array needed for dpc + sbc local inlifs. This value is for the whole system, and not just per core.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_all_local_inlifs_array_sw_size].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_all_local_inlif_hash_sw_size].name = "all_local_inlif_hash_sw_size";
    submodule_data->defines[dnx_data_lif_in_lif_define_all_local_inlif_hash_sw_size].doc = "Size of sw hash table needed for dpc local inlif. This value is for the whole system, and not just per core.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_all_local_inlif_hash_sw_size].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientaion].name = "in_lif_profile_allocate_orientaion";
    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientaion].doc = "number of bits needed for egress property in_lif_orientation in in_lif_profile";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientaion].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp].name = "in_lif_profile_allocate_policer_inner_dp";
    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp].doc = "number of bits needed for egress property ive_inner_qos_dp_profile in in_lif_profile.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp].name = "in_lif_profile_allocate_policer_outer_dp";
    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp].doc = "number of bits needed for egress property ive_outer_qos_dp_profile in in_lif_profile.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode].name = "in_lif_profile_allocate_same_interface_mode";
    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode].doc = "number of bits needed for egress property in_lif_profile_allocate_same_interface_mode in in_lif_profile.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_lif_in_lif_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data lif in_lif tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * in_lif features
 */
int
dnx_data_lif_in_lif_feature_get(
    int unit,
    dnx_data_lif_in_lif_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, feature);
}

/*
 * in_lif defines
 */
uint32
dnx_data_lif_in_lif_inlif_index_bit_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_inlif_index_bit_size);
}

uint32
dnx_data_lif_in_lif_inlif_minimum_index_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_inlif_minimum_index_size);
}

uint32
dnx_data_lif_in_lif_inlif_resource_tag_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_inlif_resource_tag_size);
}

uint32
dnx_data_lif_in_lif_nof_in_lif_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_nof_in_lif_profiles);
}

uint32
dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits);
}

uint32
dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits);
}

uint32
dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation);
}

uint32
dnx_data_lif_in_lif_nof_eth_rif_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_nof_eth_rif_profiles);
}

uint32
dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles);
}

uint32
dnx_data_lif_in_lif_default_da_not_found_destination_profile_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_default_da_not_found_destination_profile);
}

uint32
dnx_data_lif_in_lif_drop_in_lif_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_drop_in_lif);
}

uint32
dnx_data_lif_in_lif_nof_dpc_local_in_lifs_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_nof_dpc_local_in_lifs);
}

uint32
dnx_data_lif_in_lif_dpc_local_inlif_array_sw_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_dpc_local_inlif_array_sw_size);
}

uint32
dnx_data_lif_in_lif_dpc_local_inlif_hash_sw_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_dpc_local_inlif_hash_sw_size);
}

uint32
dnx_data_lif_in_lif_nof_sbc_local_in_lifs_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_nof_sbc_local_in_lifs);
}

uint32
dnx_data_lif_in_lif_sbc_local_inlif_array_sw_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_sbc_local_inlif_array_sw_size);
}

uint32
dnx_data_lif_in_lif_sbc_local_inlif_hash_sw_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_sbc_local_inlif_hash_sw_size);
}

uint32
dnx_data_lif_in_lif_all_local_inlifs_array_sw_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_all_local_inlifs_array_sw_size);
}

uint32
dnx_data_lif_in_lif_all_local_inlif_hash_sw_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_all_local_inlif_hash_sw_size);
}

uint32
dnx_data_lif_in_lif_in_lif_profile_allocate_orientaion_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientaion);
}

uint32
dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp);
}

uint32
dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp);
}

uint32
dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_in_lif, dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode);
}

/*
 * in_lif tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - OUT_LIF:
 * {
 */
/*
 * out_lif init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_lif_out_lif_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "out_lif";
    submodule_data->doc = "Out lif attributes";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_lif_out_lif_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data lif out_lif features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_lif_out_lif_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data lif out_lif defines");

    submodule_data->defines[dnx_data_lif_out_lif_define_nof_out_lif_profiles].name = "nof_out_lif_profiles";
    submodule_data->defines[dnx_data_lif_out_lif_define_nof_out_lif_profiles].doc = "Number of possible out_lif profiles.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_nof_out_lif_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation].name = "nof_out_lif_outgoing_orientation";
    submodule_data->defines[dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation].doc = "Number of possible out_lif profile outgoing orientation groups.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_outlif_pointer_size].name = "outlif_pointer_size";
    submodule_data->defines[dnx_data_lif_out_lif_define_outlif_pointer_size].doc = "The number of bits in the outlif pointer used in the system.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_outlif_pointer_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_local_outlif_width].name = "local_outlif_width";
    submodule_data->defines[dnx_data_lif_out_lif_define_local_outlif_width].doc = "The number of bits in the local outlif from GLEM.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_local_outlif_width].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_outlif_profile_width].name = "outlif_profile_width";
    submodule_data->defines[dnx_data_lif_out_lif_define_outlif_profile_width].doc = "The number of bits in the outlif profile from GLEM.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_outlif_profile_width].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_glem_result].name = "glem_result";
    submodule_data->defines[dnx_data_lif_out_lif_define_glem_result].doc = "The number of bits in GLEM result.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_glem_result].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_nof_local_out_lifs].name = "nof_local_out_lifs";
    submodule_data->defines[dnx_data_lif_out_lif_define_nof_local_out_lifs].doc = "Number of potential local outlifs in the device. Derived from the pointer size.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_nof_local_out_lifs].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_allocation_bank_size].name = "allocation_bank_size";
    submodule_data->defines[dnx_data_lif_out_lif_define_allocation_bank_size].doc = "Size of the outlif bank used by the outlif allocation algorithm.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_allocation_bank_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_physical_bank_pointer_size].name = "physical_bank_pointer_size";
    submodule_data->defines[dnx_data_lif_out_lif_define_physical_bank_pointer_size].doc = "How many bits from the outlif pointer are used to indicate the physical bank.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_physical_bank_pointer_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_out_lif_define_physical_bank_size].name = "physical_bank_size";
    submodule_data->defines[dnx_data_lif_out_lif_define_physical_bank_size].doc = "Size of the outlif bank used by the phase map and mags. Derived from the outlif pointer size  and the physical bank pointer size.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_out_lif_define_physical_bank_size].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_lif_out_lif_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data lif out_lif tables");

    /*
     * Table - logical_to_physical_phase_map
     */
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].name = "logical_to_physical_phase_map";
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].doc = "Map outlif logical phase to physical phase.  The reverse mapping is implied from this.";
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].size_of_values = sizeof(dnx_data_lif_out_lif_logical_to_physical_phase_map_t);
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].entry_get = dnx_data_lif_out_lif_logical_to_physical_phase_map_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].nof_keys = 1;
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].keys[0].name = "logical_phase";
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].keys[0].doc = "Logical phase to map.";

    /* Values */
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].values, dnxc_data_value_t, submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].nof_values, "_dnx_data_lif_out_lif_table_logical_to_physical_phase_map table values");
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].values[0].name = "physical_phase";
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].values[0].type = "int";
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].values[0].doc = "Mapped physical phase.";
    submodule_data->tables[dnx_data_lif_out_lif_table_logical_to_physical_phase_map].values[0].offset = UTILEX_OFFSETOF(dnx_data_lif_out_lif_logical_to_physical_phase_map_t, physical_phase);


exit:
    SHR_FUNC_EXIT;
}

/*
 * out_lif features
 */
int
dnx_data_lif_out_lif_feature_get(
    int unit,
    dnx_data_lif_out_lif_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, feature);
}

/*
 * out_lif defines
 */
uint32
dnx_data_lif_out_lif_nof_out_lif_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_nof_out_lif_profiles);
}

uint32
dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation);
}

uint32
dnx_data_lif_out_lif_outlif_pointer_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_outlif_pointer_size);
}

uint32
dnx_data_lif_out_lif_local_outlif_width_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_local_outlif_width);
}

uint32
dnx_data_lif_out_lif_outlif_profile_width_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_outlif_profile_width);
}

uint32
dnx_data_lif_out_lif_glem_result_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_glem_result);
}

uint32
dnx_data_lif_out_lif_nof_local_out_lifs_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_nof_local_out_lifs);
}

uint32
dnx_data_lif_out_lif_allocation_bank_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_allocation_bank_size);
}

uint32
dnx_data_lif_out_lif_physical_bank_pointer_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_physical_bank_pointer_size);
}

uint32
dnx_data_lif_out_lif_physical_bank_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_define_physical_bank_size);
}

/*
 * out_lif tables
 */
/* Table Get */
const dnx_data_lif_out_lif_logical_to_physical_phase_map_t *
dnx_data_lif_out_lif_logical_to_physical_phase_map_get(
    int unit,
    int logical_phase)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_table_logical_to_physical_phase_map);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, logical_phase, 0);
    return (const dnx_data_lif_out_lif_logical_to_physical_phase_map_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_lif_out_lif_logical_to_physical_phase_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_lif_out_lif_logical_to_physical_phase_map_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_table_logical_to_physical_phase_map);
    data = (const dnx_data_lif_out_lif_logical_to_physical_phase_map_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->physical_phase);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_lif_out_lif_logical_to_physical_phase_map_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_out_lif, dnx_data_lif_out_lif_table_logical_to_physical_phase_map);

}

/*
 * }
 */

/*
 * SUBMODULE - LIF_TABLE_MANAGER:
 * {
 */
/*
 * lif_table_manager init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_lif_lif_table_manager_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "lif_table_manager";
    submodule_data->doc = "module for local lif allocation";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_lif_lif_table_manager_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data lif lif_table_manager features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_lif_lif_table_manager_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data lif lif_table_manager defines");

    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_nof_lif_tables].name = "max_nof_lif_tables";
    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_nof_lif_tables].doc = "Maximal number of logical lif tables (inlif + outlif)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_nof_lif_tables].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_nof_result_types].name = "max_nof_result_types";
    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_nof_result_types].doc = "Maximal number of result types in lif table";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_nof_result_types].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_fields_per_result_type].name = "max_fields_per_result_type";
    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_fields_per_result_type].doc = "Maximal number of fields for one result types in lif table";
    /* Set data type flag */
    submodule_data->defines[dnx_data_lif_lif_table_manager_define_max_fields_per_result_type].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_lif_lif_table_manager_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data lif lif_table_manager tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * lif_table_manager features
 */
int
dnx_data_lif_lif_table_manager_feature_get(
    int unit,
    dnx_data_lif_lif_table_manager_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_lif_table_manager, feature);
}

/*
 * lif_table_manager defines
 */
uint32
dnx_data_lif_lif_table_manager_max_nof_lif_tables_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_lif_table_manager, dnx_data_lif_lif_table_manager_define_max_nof_lif_tables);
}

uint32
dnx_data_lif_lif_table_manager_max_nof_result_types_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_lif_table_manager, dnx_data_lif_lif_table_manager_define_max_nof_result_types);
}

uint32
dnx_data_lif_lif_table_manager_max_fields_per_result_type_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_lif, dnx_data_lif_submodule_lif_table_manager, dnx_data_lif_lif_table_manager_define_max_fields_per_result_type);
}

/*
 * lif_table_manager tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

shr_error_e
dnx_data_lif_init(
    int unit,
    dnxc_data_module_t *module_data)
{
    SHR_FUNC_INIT_VARS(unit);

    /* Data Struct Init */
    module_data->name = "lif";
    module_data->nof_submodules = _dnx_data_lif_submodule_nof;
    DNXC_DATA_ALLOC(module_data->submodules, dnxc_data_submodule_t, module_data->nof_submodules, "_dnxc_data lif submodules");

    /*
     * Init Submodule data
     */
    SHR_IF_ERR_EXIT(dnx_data_lif_global_lif_init(unit, &module_data->submodules[dnx_data_lif_submodule_global_lif]));
    SHR_IF_ERR_EXIT(dnx_data_lif_in_lif_init(unit, &module_data->submodules[dnx_data_lif_submodule_in_lif]));
    SHR_IF_ERR_EXIT(dnx_data_lif_out_lif_init(unit, &module_data->submodules[dnx_data_lif_submodule_out_lif]));
    SHR_IF_ERR_EXIT(dnx_data_lif_lif_table_manager_init(unit, &module_data->submodules[dnx_data_lif_submodule_lif_table_manager]));
    /*
     * Attach device module
     */
    if (dnxc_data_mgmt_is_jer2_a0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_lif_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_jer2_b0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_lif_attach(unit));
    }

exit:
    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
