/** \file dnx_data_sch.c
 * 
 * MODULE DEVICE DATA - SCH
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_COSQ
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_sch.h>
/*
 * }
 */

/*
 * Extern per device attach function
 */
extern shr_error_e jer2_a0_data_sch_attach(
    int unit);
/*
 * SUBMODULE - GENERAL:
 * {
 */
/*
 * general init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_general_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "general";
    submodule_data->doc = "e2e scheduler general information";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_general_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch general features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_general_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch general defines");

    submodule_data->defines[dnx_data_sch_general_define_nof_slow_profiles].name = "nof_slow_profiles";
    submodule_data->defines[dnx_data_sch_general_define_nof_slow_profiles].doc = "Number of slow profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_general_define_nof_slow_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_general_define_nof_slow_levels].name = "nof_slow_levels";
    submodule_data->defines[dnx_data_sch_general_define_nof_slow_levels].doc = "Number of slow levels";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_general_define_nof_slow_levels].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_general_define_cycles_per_credit_token].name = "cycles_per_credit_token";
    submodule_data->defines[dnx_data_sch_general_define_cycles_per_credit_token].doc = "Number of of cycles between credit tokens of the same flow";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_general_define_cycles_per_credit_token].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_general_define_nof_fmq_class].name = "nof_fmq_class";
    submodule_data->defines[dnx_data_sch_general_define_nof_fmq_class].doc = "Number of FMQ class";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_general_define_nof_fmq_class].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_general_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch general tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * general features
 */
int
dnx_data_sch_general_feature_get(
    int unit,
    dnx_data_sch_general_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_general, feature);
}

/*
 * general defines
 */
uint32
dnx_data_sch_general_nof_slow_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_general, dnx_data_sch_general_define_nof_slow_profiles);
}

uint32
dnx_data_sch_general_nof_slow_levels_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_general, dnx_data_sch_general_define_nof_slow_levels);
}

uint32
dnx_data_sch_general_cycles_per_credit_token_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_general, dnx_data_sch_general_define_cycles_per_credit_token);
}

uint32
dnx_data_sch_general_nof_fmq_class_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_general, dnx_data_sch_general_define_nof_fmq_class);
}

/*
 * general tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - PS:
 * {
 */
/*
 * ps init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_ps_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "ps";
    submodule_data->doc = "e2e port scheduler (PS) information";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_ps_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch ps features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_ps_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch ps defines");

    submodule_data->defines[dnx_data_sch_ps_define_min_priority_for_tcg].name = "min_priority_for_tcg";
    submodule_data->defines[dnx_data_sch_ps_define_min_priority_for_tcg].doc = "Minimal port priority supporting tcg";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_ps_define_min_priority_for_tcg].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_ps_define_max_nof_tcg].name = "max_nof_tcg";
    submodule_data->defines[dnx_data_sch_ps_define_max_nof_tcg].doc = "Maximal number of TCGs in a port scheduler";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_ps_define_max_nof_tcg].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_ps_define_nof_hrs_in_ps].name = "nof_hrs_in_ps";
    submodule_data->defines[dnx_data_sch_ps_define_nof_hrs_in_ps].doc = "Number of HRs in port scheduler";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_ps_define_nof_hrs_in_ps].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_ps_define_max_tcg_weight].name = "max_tcg_weight";
    submodule_data->defines[dnx_data_sch_ps_define_max_tcg_weight].doc = "Maximal TCG EIR weight";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_ps_define_max_tcg_weight].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_ps_define_tc_tcg_calendar_access_period].name = "tc_tcg_calendar_access_period";
    submodule_data->defines[dnx_data_sch_ps_define_tc_tcg_calendar_access_period].doc = "Access period of TC/TCG calendars";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_ps_define_tc_tcg_calendar_access_period].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_ps_define_max_burst].name = "max_burst";
    submodule_data->defines[dnx_data_sch_ps_define_max_burst].doc = "Maximal burst of TC/TCG port shapers";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_ps_define_max_burst].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_ps_define_max_port_rate_mbps].name = "max_port_rate_mbps";
    submodule_data->defines[dnx_data_sch_ps_define_max_port_rate_mbps].doc = "maximal rate an port can drive (in MBits/sec)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_ps_define_max_port_rate_mbps].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_ps_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch ps tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * ps features
 */
int
dnx_data_sch_ps_feature_get(
    int unit,
    dnx_data_sch_ps_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_ps, feature);
}

/*
 * ps defines
 */
uint32
dnx_data_sch_ps_min_priority_for_tcg_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_ps, dnx_data_sch_ps_define_min_priority_for_tcg);
}

uint32
dnx_data_sch_ps_max_nof_tcg_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_ps, dnx_data_sch_ps_define_max_nof_tcg);
}

uint32
dnx_data_sch_ps_nof_hrs_in_ps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_ps, dnx_data_sch_ps_define_nof_hrs_in_ps);
}

uint32
dnx_data_sch_ps_max_tcg_weight_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_ps, dnx_data_sch_ps_define_max_tcg_weight);
}

uint32
dnx_data_sch_ps_tc_tcg_calendar_access_period_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_ps, dnx_data_sch_ps_define_tc_tcg_calendar_access_period);
}

uint32
dnx_data_sch_ps_max_burst_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_ps, dnx_data_sch_ps_define_max_burst);
}

uint32
dnx_data_sch_ps_max_port_rate_mbps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_ps, dnx_data_sch_ps_define_max_port_rate_mbps);
}

/*
 * ps tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - FLOW:
 * {
 */
/*
 * flow init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_flow_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "flow";
    submodule_data->doc = "e2e scheduler information";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_flow_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch flow features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_flow_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch flow defines");

    submodule_data->defines[dnx_data_sch_flow_define_nof_hr].name = "nof_hr";
    submodule_data->defines[dnx_data_sch_flow_define_nof_hr].doc = "Number of HR elements per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_nof_hr].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_nof_cl].name = "nof_cl";
    submodule_data->defines[dnx_data_sch_flow_define_nof_cl].doc = "Number of CL elements per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_nof_cl].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_erp_hr].name = "erp_hr";
    submodule_data->defines[dnx_data_sch_flow_define_erp_hr].doc = "HR id of first ERP HR";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_erp_hr].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_reserved_hr].name = "reserved_hr";
    submodule_data->defines[dnx_data_sch_flow_define_reserved_hr].doc = "reserved HR allocated for returned credits in LAG scheduling";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_reserved_hr].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_nof_se].name = "nof_se";
    submodule_data->defines[dnx_data_sch_flow_define_nof_se].doc = "Number of scheduling elements per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_nof_se].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_max_se].name = "max_se";
    submodule_data->defines[dnx_data_sch_flow_define_max_se].doc = "Maximal Scheduling element id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_max_se].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_nof_flows].name = "nof_flows";
    submodule_data->defines[dnx_data_sch_flow_define_nof_flows].doc = "Number of flows per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_nof_flows].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_max_flow].name = "max_flow";
    submodule_data->defines[dnx_data_sch_flow_define_max_flow].doc = "Maximal flow id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_max_flow].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_region_size].name = "region_size";
    submodule_data->defines[dnx_data_sch_flow_define_region_size].doc = "Number of flows in a region";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_region_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_nof_regions].name = "nof_regions";
    submodule_data->defines[dnx_data_sch_flow_define_nof_regions].doc = "Number of regions in a core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_nof_regions].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_first_hr_region].name = "first_hr_region";
    submodule_data->defines[dnx_data_sch_flow_define_first_hr_region].doc = "First HR region";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_first_hr_region].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_nof_hr_regions].name = "nof_hr_regions";
    submodule_data->defines[dnx_data_sch_flow_define_nof_hr_regions].doc = "Number of hr regions in a core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_nof_hr_regions].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_nof_connectors_only_regions].name = "nof_connectors_only_regions";
    submodule_data->defines[dnx_data_sch_flow_define_nof_connectors_only_regions].doc = "Number of connectors-only regions per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_nof_connectors_only_regions].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_first_se_flow_id].name = "first_se_flow_id";
    submodule_data->defines[dnx_data_sch_flow_define_first_se_flow_id].doc = "Flow ID of first scheduling element";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_first_se_flow_id].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_flow_in_region_mask].name = "flow_in_region_mask";
    submodule_data->defines[dnx_data_sch_flow_define_flow_in_region_mask].doc = "mask for flows in region";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_flow_in_region_mask].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_hr_se_id_min].name = "hr_se_id_min";
    submodule_data->defines[dnx_data_sch_flow_define_hr_se_id_min].doc = "min hr se id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_hr_se_id_min].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_hr_se_id_max].name = "hr_se_id_max";
    submodule_data->defines[dnx_data_sch_flow_define_hr_se_id_max].doc = "max hr se id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_hr_se_id_max].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_default_credit_source_se_id].name = "default_credit_source_se_id";
    submodule_data->defines[dnx_data_sch_flow_define_default_credit_source_se_id].doc = "SE ID of default credit source. used to mark unattached flow";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_default_credit_source_se_id].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_min_connector_bundle_size].name = "min_connector_bundle_size";
    submodule_data->defines[dnx_data_sch_flow_define_min_connector_bundle_size].doc = "minimal number of connectors in bundle";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_min_connector_bundle_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_conn_idx_interdig_flow].name = "conn_idx_interdig_flow";
    submodule_data->defines[dnx_data_sch_flow_define_conn_idx_interdig_flow].doc = "first connector index in an interdigitated flow";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_conn_idx_interdig_flow].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_flow_define_runtime_performance_optimize_enable_sched_allocation].name = "runtime_performance_optimize_enable_sched_allocation";
    submodule_data->defines[dnx_data_sch_flow_define_runtime_performance_optimize_enable_sched_allocation].doc = "enable flow properties access optimization";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_flow_define_runtime_performance_optimize_enable_sched_allocation].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_flow_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch flow tables");

    /*
     * Table - region_type
     */
    submodule_data->tables[dnx_data_sch_flow_table_region_type].name = "region_type";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].doc = "flow region type";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_flow_table_region_type].size_of_values = sizeof(dnx_data_sch_flow_region_type_t);
    submodule_data->tables[dnx_data_sch_flow_table_region_type].entry_get = dnx_data_sch_flow_region_type_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_flow_table_region_type].nof_keys = 2;
    submodule_data->tables[dnx_data_sch_flow_table_region_type].keys[0].name = "core";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].keys[0].doc = "see table doc";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].keys[1].name = "region";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].keys[1].doc = "see table doc";

    /* Values */
    submodule_data->tables[dnx_data_sch_flow_table_region_type].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_flow_table_region_type].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_flow_table_region_type].nof_values, "_dnx_data_sch_flow_table_region_type table values");
    submodule_data->tables[dnx_data_sch_flow_table_region_type].values[0].name = "type";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].values[0].type = "uint32";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].values[0].doc = "see table doc";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_flow_region_type_t, type);
    submodule_data->tables[dnx_data_sch_flow_table_region_type].values[1].name = "propagation_direction";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].values[1].type = "uint32";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].values[1].doc = "see table doc";
    submodule_data->tables[dnx_data_sch_flow_table_region_type].values[1].offset = UTILEX_OFFSETOF(dnx_data_sch_flow_region_type_t, propagation_direction);

    /*
     * Table - nof_remote_cores
     */
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].name = "nof_remote_cores";
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].doc = "flow region type";
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].size_of_values = sizeof(dnx_data_sch_flow_nof_remote_cores_t);
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].entry_get = dnx_data_sch_flow_nof_remote_cores_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].nof_keys = 2;
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].keys[0].name = "core";
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].keys[0].doc = "see table doc";
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].keys[1].name = "region";
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].keys[1].doc = "see table doc";

    /* Values */
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].nof_values, "_dnx_data_sch_flow_table_nof_remote_cores table values");
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].values[0].name = "val";
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].values[0].type = "uint32";
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].values[0].doc = "see table doc";
    submodule_data->tables[dnx_data_sch_flow_table_nof_remote_cores].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_flow_nof_remote_cores_t, val);

    /*
     * Table - cl_num_to_quartet_offset
     */
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].name = "cl_num_to_quartet_offset";
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].doc = "mapping CL number to quartet index";
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].size_of_values = sizeof(dnx_data_sch_flow_cl_num_to_quartet_offset_t);
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].entry_get = dnx_data_sch_flow_cl_num_to_quartet_offset_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].nof_keys = 1;
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].keys[0].name = "cl_num";
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].keys[0].doc = "number of CL in the quartet";

    /* Values */
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].nof_values, "_dnx_data_sch_flow_table_cl_num_to_quartet_offset table values");
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].values[0].name = "quartet_offset";
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].values[0].type = "int";
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].values[0].doc = "quartet offset";
    submodule_data->tables[dnx_data_sch_flow_table_cl_num_to_quartet_offset].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_flow_cl_num_to_quartet_offset_t, quartet_offset);

    /*
     * Table - quartet_offset_to_cl_num
     */
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].name = "quartet_offset_to_cl_num";
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].doc = "mapping quartet index to CL number";
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].size_of_values = sizeof(dnx_data_sch_flow_quartet_offset_to_cl_num_t);
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].entry_get = dnx_data_sch_flow_quartet_offset_to_cl_num_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].nof_keys = 1;
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].keys[0].name = "quartet_offset";
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].keys[0].doc = "quartet offset";

    /* Values */
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].nof_values, "_dnx_data_sch_flow_table_quartet_offset_to_cl_num table values");
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].values[0].name = "cl_num";
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].values[0].type = "int";
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].values[0].doc = "number of CL in the quartet";
    submodule_data->tables[dnx_data_sch_flow_table_quartet_offset_to_cl_num].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_flow_quartet_offset_to_cl_num_t, cl_num);


exit:
    SHR_FUNC_EXIT;
}

/*
 * flow features
 */
int
dnx_data_sch_flow_feature_get(
    int unit,
    dnx_data_sch_flow_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, feature);
}

/*
 * flow defines
 */
uint32
dnx_data_sch_flow_nof_hr_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_nof_hr);
}

uint32
dnx_data_sch_flow_nof_cl_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_nof_cl);
}

uint32
dnx_data_sch_flow_erp_hr_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_erp_hr);
}

uint32
dnx_data_sch_flow_reserved_hr_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_reserved_hr);
}

uint32
dnx_data_sch_flow_nof_se_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_nof_se);
}

uint32
dnx_data_sch_flow_max_se_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_max_se);
}

uint32
dnx_data_sch_flow_nof_flows_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_nof_flows);
}

uint32
dnx_data_sch_flow_max_flow_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_max_flow);
}

uint32
dnx_data_sch_flow_region_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_region_size);
}

uint32
dnx_data_sch_flow_nof_regions_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_nof_regions);
}

uint32
dnx_data_sch_flow_first_hr_region_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_first_hr_region);
}

uint32
dnx_data_sch_flow_nof_hr_regions_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_nof_hr_regions);
}

uint32
dnx_data_sch_flow_nof_connectors_only_regions_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_nof_connectors_only_regions);
}

uint32
dnx_data_sch_flow_first_se_flow_id_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_first_se_flow_id);
}

uint32
dnx_data_sch_flow_flow_in_region_mask_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_flow_in_region_mask);
}

uint32
dnx_data_sch_flow_hr_se_id_min_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_hr_se_id_min);
}

uint32
dnx_data_sch_flow_hr_se_id_max_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_hr_se_id_max);
}

uint32
dnx_data_sch_flow_default_credit_source_se_id_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_default_credit_source_se_id);
}

uint32
dnx_data_sch_flow_min_connector_bundle_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_min_connector_bundle_size);
}

uint32
dnx_data_sch_flow_conn_idx_interdig_flow_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_conn_idx_interdig_flow);
}

uint32
dnx_data_sch_flow_runtime_performance_optimize_enable_sched_allocation_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_define_runtime_performance_optimize_enable_sched_allocation);
}

/*
 * flow tables
 */
/* Table Get */
const dnx_data_sch_flow_region_type_t *
dnx_data_sch_flow_region_type_get(
    int unit,
    int core,
    int region)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_region_type);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, core, region);
    return (const dnx_data_sch_flow_region_type_t *) data;

}

const dnx_data_sch_flow_nof_remote_cores_t *
dnx_data_sch_flow_nof_remote_cores_get(
    int unit,
    int core,
    int region)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_nof_remote_cores);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, core, region);
    return (const dnx_data_sch_flow_nof_remote_cores_t *) data;

}

const dnx_data_sch_flow_cl_num_to_quartet_offset_t *
dnx_data_sch_flow_cl_num_to_quartet_offset_get(
    int unit,
    int cl_num)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_cl_num_to_quartet_offset);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, cl_num, 0);
    return (const dnx_data_sch_flow_cl_num_to_quartet_offset_t *) data;

}

const dnx_data_sch_flow_quartet_offset_to_cl_num_t *
dnx_data_sch_flow_quartet_offset_to_cl_num_get(
    int unit,
    int quartet_offset)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_quartet_offset_to_cl_num);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, quartet_offset, 0);
    return (const dnx_data_sch_flow_quartet_offset_to_cl_num_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_sch_flow_region_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_flow_region_type_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_region_type);
    data = (const dnx_data_sch_flow_region_type_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, key1);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->type);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->propagation_direction);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_sch_flow_nof_remote_cores_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_flow_nof_remote_cores_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_nof_remote_cores);
    data = (const dnx_data_sch_flow_nof_remote_cores_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, key1);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->val);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_sch_flow_cl_num_to_quartet_offset_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_flow_cl_num_to_quartet_offset_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_cl_num_to_quartet_offset);
    data = (const dnx_data_sch_flow_cl_num_to_quartet_offset_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->quartet_offset);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_sch_flow_quartet_offset_to_cl_num_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_flow_quartet_offset_to_cl_num_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_quartet_offset_to_cl_num);
    data = (const dnx_data_sch_flow_quartet_offset_to_cl_num_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->cl_num);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_sch_flow_region_type_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_region_type);

}

const dnxc_data_table_info_t *
dnx_data_sch_flow_nof_remote_cores_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_nof_remote_cores);

}

const dnxc_data_table_info_t *
dnx_data_sch_flow_cl_num_to_quartet_offset_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_cl_num_to_quartet_offset);

}

const dnxc_data_table_info_t *
dnx_data_sch_flow_quartet_offset_to_cl_num_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_flow, dnx_data_sch_flow_table_quartet_offset_to_cl_num);

}

/*
 * }
 */

/*
 * SUBMODULE - SE:
 * {
 */
/*
 * se init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_se_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "se";
    submodule_data->doc = "scheduler elements information";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_se_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch se features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_se_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch se defines");

    submodule_data->defines[dnx_data_sch_se_define_default_cos].name = "default_cos";
    submodule_data->defines[dnx_data_sch_se_define_default_cos].doc = "default parameter of credit source COS. Used for FQ";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_se_define_default_cos].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_se_define_nof_color_group].name = "nof_color_group";
    submodule_data->defines[dnx_data_sch_se_define_nof_color_group].doc = "number of colors (groups)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_se_define_nof_color_group].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_se_define_max_hr_weight].name = "max_hr_weight";
    submodule_data->defines[dnx_data_sch_se_define_max_hr_weight].doc = "maximal weight in HR WFQ";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_se_define_max_hr_weight].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_se_define_cl_class_profile_nof].name = "cl_class_profile_nof";
    submodule_data->defines[dnx_data_sch_se_define_cl_class_profile_nof].doc = "number of profiles for CL class";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_se_define_cl_class_profile_nof].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_se_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch se tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * se features
 */
int
dnx_data_sch_se_feature_get(
    int unit,
    dnx_data_sch_se_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_se, feature);
}

/*
 * se defines
 */
uint32
dnx_data_sch_se_default_cos_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_se, dnx_data_sch_se_define_default_cos);
}

uint32
dnx_data_sch_se_nof_color_group_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_se, dnx_data_sch_se_define_nof_color_group);
}

uint32
dnx_data_sch_se_max_hr_weight_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_se, dnx_data_sch_se_define_max_hr_weight);
}

uint32
dnx_data_sch_se_cl_class_profile_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_se, dnx_data_sch_se_define_cl_class_profile_nof);
}

/*
 * se tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - INTERFACE:
 * {
 */
/*
 * interface init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_interface_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "interface";
    submodule_data->doc = "e2e interface information";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_interface_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch interface features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_interface_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch interface defines");

    submodule_data->defines[dnx_data_sch_interface_define_nof_big_calendars].name = "nof_big_calendars";
    submodule_data->defines[dnx_data_sch_interface_define_nof_big_calendars].doc = "Number of big calendars per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_interface_define_nof_big_calendars].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_interface_define_big_calendar_size].name = "big_calendar_size";
    submodule_data->defines[dnx_data_sch_interface_define_big_calendar_size].doc = "Size of big calendar";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_interface_define_big_calendar_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_interface_define_nof_sch_interfaces].name = "nof_sch_interfaces";
    submodule_data->defines[dnx_data_sch_interface_define_nof_sch_interfaces].doc = "Number of sch interfaces per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_interface_define_nof_sch_interfaces].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_interface_define_cal_speed_resolution].name = "cal_speed_resolution";
    submodule_data->defines[dnx_data_sch_interface_define_cal_speed_resolution].doc = "Resolution of interface calendar processing speed";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_interface_define_cal_speed_resolution].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_interface_define_shaper_resolution].name = "shaper_resolution";
    submodule_data->defines[dnx_data_sch_interface_define_shaper_resolution].doc = "Resolution of interface shaper";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_interface_define_shaper_resolution].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_interface_define_max_if_rate_mbps].name = "max_if_rate_mbps";
    submodule_data->defines[dnx_data_sch_interface_define_max_if_rate_mbps].doc = "maximal rate an interface can drive (in MBits/sec)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_interface_define_max_if_rate_mbps].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_interface_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch interface tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * interface features
 */
int
dnx_data_sch_interface_feature_get(
    int unit,
    dnx_data_sch_interface_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_interface, feature);
}

/*
 * interface defines
 */
uint32
dnx_data_sch_interface_nof_big_calendars_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_interface, dnx_data_sch_interface_define_nof_big_calendars);
}

uint32
dnx_data_sch_interface_big_calendar_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_interface, dnx_data_sch_interface_define_big_calendar_size);
}

uint32
dnx_data_sch_interface_nof_sch_interfaces_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_interface, dnx_data_sch_interface_define_nof_sch_interfaces);
}

uint32
dnx_data_sch_interface_cal_speed_resolution_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_interface, dnx_data_sch_interface_define_cal_speed_resolution);
}

uint32
dnx_data_sch_interface_shaper_resolution_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_interface, dnx_data_sch_interface_define_shaper_resolution);
}

uint32
dnx_data_sch_interface_max_if_rate_mbps_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_interface, dnx_data_sch_interface_define_max_if_rate_mbps);
}

/*
 * interface tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - DEVICE:
 * {
 */
/*
 * device init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_device_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "device";
    submodule_data->doc = "DRM information";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_device_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch device features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_device_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch device defines");

    submodule_data->defines[dnx_data_sch_device_define_drm_resolution].name = "drm_resolution";
    submodule_data->defines[dnx_data_sch_device_define_drm_resolution].doc = "resolution of DRM rate";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_device_define_drm_resolution].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_device_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch device tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * device features
 */
int
dnx_data_sch_device_feature_get(
    int unit,
    dnx_data_sch_device_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_device, feature);
}

/*
 * device defines
 */
uint32
dnx_data_sch_device_drm_resolution_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_device, dnx_data_sch_device_define_drm_resolution);
}

/*
 * device tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - SCH_ALLOC:
 * {
 */
/*
 * sch_alloc init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_sch_alloc_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "sch_alloc";
    submodule_data->doc = "e2e scheduler allocation defines";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_sch_alloc_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch sch_alloc features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_sch_alloc_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch sch_alloc defines");

    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_2].name = "tag_aggregate_se_2";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_2].doc = "2 SE aggregate tag";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_2].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_4].name = "tag_aggregate_se_4";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_4].doc = "4 SE aggregate tag";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_4].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_8].name = "tag_aggregate_se_8";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_8].doc = "8 SE aggregate tag";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_aggregate_se_8].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_shared_shaper_max_tag_value].name = "shared_shaper_max_tag_value";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_shared_shaper_max_tag_value].doc = "max tag value for shared shaper";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_shared_shaper_max_tag_value].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_size_aggregate_se].name = "tag_size_aggregate_se";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_size_aggregate_se].doc = "tag size for SE aggregate";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_size_aggregate_se].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_size_con].name = "tag_size_con";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_size_con].doc = "tag size for connectors - modid";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_tag_size_con].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_con_reg_start].name = "type_con_reg_start";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_con_reg_start].doc = "searching start of the contiguous region";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_con_reg_start].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_con_reg_end].name = "type_con_reg_end";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_con_reg_end].doc = "searching end of the contiguous region";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_con_reg_end].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_hr_reg_start].name = "type_hr_reg_start";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_hr_reg_start].doc = "earching start of the HR region";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_type_hr_reg_start].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_alloc_invalid_flow].name = "alloc_invalid_flow";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_alloc_invalid_flow].doc = "invalid flow define";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_alloc_invalid_flow].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_sch_alloc_define_dealloc_flow_ids].name = "dealloc_flow_ids";
    submodule_data->defines[dnx_data_sch_sch_alloc_define_dealloc_flow_ids].doc = "max number of flows to deallocate";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_sch_alloc_define_dealloc_flow_ids].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_sch_alloc_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch sch_alloc tables");

    /*
     * Table - region
     */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].name = "region";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].doc = "content of quartet in each region type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].size_of_values = sizeof(dnx_data_sch_sch_alloc_region_t);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].entry_get = dnx_data_sch_sch_alloc_region_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].nof_keys = 1;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].keys[0].name = "region_type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].keys[0].doc = "region type";

    /* Values */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_sch_alloc_table_region].nof_values, "_dnx_data_sch_sch_alloc_table_region table values");
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values[0].name = "flow_type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values[0].type = "dnx_sch_element_se_type_e[4]";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values[0].doc = "list of elements in quartet";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_region_t, flow_type);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values[1].name = "odd_even_mode";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values[1].type = "dnx_scheduler_region_odd_even_mode_t";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values[1].doc = "Odd/even mode";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_region].values[1].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_region_t, odd_even_mode);

    /*
     * Table - connector
     */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].name = "connector";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].doc = "allocation info for VOQ connectors";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].size_of_values = sizeof(dnx_data_sch_sch_alloc_connector_t);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].entry_get = dnx_data_sch_sch_alloc_connector_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].nof_keys = 2;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].keys[0].name = "composite";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].keys[0].doc = "is composite connector";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].keys[1].name = "interdigitated";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].keys[1].doc = "is interdigitated";

    /* Values */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].nof_values = 4;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].nof_values, "_dnx_data_sch_sch_alloc_table_connector table values");
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[0].name = "alignment";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[0].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[0].doc = "alignment requirement";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_connector_t, alignment);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[1].name = "pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[1].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[1].doc = "allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[1].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_connector_t, pattern);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[2].name = "pattern_size";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[2].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[2].doc = "size of allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[2].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_connector_t, pattern_size);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[3].name = "nof_in_pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[3].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[3].doc = "number of elements in allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_connector].values[3].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_connector_t, nof_in_pattern);

    /*
     * Table - se_per_region_type
     */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].name = "se_per_region_type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].doc = "allocation info for scheduling elements per region type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].size_of_values = sizeof(dnx_data_sch_sch_alloc_se_per_region_type_t);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].entry_get = dnx_data_sch_sch_alloc_se_per_region_type_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].nof_keys = 2;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].keys[0].name = "flow_type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].keys[0].doc = "type of element";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].keys[1].name = "region_type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].keys[1].doc = "type of region";

    /* Values */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].nof_values = 6;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].nof_values, "_dnx_data_sch_sch_alloc_table_se_per_region_type table values");
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[0].name = "valid";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[0].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[0].doc = "is the entry valid. In case the entry is not valid, the data is taken from se table";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_per_region_type_t, valid);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[1].name = "alignment";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[1].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[1].doc = "alignment requirement";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[1].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_per_region_type_t, alignment);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[2].name = "pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[2].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[2].doc = "allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[2].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_per_region_type_t, pattern);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[3].name = "pattern_size";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[3].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[3].doc = "size of allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[3].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_per_region_type_t, pattern_size);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[4].name = "nof_offsets";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[4].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[4].doc = "size offset array";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[4].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_per_region_type_t, nof_offsets);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[5].name = "offset";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[5].type = "uint32[4]";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[5].doc = "list of offsets";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se_per_region_type].values[5].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_per_region_type_t, offset);

    /*
     * Table - se
     */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].name = "se";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].doc = "allocation info for scheduling elements";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].size_of_values = sizeof(dnx_data_sch_sch_alloc_se_t);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].entry_get = dnx_data_sch_sch_alloc_se_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].nof_keys = 1;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].keys[0].name = "flow_type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].keys[0].doc = "type of element";

    /* Values */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].nof_values = 5;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_sch_alloc_table_se].nof_values, "_dnx_data_sch_sch_alloc_table_se table values");
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[0].name = "alignment";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[0].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[0].doc = "alignment requirement";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_t, alignment);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[1].name = "pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[1].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[1].doc = "allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[1].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_t, pattern);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[2].name = "pattern_size";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[2].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[2].doc = "size of allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[2].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_t, pattern_size);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[3].name = "nof_offsets";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[3].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[3].doc = "size offset array";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[3].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_t, nof_offsets);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[4].name = "offset";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[4].type = "uint32[4]";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[4].doc = "list of offsets";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_se].values[4].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_se_t, offset);

    /*
     * Table - composite_se
     */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].name = "composite_se";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].doc = "allocation info for composite scheduling elements";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].size_of_values = sizeof(dnx_data_sch_sch_alloc_composite_se_t);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].entry_get = dnx_data_sch_sch_alloc_composite_se_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].nof_keys = 2;
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].keys[0].name = "flow_type";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].keys[0].doc = "type of element";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].keys[1].name = "odd_even_mode";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].keys[1].doc = "odd or even region";

    /* Values */
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].nof_values = 3;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values, dnxc_data_value_t, submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].nof_values, "_dnx_data_sch_sch_alloc_table_composite_se table values");
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[0].name = "alignment";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[0].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[0].doc = "alignment requirement";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[0].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_composite_se_t, alignment);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[1].name = "pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[1].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[1].doc = "allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[1].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_composite_se_t, pattern);
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[2].name = "pattern_size";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[2].type = "uint32";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[2].doc = "size of allocation pattern";
    submodule_data->tables[dnx_data_sch_sch_alloc_table_composite_se].values[2].offset = UTILEX_OFFSETOF(dnx_data_sch_sch_alloc_composite_se_t, pattern_size);


exit:
    SHR_FUNC_EXIT;
}

/*
 * sch_alloc features
 */
int
dnx_data_sch_sch_alloc_feature_get(
    int unit,
    dnx_data_sch_sch_alloc_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, feature);
}

/*
 * sch_alloc defines
 */
uint32
dnx_data_sch_sch_alloc_tag_aggregate_se_2_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_tag_aggregate_se_2);
}

uint32
dnx_data_sch_sch_alloc_tag_aggregate_se_4_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_tag_aggregate_se_4);
}

uint32
dnx_data_sch_sch_alloc_tag_aggregate_se_8_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_tag_aggregate_se_8);
}

uint32
dnx_data_sch_sch_alloc_shared_shaper_max_tag_value_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_shared_shaper_max_tag_value);
}

uint32
dnx_data_sch_sch_alloc_tag_size_aggregate_se_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_tag_size_aggregate_se);
}

uint32
dnx_data_sch_sch_alloc_tag_size_con_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_tag_size_con);
}

uint32
dnx_data_sch_sch_alloc_type_con_reg_start_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_type_con_reg_start);
}

uint32
dnx_data_sch_sch_alloc_type_con_reg_end_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_type_con_reg_end);
}

uint32
dnx_data_sch_sch_alloc_type_hr_reg_start_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_type_hr_reg_start);
}

uint32
dnx_data_sch_sch_alloc_alloc_invalid_flow_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_alloc_invalid_flow);
}

uint32
dnx_data_sch_sch_alloc_dealloc_flow_ids_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_define_dealloc_flow_ids);
}

/*
 * sch_alloc tables
 */
/* Table Get */
const dnx_data_sch_sch_alloc_region_t *
dnx_data_sch_sch_alloc_region_get(
    int unit,
    int region_type)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_region);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, region_type, 0);
    return (const dnx_data_sch_sch_alloc_region_t *) data;

}

const dnx_data_sch_sch_alloc_connector_t *
dnx_data_sch_sch_alloc_connector_get(
    int unit,
    int composite,
    int interdigitated)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_connector);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, composite, interdigitated);
    return (const dnx_data_sch_sch_alloc_connector_t *) data;

}

const dnx_data_sch_sch_alloc_se_per_region_type_t *
dnx_data_sch_sch_alloc_se_per_region_type_get(
    int unit,
    int flow_type,
    int region_type)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_se_per_region_type);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, flow_type, region_type);
    return (const dnx_data_sch_sch_alloc_se_per_region_type_t *) data;

}

const dnx_data_sch_sch_alloc_se_t *
dnx_data_sch_sch_alloc_se_get(
    int unit,
    int flow_type)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_se);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, flow_type, 0);
    return (const dnx_data_sch_sch_alloc_se_t *) data;

}

const dnx_data_sch_sch_alloc_composite_se_t *
dnx_data_sch_sch_alloc_composite_se_get(
    int unit,
    int flow_type,
    int odd_even_mode)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_composite_se);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, flow_type, odd_even_mode);
    return (const dnx_data_sch_sch_alloc_composite_se_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_sch_sch_alloc_region_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_sch_alloc_region_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_region);
    data = (const dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            DNXC_DATA_MGMT_ARR_STR(buffer, 4, data->flow_type);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->odd_even_mode);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_sch_sch_alloc_connector_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_sch_alloc_connector_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_connector);
    data = (const dnx_data_sch_sch_alloc_connector_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, key1);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->alignment);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pattern);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pattern_size);
            break;
        case 3:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->nof_in_pattern);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_sch_sch_alloc_se_per_region_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_sch_alloc_se_per_region_type_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_se_per_region_type);
    data = (const dnx_data_sch_sch_alloc_se_per_region_type_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, key1);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->valid);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->alignment);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pattern);
            break;
        case 3:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pattern_size);
            break;
        case 4:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->nof_offsets);
            break;
        case 5:
            DNXC_DATA_MGMT_ARR_STR(buffer, 4, data->offset);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_sch_sch_alloc_se_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_sch_alloc_se_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_se);
    data = (const dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->alignment);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pattern);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pattern_size);
            break;
        case 3:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->nof_offsets);
            break;
        case 4:
            DNXC_DATA_MGMT_ARR_STR(buffer, 4, data->offset);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_sch_sch_alloc_composite_se_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_sch_sch_alloc_composite_se_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_composite_se);
    data = (const dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, key1);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->alignment);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pattern);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pattern_size);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_sch_sch_alloc_region_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_region);

}

const dnxc_data_table_info_t *
dnx_data_sch_sch_alloc_connector_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_connector);

}

const dnxc_data_table_info_t *
dnx_data_sch_sch_alloc_se_per_region_type_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_se_per_region_type);

}

const dnxc_data_table_info_t *
dnx_data_sch_sch_alloc_se_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_se);

}

const dnxc_data_table_info_t *
dnx_data_sch_sch_alloc_composite_se_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_sch_alloc, dnx_data_sch_sch_alloc_table_composite_se);

}

/*
 * }
 */

/*
 * SUBMODULE - DBAL:
 * {
 */
/*
 * dbal init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_dbal_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "dbal";
    submodule_data->doc = "e2e scheduler dbal defines";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_dbal_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch dbal features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_dbal_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch dbal defines");

    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_grouping_factor].name = "scheduler_enable_grouping_factor";
    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_grouping_factor].doc = "size of group of sched elements sharing the same HW field ";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_grouping_factor].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_dbal_mult_factor].name = "scheduler_enable_dbal_mult_factor";
    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_dbal_mult_factor].doc = "DBAL multiplication factor";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_dbal_mult_factor].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_key_size].name = "scheduler_enable_key_size";
    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_key_size].doc = "size in bits of key in scheduler enable DBAL table";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_scheduler_enable_key_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_flow_id_pair_key_size].name = "flow_id_pair_key_size";
    submodule_data->defines[dnx_data_sch_dbal_define_flow_id_pair_key_size].doc = "size in bits of half flow id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_flow_id_pair_key_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_flow_id_pair_max].name = "flow_id_pair_max";
    submodule_data->defines[dnx_data_sch_dbal_define_flow_id_pair_max].doc = "max value of half flow id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_flow_id_pair_max].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_flow_bits].name = "flow_bits";
    submodule_data->defines[dnx_data_sch_dbal_define_flow_bits].doc = "Number of bits in flow id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_flow_bits].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_se_bits].name = "se_bits";
    submodule_data->defines[dnx_data_sch_dbal_define_se_bits].doc = "Number of bits in Scheduling element id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_se_bits].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_cl_bits].name = "cl_bits";
    submodule_data->defines[dnx_data_sch_dbal_define_cl_bits].doc = "Number of bits in CL id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_cl_bits].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_hr_bits].name = "hr_bits";
    submodule_data->defines[dnx_data_sch_dbal_define_hr_bits].doc = "Number of bits in HR id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_hr_bits].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_ps_bits].name = "ps_bits";
    submodule_data->defines[dnx_data_sch_dbal_define_ps_bits].doc = "Number of bits in PS id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_ps_bits].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_sch_dbal_define_interface_bits].name = "interface_bits";
    submodule_data->defines[dnx_data_sch_dbal_define_interface_bits].doc = "Number of bits in interface id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_sch_dbal_define_interface_bits].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_dbal_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch dbal tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * dbal features
 */
int
dnx_data_sch_dbal_feature_get(
    int unit,
    dnx_data_sch_dbal_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, feature);
}

/*
 * dbal defines
 */
uint32
dnx_data_sch_dbal_scheduler_enable_grouping_factor_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_scheduler_enable_grouping_factor);
}

uint32
dnx_data_sch_dbal_scheduler_enable_dbal_mult_factor_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_scheduler_enable_dbal_mult_factor);
}

uint32
dnx_data_sch_dbal_scheduler_enable_key_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_scheduler_enable_key_size);
}

uint32
dnx_data_sch_dbal_flow_id_pair_key_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_flow_id_pair_key_size);
}

uint32
dnx_data_sch_dbal_flow_id_pair_max_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_flow_id_pair_max);
}

uint32
dnx_data_sch_dbal_flow_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_flow_bits);
}

uint32
dnx_data_sch_dbal_se_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_se_bits);
}

uint32
dnx_data_sch_dbal_cl_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_cl_bits);
}

uint32
dnx_data_sch_dbal_hr_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_hr_bits);
}

uint32
dnx_data_sch_dbal_ps_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_ps_bits);
}

uint32
dnx_data_sch_dbal_interface_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_dbal, dnx_data_sch_dbal_define_interface_bits);
}

/*
 * dbal tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - HW_WORKAROUNDS:
 * {
 */
/*
 * hw_workarounds init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_sch_hw_workarounds_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "hw_workarounds";
    submodule_data->doc = "All devices workarounds";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_sch_hw_workarounds_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data sch hw_workarounds features");

    submodule_data->features[dnx_data_sch_hw_workarounds_dlm].name = "dlm";
    submodule_data->features[dnx_data_sch_hw_workarounds_dlm].doc = "Set couple of DLM registers to their MAX value due to hardware bug(HWJERICHO2-2480).";
    submodule_data->features[dnx_data_sch_hw_workarounds_dlm].flags |= DNXC_DATA_F_FEATURE;

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_sch_hw_workarounds_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data sch hw_workarounds defines");

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_sch_hw_workarounds_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data sch hw_workarounds tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * hw_workarounds features
 */
int
dnx_data_sch_hw_workarounds_feature_get(
    int unit,
    dnx_data_sch_hw_workarounds_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_sch, dnx_data_sch_submodule_hw_workarounds, feature);
}

/*
 * hw_workarounds defines
 */
/*
 * hw_workarounds tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

shr_error_e
dnx_data_sch_init(
    int unit,
    dnxc_data_module_t *module_data)
{
    SHR_FUNC_INIT_VARS(unit);

    /* Data Struct Init */
    module_data->name = "sch";
    module_data->nof_submodules = _dnx_data_sch_submodule_nof;
    DNXC_DATA_ALLOC(module_data->submodules, dnxc_data_submodule_t, module_data->nof_submodules, "_dnxc_data sch submodules");

    /*
     * Init Submodule data
     */
    SHR_IF_ERR_EXIT(dnx_data_sch_general_init(unit, &module_data->submodules[dnx_data_sch_submodule_general]));
    SHR_IF_ERR_EXIT(dnx_data_sch_ps_init(unit, &module_data->submodules[dnx_data_sch_submodule_ps]));
    SHR_IF_ERR_EXIT(dnx_data_sch_flow_init(unit, &module_data->submodules[dnx_data_sch_submodule_flow]));
    SHR_IF_ERR_EXIT(dnx_data_sch_se_init(unit, &module_data->submodules[dnx_data_sch_submodule_se]));
    SHR_IF_ERR_EXIT(dnx_data_sch_interface_init(unit, &module_data->submodules[dnx_data_sch_submodule_interface]));
    SHR_IF_ERR_EXIT(dnx_data_sch_device_init(unit, &module_data->submodules[dnx_data_sch_submodule_device]));
    SHR_IF_ERR_EXIT(dnx_data_sch_sch_alloc_init(unit, &module_data->submodules[dnx_data_sch_submodule_sch_alloc]));
    SHR_IF_ERR_EXIT(dnx_data_sch_dbal_init(unit, &module_data->submodules[dnx_data_sch_submodule_dbal]));
    SHR_IF_ERR_EXIT(dnx_data_sch_hw_workarounds_init(unit, &module_data->submodules[dnx_data_sch_submodule_hw_workarounds]));
    /*
     * Attach device module
     */
    if (dnxc_data_mgmt_is_jer2_a0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_sch_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_jer2_b0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_sch_attach(unit));
    }

exit:
    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
