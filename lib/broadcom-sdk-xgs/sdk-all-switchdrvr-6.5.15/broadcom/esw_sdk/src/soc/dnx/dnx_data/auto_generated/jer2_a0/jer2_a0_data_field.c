/** \file jer2_a0_data_field.c
 * 
 * DEVICE DATA - FIELD
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_FLDPROCDNX
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_field.h>
#include <bcm_int/dnx/field/field_context.h>
#include <bcm_int/dnx/field/field_map.h>
#include <shared/utilex/utilex_integer_arithmetic.h>
/*
 * }
 */

/*
 * EXTERN FUNCTIONS:
 * {
 */
/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: base_ipmf1
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_ffc
 * define info:
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_ffc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_ffc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ffc_groups
 * define info:
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_ffc_groups_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_ffc_groups;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_lower
 * define info:
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_ffc_group_one_lower_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_ffc_group_one_lower;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_upper
 * define info:
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_ffc_group_one_upper_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_ffc_group_one_upper;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 15;

    /* Set value */
    define->data = 15;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_two_lower
 * define info:
 * Min FFC Index for Second FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_ffc_group_two_lower_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_ffc_group_two_lower;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_two_upper
 * define info:
 * Max FFC Index for Second FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_ffc_group_two_upper_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_ffc_group_two_upper;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 31;

    /* Set value */
    define->data = 31;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_three_lower
 * define info:
 * Min FFC Index for Thirth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_ffc_group_three_lower_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_ffc_group_three_lower;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_three_upper
 * define info:
 * Max FFC Index for Thirth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_ffc_group_three_upper_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_ffc_group_three_upper;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 47;

    /* Set value */
    define->data = 47;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_four_lower
 * define info:
 * Min FFC Index for Fourth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_ffc_group_four_lower_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_ffc_group_four_lower;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 48;

    /* Set value */
    define->data = 48;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_four_upper
 * define info:
 * Max FFC Index for Fourth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_ffc_group_four_upper_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_ffc_group_four_upper;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 63;

    /* Set value */
    define->data = 63;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys
 * define info:
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_keys_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_keys;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 10;

    /* Set value */
    define->data = 10;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_keys_alloc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_keys_alloc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_tcam
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_keys_alloc_for_tcam_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_tcam;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_exem
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_keys_alloc_for_exem_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_exem;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_masks_per_fes
 * define info:
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_masks_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_masks_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_id_per_array
 * define info:
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fes_id_per_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fes_id_per_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_array
 * define info:
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fes_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fes_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_instruction_per_context
 * define info:
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fes_instruction_per_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fes_instruction_per_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_fes_id_per_array_get(unit)*dnx_data_field.base_ipmf1.nof_fes_array_get(unit));

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_fes_id_per_array_get(unit)*dnx_data_field.base_ipmf1.nof_fes_array_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_programs
 * define info:
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fes_programs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fes_programs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_prog_per_fes
 * define info:
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_prog_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_prog_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define program_selection_cam_mask_nof_bits
 * define info:
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_program_selection_cam_mask_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_program_selection_cam_mask_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 95;

    /* Set value */
    define->data = 95;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_contexts
 * define info:
 * Number of Ingress PMF_A programs (contexts). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_contexts_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_contexts;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_link_profiles
 * define info:
 * Number of profiles assigned to iPMF1 contexts in order to create links between iPMF1 and iPMF2 contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_link_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_link_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_cs_lines
 * define info:
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_cs_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_cs_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_actions
 * define info:
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_actions_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_actions;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_qualifiers
 * define info:
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_qualifiers_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_qualifiers;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_80B_zones
 * define info:
 * Number of Ingress PMF 80b dedicated instruction groupsv
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_80B_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_80B_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zones
 * define info:
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_key_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_key_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zone_bits
 * define info:
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_key_zone_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_key_zone_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 80;

    /* Set value */
    define->data = 80;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_action
 * define info:
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fes_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fes_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_key_select
 * define info:
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fes_key_select_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fes_key_select;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_key_selects_on_one_actions_line
 * define info:
 * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fes_key_selects_on_one_actions_line_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fes_key_selects_on_one_actions_line;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fem_condition_ms_bit_min_value
 * define info:
 * The minumum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_fem_condition_ms_bit_min_value_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_fem_condition_ms_bit_min_value;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fem_condition_ms_bit_max_value
 * define info:
 * The maximum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_fem_condition_ms_bit_max_value_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_fem_condition_ms_bit_max_value;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 31;

    /* Set value */
    define->data = 31;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_programs
 * define info:
 * Number of bit in FEM program representation. This is log2 of the number of fem programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_programs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_programs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fem_programs
 * define info:
 * Total number FEM programs available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fem_programs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fem_programs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_field.base_ipmf1.nof_bits_in_fem_programs_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_field.base_ipmf1.nof_bits_in_fem_programs_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define log_nof_bits_in_fem_key_select
 * define info:
 * Log2 of number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_log_nof_bits_in_fem_key_select_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_log_nof_bits_in_fem_key_select;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_key_select
 * define info:
 * Number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_key_select_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_key_select;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_field.base_ipmf1.log_nof_bits_in_fem_key_select_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_field.base_ipmf1.log_nof_bits_in_fem_key_select_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fem_key_select_resolution_in_bits
 * define info:
 * Number of bits in the 'step' from one 'key select' to the following. See dbal_enum_value_field_field_pmf_a_fem_key_select_e. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_fem_key_select_resolution_in_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_fem_key_select_resolution_in_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define log_nof_bits_in_fem_map_data_field
 * define info:
 * Log2 of number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_log_nof_bits_in_fem_map_data_field_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_log_nof_bits_in_fem_map_data_field;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_map_data_field
 * define info:
 * Number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_map_data_field_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_map_data_field;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_field.base_ipmf1.log_nof_bits_in_fem_map_data_field_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_field.base_ipmf1.log_nof_bits_in_fem_map_data_field_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_action_fems_2_15
 * define info:
 * Number of bits on action value in IPPC_FEM_*_24B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_2_15_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action_fems_2_15;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 24;

    /* Set value */
    define->data = 24;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_action_fems_0_1
 * define info:
 * Number of bits on action value in IPPC_FEM_*_4B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_0_1_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action_fems_0_1;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_action
 * define info:
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX(dnx_data_field.base_ipmf1.nof_bits_in_fem_action_fems_2_15_get(unit), dnx_data_field.base_ipmf1.nof_bits_in_fem_action_fems_0_1_get(unit));

    /* Set value */
    define->data = UTILEX_MAX(dnx_data_field.base_ipmf1.nof_bits_in_fem_action_fems_2_15_get(unit), dnx_data_field.base_ipmf1.nof_bits_in_fem_action_fems_0_1_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_condition
 * define info:
 * Number of bits on fem condition. This is log2 of the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_condition_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_condition;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fem_condition
 * define info:
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fem_condition_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fem_condition;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_field.base_ipmf1.nof_bits_in_fem_condition_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_field.base_ipmf1.nof_bits_in_fem_condition_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_map_index
 * define info:
 * Number of bits on fem map index. This represents log2 of the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_map_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_map_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fem_map_index
 * define info:
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fem_map_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fem_map_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_field.base_ipmf1.nof_bits_in_fem_map_index_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_field.base_ipmf1.nof_bits_in_fem_map_index_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_id
 * define info:
 * Number of bits on fem identifier. This represents the number of FEMs in the system: No. of FEMs is 2^nof_bits_in_fem_id. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fem_id
 * define info:
 * Total number 'FEM id's available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fem_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fem_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_field.base_ipmf1.nof_bits_in_fem_id_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_field.base_ipmf1.nof_bits_in_fem_id_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define num_fems_with_short_action
 * define info:
 * Number of FEMs, starting from 'fem_id=0', which have only 4 bits on action value. The rest have 24 bits on action value. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_num_fems_with_short_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_num_fems_with_short_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define num_bits_in_fem_field_select
 * define info:
 * Number of bits on each of the HW field marked FIELD_SELECT_MAP_*. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_num_bits_in_fem_field_select_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_num_bits_in_fem_field_select;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fem_id_per_array
 * define info:
 * Number FEMes in each FEM array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fem_id_per_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fem_id_per_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fem_array
 * define info:
 * Number FEM arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fem_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fem_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fems_per_context
 * define info:
 * Number of FEMs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_fems_per_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_fems_per_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.base_ipmf1.nof_fem_id_per_array_get(unit) * dnx_data_field.base_ipmf1.nof_fem_array_get(unit);

    /* Set value */
    define->data = dnx_data_field.base_ipmf1.nof_fem_id_per_array_get(unit) * dnx_data_field.base_ipmf1.nof_fem_array_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_strength
 * define info:
 * Default value for PMF strength. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_default_strength_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_default_strength;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_compare_pairs_in_compare_mode
 * define info:
 * Number compare pairs in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_compare_pairs_in_compare_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_compare_pairs_in_compare_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_compare_keys_in_compare_mode
 * define info:
 * Number compare keys in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_compare_keys_in_compare_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_compare_keys_in_compare_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define compare_key_size
 * define info:
 * Size of the compare key in the system. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_compare_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_compare_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_l4_ops_ranges
 * define info:
 * Number of ranges for L4 Ops. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_l4_ops_ranges_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_l4_ops_ranges;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 24;

    /* Set value */
    define->data = 24;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_pkt_hdr_ranges
 * define info:
 * Number of ranges for PKT HDR. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_pkt_hdr_ranges_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_pkt_hdr_ranges;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_out_lif_ranges
 * define info:
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_nof_out_lif_ranges_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_nof_out_lif_ranges;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_key_select_for_zero_bit
 * define info:
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_fes_key_select_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_fes_key_select_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_shift_for_zero_bit
 * define info:
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_fes_shift_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_fes_shift_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cmp_selection
 * define info:
 * Compare selection for both keys of 2nd compare, See the CMP_SELECTION field in IPPC_PMF_GENERAL register for additional information. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf1_cmp_selection_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf1;
    int define_index = dnx_data_field_base_ipmf1_define_cmp_selection;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xF;

    /* Set value */
    define->data = 0xF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: base_ipmf2
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_ffc
 * define info:
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_ffc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_ffc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ffc_groups
 * define info:
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_ffc_groups_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_ffc_groups;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_lower
 * define info:
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_ffc_group_one_lower_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_ffc_group_one_lower;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_upper
 * define info:
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_ffc_group_one_upper_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_ffc_group_one_upper;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 31;

    /* Set value */
    define->data = 31;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys
 * define info:
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_keys_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_keys;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_keys_alloc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_keys_alloc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_tcam
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_keys_alloc_for_tcam_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_tcam;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_exem
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_keys_alloc_for_exem_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_exem;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_dir_ext
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_keys_alloc_for_dir_ext_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_dir_ext;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_masks_per_fes
 * define info:
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_masks_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_masks_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_id_per_array
 * define info:
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_fes_id_per_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_fes_id_per_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_array
 * define info:
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_fes_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_fes_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_instruction_per_context
 * define info:
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_fes_instruction_per_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_fes_instruction_per_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf2.nof_fes_id_per_array_get(unit)*dnx_data_field.base_ipmf2.nof_fes_array_get(unit));

    /* Set value */
    define->data = (dnx_data_field.base_ipmf2.nof_fes_id_per_array_get(unit)*dnx_data_field.base_ipmf2.nof_fes_array_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_cs_lines
 * define info:
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_cs_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_cs_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_contexts
 * define info:
 * Number of contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_contexts_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_contexts;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define program_selection_cam_mask_nof_bits
 * define info:
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_program_selection_cam_mask_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_program_selection_cam_mask_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 95;

    /* Set value */
    define->data = 95;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_qualifiers
 * define info:
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_qualifiers_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_qualifiers;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_80B_zones
 * define info:
 * Number of Ingress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_80B_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_80B_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zones
 * define info:
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_key_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_key_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zone_bits
 * define info:
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_nof_key_zone_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_nof_key_zone_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 80;

    /* Set value */
    define->data = 80;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_key_select_for_zero_bit
 * define info:
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_fes_key_select_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_fes_key_select_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_shift_for_zero_bit
 * define info:
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf2_fes_shift_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf2;
    int define_index = dnx_data_field_base_ipmf2_define_fes_shift_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: base_ipmf3
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_ffc
 * define info:
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_ffc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_ffc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ffc_groups
 * define info:
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_ffc_groups_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_ffc_groups;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_lower
 * define info:
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_ffc_group_one_lower_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_ffc_group_one_lower;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_upper
 * define info:
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_ffc_group_one_upper_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_ffc_group_one_upper;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 31;

    /* Set value */
    define->data = 31;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys
 * define info:
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_keys_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_keys;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_keys_alloc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_keys_alloc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_tcam
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_keys_alloc_for_tcam_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_tcam;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_exem
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_keys_alloc_for_exem_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_exem;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_dir_ext
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_keys_alloc_for_dir_ext_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_dir_ext;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_masks_per_fes
 * define info:
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_masks_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_masks_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_id_per_array
 * define info:
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_fes_id_per_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_fes_id_per_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_array
 * define info:
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_fes_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_fes_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_instruction_per_context
 * define info:
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_fes_instruction_per_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_fes_instruction_per_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf3.nof_fes_id_per_array_get(unit)*dnx_data_field.base_ipmf3.nof_fes_array_get(unit));

    /* Set value */
    define->data = (dnx_data_field.base_ipmf3.nof_fes_id_per_array_get(unit)*dnx_data_field.base_ipmf3.nof_fes_array_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_programs
 * define info:
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_fes_programs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_fes_programs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_prog_per_fes
 * define info:
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_prog_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_prog_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define program_selection_cam_mask_nof_bits
 * define info:
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_program_selection_cam_mask_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_program_selection_cam_mask_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 95;

    /* Set value */
    define->data = 95;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_contexts
 * define info:
 * Number of Ingress PMF_B programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_contexts_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_contexts;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_cs_lines
 * define info:
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_cs_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_cs_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_actions
 * define info:
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_actions_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_actions;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_qualifiers
 * define info:
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_qualifiers_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_qualifiers;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_80B_zones
 * define info:
 * Number of Ingress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_80B_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_80B_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zones
 * define info:
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_key_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_key_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zone_bits
 * define info:
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_key_zone_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_key_zone_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 80;

    /* Set value */
    define->data = 80;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_action
 * define info:
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_bits_in_fes_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_bits_in_fes_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_key_select
 * define info:
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_bits_in_fes_key_select_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_bits_in_fes_key_select;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_key_selects_on_one_actions_line
 * define info:
 * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_fes_key_selects_on_one_actions_line_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_fes_key_selects_on_one_actions_line;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_strength
 * define info:
 * Default value for PMF strength. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_default_strength_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_default_strength;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_out_lif_ranges
 * define info:
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_nof_out_lif_ranges_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_nof_out_lif_ranges;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_key_select_for_zero_bit
 * define info:
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_fes_key_select_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_fes_key_select_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_shift_for_zero_bit
 * define info:
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ipmf3_fes_shift_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ipmf3;
    int define_index = dnx_data_field_base_ipmf3_define_fes_shift_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: base_epmf
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_ffc
 * define info:
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_ffc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_ffc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ffc_groups
 * define info:
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_ffc_groups_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_ffc_groups;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_lower
 * define info:
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_ffc_group_one_lower_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_ffc_group_one_lower;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_upper
 * define info:
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_ffc_group_one_upper_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_ffc_group_one_upper;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys
 * define info:
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_keys_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_keys;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_keys_alloc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_keys_alloc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_tcam
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_keys_alloc_for_tcam_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_keys_alloc_for_tcam;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_alloc_for_exem
 * define info:
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_keys_alloc_for_exem_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_keys_alloc_for_exem;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_masks_per_fes
 * define info:
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_masks_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_masks_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_id_per_array
 * define info:
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_fes_id_per_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_fes_id_per_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 12;

    /* Set value */
    define->data = 12;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_array
 * define info:
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_fes_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_fes_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_instruction_per_context
 * define info:
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_fes_instruction_per_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_fes_instruction_per_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_epmf.nof_fes_id_per_array_get(unit)*dnx_data_field.base_epmf.nof_fes_array_get(unit));

    /* Set value */
    define->data = (dnx_data_field.base_epmf.nof_fes_id_per_array_get(unit)*dnx_data_field.base_epmf.nof_fes_array_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_programs
 * define info:
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_fes_programs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_fes_programs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_prog_per_fes
 * define info:
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_prog_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_prog_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define program_selection_cam_mask_nof_bits
 * define info:
 * Number of bits for data or mask in the memory EGQ_PMF_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_program_selection_cam_mask_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_program_selection_cam_mask_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 37;

    /* Set value */
    define->data = 37;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_cs_lines
 * define info:
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_cs_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_cs_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_contexts
 * define info:
 * Number of Egress contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_contexts_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_contexts;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_actions
 * define info:
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_actions_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_actions;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_qualifiers
 * define info:
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_qualifiers_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_qualifiers;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_80B_zones
 * define info:
 * Number of Egress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_80B_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_80B_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zones
 * define info:
 * Number of Egress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_key_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_key_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zone_bits
 * define info:
 * Number of Egress PMF key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_key_zone_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_key_zone_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 80;

    /* Set value */
    define->data = 80;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_action
 * define info:
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_bits_in_fes_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_bits_in_fes_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_key_select
 * define info:
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_bits_in_fes_key_select_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_bits_in_fes_key_select;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_key_selects_on_one_actions_line
 * define info:
 * Number of 'key select's that can applied on one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_fes_key_selects_on_one_actions_line_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_fes_key_selects_on_one_actions_line;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_l4_ops_ranges
 * define info:
 * Number of ranges for L4 Ops. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_nof_l4_ops_ranges_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_nof_l4_ops_ranges;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 24;

    /* Set value */
    define->data = 24;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_key_select_for_zero_bit
 * define info:
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_fes_key_select_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_fes_key_select_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_shift_for_zero_bit
 * define info:
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_epmf_fes_shift_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_epmf;
    int define_index = dnx_data_field_base_epmf_define_fes_shift_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 60;

    /* Set value */
    define->data = 60;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: base_ifwd2
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_ffc
 * define info:
 * Number of FFC's in this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ifwd2_nof_ffc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ifwd2;
    int define_index = dnx_data_field_base_ifwd2_define_nof_ffc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 38;

    /* Set value */
    define->data = 38;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ffc_groups
 * define info:
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ifwd2_nof_ffc_groups_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ifwd2;
    int define_index = dnx_data_field_base_ifwd2_define_nof_ffc_groups;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_lower
 * define info:
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ifwd2_ffc_group_one_lower_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ifwd2;
    int define_index = dnx_data_field_base_ifwd2_define_ffc_group_one_lower;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ffc_group_one_upper
 * define info:
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ifwd2_ffc_group_one_upper_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ifwd2;
    int define_index = dnx_data_field_base_ifwd2_define_ffc_group_one_upper;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys
 * define info:
 * Number of keys available for allocation for use by this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ifwd2_nof_keys_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ifwd2;
    int define_index = dnx_data_field_base_ifwd2_define_nof_keys;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_contexts
 * define info:
 * Number of KBP ACL contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ifwd2_nof_contexts_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ifwd2;
    int define_index = dnx_data_field_base_ifwd2_define_nof_contexts;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_cs_lines
 * define info:
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_base_ifwd2_nof_cs_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_base_ifwd2;
    int define_index = dnx_data_field_base_ifwd2_define_nof_cs_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: stage
 */

/*
 * Features
 */
/*
 * Defines
 */
/*
 * Tables
 */
/**
 * \brief device level function which set values for table stage_info
 * Module - 'field', Submodule - 'stage', table - 'stage_info'
 * Per stage information
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_stage_stage_info_set(
    int unit)
{
    int stage_index;
    dnx_data_field_stage_stage_info_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_stage;
    int table_index = dnx_data_field_stage_table_stage_info;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_FIELD_STAGE_NOF;
    table->info_get.key_size[0] = DNX_FIELD_STAGE_NOF;

    /* Info - default values */
    table->values[0].default_val = "FALSE";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "0";
    table->values[5].default_val = "0";
    table->values[6].default_val = "0";
    table->values[7].default_val = "0";
    table->values[8].default_val = "0";
    table->values[9].default_val = "0";
    table->values[10].default_val = "0";
    table->values[11].default_val = "0";
    table->values[12].default_val = "0";
    table->values[13].default_val = "0";
    table->values[14].default_val = "0";
    table->values[15].default_val = "0";
    table->values[16].default_val = "0";
    table->values[17].default_val = "0";
    table->values[18].default_val = "0";
    table->values[19].default_val = "0";
    table->values[20].default_val = "0";
    table->values[21].default_val = "0";
    table->values[22].default_val = "0";
    table->values[23].default_val = "0";
    table->values[24].default_val = "0";
    table->values[25].default_val = "0";
    table->values[26].default_val = "0";
    table->values[27].default_val = "0";
    table->values[28].default_val = "0";
    table->values[29].default_val = "0";
    table->values[30].default_val = "0";
    table->values[31].default_val = "0";
    table->values[32].default_val = "0";
    table->values[33].default_val = "0";
    table->values[34].default_val = "0";
    table->values[35].default_val = "0";
    table->values[36].default_val = "0";
    table->values[37].default_val = "0";
    table->values[38].default_val = "0";
    table->values[39].default_val = "0";
    table->values[40].default_val = "0";
    table->values[41].default_val = "0";
    table->values[42].default_val = "0";
    table->values[43].default_val = "0";
    table->values[44].default_val = "0";
    table->values[45].default_val = "0";
    table->values[46].default_val = "0";
    table->values[47].default_val = "0";
    table->values[48].default_val = "0";
    table->values[49].default_val = "0";
    table->values[50].default_val = "0";
    table->values[51].default_val = "0";
    table->values[52].default_val = "0";
    table->values[53].default_val = "0";
    table->values[54].default_val = "0";
    table->values[55].default_val = "0";
    table->values[56].default_val = "0";
    table->values[57].default_val = "0";
    table->values[58].default_val = "0";
    table->values[59].default_val = "0";
    table->values[60].default_val = "0";
    table->values[61].default_val = "0";
    table->values[62].default_val = "0";
    table->values[63].default_val = "0";
    table->values[64].default_val = "0";
    table->values[65].default_val = "0";
    table->values[66].default_val = "0";
    table->values[67].default_val = "0";
    table->values[68].default_val = "0";
    table->values[69].default_val = "FALSE";
    table->values[70].default_val = "FALSE";
    table->values[71].default_val = "0";
    table->values[72].default_val = "0";
    table->values[73].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_stage_stage_info_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_field_stage_table_stage_info");

    /* Store Default Values */
    default_data = (dnx_data_field_stage_stage_info_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->valid = FALSE;
    default_data->nof_ffc = 0;
    default_data->nof_ffc_groups = 0;
    default_data->ffc_group_one_lower = 0;
    default_data->ffc_group_one_upper = 0;
    default_data->ffc_group_two_lower = 0;
    default_data->ffc_group_two_upper = 0;
    default_data->ffc_group_three_lower = 0;
    default_data->ffc_group_three_upper = 0;
    default_data->ffc_group_four_lower = 0;
    default_data->ffc_group_four_upper = 0;
    default_data->nof_keys = 0;
    default_data->nof_keys_alloc = 0;
    default_data->nof_keys_alloc_for_tcam = 0;
    default_data->nof_keys_alloc_for_exem = 0;
    default_data->nof_keys_alloc_for_dir_ext = 0;
    default_data->nof_masks_per_fes = 0;
    default_data->nof_fes_id_per_array = 0;
    default_data->nof_fes_array = 0;
    default_data->nof_fes_instruction_per_context = 0;
    default_data->nof_fes_programs = 0;
    default_data->nof_prog_per_fes = 0;
    default_data->program_selection_cam_mask_nof_bits = 0;
    default_data->nof_contexts = 0;
    default_data->nof_link_profiles = 0;
    default_data->nof_cs_lines = 0;
    default_data->nof_actions = 0;
    default_data->nof_qualifiers = 0;
    default_data->nof_80B_zones = 0;
    default_data->nof_key_zones = 0;
    default_data->nof_key_zone_bits = 0;
    default_data->nof_bits_in_fes_action = 0;
    default_data->nof_bits_in_fes_key_select = 0;
    default_data->nof_fes_key_selects_on_one_actions_line = 0;
    default_data->fem_condition_ms_bit_min_value = 0;
    default_data->fem_condition_ms_bit_max_value = 0;
    default_data->nof_bits_in_fem_programs = 0;
    default_data->nof_fem_programs = 0;
    default_data->log_nof_bits_in_fem_key_select = 0;
    default_data->nof_bits_in_fem_key_select = 0;
    default_data->fem_key_select_resolution_in_bits = 0;
    default_data->log_nof_bits_in_fem_map_data_field = 0;
    default_data->nof_bits_in_fem_map_data_field = 0;
    default_data->nof_bits_in_fem_action_fems_2_15 = 0;
    default_data->nof_bits_in_fem_action_fems_0_1 = 0;
    default_data->nof_bits_in_fem_action = 0;
    default_data->nof_bits_in_fem_condition = 0;
    default_data->nof_fem_condition = 0;
    default_data->nof_bits_in_fem_map_index = 0;
    default_data->nof_fem_map_index = 0;
    default_data->nof_bits_in_fem_id = 0;
    default_data->nof_fem_id = 0;
    default_data->num_fems_with_short_action = 0;
    default_data->num_bits_in_fem_field_select = 0;
    default_data->nof_fem_id_per_array = 0;
    default_data->nof_fem_array = 0;
    default_data->nof_fems_per_context = 0;
    default_data->default_strength = 0;
    default_data->pbus_header_length = 0;
    default_data->nof_layer_records = 0;
    default_data->layer_record_size = 0;
    default_data->nof_compare_pairs_in_compare_mode = 0;
    default_data->nof_compare_keys_in_compare_mode = 0;
    default_data->compare_key_size = 0;
    default_data->nof_l4_ops_ranges = 0;
    default_data->nof_pkt_hdr_ranges = 0;
    default_data->nof_out_lif_ranges = 0;
    default_data->fes_key_select_for_zero_bit = 0;
    default_data->fes_shift_for_zero_bit = 0;
    default_data->uses_small_exem = FALSE;
    default_data->uses_large_exem = FALSE;
    default_data->cmp_selection = 0;
    default_data->nof_bits_main_pbus = 0;
    default_data->nof_bits_native_pbus = 0;
    /* Set Default Values */
    for (stage_index = 0; stage_index < table->keys[0].size; stage_index++)
    {
        data = (dnx_data_field_stage_stage_info_t *) dnxc_data_mgmt_table_data_get(unit, table, stage_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_stage_stage_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF1, 0);
    data->valid = TRUE;
    data->nof_ffc = dnx_data_field.base_ipmf1.nof_ffc_get(unit);
    data->nof_ffc_groups = dnx_data_field.base_ipmf1.nof_ffc_groups_get(unit);
    data->ffc_group_one_lower = dnx_data_field.base_ipmf1.ffc_group_one_lower_get(unit);
    data->ffc_group_one_upper = dnx_data_field.base_ipmf1.ffc_group_one_upper_get(unit);
    data->ffc_group_two_lower = dnx_data_field.base_ipmf1.ffc_group_two_lower_get(unit);
    data->ffc_group_two_upper = dnx_data_field.base_ipmf1.ffc_group_two_upper_get(unit);
    data->ffc_group_three_lower = dnx_data_field.base_ipmf1.ffc_group_three_lower_get(unit);
    data->ffc_group_three_upper = dnx_data_field.base_ipmf1.ffc_group_three_upper_get(unit);
    data->ffc_group_four_lower = dnx_data_field.base_ipmf1.ffc_group_four_lower_get(unit);
    data->ffc_group_four_upper = dnx_data_field.base_ipmf1.ffc_group_four_upper_get(unit);
    data->nof_keys = dnx_data_field.base_ipmf1.nof_keys_get(unit);
    data->nof_keys_alloc = dnx_data_field.base_ipmf1.nof_keys_alloc_get(unit);
    data->nof_keys_alloc_for_tcam = dnx_data_field.base_ipmf1.nof_keys_alloc_for_tcam_get(unit);
    data->nof_keys_alloc_for_exem = dnx_data_field.base_ipmf1.nof_keys_alloc_for_exem_get(unit);
    data->nof_masks_per_fes = dnx_data_field.base_ipmf1.nof_masks_per_fes_get(unit);
    data->nof_fes_id_per_array = dnx_data_field.base_ipmf1.nof_fes_id_per_array_get(unit);
    data->nof_fes_array = dnx_data_field.base_ipmf1.nof_fes_array_get(unit);
    data->nof_fes_instruction_per_context = dnx_data_field.base_ipmf1.nof_fes_instruction_per_context_get(unit);
    data->nof_fes_programs = dnx_data_field.base_ipmf1.nof_fes_programs_get(unit);
    data->nof_prog_per_fes = dnx_data_field.base_ipmf1.nof_prog_per_fes_get(unit);
    data->program_selection_cam_mask_nof_bits = dnx_data_field.base_ipmf1.program_selection_cam_mask_nof_bits_get(unit);
    data->nof_contexts = dnx_data_field.base_ipmf1.nof_contexts_get(unit);
    data->nof_link_profiles = dnx_data_field.base_ipmf1.nof_link_profiles_get(unit);
    data->nof_cs_lines = dnx_data_field.base_ipmf1.nof_cs_lines_get(unit);
    data->nof_actions = dnx_data_field.base_ipmf1.nof_actions_get(unit);
    data->nof_qualifiers = dnx_data_field.base_ipmf1.nof_qualifiers_get(unit);
    data->nof_80B_zones = dnx_data_field.base_ipmf1.nof_80B_zones_get(unit);
    data->nof_key_zones = dnx_data_field.base_ipmf1.nof_key_zones_get(unit);
    data->nof_key_zone_bits = dnx_data_field.base_ipmf1.nof_key_zone_bits_get(unit);
    data->nof_bits_in_fes_action = dnx_data_field.base_ipmf1.nof_bits_in_fes_action_get(unit);
    data->nof_bits_in_fes_key_select = dnx_data_field.base_ipmf1.nof_bits_in_fes_key_select_get(unit);
    data->nof_fes_key_selects_on_one_actions_line = dnx_data_field.base_ipmf1.nof_fes_key_selects_on_one_actions_line_get(unit);
    data->fem_condition_ms_bit_min_value = dnx_data_field.base_ipmf1.fem_condition_ms_bit_min_value_get(unit);
    data->fem_condition_ms_bit_max_value = dnx_data_field.base_ipmf1.fem_condition_ms_bit_max_value_get(unit);
    data->nof_bits_in_fem_programs = dnx_data_field.base_ipmf1.nof_bits_in_fem_programs_get(unit);
    data->nof_fem_programs = dnx_data_field.base_ipmf1.nof_fem_programs_get(unit);
    data->log_nof_bits_in_fem_key_select = dnx_data_field.base_ipmf1.log_nof_bits_in_fem_key_select_get(unit);
    data->nof_bits_in_fem_key_select = dnx_data_field.base_ipmf1.nof_bits_in_fem_key_select_get(unit);
    data->fem_key_select_resolution_in_bits = dnx_data_field.base_ipmf1.fem_key_select_resolution_in_bits_get(unit);
    data->log_nof_bits_in_fem_map_data_field = dnx_data_field.base_ipmf1.log_nof_bits_in_fem_map_data_field_get(unit);
    data->nof_bits_in_fem_map_data_field = dnx_data_field.base_ipmf1.nof_bits_in_fem_map_data_field_get(unit);
    data->nof_bits_in_fem_action_fems_2_15 = dnx_data_field.base_ipmf1.nof_bits_in_fem_action_fems_2_15_get(unit);
    data->nof_bits_in_fem_action_fems_0_1 = dnx_data_field.base_ipmf1.nof_bits_in_fem_action_fems_0_1_get(unit);
    data->nof_bits_in_fem_action = dnx_data_field.base_ipmf1.nof_bits_in_fem_action_get(unit);
    data->nof_bits_in_fem_condition = dnx_data_field.base_ipmf1.nof_bits_in_fem_condition_get(unit);
    data->nof_fem_condition = dnx_data_field.base_ipmf1.nof_fem_condition_get(unit);
    data->nof_bits_in_fem_map_index = dnx_data_field.base_ipmf1.nof_bits_in_fem_map_index_get(unit);
    data->nof_fem_map_index = dnx_data_field.base_ipmf1.nof_fem_map_index_get(unit);
    data->nof_bits_in_fem_id = dnx_data_field.base_ipmf1.nof_bits_in_fem_id_get(unit);
    data->nof_fem_id = dnx_data_field.base_ipmf1.nof_fem_id_get(unit);
    data->num_fems_with_short_action = dnx_data_field.base_ipmf1.num_fems_with_short_action_get(unit);
    data->num_bits_in_fem_field_select = dnx_data_field.base_ipmf1.num_bits_in_fem_field_select_get(unit);
    data->nof_fem_id_per_array = dnx_data_field.base_ipmf1.nof_fem_id_per_array_get(unit);
    data->nof_fem_array = dnx_data_field.base_ipmf1.nof_fem_array_get(unit);
    data->nof_fems_per_context = dnx_data_field.base_ipmf1.nof_fems_per_context_get(unit);
    data->default_strength = dnx_data_field.base_ipmf1.default_strength_get(unit);
    data->pbus_header_length = dnx_data_field.qual.ingress_pbus_header_length_get(unit);
    data->nof_layer_records = dnx_data_field.qual.ingress_nof_layer_records_get(unit);
    data->layer_record_size = dnx_data_field.qual.ingress_layer_record_size_get(unit);
    data->nof_compare_pairs_in_compare_mode = dnx_data_field.base_ipmf1.nof_compare_pairs_in_compare_mode_get(unit);
    data->nof_compare_keys_in_compare_mode = dnx_data_field.base_ipmf1.nof_compare_keys_in_compare_mode_get(unit);
    data->compare_key_size = dnx_data_field.base_ipmf1.compare_key_size_get(unit);
    data->nof_l4_ops_ranges = dnx_data_field.base_ipmf1.nof_l4_ops_ranges_get(unit);
    data->nof_pkt_hdr_ranges = dnx_data_field.base_ipmf1.nof_pkt_hdr_ranges_get(unit);
    data->nof_out_lif_ranges = dnx_data_field.base_ipmf1.nof_out_lif_ranges_get(unit);
    data->fes_key_select_for_zero_bit = dnx_data_field.base_ipmf1.fes_key_select_for_zero_bit_get(unit);
    data->fes_shift_for_zero_bit = dnx_data_field.base_ipmf1.fes_shift_for_zero_bit_get(unit);
    data->uses_small_exem = FALSE;
    data->uses_large_exem = TRUE;
    data->cmp_selection = dnx_data_field.base_ipmf1.cmp_selection_get(unit);
    data->nof_bits_main_pbus = dnx_data_field.qual.ipmf1_pbus_size_get(unit);
    data = (dnx_data_field_stage_stage_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, 0);
    data->valid = TRUE;
    data->nof_ffc = dnx_data_field.base_ipmf2.nof_ffc_get(unit);
    data->nof_ffc_groups = dnx_data_field.base_ipmf2.nof_ffc_groups_get(unit);
    data->ffc_group_one_lower = dnx_data_field.base_ipmf2.ffc_group_one_lower_get(unit);
    data->ffc_group_one_upper = dnx_data_field.base_ipmf2.ffc_group_one_upper_get(unit);
    data->nof_keys = dnx_data_field.base_ipmf2.nof_keys_get(unit);
    data->nof_keys_alloc = dnx_data_field.base_ipmf2.nof_keys_alloc_get(unit);
    data->nof_keys_alloc_for_tcam = dnx_data_field.base_ipmf2.nof_keys_alloc_for_tcam_get(unit);
    data->nof_keys_alloc_for_exem = dnx_data_field.base_ipmf2.nof_keys_alloc_for_exem_get(unit);
    data->nof_keys_alloc_for_dir_ext = dnx_data_field.base_ipmf2.nof_keys_alloc_for_dir_ext_get(unit);
    data->nof_masks_per_fes = dnx_data_field.base_ipmf2.nof_masks_per_fes_get(unit);
    data->nof_fes_id_per_array = dnx_data_field.base_ipmf2.nof_fes_id_per_array_get(unit);
    data->nof_fes_array = dnx_data_field.base_ipmf2.nof_fes_array_get(unit);
    data->nof_fes_instruction_per_context = dnx_data_field.base_ipmf2.nof_fes_instruction_per_context_get(unit);
    data->nof_fes_programs = dnx_data_field.base_ipmf1.nof_fes_programs_get(unit);
    data->nof_prog_per_fes = dnx_data_field.base_ipmf1.nof_prog_per_fes_get(unit);
    data->program_selection_cam_mask_nof_bits = dnx_data_field.base_ipmf2.program_selection_cam_mask_nof_bits_get(unit);
    data->nof_contexts = dnx_data_field.base_ipmf2.nof_contexts_get(unit);
    data->nof_cs_lines = dnx_data_field.base_ipmf2.nof_cs_lines_get(unit);
    data->nof_qualifiers = dnx_data_field.base_ipmf2.nof_qualifiers_get(unit);
    data->nof_80B_zones = dnx_data_field.base_ipmf2.nof_80B_zones_get(unit);
    data->nof_key_zones = dnx_data_field.base_ipmf2.nof_key_zones_get(unit);
    data->nof_key_zone_bits = dnx_data_field.base_ipmf2.nof_key_zone_bits_get(unit);
    data->nof_bits_in_fes_action = dnx_data_field.base_ipmf1.nof_bits_in_fes_action_get(unit);
    data->nof_bits_in_fes_key_select = dnx_data_field.base_ipmf1.nof_bits_in_fes_key_select_get(unit);
    data->fem_condition_ms_bit_min_value = dnx_data_field.base_ipmf1.fem_condition_ms_bit_min_value_get(unit);
    data->fem_condition_ms_bit_max_value = dnx_data_field.base_ipmf1.fem_condition_ms_bit_max_value_get(unit);
    data->nof_bits_in_fem_programs = dnx_data_field.base_ipmf1.nof_bits_in_fem_programs_get(unit);
    data->nof_fem_programs = dnx_data_field.base_ipmf1.nof_fem_programs_get(unit);
    data->log_nof_bits_in_fem_key_select = dnx_data_field.base_ipmf1.log_nof_bits_in_fem_key_select_get(unit);
    data->nof_bits_in_fem_key_select = dnx_data_field.base_ipmf1.nof_bits_in_fem_key_select_get(unit);
    data->fem_key_select_resolution_in_bits = dnx_data_field.base_ipmf1.fem_key_select_resolution_in_bits_get(unit);
    data->log_nof_bits_in_fem_map_data_field = dnx_data_field.base_ipmf1.log_nof_bits_in_fem_map_data_field_get(unit);
    data->nof_bits_in_fem_map_data_field = dnx_data_field.base_ipmf1.nof_bits_in_fem_map_data_field_get(unit);
    data->nof_bits_in_fem_action_fems_2_15 = dnx_data_field.base_ipmf1.nof_bits_in_fem_action_fems_2_15_get(unit);
    data->nof_bits_in_fem_action_fems_0_1 = dnx_data_field.base_ipmf1.nof_bits_in_fem_action_fems_0_1_get(unit);
    data->nof_bits_in_fem_action = dnx_data_field.base_ipmf1.nof_bits_in_fem_action_get(unit);
    data->nof_bits_in_fem_condition = dnx_data_field.base_ipmf1.nof_bits_in_fem_condition_get(unit);
    data->nof_fem_condition = dnx_data_field.base_ipmf1.nof_fem_condition_get(unit);
    data->nof_bits_in_fem_map_index = dnx_data_field.base_ipmf1.nof_bits_in_fem_map_index_get(unit);
    data->nof_fem_map_index = dnx_data_field.base_ipmf1.nof_fem_map_index_get(unit);
    data->nof_bits_in_fem_id = dnx_data_field.base_ipmf1.nof_bits_in_fem_id_get(unit);
    data->nof_fem_id = dnx_data_field.base_ipmf1.nof_fem_id_get(unit);
    data->num_fems_with_short_action = dnx_data_field.base_ipmf1.num_fems_with_short_action_get(unit);
    data->num_bits_in_fem_field_select = dnx_data_field.base_ipmf1.num_bits_in_fem_field_select_get(unit);
    data->nof_fem_id_per_array = dnx_data_field.base_ipmf1.nof_fem_id_per_array_get(unit);
    data->nof_fem_array = dnx_data_field.base_ipmf1.nof_fem_array_get(unit);
    data->nof_fems_per_context = dnx_data_field.base_ipmf1.nof_fems_per_context_get(unit);
    data->pbus_header_length = dnx_data_field.qual.ingress_pbus_header_length_get(unit);
    data->nof_layer_records = dnx_data_field.qual.ingress_nof_layer_records_get(unit);
    data->layer_record_size = dnx_data_field.qual.ingress_layer_record_size_get(unit);
    data->fes_key_select_for_zero_bit = dnx_data_field.base_ipmf2.fes_key_select_for_zero_bit_get(unit);
    data->fes_shift_for_zero_bit = dnx_data_field.base_ipmf2.fes_shift_for_zero_bit_get(unit);
    data->uses_small_exem = TRUE;
    data->uses_large_exem = FALSE;
    data->nof_bits_main_pbus = dnx_data_field.qual.ipmf1_pbus_size_get(unit);
    data->nof_bits_native_pbus = dnx_data_field.qual.ipmf2_pbus_size_get(unit);
    data = (dnx_data_field_stage_stage_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, 0);
    data->valid = TRUE;
    data->nof_ffc = dnx_data_field.base_ipmf3.nof_ffc_get(unit);
    data->nof_ffc_groups = dnx_data_field.base_ipmf3.nof_ffc_groups_get(unit);
    data->ffc_group_one_lower = dnx_data_field.base_ipmf3.ffc_group_one_lower_get(unit);
    data->ffc_group_one_upper = dnx_data_field.base_ipmf3.ffc_group_one_upper_get(unit);
    data->nof_keys = dnx_data_field.base_ipmf3.nof_keys_get(unit);
    data->nof_keys_alloc = dnx_data_field.base_ipmf3.nof_keys_alloc_get(unit);
    data->nof_keys_alloc_for_tcam = dnx_data_field.base_ipmf3.nof_keys_alloc_for_tcam_get(unit);
    data->nof_keys_alloc_for_exem = dnx_data_field.base_ipmf3.nof_keys_alloc_for_exem_get(unit);
    data->nof_keys_alloc_for_dir_ext = dnx_data_field.base_ipmf3.nof_keys_alloc_for_dir_ext_get(unit);
    data->nof_masks_per_fes = dnx_data_field.base_ipmf3.nof_masks_per_fes_get(unit);
    data->nof_fes_id_per_array = dnx_data_field.base_ipmf3.nof_fes_id_per_array_get(unit);
    data->nof_fes_array = dnx_data_field.base_ipmf3.nof_fes_array_get(unit);
    data->nof_fes_instruction_per_context = dnx_data_field.base_ipmf3.nof_fes_instruction_per_context_get(unit);
    data->nof_fes_programs = dnx_data_field.base_ipmf3.nof_fes_programs_get(unit);
    data->nof_prog_per_fes = dnx_data_field.base_ipmf3.nof_prog_per_fes_get(unit);
    data->program_selection_cam_mask_nof_bits = dnx_data_field.base_ipmf3.program_selection_cam_mask_nof_bits_get(unit);
    data->nof_contexts = dnx_data_field.base_ipmf3.nof_contexts_get(unit);
    data->nof_cs_lines = dnx_data_field.base_ipmf3.nof_cs_lines_get(unit);
    data->nof_actions = dnx_data_field.base_ipmf3.nof_actions_get(unit);
    data->nof_qualifiers = dnx_data_field.base_ipmf3.nof_qualifiers_get(unit);
    data->nof_80B_zones = dnx_data_field.base_ipmf3.nof_80B_zones_get(unit);
    data->nof_key_zones = dnx_data_field.base_ipmf3.nof_key_zones_get(unit);
    data->nof_key_zone_bits = dnx_data_field.base_ipmf3.nof_key_zone_bits_get(unit);
    data->nof_bits_in_fes_action = dnx_data_field.base_ipmf3.nof_bits_in_fes_action_get(unit);
    data->nof_bits_in_fes_key_select = dnx_data_field.base_ipmf3.nof_bits_in_fes_key_select_get(unit);
    data->nof_fes_key_selects_on_one_actions_line = dnx_data_field.base_ipmf3.nof_fes_key_selects_on_one_actions_line_get(unit);
    data->default_strength = dnx_data_field.base_ipmf3.default_strength_get(unit);
    data->nof_layer_records = dnx_data_field.qual.ingress_nof_layer_records_get(unit);
    data->layer_record_size = dnx_data_field.qual.ingress_layer_record_size_get(unit);
    data->nof_out_lif_ranges = dnx_data_field.base_ipmf3.nof_out_lif_ranges_get(unit);
    data->fes_key_select_for_zero_bit = dnx_data_field.base_ipmf3.fes_key_select_for_zero_bit_get(unit);
    data->fes_shift_for_zero_bit = dnx_data_field.base_ipmf3.fes_shift_for_zero_bit_get(unit);
    data->uses_small_exem = TRUE;
    data->uses_large_exem = FALSE;
    data->nof_bits_main_pbus = dnx_data_field.qual.ipmf3_pbus_size_get(unit);
    data = (dnx_data_field_stage_stage_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_EPMF, 0);
    data->valid = TRUE;
    data->nof_ffc = dnx_data_field.base_epmf.nof_ffc_get(unit);
    data->nof_ffc_groups = dnx_data_field.base_epmf.nof_ffc_groups_get(unit);
    data->ffc_group_one_lower = dnx_data_field.base_epmf.ffc_group_one_lower_get(unit);
    data->ffc_group_one_upper = dnx_data_field.base_epmf.ffc_group_one_upper_get(unit);
    data->nof_keys = dnx_data_field.base_epmf.nof_keys_get(unit);
    data->nof_keys_alloc = dnx_data_field.base_epmf.nof_keys_alloc_get(unit);
    data->nof_keys_alloc_for_tcam = dnx_data_field.base_epmf.nof_keys_alloc_for_tcam_get(unit);
    data->nof_keys_alloc_for_exem = dnx_data_field.base_epmf.nof_keys_alloc_for_exem_get(unit);
    data->nof_masks_per_fes = dnx_data_field.base_epmf.nof_masks_per_fes_get(unit);
    data->nof_fes_id_per_array = dnx_data_field.base_epmf.nof_fes_id_per_array_get(unit);
    data->nof_fes_array = dnx_data_field.base_epmf.nof_fes_array_get(unit);
    data->nof_fes_instruction_per_context = dnx_data_field.base_epmf.nof_fes_instruction_per_context_get(unit);
    data->nof_fes_programs = dnx_data_field.base_epmf.nof_fes_programs_get(unit);
    data->nof_prog_per_fes = dnx_data_field.base_epmf.nof_prog_per_fes_get(unit);
    data->program_selection_cam_mask_nof_bits = dnx_data_field.base_epmf.program_selection_cam_mask_nof_bits_get(unit);
    data->nof_contexts = dnx_data_field.base_epmf.nof_contexts_get(unit);
    data->nof_cs_lines = dnx_data_field.base_epmf.nof_cs_lines_get(unit);
    data->nof_actions = dnx_data_field.base_epmf.nof_actions_get(unit);
    data->nof_qualifiers = dnx_data_field.base_epmf.nof_qualifiers_get(unit);
    data->nof_80B_zones = dnx_data_field.base_epmf.nof_80B_zones_get(unit);
    data->nof_key_zones = dnx_data_field.base_epmf.nof_key_zones_get(unit);
    data->nof_key_zone_bits = dnx_data_field.base_epmf.nof_key_zone_bits_get(unit);
    data->nof_bits_in_fes_action = dnx_data_field.base_epmf.nof_bits_in_fes_action_get(unit);
    data->nof_bits_in_fes_key_select = dnx_data_field.base_epmf.nof_bits_in_fes_key_select_get(unit);
    data->nof_fes_key_selects_on_one_actions_line = dnx_data_field.base_epmf.nof_fes_key_selects_on_one_actions_line_get(unit);
    data->pbus_header_length = dnx_data_field.qual.egress_pbus_header_length_get(unit);
    data->nof_layer_records = dnx_data_field.qual.egress_nof_layer_records_get(unit);
    data->layer_record_size = dnx_data_field.qual.egress_layer_record_size_get(unit);
    data->nof_l4_ops_ranges = dnx_data_field.base_epmf.nof_l4_ops_ranges_get(unit);
    data->fes_key_select_for_zero_bit = dnx_data_field.base_epmf.fes_key_select_for_zero_bit_get(unit);
    data->fes_shift_for_zero_bit = dnx_data_field.base_epmf.fes_shift_for_zero_bit_get(unit);
    data->uses_small_exem = FALSE;
    data->uses_large_exem = TRUE;
    data->nof_bits_main_pbus = dnx_data_field.qual.epmf_pbus_size_get(unit);
    data = (dnx_data_field_stage_stage_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_EXTERNAL, 0);
    data->valid = TRUE;
    data->nof_ffc = dnx_data_field.base_ifwd2.nof_ffc_get(unit);
    data->nof_ffc_groups = dnx_data_field.base_ifwd2.nof_ffc_groups_get(unit);
    data->ffc_group_one_lower = dnx_data_field.base_ifwd2.ffc_group_one_lower_get(unit);
    data->ffc_group_one_upper = dnx_data_field.base_ifwd2.ffc_group_one_upper_get(unit);
    data->nof_keys = dnx_data_field.base_ifwd2.nof_keys_get(unit);
    data->nof_contexts = dnx_data_field.base_ifwd2.nof_contexts_get(unit);
    data->nof_cs_lines = dnx_data_field.base_ifwd2.nof_cs_lines_get(unit);
    data->pbus_header_length = dnx_data_field.qual.ingress_pbus_header_length_get(unit);
    data->nof_layer_records = dnx_data_field.qual.ingress_nof_layer_records_get(unit);
    data->layer_record_size = dnx_data_field.qual.ingress_layer_record_size_get(unit);
    data->nof_bits_main_pbus = dnx_data_field.qual.ifwd2_pbus_size_get(unit);
    data = (dnx_data_field_stage_stage_info_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_ACE, 0);
    data->valid = TRUE;
    data->nof_masks_per_fes = dnx_data_field.ace.nof_masks_per_fes_get(unit);
    data->nof_fes_id_per_array = dnx_data_field.ace.nof_fes_id_per_array_get(unit);
    data->nof_fes_array = dnx_data_field.ace.nof_fes_array_get(unit);
    data->nof_fes_instruction_per_context = dnx_data_field.ace.nof_fes_instruction_per_context_get(unit);
    data->nof_fes_programs = dnx_data_field.ace.nof_fes_programs_get(unit);
    data->nof_prog_per_fes = dnx_data_field.ace.nof_prog_per_fes_get(unit);
    data->nof_bits_in_fes_action = dnx_data_field.ace.nof_bits_in_fes_action_get(unit);
    data->fes_shift_for_zero_bit = dnx_data_field.ace.fes_shift_for_zero_bit_get(unit);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: kbp
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_fgs
 * define info:
 * Number of External TCAM Field Groups
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_nof_fgs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_nof_fgs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_master_key_size
 * define info:
 * Maximum Master key size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_max_master_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_max_master_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 320;

    /* Set value */
    define->data = 320;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_single_key_size
 * define info:
 * Maximum single key size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_max_single_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_max_single_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 160;

    /* Set value */
    define->data = 160;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_acl_keys_master_max
 * define info:
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single context
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_nof_acl_keys_master_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_nof_acl_keys_master_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_acl_keys_fg_max
 * define info:
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single field group
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_nof_acl_keys_fg_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_nof_acl_keys_fg_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define min_acl_nof_ffc
 * define info:
 * Minimum number of FFC's that should be allocated for each context for ACL purposes.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_min_acl_nof_ffc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_min_acl_nof_ffc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fwd_context_num_for_one_apptype
 * define info:
 * Maximum number of fwd contexts that could be mapped to an apptype 
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_max_fwd_context_num_for_one_apptype_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_max_fwd_context_num_for_one_apptype;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_acl_context_num
 * define info:
 * Maximum number of ACL contexts in the KBP 
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_max_acl_context_num_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_max_acl_context_num;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.base_ifwd2.nof_contexts_get(unit);

    /* Set value */
    define->data = dnx_data_field.base_ifwd2.nof_contexts_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define size_apptype_profile_id
 * define info:
 * Size in bits of the apptype profile ID (based on iFED2 ACL context)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_size_apptype_profile_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_size_apptype_profile_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define key_bmp
 * define info:
 * bitmap of the key IDs used by the KBP.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_key_bmp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_key_bmp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x30030;

    /* Set value */
    define->data = 0x30030;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define apptype_user_1st
 * define info:
 * First User defined Apptype id to avoid overlapping with static ones
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_apptype_user_1st_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_apptype_user_1st;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define apptype_user_nof
 * define info:
 * Number of user Defined apptypes that can be created
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_apptype_user_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int define_index = dnx_data_field_kbp_define_apptype_user_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table ffc_to_quad_and_group_map
 * Module - 'field', Submodule - 'kbp', table - 'ffc_to_quad_and_group_map'
 * Mapping of the ffc id to its quad anad group
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_kbp_ffc_to_quad_and_group_map_set(
    int unit)
{
    int ffc_id_index;
    dnx_data_field_kbp_ffc_to_quad_and_group_map_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_kbp;
    int table_index = dnx_data_field_kbp_table_ffc_to_quad_and_group_map;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_field.base_ifwd2.nof_ffc_get(unit);
    table->info_get.key_size[0] = dnx_data_field.base_ifwd2.nof_ffc_get(unit);

    /* Info - default values */
    table->values[0].default_val = "SAL_UINT32_MAX";
    table->values[1].default_val = "SAL_UINT32_MAX";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_kbp_ffc_to_quad_and_group_map_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_field_kbp_table_ffc_to_quad_and_group_map");

    /* Store Default Values */
    default_data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->quad_id = SAL_UINT32_MAX;
    default_data->group_id = SAL_UINT32_MAX;
    /* Set Default Values */
    for (ffc_id_index = 0; ffc_id_index < table->keys[0].size; ffc_id_index++)
    {
        data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, ffc_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->quad_id = 0;
    data->group_id = 0;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->quad_id = 0;
    data->group_id = 0;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->quad_id = 1;
    data->group_id = 1;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->quad_id = 1;
    data->group_id = 1;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->quad_id = 1;
    data->group_id = 1;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    data->quad_id = 1;
    data->group_id = 1;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->quad_id = 2;
    data->group_id = 2;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->quad_id = 2;
    data->group_id = 2;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->quad_id = 2;
    data->group_id = 2;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    data->quad_id = 2;
    data->group_id = 2;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
    data->quad_id = 3;
    data->group_id = 2;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
    data->quad_id = 3;
    data->group_id = 2;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 12, 0);
    data->quad_id = 3;
    data->group_id = 2;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 13, 0);
    data->quad_id = 3;
    data->group_id = 2;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 14, 0);
    data->quad_id = 4;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 15, 0);
    data->quad_id = 4;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 16, 0);
    data->quad_id = 4;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 17, 0);
    data->quad_id = 4;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 18, 0);
    data->quad_id = 5;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 19, 0);
    data->quad_id = 5;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 20, 0);
    data->quad_id = 5;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 21, 0);
    data->quad_id = 5;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 22, 0);
    data->quad_id = 6;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 23, 0);
    data->quad_id = 6;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 24, 0);
    data->quad_id = 6;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 25, 0);
    data->quad_id = 6;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 26, 0);
    data->quad_id = 7;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 27, 0);
    data->quad_id = 7;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 28, 0);
    data->quad_id = 7;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 29, 0);
    data->quad_id = 7;
    data->group_id = 3;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 30, 0);
    data->quad_id = 8;
    data->group_id = 4;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 31, 0);
    data->quad_id = 8;
    data->group_id = 4;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 32, 0);
    data->quad_id = 8;
    data->group_id = 4;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 33, 0);
    data->quad_id = 8;
    data->group_id = 4;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 34, 0);
    data->quad_id = 9;
    data->group_id = 4;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 35, 0);
    data->quad_id = 9;
    data->group_id = 4;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 36, 0);
    data->quad_id = 9;
    data->group_id = 4;
    data = (dnx_data_field_kbp_ffc_to_quad_and_group_map_t *) dnxc_data_mgmt_table_data_get(unit, table, 37, 0);
    data->quad_id = 9;
    data->group_id = 4;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: tcam
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define key_size_half
 * define info:
 * Half TCAM key size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_key_size_half_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_key_size_half;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 80;

    /* Set value */
    define->data = 80;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define key_size_single
 * define info:
 * Single TCAM key size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_key_size_single_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_key_size_single;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 160;

    /* Set value */
    define->data = 160;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define key_size_double
 * define info:
 * Double TCAM key size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_key_size_double_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_key_size_double;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 320;

    /* Set value */
    define->data = 320;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define dt_max_key_size
 * define info:
 * Maximum key size for TCAM DT
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_dt_max_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_dt_max_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 11;

    /* Set value */
    define->data = 11;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define action_size_half
 * define info:
 * When the key size is half key (80b), this holds the action width payload
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_action_size_half_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_action_size_half;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define action_size_single
 * define info:
 * When the key size is single key (160b), this holds the action width payload
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_action_size_single_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_action_size_single;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define action_size_double
 * define info:
 * When the key size is double key (320b), this holds the action width payload
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_action_size_double_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_action_size_double;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define key_mode_size
 * define info:
 * Number of bits representing the entry size for each half entry.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_key_mode_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_key_mode_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define entry_size_single_key_hw
 * define info:
 * The full key size in HW, includingd entry size field, not including payload and valid bits.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_entry_size_single_key_hw_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_entry_size_single_key_hw;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (2*((dnx_data_field.tcam.key_size_half_get(unit))+(dnx_data_field.tcam.key_mode_size_get(unit))));

    /* Set value */
    define->data = (2*((dnx_data_field.tcam.key_size_half_get(unit))+(dnx_data_field.tcam.key_mode_size_get(unit))));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define entry_size_single_valid_bits_hw
 * define info:
 * The size of the valid bits in HW.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_entry_size_single_valid_bits_hw_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_entry_size_single_valid_bits_hw;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define entry_size_half_payload_hw
 * define info:
 * The full payload size in HW for half an entry.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_entry_size_half_payload_hw_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_entry_size_half_payload_hw;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define hw_bank_size
 * define info:
 * Size of a TCAM bank in HW
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_hw_bank_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_hw_bank_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4096;

    /* Set value */
    define->data = 4096;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_bank_size
 * define info:
 * Number of entries per small TCAM bank
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_small_bank_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_small_bank_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_big_bank_lines
 * define info:
 * Number of TCAM big bank lines
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_big_bank_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_big_bank_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4096;

    /* Set value */
    define->data = 4096;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_small_bank_lines
 * define info:
 * Number of TCAM small bank lines
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_small_bank_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_small_bank_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 512;

    /* Set value */
    define->data = 512;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_big_banks
 * define info:
 * Number of TCAM big banks
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_big_banks_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_big_banks;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 12;

    /* Set value */
    define->data = 12;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_small_banks
 * define info:
 * Number of TCAM small banks
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_small_banks_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_small_banks;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_banks
 * define info:
 * Number of TCAM banks
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_banks_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_banks;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_payload_tables
 * define info:
 * Number of action tables
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_payload_tables_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_payload_tables;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_access_profiles
 * define info:
 * Number of TCAM access profiles
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_access_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_access_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define action_width_selector_size
 * define info:
 * The action width selector size for each bank in each access profile, each bit represents the corresponding 32 bit in the action table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_action_width_selector_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_action_width_selector_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cascaded_data_nof_bits
 * define info:
 * Number of TCAM cascaded data bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_cascaded_data_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_cascaded_data_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define big_bank_key_nof_bits
 * define info:
 * Number of TCAM big bank key bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_big_bank_key_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_big_bank_key_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 11;

    /* Set value */
    define->data = 11;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_entries_160_bits
 * define info:
 * Number of 160 bits TCAM entries; Value: (nof_big_banks*nof_big_bank_lines)+(nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_entries_160_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_entries_160_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 25600;

    /* Set value */
    define->data = 25600;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_entries_80_bits
 * define info:
 * Number of 80 bits TCAM entries; Value: (2*nof_big_banks*nof_big_bank_lines)+(2*nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_entries_80_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_entries_80_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 51200;

    /* Set value */
    define->data = 51200;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tcam_banks_size
 * define info:
 * The size of TCAM_TCAM_BANK which is equal to (nof_big_banks + nof_small_banks) * nof_big_bank_lines
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_tcam_banks_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_tcam_banks_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 65536;

    /* Set value */
    define->data = 65536;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tcam_banks_last_index
 * define info:
 * Last index available in TCAM banks
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_tcam_banks_last_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_tcam_banks_last_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 61952;

    /* Set value */
    define->data = 61952;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_tcam_handlers
 * define info:
 * Number of TCAM handlers in device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_tcam_handlers_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_tcam_handlers;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_prefix_size
 * define info:
 * Maximum prefix size in TCAM
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_max_prefix_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_max_prefix_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_prefix_value
 * define info:
 * Maximum prefix value in TCAM
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_max_prefix_value_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_max_prefix_value;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_in_double_key
 * define info:
 * Number of 160'b key's in double key
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_keys_in_double_key_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_keys_in_double_key;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_max
 * define info:
 * Number of 160'b key's in one search lookup
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_nof_keys_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_nof_keys_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.tcam.nof_keys_in_double_key_get(unit);

    /* Set value */
    define->data = dnx_data_field.tcam.nof_keys_in_double_key_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define access_profile_half_key_mode
 * define info:
 * Half key mode in access profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_access_profile_half_key_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_access_profile_half_key_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define access_profile_single_key_mode
 * define info:
 * Single key mode in access profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_access_profile_single_key_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_access_profile_single_key_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define access_profile_double_key_mode
 * define info:
 * Double key mode in access profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_access_profile_double_key_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_access_profile_double_key_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define hit_indication_entries_per_byte
 * define info:
 * Number of entries in byte, in TCAM and CS TCAM HIT and indication memories.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_hit_indication_entries_per_byte_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_hit_indication_entries_per_byte;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_tcam_priority
 * define info:
 * The biggest valid value for the priority of a TCAM entry
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_tcam_max_tcam_priority_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_tcam;
    int define_index = dnx_data_field_tcam_define_max_tcam_priority;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x7fffffff;

    /* Set value */
    define->data = 0x7fffffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: group
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_fgs
 * define info:
 * Number of Field Groups
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_group_nof_fgs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_group;
    int define_index = dnx_data_field_group_define_nof_fgs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_action_per_fg
 * define info:
 * Number of action per Field Group
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_group_nof_action_per_fg_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_group;
    int define_index = dnx_data_field_group_define_nof_action_per_fg;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_quals_per_fg
 * define info:
 * Number of qualifiers per Field Group
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_group_nof_quals_per_fg_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_group;
    int define_index = dnx_data_field_group_define_nof_quals_per_fg;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys_per_fg_max
 * define info:
 * Maximum number of keys (KBRs) a field group can have.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_group_nof_keys_per_fg_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_group;
    int define_index = dnx_data_field_group_define_nof_keys_per_fg_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX3(dnx_data_field.tcam.nof_keys_max_get(unit), dnx_data_field.kbp.nof_acl_keys_master_max_get(unit), dnx_data_field.common_max_val.nof_compare_pairs_get(unit));

    /* Set value */
    define->data = UTILEX_MAX3(dnx_data_field.tcam.nof_keys_max_get(unit), dnx_data_field.kbp.nof_acl_keys_master_max_get(unit), dnx_data_field.common_max_val.nof_compare_pairs_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define id_fec_wa
 * define info:
 * FEC WA is being used in more then one WA context, hence must be created with_id so that other WA can re-use the FG
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_group_id_fec_wa_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_group;
    int define_index = dnx_data_field_group_define_id_fec_wa;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.group.nof_fgs_get(unit)-1;

    /* Set value */
    define->data = dnx_data_field.group.nof_fgs_get(unit)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: efes
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_nof_key_selects_per_field_io
 * define info:
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_efes_max_nof_key_selects_per_field_io_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_efes;
    int define_index = dnx_data_field_efes_define_max_nof_key_selects_per_field_io;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 11;

    /* Set value */
    define->data = 11;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table key_select_properties
 * Module - 'field', Submodule - 'efes', table - 'key_select_properties'
 * The properties of the different key select options
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_efes_key_select_properties_set(
    int unit)
{
    int stage_index;
    int field_io_index;
    dnx_data_field_efes_key_select_properties_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_efes;
    int table_index = dnx_data_field_efes_table_key_select_properties;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_FIELD_STAGE_NOF;
    table->info_get.key_size[0] = DNX_FIELD_STAGE_NOF;
    table->keys[1].size = DBAL_NOF_ENUM_FIELD_IO_VALUES;
    table->info_get.key_size[1] = DBAL_NOF_ENUM_FIELD_IO_VALUES;

    /* Info - default values */
    table->values[0].default_val = "-1";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_efes_key_select_properties_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_field_efes_table_key_select_properties");

    /* Store Default Values */
    default_data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->key_select[0] = -1;
    default_data->num_bits[0] = 0;
    default_data->lsb[0] = 0;
    default_data->num_bits_not_on_key[0] = 0;
    /* Set Default Values */
    for (stage_index = 0; stage_index < table->keys[0].size; stage_index++)
    {
        for (field_io_index = 0; field_io_index < table->keys[1].size; field_io_index++)
        {
            data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, stage_index, field_io_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_0_63_0;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_1_31_0_TCAM_0_63_32;
    data->num_bits[0] = 64;
    data->num_bits[1] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 32;
    data->num_bits_not_on_key[0] = 0;
    data->num_bits_not_on_key[1] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_1_31_0_TCAM_0_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_1_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_2_31_0_TCAM_1_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_2);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_2_31_0_TCAM_1_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_2_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_3_31_0_TCAM_2_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_3);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_3_31_0_TCAM_2_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_3_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_4_31_0_TCAM_3_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_4);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_4_31_0_TCAM_3_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_4_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_5_31_0_TCAM_4_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_5);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_5_31_0_TCAM_4_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_5_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_6_31_0_TCAM_5_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_6);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_6_31_0_TCAM_5_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_6_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_7_31_0_TCAM_6_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_7);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_7_31_0_TCAM_6_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_7_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_LEXEM_27_0_4_B0_TCAM_7_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_0_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_0_63_0;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_1_31_0_TCAM_0_63_32;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_1_63_0;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_2_31_0_TCAM_1_63_32;
    data->num_bits[0] = 64;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 32;
    data->lsb[2] = 64;
    data->lsb[3] = 96;
    data->num_bits_not_on_key[0] = 0;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_1_2);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_1_31_0_TCAM_0_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_1_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_2_31_0_TCAM_1_63_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_2_63_0;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_3_31_0_TCAM_2_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_2_3);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_2_31_0_TCAM_1_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_2_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_3_31_0_TCAM_2_63_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_3_63_0;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_4_31_0_TCAM_3_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_4_5);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_4_31_0_TCAM_3_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_4_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_5_31_0_TCAM_4_63_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_5_63_0;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_6_31_0_TCAM_5_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_5_6);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_5_31_0_TCAM_4_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_5_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_6_31_0_TCAM_5_63_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_6_63_0;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_7_31_0_TCAM_6_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_6_7);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_6_31_0_TCAM_5_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_6_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_7_31_0_TCAM_6_63_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_TCAM_7_63_0;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_LEXEM_27_0_4_B0_TCAM_7_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_LEXEM);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_LEXEM_27_0_4_B0_TCAM_7_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_LEXEM_59_0_4_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_SEXEM_27_0_4_B0_LEXEM_59_28;
    data->num_bits[0] = 28;
    data->num_bits[1] = 60;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 28;
    data->num_bits_not_on_key[0] = 36;
    data->num_bits_not_on_key[1] = 4;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_SEXEM);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_SEXEM_27_0_4_B0_LEXEM_59_28;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_SEXEM_59_0_4_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_31_0_SEXEM_59_28;
    data->num_bits[0] = 28;
    data->num_bits[1] = 60;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 28;
    data->num_bits_not_on_key[0] = 36;
    data->num_bits_not_on_key[1] = 4;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_DIRECT_0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_0_23_0_8_B0_KEY_J_159_128;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_0_55_0_8_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_0_87_24;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_0_119_56;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_1_23_0_8_B0_DIRECT_0_119_88;
    data->num_bits[0] = 24;
    data->num_bits[1] = 56;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 24;
    data->lsb[3] = 56;
    data->lsb[4] = 88;
    data->num_bits_not_on_key[0] = 40;
    data->num_bits_not_on_key[1] = 8;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_DIRECT_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_1_23_0_8_B0_DIRECT_0_119_88;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_1_55_0_8_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_1_87_24;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_1_119_56;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_1_119_88;
    data->num_bits[0] = 24;
    data->num_bits[1] = 56;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 24;
    data->lsb[3] = 56;
    data->lsb[4] = 88;
    data->num_bits_not_on_key[0] = 40;
    data->num_bits_not_on_key[1] = 8;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_31_0_SEXEM_59_28;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_95_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_127_64;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_159_96;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_31_0_KEY_I_159_128;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 64;
    data->num_bits[5] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->lsb[5] = 128;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_31_0_KEY_I_159_128;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_95_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_127_64;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_159_96;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_0_23_0_8_B0_KEY_J_159_128;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 64;
    data->num_bits[5] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->lsb[5] = 128;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF2, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_0_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_31_0_SEXEM_59_28;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_95_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_127_64;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_I_159_96;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_31_0_KEY_I_159_128;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_63_0;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_95_32;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_127_64;
    data->key_select[9] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_KEY_J_159_96;
    data->key_select[10] = DBAL_ENUM_FVAL_FIELD_PMF_A_FES_KEY_SELECT_DIRECT_0_23_0_8_B0_KEY_J_159_128;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 64;
    data->num_bits[5] = 64;
    data->num_bits[6] = 64;
    data->num_bits[7] = 64;
    data->num_bits[8] = 64;
    data->num_bits[9] = 64;
    data->num_bits[10] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->lsb[5] = 128;
    data->lsb[6] = 160;
    data->lsb[7] = 192;
    data->lsb[8] = 224;
    data->lsb[9] = 256;
    data->lsb[10] = 288;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data->num_bits_not_on_key[9] = 0;
    data->num_bits_not_on_key[10] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_TCAM_0_63_0;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_TCAM_1_31_0_TCAM_0_63_32;
    data->num_bits[0] = 64;
    data->num_bits[1] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 32;
    data->num_bits_not_on_key[0] = 0;
    data->num_bits_not_on_key[1] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_TCAM_1_31_0_TCAM_0_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_TCAM_1_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_SEXEM_27_0_4_B0_TCAM_1_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_0_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_TCAM_0_63_0;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_TCAM_1_31_0_TCAM_0_63_32;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_TCAM_1_63_0;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_SEXEM_27_0_4_B0_TCAM_1_63_32;
    data->num_bits[0] = 64;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 32;
    data->lsb[2] = 64;
    data->lsb[3] = 96;
    data->num_bits_not_on_key[0] = 0;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, DBAL_ENUM_FVAL_FIELD_IO_SEXEM);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_SEXEM_27_0_4_B0_TCAM_1_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_SEXEM_59_0_4_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_31_0_SEXEM_59_28;
    data->num_bits[0] = 28;
    data->num_bits[1] = 60;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 28;
    data->num_bits_not_on_key[0] = 36;
    data->num_bits_not_on_key[1] = 4;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, DBAL_ENUM_FVAL_FIELD_IO_DIRECT_0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_DIRECT_31_0_KEY_B_159_128;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_DIRECT_55_0_8_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_DIRECT_87_24;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_DIRECT_119_56;
    data->num_bits[0] = 24;
    data->num_bits[1] = 56;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 24;
    data->lsb[3] = 56;
    data->num_bits_not_on_key[0] = 40;
    data->num_bits_not_on_key[1] = 8;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_31_0_SEXEM_59_28;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_95_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_127_64;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_159_96;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_31_0_KEY_A_159_128;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 64;
    data->num_bits[5] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->lsb[5] = 128;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_31_0_KEY_A_159_128;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_95_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_127_64;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_159_96;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_DIRECT_31_0_KEY_B_159_128;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 64;
    data->num_bits[5] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->lsb[5] = 128;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_IPMF3, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_0_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_31_0_SEXEM_59_28;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_95_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_127_64;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_A_159_96;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_31_0_KEY_A_159_128;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_63_0;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_95_32;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_127_64;
    data->key_select[9] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_KEY_B_159_96;
    data->key_select[10] = DBAL_ENUM_FVAL_FIELD_PMF_B_FES_KEY_SELECT_DIRECT_31_0_KEY_B_159_128;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->num_bits[4] = 64;
    data->num_bits[5] = 64;
    data->num_bits[6] = 64;
    data->num_bits[7] = 64;
    data->num_bits[8] = 64;
    data->num_bits[9] = 64;
    data->num_bits[10] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->lsb[4] = 96;
    data->lsb[5] = 128;
    data->lsb[6] = 160;
    data->lsb[7] = 192;
    data->lsb[8] = 224;
    data->lsb[9] = 256;
    data->lsb[10] = 288;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data->num_bits_not_on_key[9] = 0;
    data->num_bits_not_on_key[10] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_EPMF, DBAL_ENUM_FVAL_FIELD_IO_LEXEM);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_LEXEM_4_B0_59_0;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_0_PAYLOAD_31_0_4_B0_LEXEM_59_32;
    data->num_bits[0] = 60;
    data->num_bits[1] = 28;
    data->lsb[0] = 0;
    data->lsb[1] = 32;
    data->num_bits_not_on_key[0] = 0;
    data->num_bits_not_on_key[1] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_EPMF, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_0_PAYLOAD_31_0_4_B0_LEXEM_59_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_0_PAYLOAD_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_1_PAYLOAD_31_0_TCAM_0_PAYLOAD_63_32;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_EPMF, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_1_PAYLOAD_31_0_TCAM_0_PAYLOAD_63_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_1_PAYLOAD_63_0;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_EPMF, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_0_1);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_0_PAYLOAD_31_0_4_B0_LEXEM_59_32;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_0_PAYLOAD_63_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_1_PAYLOAD_31_0_TCAM_0_PAYLOAD_63_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_E_PMF_FES_KEY_SELECT_TCAM_1_PAYLOAD_63_0;
    data->num_bits[0] = 32;
    data->num_bits[1] = 64;
    data->num_bits[2] = 64;
    data->num_bits[3] = 64;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 32;
    data->lsb[3] = 64;
    data->num_bits_not_on_key[0] = 32;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data = (dnx_data_field_efes_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_STAGE_ACE, DBAL_ENUM_FVAL_FIELD_IO_ACE);
    data->key_select[0] = 0;
    data->num_bits[0] = 104;
    data->lsb[0] = 0;
    data->num_bits_not_on_key[0] = 0;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: fem
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_nof_key_selects_per_field_io
 * define info:
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_fem_max_nof_key_selects_per_field_io_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_fem;
    int define_index = dnx_data_field_fem_define_max_nof_key_selects_per_field_io;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 21;

    /* Set value */
    define->data = 21;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table key_select_properties
 * Module - 'field', Submodule - 'fem', table - 'key_select_properties'
 * The properties of the different key select options
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_fem_key_select_properties_set(
    int unit)
{
    int field_io_index;
    dnx_data_field_fem_key_select_properties_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_fem;
    int table_index = dnx_data_field_fem_table_key_select_properties;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DBAL_NOF_ENUM_FIELD_IO_VALUES;
    table->info_get.key_size[0] = DBAL_NOF_ENUM_FIELD_IO_VALUES;

    /* Info - default values */
    table->values[0].default_val = "-1";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_fem_key_select_properties_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_field_fem_table_key_select_properties");

    /* Store Default Values */
    default_data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->key_select[0] = -1;
    default_data->num_bits[0] = 0;
    default_data->lsb[0] = 0;
    default_data->num_bits_not_on_key[0] = 0;
    /* Set Default Values */
    for (field_io_index = 0; field_io_index < table->keys[0].size; field_io_index++)
    {
        data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, field_io_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_0, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_0_31_0;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_0_47_16;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_0_63_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_15_0_TCAM_0_63_48;
    data->num_bits[0] = 32;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 16;
    data->lsb[2] = 32;
    data->lsb[3] = 48;
    data->num_bits_not_on_key[0] = 0;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_1, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_15_0_TCAM_0_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_15_0_TCAM_1_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_2, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_15_0_TCAM_1_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_15_0_TCAM_2_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_3, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_15_0_TCAM_2_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_15_0_TCAM_3_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_4, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_15_0_TCAM_3_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_15_0_TCAM_4_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_5, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_15_0_TCAM_4_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_15_0_TCAM_5_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_6, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_15_0_TCAM_5_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_15_0_TCAM_6_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_7, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_15_0_TCAM_6_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_LEXEM_11_0_4_B0_TCAM_7_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_0_1, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_0_31_0;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_0_47_16;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_0_63_32;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_15_0_TCAM_0_63_48;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_31_0;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_47_16;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_63_32;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_15_0_TCAM_1_63_48;
    data->num_bits[0] = 32;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 16;
    data->lsb[2] = 32;
    data->lsb[3] = 48;
    data->lsb[4] = 64;
    data->lsb[5] = 80;
    data->lsb[6] = 96;
    data->lsb[7] = 112;
    data->num_bits_not_on_key[0] = 0;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_1_2, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_15_0_TCAM_0_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_1_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_15_0_TCAM_1_63_48;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_31_0;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_47_16;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_63_32;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_15_0_TCAM_2_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->lsb[5] = 64;
    data->lsb[6] = 80;
    data->lsb[7] = 96;
    data->lsb[8] = 112;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_2_3, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_15_0_TCAM_1_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_2_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_15_0_TCAM_2_63_48;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_31_0;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_47_16;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_3_63_32;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_15_0_TCAM_3_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->lsb[5] = 64;
    data->lsb[6] = 80;
    data->lsb[7] = 96;
    data->lsb[8] = 112;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_4_5, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_15_0_TCAM_3_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_4_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_15_0_TCAM_4_63_48;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_31_0;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_47_16;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_63_32;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_15_0_TCAM_5_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->lsb[5] = 64;
    data->lsb[6] = 80;
    data->lsb[7] = 96;
    data->lsb[8] = 112;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_5_6, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_15_0_TCAM_4_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_5_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_15_0_TCAM_5_63_48;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_31_0;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_47_16;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_63_32;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_15_0_TCAM_6_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->lsb[5] = 64;
    data->lsb[6] = 80;
    data->lsb[7] = 96;
    data->lsb[8] = 112;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_INTERNAL_TCAM_6_7, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_15_0_TCAM_5_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_6_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_15_0_TCAM_6_63_48;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_31_0;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_47_16;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_TCAM_7_63_32;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_LEXEM_11_0_4_B0_TCAM_7_63_48;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->lsb[5] = 64;
    data->lsb[6] = 80;
    data->lsb[7] = 96;
    data->lsb[8] = 112;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_LEXEM, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_LEXEM_11_0_4_B0_TCAM_7_63_48;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_LEXEM_27_0_4_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_LEXEM_43_12;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_LEXEM_59_28;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_SEXEM_11_0_4_B0_LEXEM_59_44;
    data->num_bits[0] = 12;
    data->num_bits[1] = 28;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 12;
    data->lsb[3] = 28;
    data->lsb[4] = 44;
    data->num_bits_not_on_key[0] = 20;
    data->num_bits_not_on_key[1] = 40;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_SEXEM, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_SEXEM_11_0_4_B0_LEXEM_59_44;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_SEXEM_27_0_4_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_SEXEM_43_12;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_SEXEM_59_28;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_16_0_SEXEM_59_44;
    data->num_bits[0] = 12;
    data->num_bits[1] = 28;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 12;
    data->lsb[3] = 28;
    data->lsb[4] = 44;
    data->num_bits_not_on_key[0] = 20;
    data->num_bits_not_on_key[1] = 40;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_DIRECT_0, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_7_0_8_B0_KEY_J_159_144;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_23_0_8_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_39_8;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_55_24;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_71_40;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_87_56;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_103_72;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_119_88;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_7_0_8_B0_DIRECT_0_119_104;
    data->num_bits[0] = 8;
    data->num_bits[1] = 24;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 8;
    data->lsb[3] = 24;
    data->lsb[4] = 40;
    data->lsb[5] = 56;
    data->lsb[6] = 72;
    data->lsb[7] = 88;
    data->lsb[8] = 104;
    data->num_bits_not_on_key[0] = 24;
    data->num_bits_not_on_key[1] = 8;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_DIRECT_1, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_7_0_8_B0_DIRECT_0_119_104;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_23_0_8_B0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_39_8;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_55_24;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_71_40;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_87_56;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_103_72;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_1_119_88;
    data->num_bits[0] = 8;
    data->num_bits[1] = 24;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 8;
    data->lsb[3] = 24;
    data->lsb[4] = 40;
    data->lsb[5] = 56;
    data->lsb[6] = 72;
    data->lsb[7] = 88;
    data->num_bits_not_on_key[0] = 24;
    data->num_bits_not_on_key[1] = 8;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_0, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_16_0_SEXEM_59_44;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_79_48;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_95_64;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_111_80;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_127_96;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_143_112;
    data->key_select[9] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_159_128;
    data->key_select[10] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_15_0_KEY_I_159_144;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 32;
    data->num_bits[9] = 32;
    data->num_bits[10] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->lsb[5] = 64;
    data->lsb[6] = 80;
    data->lsb[7] = 96;
    data->lsb[8] = 112;
    data->lsb[9] = 128;
    data->lsb[10] = 144;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data->num_bits_not_on_key[9] = 0;
    data->num_bits_not_on_key[10] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_1, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_15_0_KEY_I_159_144;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_79_48;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_95_64;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_111_80;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_127_96;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_143_112;
    data->key_select[9] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_159_128;
    data->key_select[10] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_7_0_8_B0_KEY_J_159_144;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 32;
    data->num_bits[9] = 32;
    data->num_bits[10] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->lsb[5] = 64;
    data->lsb[6] = 80;
    data->lsb[7] = 96;
    data->lsb[8] = 112;
    data->lsb[9] = 128;
    data->lsb[10] = 144;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data->num_bits_not_on_key[9] = 0;
    data->num_bits_not_on_key[10] = 0;
    data = (dnx_data_field_fem_key_select_properties_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_FIELD_IO_DIR_EXT_KEY_0_1, 0);
    data->key_select[0] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_16_0_SEXEM_59_44;
    data->key_select[1] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_31_0;
    data->key_select[2] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_47_16;
    data->key_select[3] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_63_32;
    data->key_select[4] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_79_48;
    data->key_select[5] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_95_64;
    data->key_select[6] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_111_80;
    data->key_select[7] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_127_96;
    data->key_select[8] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_143_112;
    data->key_select[9] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_I_159_128;
    data->key_select[10] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_15_0_KEY_I_159_144;
    data->key_select[11] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_31_0;
    data->key_select[12] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_47_16;
    data->key_select[13] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_63_32;
    data->key_select[14] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_79_48;
    data->key_select[15] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_95_64;
    data->key_select[16] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_111_80;
    data->key_select[17] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_127_96;
    data->key_select[18] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_143_112;
    data->key_select[19] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_KEY_J_159_128;
    data->key_select[20] = DBAL_ENUM_FVAL_FIELD_PMF_A_FEM_KEY_SELECT_DIRECT_0_7_0_8_B0_KEY_J_159_144;
    data->num_bits[0] = 16;
    data->num_bits[1] = 32;
    data->num_bits[2] = 32;
    data->num_bits[3] = 32;
    data->num_bits[4] = 32;
    data->num_bits[5] = 32;
    data->num_bits[6] = 32;
    data->num_bits[7] = 32;
    data->num_bits[8] = 32;
    data->num_bits[9] = 32;
    data->num_bits[10] = 32;
    data->num_bits[11] = 32;
    data->num_bits[12] = 32;
    data->num_bits[13] = 32;
    data->num_bits[14] = 32;
    data->num_bits[15] = 32;
    data->num_bits[16] = 32;
    data->num_bits[17] = 32;
    data->num_bits[18] = 32;
    data->num_bits[19] = 32;
    data->num_bits[20] = 16;
    data->lsb[0] = 0;
    data->lsb[1] = 0;
    data->lsb[2] = 16;
    data->lsb[3] = 32;
    data->lsb[4] = 48;
    data->lsb[5] = 64;
    data->lsb[6] = 80;
    data->lsb[7] = 96;
    data->lsb[8] = 112;
    data->lsb[9] = 128;
    data->lsb[10] = 144;
    data->lsb[11] = 160;
    data->lsb[12] = 176;
    data->lsb[13] = 192;
    data->lsb[14] = 208;
    data->lsb[15] = 224;
    data->lsb[16] = 240;
    data->lsb[17] = 256;
    data->lsb[18] = 272;
    data->lsb[19] = 288;
    data->lsb[20] = 304;
    data->num_bits_not_on_key[0] = 16;
    data->num_bits_not_on_key[1] = 0;
    data->num_bits_not_on_key[2] = 0;
    data->num_bits_not_on_key[3] = 0;
    data->num_bits_not_on_key[4] = 0;
    data->num_bits_not_on_key[5] = 0;
    data->num_bits_not_on_key[6] = 0;
    data->num_bits_not_on_key[7] = 0;
    data->num_bits_not_on_key[8] = 0;
    data->num_bits_not_on_key[9] = 0;
    data->num_bits_not_on_key[10] = 0;
    data->num_bits_not_on_key[11] = 0;
    data->num_bits_not_on_key[12] = 0;
    data->num_bits_not_on_key[13] = 0;
    data->num_bits_not_on_key[14] = 0;
    data->num_bits_not_on_key[15] = 0;
    data->num_bits_not_on_key[16] = 0;
    data->num_bits_not_on_key[17] = 0;
    data->num_bits_not_on_key[18] = 0;
    data->num_bits_not_on_key[19] = 0;
    data->num_bits_not_on_key[20] = 0;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: context
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define default_context
 * define info:
 * Default Context Id (used for Ethernet Packets)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_context_default_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_context;
    int define_index = dnx_data_field_context_define_default_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_itmh_context
 * define info:
 * Default Context Id for ITMH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_context_default_itmh_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_context;
    int define_index = dnx_data_field_context_define_default_itmh_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-1);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-1);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_itmh_pph_context
 * define info:
 * Default Context Id for ITMH_PPH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_context_default_itmh_pph_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_context;
    int define_index = dnx_data_field_context_define_default_itmh_pph_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-2);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-2);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_j1_itmh_context
 * define info:
 * Default Context Id for J1 ITMH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_context_default_j1_itmh_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_context;
    int define_index = dnx_data_field_context_define_default_j1_itmh_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-6);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-6);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_j1_itmh_pph_context
 * define info:
 * Default Context Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_context_default_j1_itmh_pph_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_context;
    int define_index = dnx_data_field_context_define_default_j1_itmh_pph_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-7);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-7);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_stacking_context
 * define info:
 * Default Context Id for Stacking Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_context_default_stacking_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_context;
    int define_index = dnx_data_field_context_define_default_stacking_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-3);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-3);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_oam_context
 * define info:
 * Default Context Id for OAM Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_context_default_oam_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_context;
    int define_index = dnx_data_field_context_define_default_oam_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-4);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-4);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_oam_reflector_context
 * define info:
 * Default Context Id for OAM downmep reflector Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_context_default_oam_reflector_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_context;
    int define_index = dnx_data_field_context_define_default_oam_reflector_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-5);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_contexts_get(unit)-5);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: preselector
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define default_oam_presel_id_ipmf1
 * define info:
 * Default Presel Id in iPMF1 for OAM Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_default_oam_presel_id_ipmf1_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_default_oam_presel_id_ipmf1;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_itmh_presel_id_ipmf1
 * define info:
 * Default Presel Id in iPMF1 for ITMH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_default_itmh_presel_id_ipmf1_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_default_itmh_presel_id_ipmf1;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-2);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-2);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_j1_itmh_presel_id_ipmf1
 * define info:
 * Default Presel Id in iPMF1 for J1 ITMH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_default_j1_itmh_presel_id_ipmf1_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_default_j1_itmh_presel_id_ipmf1;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-4);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-4);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_itmh_pph_presel_id_ipmf1
 * define info:
 * Default Presel in iPMF1 Id for ITMH_PPH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf1_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_default_itmh_pph_presel_id_ipmf1;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-3);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-3);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_itmh_pph_presel_id_ipmf3
 * define info:
 * Default Presel in iPMF3 Id for ITMH_PPH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf3_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_default_itmh_pph_presel_id_ipmf3;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf3.nof_cs_lines_get(unit)-2);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf3.nof_cs_lines_get(unit)-2);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_j1_itmh_pph_presel_id_ipmf1
 * define info:
 * Default Presel in iPMF1 Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf1_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_default_j1_itmh_pph_presel_id_ipmf1;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-5);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-5);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_j1_itmh_pph_presel_id_ipmf3
 * define info:
 * Default Presel in iPMF3 Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf3_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_default_j1_itmh_pph_presel_id_ipmf3;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf3.nof_cs_lines_get(unit)-5);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf3.nof_cs_lines_get(unit)-5);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define default_stacking_presel_id_ipmf1
 * define info:
 * Default Presel in iPMF1 Id for Stacking Packets
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_default_stacking_presel_id_ipmf1_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_default_stacking_presel_id_ipmf1;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-6);

    /* Set value */
    define->data = (dnx_data_field.base_ipmf1.nof_cs_lines_get(unit)-6);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define num_cs_inlif_profile_entries
 * define info:
 * The number of CS entries which are used for inlif profile mapping
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_preselector_num_cs_inlif_profile_entries_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_preselector;
    int define_index = dnx_data_field_preselector_define_num_cs_inlif_profile_entries;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: qual
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define user_1st
 * define info:
 * First User qualifier id to avoid overlapping with static ones
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_user_1st_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_user_1st;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2048;

    /* Set value */
    define->data = 2048;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define user_nof
 * define info:
 * Number of User Define Data qualifiers that can be created
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_user_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_user_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_bits_in_qual
 * define info:
 * Maximum number of bits that any qualifier can have
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_max_bits_in_qual_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_max_bits_in_qual;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 160;

    /* Set value */
    define->data = 160;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ingress_pbus_header_length
 * define info:
 * Number of bits reserved in ingress PBUS for header.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_ingress_pbus_header_length_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_ingress_pbus_header_length;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1152;

    /* Set value */
    define->data = 1152;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define egress_pbus_header_length
 * define info:
 * Number of bits reserved in egress PBUS for header.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_egress_pbus_header_length_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_egress_pbus_header_length;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1024;

    /* Set value */
    define->data = 1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ifwd2_pbus_size
 * define info:
 * Number of bits in the PBUS of iFWD2
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_ifwd2_pbus_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_ifwd2_pbus_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3225;

    /* Set value */
    define->data = 3225;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ipmf1_pbus_size
 * define info:
 * Number of bits in the PBUS of iPMF1
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_ipmf1_pbus_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_ipmf1_pbus_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3355;

    /* Set value */
    define->data = 3355;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ipmf2_pbus_size
 * define info:
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_ipmf2_pbus_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_ipmf2_pbus_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1384;

    /* Set value */
    define->data = 1384;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ipmf3_pbus_size
 * define info:
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_ipmf3_pbus_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_ipmf3_pbus_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1714;

    /* Set value */
    define->data = 1714;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define epmf_pbus_size
 * define info:
 * Number of bits in the PBUS of ePMF
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_epmf_pbus_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_epmf_pbus_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2555;

    /* Set value */
    define->data = 2555;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ingress_nof_layer_records
 * define info:
 * Number of layer records taken from the parser in ingress stages.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_ingress_nof_layer_records_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_ingress_nof_layer_records;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ingress_layer_record_size
 * define info:
 * Number of bits in each layer record in ingress stages.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_ingress_layer_record_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_ingress_layer_record_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define egress_nof_layer_records
 * define info:
 * Number of layer records taken from the parser in egress stages.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_egress_nof_layer_records_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_egress_nof_layer_records;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define egress_layer_record_size
 * define info:
 * Number of bits in each layer record in egress stages.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_egress_layer_record_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int define_index = dnx_data_field_qual_define_egress_layer_record_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 28;

    /* Set value */
    define->data = 28;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table params
 * Module - 'field', Submodule - 'qual', table - 'params'
 * Per stage Per qualifier properties
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_params_set(
    int unit)
{
    int stage_index;
    int qual_index;
    dnx_data_field_qual_params_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int table_index = dnx_data_field_qual_table_params;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_PP_STAGE_NOF;
    table->info_get.key_size[0] = DNX_PP_STAGE_NOF;
    table->keys[1].size = 256;
    table->info_get.key_size[1] = 256;

    /* Info - default values */
    table->values[0].default_val = "-1";
    table->values[1].default_val = "unsupported";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_qual_params_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_field_qual_table_params");

    /* Store Default Values */
    default_data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->offset = -1;
    default_data->signal = "unsupported";
    /* Set Default Values */
    for (stage_index = 0; stage_index < table->keys[0].size; stage_index++)
    {
        for (qual_index = 0; qual_index < table->keys[1].size; qual_index++)
        {
            data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, stage_index, qual_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PMF_ETH_RIF_PROFILE);
    data->offset = 1734;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_LAYER_INDEX);
    data->offset = 1408;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_RPF_ROUTE_VALID);
    data->offset = 1411;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_FWD_PROFILE);
    data->offset = 1412;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_FWD_RESULT);
    data->offset = 1419;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_RPF_PROFILE);
    data->offset = 1515;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_RPF_RESULT);
    data->offset = 1522;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_MP_PROFILE_SEL);
    data->offset = 1618;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_RPF_DEFAULT_ROUTE_FOUND);
    data->offset = 1619;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ACL_CONTEXT);
    data->offset = 1620;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_CONTEXT);
    data->offset = 1626;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_NASID);
    data->offset = 1632;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ENABLE_PP_INJECT);
    data->offset = 1637;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_EEI);
    data->offset = 1638;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_EGRESS_LEARN_ENABLE);
    data->offset = 1662;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_ACTION_CPU_TRAP_CODE);
    data->offset = 1663;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_ACTION_CPU_TRAP_QUAL);
    data->offset = 1672;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_ACTION_DESTINATION);
    data->offset = 1691;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_ACTION_STRENGTH);
    data->offset = 1712;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_DOMAIN);
    data->offset = 1716;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_DOMAIN_PROFILE);
    data->offset = 1734;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_LAYER_ADDITIONAL_INFO);
    data->offset = 1744;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_GENERAL_DATA_0);
    data->offset = 1748;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_GENERAL_DATA_1);
    data->offset = 1876;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_GENERAL_DATA_2);
    data->offset = 1904;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_GENERAL_DATA_3);
    data->offset = 2032;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IEEE1588_COMMAND);
    data->offset = 2258;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IEEE1588_COMPENSATE_TIME_STAMP);
    data->offset = 2260;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IEEE1588_ENCAPSULATION);
    data->offset = 2261;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IEEE1588_HEADER_OFFSET);
    data->offset = 2262;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IN_LIF_PROFILE_0);
    data->offset = 2270;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IN_LIF_PROFILE_1);
    data->offset = 2278;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_GLOB_IN_LIF_0);
    data->offset = 2286;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_GLOB_IN_LIF_1);
    data->offset = 2308;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PP_PORT);
    data->offset = 2330;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_INCOMING_TAG_STRUCTURE);
    data->offset = 2338;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_INGRESS_LEARN_ENABLE);
    data->offset = 2343;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_LEARN_INFO);
    data->offset = 2344;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_MEM_SOFT_ERR);
    data->offset = 2504;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_NWK_QOS);
    data->offset = 2505;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_OAM_OFFSET);
    data->offset = 2513;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_OAM_STAMP_OFFSET);
    data->offset = 2521;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_OAM_OPCODE);
    data->offset = 2529;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_OAM_YOUR_DISCR);
    data->offset = 2533;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_MY_CFM_MAC);
    data->offset = 2534;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PACKET_IS_OAM);
    data->offset = 2535;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PACKET_IS_BFD);
    data->offset = 2536;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_MDL);
    data->offset = 2537;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_0);
    data->offset = 2540;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_0_VALID);
    data->offset = 2562;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_1);
    data->offset = 2563;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_1_VALID);
    data->offset = 2585;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_2);
    data->offset = 2586;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_LIF_2_VALID);
    data->offset = 2608;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_PCP_0);
    data->offset = 2609;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_PCP_1);
    data->offset = 2612;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VTT_OAM_PCP_2);
    data->offset = 2615;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_GLOB_OUT_LIF_0);
    data->offset = 2618;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_GLOB_OUT_LIF_1);
    data->offset = 2640;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PRT_QUALIFIER);
    data->offset = 2662;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PACKET_HEADER_SIZE);
    data->offset = 2665;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PACKET_IS_APPLET);
    data->offset = 2673;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PACKET_IS_COMPATIBLE_MC);
    data->offset = 2674;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PACKET_IS_IEEE1588);
    data->offset = 2675;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_DP);
    data->offset = 2676;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ECN);
    data->offset = 2678;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_TC);
    data->offset = 2680;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_PTC);
    data->offset = 2683;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_RPF_DST);
    data->offset = 2691;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_RPF_DST_VALID);
    data->offset = 2712;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_SNOOP_CODE);
    data->offset = 2713;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_SNOOP_STRENGTH);
    data->offset = 2722;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_MIRROR_CODE);
    data->offset = 2725;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_STATISTICAL_SAMPLING_CODE);
    data->offset = 2734;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_SRC_SYS_PORT);
    data->offset = 2743;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_0);
    data->offset = 2759;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_1);
    data->offset = 2779;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_2);
    data->offset = 2799;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_3);
    data->offset = 2819;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_4);
    data->offset = 2839;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ID_5);
    data->offset = 2859;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_0);
    data->offset = 2879;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_1);
    data->offset = 2884;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_2);
    data->offset = 2889;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_3);
    data->offset = 2894;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_4);
    data->offset = 2899;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FLP_STATISTICS_ATR_5);
    data->offset = 2904;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VLAN_EDIT_CMD);
    data->offset = 2909;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_TRACE_PACKET);
    data->offset = 2948;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IN_TTL);
    data->offset = 2949;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_LIF_OAM_TRAP_PROFILE);
    data->offset = 2957;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VISIBILITY_CLEAR);
    data->offset = 2959;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VISIBILITY);
    data->offset = 2960;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_RPF_OUT_LIF);
    data->offset = 2961;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ACTION_PROFILE_SA_DROP_INDEX);
    data->offset = 2983;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ACTION_PROFILE_SA_NOT_FOUND_INDEX);
    data->offset = 2985;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ACTION_PROFILE_DA_NOT_FOUND_INDEX);
    data->offset = 2987;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_SAVED_CONTEXT_PROFILE);
    data->offset = 2988;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IPV4_VERSION_ERROR);
    data->offset = 2994;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IPV4_CHECKSUM_ERROR);
    data->offset = 2995;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IPV4_TOTAL_LENGTH_ERROR);
    data->offset = 2996;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IPV4_OPTIONS_ERROR);
    data->offset = 2997;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IPV4_SIP_EQUAL_DIP_ERROR);
    data->offset = 2998;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IPV4_DIP_ZERO_ERROR);
    data->offset = 2999;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IPV4_SIP_IS_MC_ERROR);
    data->offset = 3000;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IPV4_HEADER_LENGTH_ERROR);
    data->offset = 3001;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IN_LIF_UNKNOWN_DA_PROFILE);
    data->offset = 3002;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_NOF_VALID_LM_LIFS);
    data->offset = 3004;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_IS_IN_LIF_VALID_FOR_LM);
    data->offset = 3006;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_FWD_STRENGTH);
    data->offset = 3007;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_RPF_STRENGTH);
    data->offset = 3012;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_FWD_FOUND);
    data->offset = 3017;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD1_PRIORITY_DECODER_RPF_FOUND);
    data->offset = 3018;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_STATISTICS_META_DATA);
    data->offset = 3019;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_STAT_ATTRIBUTE_OBJ_CMD);
    data->offset = 3035;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_FWD_STAT_ATTRIBUTE_OBJ);
    data->offset = 3040;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_VSI_UNKNOWN_DA_DESTINATION);
    data->offset = 3060;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ECMP_LB_KEY_0);
    data->offset = 3081;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ECMP_LB_KEY_1);
    data->offset = 3097;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_ECMP_LB_KEY_2);
    data->offset = 3113;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_LAG_LB_KEY);
    data->offset = 3129;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_NWK_LB_KEY);
    data->offset = 3145;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IFWD2, DNX_FIELD_IFWD2_QUAL_CONTEXT_CONSTANTS);
    data->offset = 3161;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PMF_ETH_RIF_PROFILE);
    data->offset = 2884;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_TM_PORT_PMF_PROFILE);
    data->offset = 1866;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PP_PORT_PMF_GENERAL_DATA);
    data->offset = 1907+dnx_data_field.profile_bits.nof_bits_in_port_profile_get(unit);
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PP_PORT_PMF_PROFILE);
    data->offset = 1907;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ALL_ONES);
    data->offset = 3339;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_MEM_SOFT_ERR);
    data->offset = 3338;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ACL_CONTEXT);
    data->offset = 3332;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_NASID);
    data->offset = 3327;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_CONTEXT);
    data->offset = 3321;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_RPF_OUT_LIF);
    data->offset = 3299;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_RPF_DEFAULT_ROUTE_FOUND);
    data->offset = 3298;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_RPF_ROUTE_VALID);
    data->offset = 3297;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PACKET_IS_APPLET);
    data->offset = 3296;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_GENERAL_DATA_2);
    data->offset = 3168;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_GENERAL_DATA_1);
    data->offset = 3040;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_GENERAL_DATA_0);
    data->offset = 2912;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_DOMAIN);
    data->offset = 2894;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_DOMAIN_PROFILE);
    data->offset = 2884;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_PCP_2);
    data->offset = 2881;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_DEI_2);
    data->offset = 2880;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_PCP_DEI_2);
    data->offset = 2880;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_VID_2);
    data->offset = 2868;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_PCP_1);
    data->offset = 2865;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_DEI_1);
    data->offset = 2864;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_PCP_DEI_1);
    data->offset = 2864;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_VID_1);
    data->offset = 2852;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_CMD_INDEX);
    data->offset = 2845;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VLAN_EDIT_CMD);
    data->offset = 2845;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_SRC_SYS_PORT);
    data->offset = 2829;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_SNOOP_CODE);
    data->offset = 2820;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_SNOOP_STRENGTH);
    data->offset = 2817;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_LAYER_ADDITIONAL_INFO);
    data->offset = 2813;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_RPF_DST);
    data->offset = 2792;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_RPF_DST_VALID);
    data->offset = 2791;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PACKET_IS_IEEE1588);
    data->offset = 2790;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IEEE1588_COMPENSATE_TIME_STAMP);
    data->offset = 2789;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IEEE1588_COMMAND);
    data->offset = 2787;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IEEE1588_ENCAPSULATION);
    data->offset = 2786;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IEEE1588_HEADER_OFFSET);
    data->offset = 2778;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PACKET_IS_COMPATIBLE_MC);
    data->offset = 2777;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PRT_QUALIFIER);
    data->offset = 2774;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PACKET_HEADER_SIZE);
    data->offset = 2766;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_MIRROR_CODE);
    data->offset = 2717;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VISIBILITY);
    data->offset = 2716;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_OAM_ID);
    data->offset = 2747;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_OAM_UP_MEP);
    data->offset = 2746;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_OAM_SUB_TYPE);
    data->offset = 2742;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_OAM_OFFSET);
    data->offset = 2734;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_OAM_STAMP_OFFSET);
    data->offset = 2726;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_LEARN_INFO);
    data->offset = 2556;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_INGRESS_LEARN_ENABLE);
    data->offset = 2555;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EGRESS_LEARN_ENABLE);
    data->offset = 2554;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_GLOB_IN_LIF_1);
    data->offset = 2532;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_GLOB_IN_LIF_0);
    data->offset = 2510;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IN_LIF_PROFILE_1);
    data->offset = 2502;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IN_LIF_PROFILE_0);
    data->offset = 2494;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_ACTION_STRENGTH);
    data->offset = 2490;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_ACTION_DESTINATION);
    data->offset = 2469;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_ACTION_CPU_TRAP_CODE);
    data->offset = 2460;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_ACTION_CPU_TRAP_QUAL);
    data->offset = 2441;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EEI);
    data->offset = 2417;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_0);
    data->offset = 2416;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_1);
    data->offset = 2415;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_2);
    data->offset = 2414;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_3);
    data->offset = 2413;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_4);
    data->offset = 2412;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_5);
    data->offset = 2411;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_6);
    data->offset = 2410;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_HIT_7);
    data->offset = 2409;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_PAYLOAD_ALL_PART_1);
    data->offset = 2321;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ELK_LKP_PAYLOAD_ALL_PART_0);
    data->offset = 2161;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IN_PORT);
    data->offset = 2152;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PTC);
    data->offset = 2144;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_LAG_LB_KEY);
    data->offset = 2128;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_NWK_LB_KEY);
    data->offset = 2112;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ECMP_LB_KEY_2);
    data->offset = 2096;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ECMP_LB_KEY_1);
    data->offset = 2080;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ECMP_LB_KEY_0);
    data->offset = 2064;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_GLOB_OUT_LIF_1);
    data->offset = 2042;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_GLOB_OUT_LIF_0);
    data->offset = 2020;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IN_TTL);
    data->offset = 2012;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_BIER_STR_OFFSET);
    data->offset = 2004;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_BIER_STR_SIZE);
    data->offset = 2002;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PACKET_IS_BIER);
    data->offset = 2001;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_SAVED_CONTEXT_PROFILE);
    data->offset = 1995;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_OAM_METER_DISABLE);
    data->offset = 1994;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_INCOMING_TAG_STRUCTURE);
    data->offset = 1989;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_TC);
    data->offset = 1986;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_DP);
    data->offset = 1984;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_ECN);
    data->offset = 1982;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_NWK_QOS);
    data->offset = 1974;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_TRACE_PACKET);
    data->offset = 1973;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PACKET_HEADER_SIZE_RANGE);
    data->offset = 1971;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IN_PORT_KEY_GEN_VAR);
    data->offset = 1907;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_IN_PORT_MAPPED_PP_PORT);
    data->offset = 1898;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_PTC_KEY_GEN_VAR);
    data->offset = 1866;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_VID_VALID);
    data->offset = 1865;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_L4OPS);
    data->offset = 1841;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_OBJECT10);
    data->offset = 1838;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_CPU_TRAP_CODE_PROFILE);
    data->offset = 1837;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_TM_FLOW_ID);
    data->offset = 1817;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ID_3);
    data->offset = 1797;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ID_2);
    data->offset = 1777;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ID_1);
    data->offset = 1757;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ID_0);
    data->offset = 1737;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_9);
    data->offset = 1717;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_8);
    data->offset = 1697;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_7);
    data->offset = 1677;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_6);
    data->offset = 1657;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_5);
    data->offset = 1637;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_4);
    data->offset = 1617;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_3);
    data->offset = 1597;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_2);
    data->offset = 1577;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_1);
    data->offset = 1557;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ID_0);
    data->offset = 1537;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_TM_FLOW_ATR);
    data->offset = 1532;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ATR_3);
    data->offset = 1527;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ATR_2);
    data->offset = 1522;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ATR_1);
    data->offset = 1517;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EXT_STATISTICS_ATR_0);
    data->offset = 1512;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_9);
    data->offset = 1507;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_8);
    data->offset = 1502;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_7);
    data->offset = 1497;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_6);
    data->offset = 1492;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_5);
    data->offset = 1487;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_4);
    data->offset = 1482;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_3);
    data->offset = 1477;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_2);
    data->offset = 1472;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_1);
    data->offset = 1467;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_ATR_0);
    data->offset = 1462;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_STATISTICS_META_DATA);
    data->offset = 1446;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_CONTEXT_KEY_GEN_VAR);
    data->offset = 1414;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_EGRESS_PARSING_INDEX);
    data->offset = 1411;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_FWD_LAYER_INDEX);
    data->offset = 1408;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_AC_IN_LIF_WIDE_DATA);
    data->offset = 3248;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF1, DNX_FIELD_IPMF1_QUAL_NATIVE_AC_IN_LIF_WIDE_DATA);
    data->offset = 3256;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_PMF1_TCAM_ACTION_0);
    data->offset = 1320;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_PMF1_TCAM_ACTION_1);
    data->offset = 1256;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_PMF1_TCAM_ACTION_2);
    data->offset = 1192;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_PMF1_TCAM_ACTION_3);
    data->offset = 1128;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_PMF1_EXEM_ACTION);
    data->offset = 1064;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_PMF1_DIRECT_ACTION);
    data->offset = 944;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_STATE_DATA);
    data->offset = 935;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_STATE_ADDRESS);
    data->offset = 925;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_KEY_F_INITIAL);
    data->offset = 765;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_KEY_G_INITIAL);
    data->offset = 605;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_KEY_H_INITIAL);
    data->offset = 445;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_KEY_I_INITIAL);
    data->offset = 285;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_KEY_J_INITIAL);
    data->offset = 125;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_LAG_LB_KEY);
    data->offset = 109;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_NWK_LB_KEY);
    data->offset = 93;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_ECMP_LB_KEY_2);
    data->offset = 77;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_ECMP_LB_KEY_1);
    data->offset = 61;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_ECMP_LB_KEY_0);
    data->offset = 45;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_TRJ_HASH);
    data->offset = 29;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_CMP_KEY_0_DECODED);
    data->offset = 23;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_CMP_KEY_1_DECODED);
    data->offset = 17;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_CMP_KEY_TCAM_0_DECODED);
    data->offset = 11;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_CMP_KEY_TCAM_1_DECODED);
    data->offset = 5;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF2, DNX_FIELD_IPMF2_QUAL_NASID);
    data->offset = 0;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PMF_ETH_RIF_PROFILE);
    data->offset = 1369;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_TM_PORT_PMF_PROFILE);
    data->offset = 436;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PP_PORT_PMF_GENERAL_DATA);
    data->offset = 372+dnx_data_field.profile_bits.nof_bits_in_port_profile_get(unit);
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PP_PORT_PMF_PROFILE);
    data->offset = 372;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_ALL_ONES);
    data->offset = 1698;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_LEARN_INFO);
    data->offset = 1538;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_RPF_ECMP_MODE);
    data->offset = 1536;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_RPF_ECMP_GROUP);
    data->offset = 1520;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_ADMT_PROFILE);
    data->offset = 1517;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_BIER_STR_OFFSET);
    data->offset = 1509;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_BIER_STR_SIZE);
    data->offset = 1507;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_BYTES_TO_REMOVE);
    data->offset = 1498;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_WEAK_TM_VALID);
    data->offset = 1497;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_WEAK_TM_PROFILE);
    data->offset = 1491;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_STAT_OBJ_LM_READ_INDEX);
    data->offset = 1489;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_CONGESTION_INFO);
    data->offset = 1487;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_END_OF_PACKET_EDITING);
    data->offset = 1484;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_EEI);
    data->offset = 1460;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_EGRESS_LEARN_ENABLE);
    data->offset = 1459;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_ACTION_CPU_TRAP_QUAL);
    data->offset = 1440;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_ACTION_CPU_TRAP_CODE);
    data->offset = 1431;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_ACTION_DP_METER_COMMAND);
    data->offset = 1427;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_ACTION_DP);
    data->offset = 1425;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_ACTION_TC);
    data->offset = 1422;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_ACTION_DESTINATION);
    data->offset = 1401;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_ACTION_STRENGTH);
    data->offset = 1397;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_PAYLOAD);
    data->offset = 1397;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_DOMAIN);
    data->offset = 1379;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_DOMAIN_PROFILE);
    data->offset = 1369;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_GENERAL_DATA);
    data->offset = 1337;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IEEE1588_COMMAND);
    data->offset = 1239;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IEEE1588_COMPENSATE_TIME_STAMP);
    data->offset = 1238;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IEEE1588_ENCAPSULATION);
    data->offset = 1237;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IEEE1588_HEADER_OFFSET);
    data->offset = 1229;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IN_LIF_PROFILE_1);
    data->offset = 1221;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IN_LIF_PROFILE_0);
    data->offset = 1213;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_GLOB_IN_LIF_1);
    data->offset = 1191;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_GLOB_IN_LIF_0);
    data->offset = 1169;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IN_PORT);
    data->offset = 1160;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_CORE_ID);
    data->offset = 1160;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IN_TTL);
    data->offset = 1152;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_INGRESS_LEARN_ENABLE);
    data->offset = 1151;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_ITPP_DELTA);
    data->offset = 1143;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_LAG_LB_KEY);
    data->offset = 1127;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_LATENCY_FLOW_ID_VALID);
    data->offset = 1126;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_LATENCY_FLOW_ID);
    data->offset = 1107;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_MIRROR_CODE);
    data->offset = 1098;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_MIRROR_QUALIFIER);
    data->offset = 1090;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_NWK_LB_KEY);
    data->offset = 1074;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_NWK_QOS);
    data->offset = 1066;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_OAM_ID);
    data->offset = 1047;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_OAM_OFFSET);
    data->offset = 1039;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_OAM_STAMP_OFFSET);
    data->offset = 1031;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_OAM_SUB_TYPE);
    data->offset = 1027;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_OAM_UP_MEP);
    data->offset = 1026;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_GLOB_OUT_LIF_3);
    data->offset = 1004;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_GLOB_OUT_LIF_2);
    data->offset = 982;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_GLOB_OUT_LIF_1);
    data->offset = 960;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_GLOB_OUT_LIF_0);
    data->offset = 938;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PACKET_IS_APPLET);
    data->offset = 937;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_NASID);
    data->offset = 932;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PACKET_IS_BIER);
    data->offset = 931;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PACKET_IS_IEEE1588);
    data->offset = 930;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_EGRESS_PARSING_INDEX);
    data->offset = 927;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PTC);
    data->offset = 919;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_EXT_STATISTICS_VALID);
    data->offset = 918;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PPH_RESERVED);
    data->offset = 915;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PPH_TYPE);
    data->offset = 913;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_RPF_DST);
    data->offset = 892;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_RPF_DST_VALID);
    data->offset = 891;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_SNOOP_CODE);
    data->offset = 882;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_SNOOP_STRENGTH);
    data->offset = 879;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_SNOOP_QUALIFIER);
    data->offset = 871;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_SRC_SYS_PORT);
    data->offset = 855;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_ST_VSQ_PTR);
    data->offset = 847;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_STATISTICAL_SAMPLING_CODE);
    data->offset = 838;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_STATISTICAL_SAMPLING_QUALIFIER);
    data->offset = 830;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_STACKING_ROUTE_HISTORY_BITMAP);
    data->offset = 814;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_STATISTICS_META_DATA);
    data->offset = 798;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_STATISTICS_OBJECT10);
    data->offset = 795;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_SYSTEM_HEADER_PROFILE_INDEX);
    data->offset = 791;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_TM_PROFILE);
    data->offset = 789;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADER_1);
    data->offset = 757;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADER_2);
    data->offset = 725;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADER_3);
    data->offset = 693;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADER_4);
    data->offset = 661;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADER_1_TYPE);
    data->offset = 659;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADER_2_TYPE);
    data->offset = 657;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADER_3_TYPE);
    data->offset = 655;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADER_4_TYPE);
    data->offset = 653;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_USER_HEADERS_TYPE);
    data->offset = 653;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VISIBILITY);
    data->offset = 652;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_VID_2);
    data->offset = 640;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_VID_1);
    data->offset = 628;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_DEI_2);
    data->offset = 627;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_PCP_2);
    data->offset = 624;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_PCP_DEI_2);
    data->offset = 624;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_DEI_1);
    data->offset = 623;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_PCP_1);
    data->offset = 620;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_PCP_DEI_1);
    data->offset = 620;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_CMD_INDEX);
    data->offset = 613;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_VLAN_EDIT_CMD);
    data->offset = 613;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_LAYER_ADDITIONAL_INFO);
    data->offset = 609;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_SLB_LEARN_NEEDED);
    data->offset = 608;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_SLB_KEY);
    data->offset = 528;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_SLB_PAYLOAD);
    data->offset = 468;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_PTC_KEY_GEN_VAR);
    data->offset = 436;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IN_PORT_KEY_GEN_VAR);
    data->offset = 372;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_IN_PORT_MAPPED_PP_PORT);
    data->offset = 363;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_CONTEXT_KEY_GEN_VAR);
    data->offset = 331;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FER_STATISTICS_OBJ);
    data->offset = 259;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_IPMF3, DNX_FIELD_IPMF3_QUAL_FWD_LAYER_INDEX);
    data->offset = 256;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_TM_PORT_PMF_PROFILE);
    data->offset = 2453;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PP_PORT_PMF_PROFILE);
    data->offset = 2501;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_RESERVED);
    data->offset = 1167;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_VISIBILITY);
    data->offset = 1168;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_TM_PROFILE);
    data->offset = 1169;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_ECN_ENABLE);
    data->offset = 1171;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_CNI);
    data->offset = 1172;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_BIER_BFR_EXT_PRESENT);
    data->offset = 1173;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_FLOW_ID_EXT_PRESENT);
    data->offset = 1174;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_APPLICATION_SPECIFIC_EXT_PRESENT);
    data->offset = 1175;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_TM_DESTINATION_EXT_PRESENT);
    data->offset = 1176;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_MCID_OR_OUTLIF_0_OR_MCDB_PTR);
    data->offset = 1177;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_TM_ACTION_IS_MC);
    data->offset = 1199;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_PPH_PRESENT);
    data->offset = 1200;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_TSH_EXT_PRESENT);
    data->offset = 1201;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_TM_ACTION_TYPE);
    data->offset = 1202;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_DP);
    data->offset = 1204;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PP_DSP);
    data->offset = 1206;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_SRC_SYS_PORT);
    data->offset = 1214;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_TC);
    data->offset = 1230;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FTMH_PACKET_SIZE);
    data->offset = 1233;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_LB_KEY);
    data->offset = 1247;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_NWK_KEY);
    data->offset = 1255;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_STACKING_EXT);
    data->offset = 1271;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_BIER_BFR_EXT);
    data->offset = 1287;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_TM_DESTINATION_EXT);
    data->offset = 1303;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_APPLICATION_SPECIFIC_EXT);
    data->offset = 1327;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_TSH_EXT);
    data->offset = 1375;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FWD_STRENGTH);
    data->offset = 1431;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_PARSING_START_TYPE);
    data->offset = 1435;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_PARSING_START_OFFSET);
    data->offset = 1440;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_LIF_EXT_TYPE);
    data->offset = 1447;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_FHEI_SIZE);
    data->offset = 1450;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_LEARN_EXT_PRESENT);
    data->offset = 1452;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_TTL);
    data->offset = 1453;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_NWK_QOS);
    data->offset = 1461;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_IN_LIF);
    data->offset = 1469;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_FWD_DOMAIN);
    data->offset = 1491;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_IN_LIF_PROFILE);
    data->offset = 1509;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_END_OF_PACKET_EDITING);
    data->offset = 1517;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_FWD_LAYER_ADDITIONAL_INFO);
    data->offset = 1520;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_VALUE1);
    data->offset = 1524;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PPH_VALUE2);
    data->offset = 1532;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FHEI_EXT);
    data->offset = 1540;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_LEARN_EXT);
    data->offset = 1604;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_LIF_EXT);
    data->offset = 1756;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_USER_HEADER_4);
    data->offset = 1828;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_USER_HEADER_3);
    data->offset = 1860;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_USER_HEADER_2);
    data->offset = 1892;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_USER_HEADER_1);
    data->offset = 1924;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_USER_HEADER_4_TYPE);
    data->offset = 1956;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_USER_HEADER_3_TYPE);
    data->offset = 1958;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_USER_HEADER_2_TYPE);
    data->offset = 1960;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_USER_HEADER_1_TYPE);
    data->offset = 1962;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_IS_TDM);
    data->offset = 1964;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_CUD_OUTLIF_OR_MCDB_PTR);
    data->offset = 1965;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_DISCARD);
    data->offset = 1987;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_OUT_LIF_PROFILE);
    data->offset = 1988;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_ETH_TAG_FORMAT);
    data->offset = 1992;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_UPDATED_TPIDS_PACKET_DATA);
    data->offset = 2002;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_IVE_BYTES_TO_ADD);
    data->offset = 2146;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_IVE_BYTES_TO_REMOVE);
    data->offset = 2151;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_ETHER_TYPE_CODE);
    data->offset = 2156;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FABRIC_OR_EGRESS_MC);
    data->offset = 2172;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_ESTIMATED_BTR);
    data->offset = 2173;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FWD_CONTEXT);
    data->offset = 2181;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_GLOB_OUT_LIF_0);
    data->offset = 2187;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_GLOB_OUT_LIF_1);
    data->offset = 2209;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_GLOB_OUT_LIF_2);
    data->offset = 2231;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_GLOB_OUT_LIF_3);
    data->offset = 2253;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_GLOB_IN_LIF_0);
    data->offset = 2275;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_IN_LIF_PROFILE_0);
    data->offset = 2297;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_IP_MC_ELIGIBLE);
    data->offset = 2305;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_IP_MC_SHOULD_BE_BRIDGED);
    data->offset = 2306;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_LEARN_VALID);
    data->offset = 2307;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_LOCAL_OUT_LIF);
    data->offset = 2308;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_FWD_ACTION_PROFILE_INDEX);
    data->offset = 2328;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_SNOOP_ACTION_PROFILE_INDEX);
    data->offset = 2331;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_SNOOP_STRENGTH);
    data->offset = 2333;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_SYSTEM_HEADERS_SIZE);
    data->offset = 2336;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_DST_SYS_PORT);
    data->offset = 2343;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_OUT_TM_PORT);
    data->offset = 2359;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_OUT_PP_PORT);
    data->offset = 2367;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PACKET_IS_APPLET);
    data->offset = 2375;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_MEM_SOFT_ERR);
    data->offset = 2376;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_TC_MAP_PROFILE);
    data->offset = 2377;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_L4_PORT_IN_RANGE);
    data->offset = 2381;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PROGRAM_INDEX);
    data->offset = 2405;
    data = (dnx_data_field_qual_params_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_PP_STAGE_EPMF, DNX_FIELD_EPMF_QUAL_PER_PORT_TABLE_DATA);
    data->offset = 2411;

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table layer_record_info_ingress
 * Module - 'field', Submodule - 'qual', table - 'layer_record_info_ingress'
 * Information about layer record qualifiers in the ingress
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_layer_record_info_ingress_set(
    int unit)
{
    int layer_record_index;
    dnx_data_field_qual_layer_record_info_ingress_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int table_index = dnx_data_field_qual_table_layer_record_info_ingress;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_FIELD_LR_QUAL_NOF;
    table->info_get.key_size[0] = DNX_FIELD_LR_QUAL_NOF;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_qual_layer_record_info_ingress_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_field_qual_table_layer_record_info_ingress");

    /* Store Default Values */
    default_data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->valid = 0;
    default_data->size = 0;
    default_data->offset = 0;
    /* Set Default Values */
    for (layer_record_index = 0; layer_record_index < table->keys[0].size; layer_record_index++)
    {
        data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, layer_record_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_OFFSET, 0);
    data->valid = TRUE;
    data->size = 8;
    data->offset = 0;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_PROTOCOL, 0);
    data->valid = TRUE;
    data->size = 5;
    data->offset = 24;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_QUALIFIER, 0);
    data->valid = TRUE;
    data->size = 16;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_IS_DA_MC, 0);
    data->valid = dnx_data_field.minor_changes_j2_a0_b0.lr_eth_is_da_mac_valid_get(unit);
    data->size = 1;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_IS_DA_BC, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 9;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_1ST_TPID_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 10;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_1ST_TPID_INDEX, 0);
    data->valid = TRUE;
    data->size = 3;
    data->offset = 11;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_2ND_TPID_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 14;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_2ND_TPID_INDEX, 0);
    data->valid = TRUE;
    data->size = 3;
    data->offset = 15;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_3RD_TPID_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 18;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_3RD_TPID_INDEX, 0);
    data->valid = TRUE;
    data->size = 3;
    data->offset = 19;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_IS_MC, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_HAS_OPTION, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 9;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_IS_FRAGMENTED, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 10;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_IS_1ST_FRAGMENT, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 11;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_1ST_ADD_HEADER_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 12;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_1ST_ADD_HEADER, 0);
    data->valid = TRUE;
    data->size = 4;
    data->offset = 13;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_2ND_ADD_HEADER_EXISTS, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 17;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_TUNNEL_TYPE, 0);
    data->valid = TRUE;
    data->size = 4;
    data->offset = 18;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_IS_MC, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_1ST_ADD_HEADER_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 9;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_1ST_ADD_HEADER, 0);
    data->valid = TRUE;
    data->size = 5;
    data->offset = 10;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_2ND_ADD_HEADER_EXISTS, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 15;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_2ND_ADD_HEADER, 0);
    data->valid = TRUE;
    data->size = 5;
    data->offset = 16;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_3RD_ADD_HEADER_EXISTS, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 21;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_VALUE_1, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 22;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_SRV6_EP_SEGMENT_LEFT_MINUS_ONE, 0);
    data->valid = TRUE;
    data->size = 8;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_MPLS_NOF_LABELS, 0);
    data->valid = TRUE;
    data->size = 4;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_BIER_BITSTRINGLENGTH, 0);
    data->valid = TRUE;
    data->size = 4;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_FCOE_IS_FIP, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_FCOE_IS_ENCAP, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 9;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_FCOE_VFT_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 10;
    data = (dnx_data_field_qual_layer_record_info_ingress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ITMH_PPH_TYPE, 0);
    data->valid = TRUE;
    data->size = 2;
    data->offset = 8;

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table layer_record_info_egress
 * Module - 'field', Submodule - 'qual', table - 'layer_record_info_egress'
 * Information about layer record qualifiers in the egress
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_qual_layer_record_info_egress_set(
    int unit)
{
    int layer_record_index;
    dnx_data_field_qual_layer_record_info_egress_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_qual;
    int table_index = dnx_data_field_qual_table_layer_record_info_egress;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_FIELD_LR_QUAL_NOF;
    table->info_get.key_size[0] = DNX_FIELD_LR_QUAL_NOF;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_qual_layer_record_info_egress_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_field_qual_table_layer_record_info_egress");

    /* Store Default Values */
    default_data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->valid = 0;
    default_data->size = 0;
    default_data->offset = 0;
    /* Set Default Values */
    for (layer_record_index = 0; layer_record_index < table->keys[0].size; layer_record_index++)
    {
        data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, layer_record_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_OFFSET, 0);
    data->valid = TRUE;
    data->size = 7;
    data->offset = 0;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_PROTOCOL, 0);
    data->valid = TRUE;
    data->size = 5;
    data->offset = 23;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_QUALIFIER, 0);
    data->valid = TRUE;
    data->size = 16;
    data->offset = 7;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_IS_DA_MC, 0);
    data->valid = dnx_data_field.minor_changes_j2_a0_b0.lr_eth_is_da_mac_valid_get(unit);
    data->size = 1;
    data->offset = 7;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_IS_DA_BC, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_1ST_TPID_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 9;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_1ST_TPID_INDEX, 0);
    data->valid = TRUE;
    data->size = 3;
    data->offset = 10;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_2ND_TPID_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 13;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_2ND_TPID_INDEX, 0);
    data->valid = TRUE;
    data->size = 3;
    data->offset = 14;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_3RD_TPID_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 17;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ETH_3RD_TPID_INDEX, 0);
    data->valid = TRUE;
    data->size = 3;
    data->offset = 18;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_IS_MC, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 7;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_HAS_OPTION, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_IS_FRAGMENTED, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 9;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_IS_1ST_FRAGMENT, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 10;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_1ST_ADD_HEADER_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 11;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_1ST_ADD_HEADER, 0);
    data->valid = TRUE;
    data->size = 4;
    data->offset = 12;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_2ND_ADD_HEADER_EXISTS, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 16;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV4_TUNNEL_TYPE, 0);
    data->valid = TRUE;
    data->size = 4;
    data->offset = 17;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_IS_MC, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 7;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_1ST_ADD_HEADER_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_1ST_ADD_HEADER, 0);
    data->valid = TRUE;
    data->size = 5;
    data->offset = 9;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_2ND_ADD_HEADER_EXISTS, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 14;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_2ND_ADD_HEADER, 0);
    data->valid = TRUE;
    data->size = 5;
    data->offset = 15;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_3RD_ADD_HEADER_EXISTS, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 20;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_IPV6_VALUE_1, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 21;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_SRV6_EP_SEGMENT_LEFT_MINUS_ONE, 0);
    data->valid = TRUE;
    data->size = 8;
    data->offset = 7;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_MPLS_NOF_LABELS, 0);
    data->valid = TRUE;
    data->size = 4;
    data->offset = 7;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_BIER_BITSTRINGLENGTH, 0);
    data->valid = TRUE;
    data->size = 4;
    data->offset = 7;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_FCOE_IS_FIP, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 7;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_FCOE_IS_ENCAP, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 8;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_FCOE_VFT_EXIST, 0);
    data->valid = TRUE;
    data->size = 1;
    data->offset = 9;
    data = (dnx_data_field_qual_layer_record_info_egress_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_LR_QUAL_ITMH_PPH_TYPE, 0);
    data->valid = TRUE;
    data->size = 2;
    data->offset = 7;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: action
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define user_1st
 * define info:
 * First user action id to avaoid overlapping with static ones
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_action_user_1st_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_action;
    int define_index = dnx_data_field_action_define_user_1st;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2048;

    /* Set value */
    define->data = 2048;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define user_nof
 * define info:
 * Number of User Define Data actions that can be created
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_action_user_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_action;
    int define_index = dnx_data_field_action_define_user_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: profile_bits
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_ing_in_lif
 * define info:
 * Number of reserved bits for Ingress FP in in_lif_profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_nof_ing_in_lif_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_nof_ing_in_lif;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_PMF_IN_LIF_PROFILE_NOF_BITS;
    define->property.doc = 
        "\n"
        "Configure number of in lif profile bits which will be used by PMF:\n"
        "pmf_in_lif_profile_nof_bits= 1-7\n"
        "Default: 2\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_range;
    define->property.method_str = "range";
    define->property.range_min = 1;
    define->property.range_max = 7;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_eg_in_lif
 * define info:
 * Number of reserved bits for Egress FP in in_lif_profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_nof_eg_in_lif_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_nof_eg_in_lif;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ing_eth_rif
 * define info:
 * Number of reserved bits for Ingress FP in in_rif_profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_nof_ing_eth_rif_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_nof_ing_eth_rif;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_PMF_IN_RIF_PROFILE_NOF_BITS;
    define->property.doc = 
        "\n"
        "Configure number of in-rif profile bits which will be used by PMF:\n"
        "pmf_in_lif_profile_nof_bits= 1-7\n"
        "Default: 2\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_range;
    define->property.method_str = "range";
    define->property.range_min = 1;
    define->property.range_max = 7;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_eg_eth_rif
 * define info:
 * Number of reserved bits for Egress FP in in_rif_profile
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_nof_eg_eth_rif_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_nof_eg_eth_rif;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ingress_pp_port_key_gen_var_size
 * define info:
 * Number of bits available on the key_ken_per per PP port
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_ingress_pp_port_key_gen_var_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_ingress_pp_port_key_gen_var_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_port_profile_size
 * define info:
 * The maximum number in bits of all port profiles hw memories possible
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_max_port_profile_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_max_port_profile_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX(dnx_data_field.profile_bits.ingress_pp_port_key_gen_var_size_get(unit), 64);

    /* Set value */
    define->data = UTILEX_MAX(dnx_data_field.profile_bits.ingress_pp_port_key_gen_var_size_get(unit), 64);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_port_profile
 * define info:
 * The number of bits used by the PMF for port profiles. Note that the actual number may be lower in some stages.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_nof_bits_in_port_profile_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_nof_bits_in_port_profile;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 24;

    /* Set value */
    define->data = 24;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_ingress_pp_port_general_data
 * define info:
 * The number of bits used by the PMF for per PP port general data.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_nof_bits_in_ingress_pp_port_general_data_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_nof_bits_in_ingress_pp_port_general_data;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = ((dnx_data_field.profile_bits.ingress_pp_port_key_gen_var_size_get(unit))-(dnx_data_field.profile_bits.nof_bits_in_port_profile_get(unit)));

    /* Set value */
    define->data = ((dnx_data_field.profile_bits.ingress_pp_port_key_gen_var_size_get(unit))-(dnx_data_field.profile_bits.nof_bits_in_port_profile_get(unit)));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric pmf_sexem3_stage
 * numeric info:
 * Determines using SOC property if we use SEXEM3 in iPMF2 or iPMF3.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_profile_bits_pmf_sexem3_stage_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_profile_bits;
    int define_index = dnx_data_field_profile_bits_define_pmf_sexem3_stage;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = DNX_FIELD_STAGE_IPMF3;

    /* Set value */
    define->data = DNX_FIELD_STAGE_IPMF3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_PMF_SEXEM3_STAGE;
    define->property.doc = 
        "\n"
        "Set PMF stage that will use SEXEM3. It can be:\n"
        "IPMF2 - Ingress PMF stage 2.\n"
        "IPMF3 - Ingress PMF stage 3.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "IPMF2";
    define->property.mapping[0].val = DNX_FIELD_STAGE_IPMF2;
    define->property.mapping[1].name = "IPMF3";
    define->property.mapping[1].val = DNX_FIELD_STAGE_IPMF3;
    define->property.mapping[1].is_default = 1 ;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: dir_ext
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define half_key_size
 * define info:
 * Half key size of direct extraction
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_dir_ext_half_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_dir_ext;
    int define_index = dnx_data_field_dir_ext_define_half_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 80;

    /* Set value */
    define->data = 80;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define single_key_size
 * define info:
 * Single key size of direct extraction
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_dir_ext_single_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_dir_ext;
    int define_index = dnx_data_field_dir_ext_define_single_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 160;

    /* Set value */
    define->data = 160;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define double_key_size
 * define info:
 * Double key size of direct extraction
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_dir_ext_double_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_dir_ext;
    int define_index = dnx_data_field_dir_ext_define_double_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 320;

    /* Set value */
    define->data = 320;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: state_table
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define key_size
 * define info:
 * Size of the state table key in the system
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_state_table_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_state_table;
    int define_index = dnx_data_field_state_table_define_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define address_max
 * define info:
 * Max address for the state table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_state_table_address_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_state_table;
    int define_index = dnx_data_field_state_table_define_address_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1023;

    /* Set value */
    define->data = 1023;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define address_size
 * define info:
 * Size of the address field in State Table in bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_state_table_address_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_state_table;
    int define_index = dnx_data_field_state_table_define_address_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 10;

    /* Set value */
    define->data = 10;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define data_size
 * define info:
 * Size of the data field in State Table in bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_state_table_data_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_state_table;
    int define_index = dnx_data_field_state_table_define_data_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: hash
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_key_size
 * define info:
 * maximal key size Field Group type 
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_hash_max_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_hash;
    int define_index = dnx_data_field_hash_define_max_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 320;

    /* Set value */
    define->data = 320;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: udh
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define type_count
 * define info:
 * UDH Type count
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_type_count_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_type_count;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define type_0_length
 * define info:
 * UDH Type 0 length in bytes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_type_0_length_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_type_0_length;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define type_1_length
 * define info:
 * UDH Type 1 length in bytes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_type_1_length_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_type_1_length;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define type_2_length
 * define info:
 * UDH Type 2 length in bytes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_type_2_length_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_type_2_length;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define type_3_length
 * define info:
 * UDH Type 3 length in bytes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_type_3_length_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_type_3_length;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric field_class_id_size_0
 * numeric info:
 * J1 Mode UDH related size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_field_class_id_size_0_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_field_class_id_size_0;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_FIELD_CLASS_ID_SIZE_0;
    define->property.doc = 
        "\n"
        "Field class ID size 0 is used to determine UDH_0\n"
        "size in J1 mode and also the udh_egress_offset_0/1.\n"
        "Default: 0x0.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 5;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "8";
    define->property.mapping[1].val = 8;
    define->property.mapping[2].name = "16";
    define->property.mapping[2].val = 16;
    define->property.mapping[3].name = "24";
    define->property.mapping[3].val = 24;
    define->property.mapping[4].name = "32";
    define->property.mapping[4].val = 32;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric field_class_id_size_1
 * numeric info:
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_field_class_id_size_1_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_field_class_id_size_1;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_FIELD_CLASS_ID_SIZE_1;
    define->property.doc = 
        "\n"
        "Field class ID size 1 is used to determine UDH_1\n"
        "size in J1 mode.\n"
        "Default: 0x0.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 5;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "8";
    define->property.mapping[1].val = 8;
    define->property.mapping[2].name = "16";
    define->property.mapping[2].val = 16;
    define->property.mapping[3].name = "24";
    define->property.mapping[3].val = 24;
    define->property.mapping[4].name = "32";
    define->property.mapping[4].val = 32;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric field_class_id_size_2
 * numeric info:
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_field_class_id_size_2_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_field_class_id_size_2;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_FIELD_CLASS_ID_SIZE_2;
    define->property.doc = 
        "\n"
        "Field class ID size 2 is used to determine UDH_0\n"
        "size in J1 mode.\n"
        "Default: 0x0.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 5;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "8";
    define->property.mapping[1].val = 8;
    define->property.mapping[2].name = "16";
    define->property.mapping[2].val = 16;
    define->property.mapping[3].name = "24";
    define->property.mapping[3].val = 24;
    define->property.mapping[4].name = "32";
    define->property.mapping[4].val = 32;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric field_class_id_size_3
 * numeric info:
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_udh_field_class_id_size_3_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_udh;
    int define_index = dnx_data_field_udh_define_field_class_id_size_3;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_FIELD_CLASS_ID_SIZE_3;
    define->property.doc = 
        "\n"
        "Field class ID size 3 is used to determine UDH_1\n"
        "size in J1 mode.\n"
        "Default: 0x0.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 5;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "0";
    define->property.mapping[0].val = 0;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "8";
    define->property.mapping[1].val = 8;
    define->property.mapping[2].name = "16";
    define->property.mapping[2].val = 16;
    define->property.mapping[3].name = "24";
    define->property.mapping[3].val = 24;
    define->property.mapping[4].name = "32";
    define->property.mapping[4].val = 32;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: system_headers
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_profiles
 * define info:
 * Number of system headers in device
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_system_headers_nof_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_system_headers;
    int define_index = dnx_data_field_system_headers_define_nof_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table system_header_profiles
 * Module - 'field', Submodule - 'system_headers', table - 'system_header_profiles'
 * Contains all system headers profiles defined in this device
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_system_headers_system_header_profiles_set(
    int unit)
{
    int system_header_profile_index;
    dnx_data_field_system_headers_system_header_profiles_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_system_headers;
    int table_index = dnx_data_field_system_headers_table_system_header_profiles;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_FIELD_CONTEXT_SYS_HDR_PROFILE_NOF;
    table->info_get.key_size[0] = DNX_FIELD_CONTEXT_SYS_HDR_PROFILE_NOF;

    /* Info - default values */
    table->values[0].default_val = "unsupported";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "0";
    table->values[5].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_system_headers_system_header_profiles_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_field_system_headers_table_system_header_profiles");

    /* Store Default Values */
    default_data = (dnx_data_field_system_headers_system_header_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->name = "unsupported";
    default_data->build_ftmh = 0;
    default_data->build_tsh = 0;
    default_data->build_pph = 0;
    default_data->build_udh = 0;
    default_data->never_add_pph_learn_ext = 0;
    /* Set Default Values */
    for (system_header_profile_index = 0; system_header_profile_index < table->keys[0].size; system_header_profile_index++)
    {
        data = (dnx_data_field_system_headers_system_header_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, system_header_profile_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_system_headers_system_header_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_CONTEXT_SYS_HDR_PROFILE_EMPTY, 0);
    data->name = "NONE";
    data = (dnx_data_field_system_headers_system_header_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_CONTEXT_SYS_HDR_PROFILE_FTMH, 0);
    data->name = "FTMH";
    data->build_ftmh = 1;
    data = (dnx_data_field_system_headers_system_header_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_CONTEXT_SYS_HDR_PROFILE_FTMH_PPH, 0);
    data->name = "FTMH_PPH";
    data->build_ftmh = 1;
    data->build_pph = 1;
    data->never_add_pph_learn_ext = 1;
    data = (dnx_data_field_system_headers_system_header_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_CONTEXT_SYS_HDR_PROFILE_FTMH_TSH, 0);
    data->name = "FTMH_TSH";
    data->build_ftmh = 1;
    data->build_tsh = 1;
    data = (dnx_data_field_system_headers_system_header_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_CONTEXT_SYS_HDR_PROFILE_FTMH_TSH_PPH, 0);
    data->name = "FTMH_TSH_PPH";
    data->build_ftmh = 1;
    data->build_tsh = 1;
    data->build_pph = 1;
    data->never_add_pph_learn_ext = 1;
    data = (dnx_data_field_system_headers_system_header_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_FIELD_CONTEXT_SYS_HDR_PROFILE_FTMH_TSH_PPH_UDH, 0);
    data->name = "FTMH_TSH_PPH_UDH";
    data->build_ftmh = 1;
    data->build_tsh = 1;
    data->build_pph = 1;
    data->build_udh = 1;
    data->never_add_pph_learn_ext = 1;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: exem
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define small_app_db_id_size
 * define info:
 * Number of bits used application db
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_app_db_id_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_app_db_id_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_app_db_id_size
 * define info:
 * Number of bits used application db
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_app_db_id_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_app_db_id_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_vmv_size
 * define info:
 * Number of bits used to encode the container size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_vmv_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_vmv_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_vmv_size
 * define info:
 * Number of bits used to encode the container size
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_vmv_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_vmv_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_max_key_size
 * define info:
 * Small EXEM key size in bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_max_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_max_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 80;

    /* Set value */
    define->data = 80;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_max_key_size
 * define info:
 * Large EXEM key size in bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_max_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_max_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 160;

    /* Set value */
    define->data = 160;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_max_entry_result_size
 * define info:
 * Small EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_max_entry_result_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_max_entry_result_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 60;

    /* Set value */
    define->data = 60;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_max_entry_result_size
 * define info:
 * Large EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_max_entry_result_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_max_entry_result_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 60;

    /* Set value */
    define->data = 60;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_max_result_size
 * define info:
 * Small EXEM result (payload) size in bits, not including VMV
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_max_result_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_max_result_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.exem.small_max_entry_result_size_get(unit) - dnx_data_field.exem.small_vmv_size_get(unit));

    /* Set value */
    define->data = (dnx_data_field.exem.small_max_entry_result_size_get(unit) - dnx_data_field.exem.small_vmv_size_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_max_result_size
 * define info:
 * Large EXEM result (payload) size in bits, not including VMV
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_max_result_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_max_result_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.exem.large_max_entry_result_size_get(unit) - dnx_data_field.exem.large_vmv_size_get(unit));

    /* Set value */
    define->data = (dnx_data_field.exem.large_max_entry_result_size_get(unit) - dnx_data_field.exem.large_vmv_size_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_max_container_size
 * define info:
 * Large EXEM maximal container size in bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_max_container_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_max_container_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 120;

    /* Set value */
    define->data = 120;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_max_container_size
 * define info:
 * Large EXEM result (payload) size in bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_max_container_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_max_container_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 240;

    /* Set value */
    define->data = 240;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_key_hash_size
 * define info:
 * number of bits out of key used for hashing (these bits are spared from saving in container)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_key_hash_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_key_hash_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 13;

    /* Set value */
    define->data = 13;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_key_hash_size
 * define info:
 * number of bits out of key used for hashing (these bits are spared from saving in container)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_key_hash_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_key_hash_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 13;

    /* Set value */
    define->data = 13;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_min_app_db_id_range
 * define info:
 * Small EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_min_app_db_id_range_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_min_app_db_id_range;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 48;

    /* Set value */
    define->data = 48;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_min_app_db_id_range
 * define info:
 * Large EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_min_app_db_id_range_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_min_app_db_id_range;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 48;

    /* Set value */
    define->data = 48;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_max_app_db_id_range
 * define info:
 * Small EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_max_app_db_id_range_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_max_app_db_id_range;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 63;

    /* Set value */
    define->data = 63;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_max_app_db_id_range
 * define info:
 * Large EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_max_app_db_id_range_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_max_app_db_id_range;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 63;

    /* Set value */
    define->data = 63;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_ipmf2_key
 * define info:
 * The PMF key used for EXEM lookup by iPMF2. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_ipmf2_key_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_ipmf2_key;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_ipmf2_key_part
 * define info:
 * The PMF key part used for EXEM lookup by iPMF2. 0 means the LSB half, 1 the MSB half.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_ipmf2_key_part_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_ipmf2_key_part;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_ipmf2_key_hw_value
 * define info:
 * The HW value to provide for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_ipmf2_key_hw_value_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_ipmf2_key_hw_value;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.exem.small_ipmf2_key_get(unit);

    /* Set value */
    define->data = dnx_data_field.exem.small_ipmf2_key_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define small_ipmf2_key_hw_bits
 * define info:
 * The number of bits used by the HW for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_small_ipmf2_key_hw_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_small_ipmf2_key_hw_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_ipmf1_key_configurable
 * define info:
 * Whether or not the EXEM key for iPMF1 can be configured on a chip wide basis.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_ipmf1_key_configurable_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_ipmf1_key_configurable;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define large_ipmf1_key
 * define info:
 * The PMF key used for EXEM lookup by iPMF1. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_exem_large_ipmf1_key_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_exem;
    int define_index = dnx_data_field_exem_define_large_ipmf1_key;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: ace
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define ace_id_size
 * define info:
 * Number of bits used for the ACE ID (result type), which serves as an ID for the ACE format and context ID for the ACE EFES.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_ace_id_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_ace_id_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define key_size
 * define info:
 * Number of bits in the key of the PPMC table, including the prefix that indicates the type to the entry
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 22;

    /* Set value */
    define->data = 22;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define key_hash_size
 * define info:
 * Number of bits in the key that are only used in the hash and aren't placed in the entry.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_key_hash_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_key_hash_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 17;

    /* Set value */
    define->data = 17;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define app_db_id_size
 * define info:
 * Number of bits Used for the APP DB ID.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_app_db_id_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_app_db_id_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define payload_size
 * define info:
 * Number of bits used to encode the container size, including the result type
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_payload_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_payload_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 110;

    /* Set value */
    define->data = 110;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define min_key_range_pmf
 * define info:
 * The first entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_min_key_range_pmf_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_min_key_range_pmf;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x3c0000;

    /* Set value */
    define->data = 0x3c0000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_key_range_pmf
 * define info:
 * The last entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_max_key_range_pmf_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_max_key_range_pmf;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x3fffff;

    /* Set value */
    define->data = 0x3fffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define min_ace_id_dynamic_range
 * define info:
 * Minimal number of ACE ID that can be allocated dynamically.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_min_ace_id_dynamic_range_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_min_ace_id_dynamic_range;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ace_id
 * define info:
 * Number of ACE IDs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_ace_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_ace_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_action_per_ace_format
 * define info:
 * Number of action per ACE Format
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_action_per_ace_format_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_action_per_ace_format;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define row_size
 * define info:
 * Number of bits per raw, entry size is number row size times VMV encoding meaning, e.g. half row encoding VMV would mean 60 bits entry size.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_row_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_row_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 120;

    /* Set value */
    define->data = 120;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define min_entry_size
 * define info:
 * Minimum number of bits in entry.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_min_entry_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_min_entry_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 30;

    /* Set value */
    define->data = 30;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ace_id_pmf_alloc_first
 * define info:
 * The first ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_ace_id_pmf_alloc_first_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_ace_id_pmf_alloc_first;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 48;

    /* Set value */
    define->data = 48;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ace_id_pmf_alloc_last
 * define info:
 * The last ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_ace_id_pmf_alloc_last_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_ace_id_pmf_alloc_last;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 63;

    /* Set value */
    define->data = 63;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_masks_per_fes
 * define info:
 * Number of masks per FES
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_masks_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_masks_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_id_per_array
 * define info:
 * Number FESes in each FES array
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_fes_id_per_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_fes_id_per_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_array
 * define info:
 * Number FES arrays
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_fes_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_fes_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_instruction_per_context
 * define info:
 * Number of FES INSTRUCTIONs per ACE ID, also the number of FESes.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_fes_instruction_per_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_fes_instruction_per_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_field.ace.nof_fes_id_per_array_get(unit)*dnx_data_field.ace.nof_fes_array_get(unit));

    /* Set value */
    define->data = (dnx_data_field.ace.nof_fes_id_per_array_get(unit)*dnx_data_field.ace.nof_fes_array_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_programs
 * define info:
 * Number of FES programs. For ACE the FES program is the same as ACE ID. Used here for compatibility with PMF FESes.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_fes_programs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_fes_programs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_prog_per_fes
 * define info:
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_prog_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_prog_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_action
 * define info:
 * Number of bits on the output of a FES.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_nof_bits_in_fes_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_nof_bits_in_fes_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fes_shift_for_zero_bit
 * define info:
 * The shift used for obtaining an always zero bit for input to FES. Uses the zero padding at the end of the payload, expected to work only if EFES field type=1.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_ace_fes_shift_for_zero_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_ace;
    int define_index = dnx_data_field_ace_define_fes_shift_for_zero_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 110;

    /* Set value */
    define->data = 110;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: entry
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define dir_ext_nof_fields
 * define info:
 * The maximum number of fields in a direct extraction request. \n                                                   (e.g. if we want the action to be composed of 3 bits of constant value, 5 bits from the key, \n                                                   5 bits of constant value and then 4 bits from the key we need at least 4 fields.)\n                                                   Used by dnx_field_dir_ext_action_t for the array size of the fields. \n                                                   Arbitrary value, can be increased.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_entry_dir_ext_nof_fields_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_entry;
    int define_index = dnx_data_field_entry_define_dir_ext_nof_fields;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_action_params_per_entry
 * define info:
 * Number of action parameters can be given for each action \n                                                             e.g. action values that are filled for TCAM action result
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_entry_nof_action_params_per_entry_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_entry;
    int define_index = dnx_data_field_entry_define_nof_action_params_per_entry;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_qual_params_per_entry
 * define info:
 * Number of qualifiers parameters can be given for each qualifier type \n                                                             e.g. qualifier/key values that are filled for TCAM key
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_entry_nof_qual_params_per_entry_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_entry;
    int define_index = dnx_data_field_entry_define_nof_qual_params_per_entry;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: L4_Ops
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define udp_position
 * define info:
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_L4_Ops_udp_position_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_L4_Ops;
    int define_index = dnx_data_field_L4_Ops_define_udp_position;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 9;

    /* Set value */
    define->data = 9;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tcp_position
 * define info:
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_L4_Ops_tcp_position_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_L4_Ops;
    int define_index = dnx_data_field_L4_Ops_define_tcp_position;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: encoded_qual_actions_offset
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define trap_strength_offset
 * define info:
 * The offset of the Trap Strength in the action
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_encoded_qual_actions_offset_trap_strength_offset_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_encoded_qual_actions_offset;
    int define_index = dnx_data_field_encoded_qual_actions_offset_define_trap_strength_offset;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 9;

    /* Set value */
    define->data = 9;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define trap_qualifier_offset
 * define info:
 * The offset of the Trap Qualifier in the action
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_encoded_qual_actions_offset_trap_qualifier_offset_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_encoded_qual_actions_offset;
    int define_index = dnx_data_field_encoded_qual_actions_offset_define_trap_qualifier_offset;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 13;

    /* Set value */
    define->data = 13;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define sniff_qualifier_offset
 * define info:
 * The offset of the Snoop qualifier in the action
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_encoded_qual_actions_offset_sniff_qualifier_offset_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_encoded_qual_actions_offset;
    int define_index = dnx_data_field_encoded_qual_actions_offset_define_sniff_qualifier_offset;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 12;

    /* Set value */
    define->data = 12;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define mirror_qualifier_offset
 * define info:
 * The offset of the Mirror Qualifier in the action
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_encoded_qual_actions_offset_mirror_qualifier_offset_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_encoded_qual_actions_offset;
    int define_index = dnx_data_field_encoded_qual_actions_offset_define_mirror_qualifier_offset;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 9;

    /* Set value */
    define->data = 9;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: Compare_operand
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define equal
 * define info:
 * The position in the qual showing that the result of compare is equal
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_Compare_operand_equal_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_Compare_operand;
    int define_index = dnx_data_field_Compare_operand_define_equal;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define not_equal
 * define info:
 * The position in the qual showing that the result of compare is not equal
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_Compare_operand_not_equal_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_Compare_operand;
    int define_index = dnx_data_field_Compare_operand_define_not_equal;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define smaller
 * define info:
 * The position in the qual showing that the first compare value is smaller then the second
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_Compare_operand_smaller_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_Compare_operand;
    int define_index = dnx_data_field_Compare_operand_define_smaller;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define not_smaller
 * define info:
 * The position in the qual showing that the first compare value is not smaller then the second
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_Compare_operand_not_smaller_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_Compare_operand;
    int define_index = dnx_data_field_Compare_operand_define_not_smaller;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define bigger
 * define info:
 * The position in the qual showing that the first compare value is bigger then the second
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_Compare_operand_bigger_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_Compare_operand;
    int define_index = dnx_data_field_Compare_operand_define_bigger;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define not_bigger
 * define info:
 * The position in the qual showing that the first compare value is not bigger then the second
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_Compare_operand_not_bigger_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_Compare_operand;
    int define_index = dnx_data_field_Compare_operand_define_not_bigger;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_operands
 * define info:
 * The number of all operands
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_Compare_operand_nof_operands_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_Compare_operand;
    int define_index = dnx_data_field_Compare_operand_define_nof_operands;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: diag
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_diag_tcam_cs_hit_bit_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_diag;
    int feature_index = dnx_data_field_diag_tcam_cs_hit_bit_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define bytes_to_remove_mask
 * define info:
 * Mask of bits, which are related to the value of bytes to remove, from the signal.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_diag_bytes_to_remove_mask_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_diag;
    int define_index = dnx_data_field_diag_define_bytes_to_remove_mask;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x0F;

    /* Set value */
    define->data = 0x0F;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define layers_to_remove_size_in_bit
 * define info:
 * Size of the layers to remove value in bits, to be used for shifting the signal value.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_diag_layers_to_remove_size_in_bit_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_diag;
    int define_index = dnx_data_field_diag_define_layers_to_remove_size_in_bit;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define layers_to_remove_mask
 * define info:
 * Mask of bits, which are related to the value of layers to remove, from the signal.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_diag_layers_to_remove_mask_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_diag;
    int define_index = dnx_data_field_diag_define_layers_to_remove_mask;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x07;

    /* Set value */
    define->data = 0x07;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_signals_per_action
 * define info:
 * Maximum number of signals per action.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_diag_nof_signals_per_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_diag;
    int define_index = dnx_data_field_diag_define_nof_signals_per_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 10;

    /* Set value */
    define->data = 10;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_signals_per_qualifier
 * define info:
 * Maximum number of signals per qualifier.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_diag_nof_signals_per_qualifier_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_diag;
    int define_index = dnx_data_field_diag_define_nof_signals_per_qualifier;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 10;

    /* Set value */
    define->data = 10;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: common_max_val
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_ffc
 * define info:
 * Maximal number of FFC's in all stages
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_ffc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_ffc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_ffc_get(unit), dnx_data_field.base_ipmf2.nof_ffc_get(unit), dnx_data_field.base_ipmf3.nof_ffc_get(unit), dnx_data_field.base_epmf.nof_ffc_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_ffc_get(unit), dnx_data_field.base_ipmf2.nof_ffc_get(unit), dnx_data_field.base_ipmf3.nof_ffc_get(unit), dnx_data_field.base_epmf.nof_ffc_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_keys
 * define info:
 * Number of keys for the entire PMF module
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_keys_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_keys;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_keys_get(unit), dnx_data_field.base_ipmf2.nof_keys_get(unit), dnx_data_field.base_ipmf3.nof_keys_get(unit), dnx_data_field.base_epmf.nof_keys_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_keys_get(unit), dnx_data_field.base_ipmf2.nof_keys_get(unit), dnx_data_field.base_ipmf3.nof_keys_get(unit), dnx_data_field.base_epmf.nof_keys_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_masks_per_fes
 * define info:
 * Number of masks per FES
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_masks_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_masks_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_masks_per_fes_get(unit), dnx_data_field.base_ipmf3.nof_masks_per_fes_get(unit), dnx_data_field.base_epmf.nof_masks_per_fes_get(unit));

    /* Set value */
    define->data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_masks_per_fes_get(unit), dnx_data_field.base_ipmf3.nof_masks_per_fes_get(unit), dnx_data_field.base_epmf.nof_masks_per_fes_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_id_per_array
 * define info:
 * Number FESes in each FES array
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_fes_id_per_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_fes_id_per_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_fes_id_per_array_get(unit), dnx_data_field.base_ipmf2.nof_fes_id_per_array_get(unit), dnx_data_field.base_ipmf3.nof_fes_id_per_array_get(unit), dnx_data_field.base_epmf.nof_fes_id_per_array_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_fes_id_per_array_get(unit), dnx_data_field.base_ipmf2.nof_fes_id_per_array_get(unit), dnx_data_field.base_ipmf3.nof_fes_id_per_array_get(unit), dnx_data_field.base_epmf.nof_fes_id_per_array_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_array
 * define info:
 * Number FES arrays
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_fes_array_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_fes_array;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_fes_array_get(unit), dnx_data_field.base_ipmf2.nof_fes_array_get(unit), dnx_data_field.base_ipmf3.nof_fes_array_get(unit), dnx_data_field.base_epmf.nof_fes_array_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_fes_array_get(unit), dnx_data_field.base_ipmf2.nof_fes_array_get(unit), dnx_data_field.base_ipmf3.nof_fes_array_get(unit), dnx_data_field.base_epmf.nof_fes_array_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_instruction_per_context
 * define info:
 * Number of FES INSTRUCTIONs per context
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_fes_instruction_per_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_fes_instruction_per_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_fes_instruction_per_context_get(unit), dnx_data_field.base_ipmf2.nof_fes_instruction_per_context_get(unit), dnx_data_field.base_ipmf3.nof_fes_instruction_per_context_get(unit), dnx_data_field.base_epmf.nof_fes_instruction_per_context_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_fes_instruction_per_context_get(unit), dnx_data_field.base_ipmf2.nof_fes_instruction_per_context_get(unit), dnx_data_field.base_ipmf3.nof_fes_instruction_per_context_get(unit), dnx_data_field.base_epmf.nof_fes_instruction_per_context_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_programs
 * define info:
 * Number of FES programs
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_fes_programs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_fes_programs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_fes_programs_get(unit), dnx_data_field.base_ipmf3.nof_fes_programs_get(unit), dnx_data_field.base_epmf.nof_fes_programs_get(unit));

    /* Set value */
    define->data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_fes_programs_get(unit), dnx_data_field.base_ipmf3.nof_fes_programs_get(unit), dnx_data_field.base_epmf.nof_fes_programs_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_prog_per_fes
 * define info:
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_prog_per_fes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_prog_per_fes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_prog_per_fes_get(unit), dnx_data_field.base_ipmf3.nof_prog_per_fes_get(unit), dnx_data_field.base_epmf.nof_prog_per_fes_get(unit));

    /* Set value */
    define->data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_prog_per_fes_get(unit), dnx_data_field.base_ipmf3.nof_prog_per_fes_get(unit), dnx_data_field.base_epmf.nof_prog_per_fes_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_program_selection_lines
 * define info:
 * Number of Ingress context selection lines
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_program_selection_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_program_selection_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_cs_lines_get(unit), dnx_data_field.base_ipmf2.nof_cs_lines_get(unit), dnx_data_field.base_ipmf3.nof_cs_lines_get(unit), dnx_data_field.base_epmf.nof_cs_lines_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_cs_lines_get(unit), dnx_data_field.base_ipmf2.nof_cs_lines_get(unit), dnx_data_field.base_ipmf3.nof_cs_lines_get(unit), dnx_data_field.base_epmf.nof_cs_lines_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define program_selection_cam_mask_nof_bits
 * define info:
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_program_selection_cam_mask_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_program_selection_cam_mask_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.program_selection_cam_mask_nof_bits_get(unit), dnx_data_field.base_ipmf2.program_selection_cam_mask_nof_bits_get(unit), dnx_data_field.base_ipmf3.program_selection_cam_mask_nof_bits_get(unit), dnx_data_field.base_epmf.program_selection_cam_mask_nof_bits_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.program_selection_cam_mask_nof_bits_get(unit), dnx_data_field.base_ipmf2.program_selection_cam_mask_nof_bits_get(unit), dnx_data_field.base_ipmf3.program_selection_cam_mask_nof_bits_get(unit), dnx_data_field.base_epmf.program_selection_cam_mask_nof_bits_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_cs_lines
 * define info:
 * Number of program selection lines
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_cs_lines_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_cs_lines;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_cs_lines_get(unit), dnx_data_field.base_ipmf2.nof_cs_lines_get(unit), dnx_data_field.base_ipmf3.nof_cs_lines_get(unit), dnx_data_field.base_epmf.nof_cs_lines_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_cs_lines_get(unit), dnx_data_field.base_ipmf2.nof_cs_lines_get(unit), dnx_data_field.base_ipmf3.nof_cs_lines_get(unit), dnx_data_field.base_epmf.nof_cs_lines_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_contexts
 * define info:
 * Number of contexts per PMF
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_contexts_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_contexts;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_contexts_get(unit), dnx_data_field.base_ipmf2.nof_contexts_get(unit), dnx_data_field.base_ipmf3.nof_contexts_get(unit), dnx_data_field.base_epmf.nof_contexts_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_contexts_get(unit), dnx_data_field.base_ipmf2.nof_contexts_get(unit), dnx_data_field.base_ipmf3.nof_contexts_get(unit), dnx_data_field.base_epmf.nof_contexts_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_actions
 * define info:
 * Number of actions
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_actions_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_actions;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_actions_get(unit),  dnx_data_field.base_ipmf3.nof_actions_get(unit), dnx_data_field.base_epmf.nof_actions_get(unit));

    /* Set value */
    define->data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_actions_get(unit),  dnx_data_field.base_ipmf3.nof_actions_get(unit), dnx_data_field.base_epmf.nof_actions_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_qualifiers
 * define info:
 * Number of qualifiers
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_qualifiers_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_qualifiers;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_qualifiers_get(unit), dnx_data_field.base_ipmf2.nof_qualifiers_get(unit), dnx_data_field.base_ipmf3.nof_qualifiers_get(unit), dnx_data_field.base_epmf.nof_qualifiers_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_qualifiers_get(unit), dnx_data_field.base_ipmf2.nof_qualifiers_get(unit), dnx_data_field.base_ipmf3.nof_qualifiers_get(unit), dnx_data_field.base_epmf.nof_qualifiers_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_80B_zones
 * define info:
 * Number of Ingress PMF 80b dedicated instruction groups
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_80B_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_80B_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_80B_zones_get(unit),dnx_data_field.base_ipmf2.nof_80B_zones_get(unit), dnx_data_field.base_ipmf3.nof_80B_zones_get(unit), dnx_data_field.base_epmf.nof_80B_zones_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_80B_zones_get(unit),dnx_data_field.base_ipmf2.nof_80B_zones_get(unit), dnx_data_field.base_ipmf3.nof_80B_zones_get(unit), dnx_data_field.base_epmf.nof_80B_zones_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zones
 * define info:
 * Number of Ingress PMF 80b key zones
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_key_zones_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_key_zones;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_key_zones_get(unit), dnx_data_field.base_ipmf2.nof_key_zones_get(unit), dnx_data_field.base_ipmf3.nof_key_zones_get(unit), dnx_data_field.base_epmf.nof_key_zones_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_key_zones_get(unit), dnx_data_field.base_ipmf2.nof_key_zones_get(unit), dnx_data_field.base_ipmf3.nof_key_zones_get(unit), dnx_data_field.base_epmf.nof_key_zones_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_key_zone_bits
 * define info:
 * Number of Ingress PMF 80b key zone bits
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_key_zone_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_key_zone_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_key_zone_bits_get(unit), dnx_data_field.base_ipmf2.nof_key_zone_bits_get(unit), dnx_data_field.base_ipmf3.nof_key_zone_bits_get(unit), dnx_data_field.base_epmf.nof_key_zone_bits_get(unit));

    /* Set value */
    define->data = UTILEX_MAX4(dnx_data_field.base_ipmf1.nof_key_zone_bits_get(unit), dnx_data_field.base_ipmf2.nof_key_zone_bits_get(unit), dnx_data_field.base_ipmf3.nof_key_zone_bits_get(unit), dnx_data_field.base_epmf.nof_key_zone_bits_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_action
 * define info:
 * Number of bits on the outpus of a FES.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_bits_in_fes_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_bits_in_fes_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_bits_in_fes_action_get(unit), dnx_data_field.base_ipmf3.nof_bits_in_fes_action_get(unit), dnx_data_field.base_epmf.nof_bits_in_fes_action_get(unit));

    /* Set value */
    define->data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_bits_in_fes_action_get(unit), dnx_data_field.base_ipmf3.nof_bits_in_fes_action_get(unit), dnx_data_field.base_epmf.nof_bits_in_fes_action_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fes_key_select
 * define info:
 * Number of bits on input to FES.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_bits_in_fes_key_select_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_bits_in_fes_key_select;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_bits_in_fes_key_select_get(unit), dnx_data_field.base_ipmf3.nof_bits_in_fes_key_select_get(unit), dnx_data_field.base_epmf.nof_bits_in_fes_key_select_get(unit));

    /* Set value */
    define->data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_bits_in_fes_key_select_get(unit), dnx_data_field.base_ipmf3.nof_bits_in_fes_key_select_get(unit), dnx_data_field.base_epmf.nof_bits_in_fes_key_select_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fes_key_selects_on_one_actions_line
 * define info:
 * Number of 'key select's that can be applied on one line on actions table. ('double key' actions are considered one line)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_fes_key_selects_on_one_actions_line_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_fes_key_selects_on_one_actions_line;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_fes_key_selects_on_one_actions_line_get(unit), dnx_data_field.base_ipmf3.nof_fes_key_selects_on_one_actions_line_get(unit), dnx_data_field.base_epmf.nof_fes_key_selects_on_one_actions_line_get(unit));

    /* Set value */
    define->data = UTILEX_MAX3(dnx_data_field.base_ipmf1.nof_fes_key_selects_on_one_actions_line_get(unit), dnx_data_field.base_ipmf3.nof_fes_key_selects_on_one_actions_line_get(unit), dnx_data_field.base_epmf.nof_fes_key_selects_on_one_actions_line_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ffc_in_qual
 * define info:
 * Maximal number of ffc for one qualifier.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_ffc_in_qual_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_ffc_in_qual;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_ffc
 * define info:
 * Number of bits in ffc.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_bits_in_ffc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_bits_in_ffc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ffc_in_uint32
 * define info:
 * Number of uint32 needed to hold bitmap for maximum number of FFC's.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_ffc_in_uint32_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_ffc_in_uint32;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = ((dnx_data_field.common_max_val.nof_ffc_get(unit)+32-1)/32);

    /* Set value */
    define->data = ((dnx_data_field.common_max_val.nof_ffc_get(unit)+32-1)/32);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_action_per_group
 * define info:
 * Maxmimal number of actions between both Field Group and ACE format. Used for arrays in functions that serve both.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_action_per_group_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_action_per_group;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX(dnx_data_field.group.nof_action_per_fg_get(unit), dnx_data_field.ace.nof_action_per_ace_format_get(unit));

    /* Set value */
    define->data = UTILEX_MAX(dnx_data_field.group.nof_action_per_fg_get(unit), dnx_data_field.ace.nof_action_per_ace_format_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_layer_records
 * define info:
 * Maximal number of layer records.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_layer_records_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_layer_records;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX(dnx_data_field.qual.ingress_nof_layer_records_get(unit), dnx_data_field.qual.egress_nof_layer_records_get(unit));

    /* Set value */
    define->data = UTILEX_MAX(dnx_data_field.qual.ingress_nof_layer_records_get(unit), dnx_data_field.qual.egress_nof_layer_records_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_l4_ops_ranges
 * define info:
 * Maximal number of ranges for L4 Ops.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_l4_ops_ranges_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_l4_ops_ranges;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX(dnx_data_field.base_ipmf1.nof_l4_ops_ranges_get(unit), dnx_data_field.base_epmf.nof_l4_ops_ranges_get(unit));

    /* Set value */
    define->data = UTILEX_MAX(dnx_data_field.base_ipmf1.nof_l4_ops_ranges_get(unit), dnx_data_field.base_epmf.nof_l4_ops_ranges_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_pkt_hdr_ranges
 * define info:
 * Maximal number of ranges for packet header.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_pkt_hdr_ranges_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_pkt_hdr_ranges;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.base_ipmf1.nof_pkt_hdr_ranges_get(unit);

    /* Set value */
    define->data = dnx_data_field.base_ipmf1.nof_pkt_hdr_ranges_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_out_lif_ranges
 * define info:
 * Maximal number of ranges for Out Lif.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_out_lif_ranges_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_out_lif_ranges;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MAX(dnx_data_field.base_ipmf1.nof_out_lif_ranges_get(unit), dnx_data_field.base_ipmf3.nof_out_lif_ranges_get(unit));

    /* Set value */
    define->data = UTILEX_MAX(dnx_data_field.base_ipmf1.nof_out_lif_ranges_get(unit), dnx_data_field.base_ipmf3.nof_out_lif_ranges_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define kbr_size
 * define info:
 * Maximal KBR size.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_kbr_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_kbr_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 160;

    /* Set value */
    define->data = 160;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_compare_pairs
 * define info:
 * Maximal number of pairs used for compare.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_compare_pairs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_compare_pairs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_compare_pairs_in_compare_mode
 * define info:
 * Number compare pairs in compare mode.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_compare_pairs_in_compare_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_compare_pairs_in_compare_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.base_ipmf1.nof_compare_pairs_in_compare_mode_get(unit);

    /* Set value */
    define->data = dnx_data_field.base_ipmf1.nof_compare_pairs_in_compare_mode_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_compare_keys_in_compare_mode
 * define info:
 * Number compare keys in compare mode.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_compare_keys_in_compare_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_compare_keys_in_compare_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.base_ipmf1.nof_compare_keys_in_compare_mode_get(unit);

    /* Set value */
    define->data = dnx_data_field.base_ipmf1.nof_compare_keys_in_compare_mode_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bits_in_fem_action
 * define info:
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_bits_in_fem_action_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_bits_in_fem_action;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.base_ipmf1.nof_bits_in_fem_action_get(unit);

    /* Set value */
    define->data = dnx_data_field.base_ipmf1.nof_bits_in_fem_action_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fem_condition
 * define info:
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_fem_condition_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_fem_condition;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.base_ipmf1.nof_fem_condition_get(unit);

    /* Set value */
    define->data = dnx_data_field.base_ipmf1.nof_fem_condition_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fem_map_index
 * define info:
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_fem_map_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_fem_map_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_field.base_ipmf1.nof_fem_map_index_get(unit);

    /* Set value */
    define->data = dnx_data_field.base_ipmf1.nof_fem_map_index_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_array_ids
 * define info:
 * Total number of 'array_is's which are used to identify a range of FESes or FEMs. See BCM_FIELD_ACTION_POSITION.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_nof_array_ids_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_nof_array_ids;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define dbal_pairs
 * define info:
 * Maximum number of pairs which are used to identify the DBAL key/result field in dnx_field_dbal_entry_set function. 
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_dbal_pairs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int define_index = dnx_data_field_common_max_val_define_dbal_pairs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 10;

    /* Set value */
    define->data = 10;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table array_id_type
 * Module - 'field', Submodule - 'common_max_val', table - 'array_id_type'
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_common_max_val_array_id_type_set(
    int unit)
{
    int array_id_index;
    dnx_data_field_common_max_val_array_id_type_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_common_max_val;
    int table_index = dnx_data_field_common_max_val_table_array_id_type;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_field.common_max_val.nof_array_ids_get(unit);
    table->info_get.key_size[0] = dnx_data_field.common_max_val.nof_array_ids_get(unit);

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_field_common_max_val_array_id_type_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_field_common_max_val_table_array_id_type");

    /* Store Default Values */
    default_data = (dnx_data_field_common_max_val_array_id_type_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->is_fes = 0;
    default_data->is_fem = 0;
    default_data->fes_array_index = 0;
    default_data->fem_array_index = 0;
    /* Set Default Values */
    for (array_id_index = 0; array_id_index < table->keys[0].size; array_id_index++)
    {
        data = (dnx_data_field_common_max_val_array_id_type_t *) dnxc_data_mgmt_table_data_get(unit, table, array_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_field_common_max_val_array_id_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->is_fes = 1;
    data->is_fem = 0;
    data->fes_array_index = 0;
    data = (dnx_data_field_common_max_val_array_id_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->is_fes = 0;
    data->is_fem = 1;
    data->fem_array_index = 0;
    data = (dnx_data_field_common_max_val_array_id_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->is_fes = 1;
    data->is_fem = 0;
    data->fes_array_index = 1;
    data = (dnx_data_field_common_max_val_array_id_type_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->is_fes = 0;
    data->is_fem = 1;
    data->fem_array_index = 1;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: init
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define wa_fec_dest
 * define info:
 * APP WA for fec destination
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_init_wa_fec_dest_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_init;
    int define_index = dnx_data_field_init_define_wa_fec_dest;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wa_l4_trap
 * define info:
 * APP WA for L4 Trap
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_init_wa_l4_trap_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_init;
    int define_index = dnx_data_field_init_define_wa_l4_trap;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wa_oam_layer_index
 * define info:
 * APP WA for OAM Layer Index
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_init_wa_oam_layer_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_init;
    int define_index = dnx_data_field_init_define_wa_oam_layer_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wa_oam_stat
 * define info:
 * APP WA for OAM Statistics
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_init_wa_oam_stat_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_init;
    int define_index = dnx_data_field_init_define_wa_oam_stat;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wa_flow_id
 * define info:
 * APP WA for Flow ID
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_init_wa_flow_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_init;
    int define_index = dnx_data_field_init_define_wa_flow_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wa_roo
 * define info:
 * APP WA for Roo
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_init_wa_roo_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_init;
    int define_index = dnx_data_field_init_define_wa_roo;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wa_j1_same_port
 * define info:
 * APP WA for J1 Same port
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_init_wa_j1_same_port_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_init;
    int define_index = dnx_data_field_init_define_wa_j1_same_port;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define wa_j1_learning
 * define info:
 * APP WA for J1 Learning
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_init_wa_j1_learning_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_init;
    int define_index = dnx_data_field_init_define_wa_j1_learning;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: hw_workarounds
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define ecc_wa_enable
 * define info:
 * ECC is calculated per whole entry on each entry write, therefore, when writing half-entries\n                      wrong ECC values is being calculated, this workaround enables read-modify-write of the whole\n                      entry instead of writing half-entries to have correct ECC calculated on each write.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_hw_workarounds_ecc_wa_enable_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_hw_workarounds;
    int define_index = dnx_data_field_hw_workarounds_define_ecc_wa_enable;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: hw_features
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define switch_to_acl_context
 * define info:
 * Allows to swap the acl_context and fwd_context signals after iPMF1/2 using IPPC_PMF_GENERAL.SWITCH_TO_ACL_CONTEXT.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_hw_features_switch_to_acl_context_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_hw_features;
    int define_index = dnx_data_field_hw_features_define_switch_to_acl_context;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: minor_changes_j2_a0_b0
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define lr_eth_is_da_mac_valid
 * define info:
 * Whether layer record ETH_IS_DA_MAC works on device (works on JR2_B0 but not on JR2_A0). For internal DNX DATA usage only.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_minor_changes_j2_a0_b0_lr_eth_is_da_mac_valid_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_minor_changes_j2_a0_b0;
    int define_index = dnx_data_field_minor_changes_j2_a0_b0_define_lr_eth_is_da_mac_valid;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define per_pp_port_pmf_profile_cs_offset
 * define info:
 * The placement of PMF_PROFILE field within ERPP_PER_PORT_TABLE. Used because DBAL mapping by device didn't work.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_minor_changes_j2_a0_b0_per_pp_port_pmf_profile_cs_offset_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_minor_changes_j2_a0_b0;
    int define_index = dnx_data_field_minor_changes_j2_a0_b0_define_per_pp_port_pmf_profile_cs_offset;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tcam_result_flip_eco
 * define info:
 * The TCAM result flip ECO is about flippiing lsb and msb parts of the TCAM-result in order to support 80b result being parsed by ARR
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_field_minor_changes_j2_a0_b0_tcam_result_flip_eco_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_field;
    int submodule_index = dnx_data_field_submodule_minor_changes_j2_a0_b0;
    int define_index = dnx_data_field_minor_changes_j2_a0_b0_define_tcam_result_flip_eco;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jer2_a0_data_field_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_field;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: base_ipmf1
     */
    submodule_index = dnx_data_field_submodule_base_ipmf1;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_base_ipmf1_define_nof_ffc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_ffc_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_ffc_groups;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_ffc_groups_set;
    data_index = dnx_data_field_base_ipmf1_define_ffc_group_one_lower;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_ffc_group_one_lower_set;
    data_index = dnx_data_field_base_ipmf1_define_ffc_group_one_upper;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_ffc_group_one_upper_set;
    data_index = dnx_data_field_base_ipmf1_define_ffc_group_two_lower;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_ffc_group_two_lower_set;
    data_index = dnx_data_field_base_ipmf1_define_ffc_group_two_upper;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_ffc_group_two_upper_set;
    data_index = dnx_data_field_base_ipmf1_define_ffc_group_three_lower;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_ffc_group_three_lower_set;
    data_index = dnx_data_field_base_ipmf1_define_ffc_group_three_upper;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_ffc_group_three_upper_set;
    data_index = dnx_data_field_base_ipmf1_define_ffc_group_four_lower;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_ffc_group_four_lower_set;
    data_index = dnx_data_field_base_ipmf1_define_ffc_group_four_upper;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_ffc_group_four_upper_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_keys;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_keys_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_keys_alloc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_keys_alloc_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_tcam;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_keys_alloc_for_tcam_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_exem;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_keys_alloc_for_exem_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_masks_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_masks_per_fes_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fes_id_per_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fes_id_per_array_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fes_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fes_array_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fes_instruction_per_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fes_instruction_per_context_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fes_programs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fes_programs_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_prog_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_prog_per_fes_set;
    data_index = dnx_data_field_base_ipmf1_define_program_selection_cam_mask_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_program_selection_cam_mask_nof_bits_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_contexts;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_contexts_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_link_profiles;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_link_profiles_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_cs_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_cs_lines_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_actions;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_actions_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_qualifiers;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_qualifiers_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_80B_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_80B_zones_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_key_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_key_zones_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_key_zone_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_key_zone_bits_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fes_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fes_action_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fes_key_select;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fes_key_select_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fes_key_selects_on_one_actions_line;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fes_key_selects_on_one_actions_line_set;
    data_index = dnx_data_field_base_ipmf1_define_fem_condition_ms_bit_min_value;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_fem_condition_ms_bit_min_value_set;
    data_index = dnx_data_field_base_ipmf1_define_fem_condition_ms_bit_max_value;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_fem_condition_ms_bit_max_value_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_programs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_programs_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fem_programs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fem_programs_set;
    data_index = dnx_data_field_base_ipmf1_define_log_nof_bits_in_fem_key_select;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_log_nof_bits_in_fem_key_select_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_key_select;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_key_select_set;
    data_index = dnx_data_field_base_ipmf1_define_fem_key_select_resolution_in_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_fem_key_select_resolution_in_bits_set;
    data_index = dnx_data_field_base_ipmf1_define_log_nof_bits_in_fem_map_data_field;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_log_nof_bits_in_fem_map_data_field_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_map_data_field;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_map_data_field_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action_fems_2_15;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_2_15_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action_fems_0_1;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_0_1_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_action_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_condition;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_condition_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fem_condition;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fem_condition_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_map_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_map_index_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fem_map_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fem_map_index_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_bits_in_fem_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_bits_in_fem_id_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fem_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fem_id_set;
    data_index = dnx_data_field_base_ipmf1_define_num_fems_with_short_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_num_fems_with_short_action_set;
    data_index = dnx_data_field_base_ipmf1_define_num_bits_in_fem_field_select;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_num_bits_in_fem_field_select_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fem_id_per_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fem_id_per_array_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fem_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fem_array_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_fems_per_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_fems_per_context_set;
    data_index = dnx_data_field_base_ipmf1_define_default_strength;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_default_strength_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_compare_pairs_in_compare_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_compare_pairs_in_compare_mode_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_compare_keys_in_compare_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_compare_keys_in_compare_mode_set;
    data_index = dnx_data_field_base_ipmf1_define_compare_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_compare_key_size_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_l4_ops_ranges;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_l4_ops_ranges_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_pkt_hdr_ranges;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_pkt_hdr_ranges_set;
    data_index = dnx_data_field_base_ipmf1_define_nof_out_lif_ranges;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_nof_out_lif_ranges_set;
    data_index = dnx_data_field_base_ipmf1_define_fes_key_select_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_fes_key_select_for_zero_bit_set;
    data_index = dnx_data_field_base_ipmf1_define_fes_shift_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_fes_shift_for_zero_bit_set;
    data_index = dnx_data_field_base_ipmf1_define_cmp_selection;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf1_cmp_selection_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: base_ipmf2
     */
    submodule_index = dnx_data_field_submodule_base_ipmf2;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_base_ipmf2_define_nof_ffc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_ffc_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_ffc_groups;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_ffc_groups_set;
    data_index = dnx_data_field_base_ipmf2_define_ffc_group_one_lower;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_ffc_group_one_lower_set;
    data_index = dnx_data_field_base_ipmf2_define_ffc_group_one_upper;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_ffc_group_one_upper_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_keys;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_keys_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_keys_alloc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_keys_alloc_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_tcam;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_keys_alloc_for_tcam_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_exem;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_keys_alloc_for_exem_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_dir_ext;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_keys_alloc_for_dir_ext_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_masks_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_masks_per_fes_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_fes_id_per_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_fes_id_per_array_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_fes_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_fes_array_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_fes_instruction_per_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_fes_instruction_per_context_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_cs_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_cs_lines_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_contexts;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_contexts_set;
    data_index = dnx_data_field_base_ipmf2_define_program_selection_cam_mask_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_program_selection_cam_mask_nof_bits_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_qualifiers;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_qualifiers_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_80B_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_80B_zones_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_key_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_key_zones_set;
    data_index = dnx_data_field_base_ipmf2_define_nof_key_zone_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_nof_key_zone_bits_set;
    data_index = dnx_data_field_base_ipmf2_define_fes_key_select_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_fes_key_select_for_zero_bit_set;
    data_index = dnx_data_field_base_ipmf2_define_fes_shift_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf2_fes_shift_for_zero_bit_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: base_ipmf3
     */
    submodule_index = dnx_data_field_submodule_base_ipmf3;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_base_ipmf3_define_nof_ffc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_ffc_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_ffc_groups;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_ffc_groups_set;
    data_index = dnx_data_field_base_ipmf3_define_ffc_group_one_lower;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_ffc_group_one_lower_set;
    data_index = dnx_data_field_base_ipmf3_define_ffc_group_one_upper;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_ffc_group_one_upper_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_keys;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_keys_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_keys_alloc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_keys_alloc_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_tcam;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_keys_alloc_for_tcam_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_exem;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_keys_alloc_for_exem_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_dir_ext;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_keys_alloc_for_dir_ext_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_masks_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_masks_per_fes_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_fes_id_per_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_fes_id_per_array_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_fes_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_fes_array_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_fes_instruction_per_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_fes_instruction_per_context_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_fes_programs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_fes_programs_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_prog_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_prog_per_fes_set;
    data_index = dnx_data_field_base_ipmf3_define_program_selection_cam_mask_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_program_selection_cam_mask_nof_bits_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_contexts;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_contexts_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_cs_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_cs_lines_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_actions;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_actions_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_qualifiers;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_qualifiers_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_80B_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_80B_zones_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_key_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_key_zones_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_key_zone_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_key_zone_bits_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_bits_in_fes_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_bits_in_fes_action_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_bits_in_fes_key_select;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_bits_in_fes_key_select_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_fes_key_selects_on_one_actions_line;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_fes_key_selects_on_one_actions_line_set;
    data_index = dnx_data_field_base_ipmf3_define_default_strength;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_default_strength_set;
    data_index = dnx_data_field_base_ipmf3_define_nof_out_lif_ranges;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_nof_out_lif_ranges_set;
    data_index = dnx_data_field_base_ipmf3_define_fes_key_select_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_fes_key_select_for_zero_bit_set;
    data_index = dnx_data_field_base_ipmf3_define_fes_shift_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ipmf3_fes_shift_for_zero_bit_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: base_epmf
     */
    submodule_index = dnx_data_field_submodule_base_epmf;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_base_epmf_define_nof_ffc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_ffc_set;
    data_index = dnx_data_field_base_epmf_define_nof_ffc_groups;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_ffc_groups_set;
    data_index = dnx_data_field_base_epmf_define_ffc_group_one_lower;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_ffc_group_one_lower_set;
    data_index = dnx_data_field_base_epmf_define_ffc_group_one_upper;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_ffc_group_one_upper_set;
    data_index = dnx_data_field_base_epmf_define_nof_keys;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_keys_set;
    data_index = dnx_data_field_base_epmf_define_nof_keys_alloc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_keys_alloc_set;
    data_index = dnx_data_field_base_epmf_define_nof_keys_alloc_for_tcam;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_keys_alloc_for_tcam_set;
    data_index = dnx_data_field_base_epmf_define_nof_keys_alloc_for_exem;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_keys_alloc_for_exem_set;
    data_index = dnx_data_field_base_epmf_define_nof_masks_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_masks_per_fes_set;
    data_index = dnx_data_field_base_epmf_define_nof_fes_id_per_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_fes_id_per_array_set;
    data_index = dnx_data_field_base_epmf_define_nof_fes_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_fes_array_set;
    data_index = dnx_data_field_base_epmf_define_nof_fes_instruction_per_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_fes_instruction_per_context_set;
    data_index = dnx_data_field_base_epmf_define_nof_fes_programs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_fes_programs_set;
    data_index = dnx_data_field_base_epmf_define_nof_prog_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_prog_per_fes_set;
    data_index = dnx_data_field_base_epmf_define_program_selection_cam_mask_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_program_selection_cam_mask_nof_bits_set;
    data_index = dnx_data_field_base_epmf_define_nof_cs_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_cs_lines_set;
    data_index = dnx_data_field_base_epmf_define_nof_contexts;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_contexts_set;
    data_index = dnx_data_field_base_epmf_define_nof_actions;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_actions_set;
    data_index = dnx_data_field_base_epmf_define_nof_qualifiers;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_qualifiers_set;
    data_index = dnx_data_field_base_epmf_define_nof_80B_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_80B_zones_set;
    data_index = dnx_data_field_base_epmf_define_nof_key_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_key_zones_set;
    data_index = dnx_data_field_base_epmf_define_nof_key_zone_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_key_zone_bits_set;
    data_index = dnx_data_field_base_epmf_define_nof_bits_in_fes_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_bits_in_fes_action_set;
    data_index = dnx_data_field_base_epmf_define_nof_bits_in_fes_key_select;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_bits_in_fes_key_select_set;
    data_index = dnx_data_field_base_epmf_define_nof_fes_key_selects_on_one_actions_line;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_fes_key_selects_on_one_actions_line_set;
    data_index = dnx_data_field_base_epmf_define_nof_l4_ops_ranges;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_nof_l4_ops_ranges_set;
    data_index = dnx_data_field_base_epmf_define_fes_key_select_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_fes_key_select_for_zero_bit_set;
    data_index = dnx_data_field_base_epmf_define_fes_shift_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_epmf_fes_shift_for_zero_bit_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: base_ifwd2
     */
    submodule_index = dnx_data_field_submodule_base_ifwd2;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_base_ifwd2_define_nof_ffc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ifwd2_nof_ffc_set;
    data_index = dnx_data_field_base_ifwd2_define_nof_ffc_groups;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ifwd2_nof_ffc_groups_set;
    data_index = dnx_data_field_base_ifwd2_define_ffc_group_one_lower;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ifwd2_ffc_group_one_lower_set;
    data_index = dnx_data_field_base_ifwd2_define_ffc_group_one_upper;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ifwd2_ffc_group_one_upper_set;
    data_index = dnx_data_field_base_ifwd2_define_nof_keys;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ifwd2_nof_keys_set;
    data_index = dnx_data_field_base_ifwd2_define_nof_contexts;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ifwd2_nof_contexts_set;
    data_index = dnx_data_field_base_ifwd2_define_nof_cs_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_base_ifwd2_nof_cs_lines_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: stage
     */
    submodule_index = dnx_data_field_submodule_stage;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_field_stage_table_stage_info;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_stage_stage_info_set;
    /*
     * Attach submodule: kbp
     */
    submodule_index = dnx_data_field_submodule_kbp;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_kbp_define_nof_fgs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_nof_fgs_set;
    data_index = dnx_data_field_kbp_define_max_master_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_max_master_key_size_set;
    data_index = dnx_data_field_kbp_define_max_single_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_max_single_key_size_set;
    data_index = dnx_data_field_kbp_define_nof_acl_keys_master_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_nof_acl_keys_master_max_set;
    data_index = dnx_data_field_kbp_define_nof_acl_keys_fg_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_nof_acl_keys_fg_max_set;
    data_index = dnx_data_field_kbp_define_min_acl_nof_ffc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_min_acl_nof_ffc_set;
    data_index = dnx_data_field_kbp_define_max_fwd_context_num_for_one_apptype;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_max_fwd_context_num_for_one_apptype_set;
    data_index = dnx_data_field_kbp_define_max_acl_context_num;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_max_acl_context_num_set;
    data_index = dnx_data_field_kbp_define_size_apptype_profile_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_size_apptype_profile_id_set;
    data_index = dnx_data_field_kbp_define_key_bmp;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_key_bmp_set;
    data_index = dnx_data_field_kbp_define_apptype_user_1st;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_apptype_user_1st_set;
    data_index = dnx_data_field_kbp_define_apptype_user_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_kbp_apptype_user_nof_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_field_kbp_table_ffc_to_quad_and_group_map;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_kbp_ffc_to_quad_and_group_map_set;
    /*
     * Attach submodule: tcam
     */
    submodule_index = dnx_data_field_submodule_tcam;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_tcam_define_key_size_half;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_key_size_half_set;
    data_index = dnx_data_field_tcam_define_key_size_single;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_key_size_single_set;
    data_index = dnx_data_field_tcam_define_key_size_double;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_key_size_double_set;
    data_index = dnx_data_field_tcam_define_dt_max_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_dt_max_key_size_set;
    data_index = dnx_data_field_tcam_define_action_size_half;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_action_size_half_set;
    data_index = dnx_data_field_tcam_define_action_size_single;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_action_size_single_set;
    data_index = dnx_data_field_tcam_define_action_size_double;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_action_size_double_set;
    data_index = dnx_data_field_tcam_define_key_mode_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_key_mode_size_set;
    data_index = dnx_data_field_tcam_define_entry_size_single_key_hw;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_entry_size_single_key_hw_set;
    data_index = dnx_data_field_tcam_define_entry_size_single_valid_bits_hw;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_entry_size_single_valid_bits_hw_set;
    data_index = dnx_data_field_tcam_define_entry_size_half_payload_hw;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_entry_size_half_payload_hw_set;
    data_index = dnx_data_field_tcam_define_hw_bank_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_hw_bank_size_set;
    data_index = dnx_data_field_tcam_define_small_bank_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_small_bank_size_set;
    data_index = dnx_data_field_tcam_define_nof_big_bank_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_big_bank_lines_set;
    data_index = dnx_data_field_tcam_define_nof_small_bank_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_small_bank_lines_set;
    data_index = dnx_data_field_tcam_define_nof_big_banks;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_big_banks_set;
    data_index = dnx_data_field_tcam_define_nof_small_banks;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_small_banks_set;
    data_index = dnx_data_field_tcam_define_nof_banks;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_banks_set;
    data_index = dnx_data_field_tcam_define_nof_payload_tables;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_payload_tables_set;
    data_index = dnx_data_field_tcam_define_nof_access_profiles;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_access_profiles_set;
    data_index = dnx_data_field_tcam_define_action_width_selector_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_action_width_selector_size_set;
    data_index = dnx_data_field_tcam_define_cascaded_data_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_cascaded_data_nof_bits_set;
    data_index = dnx_data_field_tcam_define_big_bank_key_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_big_bank_key_nof_bits_set;
    data_index = dnx_data_field_tcam_define_nof_entries_160_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_entries_160_bits_set;
    data_index = dnx_data_field_tcam_define_nof_entries_80_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_entries_80_bits_set;
    data_index = dnx_data_field_tcam_define_tcam_banks_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_tcam_banks_size_set;
    data_index = dnx_data_field_tcam_define_tcam_banks_last_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_tcam_banks_last_index_set;
    data_index = dnx_data_field_tcam_define_nof_tcam_handlers;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_tcam_handlers_set;
    data_index = dnx_data_field_tcam_define_max_prefix_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_max_prefix_size_set;
    data_index = dnx_data_field_tcam_define_max_prefix_value;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_max_prefix_value_set;
    data_index = dnx_data_field_tcam_define_nof_keys_in_double_key;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_keys_in_double_key_set;
    data_index = dnx_data_field_tcam_define_nof_keys_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_nof_keys_max_set;
    data_index = dnx_data_field_tcam_define_access_profile_half_key_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_access_profile_half_key_mode_set;
    data_index = dnx_data_field_tcam_define_access_profile_single_key_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_access_profile_single_key_mode_set;
    data_index = dnx_data_field_tcam_define_access_profile_double_key_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_access_profile_double_key_mode_set;
    data_index = dnx_data_field_tcam_define_hit_indication_entries_per_byte;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_hit_indication_entries_per_byte_set;
    data_index = dnx_data_field_tcam_define_max_tcam_priority;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_tcam_max_tcam_priority_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: group
     */
    submodule_index = dnx_data_field_submodule_group;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_group_define_nof_fgs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_group_nof_fgs_set;
    data_index = dnx_data_field_group_define_nof_action_per_fg;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_group_nof_action_per_fg_set;
    data_index = dnx_data_field_group_define_nof_quals_per_fg;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_group_nof_quals_per_fg_set;
    data_index = dnx_data_field_group_define_nof_keys_per_fg_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_group_nof_keys_per_fg_max_set;
    data_index = dnx_data_field_group_define_id_fec_wa;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_group_id_fec_wa_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: efes
     */
    submodule_index = dnx_data_field_submodule_efes;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_efes_define_max_nof_key_selects_per_field_io;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_efes_max_nof_key_selects_per_field_io_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_field_efes_table_key_select_properties;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_efes_key_select_properties_set;
    /*
     * Attach submodule: fem
     */
    submodule_index = dnx_data_field_submodule_fem;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_fem_define_max_nof_key_selects_per_field_io;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_fem_max_nof_key_selects_per_field_io_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_field_fem_table_key_select_properties;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_fem_key_select_properties_set;
    /*
     * Attach submodule: context
     */
    submodule_index = dnx_data_field_submodule_context;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_context_define_default_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_context_default_context_set;
    data_index = dnx_data_field_context_define_default_itmh_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_context_default_itmh_context_set;
    data_index = dnx_data_field_context_define_default_itmh_pph_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_context_default_itmh_pph_context_set;
    data_index = dnx_data_field_context_define_default_j1_itmh_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_context_default_j1_itmh_context_set;
    data_index = dnx_data_field_context_define_default_j1_itmh_pph_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_context_default_j1_itmh_pph_context_set;
    data_index = dnx_data_field_context_define_default_stacking_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_context_default_stacking_context_set;
    data_index = dnx_data_field_context_define_default_oam_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_context_default_oam_context_set;
    data_index = dnx_data_field_context_define_default_oam_reflector_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_context_default_oam_reflector_context_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: preselector
     */
    submodule_index = dnx_data_field_submodule_preselector;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_preselector_define_default_oam_presel_id_ipmf1;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_default_oam_presel_id_ipmf1_set;
    data_index = dnx_data_field_preselector_define_default_itmh_presel_id_ipmf1;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_default_itmh_presel_id_ipmf1_set;
    data_index = dnx_data_field_preselector_define_default_j1_itmh_presel_id_ipmf1;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_default_j1_itmh_presel_id_ipmf1_set;
    data_index = dnx_data_field_preselector_define_default_itmh_pph_presel_id_ipmf1;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf1_set;
    data_index = dnx_data_field_preselector_define_default_itmh_pph_presel_id_ipmf3;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf3_set;
    data_index = dnx_data_field_preselector_define_default_j1_itmh_pph_presel_id_ipmf1;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf1_set;
    data_index = dnx_data_field_preselector_define_default_j1_itmh_pph_presel_id_ipmf3;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf3_set;
    data_index = dnx_data_field_preselector_define_default_stacking_presel_id_ipmf1;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_default_stacking_presel_id_ipmf1_set;
    data_index = dnx_data_field_preselector_define_num_cs_inlif_profile_entries;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_preselector_num_cs_inlif_profile_entries_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: qual
     */
    submodule_index = dnx_data_field_submodule_qual;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_qual_define_user_1st;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_user_1st_set;
    data_index = dnx_data_field_qual_define_user_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_user_nof_set;
    data_index = dnx_data_field_qual_define_max_bits_in_qual;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_max_bits_in_qual_set;
    data_index = dnx_data_field_qual_define_ingress_pbus_header_length;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_ingress_pbus_header_length_set;
    data_index = dnx_data_field_qual_define_egress_pbus_header_length;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_egress_pbus_header_length_set;
    data_index = dnx_data_field_qual_define_ifwd2_pbus_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_ifwd2_pbus_size_set;
    data_index = dnx_data_field_qual_define_ipmf1_pbus_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_ipmf1_pbus_size_set;
    data_index = dnx_data_field_qual_define_ipmf2_pbus_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_ipmf2_pbus_size_set;
    data_index = dnx_data_field_qual_define_ipmf3_pbus_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_ipmf3_pbus_size_set;
    data_index = dnx_data_field_qual_define_epmf_pbus_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_epmf_pbus_size_set;
    data_index = dnx_data_field_qual_define_ingress_nof_layer_records;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_ingress_nof_layer_records_set;
    data_index = dnx_data_field_qual_define_ingress_layer_record_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_ingress_layer_record_size_set;
    data_index = dnx_data_field_qual_define_egress_nof_layer_records;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_egress_nof_layer_records_set;
    data_index = dnx_data_field_qual_define_egress_layer_record_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_qual_egress_layer_record_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_field_qual_table_params;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_qual_params_set;
    data_index = dnx_data_field_qual_table_layer_record_info_ingress;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_qual_layer_record_info_ingress_set;
    data_index = dnx_data_field_qual_table_layer_record_info_egress;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_qual_layer_record_info_egress_set;
    /*
     * Attach submodule: action
     */
    submodule_index = dnx_data_field_submodule_action;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_action_define_user_1st;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_action_user_1st_set;
    data_index = dnx_data_field_action_define_user_nof;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_action_user_nof_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: profile_bits
     */
    submodule_index = dnx_data_field_submodule_profile_bits;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_profile_bits_define_nof_ing_in_lif;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_nof_ing_in_lif_set;
    data_index = dnx_data_field_profile_bits_define_nof_eg_in_lif;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_nof_eg_in_lif_set;
    data_index = dnx_data_field_profile_bits_define_nof_ing_eth_rif;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_nof_ing_eth_rif_set;
    data_index = dnx_data_field_profile_bits_define_nof_eg_eth_rif;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_nof_eg_eth_rif_set;
    data_index = dnx_data_field_profile_bits_define_ingress_pp_port_key_gen_var_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_ingress_pp_port_key_gen_var_size_set;
    data_index = dnx_data_field_profile_bits_define_max_port_profile_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_max_port_profile_size_set;
    data_index = dnx_data_field_profile_bits_define_nof_bits_in_port_profile;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_nof_bits_in_port_profile_set;
    data_index = dnx_data_field_profile_bits_define_nof_bits_in_ingress_pp_port_general_data;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_nof_bits_in_ingress_pp_port_general_data_set;
    data_index = dnx_data_field_profile_bits_define_pmf_sexem3_stage;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_profile_bits_pmf_sexem3_stage_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: dir_ext
     */
    submodule_index = dnx_data_field_submodule_dir_ext;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_dir_ext_define_half_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_dir_ext_half_key_size_set;
    data_index = dnx_data_field_dir_ext_define_single_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_dir_ext_single_key_size_set;
    data_index = dnx_data_field_dir_ext_define_double_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_dir_ext_double_key_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: state_table
     */
    submodule_index = dnx_data_field_submodule_state_table;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_state_table_define_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_state_table_key_size_set;
    data_index = dnx_data_field_state_table_define_address_max;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_state_table_address_max_set;
    data_index = dnx_data_field_state_table_define_address_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_state_table_address_size_set;
    data_index = dnx_data_field_state_table_define_data_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_state_table_data_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: hash
     */
    submodule_index = dnx_data_field_submodule_hash;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_hash_define_max_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_hash_max_key_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: udh
     */
    submodule_index = dnx_data_field_submodule_udh;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_udh_define_type_count;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_type_count_set;
    data_index = dnx_data_field_udh_define_type_0_length;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_type_0_length_set;
    data_index = dnx_data_field_udh_define_type_1_length;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_type_1_length_set;
    data_index = dnx_data_field_udh_define_type_2_length;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_type_2_length_set;
    data_index = dnx_data_field_udh_define_type_3_length;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_type_3_length_set;
    data_index = dnx_data_field_udh_define_field_class_id_size_0;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_field_class_id_size_0_set;
    data_index = dnx_data_field_udh_define_field_class_id_size_1;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_field_class_id_size_1_set;
    data_index = dnx_data_field_udh_define_field_class_id_size_2;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_field_class_id_size_2_set;
    data_index = dnx_data_field_udh_define_field_class_id_size_3;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_udh_field_class_id_size_3_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: system_headers
     */
    submodule_index = dnx_data_field_submodule_system_headers;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_system_headers_define_nof_profiles;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_system_headers_nof_profiles_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_field_system_headers_table_system_header_profiles;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_system_headers_system_header_profiles_set;
    /*
     * Attach submodule: exem
     */
    submodule_index = dnx_data_field_submodule_exem;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_exem_define_small_app_db_id_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_app_db_id_size_set;
    data_index = dnx_data_field_exem_define_large_app_db_id_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_app_db_id_size_set;
    data_index = dnx_data_field_exem_define_small_vmv_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_vmv_size_set;
    data_index = dnx_data_field_exem_define_large_vmv_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_vmv_size_set;
    data_index = dnx_data_field_exem_define_small_max_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_max_key_size_set;
    data_index = dnx_data_field_exem_define_large_max_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_max_key_size_set;
    data_index = dnx_data_field_exem_define_small_max_entry_result_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_max_entry_result_size_set;
    data_index = dnx_data_field_exem_define_large_max_entry_result_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_max_entry_result_size_set;
    data_index = dnx_data_field_exem_define_small_max_result_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_max_result_size_set;
    data_index = dnx_data_field_exem_define_large_max_result_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_max_result_size_set;
    data_index = dnx_data_field_exem_define_small_max_container_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_max_container_size_set;
    data_index = dnx_data_field_exem_define_large_max_container_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_max_container_size_set;
    data_index = dnx_data_field_exem_define_small_key_hash_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_key_hash_size_set;
    data_index = dnx_data_field_exem_define_large_key_hash_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_key_hash_size_set;
    data_index = dnx_data_field_exem_define_small_min_app_db_id_range;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_min_app_db_id_range_set;
    data_index = dnx_data_field_exem_define_large_min_app_db_id_range;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_min_app_db_id_range_set;
    data_index = dnx_data_field_exem_define_small_max_app_db_id_range;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_max_app_db_id_range_set;
    data_index = dnx_data_field_exem_define_large_max_app_db_id_range;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_max_app_db_id_range_set;
    data_index = dnx_data_field_exem_define_small_ipmf2_key;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_ipmf2_key_set;
    data_index = dnx_data_field_exem_define_small_ipmf2_key_part;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_ipmf2_key_part_set;
    data_index = dnx_data_field_exem_define_small_ipmf2_key_hw_value;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_ipmf2_key_hw_value_set;
    data_index = dnx_data_field_exem_define_small_ipmf2_key_hw_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_small_ipmf2_key_hw_bits_set;
    data_index = dnx_data_field_exem_define_large_ipmf1_key_configurable;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_ipmf1_key_configurable_set;
    data_index = dnx_data_field_exem_define_large_ipmf1_key;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_exem_large_ipmf1_key_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: ace
     */
    submodule_index = dnx_data_field_submodule_ace;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_ace_define_ace_id_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_ace_id_size_set;
    data_index = dnx_data_field_ace_define_key_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_key_size_set;
    data_index = dnx_data_field_ace_define_key_hash_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_key_hash_size_set;
    data_index = dnx_data_field_ace_define_app_db_id_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_app_db_id_size_set;
    data_index = dnx_data_field_ace_define_payload_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_payload_size_set;
    data_index = dnx_data_field_ace_define_min_key_range_pmf;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_min_key_range_pmf_set;
    data_index = dnx_data_field_ace_define_max_key_range_pmf;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_max_key_range_pmf_set;
    data_index = dnx_data_field_ace_define_min_ace_id_dynamic_range;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_min_ace_id_dynamic_range_set;
    data_index = dnx_data_field_ace_define_nof_ace_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_ace_id_set;
    data_index = dnx_data_field_ace_define_nof_action_per_ace_format;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_action_per_ace_format_set;
    data_index = dnx_data_field_ace_define_row_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_row_size_set;
    data_index = dnx_data_field_ace_define_min_entry_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_min_entry_size_set;
    data_index = dnx_data_field_ace_define_ace_id_pmf_alloc_first;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_ace_id_pmf_alloc_first_set;
    data_index = dnx_data_field_ace_define_ace_id_pmf_alloc_last;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_ace_id_pmf_alloc_last_set;
    data_index = dnx_data_field_ace_define_nof_masks_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_masks_per_fes_set;
    data_index = dnx_data_field_ace_define_nof_fes_id_per_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_fes_id_per_array_set;
    data_index = dnx_data_field_ace_define_nof_fes_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_fes_array_set;
    data_index = dnx_data_field_ace_define_nof_fes_instruction_per_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_fes_instruction_per_context_set;
    data_index = dnx_data_field_ace_define_nof_fes_programs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_fes_programs_set;
    data_index = dnx_data_field_ace_define_nof_prog_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_prog_per_fes_set;
    data_index = dnx_data_field_ace_define_nof_bits_in_fes_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_nof_bits_in_fes_action_set;
    data_index = dnx_data_field_ace_define_fes_shift_for_zero_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_ace_fes_shift_for_zero_bit_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: entry
     */
    submodule_index = dnx_data_field_submodule_entry;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_entry_define_dir_ext_nof_fields;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_entry_dir_ext_nof_fields_set;
    data_index = dnx_data_field_entry_define_nof_action_params_per_entry;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_entry_nof_action_params_per_entry_set;
    data_index = dnx_data_field_entry_define_nof_qual_params_per_entry;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_entry_nof_qual_params_per_entry_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: L4_Ops
     */
    submodule_index = dnx_data_field_submodule_L4_Ops;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_L4_Ops_define_udp_position;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_L4_Ops_udp_position_set;
    data_index = dnx_data_field_L4_Ops_define_tcp_position;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_L4_Ops_tcp_position_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: encoded_qual_actions_offset
     */
    submodule_index = dnx_data_field_submodule_encoded_qual_actions_offset;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_encoded_qual_actions_offset_define_trap_strength_offset;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_encoded_qual_actions_offset_trap_strength_offset_set;
    data_index = dnx_data_field_encoded_qual_actions_offset_define_trap_qualifier_offset;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_encoded_qual_actions_offset_trap_qualifier_offset_set;
    data_index = dnx_data_field_encoded_qual_actions_offset_define_sniff_qualifier_offset;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_encoded_qual_actions_offset_sniff_qualifier_offset_set;
    data_index = dnx_data_field_encoded_qual_actions_offset_define_mirror_qualifier_offset;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_encoded_qual_actions_offset_mirror_qualifier_offset_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: Compare_operand
     */
    submodule_index = dnx_data_field_submodule_Compare_operand;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_Compare_operand_define_equal;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_Compare_operand_equal_set;
    data_index = dnx_data_field_Compare_operand_define_not_equal;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_Compare_operand_not_equal_set;
    data_index = dnx_data_field_Compare_operand_define_smaller;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_Compare_operand_smaller_set;
    data_index = dnx_data_field_Compare_operand_define_not_smaller;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_Compare_operand_not_smaller_set;
    data_index = dnx_data_field_Compare_operand_define_bigger;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_Compare_operand_bigger_set;
    data_index = dnx_data_field_Compare_operand_define_not_bigger;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_Compare_operand_not_bigger_set;
    data_index = dnx_data_field_Compare_operand_define_nof_operands;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_Compare_operand_nof_operands_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: diag
     */
    submodule_index = dnx_data_field_submodule_diag;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_diag_define_bytes_to_remove_mask;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_diag_bytes_to_remove_mask_set;
    data_index = dnx_data_field_diag_define_layers_to_remove_size_in_bit;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_diag_layers_to_remove_size_in_bit_set;
    data_index = dnx_data_field_diag_define_layers_to_remove_mask;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_diag_layers_to_remove_mask_set;
    data_index = dnx_data_field_diag_define_nof_signals_per_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_diag_nof_signals_per_action_set;
    data_index = dnx_data_field_diag_define_nof_signals_per_qualifier;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_diag_nof_signals_per_qualifier_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_field_diag_tcam_cs_hit_bit_support;
    feature = &submodule->features[data_index];
    feature->set = jer2_a0_dnx_data_field_diag_tcam_cs_hit_bit_support_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: common_max_val
     */
    submodule_index = dnx_data_field_submodule_common_max_val;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_common_max_val_define_nof_ffc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_ffc_set;
    data_index = dnx_data_field_common_max_val_define_nof_keys;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_keys_set;
    data_index = dnx_data_field_common_max_val_define_nof_masks_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_masks_per_fes_set;
    data_index = dnx_data_field_common_max_val_define_nof_fes_id_per_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_fes_id_per_array_set;
    data_index = dnx_data_field_common_max_val_define_nof_fes_array;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_fes_array_set;
    data_index = dnx_data_field_common_max_val_define_nof_fes_instruction_per_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_fes_instruction_per_context_set;
    data_index = dnx_data_field_common_max_val_define_nof_fes_programs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_fes_programs_set;
    data_index = dnx_data_field_common_max_val_define_nof_prog_per_fes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_prog_per_fes_set;
    data_index = dnx_data_field_common_max_val_define_nof_program_selection_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_program_selection_lines_set;
    data_index = dnx_data_field_common_max_val_define_program_selection_cam_mask_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_program_selection_cam_mask_nof_bits_set;
    data_index = dnx_data_field_common_max_val_define_nof_cs_lines;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_cs_lines_set;
    data_index = dnx_data_field_common_max_val_define_nof_contexts;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_contexts_set;
    data_index = dnx_data_field_common_max_val_define_nof_actions;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_actions_set;
    data_index = dnx_data_field_common_max_val_define_nof_qualifiers;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_qualifiers_set;
    data_index = dnx_data_field_common_max_val_define_nof_80B_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_80B_zones_set;
    data_index = dnx_data_field_common_max_val_define_nof_key_zones;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_key_zones_set;
    data_index = dnx_data_field_common_max_val_define_nof_key_zone_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_key_zone_bits_set;
    data_index = dnx_data_field_common_max_val_define_nof_bits_in_fes_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_bits_in_fes_action_set;
    data_index = dnx_data_field_common_max_val_define_nof_bits_in_fes_key_select;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_bits_in_fes_key_select_set;
    data_index = dnx_data_field_common_max_val_define_nof_fes_key_selects_on_one_actions_line;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_fes_key_selects_on_one_actions_line_set;
    data_index = dnx_data_field_common_max_val_define_nof_ffc_in_qual;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_ffc_in_qual_set;
    data_index = dnx_data_field_common_max_val_define_nof_bits_in_ffc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_bits_in_ffc_set;
    data_index = dnx_data_field_common_max_val_define_nof_ffc_in_uint32;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_ffc_in_uint32_set;
    data_index = dnx_data_field_common_max_val_define_nof_action_per_group;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_action_per_group_set;
    data_index = dnx_data_field_common_max_val_define_nof_layer_records;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_layer_records_set;
    data_index = dnx_data_field_common_max_val_define_nof_l4_ops_ranges;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_l4_ops_ranges_set;
    data_index = dnx_data_field_common_max_val_define_nof_pkt_hdr_ranges;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_pkt_hdr_ranges_set;
    data_index = dnx_data_field_common_max_val_define_nof_out_lif_ranges;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_out_lif_ranges_set;
    data_index = dnx_data_field_common_max_val_define_kbr_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_kbr_size_set;
    data_index = dnx_data_field_common_max_val_define_nof_compare_pairs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_compare_pairs_set;
    data_index = dnx_data_field_common_max_val_define_nof_compare_pairs_in_compare_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_compare_pairs_in_compare_mode_set;
    data_index = dnx_data_field_common_max_val_define_nof_compare_keys_in_compare_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_compare_keys_in_compare_mode_set;
    data_index = dnx_data_field_common_max_val_define_nof_bits_in_fem_action;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_bits_in_fem_action_set;
    data_index = dnx_data_field_common_max_val_define_nof_fem_condition;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_fem_condition_set;
    data_index = dnx_data_field_common_max_val_define_nof_fem_map_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_fem_map_index_set;
    data_index = dnx_data_field_common_max_val_define_nof_array_ids;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_nof_array_ids_set;
    data_index = dnx_data_field_common_max_val_define_dbal_pairs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_common_max_val_dbal_pairs_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_field_common_max_val_table_array_id_type;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_field_common_max_val_array_id_type_set;
    /*
     * Attach submodule: init
     */
    submodule_index = dnx_data_field_submodule_init;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_init_define_wa_fec_dest;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_init_wa_fec_dest_set;
    data_index = dnx_data_field_init_define_wa_l4_trap;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_init_wa_l4_trap_set;
    data_index = dnx_data_field_init_define_wa_oam_layer_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_init_wa_oam_layer_index_set;
    data_index = dnx_data_field_init_define_wa_oam_stat;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_init_wa_oam_stat_set;
    data_index = dnx_data_field_init_define_wa_flow_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_init_wa_flow_id_set;
    data_index = dnx_data_field_init_define_wa_roo;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_init_wa_roo_set;
    data_index = dnx_data_field_init_define_wa_j1_same_port;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_init_wa_j1_same_port_set;
    data_index = dnx_data_field_init_define_wa_j1_learning;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_init_wa_j1_learning_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: hw_workarounds
     */
    submodule_index = dnx_data_field_submodule_hw_workarounds;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_hw_workarounds_define_ecc_wa_enable;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_hw_workarounds_ecc_wa_enable_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: hw_features
     */
    submodule_index = dnx_data_field_submodule_hw_features;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_hw_features_define_switch_to_acl_context;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_hw_features_switch_to_acl_context_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: minor_changes_j2_a0_b0
     */
    submodule_index = dnx_data_field_submodule_minor_changes_j2_a0_b0;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_field_minor_changes_j2_a0_b0_define_lr_eth_is_da_mac_valid;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_minor_changes_j2_a0_b0_lr_eth_is_da_mac_valid_set;
    data_index = dnx_data_field_minor_changes_j2_a0_b0_define_per_pp_port_pmf_profile_cs_offset;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_minor_changes_j2_a0_b0_per_pp_port_pmf_profile_cs_offset_set;
    data_index = dnx_data_field_minor_changes_j2_a0_b0_define_tcam_result_flip_eco;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_field_minor_changes_j2_a0_b0_tcam_result_flip_eco_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
