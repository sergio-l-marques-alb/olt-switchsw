/** \file dnx_data_nif.c
 * 
 * MODULE DEVICE DATA - NIF
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_PORT
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_nif.h>
/*
 * }
 */

/*
 * Extern per device attach function
 */
extern shr_error_e jer2_a0_data_nif_attach(
    int unit);
/*
 * SUBMODULE - GLOBAL:
 * {
 */
/*
 * global init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_nif_global_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "global";
    submodule_data->doc = "global nif proprties and data";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_nif_global_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data nif global features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_nif_global_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data nif global defines");

    submodule_data->defines[dnx_data_nif_global_define_nof_lcplls].name = "nof_lcplls";
    submodule_data->defines[dnx_data_nif_global_define_nof_lcplls].doc = "number of lcplls supported";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_global_define_nof_lcplls].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_global_define_start_tx_threshold_global].name = "start_tx_threshold_global";
    submodule_data->defines[dnx_data_nif_global_define_start_tx_threshold_global].doc = "Global start TX threshold. This value overrides TX threshold table values";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_global_define_start_tx_threshold_global].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_nif_global_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data nif global tables");

    /*
     * Table - pll_phys
     */
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].name = "pll_phys";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].doc = "phys controlled by each lcpll";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].size_of_values = sizeof(dnx_data_nif_global_pll_phys_t);
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].entry_get = dnx_data_nif_global_pll_phys_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].keys[0].name = "lcpll";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].keys[0].doc = "LCPLL index";

    /* Values */
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_global_table_pll_phys].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_global_table_pll_phys].nof_values, "_dnx_data_nif_global_table_pll_phys table values");
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].values[0].name = "min_phy_id";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].values[0].type = "uint32";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].values[0].doc = "The min phy ID controlled by given pll";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_global_pll_phys_t, min_phy_id);
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].values[1].name = "max_phy_id";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].values[1].doc = "The max phy ID controlled by given pll";
    submodule_data->tables[dnx_data_nif_global_table_pll_phys].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_global_pll_phys_t, max_phy_id);

    /*
     * Table - start_tx_threshold_table
     */
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].name = "start_tx_threshold_table";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].doc = "TX threshold table of values per speed";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].size_of_values = sizeof(dnx_data_nif_global_start_tx_threshold_table_t);
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].entry_get = dnx_data_nif_global_start_tx_threshold_table_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].keys[0].name = "idx";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].keys[0].doc = "Entry index";

    /* Values */
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].nof_values, "_dnx_data_nif_global_table_start_tx_threshold_table table values");
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values[0].name = "speed";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values[0].type = "uint32";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values[0].doc = "Interface rate";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_global_start_tx_threshold_table_t, speed);
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values[1].name = "start_thr";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values[1].doc = "Start TX threshold";
    submodule_data->tables[dnx_data_nif_global_table_start_tx_threshold_table].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_global_start_tx_threshold_table_t, start_thr);


exit:
    SHR_FUNC_EXIT;
}

/*
 * global features
 */
int
dnx_data_nif_global_feature_get(
    int unit,
    dnx_data_nif_global_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, feature);
}

/*
 * global defines
 */
uint32
dnx_data_nif_global_nof_lcplls_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, dnx_data_nif_global_define_nof_lcplls);
}

uint32
dnx_data_nif_global_start_tx_threshold_global_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, dnx_data_nif_global_define_start_tx_threshold_global);
}

/*
 * global tables
 */
/* Table Get */
const dnx_data_nif_global_pll_phys_t *
dnx_data_nif_global_pll_phys_get(
    int unit,
    int lcpll)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, dnx_data_nif_global_table_pll_phys);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, lcpll, 0);
    return (const dnx_data_nif_global_pll_phys_t *) data;

}

const dnx_data_nif_global_start_tx_threshold_table_t *
dnx_data_nif_global_start_tx_threshold_table_get(
    int unit,
    int idx)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, dnx_data_nif_global_table_start_tx_threshold_table);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, idx, 0);
    return (const dnx_data_nif_global_start_tx_threshold_table_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_nif_global_pll_phys_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_global_pll_phys_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, dnx_data_nif_global_table_pll_phys);
    data = (const dnx_data_nif_global_pll_phys_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->min_phy_id);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->max_phy_id);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_global_start_tx_threshold_table_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_global_start_tx_threshold_table_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, dnx_data_nif_global_table_start_tx_threshold_table);
    data = (const dnx_data_nif_global_start_tx_threshold_table_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->speed);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->start_thr);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_nif_global_pll_phys_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, dnx_data_nif_global_table_pll_phys);

}

const dnxc_data_table_info_t *
dnx_data_nif_global_start_tx_threshold_table_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_global, dnx_data_nif_global_table_start_tx_threshold_table);

}

/*
 * }
 */

/*
 * SUBMODULE - PHYS:
 * {
 */
/*
 * phys init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_nif_phys_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "phys";
    submodule_data->doc = "data about phys";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_nif_phys_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data nif phys features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_nif_phys_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data nif phys defines");

    submodule_data->defines[dnx_data_nif_phys_define_nof_phys].name = "nof_phys";
    submodule_data->defines[dnx_data_nif_phys_define_nof_phys].doc = "number of phys supported";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_phys_define_nof_phys].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_phys_define_nof_phys_per_core].name = "nof_phys_per_core";
    submodule_data->defines[dnx_data_nif_phys_define_nof_phys_per_core].doc = "number of phys per core supported";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_phys_define_nof_phys_per_core].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_phys_define_nof_pms].name = "nof_pms";
    submodule_data->defines[dnx_data_nif_phys_define_nof_pms].doc = "number of PMs supported";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_phys_define_nof_pms].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_phys_define_vco_div].name = "vco_div";
    submodule_data->defines[dnx_data_nif_phys_define_vco_div].doc = "VCO divider";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_phys_define_vco_div].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_nif_phys_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data nif phys tables");

    /*
     * Table - general
     */
    submodule_data->tables[dnx_data_nif_phys_table_general].name = "general";
    submodule_data->tables[dnx_data_nif_phys_table_general].doc = "general data about phys";
    submodule_data->tables[dnx_data_nif_phys_table_general].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_phys_table_general].size_of_values = sizeof(dnx_data_nif_phys_general_t);
    submodule_data->tables[dnx_data_nif_phys_table_general].entry_get = dnx_data_nif_phys_general_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_phys_table_general].nof_keys = 0;

    /* Values */
    submodule_data->tables[dnx_data_nif_phys_table_general].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_phys_table_general].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_phys_table_general].nof_values, "_dnx_data_nif_phys_table_general table values");
    submodule_data->tables[dnx_data_nif_phys_table_general].values[0].name = "supported_phys";
    submodule_data->tables[dnx_data_nif_phys_table_general].values[0].type = "bcm_pbmp_t";
    submodule_data->tables[dnx_data_nif_phys_table_general].values[0].doc = "bitmap of supported phys";
    submodule_data->tables[dnx_data_nif_phys_table_general].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_phys_general_t, supported_phys);

    /*
     * Table - polarity
     */
    submodule_data->tables[dnx_data_nif_phys_table_polarity].name = "polarity";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].doc = "rx and tx polarity per lane";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_phys_table_polarity].size_of_values = sizeof(dnx_data_nif_phys_polarity_t);
    submodule_data->tables[dnx_data_nif_phys_table_polarity].entry_get = dnx_data_nif_phys_polarity_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_phys_table_polarity].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_phys_table_polarity].keys[0].name = "lane_index";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].keys[0].doc = "lane index (0-based)";

    /* Values */
    submodule_data->tables[dnx_data_nif_phys_table_polarity].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_phys_table_polarity].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_phys_table_polarity].nof_values, "_dnx_data_nif_phys_table_polarity table values");
    submodule_data->tables[dnx_data_nif_phys_table_polarity].values[0].name = "tx_polarity";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].values[0].type = "uint32";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].values[0].doc = "switch TX phy polarity";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_phys_polarity_t, tx_polarity);
    submodule_data->tables[dnx_data_nif_phys_table_polarity].values[1].name = "rx_polarity";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].values[1].doc = "switch RX phy polarity";
    submodule_data->tables[dnx_data_nif_phys_table_polarity].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_phys_polarity_t, rx_polarity);

    /*
     * Table - core_phys_map
     */
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].name = "core_phys_map";
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].doc = "map pipeline core to connected PHYs";
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].size_of_values = sizeof(dnx_data_nif_phys_core_phys_map_t);
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].entry_get = dnx_data_nif_phys_core_phys_map_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].keys[0].name = "core_index";
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].keys[0].doc = "Core number.";

    /* Values */
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].nof_values, "_dnx_data_nif_phys_table_core_phys_map table values");
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].values[0].name = "phys";
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].values[0].type = "bcm_pbmp_t";
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].values[0].doc = "phys connected to the CORE.";
    submodule_data->tables[dnx_data_nif_phys_table_core_phys_map].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_phys_core_phys_map_t, phys);


exit:
    SHR_FUNC_EXIT;
}

/*
 * phys features
 */
int
dnx_data_nif_phys_feature_get(
    int unit,
    dnx_data_nif_phys_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, feature);
}

/*
 * phys defines
 */
uint32
dnx_data_nif_phys_nof_phys_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_define_nof_phys);
}

uint32
dnx_data_nif_phys_nof_phys_per_core_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_define_nof_phys_per_core);
}

uint32
dnx_data_nif_phys_nof_pms_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_define_nof_pms);
}

uint32
dnx_data_nif_phys_vco_div_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_define_vco_div);
}

/*
 * phys tables
 */
/* Table Get */
const dnx_data_nif_phys_general_t *
dnx_data_nif_phys_general_get(
    int unit)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_general);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    return (const dnx_data_nif_phys_general_t *) data;

}

const dnx_data_nif_phys_polarity_t *
dnx_data_nif_phys_polarity_get(
    int unit,
    int lane_index)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_polarity);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, lane_index, 0);
    return (const dnx_data_nif_phys_polarity_t *) data;

}

const dnx_data_nif_phys_core_phys_map_t *
dnx_data_nif_phys_core_phys_map_get(
    int unit,
    int core_index)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_core_phys_map);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, core_index, 0);
    return (const dnx_data_nif_phys_core_phys_map_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_nif_phys_general_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_phys_general_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_general);
    data = (const dnx_data_nif_phys_general_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, 0, 0);
    switch (value_index)
    {
        case 0:
            DNXC_DATA_MGMT_PBMP_STR(buffer, data->supported_phys);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_phys_polarity_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_phys_polarity_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_polarity);
    data = (const dnx_data_nif_phys_polarity_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->tx_polarity);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->rx_polarity);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_phys_core_phys_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_phys_core_phys_map_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_core_phys_map);
    data = (const dnx_data_nif_phys_core_phys_map_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            DNXC_DATA_MGMT_PBMP_STR(buffer, data->phys);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_nif_phys_general_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_general);

}

const dnxc_data_table_info_t *
dnx_data_nif_phys_polarity_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_polarity);

}

const dnxc_data_table_info_t *
dnx_data_nif_phys_core_phys_map_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_phys, dnx_data_nif_phys_table_core_phys_map);

}

/*
 * }
 */

/*
 * SUBMODULE - ILKN:
 * {
 */
/*
 * ilkn init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_nif_ilkn_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "ilkn";
    submodule_data->doc = "data about ILKN ports";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_nif_ilkn_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data nif ilkn features");

    submodule_data->features[dnx_data_nif_ilkn_is_supported].name = "is_supported";
    submodule_data->features[dnx_data_nif_ilkn_is_supported].doc = "is device type support ILKN.";
    submodule_data->features[dnx_data_nif_ilkn_is_supported].flags |= DNXC_DATA_F_FEATURE;

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_nif_ilkn_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data nif ilkn defines");

    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_unit_nof].name = "ilkn_unit_nof";
    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_unit_nof].doc = "Number of ILKN units in the device";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_unit_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_unit_if_nof].name = "ilkn_unit_if_nof";
    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_unit_if_nof].doc = "Number of ILKN Interfaces in each ILKN unit";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_unit_if_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_if_nof].name = "ilkn_if_nof";
    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_if_nof].doc = "Number of ILKN Interfaces in the device";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_if_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_lanes_max_nof].name = "lanes_max_nof";
    submodule_data->defines[dnx_data_nif_ilkn_define_lanes_max_nof].doc = "Max number of lanes for ILKN port";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_lanes_max_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_lanes_allowed_nof].name = "lanes_allowed_nof";
    submodule_data->defines[dnx_data_nif_ilkn_define_lanes_allowed_nof].doc = "The allowed lanes for each ILKN port";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_lanes_allowed_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_over_eth_pms_max].name = "ilkn_over_eth_pms_max";
    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_over_eth_pms_max].doc = "Max number eth pms ilkn lanes is part of";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_ilkn_over_eth_pms_max].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_segments_max_nof].name = "segments_max_nof";
    submodule_data->defines[dnx_data_nif_ilkn_define_segments_max_nof].doc = "Max number of segments in ILKN protocol. (Segment is a resource of ILKN which is shared between all ports of the ILKN unit)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_segments_max_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_watermark_high].name = "watermark_high";
    submodule_data->defines[dnx_data_nif_ilkn_define_watermark_high].doc = "High Watermark value for ILKN";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_watermark_high].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_watermark_low].name = "watermark_low";
    submodule_data->defines[dnx_data_nif_ilkn_define_watermark_low].doc = "Low Watermark value for ILKN";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_watermark_low].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_pms_nof].name = "pms_nof";
    submodule_data->defines[dnx_data_nif_ilkn_define_pms_nof].doc = "Number of PMs connectted to the ILKN unit";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_pms_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_ilkn_define_fmac_bus_size].name = "fmac_bus_size";
    submodule_data->defines[dnx_data_nif_ilkn_define_fmac_bus_size].doc = "Fabric MAC bus size [bits], relevant for ILKN over fabric ports";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_ilkn_define_fmac_bus_size].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_nif_ilkn_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data nif ilkn tables");

    /*
     * Table - phys
     */
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].name = "phys";
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].doc = "phys bitmap for ports added by soc property";
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].size_of_values = sizeof(dnx_data_nif_ilkn_phys_t);
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].entry_get = dnx_data_nif_ilkn_phys_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].keys[0].name = "ilkn_id";
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].keys[0].doc = "ilkn if id";

    /* Values */
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_ilkn_table_phys].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_ilkn_table_phys].nof_values, "_dnx_data_nif_ilkn_table_phys table values");
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].values[0].name = "bitmap";
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].values[0].type = "bcm_pbmp_t";
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].values[0].doc = "phys connected to the ILKN id.";
    submodule_data->tables[dnx_data_nif_ilkn_table_phys].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_phys_t, bitmap);

    /*
     * Table - supported_phys
     */
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].name = "supported_phys";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].doc = "supported phys per ILKN id";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].size_of_values = sizeof(dnx_data_nif_ilkn_supported_phys_t);
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].entry_get = dnx_data_nif_ilkn_supported_phys_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].keys[0].name = "ilkn_id";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].keys[0].doc = "ilkn if id";

    /* Values */
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].nof_values = 4;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].nof_values, "_dnx_data_nif_ilkn_table_supported_phys table values");
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[0].name = "is_supported";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[0].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[0].doc = "is ILKN id supported on the device.";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_supported_phys_t, is_supported);
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[1].name = "max_phys";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[1].doc = "Max supported phys for the ILKN id.";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_supported_phys_t, max_phys);
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[2].name = "nif_phys";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[2].type = "bcm_pbmp_t";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[2].doc = "NIF phys supported by the ILKN id.";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[2].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_supported_phys_t, nif_phys);
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[3].name = "fabric_phys";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[3].type = "bcm_pbmp_t";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[3].doc = "Fabric phys supported by the ILKN id. if the ILKN unit is not connected to fabric lanes, this value should be 0.";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_phys].values[3].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_supported_phys_t, fabric_phys);

    /*
     * Table - supported_core
     */
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].name = "supported_core";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].doc = "supported device core per ILKN id";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].size_of_values = sizeof(dnx_data_nif_ilkn_supported_core_t);
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].entry_get = dnx_data_nif_ilkn_supported_core_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].keys[0].name = "ilkn_id";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].keys[0].doc = "ilkn if id";

    /* Values */
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].nof_values, "_dnx_data_nif_ilkn_table_supported_core table values");
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].values[0].name = "core";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].values[0].type = "int";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].values[0].doc = "Core id of which ILKN id is associated.";
    submodule_data->tables[dnx_data_nif_ilkn_table_supported_core].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_supported_core_t, core);

    /*
     * Table - properties
     */
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].name = "properties";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].doc = "ILKN properties per ILKN id - added using soc property.";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].size_of_values = sizeof(dnx_data_nif_ilkn_properties_t);
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].entry_get = dnx_data_nif_ilkn_properties_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].keys[0].name = "ilkn_id";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].keys[0].doc = "ilkn if id";

    /* Values */
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].nof_values = 5;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_ilkn_table_properties].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_ilkn_table_properties].nof_values, "_dnx_data_nif_ilkn_table_properties table values");
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[0].name = "burst_short";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[0].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[0].doc = "ILKN burst short value. Sets the smallest burst size for the ILKN port. Shorter bursts will be padded with idles";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_properties_t, burst_short);
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[1].name = "burst_max";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[1].doc = "ILKN burst Max value. Set the max burst size for the ILKN port.";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_properties_t, burst_max);
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[2].name = "burst_min";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[2].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[2].doc = "ILKN burst min value. BurstMin should be bigger or equal to BurstShort and less or equal to BurstMax/2. This value is used to optimize the usage of the interface.";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[2].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_properties_t, burst_min);
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[3].name = "metaframe_period";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[3].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[3].doc = "Specify the interval (in words) between meta-frame sync words. supported values: 64-16K.";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[3].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_properties_t, metaframe_period);
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[4].name = "is_over_fabric";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[4].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[4].doc = "ILKN over fabric indication. Specify the ILKN port is using Fabric lanes instead of NIF phys.";
    submodule_data->tables[dnx_data_nif_ilkn_table_properties].values[4].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_properties_t, is_over_fabric);

    /*
     * Table - nif_pms
     */
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].name = "nif_pms";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].doc = "ILKN PM table over NIF";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].size_of_values = sizeof(dnx_data_nif_ilkn_nif_pms_t);
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].entry_get = dnx_data_nif_ilkn_nif_pms_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].keys[0].name = "pm_id";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].keys[0].doc = "Port Macro identifier";

    /* Values */
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].nof_values, "_dnx_data_nif_ilkn_table_nif_pms table values");
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values[0].name = "dispatch_type";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values[0].type = "portmod_dispatch_type_t";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values[0].doc = "PM dispatch type in Portmod";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_nif_pms_t, dispatch_type);
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values[1].name = "first_phy";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values[1].doc = "PM first phy";
    submodule_data->tables[dnx_data_nif_ilkn_table_nif_pms].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_nif_pms_t, first_phy);

    /*
     * Table - fabric_pms
     */
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].name = "fabric_pms";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].doc = "ILKN PM table over Fabric";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].size_of_values = sizeof(dnx_data_nif_ilkn_fabric_pms_t);
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].entry_get = dnx_data_nif_ilkn_fabric_pms_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].keys[0].name = "pm_id";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].keys[0].doc = "Port Macro identifier";

    /* Values */
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].nof_values, "_dnx_data_nif_ilkn_table_fabric_pms table values");
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values[0].name = "dispatch_type";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values[0].type = "portmod_dispatch_type_t";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values[0].doc = "PM dispatch type in Portmod";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_fabric_pms_t, dispatch_type);
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values[1].name = "first_phy";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values[1].doc = "PM first phy";
    submodule_data->tables[dnx_data_nif_ilkn_table_fabric_pms].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_fabric_pms_t, first_phy);

    /*
     * Table - ilkn_pms
     */
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].name = "ilkn_pms";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].doc = "ILKN PM table per ILKN id";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].size_of_values = sizeof(dnx_data_nif_ilkn_ilkn_pms_t);
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].entry_get = dnx_data_nif_ilkn_ilkn_pms_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].keys[0].name = "ilkn_id";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].keys[0].doc = "ilkn if id";

    /* Values */
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].nof_values, "_dnx_data_nif_ilkn_table_ilkn_pms table values");
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values[0].name = "nif_pm_ids";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values[0].type = "uint32[DNX_DATA_MAX_NIF_ILKN_PMS_NOF]";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values[0].doc = "ILKN connected PMs on NIF side";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_ilkn_pms_t, nif_pm_ids);
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values[1].name = "fabric_pm_ids";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values[1].type = "uint32[DNX_DATA_MAX_NIF_ILKN_PMS_NOF]";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values[1].doc = "ILKN connected PMs on Fabric side";
    submodule_data->tables[dnx_data_nif_ilkn_table_ilkn_pms].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_ilkn_ilkn_pms_t, fabric_pm_ids);


exit:
    SHR_FUNC_EXIT;
}

/*
 * ilkn features
 */
int
dnx_data_nif_ilkn_feature_get(
    int unit,
    dnx_data_nif_ilkn_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, feature);
}

/*
 * ilkn defines
 */
uint32
dnx_data_nif_ilkn_ilkn_unit_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_ilkn_unit_nof);
}

uint32
dnx_data_nif_ilkn_ilkn_unit_if_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_ilkn_unit_if_nof);
}

uint32
dnx_data_nif_ilkn_ilkn_if_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_ilkn_if_nof);
}

uint32
dnx_data_nif_ilkn_lanes_max_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_lanes_max_nof);
}

uint32
dnx_data_nif_ilkn_lanes_allowed_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_lanes_allowed_nof);
}

uint32
dnx_data_nif_ilkn_ilkn_over_eth_pms_max_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_ilkn_over_eth_pms_max);
}

uint32
dnx_data_nif_ilkn_segments_max_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_segments_max_nof);
}

uint32
dnx_data_nif_ilkn_watermark_high_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_watermark_high);
}

uint32
dnx_data_nif_ilkn_watermark_low_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_watermark_low);
}

uint32
dnx_data_nif_ilkn_pms_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_pms_nof);
}

uint32
dnx_data_nif_ilkn_fmac_bus_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_define_fmac_bus_size);
}

/*
 * ilkn tables
 */
/* Table Get */
const dnx_data_nif_ilkn_phys_t *
dnx_data_nif_ilkn_phys_get(
    int unit,
    int ilkn_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_phys);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ilkn_id, 0);
    return (const dnx_data_nif_ilkn_phys_t *) data;

}

const dnx_data_nif_ilkn_supported_phys_t *
dnx_data_nif_ilkn_supported_phys_get(
    int unit,
    int ilkn_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_supported_phys);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ilkn_id, 0);
    return (const dnx_data_nif_ilkn_supported_phys_t *) data;

}

const dnx_data_nif_ilkn_supported_core_t *
dnx_data_nif_ilkn_supported_core_get(
    int unit,
    int ilkn_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_supported_core);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ilkn_id, 0);
    return (const dnx_data_nif_ilkn_supported_core_t *) data;

}

const dnx_data_nif_ilkn_properties_t *
dnx_data_nif_ilkn_properties_get(
    int unit,
    int ilkn_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_properties);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ilkn_id, 0);
    return (const dnx_data_nif_ilkn_properties_t *) data;

}

const dnx_data_nif_ilkn_nif_pms_t *
dnx_data_nif_ilkn_nif_pms_get(
    int unit,
    int pm_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_nif_pms);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, pm_id, 0);
    return (const dnx_data_nif_ilkn_nif_pms_t *) data;

}

const dnx_data_nif_ilkn_fabric_pms_t *
dnx_data_nif_ilkn_fabric_pms_get(
    int unit,
    int pm_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_fabric_pms);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, pm_id, 0);
    return (const dnx_data_nif_ilkn_fabric_pms_t *) data;

}

const dnx_data_nif_ilkn_ilkn_pms_t *
dnx_data_nif_ilkn_ilkn_pms_get(
    int unit,
    int ilkn_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_ilkn_pms);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ilkn_id, 0);
    return (const dnx_data_nif_ilkn_ilkn_pms_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_nif_ilkn_phys_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_ilkn_phys_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_phys);
    data = (const dnx_data_nif_ilkn_phys_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            DNXC_DATA_MGMT_PBMP_STR(buffer, data->bitmap);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_ilkn_supported_phys_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_ilkn_supported_phys_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_supported_phys);
    data = (const dnx_data_nif_ilkn_supported_phys_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->is_supported);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->max_phys);
            break;
        case 2:
            DNXC_DATA_MGMT_PBMP_STR(buffer, data->nif_phys);
            break;
        case 3:
            DNXC_DATA_MGMT_PBMP_STR(buffer, data->fabric_phys);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_ilkn_supported_core_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_ilkn_supported_core_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_supported_core);
    data = (const dnx_data_nif_ilkn_supported_core_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->core);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_ilkn_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_ilkn_properties_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_properties);
    data = (const dnx_data_nif_ilkn_properties_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->burst_short);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->burst_max);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->burst_min);
            break;
        case 3:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->metaframe_period);
            break;
        case 4:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->is_over_fabric);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_ilkn_nif_pms_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_ilkn_nif_pms_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_nif_pms);
    data = (const dnx_data_nif_ilkn_nif_pms_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->dispatch_type);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->first_phy);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_ilkn_fabric_pms_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_ilkn_fabric_pms_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_fabric_pms);
    data = (const dnx_data_nif_ilkn_fabric_pms_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->dispatch_type);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->first_phy);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_ilkn_ilkn_pms_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_ilkn_ilkn_pms_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_ilkn_pms);
    data = (const dnx_data_nif_ilkn_ilkn_pms_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            DNXC_DATA_MGMT_ARR_STR(buffer, DNX_DATA_MAX_NIF_ILKN_PMS_NOF, data->nif_pm_ids);
            break;
        case 1:
            DNXC_DATA_MGMT_ARR_STR(buffer, DNX_DATA_MAX_NIF_ILKN_PMS_NOF, data->fabric_pm_ids);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_nif_ilkn_phys_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_phys);

}

const dnxc_data_table_info_t *
dnx_data_nif_ilkn_supported_phys_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_supported_phys);

}

const dnxc_data_table_info_t *
dnx_data_nif_ilkn_supported_core_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_supported_core);

}

const dnxc_data_table_info_t *
dnx_data_nif_ilkn_properties_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_properties);

}

const dnxc_data_table_info_t *
dnx_data_nif_ilkn_nif_pms_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_nif_pms);

}

const dnxc_data_table_info_t *
dnx_data_nif_ilkn_fabric_pms_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_fabric_pms);

}

const dnxc_data_table_info_t *
dnx_data_nif_ilkn_ilkn_pms_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_ilkn, dnx_data_nif_ilkn_table_ilkn_pms);

}

/*
 * }
 */

/*
 * SUBMODULE - ETH:
 * {
 */
/*
 * eth init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_nif_eth_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "eth";
    submodule_data->doc = "data about Ethernet ports";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_nif_eth_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data nif eth features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_nif_eth_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data nif eth defines");

    submodule_data->defines[dnx_data_nif_eth_define_cdu_nof].name = "cdu_nof";
    submodule_data->defines[dnx_data_nif_eth_define_cdu_nof].doc = "Number of CDU instances in the device";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_cdu_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_cdum_nof].name = "cdum_nof";
    submodule_data->defines[dnx_data_nif_eth_define_cdum_nof].doc = "Number of CDUM instances in the device";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_cdum_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_cdu_pms_nof].name = "cdu_pms_nof";
    submodule_data->defines[dnx_data_nif_eth_define_cdu_pms_nof].doc = "Number of pms in each CDU in the device";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_cdu_pms_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_cdu_nof_per_core].name = "cdu_nof_per_core";
    submodule_data->defines[dnx_data_nif_eth_define_cdu_nof_per_core].doc = "Number of CDU instances in each device core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_cdu_nof_per_core].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_cdu_lanes_nof].name = "cdu_lanes_nof";
    submodule_data->defines[dnx_data_nif_eth_define_cdu_lanes_nof].doc = "Number of lanes in each CDU";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_cdu_lanes_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_cdu_mac_nof].name = "cdu_mac_nof";
    submodule_data->defines[dnx_data_nif_eth_define_cdu_mac_nof].doc = "Number of MAC units per CDU";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_cdu_mac_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_mac_lanes_nof].name = "mac_lanes_nof";
    submodule_data->defines[dnx_data_nif_eth_define_mac_lanes_nof].doc = "Number of lanes in each MAC";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_mac_lanes_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_cdu_logical_fifo_nof].name = "cdu_logical_fifo_nof";
    submodule_data->defines[dnx_data_nif_eth_define_cdu_logical_fifo_nof].doc = "number of logical fifos in the CDU";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_cdu_logical_fifo_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_cdu_memory_entries_nof].name = "cdu_memory_entries_nof";
    submodule_data->defines[dnx_data_nif_eth_define_cdu_memory_entries_nof].doc = "number of entries in the CDU memory, to be shared between all logical FIFOs";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_cdu_memory_entries_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_priority_group_nof_entries_min].name = "priority_group_nof_entries_min";
    submodule_data->defines[dnx_data_nif_eth_define_priority_group_nof_entries_min].doc = "minimum number of entries to allocate to a priority group (priority group = RMC)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_priority_group_nof_entries_min].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_priority_groups_nof].name = "priority_groups_nof";
    submodule_data->defines[dnx_data_nif_eth_define_priority_groups_nof].doc = "number of allowed priority groups per port (priority group = RMC)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_priority_groups_nof].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_pad_size_min].name = "pad_size_min";
    submodule_data->defines[dnx_data_nif_eth_define_pad_size_min].doc = "min padding size";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_pad_size_min].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_pad_size_max].name = "pad_size_max";
    submodule_data->defines[dnx_data_nif_eth_define_pad_size_max].doc = "max padding size";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_pad_size_max].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_packet_size_max].name = "packet_size_max";
    submodule_data->defines[dnx_data_nif_eth_define_packet_size_max].doc = "max packet size";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_packet_size_max].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_eth_define_an_max_nof_abilities].name = "an_max_nof_abilities";
    submodule_data->defines[dnx_data_nif_eth_define_an_max_nof_abilities].doc = "max auto-negotiation abilities";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_eth_define_an_max_nof_abilities].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_nif_eth_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data nif eth tables");

    /*
     * Table - pm_properties
     */
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].name = "pm_properties";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].doc = "PM properties per PM";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].size_of_values = sizeof(dnx_data_nif_eth_pm_properties_t);
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].entry_get = dnx_data_nif_eth_pm_properties_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].keys[0].name = "pm_index";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].keys[0].doc = "PM instance number.";

    /* Values */
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_eth_table_pm_properties].nof_values, "_dnx_data_nif_eth_table_pm_properties table values");
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values[0].name = "phys";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values[0].type = "bcm_pbmp_t";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values[0].doc = "phys connected to the PM.";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_eth_pm_properties_t, phys);
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values[1].name = "tvco_pll_index";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values[1].type = "int";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values[1].doc = "PM TVCO PLL index.";
    submodule_data->tables[dnx_data_nif_eth_table_pm_properties].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_eth_pm_properties_t, tvco_pll_index);

    /*
     * Table - cdu_pm_map
     */
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].name = "cdu_pm_map";
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].doc = "map cdu to PM instance";
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].size_of_values = sizeof(dnx_data_nif_eth_cdu_pm_map_t);
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].entry_get = dnx_data_nif_eth_cdu_pm_map_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].keys[0].name = "cdu_index";
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].keys[0].doc = "cdu instance number.";

    /* Values */
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].nof_values, "_dnx_data_nif_eth_table_cdu_pm_map table values");
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].values[0].name = "pms";
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].values[0].type = "int[DNX_DATA_MAX_NIF_ETH_CDU_PMS_NOF]";
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].values[0].doc = "array of pms in each cdu.";
    submodule_data->tables[dnx_data_nif_eth_table_cdu_pm_map].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_eth_cdu_pm_map_t, pms);

    /*
     * Table - max_speed
     */
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].name = "max_speed";
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].doc = "Max speed for each ethernet interface type.";
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].size_of_values = sizeof(dnx_data_nif_eth_max_speed_t);
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].entry_get = dnx_data_nif_eth_max_speed_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].keys[0].name = "lane_num";
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].keys[0].doc = "number of lanes for the given interface type.";

    /* Values */
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_eth_table_max_speed].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_eth_table_max_speed].nof_values, "_dnx_data_nif_eth_table_max_speed table values");
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].values[0].name = "speed";
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].values[0].type = "int";
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].values[0].doc = "Max speed value.";
    submodule_data->tables[dnx_data_nif_eth_table_max_speed].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_eth_max_speed_t, speed);


exit:
    SHR_FUNC_EXIT;
}

/*
 * eth features
 */
int
dnx_data_nif_eth_feature_get(
    int unit,
    dnx_data_nif_eth_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, feature);
}

/*
 * eth defines
 */
uint32
dnx_data_nif_eth_cdu_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_cdu_nof);
}

uint32
dnx_data_nif_eth_cdum_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_cdum_nof);
}

uint32
dnx_data_nif_eth_cdu_pms_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_cdu_pms_nof);
}

uint32
dnx_data_nif_eth_cdu_nof_per_core_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_cdu_nof_per_core);
}

uint32
dnx_data_nif_eth_cdu_lanes_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_cdu_lanes_nof);
}

uint32
dnx_data_nif_eth_cdu_mac_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_cdu_mac_nof);
}

uint32
dnx_data_nif_eth_mac_lanes_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_mac_lanes_nof);
}

uint32
dnx_data_nif_eth_cdu_logical_fifo_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_cdu_logical_fifo_nof);
}

uint32
dnx_data_nif_eth_cdu_memory_entries_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_cdu_memory_entries_nof);
}

uint32
dnx_data_nif_eth_priority_group_nof_entries_min_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_priority_group_nof_entries_min);
}

uint32
dnx_data_nif_eth_priority_groups_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_priority_groups_nof);
}

uint32
dnx_data_nif_eth_pad_size_min_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_pad_size_min);
}

uint32
dnx_data_nif_eth_pad_size_max_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_pad_size_max);
}

uint32
dnx_data_nif_eth_packet_size_max_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_packet_size_max);
}

uint32
dnx_data_nif_eth_an_max_nof_abilities_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_define_an_max_nof_abilities);
}

/*
 * eth tables
 */
/* Table Get */
const dnx_data_nif_eth_pm_properties_t *
dnx_data_nif_eth_pm_properties_get(
    int unit,
    int pm_index)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_pm_properties);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, pm_index, 0);
    return (const dnx_data_nif_eth_pm_properties_t *) data;

}

const dnx_data_nif_eth_cdu_pm_map_t *
dnx_data_nif_eth_cdu_pm_map_get(
    int unit,
    int cdu_index)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_cdu_pm_map);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, cdu_index, 0);
    return (const dnx_data_nif_eth_cdu_pm_map_t *) data;

}

const dnx_data_nif_eth_max_speed_t *
dnx_data_nif_eth_max_speed_get(
    int unit,
    int lane_num)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_max_speed);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, lane_num, 0);
    return (const dnx_data_nif_eth_max_speed_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_nif_eth_pm_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_eth_pm_properties_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_pm_properties);
    data = (const dnx_data_nif_eth_pm_properties_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            DNXC_DATA_MGMT_PBMP_STR(buffer, data->phys);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->tvco_pll_index);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_eth_cdu_pm_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_eth_cdu_pm_map_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_cdu_pm_map);
    data = (const dnx_data_nif_eth_cdu_pm_map_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            DNXC_DATA_MGMT_ARR_STR(buffer, DNX_DATA_MAX_NIF_ETH_CDU_PMS_NOF, data->pms);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_eth_max_speed_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_eth_max_speed_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_max_speed);
    data = (const dnx_data_nif_eth_max_speed_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->speed);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_nif_eth_pm_properties_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_pm_properties);

}

const dnxc_data_table_info_t *
dnx_data_nif_eth_cdu_pm_map_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_cdu_pm_map);

}

const dnxc_data_table_info_t *
dnx_data_nif_eth_max_speed_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_eth, dnx_data_nif_eth_table_max_speed);

}

/*
 * }
 */

/*
 * SUBMODULE - PRD:
 * {
 */
/*
 * prd init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_nif_prd_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "prd";
    submodule_data->doc = "Priority Drop module";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_nif_prd_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data nif prd features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_nif_prd_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data nif prd defines");

    submodule_data->defines[dnx_data_nif_prd_define_nof_control_frames].name = "nof_control_frames";
    submodule_data->defines[dnx_data_nif_prd_define_nof_control_frames].doc = "Number of control frame properties to which each packet is compared in order to be recognized as control frame in the PRD parser";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_prd_define_nof_control_frames].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_prd_define_nof_ether_type_codes].name = "nof_ether_type_codes";
    submodule_data->defines[dnx_data_nif_prd_define_nof_ether_type_codes].doc = "Number of ether types supported by the PRD Parser";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_prd_define_nof_ether_type_codes].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_prd_define_nof_tcam_entries].name = "nof_tcam_entries";
    submodule_data->defines[dnx_data_nif_prd_define_nof_tcam_entries].doc = "Number of entries in PRD Parser soft stage TCAM";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_prd_define_nof_tcam_entries].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_prd_define_nof_mpls_special_labels].name = "nof_mpls_special_labels";
    submodule_data->defines[dnx_data_nif_prd_define_nof_mpls_special_labels].doc = "Number of MPLS special labels recognized by the PRD parser";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_prd_define_nof_mpls_special_labels].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_prd_define_nof_priorities].name = "nof_priorities";
    submodule_data->defines[dnx_data_nif_prd_define_nof_priorities].doc = "Number of PRD Priorities";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_prd_define_nof_priorities].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_prd_define_custom_ether_type_code_min].name = "custom_ether_type_code_min";
    submodule_data->defines[dnx_data_nif_prd_define_custom_ether_type_code_min].doc = "Min value of the configurable ether type codes";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_prd_define_custom_ether_type_code_min].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_prd_define_custom_ether_type_code_max].name = "custom_ether_type_code_max";
    submodule_data->defines[dnx_data_nif_prd_define_custom_ether_type_code_max].doc = "Max value of the configurable ether type codes";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_prd_define_custom_ether_type_code_max].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_nif_prd_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data nif prd tables");

    /*
     * Table - ether_type
     */
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].name = "ether_type";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].doc = "Ether type codes and sizes for fixed ether types.";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].size_of_values = sizeof(dnx_data_nif_prd_ether_type_t);
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].entry_get = dnx_data_nif_prd_ether_type_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].keys[0].name = "ether_type_code";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].keys[0].doc = "Ether type code in PRD parser";

    /* Values */
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_prd_table_ether_type].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_prd_table_ether_type].nof_values, "_dnx_data_nif_prd_table_ether_type table values");
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].values[0].name = "ether_type_name";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].values[0].type = "char *";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].values[0].doc = "the name of the Ether type.";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_prd_ether_type_t, ether_type_name);
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].values[1].name = "ether_type_size";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].values[1].doc = "the size in bytes of the ether type header.";
    submodule_data->tables[dnx_data_nif_prd_table_ether_type].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_prd_ether_type_t, ether_type_size);


exit:
    SHR_FUNC_EXIT;
}

/*
 * prd features
 */
int
dnx_data_nif_prd_feature_get(
    int unit,
    dnx_data_nif_prd_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, feature);
}

/*
 * prd defines
 */
uint32
dnx_data_nif_prd_nof_control_frames_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_define_nof_control_frames);
}

uint32
dnx_data_nif_prd_nof_ether_type_codes_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_define_nof_ether_type_codes);
}

uint32
dnx_data_nif_prd_nof_tcam_entries_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_define_nof_tcam_entries);
}

uint32
dnx_data_nif_prd_nof_mpls_special_labels_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_define_nof_mpls_special_labels);
}

uint32
dnx_data_nif_prd_nof_priorities_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_define_nof_priorities);
}

uint32
dnx_data_nif_prd_custom_ether_type_code_min_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_define_custom_ether_type_code_min);
}

uint32
dnx_data_nif_prd_custom_ether_type_code_max_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_define_custom_ether_type_code_max);
}

/*
 * prd tables
 */
/* Table Get */
const dnx_data_nif_prd_ether_type_t *
dnx_data_nif_prd_ether_type_get(
    int unit,
    int ether_type_code)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_table_ether_type);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ether_type_code, 0);
    return (const dnx_data_nif_prd_ether_type_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_nif_prd_ether_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_prd_ether_type_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_table_ether_type);
    data = (const dnx_data_nif_prd_ether_type_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%s", data->ether_type_name == NULL ? "" : data->ether_type_name);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->ether_type_size);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_nif_prd_ether_type_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_prd, dnx_data_nif_prd_table_ether_type);

}

/*
 * }
 */

/*
 * SUBMODULE - PORTMOD:
 * {
 */
/*
 * portmod init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_nif_portmod_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "portmod";
    submodule_data->doc = "information required for portmod.";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_nif_portmod_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data nif portmod features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_nif_portmod_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data nif portmod defines");

    submodule_data->defines[dnx_data_nif_portmod_define_pm_types_nof].name = "pm_types_nof";
    submodule_data->defines[dnx_data_nif_portmod_define_pm_types_nof].doc = "Number of pm types";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_portmod_define_pm_types_nof].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_nif_portmod_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data nif portmod tables");

    /*
     * Table - pm_types_and_interfaces
     */
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].name = "pm_types_and_interfaces";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].doc = "fixed types and interfaces per device";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].size_of_values = sizeof(dnx_data_nif_portmod_pm_types_and_interfaces_t);
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].entry_get = dnx_data_nif_portmod_pm_types_and_interfaces_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].keys[0].name = "index";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].keys[0].doc = "pm type index";

    /* Values */
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].nof_values, "_dnx_data_nif_portmod_table_pm_types_and_interfaces table values");
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values[0].name = "type";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values[0].type = "portmod_dispatch_type_t";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values[0].doc = "pm type";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_portmod_pm_types_and_interfaces_t, type);
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values[1].name = "instances";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values[1].type = "int";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values[1].doc = "the number of instances of the specified pm type";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_types_and_interfaces].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_portmod_pm_types_and_interfaces_t, instances);

    /*
     * Table - pm_supported_features
     */
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].name = "pm_supported_features";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].doc = "supported features per Port Macro";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].size_of_values = sizeof(dnx_data_nif_portmod_pm_supported_features_t);
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].entry_get = dnx_data_nif_portmod_pm_supported_features_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].nof_keys = 1;
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].keys[0].name = "pm_index";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].keys[0].doc = "port macro index in the device";

    /* Values */
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].nof_values = 3;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values, dnxc_data_value_t, submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].nof_values, "_dnx_data_nif_portmod_table_pm_supported_features table values");
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[0].name = "is_pam4_support";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[0].type = "uint32";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[0].doc = "are PAM4 speeds supported on this PM (50G)";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[0].offset = UTILEX_OFFSETOF(dnx_data_nif_portmod_pm_supported_features_t, is_pam4_support);
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[1].name = "is_400g_support";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[1].type = "uint32";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[1].doc = "is PM support 400G mode";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[1].offset = UTILEX_OFFSETOF(dnx_data_nif_portmod_pm_supported_features_t, is_400g_support);
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[2].name = "is_25g_support";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[2].type = "uint32";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[2].doc = "is PM support 25G speed";
    submodule_data->tables[dnx_data_nif_portmod_table_pm_supported_features].values[2].offset = UTILEX_OFFSETOF(dnx_data_nif_portmod_pm_supported_features_t, is_25g_support);


exit:
    SHR_FUNC_EXIT;
}

/*
 * portmod features
 */
int
dnx_data_nif_portmod_feature_get(
    int unit,
    dnx_data_nif_portmod_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_portmod, feature);
}

/*
 * portmod defines
 */
uint32
dnx_data_nif_portmod_pm_types_nof_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_portmod, dnx_data_nif_portmod_define_pm_types_nof);
}

/*
 * portmod tables
 */
/* Table Get */
const dnx_data_nif_portmod_pm_types_and_interfaces_t *
dnx_data_nif_portmod_pm_types_and_interfaces_get(
    int unit,
    int index)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_portmod, dnx_data_nif_portmod_table_pm_types_and_interfaces);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, index, 0);
    return (const dnx_data_nif_portmod_pm_types_and_interfaces_t *) data;

}

const dnx_data_nif_portmod_pm_supported_features_t *
dnx_data_nif_portmod_pm_supported_features_get(
    int unit,
    int pm_index)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_portmod, dnx_data_nif_portmod_table_pm_supported_features);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, pm_index, 0);
    return (const dnx_data_nif_portmod_pm_supported_features_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_nif_portmod_pm_types_and_interfaces_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_portmod_pm_types_and_interfaces_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_portmod, dnx_data_nif_portmod_table_pm_types_and_interfaces);
    data = (const dnx_data_nif_portmod_pm_types_and_interfaces_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->type);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->instances);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_nif_portmod_pm_supported_features_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_nif_portmod_pm_supported_features_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_portmod, dnx_data_nif_portmod_table_pm_supported_features);
    data = (const dnx_data_nif_portmod_pm_supported_features_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->is_pam4_support);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->is_400g_support);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->is_25g_support);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_nif_portmod_pm_types_and_interfaces_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_portmod, dnx_data_nif_portmod_table_pm_types_and_interfaces);

}

const dnxc_data_table_info_t *
dnx_data_nif_portmod_pm_supported_features_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_portmod, dnx_data_nif_portmod_table_pm_supported_features);

}

/*
 * }
 */

/*
 * SUBMODULE - SCHEDULDER:
 * {
 */
/*
 * schedulder init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_nif_schedulder_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "schedulder";
    submodule_data->doc = "data about NIF schedulder";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_nif_schedulder_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data nif schedulder features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_nif_schedulder_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data nif schedulder defines");

    submodule_data->defines[dnx_data_nif_schedulder_define_rate_per_cdu_bit].name = "rate_per_cdu_bit";
    submodule_data->defines[dnx_data_nif_schedulder_define_rate_per_cdu_bit].doc = "The Rate equivalent to 1 bit of CDU scheduler";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_schedulder_define_rate_per_cdu_bit].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_schedulder_define_rate_per_rmc_bit].name = "rate_per_rmc_bit";
    submodule_data->defines[dnx_data_nif_schedulder_define_rate_per_rmc_bit].doc = "The Rate equivalent to 1 bit of RMC scheduler";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_schedulder_define_rate_per_rmc_bit].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_schedulder_define_nof_cdu_bits].name = "nof_cdu_bits";
    submodule_data->defines[dnx_data_nif_schedulder_define_nof_cdu_bits].doc = "Number of bits in CDU scheduler";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_schedulder_define_nof_cdu_bits].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_nif_schedulder_define_nof_rmc_bits].name = "nof_rmc_bits";
    submodule_data->defines[dnx_data_nif_schedulder_define_nof_rmc_bits].doc = "Number of bits in RMC scheduler";
    /* Set data type flag */
    submodule_data->defines[dnx_data_nif_schedulder_define_nof_rmc_bits].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_nif_schedulder_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data nif schedulder tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * schedulder features
 */
int
dnx_data_nif_schedulder_feature_get(
    int unit,
    dnx_data_nif_schedulder_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_schedulder, feature);
}

/*
 * schedulder defines
 */
uint32
dnx_data_nif_schedulder_rate_per_cdu_bit_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_schedulder, dnx_data_nif_schedulder_define_rate_per_cdu_bit);
}

uint32
dnx_data_nif_schedulder_rate_per_rmc_bit_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_schedulder, dnx_data_nif_schedulder_define_rate_per_rmc_bit);
}

uint32
dnx_data_nif_schedulder_nof_cdu_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_schedulder, dnx_data_nif_schedulder_define_nof_cdu_bits);
}

uint32
dnx_data_nif_schedulder_nof_rmc_bits_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_nif, dnx_data_nif_submodule_schedulder, dnx_data_nif_schedulder_define_nof_rmc_bits);
}

/*
 * schedulder tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

shr_error_e
dnx_data_nif_init(
    int unit,
    dnxc_data_module_t *module_data)
{
    SHR_FUNC_INIT_VARS(unit);

    /* Data Struct Init */
    module_data->name = "nif";
    module_data->nof_submodules = _dnx_data_nif_submodule_nof;
    DNXC_DATA_ALLOC(module_data->submodules, dnxc_data_submodule_t, module_data->nof_submodules, "_dnxc_data nif submodules");

    /*
     * Init Submodule data
     */
    SHR_IF_ERR_EXIT(dnx_data_nif_global_init(unit, &module_data->submodules[dnx_data_nif_submodule_global]));
    SHR_IF_ERR_EXIT(dnx_data_nif_phys_init(unit, &module_data->submodules[dnx_data_nif_submodule_phys]));
    SHR_IF_ERR_EXIT(dnx_data_nif_ilkn_init(unit, &module_data->submodules[dnx_data_nif_submodule_ilkn]));
    SHR_IF_ERR_EXIT(dnx_data_nif_eth_init(unit, &module_data->submodules[dnx_data_nif_submodule_eth]));
    SHR_IF_ERR_EXIT(dnx_data_nif_prd_init(unit, &module_data->submodules[dnx_data_nif_submodule_prd]));
    SHR_IF_ERR_EXIT(dnx_data_nif_portmod_init(unit, &module_data->submodules[dnx_data_nif_submodule_portmod]));
    SHR_IF_ERR_EXIT(dnx_data_nif_schedulder_init(unit, &module_data->submodules[dnx_data_nif_submodule_schedulder]));
    /*
     * Attach device module
     */
    if (dnxc_data_mgmt_is_jer2_a0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_nif_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_jer2_b0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_nif_attach(unit));
    }

exit:
    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
