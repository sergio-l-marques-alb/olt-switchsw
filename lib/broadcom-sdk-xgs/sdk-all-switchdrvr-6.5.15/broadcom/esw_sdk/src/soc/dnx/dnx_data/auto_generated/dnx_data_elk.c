/** \file dnx_data_elk.c
 * 
 * MODULE DEVICE DATA - ELK
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_ELKDNX
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_elk.h>
/*
 * }
 */

/*
 * Extern per device attach function
 */
extern shr_error_e jer2_a0_data_elk_attach(
    int unit);
/*
 * SUBMODULE - GENERAL:
 * {
 */
/*
 * general init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_elk_general_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "general";
    submodule_data->doc = "ELK general data.";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_elk_general_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data elk general features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_elk_general_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data elk general defines");

    submodule_data->defines[dnx_data_elk_general_define_max_ports].name = "max_ports";
    submodule_data->defines[dnx_data_elk_general_define_max_ports].doc = "Max Elk ports";
    /* Set data type flag */
    submodule_data->defines[dnx_data_elk_general_define_max_ports].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_elk_general_define_rop_fifo_depth].name = "rop_fifo_depth";
    submodule_data->defines[dnx_data_elk_general_define_rop_fifo_depth].doc = "ROP Fifo memory depth in EGW";
    /* Set data type flag */
    submodule_data->defines[dnx_data_elk_general_define_rop_fifo_depth].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_elk_general_define_max_lane_id].name = "max_lane_id";
    submodule_data->defines[dnx_data_elk_general_define_max_lane_id].doc = "KBP MAX lane id";
    /* Set data type flag */
    submodule_data->defines[dnx_data_elk_general_define_max_lane_id].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_elk_general_define_device_type].name = "device_type";
    submodule_data->defines[dnx_data_elk_general_define_device_type].doc = "External Tcam device type.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_elk_general_define_device_type].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_elk_general_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data elk general tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * general features
 */
int
dnx_data_elk_general_feature_get(
    int unit,
    dnx_data_elk_general_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_general, feature);
}

/*
 * general defines
 */
uint32
dnx_data_elk_general_max_ports_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_general, dnx_data_elk_general_define_max_ports);
}

uint32
dnx_data_elk_general_rop_fifo_depth_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_general, dnx_data_elk_general_define_rop_fifo_depth);
}

uint32
dnx_data_elk_general_max_lane_id_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_general, dnx_data_elk_general_define_max_lane_id);
}

uint32
dnx_data_elk_general_device_type_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_general, dnx_data_elk_general_define_device_type);
}

/*
 * general tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - APPLICATION:
 * {
 */
/*
 * application init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_elk_application_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "application";
    submodule_data->doc = "ELK forwarding applications.";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_elk_application_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data elk application features");

    submodule_data->features[dnx_data_elk_application_ipv4].name = "ipv4";
    submodule_data->features[dnx_data_elk_application_ipv4].doc = "KBP IPv4 application enabled";
    submodule_data->features[dnx_data_elk_application_ipv4].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_elk_application_ipv6].name = "ipv6";
    submodule_data->features[dnx_data_elk_application_ipv6].doc = "KBP IPv6 application enabled";
    submodule_data->features[dnx_data_elk_application_ipv6].flags |= DNXC_DATA_F_FEATURE;

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_elk_application_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data elk application defines");

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_elk_application_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data elk application tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * application features
 */
int
dnx_data_elk_application_feature_get(
    int unit,
    dnx_data_elk_application_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_application, feature);
}

/*
 * application defines
 */
/*
 * application tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - CONNECTIVITY:
 * {
 */
/*
 * connectivity init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_elk_connectivity_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "connectivity";
    submodule_data->doc = "ELK connectivity parameters.";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_elk_connectivity_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data elk connectivity features");

    submodule_data->features[dnx_data_elk_connectivity_blackhole].name = "blackhole";
    submodule_data->features[dnx_data_elk_connectivity_blackhole].doc = "KBP Blackhole mode enabled";
    submodule_data->features[dnx_data_elk_connectivity_blackhole].flags |= DNXC_DATA_F_FEATURE;

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_elk_connectivity_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data elk connectivity defines");

    submodule_data->defines[dnx_data_elk_connectivity_define_connect_mode].name = "connect_mode";
    submodule_data->defines[dnx_data_elk_connectivity_define_connect_mode].doc = "External Tcam connect mode.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_elk_connectivity_define_connect_mode].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_elk_connectivity_define_mdio_id].name = "mdio_id";
    submodule_data->defines[dnx_data_elk_connectivity_define_mdio_id].doc = "KBP MDIO ID.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_elk_connectivity_define_mdio_id].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_elk_connectivity_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data elk connectivity tables");

    /*
     * Table - ilkn_reverse
     */
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].name = "ilkn_reverse";
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].doc = "External lookup (elk) ILKN lanes swap";
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].size_of_values = sizeof(dnx_data_elk_connectivity_ilkn_reverse_t);
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].entry_get = dnx_data_elk_connectivity_ilkn_reverse_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].nof_keys = 1;
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].keys[0].name = "ilkn_id";
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].keys[0].doc = "port id elk device side";

    /* Values */
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].values, dnxc_data_value_t, submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].nof_values, "_dnx_data_elk_connectivity_table_ilkn_reverse table values");
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].values[0].name = "reverse";
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].values[0].type = "uint32";
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].values[0].doc = "If set, reverse the lanes numbering order on elk device side";
    submodule_data->tables[dnx_data_elk_connectivity_table_ilkn_reverse].values[0].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_ilkn_reverse_t, reverse);

    /*
     * Table - topology
     */
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].name = "topology";
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].doc = "KBP to Jericho connection topology.";
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].size_of_values = sizeof(dnx_data_elk_connectivity_topology_t);
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].entry_get = dnx_data_elk_connectivity_topology_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].nof_keys = 0;

    /* Values */
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_elk_connectivity_table_topology].values, dnxc_data_value_t, submodule_data->tables[dnx_data_elk_connectivity_table_topology].nof_values, "_dnx_data_elk_connectivity_table_topology table values");
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].values[0].name = "start_lane";
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].values[0].type = "uint32[DNX_DATA_MAX_ELK_GENERAL_MAX_PORTS]";
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].values[0].doc = "Start lane number for each kbp port.";
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].values[0].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_topology_t, start_lane);
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].values[1].name = "port_core_mapping";
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].values[1].type = "uint32[DNX_DATA_MAX_ELK_GENERAL_MAX_PORTS]";
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].values[1].doc = "KBP port to Jericho2 core mapping.";
    submodule_data->tables[dnx_data_elk_connectivity_table_topology].values[1].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_topology_t, port_core_mapping);

    /*
     * Table - kbp_serdes_tx_taps
     */
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].name = "kbp_serdes_tx_taps";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].doc = "PHY TX tap configuration on KBP side";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].size_of_values = sizeof(dnx_data_elk_connectivity_kbp_serdes_tx_taps_t);
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].entry_get = dnx_data_elk_connectivity_kbp_serdes_tx_taps_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].nof_keys = 1;
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].keys[0].name = "lane_id";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].keys[0].doc = "lane id on KBP side";

    /* Values */
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].nof_values = 7;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values, dnxc_data_value_t, submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].nof_values, "_dnx_data_elk_connectivity_table_kbp_serdes_tx_taps table values");
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[0].name = "pre";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[0].type = "int";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[0].doc = "Tx fir pre tap";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[0].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_kbp_serdes_tx_taps_t, pre);
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[1].name = "main";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[1].type = "int";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[1].doc = "Tx fir main tap";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[1].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_kbp_serdes_tx_taps_t, main);
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[2].name = "post";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[2].type = "int";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[2].doc = "Tx fir post tap";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[2].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_kbp_serdes_tx_taps_t, post);
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[3].name = "pre2";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[3].type = "int";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[3].doc = "Tx fir pre2 tap";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[3].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_kbp_serdes_tx_taps_t, pre2);
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[4].name = "post2";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[4].type = "int";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[4].doc = "Tx fir post2 tap";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[4].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_kbp_serdes_tx_taps_t, post2);
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[5].name = "post3";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[5].type = "int";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[5].doc = "Tx fir post3 tap";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[5].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_kbp_serdes_tx_taps_t, post3);
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[6].name = "txfir_tap_enable";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[6].type = "enum kbp_blackhawk_tsc_txfir_tap_enable_enum";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[6].doc = "TXFIR Tap Enable Enum";
    submodule_data->tables[dnx_data_elk_connectivity_table_kbp_serdes_tx_taps].values[6].offset = UTILEX_OFFSETOF(dnx_data_elk_connectivity_kbp_serdes_tx_taps_t, txfir_tap_enable);


exit:
    SHR_FUNC_EXIT;
}

/*
 * connectivity features
 */
int
dnx_data_elk_connectivity_feature_get(
    int unit,
    dnx_data_elk_connectivity_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, feature);
}

/*
 * connectivity defines
 */
uint32
dnx_data_elk_connectivity_connect_mode_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_define_connect_mode);
}

uint32
dnx_data_elk_connectivity_mdio_id_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_define_mdio_id);
}

/*
 * connectivity tables
 */
/* Table Get */
const dnx_data_elk_connectivity_ilkn_reverse_t *
dnx_data_elk_connectivity_ilkn_reverse_get(
    int unit,
    int ilkn_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_ilkn_reverse);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ilkn_id, 0);
    return (const dnx_data_elk_connectivity_ilkn_reverse_t *) data;

}

const dnx_data_elk_connectivity_topology_t *
dnx_data_elk_connectivity_topology_get(
    int unit)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_topology);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    return (const dnx_data_elk_connectivity_topology_t *) data;

}

const dnx_data_elk_connectivity_kbp_serdes_tx_taps_t *
dnx_data_elk_connectivity_kbp_serdes_tx_taps_get(
    int unit,
    int lane_id)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_kbp_serdes_tx_taps);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, lane_id, 0);
    return (const dnx_data_elk_connectivity_kbp_serdes_tx_taps_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_elk_connectivity_ilkn_reverse_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_elk_connectivity_ilkn_reverse_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_ilkn_reverse);
    data = (const dnx_data_elk_connectivity_ilkn_reverse_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->reverse);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_elk_connectivity_topology_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_elk_connectivity_topology_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_topology);
    data = (const dnx_data_elk_connectivity_topology_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, 0, 0);
    switch (value_index)
    {
        case 0:
            DNXC_DATA_MGMT_ARR_STR(buffer, DNX_DATA_MAX_ELK_GENERAL_MAX_PORTS, data->start_lane);
            break;
        case 1:
            DNXC_DATA_MGMT_ARR_STR(buffer, DNX_DATA_MAX_ELK_GENERAL_MAX_PORTS, data->port_core_mapping);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_elk_connectivity_kbp_serdes_tx_taps_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_elk_connectivity_kbp_serdes_tx_taps_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_kbp_serdes_tx_taps);
    data = (const dnx_data_elk_connectivity_kbp_serdes_tx_taps_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pre);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->main);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->post);
            break;
        case 3:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pre2);
            break;
        case 4:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->post2);
            break;
        case 5:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->post3);
            break;
        case 6:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->txfir_tap_enable);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_elk_connectivity_ilkn_reverse_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_ilkn_reverse);

}

const dnxc_data_table_info_t *
dnx_data_elk_connectivity_topology_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_topology);

}

const dnxc_data_table_info_t *
dnx_data_elk_connectivity_kbp_serdes_tx_taps_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_connectivity, dnx_data_elk_connectivity_table_kbp_serdes_tx_taps);

}

/*
 * }
 */

/*
 * SUBMODULE - RECOVERY:
 * {
 */
/*
 * recovery init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_elk_recovery_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "recovery";
    submodule_data->doc = "ELK general data.";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_elk_recovery_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data elk recovery features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_elk_recovery_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data elk recovery defines");

    submodule_data->defines[dnx_data_elk_recovery_define_enable].name = "enable";
    submodule_data->defines[dnx_data_elk_recovery_define_enable].doc = "Enable the KBP recovery sequence.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_elk_recovery_define_enable].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_elk_recovery_define_iteration].name = "iteration";
    submodule_data->defines[dnx_data_elk_recovery_define_iteration].doc = "KBP recovery iteration.";
    /* Set data type flag */
    submodule_data->defines[dnx_data_elk_recovery_define_iteration].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_elk_recovery_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data elk recovery tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * recovery features
 */
int
dnx_data_elk_recovery_feature_get(
    int unit,
    dnx_data_elk_recovery_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_recovery, feature);
}

/*
 * recovery defines
 */
uint32
dnx_data_elk_recovery_enable_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_recovery, dnx_data_elk_recovery_define_enable);
}

uint32
dnx_data_elk_recovery_iteration_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_elk, dnx_data_elk_submodule_recovery, dnx_data_elk_recovery_define_iteration);
}

/*
 * recovery tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

shr_error_e
dnx_data_elk_init(
    int unit,
    dnxc_data_module_t *module_data)
{
    SHR_FUNC_INIT_VARS(unit);

    /* Data Struct Init */
    module_data->name = "elk";
    module_data->nof_submodules = _dnx_data_elk_submodule_nof;
    DNXC_DATA_ALLOC(module_data->submodules, dnxc_data_submodule_t, module_data->nof_submodules, "_dnxc_data elk submodules");

    /*
     * Init Submodule data
     */
    SHR_IF_ERR_EXIT(dnx_data_elk_general_init(unit, &module_data->submodules[dnx_data_elk_submodule_general]));
    SHR_IF_ERR_EXIT(dnx_data_elk_application_init(unit, &module_data->submodules[dnx_data_elk_submodule_application]));
    SHR_IF_ERR_EXIT(dnx_data_elk_connectivity_init(unit, &module_data->submodules[dnx_data_elk_submodule_connectivity]));
    SHR_IF_ERR_EXIT(dnx_data_elk_recovery_init(unit, &module_data->submodules[dnx_data_elk_submodule_recovery]));
    /*
     * Attach device module
     */
    if (dnxc_data_mgmt_is_jer2_a0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_elk_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_jer2_b0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_elk_attach(unit));
    }

exit:
    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
