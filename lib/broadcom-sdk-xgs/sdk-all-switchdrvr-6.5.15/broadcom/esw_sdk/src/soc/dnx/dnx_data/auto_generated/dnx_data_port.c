/** \file dnx_data_port.c
 * 
 * MODULE DEVICE DATA - PORT
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_PORT
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_port.h>
/*
 * }
 */

/*
 * Extern per device attach function
 */
extern shr_error_e jer2_a0_data_port_attach(
    int unit);
/*
 * SUBMODULE - STATIC_ADD:
 * {
 */
/*
 * static_add init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_port_static_add_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "static_add";
    submodule_data->doc = "adding port statically";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_port_static_add_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data port static_add features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_port_static_add_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data port static_add defines");

    submodule_data->defines[dnx_data_port_static_add_define_default_speed_for_special_if].name = "default_speed_for_special_if";
    submodule_data->defines[dnx_data_port_static_add_define_default_speed_for_special_if].doc = "default speed in kbps for special interfaces (tm ports excluding NIF)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_static_add_define_default_speed_for_special_if].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_static_add_define_fabric_fw_load_method].name = "fabric_fw_load_method";
    submodule_data->defines[dnx_data_port_static_add_define_fabric_fw_load_method].doc = "Method of the Fabric firmware load";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_static_add_define_fabric_fw_load_method].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_port_static_add_define_fabric_fw_load_verify].name = "fabric_fw_load_verify";
    submodule_data->defines[dnx_data_port_static_add_define_fabric_fw_load_verify].doc = "Fabric firmware load verification method";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_static_add_define_fabric_fw_load_verify].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_port_static_add_define_nif_fw_load_method].name = "nif_fw_load_method";
    submodule_data->defines[dnx_data_port_static_add_define_nif_fw_load_method].doc = "Method of the Nif firmware load";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_static_add_define_nif_fw_load_method].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_port_static_add_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data port static_add tables");

    /*
     * Table - ucode_port
     */
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].name = "ucode_port";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].doc = "static port configuration";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].size_of_values = sizeof(dnx_data_port_static_add_ucode_port_t);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].entry_get = dnx_data_port_static_add_ucode_port_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].keys[0].doc = "logical port";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].nof_values = 11;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_ucode_port].nof_values, "_dnx_data_port_static_add_table_ucode_port table values");
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[0].name = "interface";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[0].type = "bcm_port_if_t";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[0].doc = "port interface";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, interface);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[1].name = "nof_lanes";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[1].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[1].doc = "port number of lanes";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[1].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, nof_lanes);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[2].name = "interface_offset";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[2].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[2].doc = "interface offset";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[2].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, interface_offset);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[3].name = "core";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[3].type = "bcm_core_t";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[3].doc = "core id";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[3].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, core);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[4].name = "tm_port";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[4].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[4].doc = "tm port";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[4].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, tm_port);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[5].name = "channel";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[5].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[5].doc = "channel id";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[5].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, channel);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[6].name = "is_stif";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[6].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[6].doc = "true iff it is statistic interface port";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[6].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, is_stif);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[7].name = "is_kbp";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[7].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[7].doc = "true iff it is kbp port";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[7].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, is_kbp);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[8].name = "tdm_mode";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[8].type = "dnx_algo_port_tdm_mode_e";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[8].doc = "tdm mode of a port - see dnx_algo_port_tdm_mode_e";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[8].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, tdm_mode);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[9].name = "num_priorities";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[9].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[9].doc = "number of port priorities";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[9].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, num_priorities);
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[10].name = "base_q_pair";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[10].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[10].doc = "should be used just in case the user need to exlictly pick the base queue pair";
    submodule_data->tables[dnx_data_port_static_add_table_ucode_port].values[10].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ucode_port_t, base_q_pair);

    /*
     * Table - speed
     */
    submodule_data->tables[dnx_data_port_static_add_table_speed].name = "speed";
    submodule_data->tables[dnx_data_port_static_add_table_speed].doc = "per port speed";
    submodule_data->tables[dnx_data_port_static_add_table_speed].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_speed].size_of_values = sizeof(dnx_data_port_static_add_speed_t);
    submodule_data->tables[dnx_data_port_static_add_table_speed].entry_get = dnx_data_port_static_add_speed_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_speed].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_speed].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_speed].keys[0].doc = "logical port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_speed].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_speed].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_speed].nof_values, "_dnx_data_port_static_add_table_speed table values");
    submodule_data->tables[dnx_data_port_static_add_table_speed].values[0].name = "val";
    submodule_data->tables[dnx_data_port_static_add_table_speed].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_speed].values[0].doc = "speed value in mbps";
    submodule_data->tables[dnx_data_port_static_add_table_speed].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_speed_t, val);

    /*
     * Table - ext_stat_speed
     */
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].name = "ext_stat_speed";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].doc = "per external kbp stat port speed";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].size_of_values = sizeof(dnx_data_port_static_add_ext_stat_speed_t);
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].entry_get = dnx_data_port_static_add_ext_stat_speed_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].keys[0].name = "ext_stat_port";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].keys[0].doc = "external device (kbp) statistics port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].nof_values = 2;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].nof_values, "_dnx_data_port_static_add_table_ext_stat_speed table values");
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values[0].name = "speed";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values[0].doc = "speed value in mbps";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ext_stat_speed_t, speed);
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values[1].name = "nof_lanes";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values[1].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values[1].doc = "port number of lanes";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_speed].values[1].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ext_stat_speed_t, nof_lanes);

    /*
     * Table - eth_padding
     */
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].name = "eth_padding";
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].doc = "eth ports padding";
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].size_of_values = sizeof(dnx_data_port_static_add_eth_padding_t);
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].entry_get = dnx_data_port_static_add_eth_padding_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].keys[0].doc = "logical port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_eth_padding].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_eth_padding].nof_values, "_dnx_data_port_static_add_table_eth_padding table values");
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].values[0].name = "pad_size";
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].values[0].doc = "packets smaller than min size value are padded with this value";
    submodule_data->tables[dnx_data_port_static_add_table_eth_padding].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_eth_padding_t, pad_size);

    /*
     * Table - link_training
     */
    submodule_data->tables[dnx_data_port_static_add_table_link_training].name = "link_training";
    submodule_data->tables[dnx_data_port_static_add_table_link_training].doc = "per port link training (CL72)";
    submodule_data->tables[dnx_data_port_static_add_table_link_training].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_link_training].size_of_values = sizeof(dnx_data_port_static_add_link_training_t);
    submodule_data->tables[dnx_data_port_static_add_table_link_training].entry_get = dnx_data_port_static_add_link_training_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_link_training].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_link_training].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_link_training].keys[0].doc = "logical port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_link_training].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_link_training].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_link_training].nof_values, "_dnx_data_port_static_add_table_link_training table values");
    submodule_data->tables[dnx_data_port_static_add_table_link_training].values[0].name = "val";
    submodule_data->tables[dnx_data_port_static_add_table_link_training].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_link_training].values[0].doc = "Is CL72 is enabled";
    submodule_data->tables[dnx_data_port_static_add_table_link_training].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_link_training_t, val);

    /*
     * Table - ext_stat_link_training
     */
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].name = "ext_stat_link_training";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].doc = "per external kbp stat port link training (CL72)";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].size_of_values = sizeof(dnx_data_port_static_add_ext_stat_link_training_t);
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].entry_get = dnx_data_port_static_add_ext_stat_link_training_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].keys[0].name = "ext_stat_port";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].keys[0].doc = "external device (kbp) statistics port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].nof_values, "_dnx_data_port_static_add_table_ext_stat_link_training table values");
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].values[0].name = "val";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].values[0].doc = "Is CL72 is enabled";
    submodule_data->tables[dnx_data_port_static_add_table_ext_stat_link_training].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_ext_stat_link_training_t, val);

    /*
     * Table - fec_type
     */
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].name = "fec_type";
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].doc = "per port FEC type";
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].size_of_values = sizeof(dnx_data_port_static_add_fec_type_t);
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].entry_get = dnx_data_port_static_add_fec_type_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].keys[0].doc = "logical port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_fec_type].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_fec_type].nof_values, "_dnx_data_port_static_add_table_fec_type table values");
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].values[0].name = "val";
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].values[0].type = "bcm_port_phy_fec_t";
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].values[0].doc = "FEC type";
    submodule_data->tables[dnx_data_port_static_add_table_fec_type].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_fec_type_t, val);

    /*
     * Table - serdes_lane_config
     */
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].name = "serdes_lane_config";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].doc = "serdes lane configurations, related to firmware";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].size_of_values = sizeof(dnx_data_port_static_add_serdes_lane_config_t);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].entry_get = dnx_data_port_static_add_serdes_lane_config_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].keys[0].doc = "logical port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].nof_values = 6;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].nof_values, "_dnx_data_port_static_add_table_serdes_lane_config table values");
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[0].name = "dfe";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[0].type = "soc_dnxc_port_dfe_mode_t";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[0].doc = "dfe filter";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_lane_config_t, dfe);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[1].name = "media_type";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[1].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[1].doc = "media type";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[1].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_lane_config_t, media_type);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[2].name = "unreliable_los";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[2].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[2].doc = "unreliable los";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[2].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_lane_config_t, unreliable_los);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[3].name = "cl72_auto_polarity_enable";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[3].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[3].doc = "cl72 auto polarity";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[3].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_lane_config_t, cl72_auto_polarity_enable);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[4].name = "cl72_restart_timeout_enable";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[4].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[4].doc = "cl72 restart timeout";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[4].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_lane_config_t, cl72_restart_timeout_enable);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[5].name = "channel_mode";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[5].type = "soc_dnxc_port_channel_mode_t";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[5].doc = "force nr or force er";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_lane_config].values[5].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_lane_config_t, channel_mode);

    /*
     * Table - serdes_tx_taps
     */
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].name = "serdes_tx_taps";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].doc = "PHY TX tap configuration";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].size_of_values = sizeof(dnx_data_port_static_add_serdes_tx_taps_t);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].entry_get = dnx_data_port_static_add_serdes_tx_taps_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].keys[0].doc = "logical port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].nof_values = 8;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].nof_values, "_dnx_data_port_static_add_table_serdes_tx_taps table values");
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[0].name = "pre";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[0].doc = "Tx fir pre tap";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_tx_taps_t, pre);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[1].name = "main";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[1].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[1].doc = "Tx fir main tap";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[1].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_tx_taps_t, main);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[2].name = "post";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[2].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[2].doc = "Tx fir post tap";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[2].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_tx_taps_t, post);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[3].name = "pre2";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[3].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[3].doc = "Tx fir pre2 tap";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[3].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_tx_taps_t, pre2);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[4].name = "post2";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[4].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[4].doc = "Tx fir post2 tap";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[4].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_tx_taps_t, post2);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[5].name = "post3";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[5].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[5].doc = "Tx fir post3 tap";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[5].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_tx_taps_t, post3);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[6].name = "tx_tap_mode";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[6].type = "bcm_port_phy_tx_tap_mode_t";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[6].doc = "Tx fir tap mode";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[6].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_tx_taps_t, tx_tap_mode);
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[7].name = "signalling_mode";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[7].type = "bcm_port_phy_signalling_mode_t";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[7].doc = "Signalling Mode, NRZ or PAM4";
    submodule_data->tables[dnx_data_port_static_add_table_serdes_tx_taps].values[7].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_serdes_tx_taps_t, signalling_mode);

    /*
     * Table - tx_pam4_precoder
     */
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].name = "tx_pam4_precoder";
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].doc = "is the precoding enabled on TX side";
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].size_of_values = sizeof(dnx_data_port_static_add_tx_pam4_precoder_t);
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].entry_get = dnx_data_port_static_add_tx_pam4_precoder_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].keys[0].doc = "logical port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].nof_values, "_dnx_data_port_static_add_table_tx_pam4_precoder table values");
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].values[0].name = "val";
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].values[0].type = "uint32";
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].values[0].doc = "TX PAM4 Precoder";
    submodule_data->tables[dnx_data_port_static_add_table_tx_pam4_precoder].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_tx_pam4_precoder_t, val);

    /*
     * Table - lp_tx_precoder
     */
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].name = "lp_tx_precoder";
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].doc = "has the link partner enabled pre-coding on its TX side. In other words - enable the decoding on my RX side.";
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].size_of_values = sizeof(dnx_data_port_static_add_lp_tx_precoder_t);
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].entry_get = dnx_data_port_static_add_lp_tx_precoder_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].keys[0].doc = "logical port number";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].nof_values, "_dnx_data_port_static_add_table_lp_tx_precoder table values");
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].values[0].name = "val";
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].values[0].type = "uint32";
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].values[0].doc = "Link Partner TX Precoder";
    submodule_data->tables[dnx_data_port_static_add_table_lp_tx_precoder].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_lp_tx_precoder_t, val);

    /*
     * Table - fabric_quad_info
     */
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].name = "fabric_quad_info";
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].doc = "General fabric quad info";
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].size_of_values = sizeof(dnx_data_port_static_add_fabric_quad_info_t);
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].entry_get = dnx_data_port_static_add_fabric_quad_info_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].keys[0].name = "quad";
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].keys[0].doc = "Quad ID";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].nof_values, "_dnx_data_port_static_add_table_fabric_quad_info table values");
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].values[0].name = "quad_enable";
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].values[0].doc = "Is the quad enabled";
    submodule_data->tables[dnx_data_port_static_add_table_fabric_quad_info].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_fabric_quad_info_t, quad_enable);

    /*
     * Table - header_type
     */
    submodule_data->tables[dnx_data_port_static_add_table_header_type].name = "header_type";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].doc = "header type information";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_header_type].size_of_values = sizeof(dnx_data_port_static_add_header_type_t);
    submodule_data->tables[dnx_data_port_static_add_table_header_type].entry_get = dnx_data_port_static_add_header_type_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_header_type].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_header_type].keys[0].name = "port";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].keys[0].doc = "port";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_header_type].nof_values = 3;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_header_type].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_header_type].nof_values, "_dnx_data_port_static_add_table_header_type table values");
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[0].name = "header_type_in";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[0].doc = "header type per incoming port";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_header_type_t, header_type_in);
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[1].name = "header_type_out";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[1].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[1].doc = "header type per outgoing port";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[1].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_header_type_t, header_type_out);
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[2].name = "header_type";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[2].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[2].doc = "header type per incoming/outgoing port";
    submodule_data->tables[dnx_data_port_static_add_table_header_type].values[2].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_header_type_t, header_type);

    /*
     * Table - erp_exist
     */
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].name = "erp_exist";
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].doc = "Is ERP port defined in config file for the core";
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].flags |= DNXC_DATA_F_TABLE;
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].size_of_values = sizeof(dnx_data_port_static_add_erp_exist_t);
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].entry_get = dnx_data_port_static_add_erp_exist_entry_str_get;

    /* Keys */
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].nof_keys = 1;
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].keys[0].name = "core";
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].keys[0].doc = "core";

    /* Values */
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].nof_values = 1;
    DNXC_DATA_ALLOC(submodule_data->tables[dnx_data_port_static_add_table_erp_exist].values, dnxc_data_value_t, submodule_data->tables[dnx_data_port_static_add_table_erp_exist].nof_values, "_dnx_data_port_static_add_table_erp_exist table values");
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].values[0].name = "exist";
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].values[0].type = "int";
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].values[0].doc = "does epr exist on this core";
    submodule_data->tables[dnx_data_port_static_add_table_erp_exist].values[0].offset = UTILEX_OFFSETOF(dnx_data_port_static_add_erp_exist_t, exist);


exit:
    SHR_FUNC_EXIT;
}

/*
 * static_add features
 */
int
dnx_data_port_static_add_feature_get(
    int unit,
    dnx_data_port_static_add_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, feature);
}

/*
 * static_add defines
 */
uint32
dnx_data_port_static_add_default_speed_for_special_if_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_define_default_speed_for_special_if);
}

uint32
dnx_data_port_static_add_fabric_fw_load_method_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_define_fabric_fw_load_method);
}

uint32
dnx_data_port_static_add_fabric_fw_load_verify_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_define_fabric_fw_load_verify);
}

uint32
dnx_data_port_static_add_nif_fw_load_method_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_define_nif_fw_load_method);
}

/*
 * static_add tables
 */
/* Table Get */
const dnx_data_port_static_add_ucode_port_t *
dnx_data_port_static_add_ucode_port_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ucode_port);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_ucode_port_t *) data;

}

const dnx_data_port_static_add_speed_t *
dnx_data_port_static_add_speed_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_speed);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_speed_t *) data;

}

const dnx_data_port_static_add_ext_stat_speed_t *
dnx_data_port_static_add_ext_stat_speed_get(
    int unit,
    int ext_stat_port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ext_stat_speed);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ext_stat_port, 0);
    return (const dnx_data_port_static_add_ext_stat_speed_t *) data;

}

const dnx_data_port_static_add_eth_padding_t *
dnx_data_port_static_add_eth_padding_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_eth_padding);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_eth_padding_t *) data;

}

const dnx_data_port_static_add_link_training_t *
dnx_data_port_static_add_link_training_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_link_training);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_link_training_t *) data;

}

const dnx_data_port_static_add_ext_stat_link_training_t *
dnx_data_port_static_add_ext_stat_link_training_get(
    int unit,
    int ext_stat_port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ext_stat_link_training);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, ext_stat_port, 0);
    return (const dnx_data_port_static_add_ext_stat_link_training_t *) data;

}

const dnx_data_port_static_add_fec_type_t *
dnx_data_port_static_add_fec_type_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_fec_type);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_fec_type_t *) data;

}

const dnx_data_port_static_add_serdes_lane_config_t *
dnx_data_port_static_add_serdes_lane_config_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_serdes_lane_config);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_serdes_lane_config_t *) data;

}

const dnx_data_port_static_add_serdes_tx_taps_t *
dnx_data_port_static_add_serdes_tx_taps_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_serdes_tx_taps);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_serdes_tx_taps_t *) data;

}

const dnx_data_port_static_add_tx_pam4_precoder_t *
dnx_data_port_static_add_tx_pam4_precoder_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_tx_pam4_precoder);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_tx_pam4_precoder_t *) data;

}

const dnx_data_port_static_add_lp_tx_precoder_t *
dnx_data_port_static_add_lp_tx_precoder_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_lp_tx_precoder);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_lp_tx_precoder_t *) data;

}

const dnx_data_port_static_add_fabric_quad_info_t *
dnx_data_port_static_add_fabric_quad_info_get(
    int unit,
    int quad)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_fabric_quad_info);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, quad, 0);
    return (const dnx_data_port_static_add_fabric_quad_info_t *) data;

}

const dnx_data_port_static_add_header_type_t *
dnx_data_port_static_add_header_type_get(
    int unit,
    int port)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_header_type);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, port, 0);
    return (const dnx_data_port_static_add_header_type_t *) data;

}

const dnx_data_port_static_add_erp_exist_t *
dnx_data_port_static_add_erp_exist_get(
    int unit,
    int core)
{
    char *data;
    dnxc_data_table_t *table;

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_erp_exist);
    /* Get data */
    data = dnxc_data_mgmt_table_data_get(unit, table, core, 0);
    return (const dnx_data_port_static_add_erp_exist_t *) data;

}

/* Get value as str */
shr_error_e
dnx_data_port_static_add_ucode_port_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_ucode_port_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ucode_port);
    data = (const dnx_data_port_static_add_ucode_port_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->interface);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->nof_lanes);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->interface_offset);
            break;
        case 3:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->core);
            break;
        case 4:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->tm_port);
            break;
        case 5:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->channel);
            break;
        case 6:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->is_stif);
            break;
        case 7:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->is_kbp);
            break;
        case 8:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->tdm_mode);
            break;
        case 9:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->num_priorities);
            break;
        case 10:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->base_q_pair);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_speed_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_speed_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_speed);
    data = (const dnx_data_port_static_add_speed_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->val);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_ext_stat_speed_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_ext_stat_speed_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ext_stat_speed);
    data = (const dnx_data_port_static_add_ext_stat_speed_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->speed);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->nof_lanes);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_eth_padding_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_eth_padding_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_eth_padding);
    data = (const dnx_data_port_static_add_eth_padding_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pad_size);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_link_training_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_link_training_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_link_training);
    data = (const dnx_data_port_static_add_link_training_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->val);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_ext_stat_link_training_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_ext_stat_link_training_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ext_stat_link_training);
    data = (const dnx_data_port_static_add_ext_stat_link_training_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->val);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_fec_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_fec_type_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_fec_type);
    data = (const dnx_data_port_static_add_fec_type_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->val);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_serdes_lane_config_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_serdes_lane_config_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_serdes_lane_config);
    data = (const dnx_data_port_static_add_serdes_lane_config_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->dfe);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->media_type);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->unreliable_los);
            break;
        case 3:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->cl72_auto_polarity_enable);
            break;
        case 4:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->cl72_restart_timeout_enable);
            break;
        case 5:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->channel_mode);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_serdes_tx_taps_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_serdes_tx_taps_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_serdes_tx_taps);
    data = (const dnx_data_port_static_add_serdes_tx_taps_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pre);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->main);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->post);
            break;
        case 3:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->pre2);
            break;
        case 4:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->post2);
            break;
        case 5:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->post3);
            break;
        case 6:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->tx_tap_mode);
            break;
        case 7:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->signalling_mode);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_tx_pam4_precoder_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_tx_pam4_precoder_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_tx_pam4_precoder);
    data = (const dnx_data_port_static_add_tx_pam4_precoder_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->val);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_lp_tx_precoder_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_lp_tx_precoder_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_lp_tx_precoder);
    data = (const dnx_data_port_static_add_lp_tx_precoder_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->val);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_fabric_quad_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_fabric_quad_info_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_fabric_quad_info);
    data = (const dnx_data_port_static_add_fabric_quad_info_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->quad_enable);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_header_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_header_type_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_header_type);
    data = (const dnx_data_port_static_add_header_type_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->header_type_in);
            break;
        case 1:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->header_type_out);
            break;
        case 2:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->header_type);
            break;
    }

    SHR_FUNC_EXIT;
}

shr_error_e
dnx_data_port_static_add_erp_exist_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index)
{
    dnxc_data_table_t *table;
    const dnx_data_port_static_add_erp_exist_t *data;
    SHR_FUNC_INIT_VARS(unit);

    /* Get table */
    table = dnxc_data_mgmt_table_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_erp_exist);
    data = (const dnx_data_port_static_add_erp_exist_t *) dnxc_data_mgmt_table_data_diag_get(unit, table, key0, 0);
    switch (value_index)
    {
        case 0:
            sal_snprintf(buffer, DNXC_DATA_MGMT_MAX_TABLE_VALUE_LENGTH, "%d", data->exist);
            break;
    }

    SHR_FUNC_EXIT;
}

/* Table Info Get */
const dnxc_data_table_info_t *
dnx_data_port_static_add_ucode_port_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ucode_port);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_speed_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_speed);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_ext_stat_speed_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ext_stat_speed);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_eth_padding_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_eth_padding);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_link_training_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_link_training);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_ext_stat_link_training_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_ext_stat_link_training);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_fec_type_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_fec_type);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_serdes_lane_config_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_serdes_lane_config);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_serdes_tx_taps_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_serdes_tx_taps);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_tx_pam4_precoder_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_tx_pam4_precoder);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_lp_tx_precoder_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_lp_tx_precoder);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_fabric_quad_info_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_fabric_quad_info);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_header_type_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_header_type);

}

const dnxc_data_table_info_t *
dnx_data_port_static_add_erp_exist_info_get(
    int unit)
{

    /* Return table info */
    return dnxc_data_mgmt_table_info_get(unit, dnx_data_module_port, dnx_data_port_submodule_static_add, dnx_data_port_static_add_table_erp_exist);

}

/*
 * }
 */

/*
 * SUBMODULE - GENERAL:
 * {
 */
/*
 * general init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_port_general_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "general";
    submodule_data->doc = "general ports data";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_port_general_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data port general features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_port_general_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data port general defines");

    submodule_data->defines[dnx_data_port_general_define_nof_tm_ports].name = "nof_tm_ports";
    submodule_data->defines[dnx_data_port_general_define_nof_tm_ports].doc = "nof tm ports per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_nof_tm_ports].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_erp_tm_port].name = "erp_tm_port";
    submodule_data->defines[dnx_data_port_general_define_erp_tm_port].doc = "tm port reserved for ERP";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_erp_tm_port].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_reserved_tm_port].name = "reserved_tm_port";
    submodule_data->defines[dnx_data_port_general_define_reserved_tm_port].doc = "tm port reserved for redirection of returned credits in LAG SCH";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_reserved_tm_port].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_nof_pp_ports].name = "nof_pp_ports";
    submodule_data->defines[dnx_data_port_general_define_nof_pp_ports].doc = "nof pp ports per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_nof_pp_ports].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_nof_pms].name = "nof_pms";
    submodule_data->defines[dnx_data_port_general_define_nof_pms].doc = "Number of port macros overall in the system";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_nof_pms].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_max_nof_channels].name = "max_nof_channels";
    submodule_data->defines[dnx_data_port_general_define_max_nof_channels].doc = "max nof channel in an interface";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_max_nof_channels].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_fabric_phys_offset].name = "fabric_phys_offset";
    submodule_data->defines[dnx_data_port_general_define_fabric_phys_offset].doc = "Offset for physical fabric ports";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_fabric_phys_offset].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_tm_port_size].name = "tm_port_size";
    submodule_data->defines[dnx_data_port_general_define_tm_port_size].doc = "define the size of the tm port (in bits)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_tm_port_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_pp_port_size].name = "pp_port_size";
    submodule_data->defines[dnx_data_port_general_define_pp_port_size].doc = "define the size of the pp port (in bits)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_pp_port_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_pp_dsp_size].name = "pp_dsp_size";
    submodule_data->defines[dnx_data_port_general_define_pp_dsp_size].doc = "define the size of the pp dsp (in bits)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_pp_dsp_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_vlan_domain_size].name = "vlan_domain_size";
    submodule_data->defines[dnx_data_port_general_define_vlan_domain_size].doc = "define the size of the vlan domain (in bits)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_vlan_domain_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_nof_vlan_membership_if].name = "nof_vlan_membership_if";
    submodule_data->defines[dnx_data_port_general_define_nof_vlan_membership_if].doc = "number of vlan_membership_if";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_nof_vlan_membership_if].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_ffc_instruction_size].name = "ffc_instruction_size";
    submodule_data->defines[dnx_data_port_general_define_ffc_instruction_size].doc = "define the size of the ffc instruction (in bits)";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_ffc_instruction_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_port_general_define_fabric_port_base].name = "fabric_port_base";
    submodule_data->defines[dnx_data_port_general_define_fabric_port_base].doc = "first fabric logical port";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_fabric_port_base].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_port_general_define_dynamic_port_enable].name = "dynamic_port_enable";
    submodule_data->defines[dnx_data_port_general_define_dynamic_port_enable].doc = "dynamic port";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_general_define_dynamic_port_enable].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_port_general_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data port general tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * general features
 */
int
dnx_data_port_general_feature_get(
    int unit,
    dnx_data_port_general_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, feature);
}

/*
 * general defines
 */
uint32
dnx_data_port_general_nof_tm_ports_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_nof_tm_ports);
}

uint32
dnx_data_port_general_erp_tm_port_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_erp_tm_port);
}

uint32
dnx_data_port_general_reserved_tm_port_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_reserved_tm_port);
}

uint32
dnx_data_port_general_nof_pp_ports_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_nof_pp_ports);
}

uint32
dnx_data_port_general_nof_pms_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_nof_pms);
}

uint32
dnx_data_port_general_max_nof_channels_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_max_nof_channels);
}

uint32
dnx_data_port_general_fabric_phys_offset_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_fabric_phys_offset);
}

uint32
dnx_data_port_general_tm_port_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_tm_port_size);
}

uint32
dnx_data_port_general_pp_port_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_pp_port_size);
}

uint32
dnx_data_port_general_pp_dsp_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_pp_dsp_size);
}

uint32
dnx_data_port_general_vlan_domain_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_vlan_domain_size);
}

uint32
dnx_data_port_general_nof_vlan_membership_if_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_nof_vlan_membership_if);
}

uint32
dnx_data_port_general_ffc_instruction_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_ffc_instruction_size);
}

uint32
dnx_data_port_general_fabric_port_base_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_fabric_port_base);
}

uint32
dnx_data_port_general_dynamic_port_enable_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_general, dnx_data_port_general_define_dynamic_port_enable);
}

/*
 * general tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - EGRESS:
 * {
 */
/*
 * egress init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_port_egress_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "egress";
    submodule_data->doc = "egress related data";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_port_egress_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data port egress features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_port_egress_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data port egress defines");

    submodule_data->defines[dnx_data_port_egress_define_nof_ifs].name = "nof_ifs";
    submodule_data->defines[dnx_data_port_egress_define_nof_ifs].doc = "nof egress intrfaces per core";
    /* Set data type flag */
    submodule_data->defines[dnx_data_port_egress_define_nof_ifs].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_port_egress_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data port egress tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * egress features
 */
int
dnx_data_port_egress_feature_get(
    int unit,
    dnx_data_port_egress_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_egress, feature);
}

/*
 * egress defines
 */
uint32
dnx_data_port_egress_nof_ifs_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_port, dnx_data_port_submodule_egress, dnx_data_port_egress_define_nof_ifs);
}

/*
 * egress tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

shr_error_e
dnx_data_port_init(
    int unit,
    dnxc_data_module_t *module_data)
{
    SHR_FUNC_INIT_VARS(unit);

    /* Data Struct Init */
    module_data->name = "port";
    module_data->nof_submodules = _dnx_data_port_submodule_nof;
    DNXC_DATA_ALLOC(module_data->submodules, dnxc_data_submodule_t, module_data->nof_submodules, "_dnxc_data port submodules");

    /*
     * Init Submodule data
     */
    SHR_IF_ERR_EXIT(dnx_data_port_static_add_init(unit, &module_data->submodules[dnx_data_port_submodule_static_add]));
    SHR_IF_ERR_EXIT(dnx_data_port_general_init(unit, &module_data->submodules[dnx_data_port_submodule_general]));
    SHR_IF_ERR_EXIT(dnx_data_port_egress_init(unit, &module_data->submodules[dnx_data_port_submodule_egress]));
    /*
     * Attach device module
     */
    if (dnxc_data_mgmt_is_jer2_a0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_port_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_jer2_b0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_port_attach(unit));
    }

exit:
    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
