/** \file dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint.c
 * Logical DB enums \n 
 * DO NOT EDIT THIS FILE!\n 
 * This file is auto-generated.\n 
 * Edits to this file will be lost when it is regenerated.\n 
 * \n 
 */
/*
 * $Id: $
 $Copyright: (c) 2018 Broadcom.
 Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 */
#ifdef BSL_LOG_MODULE
#  error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SOCDNX_DBALDNX

#include <src/soc/dnx/dbal/dbal_internal.h>

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_icc_map_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_ICC_MAP" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ICC_MAP_INDEX" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, "14" /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ICC_DATA" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: ICC_DATA  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "0" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "2" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_2f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "3" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_3f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "4" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_4f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "5" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_5f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "6" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_6f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "7" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_7f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "8" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_8f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "9" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_9f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "10" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_10f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "11" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_11f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "12" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_12f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "13" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_13f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ICC_DATA" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "ICC_MAP_INDEX" /* field*/, "14" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_ICC_MAP_REG_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ICC_MAP_IDX_14f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_umc_table_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_UMC_TABLE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MEP_INDEX" /* name*/, NULL /* Valid*/, "13" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "OAMP_MEP_DB_INDEX" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "UMC" /* name*/, NULL /* Valid*/, "40" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_packed_field(unit, access_params, "0" /* field size*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_UMC_TABLEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = UMCf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_mep_profile_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_MEP_PROFILE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MEP_PROFILE_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "MEP_PROFILE" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DMM_RATE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "CCM_INTERVAL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LMM_RATE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "CCM_INTERVAL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_DUAL_ENDED_LM" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_SLM" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_REPORT_MODE_LM" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_REPORT_MODE_DM" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "RDI_GEN_METHOD" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DMM_OFFSET" /* name*/, NULL /* Valid*/, "8" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DMR_OFFSET" /* name*/, NULL /* Valid*/, "8" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LMM_OFFSET" /* name*/, NULL /* Valid*/, "8" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LMR_OFFSET" /* name*/, NULL /* Valid*/, "8" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OPCODE_BIT_MAP" /* name*/, NULL /* Valid*/, "8" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OPCODE_X_RATE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, "8" /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "OPCODE_RATE" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DM_MEASUREMENT_TYPE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "DM_ONE_WAY_TIMESTAMP_ENCODING" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DISABLE_MAID_CHECK" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DISABLE_SRC_IP_CHECK" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DISABLE_MDL_CHECK" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DISABLE_YOUR_DISCR_CHECK" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CCM_COUNT" /* name*/, NULL /* Valid*/, "19" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DMM_COUNT" /* name*/, NULL /* Valid*/, "19" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LMM_COUNT" /* name*/, NULL /* Valid*/, "19" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OPCODE_X_COUNT" /* name*/, NULL /* Valid*/, "19" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, "8" /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LMM_DA_MSB_PROFILE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "TX_COUNTER_ENABLE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "RX_COUNTER_ENABLE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OPCODE_MSK" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MEP_ID_SHIFT" /* name*/, NULL /* Valid*/, "2" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: DMM_RATE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DMM_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DMM_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LMM_RATE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LMM_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_DUAL_ENDED_LM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_DUAL_ENDED_LM" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PIGGYBACK_LMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_SLM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_SLM" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SLM_LMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_REPORT_MODE_LM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_REPORT_MODE_LM" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = REPORT_MODE_LMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_REPORT_MODE_DM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_REPORT_MODE_DM" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = REPORT_MODE_DMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: RDI_GEN_METHOD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "RDI_GEN_METHOD" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = RDI_GEN_METHODf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DMM_OFFSET  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DMM_OFFSET" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DMM_OFFSETf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DMR_OFFSET  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DMR_OFFSET" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DMR_OFFSETf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LMM_OFFSET  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LMM_OFFSET" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_OFFSETf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LMR_OFFSET  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LMR_OFFSET" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMR_OFFSETf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OPCODE_BIT_MAP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_BIT_MAP" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_BMAPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OPCODE_X_RATE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 0;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_0_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 1;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_1_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 2;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_2_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 3;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_3_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 4;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_4_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 5;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_5_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 6;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_6_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 7;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_RATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_7_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DM_MEASUREMENT_TYPE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DM_MEASUREMENT_TYPE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DMM_MEASURE_ONE_WAYf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DISABLE_MAID_CHECK  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DISABLE_MAID_CHECK" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MAID_CHECK_DISf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DISABLE_SRC_IP_CHECK  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DISABLE_SRC_IP_CHECK" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SRC_IP_CHECK_DISf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DISABLE_MDL_CHECK  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DISABLE_MDL_CHECK" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MDL_CHECK_DISf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DISABLE_YOUR_DISCR_CHECK  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DISABLE_YOUR_DISCR_CHECK" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = YOUR_DISC_CHECK_DISf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CCM_COUNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CCM_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CCM_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DMM_COUNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DMM_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DMM_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LMM_COUNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LMM_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OPCODE_X_COUNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 0;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OP_0_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 1;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OP_1_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 2;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OP_2_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 3;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OP_3_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 4;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OP_4_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 5;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OP_5_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 6;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OP_6_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                instance_index = 7;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_X_COUNT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_SCAN_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OP_7_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LMM_DA_MSB_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LMM_DA_MSB_PROFILE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TX_COUNTER_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "TX_COUNTER_ENABLE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = TX_COUNTER_ENABLEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: RX_COUNTER_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "RX_COUNTER_ENABLE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = RX_COUNTER_ENABLEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OPCODE_MSK  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OPCODE_MSK" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OPCODE_MSKf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MEP_ID_SHIFT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MEP_ID_SHIFT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_MEP_PROFILEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MEP_ID_SHIFTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_mep_da_msb_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_MEP_DA_MSB" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LMM_DA_MSB_PROFILE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DA_MSB" /* name*/, NULL /* Valid*/, "24" /* Size*/, "24" /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "L2_MAC" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: DA_MSB  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DA_MSB" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "LMM_DA_MSB_PROFILE" /* field*/, "0" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_OUIr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DA_MSB" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "LMM_DA_MSB_PROFILE" /* field*/, "1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_OUIr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DA_MSB" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "LMM_DA_MSB_PROFILE" /* field*/, "2" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_OUIr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_2f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DA_MSB" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "LMM_DA_MSB_PROFILE" /* field*/, "3" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_OUIr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_3f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DA_MSB" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "LMM_DA_MSB_PROFILE" /* field*/, "4" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_OUIr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_4f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DA_MSB" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "LMM_DA_MSB_PROFILE" /* field*/, "5" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_OUIr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_5f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DA_MSB" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "LMM_DA_MSB_PROFILE" /* field*/, "6" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_OUIr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_6f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DA_MSB" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "LMM_DA_MSB_PROFILE" /* field*/, "7" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_OUIr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_OUI_7f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_mep_da_lsb_table_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "OAMP_MEP_DA_LSB_TABLE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "OAM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LMM_DA_LSB_PROFILE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DA_LSB" /* name*/, NULL /* Valid*/, "24" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "L2_MAC" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_packed_field(unit, access_params, "0" /* field size*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = OAMP_LMM_DA_NIC_TABLEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LMM_DA_NICf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_init(
int unit,
table_db_struct_t* cur_table_param,
dbal_logical_table_t * table_info)
{
    SHR_FUNC_INIT_VARS(unit);
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_icc_map_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_umc_table_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_mep_profile_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_mep_da_msb_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_oam_hl_pp_oam_oamp_endpoint_oamp_mep_da_lsb_table_init(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}
