/** \file jer2_a0_data_dev_init.c
 * 
 * DEVICE DATA - DEV_INIT
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_INIT
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_dev_init.h>
#include <bcm_int/dnx/spb/spb.h>
#include <bcm_int/dnx/init/init_custom_funcs.h>
#include <shared/utilex/utilex_time_analyzer.h>
/*
 * }
 */

/*
 * EXTERN FUNCTIONS:
 * {
 */
/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: time
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set numeric analyze
 * numeric info:
 * whether to analyze init time
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_time_analyze_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_time;
    int define_index = dnx_data_dev_init_time_define_analyze;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_TIME_ANALYZER_MODE_OFF;

    /* Set value */
    define->data = UTILEX_TIME_ANALYZER_MODE_OFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_CUSTOM_FEATURE;
    define->property.doc = 
        "\n"
        "1 to enable time analyze module\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_direct_map;
    define->property.method_str = "suffix_direct_map";
    define->property.suffix = "time_analyze";
    define->property.nof_mapping = 3;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "OFF";
    define->property.mapping[0].val = UTILEX_TIME_ANALYZER_MODE_OFF;
    define->property.mapping[0].is_default = 1 ;
    define->property.mapping[1].name = "PER_STEP";
    define->property.mapping[1].val = UTILEX_TIME_ANALYZER_MODE_PER_INIT_STEP;
    define->property.mapping[2].name = "GLOBAL";
    define->property.mapping[2].val = UTILEX_TIME_ANALYZER_MODE_GLOBAL;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);
    define->flags |= (DNXC_DATA_F_PROPERTY_INTERNAL);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: mem
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set numeric force_zeros
 * numeric info:
 * if true will force zeroing memories in pcid and emulation
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_mem_force_zeros_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_mem;
    int define_index = dnx_data_dev_init_mem_define_force_zeros;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_CUSTOM_FEATURE;
    define->property.doc = 
        "\n"
        "custom_feature_init_tbls_to_zero='0' or '1'\n"
        "if 1 will force zeroing memories in pcid and emulation.\n"
        "Default - '0'\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_enable;
    define->property.method_str = "suffix_enable";
    define->property.suffix = "init_tbls_to_zero";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric defaults_verify
 * numeric info:
 * if true will test memory defaults are as exepected
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_mem_defaults_verify_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_mem;
    int define_index = dnx_data_dev_init_mem_define_defaults_verify;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_CUSTOM_FEATURE;
    define->property.doc = 
        "\n"
        "custom_feature_mem_defaults_verify='0' or '1'\n"
        "if 1 will verify all memories initilized during init sequence\n"
        "Default - '0'\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_enable;
    define->property.method_str = "suffix_enable";
    define->property.suffix = "mem_defaults_verify";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table default
 * Module - 'dev_init', Submodule - 'mem', table - 'default'
 * default values for memories, any mem that is not mentioned will be set to zero
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_mem_default_set(
    int unit)
{
    int index_index;
    dnx_data_dev_init_mem_default_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_mem;
    int table_index = dnx_data_dev_init_mem_table_default;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 53;
    table->info_get.key_size[0] = 53;

    /* Info - default values */
    table->values[0].default_val = "INVALIDr";
    table->values[1].default_val = "dnx_init_mem_default_mode_zero";
    table->values[2].default_val = "NULL";
    table->values[3].default_val = "INVALIDf";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_dev_init_mem_default_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_dev_init_mem_table_default");

    /* Store Default Values */
    default_data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->mem = INVALIDr;
    default_data->mode = dnx_init_mem_default_mode_zero;
    default_data->default_get_cb = NULL;
    default_data->field = INVALIDf;
    /* Set Default Values */
    for (index_index = 0; index_index < table->keys[0].size; index_index++)
    {
        data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->mem = IPS_SPMm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->mem = MTM_EGR_BITMAP_MAPPING_TABLE_Am;
    data->mode = dnx_init_mem_default_mode_index;
    data->field = PP_DSPf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->mem = MTM_EGR_BITMAP_MAPPING_TABLE_Bm;
    data->mode = dnx_init_mem_default_mode_index;
    data->field = PP_DSPf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->mem = ERPP_PRP_PP_DSP_PTR_TABLEm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_erpp_prp_pp_dsp_ptr_table_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->mem = ERPP_TM_PP_DSP_PTR_TABLEm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_erpp_tm_pp_dsp_ptr_table_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    data->mem = ETPPA_DSP_DATA_TABLEm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_etppa_dsp_data_table_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->mem = IPS_FMS_BYPASSm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = FMS_BYPASS_BMPf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->mem = CGM_REP_CMD_FIFO_OCCUPANCY_RJCT_THm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->mem = SPB_CONTEXT_MRUm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_spb_context_mru_default_get_f;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    data->mem = EPNI_ALIGNER_MIRR_QP_TO_CHANNEL_MAPm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = CHANNELf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
    data->mem = SCH_FLOW_TO_FIP_MAPPING_FFMm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_sch_flow_to_fip_mapping_default_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
    data->mem = ERPP_CFG_ENABLE_FILTER_PER_PORT_TABLEm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = CFG_SAME_INTERFACE_PER_PORTf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 12, 0);
    data->mem = ETPPB_VID_MIRROR_PROFILE_TABLEm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = OUT_PORT_MIRROR_PROFILEf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 13, 0);
    data->mem = SCH_SHAPER_DESCRIPTOR_MEMORY_STATIC_SHDSm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_sch_shaper_descr_default_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 14, 0);
    data->mem = SCH_FLOW_DESCRIPTOR_MEMORY_STATIC_FDMSm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_sch_flow_descr_default_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 15, 0);
    data->mem = IPT_PCP_CFGm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_fabric_pcp_default_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 16, 0);
    data->mem = SCH_SLOW_SCALE_A_SSAm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = MAX_BUCKETf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 17, 0);
    data->mem = SCH_SLOW_SCALE_B_SSBm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = MAX_BUCKETf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 18, 0);
    data->mem = IPPE_PINFO_LLRm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = RECYCLE_PROFILE_ENABLEf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 19, 0);
    data->mem = MTM_MCDBm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 20, 0);
    data->mem = SCH_CIR_SHAPER_CALENDAR_CSCm;
    data->mode = dnx_init_mem_default_mode_index;
    data->field = PG_NUMf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 21, 0);
    data->mem = SCH_PIR_SHAPER_CALENDAR_PSCm;
    data->mode = dnx_init_mem_default_mode_index;
    data->field = HR_NUMf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 22, 0);
    data->mem = SCH_PORT_SCHEDULER_WEIGHTS_PSWm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_sch_port_schduler_weights_psw_default_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 23, 0);
    data->mem = IPPD_DESTINATION_STATUSm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 24, 0);
    data->mem = IPS_QSPMm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = SYSTEM_PORTf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 25, 0);
    data->mem = CGM_IPP_MAPm;
    data->mode = dnx_init_mem_default_mode_all_ones;
    data->field = NIF_PORTf;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 26, 0);
    data->mem = EPS_IFC_CFGm;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 27, 0);
    data->mem = EPS_IFC_CFG_2m;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 28, 0);
    data->mem = FQP_PER_IFC_CFGm;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 29, 0);
    data->mem = IPT_PER_DTQ_GIPT_CFGm;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 30, 0);
    data->mem = IPT_PER_GIPT_SHAPER_CFGm;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 31, 0);
    data->mem = IPT_PER_SHAPER_CFGm;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 32, 0);
    data->mem = IPT_SHAPER_FMC_CFGm;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 33, 0);
    data->mem = OCB_FBM_BANK_MEMm;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 34, 0);
    data->mem = PQP_FDMm;
    data->mode = dnx_init_mem_default_mode_zero;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 35, 0);
    data->mem = ERPP_EPMFCS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 36, 0);
    data->mem = IPPA_VTDCS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 37, 0);
    data->mem = IPPA_VTECS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 38, 0);
    data->mem = IPPB_FLPACS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 39, 0);
    data->mem = IPPB_FLPBCS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 40, 0);
    data->mem = IPPC_PMFACSA_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 41, 0);
    data->mem = IPPC_PMFACSB_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 42, 0);
    data->mem = IPPD_PMFBCS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 43, 0);
    data->mem = IPPE_LLRCS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 44, 0);
    data->mem = IPPE_PRTCAM_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 45, 0);
    data->mem = IPPF_VTACS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 46, 0);
    data->mem = IPPF_VTBCS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 47, 0);
    data->mem = IPPF_VTCCS_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 48, 0);
    data->mem = TCAM_TCAM_BANKm;
    data->mode = dnx_init_mem_default_mode_none;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 49, 0);
    data->mem = IPPC_FES_2ND_INSTRUCTIONm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_ippc_fes_2nd_instruction_default_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 50, 0);
    data->mem = IPPD_FES_2ND_INSTRUCTIONm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_ippd_fes_2nd_instruction_default_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 51, 0);
    data->mem = ERPP_FES_2ND_INSTRUCTIONm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_erpp_fes_2nd_instruction_default_get;
    data = (dnx_data_dev_init_mem_default_t *) dnxc_data_mgmt_table_data_get(unit, table, 52, 0);
    data->mem = ETPPA_PRP_FES_PROGRAM_TABLEm;
    data->mode = dnx_init_mem_default_mode_custom;
    data->default_get_cb = dnx_init_custom_etppa_prp_fes_program_table_default_get;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: properties
 */

/*
 * Features
 */
/*
 * Defines
 */
/*
 * Tables
 */
/**
 * \brief device level function which set values for table unsupported
 * Module - 'dev_init', Submodule - 'properties', table - 'unsupported'
 * unsupported soc properties
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_properties_unsupported_set(
    int unit)
{
    int index_index;
    dnx_data_dev_init_properties_unsupported_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_properties;
    int table_index = dnx_data_dev_init_properties_table_unsupported;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 201;
    table->info_get.key_size[0] = 201;

    /* Info - default values */
    table->values[0].default_val = "NULL";
    table->values[1].default_val = "NULL";
    table->values[2].default_val = "-1";
    table->values[3].default_val = "0";
    table->values[4].default_val = "NULL";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_dev_init_properties_unsupported_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_dev_init_properties_table_unsupported");

    /* Store Default Values */
    default_data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->property = NULL;
    default_data->suffix = NULL;
    default_data->num_max = -1;
    default_data->per_port = 0;
    default_data->err_msg = NULL;
    /* Set Default Values */
    for (index_index = 0; index_index < table->keys[0].size; index_index++)
    {
        data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->property = "backplane_serdes_encoding";
    data->per_port = 1;
    data->err_msg = "Setting encoding supported by API bcm_port_resource_set()";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->property = "repeater_link_enable";
    data->num_max = 192;
    data->err_msg = "repeater is not supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->property = "system_is_vcs_128_in_system";
    data->err_msg = "cell format VSC128 is not supported. VSC256 will be set automatically";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->property = "hqos_mapping_enable";
    data->err_msg = "Mapping of many system ports to single modport is always allowed. No need to set this soc property.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->property = "flow_mapping_queue_base";
    data->err_msg = "Feature not supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    data->property = "system_ref_core_clock";
    data->err_msg = "system_ref_core_clock must be with '_khz' suffix";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->property = "fap_device_mode";
    data->err_msg = "The device supports only PP mode. TM mode is not supported. TDM functionality is done by other APIs (see bcm_port_add)";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->property = "custom_feature_l3_mc_use_tcam";
    data->err_msg = "L3 multicast flows are changed. There are no different options for L3 multicast forwarding. See Arch L3 section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->property = "custom_feature_l3_ipv6_uc_use_tcam";
    data->err_msg = "L3 multicast flows are changed. There are no different options for L3 multicast forwarding. See Arch L3 section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    data->property = "bcm886xx_ipv6_ext_hdr_enable";
    data->err_msg = "Several options of IPv6 Extension headers are supported by default. There is only one mode in the device.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
    data->property = "custom_feature_udp_parse_disable";
    data->err_msg = "UDP parse is enabled by default. There is only one mode in the device.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
    data->property = "sa_auth_enabled";
    data->err_msg = "SA Authentication feature is no longer done by the LLR block. Instead ACL capabilities are available. See L2 backward compatible section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 12, 0);
    data->property = "logical_port_l2_bridge";
    data->err_msg = "The functionality is no longer set by init-sequence using soc-property.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 13, 0);
    data->property = "logical_port_drop";
    data->err_msg = "The functionality is no longer set by init-sequence using soc-property.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 14, 0);
    data->property = "evb_enable";
    data->err_msg = "EVB functionality is currently not supported.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 15, 0);
    data->property = "vlan_translation_match_ipv4";
    data->err_msg = "Feature not supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 16, 0);
    data->property = "bcm886xx_next_hop_mac_extension_enable";
    data->err_msg = "Global mode is no longer required.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 17, 0);
    data->property = "bcm886xx_vlan_translate_mode";
    data->err_msg = "The device supports only advanced vlan translation. Basic vlan translation is not supported anymore. See L2 backward compatible section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 18, 0);
    data->property = "bcm886xx_mpls_termination_database_mode";
    data->err_msg = "MPLS termination flows are changed. There are no different options for MPLS termination. See Arch MPLS section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 19, 0);
    data->property = "mpls_termination_label_index_enable";
    data->err_msg = "MPLS termination flows are changed. There are no different options for MPLS termination. See Arch MPLS section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 20, 0);
    data->property = "fast_reroute_labels_enable";
    data->err_msg = "MPLS termination flows are changed. There are no different options for MPLS termination. See Arch MPLS section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 21, 0);
    data->property = "mpls_context_specific_label_enable";
    data->err_msg = "The functionality is no longer supported by a global mode.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 22, 0);
    data->property = "mpls_context";
    data->err_msg = "he functionality is no longer supported by a global mode.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 23, 0);
    data->property = "mpls_tp_mymac_reserved_address";
    data->err_msg = "Feature not supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 24, 0);
    data->property = "bcm886xx_qos_l3_l2_marking";
    data->err_msg = "QOS remarking is now supported differently. See Arch QOS section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 25, 0);
    data->property = "custom_feature_ipmc_set_entry_type_by_rif";
    data->err_msg = "Feature not supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 26, 0);
    data->property = "bcm886xx_l3_ingress_urpf_enable";
    data->err_msg = "Functionality is supported per LIF(RIF) only.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 27, 0);
    data->property = "bcm886xx_mpls_termination_key_mode";
    data->err_msg = "MPLS termination flows are changed. There are no different options for MPLS termination. See Arch MPLS section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 28, 0);
    data->property = "bcm886xx_logical_interface_bridge_filter_enable";
    data->err_msg = "The functionality per LIF is now changed and enabled by default with no need for global mode indication.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 29, 0);
    data->property = "split_horizon_forwarding_groups_mode";
    data->err_msg = "The functionality per LIF is now changed and enabled by default with no need for global mode indication.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 30, 0);
    data->property = "oam_enable";
    data->err_msg = "Functionality is enabled by default";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 31, 0);
    data->property = "bfd_enable";
    data->err_msg = "Functionality is enabled by default";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 32, 0);
    data->property = "pwe_termination_port_mode_enable";
    data->err_msg = "Feature not supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 33, 0);
    data->property = "mpls_entropy_label_indicator_enable";
    data->err_msg = "MPLS termination flows are changed. There are no different options for MPLS termination. See Arch MPLS section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 34, 0);
    data->property = "bcm886xx_ipv6_tunnel_enable";
    data->err_msg = "IPv6 tunnel flows are changed. There are no different options for IPv6 tunnels. See Arch IPv6 Tunnel section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 35, 0);
    data->property = "number_of_inrif_mac_termination_combinations";
    data->err_msg = "The functionality per In-LIF(In-RIF) profile has been changed. Global mode is no longer required.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 36, 0);
    data->property = "ipmc_l3mcastl2_mode";
    data->err_msg = "IPMC flows are changed. There are no different options for it. See Arch IPMC section.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 37, 0);
    data->property = "ext_ram_t_32aw";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 38, 0);
    data->property = "ext_ram_t_al";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 39, 0);
    data->property = "ext_ram_t_crc_alert";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 40, 0);
    data->property = "ext_ram_t_crc_rd_latency";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 41, 0);
    data->property = "ext_ram_t_crc_wr_latency";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 42, 0);
    data->property = "ext_ram_t_ras_enable";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 43, 0);
    data->property = "ext_ram_t_ref";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 44, 0);
    data->property = "ext_ram_t_rfc";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 45, 0);
    data->property = "ext_ram_t_rrd";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 46, 0);
    data->property = "ext_ram_t_rst";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 47, 0);
    data->property = "ext_ram_t_rtp";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 48, 0);
    data->property = "ext_ram_t_zqcs";
    data->err_msg = "timing parameter no longer relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 49, 0);
    data->property = "ext_ram_abi";
    data->err_msg = "address bus inversion is not relevant for jer2, drams address lines are ordered internally";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 50, 0);
    data->property = "ext_ram_addr_bank_swap";
    data->err_msg = "address banks swaps are done internally";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 51, 0);
    data->property = "ext_ram_present";
    data->err_msg = "ext_ram_present was replaced by ext_ram_enabled_bitmap to better represent which drams are available in the system";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 52, 0);
    data->property = "ext_ram_auto_tune";
    data->err_msg = "ext_ram_auto_tune was replaced by dram_phy_tune_mode_on_init to better convey the meaning and avoid confusion between soc property and shell command";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 53, 0);
    data->property = "ext_ram_dq_swap";
    data->err_msg = "data bits swaps are done internally";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 54, 0);
    data->property = "ext_ram_dbuff_mmc_optimized_distribution_enable";
    data->err_msg = "this is a legacy soc property that is relevant only for a very specific scenario which doesn't occur in jer 2";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 55, 0);
    data->property = "ext_ram_total_size";
    data->err_msg = "total dram size is configured internally";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 56, 0);
    data->property = "ext_ram_type";
    data->err_msg = "only one type of dram is supported and configured internally";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 57, 0);
    data->property = "ext_ram_gear_down_mode";
    data->err_msg = "gear down mode not supported in jer 2";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 58, 0);
    data->property = "slow_max_rate_level";
    data->err_msg = "Not supported. No tradeoffs between max slow rate and max burst";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 59, 0);
    data->property = "l3_multiple_mymac_termination_mode";
    data->err_msg = "Multiple mymac termination mode is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 60, 0);
    data->property = "bcm886xx_ingress_protection_coupled_mode";
    data->err_msg = "Ingress protection coupled mode no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 61, 0);
    data->property = "bcm_stat_flags";
    data->err_msg = "bcm_stat_flags is not in use in DNX. Please go to AE for further information. Please set this soc property to 0, or delete it from config file";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 62, 0);
    data->property = "soc_counter_control_level";
    data->err_msg = "soc_counter_control_level is not in use in DNX. Please go to AE for further information. Please delete it from config file";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 63, 0);
    data->property = "ilkn_counters_mode";
    data->err_msg = "ilkn_counters_mode is not in use in DNX. only counters per channel are supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 64, 0);
    data->property = "voq_mapping_mode";
    data->err_msg = "Only INDIRECT mode is supported, so voq_mapping_mode is not relevant";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 65, 0);
    data->property = "l3_multiple_mymac_termination_enable";
    data->err_msg = "l3_multiple_mymac_termination_enable is not supported in JR2";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 66, 0);
    data->property = "dport_map_enable";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 67, 0);
    data->property = "ilkn_num_lanes";
    data->err_msg = "ilkn_num_lanes is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 68, 0);
    data->property = "ilkn_invalid_lane_id";
    data->err_msg = "Ilkn_invalid_lane_id is not in use in DNX.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 69, 0);
    data->property = "ilkn_is_burst_interleaving";
    data->err_msg = "ilkn_is_burst_interleaving is not in use currently in DNX.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 70, 0);
    data->property = "ilkn_interface_status_ignore";
    data->err_msg = "ilkn_interface_status_ignore is not in use in DNX.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 71, 0);
    data->property = "ilkn_interface_status_oob_ignore";
    data->err_msg = "ilkn_interface_status_ignore is not in use in DNX.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 72, 0);
    data->property = "ilkn_retransmit_buffer_size";
    data->err_msg = "ilkn_retransmit_buffer_size is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 73, 0);
    data->property = "ilkn_retransmit_calendar_mode_rx";
    data->err_msg = "ilkn_retransmit_calendar_mode_rx is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 74, 0);
    data->property = "ilkn_retransmit_calendar_mode_tx";
    data->err_msg = "ilkn_retransmit_calendar_mode_tx is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 75, 0);
    data->property = "ilkn_retransmit_enable_rx";
    data->err_msg = "ilkn_retransmit_enable_rx is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 76, 0);
    data->property = "ilkn_retransmit_enable_tx";
    data->err_msg = "ilkn_retransmit_enable_tx is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 77, 0);
    data->property = "ilkn_retransmit_num_requests_resent";
    data->err_msg = "ilkn_retransmit_num_requests_resent is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 78, 0);
    data->property = "ilkn_retransmit_num_sn_repetitions_rx";
    data->err_msg = "ilkn_retransmit_num_sn_repetitions_rx is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 79, 0);
    data->property = "ilkn_retransmit_num_sn_repetitions_tx";
    data->err_msg = "ilkn_retransmit_num_sn_repetitions_tx is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 80, 0);
    data->property = "ilkn_retransmit_peer_tx_buffer_size";
    data->err_msg = "ilkn_retransmit_peer_tx_buffer_size is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 81, 0);
    data->property = "ilkn_retransmit_reserved_channel_id";
    data->err_msg = "ilkn_retransmit_reserved_channel_id is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 82, 0);
    data->property = "ilkn_retransmit_rx_discontinuity_event_timeout";
    data->err_msg = "ilkn_retransmit_rx_discontinuity_event_timeout is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 83, 0);
    data->property = "ilkn_retransmit_rx_ignore";
    data->err_msg = "ilkn_retransmit_rx_ignore is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 84, 0);
    data->property = "ilkn_retransmit_rx_reset_upon_watchdog_error_enable";
    data->err_msg = "ilkn_retransmit_rx_reset_upon_watchdog_error_enable is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 85, 0);
    data->property = "ilkn_retransmit_rx_reset_when_alligned_error_enable";
    data->err_msg = "ilkn_retransmit_rx_reset_when_alligned_error_enable is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 86, 0);
    data->property = "ilkn_retransmit_rx_reset_when_error_enable";
    data->err_msg = "ilkn_retransmit_rx_reset_when_error_enable is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 87, 0);
    data->property = "ilkn_retransmit_rx_reset_when_retry_error_enable";
    data->err_msg = "ilkn_retransmit_rx_reset_when_retry_error_enable is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 88, 0);
    data->property = "ilkn_retransmit_rx_reset_when_timout_error_enable";
    data->err_msg = "ilkn_retransmit_rx_reset_when_timout_error_enable is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 89, 0);
    data->property = "ilkn_retransmit_rx_reset_when_wrap_after_disc_error_enable";
    data->err_msg = "ilkn_retransmit_rx_reset_when_wrap_after_disc_error_enable is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 90, 0);
    data->property = "ilkn_retransmit_rx_reset_when_wrap_before_disc_error_enable";
    data->err_msg = "ilkn_retransmit_rx_reset_when_wrap_before_disc_error_enable is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 91, 0);
    data->property = "ilkn_retransmit_rx_timeout_sn";
    data->err_msg = "ilkn_retransmit_rx_timeout_sn is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 92, 0);
    data->property = "ilkn_retransmit_rx_timeout_words";
    data->err_msg = "ilkn_retransmit_rx_timeout_words is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 93, 0);
    data->property = "ilkn_retransmit_rx_watchdog";
    data->err_msg = "ilkn_retransmit_rx_watchdog is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 94, 0);
    data->property = "ilkn_retransmit_sn_bits";
    data->err_msg = "ilkn_retransmit_sn_bits is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 95, 0);
    data->property = "ilkn_retransmit_tx_ignore_requests_when_fifo_almost_empty";
    data->err_msg = "ilkn_retransmit_tx_ignore_requests_when_fifo_almost_empty is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 96, 0);
    data->property = "ilkn_retransmit_tx_wait_for_seq_num_change_enable";
    data->err_msg = "ilkn_retransmit_tx_wait_for_seq_num_change_enable is not in use in DNX. use ilkn_lanes";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 97, 0);
    data->property = "stat_if_enable_port";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 98, 0);
    data->property = "stat_if_tc_source";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 99, 0);
    data->property = "stat_if_reports_per_packet";
    data->err_msg = "this property is renamed to stat_if_pkt_size";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 100, 0);
    data->property = "stat_if_billing_ingress_queue_stamp_enable";
    data->err_msg = "this property is no longer supported, made via report format API";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 101, 0);
    data->property = "stat_if_billing_ingress_drop_reason_enable";
    data->err_msg = "this property is no longer supported, made via report format API";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 102, 0);
    data->property = "stat_if_billing_filter_reports";
    data->err_msg = "this property is no longer supported, made via source mapping API";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 103, 0);
    data->property = "stat_if_core_mode";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 104, 0);
    data->property = "stat_if_reports_per packet";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 105, 0);
    data->property = "stat_if_scrubber_uc_dram_buffer_th";
    data->num_max = 14;
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 106, 0);
    data->property = "stat_if_scrubber_buffer_descr_th";
    data->num_max = 14;
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 107, 0);
    data->property = "stat_if_etpp_counter_mode";
    data->num_max = 1;
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 108, 0);
    data->property = "stat_if_etpp_mode";
    data->num_max = 1;
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 109, 0);
    data->property = "stat_if_rate";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 110, 0);
    data->property = "counter_engine_source";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported - no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 111, 0);
    data->property = "counter_engine_statistics";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 112, 0);
    data->property = "counter_engine_format";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 113, 0);
    data->property = "counter_engine_map_enable";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 114, 0);
    data->property = "counter_engine_voq_min_queue";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 115, 0);
    data->property = "counter_engine_voq_queue_set_size";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 116, 0);
    data->property = "counter_engine_map_drop_green_offset";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 117, 0);
    data->property = "counter_engine_map_drop_yellow_offset";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 118, 0);
    data->property = "counter_engine_map_drop_red_offset";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 119, 0);
    data->property = "counter_engine_map_drop_black_offset";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 120, 0);
    data->property = "counter_engine_map_fwd_green_offset";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 121, 0);
    data->property = "counter_engine_map_fwd_yellow_offset";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 122, 0);
    data->property = "counter_engine_map_fwd_red_offset";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 123, 0);
    data->property = "counter_engine_map_fwd_black_offset";
    data->num_max = 17;
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 124, 0);
    data->property = "counter_engine_replicated_packets";
    data->err_msg = "this property is no longer supported- no soc properties to configure CRPS functionality";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 125, 0);
    data->property = "policer_base_rate";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 126, 0);
    data->property = "policer_ingress_count";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 127, 0);
    data->property = "policer_egress_count";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 128, 0);
    data->property = "policer_ingress_sharing_mode";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 129, 0);
    data->property = "policer_egress_sharing_mode";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 130, 0);
    data->property = "policer_result_map";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 131, 0);
    data->property = "policer_result_parallel_color_map";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 132, 0);
    data->property = "policer_result_parallel_bucket_update";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 133, 0);
    data->property = "policer_color_resolution_mode";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 134, 0);
    data->property = "bcm_meter_clear_fe";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 135, 0);
    data->property = "bcm_meter_clear_ge";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 136, 0);
    data->property = "bcm_meter_clear_xe";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 137, 0);
    data->property = "global_meter_control";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 138, 0);
    data->property = "global_meter_compression_share";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 139, 0);
    data->property = "global_meter_compaction_support";
    data->err_msg = "this property is no longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 140, 0);
    data->property = "private_ip_frwrd_table_size";
    data->err_msg = "mdb_kaps_a_size and mdb_kaps_b_size replace the private_ip_frwrd_table_size and public_ip_frwrd_table_size soc properties.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 141, 0);
    data->property = "public_ip_frwrd_table_size";
    data->err_msg = "mdb_kaps_a_size and mdb_kaps_b_size replace the private_ip_frwrd_table_size and public_ip_frwrd_table_size soc properties.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 142, 0);
    data->property = "enhanced_fib_scale_prefix_length";
    data->err_msg = "IPv4 FIB scale feature is not supported.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 143, 0);
    data->property = "enhanced_fib_scale_prefix_length_ipv6_long";
    data->err_msg = "IPv6 FIB scale feature is not supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 144, 0);
    data->property = "enhanced_fib_scale_prefix_length_ipv6_short";
    data->err_msg = "IPv6 FIB scale feature is not supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 145, 0);
    data->property = "phy_an_c37";
    data->per_port = 1;
    data->err_msg = "CL37 AN mode is not supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 146, 0);
    data->property = "mpls_encap_invalid_value";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 147, 0);
    data->property = "mpls_encapsulation_action_swap_or_push_enable";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 148, 0);
    data->property = "port_raw_mpls_enable";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 149, 0);
    data->property = "udp_tunnels_enable";
    data->err_msg = "UDP tunnels are always enabled, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 150, 0);
    data->property = "bcm886xx_ip4_tunnel_termination_mode";
    data->err_msg = "Tunnel termination modes are no longer configured with soc property,please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 151, 0);
    data->property = "default_logical_interface_mpls_termination_explicit_null";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 152, 0);
    data->property = "mpls_termination_explicit_null_label_lookup_mode";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 153, 0);
    data->property = "mpls_egress_label_extended_encapsulation_mode";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 154, 0);
    data->property = "bcm886xx_ipv6_tunnel_enable";
    data->err_msg = "IPV6 tunnels are always enabled, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 155, 0);
    data->property = "egress_membership_mode";
    data->err_msg = "Egress membership mode is not supported anymore, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 156, 0);
    data->property = "bcm886xx_ip6_tunnel_termination_mode";
    data->err_msg = "Ipv6 tunnel termination mode is not configured with soc property, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 157, 0);
    data->property = "bcm886xx_ip6_tunnel_encapsulation_mode";
    data->err_msg = "Ipv6 encapsulation mode is not supported anymore, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 158, 0);
    data->property = "custom_feature_allow_modifications_during_traffic";
    data->err_msg = "No need to allow modification during traffic anymore, each case handles its own restrictions internally";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 159, 0);
    data->property = "ext_1588_mac_enable";
    data->per_port = 1;
    data->err_msg = "external mac per port is determinie using API bcm_port_timesync_config_set (flag BCM_PORT_TIMESYNC_EXTERNAL_MAC_ENABLE) ";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 160, 0);
    data->property = "bcm88660_1588_48b_stamping_enable";
    data->err_msg = "1588 48b stamping is not supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 161, 0);
    data->property = "ext_ip4_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 162, 0);
    data->property = "ext_ip4_uc_fpr_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 163, 0);
    data->property = "ext_ip4_mc_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 164, 0);
    data->property = "ext_ip6_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 165, 0);
    data->property = "ext_ip6_uc_fpr_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 166, 0);
    data->property = "ext_ip6_mc_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 167, 0);
    data->property = "ext_mpls_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 168, 0);
    data->property = "ext_trill_uc_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 169, 0);
    data->property = "ext_trill_mc_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 170, 0);
    data->property = "ext_ip4_mc_bridge_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 171, 0);
    data->property = "ext_ip4_double_capacity_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 172, 0);
    data->property = "ext_ip4_uc_rpf_public_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 173, 0);
    data->property = "ext_ip6_uc_rpf_public_fwd_table_size";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 174, 0);
    data->property = "custom_feature_ext_tcam_dc_24bit_result";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 175, 0);
    data->property = "ext_tcam_result_size_segment";
    data->num_max = 7;
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 176, 0);
    data->property = "ext_tcam_result_size_segment_res1_pad";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 177, 0);
    data->property = "ext_tcam_result_size_segment_res3_pad";
    data->err_msg = "The soc property is no longer supported, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 178, 0);
    data->property = "bcm_linkscan_interval";
    data->err_msg = "The soc property is no longer supported. Please use the API bcm_linkscan_enable_set() instead.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 179, 0);
    data->property = "num_erp_tm_ports";
    data->err_msg = "The soc property is no longer supported. Please use the soc property ucode_port with interface ERP instead.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 180, 0);
    data->property = "phy_an_c73";
    data->per_port = 1;
    data->err_msg = "The soc property is no longer supported. Please use bcm_port_autoneg_ability_advert_set instead.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 181, 0);
    data->property = "port_init_autoneg";
    data->per_port = 1;
    data->err_msg = "The soc property is no longer supported. Please use bcm_port_autoneg_set instead.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 182, 0);
    data->property = "exact_match_tables_shadow_enable";
    data->err_msg = "Shadow memories are not supported for EM tables, please read the backward compatibility document.";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 183, 0);
    data->property = "cosq_admission_preference_3";
    data->err_msg = "the soc property is not supported for DP3. it is always ADMIT_OVER_GUARANTEE";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 184, 0);
    data->property = "num_oamp_ports";
    data->err_msg = "use ucode_port_232.BCM8869X=OAMP:core_0.232 and ucode_port_233.BCM8869X=OAMP:core_0.233 instead";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 185, 0);
    data->property = "bfd_ipv6_enable";
    data->err_msg = "BFD IPv6 is always enabled";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 186, 0);
    data->property = "bfd_ipv6_trap_port";
    data->err_msg = "refer to BFD over IPv6 in backwards compatability guide";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 187, 0);
    data->property = "bfd_num_sessions ";
    data->err_msg = "refer to BFD over IPv6 in backwards compatability guide";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 188, 0);
    data->property = "bfd_extended_ipv4_src_ip ";
    data->err_msg = "Soc property not required - OAMP supports 256 SIPs";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 189, 0);
    data->property = "micro_bfd_support_mode ";
    data->err_msg = "Micro BFD always enabled";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 190, 0);
    data->property = "custom_feature_multi_hop_bfd_extra_dip_support ";
    data->err_msg = "Use BCM_BFD_ENDPOINT_FLAGS2_USE_MY_DIP_DESTINATION flag in endpoint create instead";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 191, 0);
    data->property = "bfd_supported_flags_bitfield ";
    data->err_msg = "No longer required - all valid flags supported in OAMP";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 192, 0);
    data->property = "bfd_mask_flags_bitfield ";
    data->err_msg = "No longer required - all valid flags supported in OAMP";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 193, 0);
    data->property = "custom_feature_non_bfd_forwarding";
    data->err_msg = "No longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 194, 0);
    data->property = "custom_feature_tunnel_counters_enabled";
    data->err_msg = "No longer supported";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 195, 0);
    data->property = "bfd_echo_enabled";
    data->err_msg = "BFD echo always enabled";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 196, 0);
    data->property = "oam_trap_strength_injected";
    data->err_msg = "Strength is set per profile in bcm_oam_profile_action_set()";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 197, 0);
    data->property = "oam_maid_11_bytes_enable";
    data->err_msg = "Full 48B MAID may be used instead";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 198, 0);
    data->property = "oam_rcy_port";
    data->err_msg = "Refer to backwards compatability document";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 199, 0);
    data->property = "oam_hierarchical_loss_measurement_by_mdl_enable";
    data->suffix = "No longer required. Refer to backwards compatability guide";
    data = (dnx_data_dev_init_properties_unsupported_t *) dnxc_data_mgmt_table_data_get(unit, table, 200, 0);
    data->property = "custom_feature_oam_downmep_pwe_classification ";
    data->err_msg = "Refer to backwards compatability guide";

exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: general
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_general_data_path_hw_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_general;
    int feature_index = dnx_data_dev_init_general_data_path_hw;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set numeric access_only
 * numeric info:
 * boot with access only
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_general_access_only_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_general;
    int define_index = dnx_data_dev_init_general_define_access_only;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_CUSTOM_FEATURE;
    define->property.doc = 
        "\n"
        "Set to boot with access only.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_enable;
    define->property.method_str = "suffix_enable";
    define->property.suffix = "access_only";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: ha
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set numeric warmboot_support
 * numeric info:
 * specify if unit should support wb
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_ha_warmboot_support_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_ha;
    int define_index = dnx_data_dev_init_ha_define_warmboot_support;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_WARMBOOT_SUPPORT;
    define->property.doc = 
        "Specify if WarmBoot is supported\n"
    ;
    define->property.method = dnxc_data_property_method_direct_map;
    define->property.method_str = "direct_map";
    define->property.nof_mapping = 2;
    DNXC_DATA_ALLOC(define->property.mapping, dnxc_data_property_map_t, define->property.nof_mapping, "dnxc_data property mapping");

    define->property.mapping[0].name = "on";
    define->property.mapping[0].val = 1;
    define->property.mapping[1].name = "off";
    define->property.mapping[1].val = 0;
    define->property.mapping[1].is_default = 1 ;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric sw_state_max_size
 * numeric info:
 * specify the amount of memory (in bytes) preallocated for sw state
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_ha_sw_state_max_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_ha;
    int define_index = dnx_data_dev_init_ha_define_sw_state_max_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_SW_STATE_MAX_SIZE;
    define->property.doc = 
        "\n"
        "Configures the size of memory to be pre allocated for sw state.\n"
        "The valid range is 0-1000000000 (i.e up to 1TB).\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_range;
    define->property.method_str = "range";
    define->property.range_min = 0;
    define->property.range_max = 1000000000;
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: shadow
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set numeric cache_enable_all
 * numeric info:
 * if true shadow all cacheable memory
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_shadow_cache_enable_all_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_shadow;
    int define_index = dnx_data_dev_init_shadow_define_cache_enable_all;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_MEM_CACHE_ENABLE;
    define->property.doc = 
        "\n"
        "Shadow all memory or not.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_enable;
    define->property.method_str = "suffix_enable";
    define->property.suffix = "all";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric cache_enable_ecc
 * numeric info:
 * if true shadow all cacheable memory which contain ecc field
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_shadow_cache_enable_ecc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_shadow;
    int define_index = dnx_data_dev_init_shadow_define_cache_enable_ecc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_MEM_CACHE_ENABLE;
    define->property.doc = 
        "\n"
        "Shadow all memory with ecc field or not.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_enable;
    define->property.method_str = "suffix_enable";
    define->property.suffix = "ecc";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric cache_enable_parity
 * numeric info:
 * if true shadow all cacheable memory which contain parity field
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_shadow_cache_enable_parity_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_shadow;
    int define_index = dnx_data_dev_init_shadow_define_cache_enable_parity;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_MEM_CACHE_ENABLE;
    define->property.doc = 
        "\n"
        "Shadow all memory with parity field or not.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_enable;
    define->property.method_str = "suffix_enable";
    define->property.suffix = "parity";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric cache_enable_specific
 * numeric info:
 * if true, some specific memory be shadowed
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_shadow_cache_enable_specific_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_shadow;
    int define_index = dnx_data_dev_init_shadow_define_cache_enable_specific;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_MEM_CACHE_ENABLE;
    define->property.doc = 
        "\n"
        "Enable memory shadow for specific table.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_suffix_enable;
    define->property.method_str = "suffix_enable";
    define->property.suffix = "specific";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric cache_disable_specific
 * numeric info:
 * if true, some specific memory won't be shadowed
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_shadow_cache_disable_specific_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_shadow;
    int define_index = dnx_data_dev_init_shadow_define_cache_disable_specific;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_MEM_NOCACHE;
    define->property.doc = 
        "\n"
        "Disable memory shadow for specific table.\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_enable;
    define->property.method_str = "enable";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table uncacheable_mem
 * Module - 'dev_init', Submodule - 'shadow', table - 'uncacheable_mem'
 * uncache memory
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_dev_init_shadow_uncacheable_mem_set(
    int unit)
{
    int index_index;
    dnx_data_dev_init_shadow_uncacheable_mem_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = dnx_data_dev_init_submodule_shadow;
    int table_index = dnx_data_dev_init_shadow_table_uncacheable_mem;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 106;
    table->info_get.key_size[0] = 106;

    /* Info - default values */
    table->values[0].default_val = "INVALIDm";
    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_dev_init_shadow_uncacheable_mem_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_dev_init_shadow_table_uncacheable_mem");

    /* Store Default Values */
    default_data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->mem = INVALIDm;
    /* Set Default Values */
    for (index_index = 0; index_index < table->keys[0].size; index_index++)
    {
        data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
    data->mem = CDPORT_TSC_UCMEM_DATAm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
    data->mem = ILE_PORT_0_CPU_ACCESSm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
    data->mem = ILE_PORT_1_CPU_ACCESSm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
    data->mem = IPPF_LEARN_PAYLOAD_CONTEXT_MAPPINGm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
    data->mem = SCH_SCHEDULER_INITm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
    data->mem = ERPP_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
    data->mem = IPPF_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
    data->mem = RX_LKUP_1588_MEM_400Gm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 8, 0);
    data->mem = RX_LKUP_1588_MEM_MPP0m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 9, 0);
    data->mem = RX_LKUP_1588_MEM_MPP1m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 10, 0);
    data->mem = SPEED_ID_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 11, 0);
    data->mem = SPEED_PRIORITY_MAP_TBLm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 12, 0);
    data->mem = TX_LKUP_1588_MEM_400Gm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 13, 0);
    data->mem = TX_LKUP_1588_MEM_MPP0m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 14, 0);
    data->mem = TX_LKUP_1588_MEM_MPP1m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 15, 0);
    data->mem = UM_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 16, 0);
    data->mem = MDB_ARM_KAPS_TCMm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 17, 0);
    data->mem = ERPP_EPMFCS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 18, 0);
    data->mem = IPPA_VTDCS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 19, 0);
    data->mem = IPPA_VTECS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 20, 0);
    data->mem = IPPB_FLPACS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 21, 0);
    data->mem = IPPB_FLPBCS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 22, 0);
    data->mem = IPPC_PMFACSA_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 23, 0);
    data->mem = IPPC_PMFACSB_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 24, 0);
    data->mem = IPPD_PMFBCS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 25, 0);
    data->mem = IPPE_LLRCS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 26, 0);
    data->mem = IPPE_PRTCAM_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 27, 0);
    data->mem = IPPF_VTACS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 28, 0);
    data->mem = IPPF_VTBCS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 29, 0);
    data->mem = IPPF_VTCCS_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 30, 0);
    data->mem = TCAM_TCAM_BANK_COMMANDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 31, 0);
    data->mem = ERPP_EPMFCS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 32, 0);
    data->mem = IPPA_VTDCS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 33, 0);
    data->mem = IPPA_VTECS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 34, 0);
    data->mem = IPPB_FLPACS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 35, 0);
    data->mem = IPPB_FLPBCS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 36, 0);
    data->mem = IPPC_PMFACSA_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 37, 0);
    data->mem = IPPC_PMFACSB_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 38, 0);
    data->mem = IPPD_PMFBCS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 39, 0);
    data->mem = IPPE_LLRCS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 40, 0);
    data->mem = IPPE_PRTCAM_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 41, 0);
    data->mem = IPPF_VTACS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 42, 0);
    data->mem = IPPF_VTBCS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 43, 0);
    data->mem = IPPF_VTCCS_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 44, 0);
    data->mem = TCAM_TCAM_BANK_REPLYm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 45, 0);
    data->mem = ERPP_EPMFCS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 46, 0);
    data->mem = IPPA_VTDCS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 47, 0);
    data->mem = IPPA_VTECS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 48, 0);
    data->mem = IPPB_FLPACS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 49, 0);
    data->mem = IPPB_FLPBCS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 50, 0);
    data->mem = IPPC_PMFACSA_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 51, 0);
    data->mem = IPPC_PMFACSB_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 52, 0);
    data->mem = IPPD_PMFBCS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 53, 0);
    data->mem = IPPE_LLRCS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 54, 0);
    data->mem = IPPE_PRTCAM_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 55, 0);
    data->mem = IPPF_VTACS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 56, 0);
    data->mem = IPPF_VTBCS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 57, 0);
    data->mem = IPPF_VTCCS_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 58, 0);
    data->mem = TCAM_TCAM_BANKm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 59, 0);
    data->mem = AM_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 60, 0);
    data->mem = SCH_TOKEN_MEMORY_CONTROLLER_TMCm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 61, 0);
    data->mem = MDB_ARM_MEM_0m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 62, 0);
    data->mem = MDB_ISEM_1m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 63, 0);
    data->mem = MDB_ISEM_2m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 64, 0);
    data->mem = MDB_ISEM_3m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 65, 0);
    data->mem = MDB_IOEM_0m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 66, 0);
    data->mem = MDB_IOEM_1m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 67, 0);
    data->mem = MDB_MC_IDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 68, 0);
    data->mem = MDB_GLEM_0m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 69, 0);
    data->mem = MDB_GLEM_1m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 70, 0);
    data->mem = MDB_EOEM_0m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 71, 0);
    data->mem = MDB_EOEM_1m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 72, 0);
    data->mem = EVNT_ASSIGNED_CMIC_ENGINE_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 73, 0);
    data->mem = EVNT_SPACE_REGIONSm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 74, 0);
    data->mem = EVNT_CMIC_ENG_PROPERTIESm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 75, 0);
    data->mem = OAMP_MEP_DBm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 76, 0);
    data->mem = OAMP_RMEP_DBm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 77, 0);
    data->mem = MDB_ESEMm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 78, 0);
    data->mem = MDB_EXEM_1m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 79, 0);
    data->mem = MDB_EXEM_2m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 80, 0);
    data->mem = MDB_RMEPm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 81, 0);
    data->mem = IPPC_PER_PORT_STATISTICSm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 82, 0);
    data->mem = ETPPA_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 83, 0);
    data->mem = ETPPA_PARSING_START_TYPE_MAPPING_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 84, 0);
    data->mem = ETPPB_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 85, 0);
    data->mem = ETPPB_MTU_MAP_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 86, 0);
    data->mem = ETPPC_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 87, 0);
    data->mem = ETPPC_MTU_MAP_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 88, 0);
    data->mem = IPPA_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 89, 0);
    data->mem = IPPB_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 90, 0);
    data->mem = IPPB_MPLS_LABEL_TYPES_CAM_0m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 91, 0);
    data->mem = IPPB_MPLS_LABEL_TYPES_CAM_1m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 92, 0);
    data->mem = IPPC_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 93, 0);
    data->mem = IPPD_MEM_F000000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 94, 0);
    data->mem = IPPD_MIRROR_CODE_TO_CMDm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 95, 0);
    data->mem = IPPE_MEM_B900000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 96, 0);
    data->mem = IPPE_MEM_F0000m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 97, 0);
    data->mem = SCH_RESERVED_37m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 98, 0);
    data->mem = SCH_RESERVED_54m;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 99, 0);
    data->mem = EPS_OTM_CALENDAR_CRDT_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 100, 0);
    data->mem = EPS_OTM_HP_CRDT_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 101, 0);
    data->mem = EPS_OTM_LP_CRDT_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 102, 0);
    data->mem = EPS_CAL_CAL_INDX_MUXm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 103, 0);
    data->mem = EPS_QP_CREDIT_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 104, 0);
    data->mem = EPS_TCG_CREDIT_TABLEm;
    data = (dnx_data_dev_init_shadow_uncacheable_mem_t *) dnxc_data_mgmt_table_data_get(unit, table, 105, 0);
    data->mem = EPS_TCG_CBMm;

exit:
    SHR_FUNC_EXIT;
}

/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jer2_a0_data_dev_init_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_dev_init;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: time
     */
    submodule_index = dnx_data_dev_init_submodule_time;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_dev_init_time_define_analyze;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_time_analyze_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: mem
     */
    submodule_index = dnx_data_dev_init_submodule_mem;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_dev_init_mem_define_force_zeros;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_mem_force_zeros_set;
    data_index = dnx_data_dev_init_mem_define_defaults_verify;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_mem_defaults_verify_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_dev_init_mem_table_default;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_dev_init_mem_default_set;
    /*
     * Attach submodule: properties
     */
    submodule_index = dnx_data_dev_init_submodule_properties;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_dev_init_properties_table_unsupported;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_dev_init_properties_unsupported_set;
    /*
     * Attach submodule: general
     */
    submodule_index = dnx_data_dev_init_submodule_general;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_dev_init_general_define_access_only;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_general_access_only_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_dev_init_general_data_path_hw;
    feature = &submodule->features[data_index];
    feature->set = jer2_a0_dnx_data_dev_init_general_data_path_hw_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: ha
     */
    submodule_index = dnx_data_dev_init_submodule_ha;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_dev_init_ha_define_warmboot_support;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_ha_warmboot_support_set;
    data_index = dnx_data_dev_init_ha_define_sw_state_max_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_ha_sw_state_max_size_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: shadow
     */
    submodule_index = dnx_data_dev_init_submodule_shadow;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_dev_init_shadow_define_cache_enable_all;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_shadow_cache_enable_all_set;
    data_index = dnx_data_dev_init_shadow_define_cache_enable_ecc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_shadow_cache_enable_ecc_set;
    data_index = dnx_data_dev_init_shadow_define_cache_enable_parity;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_shadow_cache_enable_parity_set;
    data_index = dnx_data_dev_init_shadow_define_cache_enable_specific;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_shadow_cache_enable_specific_set;
    data_index = dnx_data_dev_init_shadow_define_cache_disable_specific;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_dev_init_shadow_cache_disable_specific_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_dev_init_shadow_table_uncacheable_mem;
    table = &submodule->tables[data_index];
    table->set = jer2_a0_dnx_data_dev_init_shadow_uncacheable_mem_set;

    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
