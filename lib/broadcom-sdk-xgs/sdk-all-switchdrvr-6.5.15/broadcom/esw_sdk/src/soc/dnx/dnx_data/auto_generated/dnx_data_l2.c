/** \file dnx_data_l2.c
 * 
 * MODULE DEVICE DATA - L2
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_L2
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_l2.h>
/*
 * }
 */

/*
 * Extern per device attach function
 */
extern shr_error_e jer2_a0_data_l2_attach(
    int unit);
extern shr_error_e jer2_b0_data_l2_attach(
    int unit);
/*
 * SUBMODULE - GENERAL:
 * {
 */
/*
 * general init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_l2_general_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "general";
    submodule_data->doc = "General L2 properties";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_l2_general_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data l2 general features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_l2_general_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data l2 general defines");

    submodule_data->defines[dnx_data_l2_general_define_vsi_offset_shift].name = "vsi_offset_shift";
    submodule_data->defines[dnx_data_l2_general_define_vsi_offset_shift].doc = "Workaround for VSI location in MACT entry";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_general_define_vsi_offset_shift].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_general_define_lif_offset_shift].name = "lif_offset_shift";
    submodule_data->defines[dnx_data_l2_general_define_lif_offset_shift].doc = "Workaround for LIF location in MACT entry";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_general_define_lif_offset_shift].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_general_define_l2_learn_limit_mode].name = "l2_learn_limit_mode";
    submodule_data->defines[dnx_data_l2_general_define_l2_learn_limit_mode].doc = "MACT learning limit mode";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_general_define_l2_learn_limit_mode].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_l2_general_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data l2 general tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * general features
 */
int
dnx_data_l2_general_feature_get(
    int unit,
    dnx_data_l2_general_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_general, feature);
}

/*
 * general defines
 */
uint32
dnx_data_l2_general_vsi_offset_shift_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_general, dnx_data_l2_general_define_vsi_offset_shift);
}

uint32
dnx_data_l2_general_lif_offset_shift_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_general, dnx_data_l2_general_define_lif_offset_shift);
}

uint32
dnx_data_l2_general_l2_learn_limit_mode_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_general, dnx_data_l2_general_define_l2_learn_limit_mode);
}

/*
 * general tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - HW_BUG:
 * {
 */
/*
 * hw_bug init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_l2_hw_bug_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "hw_bug";
    submodule_data->doc = "L2 related HW bugs";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_l2_hw_bug_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data l2 hw_bug features");

    submodule_data->features[dnx_data_l2_hw_bug_age_out_and_refresh_profile_selection].name = "age_out_and_refresh_profile_selection";
    submodule_data->features[dnx_data_l2_hw_bug_age_out_and_refresh_profile_selection].doc = "Age out and refresh distribution is always taken from the default profile";
    submodule_data->features[dnx_data_l2_hw_bug_age_out_and_refresh_profile_selection].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_l2_hw_bug_age_machine_pause_after_flush].name = "age_machine_pause_after_flush";
    submodule_data->features[dnx_data_l2_hw_bug_age_machine_pause_after_flush].doc = "Age machine stops working after flush runs";
    submodule_data->features[dnx_data_l2_hw_bug_age_machine_pause_after_flush].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_l2_hw_bug_age_state_not_updated].name = "age_state_not_updated";
    submodule_data->features[dnx_data_l2_hw_bug_age_state_not_updated].doc = "Age state of l2 entries is not updated";
    submodule_data->features[dnx_data_l2_hw_bug_age_state_not_updated].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_l2_hw_bug_appdb_id_for_olp].name = "appdb_id_for_olp";
    submodule_data->features[dnx_data_l2_hw_bug_appdb_id_for_olp].doc = "AppDB ID is wrongly taken from the 4 MSBs like in Jericho";
    submodule_data->features[dnx_data_l2_hw_bug_appdb_id_for_olp].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_l2_hw_bug_eth_qual_is_mc].name = "eth_qual_is_mc";
    submodule_data->features[dnx_data_l2_hw_bug_eth_qual_is_mc].doc = "Parser Ethernet qualifier is_mc is set correctly";
    submodule_data->features[dnx_data_l2_hw_bug_eth_qual_is_mc].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_l2_hw_bug_fid_mgmt_ecc_error].name = "fid_mgmt_ecc_error";
    submodule_data->features[dnx_data_l2_hw_bug_fid_mgmt_ecc_error].doc = "Bug in ecc calculation in the MACT";
    submodule_data->features[dnx_data_l2_hw_bug_fid_mgmt_ecc_error].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_l2_hw_bug_wrong_limit_interrupt_handling].name = "wrong_limit_interrupt_handling";
    submodule_data->features[dnx_data_l2_hw_bug_wrong_limit_interrupt_handling].doc = "No interrupt is raised for fid limit cross";
    submodule_data->features[dnx_data_l2_hw_bug_wrong_limit_interrupt_handling].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_l2_hw_bug_transplant_instead_of_refresh].name = "transplant_instead_of_refresh";
    submodule_data->features[dnx_data_l2_hw_bug_transplant_instead_of_refresh].doc = "Transplant event is created instead of refresh event";
    submodule_data->features[dnx_data_l2_hw_bug_transplant_instead_of_refresh].flags |= DNXC_DATA_F_FEATURE;

    submodule_data->features[dnx_data_l2_hw_bug_static_mac_age_out].name = "static_mac_age_out";
    submodule_data->features[dnx_data_l2_hw_bug_static_mac_age_out].doc = "Static mac entries age out and deleted";
    submodule_data->features[dnx_data_l2_hw_bug_static_mac_age_out].flags |= DNXC_DATA_F_FEATURE;

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_l2_hw_bug_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data l2 hw_bug defines");

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_l2_hw_bug_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data l2 hw_bug tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * hw_bug features
 */
int
dnx_data_l2_hw_bug_feature_get(
    int unit,
    dnx_data_l2_hw_bug_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_hw_bug, feature);
}

/*
 * hw_bug defines
 */
/*
 * hw_bug tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - VSI:
 * {
 */
/*
 * vsi init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_l2_vsi_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "vsi";
    submodule_data->doc = "VSI data";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_l2_vsi_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data l2 vsi features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_l2_vsi_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data l2 vsi defines");

    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsi_aging_profiles].name = "nof_vsi_aging_profiles";
    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsi_aging_profiles].doc = "Number of VSI aging profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsi_aging_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_vsi_define_nof_event_forwarding_profiles].name = "nof_event_forwarding_profiles";
    submodule_data->defines[dnx_data_l2_vsi_define_nof_event_forwarding_profiles].doc = "Number of event forwarding profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_vsi_define_nof_event_forwarding_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsi_learning_profiles].name = "nof_vsi_learning_profiles";
    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsi_learning_profiles].doc = "Number of VSI learning profiles";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsi_learning_profiles].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsis].name = "nof_vsis";
    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsis].doc = "Number of VSIs";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_vsi_define_nof_vsis].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_l2_vsi_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data l2 vsi tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * vsi features
 */
int
dnx_data_l2_vsi_feature_get(
    int unit,
    dnx_data_l2_vsi_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_vsi, feature);
}

/*
 * vsi defines
 */
uint32
dnx_data_l2_vsi_nof_vsi_aging_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_vsi, dnx_data_l2_vsi_define_nof_vsi_aging_profiles);
}

uint32
dnx_data_l2_vsi_nof_event_forwarding_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_vsi, dnx_data_l2_vsi_define_nof_event_forwarding_profiles);
}

uint32
dnx_data_l2_vsi_nof_vsi_learning_profiles_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_vsi, dnx_data_l2_vsi_define_nof_vsi_learning_profiles);
}

uint32
dnx_data_l2_vsi_nof_vsis_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_vsi, dnx_data_l2_vsi_define_nof_vsis);
}

/*
 * vsi tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - VLAN_DOMAIN:
 * {
 */
/*
 * vlan_domain init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_l2_vlan_domain_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "vlan_domain";
    submodule_data->doc = "vlan domain";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_l2_vlan_domain_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data l2 vlan_domain features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_l2_vlan_domain_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data l2 vlan_domain defines");

    submodule_data->defines[dnx_data_l2_vlan_domain_define_nof_vlan_domains].name = "nof_vlan_domains";
    submodule_data->defines[dnx_data_l2_vlan_domain_define_nof_vlan_domains].doc = "Number of supported vlan domains";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_vlan_domain_define_nof_vlan_domains].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_l2_vlan_domain_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data l2 vlan_domain tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * vlan_domain features
 */
int
dnx_data_l2_vlan_domain_feature_get(
    int unit,
    dnx_data_l2_vlan_domain_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_vlan_domain, feature);
}

/*
 * vlan_domain defines
 */
uint32
dnx_data_l2_vlan_domain_nof_vlan_domains_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_vlan_domain, dnx_data_l2_vlan_domain_define_nof_vlan_domains);
}

/*
 * vlan_domain tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - DMA:
 * {
 */
/*
 * dma init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_l2_dma_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "dma";
    submodule_data->doc = "dma";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_l2_dma_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data l2 dma features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_l2_dma_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data l2 dma defines");

    submodule_data->defines[dnx_data_l2_dma_define_flush_nof_dma_entries].name = "flush_nof_dma_entries";
    submodule_data->defines[dnx_data_l2_dma_define_flush_nof_dma_entries].doc = "Number of flush DMA entries that the host can hold";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_flush_nof_dma_entries].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_dma_define_flush_db_nof_dma_rules].name = "flush_db_nof_dma_rules";
    submodule_data->defines[dnx_data_l2_dma_define_flush_db_nof_dma_rules].doc = "Number of flush DMA rules";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_flush_db_nof_dma_rules].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_dma_define_flush_db_nof_dma_rules_per_table].name = "flush_db_nof_dma_rules_per_table";
    submodule_data->defines[dnx_data_l2_dma_define_flush_db_nof_dma_rules_per_table].doc = "Number of flush DMA rules in a table";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_flush_db_nof_dma_rules_per_table].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_dma_define_flush_db_rule_size].name = "flush_db_rule_size";
    submodule_data->defines[dnx_data_l2_dma_define_flush_db_rule_size].doc = "Size in bytes of a flush DB rule";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_flush_db_rule_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_dma_define_flush_db_data_size].name = "flush_db_data_size";
    submodule_data->defines[dnx_data_l2_dma_define_flush_db_data_size].doc = "Size in bytes of a flush DB action data";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_flush_db_data_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_dma_define_flush_group_size].name = "flush_group_size";
    submodule_data->defines[dnx_data_l2_dma_define_flush_group_size].doc = "the size of flush group field";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_flush_group_size].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_buffer_size].name = "learning_fifo_dma_buffer_size";
    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_buffer_size].doc = "learning fifo dma buffer size in bytes";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_buffer_size].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_timeout].name = "learning_fifo_dma_timeout";
    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_timeout].doc = "learning fifo dma timeout in microseconds";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_timeout].flags |= DNXC_DATA_F_NUMERIC;

    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_threshold].name = "learning_fifo_dma_threshold";
    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_threshold].doc = "learning fifo dma threshold";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_dma_define_learning_fifo_dma_threshold].flags |= DNXC_DATA_F_NUMERIC;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_l2_dma_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data l2 dma tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * dma features
 */
int
dnx_data_l2_dma_feature_get(
    int unit,
    dnx_data_l2_dma_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, feature);
}

/*
 * dma defines
 */
uint32
dnx_data_l2_dma_flush_nof_dma_entries_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_flush_nof_dma_entries);
}

uint32
dnx_data_l2_dma_flush_db_nof_dma_rules_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_flush_db_nof_dma_rules);
}

uint32
dnx_data_l2_dma_flush_db_nof_dma_rules_per_table_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_flush_db_nof_dma_rules_per_table);
}

uint32
dnx_data_l2_dma_flush_db_rule_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_flush_db_rule_size);
}

uint32
dnx_data_l2_dma_flush_db_data_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_flush_db_data_size);
}

uint32
dnx_data_l2_dma_flush_group_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_flush_group_size);
}

uint32
dnx_data_l2_dma_learning_fifo_dma_buffer_size_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_learning_fifo_dma_buffer_size);
}

uint32
dnx_data_l2_dma_learning_fifo_dma_timeout_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_learning_fifo_dma_timeout);
}

uint32
dnx_data_l2_dma_learning_fifo_dma_threshold_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_dma, dnx_data_l2_dma_define_learning_fifo_dma_threshold);
}

/*
 * dma tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

/*
 * SUBMODULE - OLP:
 * {
 */
/*
 * olp init
 */
/**
 * \brief Set submodule data to default value per device type
 * 
 * \param [in] unit - Unit #
 * \param [out] submodule_data - pointer to submodule data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
dnx_data_l2_olp_init(
    int unit,
    dnxc_data_submodule_t *submodule_data)
{
    SHR_FUNC_INIT_VARS(unit);

    submodule_data->name = "olp";
    submodule_data->doc = "Data for OLP configuration";
    /*
     * Features
     */
    submodule_data->nof_features = _dnx_data_l2_olp_feature_nof;
    DNXC_DATA_ALLOC(submodule_data->features, dnxc_data_feature_t,  submodule_data->nof_features, "_dnxc_data l2 olp features");

    /*
     * Defines
     */
    submodule_data->nof_defines = _dnx_data_l2_olp_define_nof;
    DNXC_DATA_ALLOC(submodule_data->defines, dnxc_data_define_t, submodule_data->nof_defines, "_dnxc_data l2 olp defines");

    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_shift].name = "lpkgv_shift";
    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_shift].doc = "Learn_Payload_Key_Gen_Var shift in learn payload msb";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_shift].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_mask].name = "lpkgv_mask";
    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_mask].doc = "Learn_Payload_Key_Gen_Var mask in learn payload msb";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_mask].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_with_outlif].name = "lpkgv_with_outlif";
    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_with_outlif].doc = "Learn_Payload_Key_Gen_Var for outlif is valid in learn payload";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_with_outlif].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_wo_outlif].name = "lpkgv_wo_outlif";
    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_wo_outlif].doc = "Learn_Payload_Key_Gen_Var for outlif is invalid in learn payload";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_olp_define_lpkgv_wo_outlif].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_olp_define_destination_offset].name = "destination_offset";
    submodule_data->defines[dnx_data_l2_olp_define_destination_offset].doc = "destination offset in learn payload";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_olp_define_destination_offset].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_olp_define_outlif_offset].name = "outlif_offset";
    submodule_data->defines[dnx_data_l2_olp_define_outlif_offset].doc = "outlif offset in learn payload";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_olp_define_outlif_offset].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_olp_define_eei_offset].name = "eei_offset";
    submodule_data->defines[dnx_data_l2_olp_define_eei_offset].doc = "eei offset in learn payload";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_olp_define_eei_offset].flags |= DNXC_DATA_F_DEFINE;

    submodule_data->defines[dnx_data_l2_olp_define_fec_offset].name = "fec_offset";
    submodule_data->defines[dnx_data_l2_olp_define_fec_offset].doc = "fec offset in learn payload";
    /* Set data type flag */
    submodule_data->defines[dnx_data_l2_olp_define_fec_offset].flags |= DNXC_DATA_F_DEFINE;

    /*
     * Tables
     */
    submodule_data->nof_tables = _dnx_data_l2_olp_table_nof;
    DNXC_DATA_ALLOC(submodule_data->tables, dnxc_data_table_t, submodule_data->nof_tables, "_dnxc_data l2 olp tables");


exit:
    SHR_FUNC_EXIT;
}

/*
 * olp features
 */
int
dnx_data_l2_olp_feature_get(
    int unit,
    dnx_data_l2_olp_feature_e feature)
{
    return dnxc_data_mgmt_feature_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, feature);
}

/*
 * olp defines
 */
uint32
dnx_data_l2_olp_lpkgv_shift_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, dnx_data_l2_olp_define_lpkgv_shift);
}

uint32
dnx_data_l2_olp_lpkgv_mask_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, dnx_data_l2_olp_define_lpkgv_mask);
}

uint32
dnx_data_l2_olp_lpkgv_with_outlif_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, dnx_data_l2_olp_define_lpkgv_with_outlif);
}

uint32
dnx_data_l2_olp_lpkgv_wo_outlif_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, dnx_data_l2_olp_define_lpkgv_wo_outlif);
}

uint32
dnx_data_l2_olp_destination_offset_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, dnx_data_l2_olp_define_destination_offset);
}

uint32
dnx_data_l2_olp_outlif_offset_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, dnx_data_l2_olp_define_outlif_offset);
}

uint32
dnx_data_l2_olp_eei_offset_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, dnx_data_l2_olp_define_eei_offset);
}

uint32
dnx_data_l2_olp_fec_offset_get(
    int unit)
{
    return dnxc_data_mgmt_define_data_get(unit, dnx_data_module_l2, dnx_data_l2_submodule_olp, dnx_data_l2_olp_define_fec_offset);
}

/*
 * olp tables
 */
/* Table Get */
/* Get value as str */
/* Table Info Get */
/*
 * }
 */

shr_error_e
dnx_data_l2_init(
    int unit,
    dnxc_data_module_t *module_data)
{
    SHR_FUNC_INIT_VARS(unit);

    /* Data Struct Init */
    module_data->name = "l2";
    module_data->nof_submodules = _dnx_data_l2_submodule_nof;
    DNXC_DATA_ALLOC(module_data->submodules, dnxc_data_submodule_t, module_data->nof_submodules, "_dnxc_data l2 submodules");

    /*
     * Init Submodule data
     */
    SHR_IF_ERR_EXIT(dnx_data_l2_general_init(unit, &module_data->submodules[dnx_data_l2_submodule_general]));
    SHR_IF_ERR_EXIT(dnx_data_l2_hw_bug_init(unit, &module_data->submodules[dnx_data_l2_submodule_hw_bug]));
    SHR_IF_ERR_EXIT(dnx_data_l2_vsi_init(unit, &module_data->submodules[dnx_data_l2_submodule_vsi]));
    SHR_IF_ERR_EXIT(dnx_data_l2_vlan_domain_init(unit, &module_data->submodules[dnx_data_l2_submodule_vlan_domain]));
    SHR_IF_ERR_EXIT(dnx_data_l2_dma_init(unit, &module_data->submodules[dnx_data_l2_submodule_dma]));
    SHR_IF_ERR_EXIT(dnx_data_l2_olp_init(unit, &module_data->submodules[dnx_data_l2_submodule_olp]));
    /*
     * Attach device module
     */
    if (dnxc_data_mgmt_is_jer2_a0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_l2_attach(unit));
    }
    else
    if (dnxc_data_mgmt_is_jer2_b0(unit))
    {
        SHR_IF_ERR_EXIT(jer2_a0_data_l2_attach(unit));
        SHR_IF_ERR_EXIT(jer2_b0_data_l2_attach(unit));
    }

exit:
    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
