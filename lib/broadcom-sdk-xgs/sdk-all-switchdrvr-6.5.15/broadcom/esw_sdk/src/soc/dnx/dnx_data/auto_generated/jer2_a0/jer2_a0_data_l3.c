/** \file jer2_a0_data_l3.c
 * 
 * DEVICE DATA - L3
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_L3
/**
 * \brief
 * Mark this file as device data internal file
 */
#define DNX_DATA_INTERNAL
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_l3.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_lif.h>
#include <shared/utilex/utilex_integer_arithmetic.h>
/*
 * }
 */

/*
 * EXTERN FUNCTIONS:
 * {
 */
/**
 * \brief Function which read the SoC property and modify the data to the required value
 * Module - 'l3', Submodule - 'rif', data - 'nof_rifs'
 * null
 * 
 * \param [in] unit - Unit #
 * \param [out] nof_rifs - data already set to default and should be modifeid according to property
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_property_l3_rif_nof_rifs_read(
    int unit,
    uint32 *nof_rifs);

/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: egr_pointed
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_bits_in_egr_pointed_id
 * define info:
 * Number of bits representing one virtual egress pointed object id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_egr_pointed;
    int define_index = dnx_data_l3_egr_pointed_define_nof_bits_in_egr_pointed_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.out_lif.outlif_pointer_size_get(unit);

    /* Set value */
    define->data = dnx_data_lif.out_lif.outlif_pointer_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_egr_pointed_ids
 * define info:
 * Number of virtual egress pointed object ids
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_egr_pointed_nof_egr_pointed_ids_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_egr_pointed;
    int define_index = dnx_data_l3_egr_pointed_define_nof_egr_pointed_ids;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1 << dnx_data_l3.egr_pointed.nof_bits_in_egr_pointed_id_get(unit);

    /* Set value */
    define->data = 1 << dnx_data_l3.egr_pointed.nof_bits_in_egr_pointed_id_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define first_egr_pointed_id
 * define info:
 * Identifier of very first virtual egress pointed object.                            Range is from 'first_egr_pointed_id' to 'nof_egr_pointed_ids - 1'
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_egr_pointed_first_egr_pointed_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_egr_pointed;
    int define_index = dnx_data_l3_egr_pointed_define_first_egr_pointed_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: fec
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_fecs
 * define info:
 * The maximal number of FECs supported by the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_nof_fecs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_fecs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xC0000;

    /* Set value */
    define->data = 0xC0000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fec_id_26k_granularity
 * define info:
 * The maximal FEC ID when using a 26k FEC granularity.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_max_fec_id_26k_granularity_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_fec_id_26k_granularity;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = UTILEX_MIN(dnx_data_l3.fec.nof_fecs_get(unit),0x80000)-1;

    /* Set value */
    define->data = UTILEX_MIN(dnx_data_l3.fec.nof_fecs_get(unit),0x80000)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fec_id_52k_granularity
 * define info:
 * The maximal FEC ID when using a 52k FEC granularity .
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_max_fec_id_52k_granularity_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_fec_id_52k_granularity;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_l3.fec.nof_fecs_get(unit)-1;

    /* Set value */
    define->data = dnx_data_l3.fec.nof_fecs_get(unit)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_default_fec
 * define info:
 * The maximal FEC id that can be used for default route.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_max_default_fec_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_default_fec;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1FFFF;

    /* Set value */
    define->data = 0x1FFFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fec_stage_map_size
 * define info:
 * The smallest number of FECs which belong to the same hierarchy
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_fec_stage_map_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_fec_stage_map_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 26214;

    /* Set value */
    define->data = 26214;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_fec_stage_map_size
 * define info:
 * The biggest number of FECs which belong to the same bank
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_max_fec_stage_map_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_fec_stage_map_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 26216;

    /* Set value */
    define->data = 26216;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_super_fecs_per_bank
 * define info:
 * The number of SUPER FEC IDs per resource manager bank.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_nof_super_fecs_per_bank_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_super_fecs_per_bank;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 26216/2;

    /* Set value */
    define->data = 26216/2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_physical_fecs_per_bank
 * define info:
 * The number of physical FEC IDs per bank.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_nof_physical_fecs_per_bank_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_nof_physical_fecs_per_bank;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8192;

    /* Set value */
    define->data = 8192;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define super_fec_size
 * define info:
 * The number of bits of a single super FEC in the MDB.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_super_fec_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_super_fec_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 150;

    /* Set value */
    define->data = 150;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fec_row_size
 * define info:
 * The number of bits in a single row in the FEC MDB table.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_fec_row_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_fec_row_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 240;

    /* Set value */
    define->data = 240;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fec_max_nof_banks
 * define info:
 * The maximal NOF possible banks in the device (not MDB profile dependent).
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_fec_max_nof_banks_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_fec_max_nof_banks;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_l3.fec.nof_fecs_get(unit)/dnx_data_l3.fec.fec_stage_map_size_get(unit));

    /* Set value */
    define->data = (dnx_data_l3.fec.nof_fecs_get(unit)/dnx_data_l3.fec.fec_stage_map_size_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define first_bank_without_id_alloc
 * define info:
 * the first fec allocation bank that can be used for allocating FECs without an ID
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_first_bank_without_id_alloc_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_first_bank_without_id_alloc;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_super_fec_id
 * define info:
 * The max ID of the super FEC
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fec_max_super_fec_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fec;
    int define_index = dnx_data_l3_fec_define_max_super_fec_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_l3.fec.nof_fecs_get(unit)/2-1);

    /* Set value */
    define->data = (dnx_data_l3.fec.nof_fecs_get(unit)/2-1);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: source_address
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define source_address_table_size
 * define info:
 * The number of entries in the source address table.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_source_address_source_address_table_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_source_address;
    int define_index = dnx_data_l3_source_address_define_source_address_table_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define custom_sa_use_dual_homing
 * define info:
 * Indication whether ARP custom sa feature is using EEDB dual homing field or full mac address from source address table.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_source_address_custom_sa_use_dual_homing_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_source_address;
    int define_index = dnx_data_l3_source_address_define_custom_sa_use_dual_homing;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: vrf
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_vrf
 * define info:
 * The maximal number of VRFs supported by the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrf_nof_vrf_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrf;
    int define_index = dnx_data_l3_vrf_define_nof_vrf;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 65536;

    /* Set value */
    define->data = 65536;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: routing_enablers
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_routing_enablers_profiles
 * define info:
 * The maximal number of references for a routing enablers vector.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_routing_enablers_nof_routing_enablers_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_routing_enablers;
    int define_index = dnx_data_l3_routing_enablers_define_nof_routing_enablers_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4096;

    /* Set value */
    define->data = 4096;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: rif
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_nof_rifs
 * define info:
 * Maximum number of rifs supported by the device.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_rif_max_nof_rifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_rif;
    int define_index = dnx_data_l3_rif_define_max_nof_rifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x20000;

    /* Set value */
    define->data = 0x20000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric nof_rifs
 * numeric info:
 * Number of rifs available in the system.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_rif_nof_rifs_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_rif;
    int define_index = dnx_data_l3_rif_define_nof_rifs;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_lif.out_lif.physical_bank_size_get(unit);

    /* Set value */
    define->data = dnx_data_lif.out_lif.physical_bank_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = "rif_id_max";
    define->property.doc = NULL;
    define->property.method = dnxc_data_property_method_custom;
    define->property.method_str = "custom";
    SHR_IF_ERR_EXIT(dnx_data_property_l3_rif_nof_rifs_read(unit, (uint32 *) &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: fwd
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_mc_group_lpm
 * define info:
 * The maximum number of MC group ID for IPMC route entries.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fwd_max_mc_group_lpm_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_max_mc_group_lpm;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1FFFF;

    /* Set value */
    define->data = 0x1FFFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_mc_group_em
 * define info:
 * The maximum number of MC group ID for IPMC host entries.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fwd_max_mc_group_em_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_max_mc_group_em;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x7FFFF;

    /* Set value */
    define->data = 0x7FFFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_my_mac_prefixes
 * define info:
 * The number of my MACs prefixes.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_fwd_nof_my_mac_prefixes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_fwd;
    int define_index = dnx_data_l3_fwd_define_nof_my_mac_prefixes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: ecmp
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define max_group_size
 * define info:
 * The maximal size of an ECMP group.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_max_group_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_max_group_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp_per_bank_of_low_ecmps
 * define info:
 * The low 32k ECMP are placed in a memory of 16 banks, each bank holds 2k ECMPS.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_nof_ecmp_per_bank_of_low_ecmps_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp_per_bank_of_low_ecmps;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x800;

    /* Set value */
    define->data = 0x800;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp_basic_mode
 * define info:
 * Number of ECMP groups that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_nof_ecmp_basic_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp_basic_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x8000;

    /* Set value */
    define->data = 0x8000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define total_nof_ecmp
 * define info:
 * The total number of IDs that are considered to be in the ECMP range.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_total_nof_ecmp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_total_nof_ecmp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xA000;

    /* Set value */
    define->data = 0xA000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_ecmp_basic_mode
 * define info:
 * Maximum ECMP group ID that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_max_ecmp_basic_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_max_ecmp_basic_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x7FFF;

    /* Set value */
    define->data = 0x7FFF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_ecmp_extended_mode
 * define info:
 * Maximum ECMP group ID that can be created in extended mode
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_max_ecmp_extended_mode_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_max_ecmp_extended_mode;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x97FF;

    /* Set value */
    define->data = 0x97FF;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp_per_bank_of_extended_ecmps
 * define info:
 * The upper 8k ECMP (from 32k to 40k) are placed in a memory of 16 banks, each bank holds 512 ECMPS.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_nof_ecmp_per_bank_of_extended_ecmps_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp_per_bank_of_extended_ecmps;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x200;

    /* Set value */
    define->data = 0x200;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fec_banks_per_extended_ecmp_bank
 * define info:
 * nof fec protection banks to be used for 1 ecmp extended bank
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_nof_fec_banks_per_extended_ecmp_bank_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_fec_banks_per_extended_ecmp_bank;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_group_profiles_per_hierarchy
 * define info:
 * Number of profiles that are available for each ECMP hierarchy.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_group_profiles_per_hierarchy;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x400;

    /* Set value */
    define->data = 0x400;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define members_table_size_in_bits
 * define info:
 * The available space for the members table in bits.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_members_table_size_in_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_members_table_size_in_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x20000;

    /* Set value */
    define->data = 0x20000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ecmp_stage_map_size
 * define info:
 * The smallest number of consecutive ECMP groups which belong to the same hierarchy
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_ecmp_stage_map_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_ecmp_stage_map_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x800;

    /* Set value */
    define->data = 0x800;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp_banks_basic
 * define info:
 * The number of ECMP banks in the basic range of IDs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_nof_ecmp_banks_basic_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp_banks_basic;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp_banks_extended
 * define info:
 * The number of ECMP banks in the extended range of IDs.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_nof_ecmp_banks_extended_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp_banks_extended;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x2000/0x800;

    /* Set value */
    define->data = 0x2000/0x800;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define first_valid_ecmp_group_id
 * define info:
 * The ID of the first valid ECMP group which can be created
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_first_valid_ecmp_group_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_first_valid_ecmp_group_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_ecmp
 * define info:
 * Number of ECMPs in the system.
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_ecmp_nof_ecmp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_ecmp;
    int define_index = dnx_data_l3_ecmp_define_nof_ecmp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xA000;

    /* Set value */
    define->data = 0xA000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: source_address_ethernet
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_mymac_prefixes
 * define info:
 * Number of mymac prefixes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_source_address_ethernet;
    int define_index = dnx_data_l3_source_address_ethernet_define_nof_mymac_prefixes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: vrrp
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_protocol_groups
 * define info:
 * Number of L3 protocol groups
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrrp_nof_protocol_groups_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_nof_protocol_groups;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_tcam_entries
 * define info:
 * Size of VRRP TCAM table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrrp_nof_tcam_entries_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_nof_tcam_entries;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_vsi_tcam_entries
 * define info:
 * Number of enries in VRRP TCAM table that can be used by VSI table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrrp_nof_vsi_tcam_entries_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_nof_vsi_tcam_entries;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_vrid_ipv4_tcam_index
 * define info:
 * TCAM index for EXEM VRRP VRID IPv4 protocol
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_vrid_ipv4_tcam_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_vrid_ipv6_tcam_index
 * define info:
 * TCAM index for EXEM VRRP VRID IPv6 protocol
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_vrid_ipv6_tcam_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 17;

    /* Set value */
    define->data = 17;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_vrid_ip_tcam_index
 * define info:
 * TCAM index for EXEM VRRP VRID IPv6 and IPv4 protocols
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrrp_exem_vrid_ip_tcam_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_vrid_ip_tcam_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 18;

    /* Set value */
    define->data = 18;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_default_tcam_index
 * define info:
 * TCAM index for EXEM VSI LSB or SOURCE-PORT multiple my mac
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrrp_exem_default_tcam_index_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_default_tcam_index;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 19;

    /* Set value */
    define->data = 19;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define exem_default_tcam_index_msb
 * define info:
 * TCAM index for EXEM VSI MSB multiple my mac
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_vrrp_exem_default_tcam_index_msb_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_vrrp;
    int define_index = dnx_data_l3_vrrp_define_exem_default_tcam_index_msb;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: hw_bug
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_hw_bug_ipv6_mc_compatible_dmac_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_hw_bug;
    int feature_index = dnx_data_l3_hw_bug_ipv6_mc_compatible_dmac;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jer2_a0_dnx_data_l3_hw_bug_fec_hit_bit_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_l3;
    int submodule_index = dnx_data_l3_submodule_hw_bug;
    int feature_index = dnx_data_l3_hw_bug_fec_hit_bit;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jer2_a0_data_l3_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_l3;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: egr_pointed
     */
    submodule_index = dnx_data_l3_submodule_egr_pointed;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_egr_pointed_define_nof_bits_in_egr_pointed_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_set;
    data_index = dnx_data_l3_egr_pointed_define_nof_egr_pointed_ids;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_egr_pointed_nof_egr_pointed_ids_set;
    data_index = dnx_data_l3_egr_pointed_define_first_egr_pointed_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_egr_pointed_first_egr_pointed_id_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: fec
     */
    submodule_index = dnx_data_l3_submodule_fec;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_fec_define_nof_fecs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_nof_fecs_set;
    data_index = dnx_data_l3_fec_define_max_fec_id_26k_granularity;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_max_fec_id_26k_granularity_set;
    data_index = dnx_data_l3_fec_define_max_fec_id_52k_granularity;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_max_fec_id_52k_granularity_set;
    data_index = dnx_data_l3_fec_define_max_default_fec;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_max_default_fec_set;
    data_index = dnx_data_l3_fec_define_fec_stage_map_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_fec_stage_map_size_set;
    data_index = dnx_data_l3_fec_define_max_fec_stage_map_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_max_fec_stage_map_size_set;
    data_index = dnx_data_l3_fec_define_nof_super_fecs_per_bank;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_nof_super_fecs_per_bank_set;
    data_index = dnx_data_l3_fec_define_nof_physical_fecs_per_bank;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_nof_physical_fecs_per_bank_set;
    data_index = dnx_data_l3_fec_define_super_fec_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_super_fec_size_set;
    data_index = dnx_data_l3_fec_define_fec_row_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_fec_row_size_set;
    data_index = dnx_data_l3_fec_define_fec_max_nof_banks;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_fec_max_nof_banks_set;
    data_index = dnx_data_l3_fec_define_first_bank_without_id_alloc;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_first_bank_without_id_alloc_set;
    data_index = dnx_data_l3_fec_define_max_super_fec_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fec_max_super_fec_id_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: source_address
     */
    submodule_index = dnx_data_l3_submodule_source_address;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_source_address_define_source_address_table_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_source_address_source_address_table_size_set;
    data_index = dnx_data_l3_source_address_define_custom_sa_use_dual_homing;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_source_address_custom_sa_use_dual_homing_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: vrf
     */
    submodule_index = dnx_data_l3_submodule_vrf;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_vrf_define_nof_vrf;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrf_nof_vrf_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: routing_enablers
     */
    submodule_index = dnx_data_l3_submodule_routing_enablers;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_routing_enablers_define_nof_routing_enablers_profiles;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_routing_enablers_nof_routing_enablers_profiles_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: rif
     */
    submodule_index = dnx_data_l3_submodule_rif;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_rif_define_max_nof_rifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_rif_max_nof_rifs_set;
    data_index = dnx_data_l3_rif_define_nof_rifs;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_rif_nof_rifs_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: fwd
     */
    submodule_index = dnx_data_l3_submodule_fwd;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_fwd_define_max_mc_group_lpm;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fwd_max_mc_group_lpm_set;
    data_index = dnx_data_l3_fwd_define_max_mc_group_em;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fwd_max_mc_group_em_set;
    data_index = dnx_data_l3_fwd_define_nof_my_mac_prefixes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_fwd_nof_my_mac_prefixes_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: ecmp
     */
    submodule_index = dnx_data_l3_submodule_ecmp;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_ecmp_define_max_group_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_max_group_size_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp_per_bank_of_low_ecmps;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_nof_ecmp_per_bank_of_low_ecmps_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp_basic_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_nof_ecmp_basic_mode_set;
    data_index = dnx_data_l3_ecmp_define_total_nof_ecmp;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_total_nof_ecmp_set;
    data_index = dnx_data_l3_ecmp_define_max_ecmp_basic_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_max_ecmp_basic_mode_set;
    data_index = dnx_data_l3_ecmp_define_max_ecmp_extended_mode;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_max_ecmp_extended_mode_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp_per_bank_of_extended_ecmps;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_nof_ecmp_per_bank_of_extended_ecmps_set;
    data_index = dnx_data_l3_ecmp_define_nof_fec_banks_per_extended_ecmp_bank;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_nof_fec_banks_per_extended_ecmp_bank_set;
    data_index = dnx_data_l3_ecmp_define_nof_group_profiles_per_hierarchy;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_set;
    data_index = dnx_data_l3_ecmp_define_members_table_size_in_bits;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_members_table_size_in_bits_set;
    data_index = dnx_data_l3_ecmp_define_ecmp_stage_map_size;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_ecmp_stage_map_size_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp_banks_basic;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_nof_ecmp_banks_basic_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp_banks_extended;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_nof_ecmp_banks_extended_set;
    data_index = dnx_data_l3_ecmp_define_first_valid_ecmp_group_id;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_first_valid_ecmp_group_id_set;
    data_index = dnx_data_l3_ecmp_define_nof_ecmp;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_ecmp_nof_ecmp_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: source_address_ethernet
     */
    submodule_index = dnx_data_l3_submodule_source_address_ethernet;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_source_address_ethernet_define_nof_mymac_prefixes;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: vrrp
     */
    submodule_index = dnx_data_l3_submodule_vrrp;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_l3_vrrp_define_nof_protocol_groups;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrrp_nof_protocol_groups_set;
    data_index = dnx_data_l3_vrrp_define_nof_tcam_entries;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrrp_nof_tcam_entries_set;
    data_index = dnx_data_l3_vrrp_define_nof_vsi_tcam_entries;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrrp_nof_vsi_tcam_entries_set;
    data_index = dnx_data_l3_vrrp_define_exem_vrid_ipv4_tcam_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_set;
    data_index = dnx_data_l3_vrrp_define_exem_vrid_ipv6_tcam_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_set;
    data_index = dnx_data_l3_vrrp_define_exem_vrid_ip_tcam_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrrp_exem_vrid_ip_tcam_index_set;
    data_index = dnx_data_l3_vrrp_define_exem_default_tcam_index;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrrp_exem_default_tcam_index_set;
    data_index = dnx_data_l3_vrrp_define_exem_default_tcam_index_msb;
    define = &submodule->defines[data_index];
    define->set = jer2_a0_dnx_data_l3_vrrp_exem_default_tcam_index_msb_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: hw_bug
     */
    submodule_index = dnx_data_l3_submodule_hw_bug;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */

    /*
     * Attach features: 
     */
    data_index = dnx_data_l3_hw_bug_ipv6_mc_compatible_dmac;
    feature = &submodule->features[data_index];
    feature->set = jer2_a0_dnx_data_l3_hw_bug_ipv6_mc_compatible_dmac_set;
    data_index = dnx_data_l3_hw_bug_fec_hit_bit;
    feature = &submodule->features[data_index];
    feature->set = jer2_a0_dnx_data_l3_hw_bug_fec_hit_bit_set;

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
/* *INDENT-ON* */
