/** \file dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition.c
 * Logical DB enums \n 
 * DO NOT EDIT THIS FILE!\n 
 * This file is auto-generated.\n 
 * Edits to this file will be lost when it is regenerated.\n 
 * \n 
 */
/*
 * $Id: $
 $Copyright: (c) 2018 Broadcom.
 Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 */
#ifdef BSL_LOG_MODULE
#  error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SOCDNX_DBALDNX

#include <src/soc/dnx/dbal/dbal_internal.h>

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_profile_map_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_PROFILE_MAP" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "QUEUE_ID" /* name*/, NULL /* Valid*/, "16" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: PROFILE_ID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PROFILE_ID" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QTYPEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = QTYPE_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "QUEUE_ID/8" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "QUEUE_ID%8*5" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_profile_general_config_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_PROFILE_GENERAL_CONFIG" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_LOW_DELAY" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_HIGH_PRIORITY" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BW_LEVEL" /* name*/, NULL /* Valid*/, "2" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_OCB_ONLY" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CREDIT_BALANCE_RESOLUTION" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "IQS_CREDIT_BALANCE_RESOLUTION" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: IS_LOW_DELAY  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_LOW_DELAY" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_MULT_PKT_DEQ_SETTINGSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MUL_PKT_DEQ_ENf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "PROFILE_ID" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_HIGH_PRIORITY  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_HIGH_PRIORITY" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QUEUE_IS_HIGH_PRIORITYr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = QUEUE_IS_HIGH_PRIORITYf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "PROFILE_ID" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BW_LEVEL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BW_LEVEL" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQM_MAX_DEQ_CMD_CRDT_SELr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQM_MAX_DEQ_CMD_CRDT_SELf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "PROFILE_ID*2" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BW_LEVEL" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_MAX_DEQ_CMD_CRDT_SELr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SQM_MAX_DEQ_CMD_CRDT_SELf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "PROFILE_ID*2" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_OCB_ONLY  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_OCB_ONLY" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QUEUE_IS_OCB_ONLYr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = QUEUE_IS_OCB_ONLYf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "PROFILE_ID" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CREDIT_BALANCE_RESOLUTION  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CREDIT_BALANCE_RESOLUTION" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CREDIT_BALANCE_RESOLUTION_REGISTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CREDIT_BALANCE_RESOLUTIONf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "PROFILE_ID*2" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_push_queue_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_PUSH_QUEUE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ENABLE" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: PROFILE_ID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PROFILE_ID" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_PUSH_QUEUE_TYPES_CONFIGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PUSH_QUEUE_TYPEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ENABLE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_PUSH_QUEUE_TYPES_CONFIGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PUSH_QUEUE_TYPE_ENf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_satisfied_thresholds_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_SATISFIED_THRESHOLDS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BACKOFF_ENTER" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BACKOFF_EXIT" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BACKLOG_ENTER" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BACKLOG_EXIT" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BACKSLOW_ENTER" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BACKSLOW_EXIT" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EMPTY_QUEUE" /* name*/, NULL /* Valid*/, "17" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EMPTY_QUEUE_SIGN" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EMPTY_QUEUE_MAX" /* name*/, NULL /* Valid*/, "17" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EMPTY_QUEUE_MAX_SIGN" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EMPTY_QUEUE_EXCEED" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: BACKOFF_ENTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BACKOFF_ENTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BACKOFF_ENTER_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BACKOFF_EXIT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BACKOFF_EXIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BACKOFF_EXIT_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BACKLOG_ENTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BACKLOG_ENTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BACKLOG_ENTER_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BACKLOG_EXIT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BACKLOG_EXIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BACKLOG_EXIT_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BACKSLOW_ENTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BACKSLOW_ENTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BACKSLOW_ENTER_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BACKSLOW_EXIT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BACKSLOW_EXIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BACKSLOW_EXIT_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EMPTY_QUEUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EMPTY_QUEUE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_EMPTY_Q_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SATISFIED_CRBALf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EMPTY_QUEUE_SIGN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EMPTY_QUEUE_SIGN" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_EMPTY_Q_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SATISFIED_CRBAL_SIGNf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EMPTY_QUEUE_MAX  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EMPTY_QUEUE_MAX" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_EMPTY_Q_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MAX_EMPTY_Q_CRBALf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EMPTY_QUEUE_MAX_SIGN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EMPTY_QUEUE_MAX_SIGN" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_EMPTY_Q_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MAX_EMPTY_Q_CRBAL_SIGNf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EMPTY_QUEUE_EXCEED  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EMPTY_QUEUE_EXCEED" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_EMPTY_Q_CRBAL_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EXCEED_MAX_EMPTY_Q_CRBALf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_hungry_thresholds_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_HUNGRY_THRESHOLDS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MULT" /* name*/, NULL /* Valid*/, "4" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OFF_TO_SLOW" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OFF_TO_SLOW_SIGN" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OFF_TO_NORM" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OFF_TO_NORM_SIGN" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SLOW_TO_NORM" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SLOW_TO_NORM_SIGN" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "NORM_TO_SLOW" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "NORM_TO_SLOW_SIGN" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MULT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MULT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = FSM_TH_MULf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OFF_TO_SLOW  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OFF_TO_SLOW" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OFF_TO_SLOW_MSG_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OFF_TO_SLOW_SIGN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OFF_TO_SLOW_SIGN" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OFF_TO_SLOW_MSG_TH_SIGNf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OFF_TO_NORM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OFF_TO_NORM" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OFF_TO_NORM_MSG_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OFF_TO_NORM_SIGN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OFF_TO_NORM_SIGN" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OFF_TO_NORM_MSG_TH_SIGNf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: SLOW_TO_NORM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SLOW_TO_NORM" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SLOW_TO_NORM_MSG_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: SLOW_TO_NORM_SIGN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SLOW_TO_NORM_SIGN" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = SLOW_TO_NORM_MSG_TH_SIGNf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: NORM_TO_SLOW  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "NORM_TO_SLOW" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = NORM_TO_SLOW_MSG_THf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: NORM_TO_SLOW_SIGN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "NORM_TO_SLOW_SIGN" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_QSIZE_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = NORM_TO_SLOW_MSG_TH_SIGNf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_slow_factor_up_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_SLOW_FACTOR_UP" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SRC_SLOW_LEVEL" /* name*/, NULL /* Valid*/, "3" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SLOW_FACTOR_UP" /* name*/, NULL /* Valid*/, "12" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: SLOW_FACTOR_UP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SLOW_FACTOR_UP" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SLOW_FACTOR_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "SRC_SLOW_LEVEL*12" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_slow_factor_down_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_SLOW_FACTOR_DOWN" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DEST_SLOW_LEVEL" /* name*/, NULL /* Valid*/, "3" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SLOW_FACTOR_DOWN" /* name*/, NULL /* Valid*/, "12" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: SLOW_FACTOR_DOWN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SLOW_FACTOR_DOWN" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SLOW_FACTOR_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "DEST_SLOW_LEVEL*12+72" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_max_deq_cmds_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_MAX_DEQ_CMDS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BW_LEVEL" /* name*/, NULL /* Valid*/, "2" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ACTIVE_QUEUES" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "IQS_ACTIVE_QUEUES" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MAX_DEQ_CMD" /* name*/, NULL /* Valid*/, "9" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MAX_DEQ_CMD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MAX_DEQ_CMD" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQM_MAX_DEQ_CMD_CRDTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "ACTIVE_QUEUES*9+BW_LEVEL*36" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MAX_DEQ_CMD" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_MAX_DEQ_CMD_CRDTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "ACTIVE_QUEUES*9+BW_LEVEL*36" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_s2d_max_deq_cmds_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_S2D_MAX_DEQ_CMDS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BW_LEVEL" /* name*/, NULL /* Valid*/, "2" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ACTIVE_QUEUES" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "IQS_ACTIVE_QUEUES" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MAX_DEQ_CMD" /* name*/, NULL /* Valid*/, "9" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MAX_DEQ_CMD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MAX_DEQ_CMD" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SRAM_TO_DRAM_MAX_DEQ_CMD_CRDTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "ACTIVE_QUEUES*9+BW_LEVEL*36" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_deq_params_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_DEQ_PARAMS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BW_LEVEL" /* name*/, NULL /* Valid*/, "2" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CREDIT_BALANCE_MSB" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SRAM_READ_WEIGHT_PROFILE" /* name*/, NULL /* Valid*/, "3" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "S2D_READ_WEIGHT_PROFILE" /* name*/, NULL /* Valid*/, "3" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DRAM_READ_WEIGHT_PROFILE" /* name*/, NULL /* Valid*/, "3" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SRAM_DEQ_EXTRA_CREDITS" /* name*/, NULL /* Valid*/, "4" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "S2D_DEQ_EXTRA_CREDITS" /* name*/, NULL /* Valid*/, "4" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SRAM_DEQ_EXTRA_CREDITS_LFSR" /* name*/, NULL /* Valid*/, "4" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "S2D_DEQ_EXTRA_CREDITS_LFSR" /* name*/, NULL /* Valid*/, "4" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: SRAM_READ_WEIGHT_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SRAM_READ_WEIGHT_PROFILE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_DEQ_CMD_PRMSm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = READ_WEIGHT_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "CREDIT_BALANCE_MSB*4+BW_LEVEL" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: S2D_READ_WEIGHT_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "S2D_READ_WEIGHT_PROFILE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_DEQ_CMD_PRMSm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = READ_WEIGHT_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "128+CREDIT_BALANCE_MSB*4+BW_LEVEL" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DRAM_READ_WEIGHT_PROFILE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DRAM_READ_WEIGHT_PROFILE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQM_DEQ_CMD_PRMSm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = READ_WEIGHT_PROFILEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "CREDIT_BALANCE_MSB*4+BW_LEVEL" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: SRAM_DEQ_EXTRA_CREDITS  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SRAM_DEQ_EXTRA_CREDITS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_DEQ_CMD_PRMSm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EXTRA_CREDITSf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "CREDIT_BALANCE_MSB*4+BW_LEVEL" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: S2D_DEQ_EXTRA_CREDITS  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "S2D_DEQ_EXTRA_CREDITS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_DEQ_CMD_PRMSm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EXTRA_CREDITSf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "128+CREDIT_BALANCE_MSB*4+BW_LEVEL" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: SRAM_DEQ_EXTRA_CREDITS_LFSR  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SRAM_DEQ_EXTRA_CREDITS_LFSR" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_DEQ_CMD_PRMSm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EXTRA_CREDITS_LFSR_MASKf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "CREDIT_BALANCE_MSB*4+BW_LEVEL" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: S2D_DEQ_EXTRA_CREDITS_LFSR  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "S2D_DEQ_EXTRA_CREDITS_LFSR" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_DEQ_CMD_PRMSm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EXTRA_CREDITS_LFSR_MASKf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "128+CREDIT_BALANCE_MSB*4+BW_LEVEL" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_queue_read_weight_profile_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_QUEUE_READ_WEIGHT_PROFILE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "3" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SQM_READ_WEIGHT" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DQM_READ_WEIGHT" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: SQM_READ_WEIGHT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "SQM_READ_WEIGHT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_SQM_DEQ_CMD_READ_WEIGHT_PROFILE_MAPm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = READ_WEIGHTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DQM_READ_WEIGHT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DQM_READ_WEIGHT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQM_DEQ_CMD_READ_WEIGHT_PROFILE_MAPm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = READ_WEIGHTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_low_delay_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_LOW_DELAY" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DEQUEUE_BYTES" /* name*/, NULL /* Valid*/, "8" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: DEQUEUE_BYTES  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "DEQUEUE_BYTES" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_MULT_PKT_DEQ_SETTINGSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MUL_PKT_DEQ_BYTESf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_fmq_th_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_REQUEST_FMQ_TH" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CREDIT_ON_TH" /* name*/, NULL /* Valid*/, "13" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CREDIT_OFF_TH" /* name*/, NULL /* Valid*/, "13" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BYTE_ON_TH" /* name*/, NULL /* Valid*/, "21" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "BYTE_OFF_TH" /* name*/, NULL /* Valid*/, "21" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EIR_CREDIT_ON_TH" /* name*/, NULL /* Valid*/, "13" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EIR_CREDIT_OFF_TH" /* name*/, NULL /* Valid*/, "13" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EIR_BYTE_ON_TH" /* name*/, NULL /* Valid*/, "21" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EIR_BYTE_OFF_TH" /* name*/, NULL /* Valid*/, "21" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: CREDIT_ON_TH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CREDIT_ON_TH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQCQ_FMC_FC_THr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQCQ_FMC_FC_SET_TH_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CREDIT_OFF_TH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CREDIT_OFF_TH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQCQ_FMC_FC_THr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQCQ_FMC_FC_CLR_TH_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BYTE_ON_TH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BYTE_ON_TH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_FMC_FC_BYTES_THr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQCQ_FMC_FC_SET_BYTES_TH_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BYTE_OFF_TH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "BYTE_OFF_TH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_FMC_FC_BYTES_THr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQCQ_FMC_FC_CLR_BYTES_TH_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EIR_CREDIT_ON_TH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EIR_CREDIT_ON_TH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQCQ_EIR_FC_THr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQCQ_EIR_FC_SET_TH_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EIR_CREDIT_OFF_TH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EIR_CREDIT_OFF_TH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQCQ_EIR_FC_THr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQCQ_EIR_FC_CLR_TH_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EIR_BYTE_ON_TH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EIR_BYTE_ON_TH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQCQ_EIR_FC_BYTES_THr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQCQ_EIR_FC_SET_BYTES_TH_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: EIR_BYTE_OFF_TH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "EIR_BYTE_OFF_TH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_DQCQ_EIR_FC_BYTES_THr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DQCQ_EIR_FC_CLR_BYTES_TH_Nf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_watchdog_common_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_WATCHDOG_COMMON" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FIRST_QUEUE" /* name*/, NULL /* Valid*/, "16" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "LAST_QUEUE" /* name*/, NULL /* Valid*/, "16" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FSM_SHAPER" /* name*/, NULL /* Valid*/, "11" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MIN_CYCLE_PERIOD" /* name*/, NULL /* Valid*/, "15" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CYCLES_FOR_RETRANSMIT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "IQS_WATCHDOG_CYCLES" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ENABLE_EXP_MODE" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: FIRST_QUEUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "FIRST_QUEUE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRDT_WD_SCAN_RANGEr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CRDT_WD_START_QNUMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAST_QUEUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "LAST_QUEUE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRDT_WD_SCAN_RANGEr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CRDT_WD_END_QNUMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: FSM_SHAPER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "FSM_SHAPER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CREDIT_WATCHDOG_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CRDT_WD_MAX_FLOW_MSG_GEN_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MIN_CYCLE_PERIOD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "MIN_CYCLE_PERIOD" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CREDIT_WATCHDOG_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CRDT_WD_MIN_SCAN_CYCLE_PERIODf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CYCLES_FOR_RETRANSMIT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CYCLES_FOR_RETRANSMIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CREDIT_WATCHDOG_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CRDT_WD_FSM_MODEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: ENABLE_EXP_MODE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ENABLE_EXP_MODE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CREDIT_WATCHDOG_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CRDT_WD_DELETE_Q_EXP_MODEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_watchdog_profile_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_WATCHDOG_PROFILE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PROFILE_ID" /* name*/, NULL /* Valid*/, "5" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DELETE_EXP" /* name*/, NULL /* Valid*/, "4" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DELETE_MANT" /* name*/, NULL /* Valid*/, "4" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_packed_field(unit, access_params, "0" /* field size*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRDT_WD_THm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = STATUS_MSG_GEN_PERIODf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "PROFILE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_worth_config_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_WORTH_CONFIG" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ENABLE" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ENABLE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CREDIT_VALUE_CONFIGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CRDT_VALUE_SEL_ENABLEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_worth_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_WORTH" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CREDIT_WORTH_GROUP_ID" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CREDIT_WORTH" /* name*/, NULL /* Valid*/, "13" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: CREDIT_WORTH  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CREDIT_WORTH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CREDIT_WORTH_GROUP_ID" /* field*/, "0" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CREDIT_CONFIGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CREDIT_VALUE_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CREDIT_WORTH" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "CREDIT_WORTH_GROUP_ID" /* field*/, "1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CREDIT_CONFIGr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CREDIT_VALUE_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_worth_groups_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_CREDIT_WORTH_GROUPS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FAP_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CREDIT_WORTH_GROUP_ID" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: CREDIT_WORTH_GROUP_ID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CREDIT_WORTH_GROUP_ID" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_CRDT_VALUE_SELm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CRDT_VALUE_BMPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "FAP_ID/16" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "FAP_ID%16" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_fsm_reorder_config_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_FSM_REORDER_CONFIG" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PER_FAP_ENABLE" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "AGING_TIMER" /* name*/, NULL /* Valid*/, "4" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: PER_FAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PER_FAP_ENABLE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, "BITWISE_NOT" /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = FCR_EFMS_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EFMS_BYPASS_ENABLEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PER_FAP_ENABLE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_FMS_PARAMETERSr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = FMS_ENABLE_BYPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: AGING_TIMER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "AGING_TIMER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = FCR_EFMS_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EFMS_AGING_TIMERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_fsm_reorder_fap_mode_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_FSM_REORDER_FAP_MODE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "FAP_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_SEQ" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: IS_SEQ  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_SEQ" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, "BITWISE_NOT" /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = FCR_EFMS_SOURCE_PIPEm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "FAP_ID/8" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "FAP_ID%8" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_SEQ" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_FMS_BYPASSm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = FMS_BYPASS_BMPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "FAP_ID/16" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "FAP_ID%16" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_debug_auto_credit_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_DEBUG_AUTO_CREDIT" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "QUEUE_MIN" /* name*/, NULL /* Valid*/, "16" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "QUEUE_MAX" /* name*/, NULL /* Valid*/, "16" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ENABLE_AUTO_CREDIT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "IQS_ENABLE_AUTO_CREDIT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: QUEUE_MIN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "QUEUE_MIN" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_AUTO_CREDIT_MECHANISM_RANGEr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = AUTO_CRDT_FIRST_QUEUEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: QUEUE_MAX  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "QUEUE_MAX" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_AUTO_CREDIT_MECHANISM_RANGEr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = AUTO_CRDT_LAST_QUEUEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: ENABLE_AUTO_CREDIT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ENABLE_AUTO_CREDIT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_AUTO_CREDIT_MECHANISM_RATEr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = AUTO_CRDT_RATEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_dqcq_flow_control_mask_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_DQCQ_FLOW_CONTROL_MASK" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SRAM_TO_DRAM" /* name*/, NULL /* Valid*/, "2" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SRAM_DELETE" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "DRAM_DELETE" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OCB_ONLY" /* name*/, NULL /* Valid*/, "10" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "SRAM" /* name*/, NULL /* Valid*/, "10" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MIXED_SRAM" /* name*/, NULL /* Valid*/, "10" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "MIXED_DRAM" /* name*/, NULL /* Valid*/, "10" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** indicate that the access has packedFields  */
        cur_table_param->hl_access[map_idx].is_packed_fields = TRUE;
        /** update access mapping in hl_access struct for the current packed fields  */
        /** set (hl direct) accesses for packed field  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_packed_field(unit, access_params, "0" /* field size*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_AUTO_DOC_NAME_31r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = AUTO_DOC_NAME_32f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_voq_state_info_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "IQS_VOQ_STATE_INFO" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "IQS" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CORE_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "VOQ" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "QUEUE_CREDIT_REQUEST_STATE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "QUEUE_CREDIT_BALANCE" /* name*/, NULL /* Valid*/, "18" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "DPC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: QUEUE_CREDIT_REQUEST_STATE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "QUEUE_CREDIT_REQUEST_STATE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_AUTO_DOC_NAME_55m;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ITEM_0_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: QUEUE_CREDIT_BALANCE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "QUEUE_CREDIT_BALANCE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPS_AUTO_DOC_NAME_55m;
                    /** set field hw Entity id  */
                    fieldHwEntityId = ITEM_14_31f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_init(
int unit,
table_db_struct_t* cur_table_param,
dbal_logical_table_t * table_info)
{
    SHR_FUNC_INIT_VARS(unit);
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_profile_map_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_profile_general_config_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_push_queue_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_satisfied_thresholds_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_hungry_thresholds_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_slow_factor_up_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_slow_factor_down_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_max_deq_cmds_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_s2d_max_deq_cmds_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_deq_params_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_queue_read_weight_profile_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_low_delay_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_request_fmq_th_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_watchdog_common_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_watchdog_profile_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_worth_config_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_worth_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_credit_worth_groups_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_fsm_reorder_config_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_fsm_reorder_fap_mode_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_debug_auto_credit_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_dqcq_flow_control_mask_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_iqs_definition_iqs_voq_state_info_init(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}
