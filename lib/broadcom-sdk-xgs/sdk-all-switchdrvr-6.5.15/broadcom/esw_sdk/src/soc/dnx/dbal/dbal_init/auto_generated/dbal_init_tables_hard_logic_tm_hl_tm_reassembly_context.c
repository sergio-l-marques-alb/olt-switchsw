/** \file dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context.c
 * Logical DB enums \n 
 * DO NOT EDIT THIS FILE!\n 
 * This file is auto-generated.\n 
 * Edits to this file will be lost when it is regenerated.\n 
 * \n 
 */
/*
 * $Id: $
 $Copyright: (c) 2018 Broadcom.
 Broadcom Proprietary and Confidential. All rights reserved.$
 * 
 */
#ifdef BSL_LOG_MODULE
#  error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_SOCDNX_DBALDNX

#include <src/soc/dnx/dbal/dbal_internal.h>

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_port_to_context_map_base_address_table_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "INGR_REASSEMBLY_PORT_TO_CONTEXT_MAP_BASE_ADDRESS_TABLE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "ITM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CORE_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "INGRESS_REASSEMBLY_INTERFACE" /* name*/, NULL /* Valid*/, "DNX_DATA.ingr_reassembly.dbal.interface_bits" /* Size*/, NULL /* Offset*/, "DNX_DATA.ingr_reassembly.dbal.interface_max" /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* name*/, NULL /* Valid*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_bits" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "IS_INTERLEAVED" /* name*/, NULL /* Valid*/, "1" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "INTERLEAVED_INTERFACE_ID" /* name*/, NULL /* Valid*/, "DNX_DATA.ingr_reassembly.dbal.interleaved_interface_bits" /* Size*/, NULL /* Offset*/, "DNX_DATA.ingr_reassembly.dbal.interleaved_interface_max" /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    if (DBAL_IS_J2A0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        sal_strncpy(cur_table_param->core_mode, "DPC", sizeof(cur_table_param->core_mode));
        /** reference field  */
        sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDm;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_PORT_TO_BASE_ADDRESS_MAPm;
                        /** set field hw Entity id  */
                        fieldHwEntityId = CTXT_MAP_BASE_ADDRESSf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
            }
            /** set (hl direct) accesses for field: IS_INTERLEAVED  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_INTERLEAVED" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDm;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_PORT_TO_BASE_ADDRESS_MAPm;
                        /** set field hw Entity id  */
                        fieldHwEntityId = NIF_PORT_IS_CHANNELIZEDf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
            }
            /** set (hl direct) accesses for field: INTERLEAVED_INTERFACE_ID  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "INTERLEAVED_INTERFACE_ID" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDm;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_PORT_TO_BASE_ADDRESS_MAPm;
                        /** set field hw Entity id  */
                        fieldHwEntityId = NIF_PORT_TO_CTXT_BIT_MAP_ADDRESSf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    else
    {
        /** set app to phy db general information  */
        /** core mode  */
        sal_strncpy(cur_table_param->core_mode, "DPC", sizeof(cur_table_param->core_mode));
        /** reference field  */
        sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDm;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_NIF_PORT_ATTRm;
                        /** set field hw Entity id  */
                        fieldHwEntityId = CTXT_MAP_BASE_ADDRESSf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
            }
            /** set (hl direct) accesses for field: IS_INTERLEAVED  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "IS_INTERLEAVED" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDm;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_NIF_PORT_ATTRm;
                        /** set field hw Entity id  */
                        fieldHwEntityId = NIF_PORT_IS_CHANNELIZEDf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
            }
            /** set (hl direct) accesses for field: INTERLEAVED_INTERFACE_ID  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "INTERLEAVED_INTERFACE_ID" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDm;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_NIF_PORT_ATTRm;
                        /** set field hw Entity id  */
                        fieldHwEntityId = NIF_PORT_TO_CTXT_BIT_MAP_ADDRESSf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_context_map_table_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "INGR_REASSEMBLY_CONTEXT_MAP_TABLE" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "ITM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CORE_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* name*/, NULL /* Valid*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_bits+1" /* Size*/, NULL /* Offset*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+3" /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "REASSEMBLY_CONTEXT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "PORT_TERMINATION_CONTEXT" /* name*/, NULL /* Valid*/, "8" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "DPC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: REASSEMBLY_CONTEXT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* field*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+3" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_EVENTOR_REASSEMBLY_CONTEXT_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EVENTOR_REASSEMBLY_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* field*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+2" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_OAMP_REASSEMBLY_CONTEXT_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OAMP_REASSEMBLY_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* field*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_OLP_REASSEMBLY_CONTEXT_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OLP_REASSEMBLY_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "LOWER_THAN" /* type*/, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* field*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_CTXT_MAPm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = REASSEMBLY_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: PORT_TERMINATION_CONTEXT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PORT_TERMINATION_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* field*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+3" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_EVENTOR_REASSEMBLY_CONTEXT_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = EVENTOR_PORT_TERMINATION_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PORT_TERMINATION_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* field*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+2" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_OAMP_REASSEMBLY_CONTEXT_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OAMP_PORT_TERMINATION_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PORT_TERMINATION_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* field*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_OLP_REASSEMBLY_CONTEXT_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OLP_PORT_TERMINATION_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "PORT_TERMINATION_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "LOWER_THAN" /* type*/, "REASSEMBLY_CONTEXT_MAP_OFFSET_EXT" /* field*/, "DNX_DATA.ingr_reassembly.dbal.context_map_base_address_max+1" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_CTXT_MAPm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = PORT_TERMINATION_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_tdm_context_map_table_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "INGR_REASSEMBLY_TDM_CONTEXT_MAP_TABLE" /* name*/, "DNX_DATA.egr_queuing.params.tdm_exist" /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "ITM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CORE_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "EXTENDED_PHY_INDEX" /* name*/, NULL /* Valid*/, "8" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "TDM_CONTEXT" /* name*/, NULL /* Valid*/, "9" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "DPC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: TDM_CONTEXT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                int condition_index;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "TDM_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** add conditions  */
                condition_index = 0;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "LOWER_THAN" /* type*/, "EXTENDED_PHY_INDEX" /* field*/, "256" /* value*/, EMPTY /* enum value*/));
                condition_index++;
                access_params->nof_conditions = condition_index;
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_CPU_TDM_CTXT_MAPm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = TDM_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "EXTENDED_PHY_INDEX-0" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_interleaved_reassembly_context_bitmap_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "INGR_REASSEMBLY_INTERLEAVED_REASSEMBLY_CONTEXT_BITMAP" /* name*/, "DNX_DATA.ingr_reassembly.ilkn.is_supported" /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "ITM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CORE_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "INTERLEAVED_INTERFACE_ID" /* name*/, NULL /* Valid*/, "DNX_DATA.ingr_reassembly.dbal.interleaved_interface_bits" /* Size*/, NULL /* Offset*/, "DNX_DATA.ingr_reassembly.dbal.interleaved_interface_max" /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        key_field_counter++;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "REASSEMBLY_CONTEXT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "ACTIVE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "DPC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: ACTIVE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "ACTIVE" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_NIF_PORT_TO_CTXT_BIT_MAPm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CONTEXTS_BIT_MAPPINGf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "INTERLEAVED_INTERFACE_ID" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, "REASSEMBLY_CONTEXT" /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_special_interface_base_address_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "INGR_REASSEMBLY_SPECIAL_INTERFACE_BASE_ADDRESS" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "ITM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "REASSEMBLY_SPECIAL_INTERFACE_TYPE" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* name*/, NULL /* Valid*/, "12" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "UINT" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    if (DBAL_IS_J2A0)
    {
        /** set app to phy db general information  */
        /** core mode  */
        sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
        /** reference field  */
        sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDm;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_PORT_TO_BASE_ADDRESS_MAPm;
                        /** set field hw Entity id  */
                        fieldHwEntityId = CTXT_MAP_BASE_ADDRESSf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, "REASSEMBLY_SPECIAL_INTERFACE_TYPE" /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    else
    {
        /** set app to phy db general information  */
        /** core mode  */
        sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
        /** reference field  */
        sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
        /** build access hl direct  */
        {
            int map_idx;
            int access_counter;
            map_idx = 0;
            access_counter = 0;
            sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
            /** set (hl direct) accesses for field: REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS  */
            {
                table_db_access_params_struct_t * access_params;
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_SPECIAL_INTERFACE_TYPE" /* field*/, NULL /* value*/, "CPU" /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_INTERFACE_BASE_ADDR_CONFIGURATIONr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = INTERFACE_CPU_BASE_ADDRf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_SPECIAL_INTERFACE_TYPE" /* field*/, NULL /* value*/, "MIRROR_LOSSLESS" /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_INTERFACE_BASE_ADDR_CONFIGURATIONr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = INTERFACE_EGQ_PRI_0_BASE_ADDRf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_SPECIAL_INTERFACE_TYPE" /* field*/, NULL /* value*/, "MIRROR_HIGH_PRIORTY" /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_INTERFACE_BASE_ADDR_CONFIGURATIONr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = INTERFACE_EGQ_PRI_1_BASE_ADDRf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_SPECIAL_INTERFACE_TYPE" /* field*/, NULL /* value*/, "MIRROR_LOW_PRIORTY" /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_INTERFACE_BASE_ADDR_CONFIGURATIONr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = INTERFACE_EGQ_PRI_2_BASE_ADDRf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_SPECIAL_INTERFACE_TYPE" /* field*/, NULL /* value*/, "RCY" /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_INTERFACE_BASE_ADDR_CONFIGURATIONr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = INTERFACE_EGQ_PRI_3_BASE_ADDRf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
                /** set access  */
                {
                    int instance_index = 0;
                    int condition_index;
                    access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                    access_counter++;
                    /** set hard logic access type  */
                    SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                    /** set access information  */
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT_MAP_BASE_ADDRESS" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                    /** add conditions  */
                    condition_index = 0;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_condition(unit, &access_params->access_condition[condition_index], "EQUAL_TO" /* type*/, "REASSEMBLY_SPECIAL_INTERFACE_TYPE" /* field*/, NULL /* value*/, "SAT" /* enum value*/));
                    condition_index++;
                    access_params->nof_conditions = condition_index;
                    /** set register/memory information for current access  */
                    {
                        int regMemHwEntityId = INVALIDr;
                        int fieldHwEntityId = INVALIDf;
                        /** set reg/mem hw Entity id  */
                        regMemHwEntityId = IRE_INTERFACE_BASE_ADDR_CONFIGURATIONr;
                        /** set field hw Entity id  */
                        fieldHwEntityId = INTERFACE_SAT_BASE_ADDRf;
                        SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                    }
                }
            }
            /** set nof access for field mapping  */
            cur_table_param->hl_access[map_idx].nof_access = access_counter;
            /** update field mapping index  */
            map_idx++;
        }
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_bad_reassembly_context_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "INGR_REASSEMBLY_BAD_REASSEMBLY_CONTEXT" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "ITM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "VALID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, "BOOL" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "REASSEMBLY_CONTEXT" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "SBC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: VALID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "VALID" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_STATIC_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BAD_REASSEMBLY_CONTEXT_VALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: REASSEMBLY_CONTEXT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REASSEMBLY_CONTEXT" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_STATIC_CONFIGURATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BAD_REASSEMBLY_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_ire_counter_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    table_db_field_params_struct_t * db_field;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, cur_table_param, "INGR_REASSEMBLY_IRE_COUNTER" /* name*/, NULL /* is valid*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    SHR_IF_ERR_EXIT(dbal_db_init_maturity_level_set(unit, cur_table_param, DBAL_MATURITY_HIGH));
    /** *************  */
    /** set interface  */
    /** *************  */
    SHR_IF_ERR_EXIT(dbal_db_init_app_db_set_interface(unit, cur_table_param, "DIRECT" /* type*/, "ITM" /* labels*/));
    /** interface keys  */
    {
        int key_field_counter = 0;
        db_field = &cur_table_param->key_fields[key_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CORE_ID" /* name*/, NULL /* Valid*/, NULL /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_ALL /* Permission*/, FALSE /* ReverseOrder*/, NULL /* Type*/));
        key_field_counter++;
        cur_table_param->nof_key_fields = key_field_counter;
    }
    /** interface results  */
    {
        int result_field_counter = 0;
        int result_type_counter = 0;
        /** interface single result  */
        sal_memset(&(cur_table_param->results_set[result_type_counter]), 0x0, sizeof(table_db_results_field_set_struct_t));
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "NIF_PACKET_COUNTER" /* name*/, NULL /* Valid*/, "64" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "ARRAY32" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "RCYH_PACKET_COUNTER" /* name*/, NULL /* Valid*/, "64" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "ARRAY32" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "RCYL_PACKET_COUNTER" /* name*/, NULL /* Valid*/, "64" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "ARRAY32" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "CPU_PACKET_COUNTER" /* name*/, NULL /* Valid*/, "64" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "ARRAY32" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OLP_PACKET_COUNTER" /* name*/, NULL /* Valid*/, "64" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "ARRAY32" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "OAMP_PACKET_COUNTER" /* name*/, NULL /* Valid*/, "64" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "ARRAY32" /* Type*/));
        result_field_counter++;
        db_field = &cur_table_param->results_set[result_type_counter].result_fields[result_field_counter];
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_field(unit, db_field, "REGISTER_INTERFACE_PACKET_COUNTER" /* name*/, NULL /* Valid*/, "64" /* Size*/, NULL /* Offset*/, NULL /* MaxValue*/, NULL /* MinValue*/, NULL /* ConstValue*/, NULL /* NofInstance*/, DBAL_PERMISSION_READONLY /* Permission*/, FALSE /* ReverseOrder*/, "ARRAY32" /* Type*/));
        result_field_counter++;
        cur_table_param->results_set[result_type_counter].nof_res_fields = result_field_counter;
        result_type_counter++;
        cur_table_param->result_type_exists = FALSE;
        cur_table_param->num_of_results_sets = result_type_counter;
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param);
    /** set app to phy db general information  */
    /** core mode  */
    sal_strncpy(cur_table_param->core_mode, "DPC", sizeof(cur_table_param->core_mode));
    /** reference field  */
    sal_strncpy(cur_table_param->reference_field_name, EMPTY /* reference field*/, sizeof(cur_table_param->reference_field_name));
    /** build access hl direct  */
    {
        int map_idx;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: NIF_PACKET_COUNTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "NIF_PACKET_COUNTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_NIF_PACKET_COUNTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = NIF_PACKET_COUNTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: RCYH_PACKET_COUNTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "RCYH_PACKET_COUNTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_RCYH_PACKET_COUNTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = RCYH_PACKET_COUNTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: RCYL_PACKET_COUNTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "RCYL_PACKET_COUNTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_RCYL_PACKET_COUNTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = RCYL_PACKET_COUNTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CPU_PACKET_COUNTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "CPU_PACKET_COUNTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_CPU_PACKET_COUNTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CPU_PACKET_COUNTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OLP_PACKET_COUNTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OLP_PACKET_COUNTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_OLP_PACKET_COUNTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OLP_PACKET_COUNTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: OAMP_PACKET_COUNTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "OAMP_PACKET_COUNTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_OAMP_PACKET_COUNTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OAMP_PACKET_COUNTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set (hl direct) accesses for field: REGISTER_INTERFACE_PACKET_COUNTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, "REGISTER_INTERFACE_PACKET_COUNTER" /* field name*/, instance_index /* instance index*/, NULL /* field size*/, NULL /* field offset*/, 0 /* is tcam*/, EMPTY /* encode type*/, NULL /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_REGISTER_INTERFACE_PACKET_COUNTERr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = REGISTER_INTERFACE_PACKET_COUNTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, EMPTY /* group name*/, regMemHwEntityId /* reg/mem hw entity id*/, EMPTY /* group offset*/, DBAL_DB_INVALID /* group offset int*/, EMPTY /* array offset*/, DBAL_DB_INVALID /* array offset int*/, EMPTY /* entry offset*/, DBAL_DB_INVALID /* entry offset int*/, EMPTY /* block index*/, DBAL_DB_INVALID /* block index int*/, EMPTY /* data offset*/, DBAL_DB_INVALID /* data offset int*/, fieldHwEntityId /* field hw entity id*/, EMPTY /* alias name*/, EMPTY /* alias offset*/, DBAL_DB_INVALID /* alias offset int*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
        /** update field mapping index  */
        map_idx++;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_init(
int unit,
table_db_struct_t* cur_table_param,
dbal_logical_table_t * table_info)
{
    SHR_FUNC_INIT_VARS(unit);
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_port_to_context_map_base_address_table_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_context_map_table_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_tdm_context_map_table_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_interleaved_reassembly_context_bitmap_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_special_interface_base_address_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_bad_reassembly_context_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_tm_hl_tm_reassembly_context_ingr_reassembly_ire_counter_init(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}
