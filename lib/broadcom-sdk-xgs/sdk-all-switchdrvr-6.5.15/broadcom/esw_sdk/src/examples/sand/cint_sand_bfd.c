/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~BFD test~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/*
*
* $Id: cint_bfd.c,v 1.15 Broadcom SDK $
* $Copyright: (c) 2018 Broadcom.
* Broadcom Proprietary and Confidential. All rights reserved.$
* 
* File: cint_bfd.c
* Purpose: Example of using BFD APIs.
*
* Usage:
* 
* 
* 
* To run IPV4 test on JR2:
* BCM.0> cd $SDK/src/examples
* BCM.0> cint sand/utility/cint_sand_utils_global.c
* BCM.0> cint sand/utility/cint_sand_utils_vlan.c
* BCM.0> cint sand/utility/cint_sand_utils_oam.c
* BCM.0> cint dpp/utility/cint_utils_global.c
* BCM.0> cint dpp/utility/cint_utils_l3.c
* BCM.0> cint dpp/utility/cint_utils_mpls.c
* BCM.0> cint dpp/utility/cint_utils_oam.c
* BCM.0> cint dpp/cint_ip_route.c
* BCM.0> cint dpp/cint_field_bfd_ipv4_single_hop.c
* BCM.0> cint dpp/cint_bfd.c
* BCM.0> cint sand/cint_sand_bfd.c
* BCM.0> cint
* bfd_local_discr = 0x300004;
* int rv;
* int unit = 0;
* int port1 = port_1;
* int port2 = port_2;
* int remote_port = -1;
* int is_extended_sip = 0;
* uint32 flags = BCM_BFD_ENDPOINT_IN_HW;
* int remote_port_fwd_strength = 0;
* rv = bfd_ipv4_run_with_defaults(unit, port1, port2, remote_port, is_extended_sip, flags, remote_port_fwd_strength, flags2);
*/

/** Global variables */

/** Server mode: when set, endpoint is created on a different device */
int is_server = 0;

int port_1 = 13; /* physical port (signal generator)*/
int port_2 = 14;

int timeout_events_count_bfd = 0;
int timeout_multi_event_count_bfd=0;
int timein_multi_event_count_bfd=0;

int tunnel_id;

int pwe_ach=1; /* May be used by PWE router alert types in Jericho, set to 1 by default*/

/** Used for egress interface */
int next_hop_mac;

/**
 * Trap code returned from creating a trap
 * for a non-accelerated endpoint
 */
int remote_gport_trap_code = 0;

/*enable bfd echo, 1- implementation without lem, 2 - implementation with lem*/
/** LEM implementation is Arad only! */
int bfd_echo=0;


/* context id initialization, will be retrieved from field_presel_fwd_layer_main */
bcm_field_context_t cint_bfd_echo_context_id_ipmf1 = BCM_FIELD_CONTEXT_ID_INVALID;
/* context priority */
bcm_field_presel_t  cint_bfd_echo_presel_id = 10;

/*enable bfd ipv4 single hop - not relevant for JR2*/
int single_hop_extended =0;

/** When set, a non-zero snoop strength is used for non-accelerated endpoints */
int use_trap_with_snoop = 0;

/* int_pri of bfd_ipv4 endpoint */
int int_pri = 0;

/** Created endpoint information */
oam__ep_info_s bfd_ep1;

/** BFD transmission period */
int bfd_tx_period = 100;

/* BFD IPv4 FLEX IPTOS */
/**
 * For Jericho2, no SOC property is needed
 * This can always be used for multi-hop.
 * For single-hop, only B0 and above.
 */
uint8 bfd_ipv4_flex_iptos = 0;

/**
 * When set, enables
 * "field group" feature
 * Not relevant for JR2
 */
int is_field_created = 0;

/* BFD local_discr */
uint32 bfd_local_discr = 0x30004;

/* When enabled the IPv4 SIP, generated by the OAMP, is
* configured by the user and replaced by the PRGE.
* Soc property bfd_extended_ipv4_src_ip must be enabled as well.
* Not relevant for JR2
*/
int bfd_extended_sip = 0;


/**
 * Destination: FEC
 * Note: there is no need to define
 * an actual FEC, but make sure that
 * you do not plan to use a FEC with
 * this number elsewhere
 */
uint32 my_bfd_dip_destination = 0xabcd;

bcm_bfd_endpoint_t ep_id_in_event = 0;

/*State change event count for BFD */
int state_change_events_count_bfd = 0;

/* Seamless BFD feature.
 * This tells whether the test is
 * currently being run on a seamless
 * bfd initiator endpoint */
uint8 is_s_bfd_init_ep = 0;
uint8 is_s_bfd_reflector = 0;

/*indicate if creating both single and multi hop bfd endpoints.
  When set, each endpoint will be given a unique local discriminator*/
int is_single_and_multi_hop_bfd_coexit =0;

int verify_bfd_ep_id_in_event(bcm_bfd_endpoint_t expected_ep_id) {
    printf("Endpoint id in event = %d\n",ep_id_in_event);
    if ( expected_ep_id == ep_id_in_event ) {
        return BCM_E_NONE;
    } else {
        return BCM_E_FAIL;
    }
}

/* creating l3 interface */
int l3_interface_init(int unit, int in_sysport, int out_sysport, int * _next_hop_mac_encap_id, int * _tunnel_id, int create_mpls_tunnel, int use_my_bfd_dip_destination){
    int rv;
    int ing_intf_in;
    int ing_intf_out;
    int fec[2] = {0x0,0x0};
    int in_vlan;
    int out_vlan = 100;
    int vrf;
    int host;
    int encap_id[2]={0};
    int route;
    int mask; 
    int l3_eg_int;
    int trap_id;
    bcm_l3_intf_t intf_sbfd;
    bcm_mac_t mac_address  = {0x00, 0x0c, 0x00, 0x02, 0x00, 0x00};  /* my-MAC */
    bcm_mac_t internal_my_mac  = {0x00, 0x0c, 0x00, 0x02, 0x00, 0x22};  /* my-MAC used reflector 2nd process after recycle */
    bcm_mac_t next_hop_mac  = {0x00, 0x00, 0x00, 0x00, 0xcd, 0x1d}; /* next_hop_mac1 */
    bcm_mac_t next_hop_mac2  = {0x00, 0x00, 0x00, 0x00, 0xcd, 0x1d}; /* next_hop_mac2 */
    bcm_l3_route_t bfd_route;

    if(is_device_or_above(unit, JERICHO2))
    {
        in_vlan = 10;
        vrf = 1;
    }
    else
    {
        in_vlan = 1;
        vrf = 0;
    }

    mpls__egress_tunnel_utils_s mpls_tunnel_properties;
    if ((!is_s_bfd_reflector) && (device_type==device_type_jericho)) {
            encap_id[0] = 0x1000;
            encap_id[1] = 0x4000;
    }
    if(is_s_bfd_reflector){
         bcm_l3_intf_t_init(&intf_sbfd);
         sal_memcpy(intf_sbfd.l3a_mac_addr, internal_my_mac, 6);
         intf_sbfd.l3a_vid = 101; /* must set to 101 since Dummy ARP lif match vid 101*/
         rv = bcm_l3_intf_create(0, &intf_sbfd);
         if (rv != BCM_E_NONE) {
             printf("Error, bcm_l3_intf_create fail rv = %d \n",rv);
         }
    }

    /*** create ingress router interface ***/
    rv = vlan__open_vlan_per_mc(unit, in_vlan, 0x1);  
    if (rv != BCM_E_NONE) {
        printf("Error, open_vlan=%d, in unit %d \n", in_vlan, unit);
    }
    rv = bcm_vlan_gport_add(unit, in_vlan, in_sysport, 0);
    if (rv != BCM_E_NONE && rv != BCM_E_EXISTS) {
        printf("fail add port(0x%08x) to vlan(%d)\n", in_sysport, in_vlan);
      return rv;
    }

    create_l3_intf_s intf;
    intf.vsi = in_vlan;
    intf.my_global_mac = mac_address;
    intf.my_lsb_mac = mac_address;
    intf.vrf_valid = 1;
    intf.vrf = vrf;
    intf.mtu_valid = 1;
    intf.mtu = 0;
    intf.mtu_forwarding = 0;
    if(use_my_bfd_dip_destination != 0)
    {
        intf.ingress_flags |= BCM_L3_INGRESS_GLOBAL_ROUTE;
    }

    rv = l3__intf_rif__create(unit, &intf);
    ing_intf_in = intf.rif;
    if (rv != BCM_E_NONE) {
        printf("Error, l3__intf_rif__create\n");
    }

    /*** create egress router interface ***/
    rv = vlan__open_vlan_per_mc(unit, out_vlan, 0x1);
    if (rv != BCM_E_NONE) {
        printf("Error, open_vlan=%d, in unit %d \n", out_vlan, unit);
    }
    rv = bcm_vlan_gport_add(unit, out_vlan, out_sysport, 0);
    if (rv != BCM_E_NONE && rv != BCM_E_EXISTS) {
        printf("fail add port(0x%08x) to vlan(%d)\n", out_sysport, out_vlan);
      return rv;
    }

    intf.vsi = out_vlan;

    rv = l3__intf_rif__create(unit, &intf);
    ing_intf_out = intf.rif;
    if (rv != BCM_E_NONE) {
        printf("Error, l3__intf_rif__create\n");
    }

    /*** create egress object 1 ***/
    if (create_mpls_tunnel) {
        /*** Create tunnel ***/
        *_tunnel_id = 0;

        mpls_tunnel_properties.label_in = mpls_label_termination;
        mpls_tunnel_properties.label_out = 0;
        mpls_tunnel_properties.next_pointer_intf = ing_intf_out;

        printf("Trying to create tunnel initiator\n");
        rv = mpls__create_tunnel_initiator__set(unit, &mpls_tunnel_properties);
        if (rv != BCM_E_NONE) {
           printf("Error, in mpls__create_tunnel_initiator__set\n");
           return rv;
        }

        *_tunnel_id = mpls_tunnel_properties.tunnel_id;

        printf("tunnel_id (egress_interface):0x%08x \n", *_tunnel_id);

        l3_eg_int = *_tunnel_id;
    }
    else {
        l3_eg_int = ing_intf_out;
    }

    /*** Create egress object1 ***/
    create_l3_egress_s l3eg;
    l3eg.out_tunnel_or_rif = l3_eg_int;
    sal_memcpy(l3eg.next_hop_mac_addr, next_hop_mac, 6);
    l3eg.vlan   = out_vlan;
    l3eg.arp_encap_id = encap_id[0];
    l3eg.fec_id = fec[0]; 
    l3eg.allocation_flags = 0;
    l3eg.out_gport = out_sysport;

    rv = l3__egress__create(unit,&l3eg);
    if (rv != BCM_E_NONE) {
        printf("Error, in l3__egress__create  \n");
        print rv;
    }
    encap_id[0] = l3eg.arp_encap_id;
    fec[0] = l3eg.fec_id;

    if(verbose >= 1) {
        printf("created FEC-id =0x%08x, in unit %d \n", fec[0], unit);
        printf("next hop mac at encap-id %08x, in unit %d\n", encap_id[0], unit);
    }

    if (!create_mpls_tunnel) {
        *_tunnel_id = encap_id[0];
    }

    /*** add host ***/

    if (single_hop_extended) {
        rv = add_host(unit, 0x12345678, vrf, fec[0]); 
    } else {
        rv = add_host(unit, 0x7fffff03, vrf, fec[0]); 
    } 
    if (rv != BCM_E_NONE) {
        printf("Error, create egress object, in_sysport=%d, in unit %d \n", in_sysport, unit);
    }

    /*** create egress object 2***/
    /* We're allocating a lif. out_sysport unit should be first, and it's already first */
    create_l3_egress_s l3eg1;
    l3eg1.out_tunnel_or_rif = l3_eg_int;
    sal_memcpy(l3eg1.next_hop_mac_addr, next_hop_mac2, 6);
    l3eg1.vlan   = out_vlan;
    l3eg1.arp_encap_id = encap_id[1];
    l3eg1.fec_id = fec[1]; 
    l3eg1.allocation_flags = 0;
    l3eg1.out_gport = out_sysport;

    rv = l3__egress__create(unit,&l3eg1);
    if (rv != BCM_E_NONE) {
        printf("Error, in bcm_vlan_create with vlan %d continue \n", l3eg.vlan);
        print rv;
    }
    encap_id[1] = l3eg1.arp_encap_id;
    fec[1] = l3eg1.fec_id;    
    *_next_hop_mac_encap_id = encap_id[1];

    if(verbose >= 1) {
        printf("created FEC-id =0x%08x, in unit %d\n", fec[1], unit);
        printf("next hop mac at encap-id %08x, in unit %d\n", encap_id[1], unit);
    }

    /*** add route point to FEC2 ***/
    if (!bfd_echo) {
        if (single_hop_extended) {
              route = 0x12345600;
        }
        else{
            route = 0x7fffff00;
        }
        mask  = 0xfffffff0;
        bfd_route.l3a_subnet = route;
        bfd_route.l3a_ip_mask = mask;
        bfd_route.l3a_vrf = vrf;
        rv = bcm_l3_route_get(unit, &bfd_route);
        if (rv == BCM_E_NONE)
        {
            printf("Attempting to add an entry that already exists. Adding replace flag.");
            bfd_route.l3a_flags = BCM_L3_REPLACE;
        }
        bfd_route.l3a_intf = fec[1];
        rv = bcm_l3_route_add(unit, &bfd_route);
        if (rv != BCM_E_NONE) {
            printf("Error, create egress object, in_sysport=%d in unit %d, \n", in_sysport, unit);
        } 
    }
    return rv;
}



int bfd_ipv4_example_init(int unit, int p1, int p2, int use_my_bfd_dip_destination) {
    int rv;

    port_1 = p1;
    port_2 = p2;

    rv = l3_interface_init(unit, port_1, port_2, &next_hop_mac, &tunnel_id, 0, use_my_bfd_dip_destination);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    return rv;
}

/**
* Create BFD over IPV4 endpoint. Following variations
* available:
* 1) Accelerated/non accelerated
* 2) Trapping incoming BFD frames to a configurable destination
* 3) IPv4 one hop/multi hop
*
* @param unit
* @param remote_gport: contains trap code, trap strength and snoop
*                      strength for non-accelerated endpoints; must
*                      be -1 for accelerated endpoints.
* @param flags: supported options:
*        BCM_BFD_ENDPOINT_MULTIHOP: multi hop/single hop
*        indication
*        BCM_BFD_ENDPOINT_IN_HW: accelerated in OAMP
*        indication
*        BCM_BFD_ENDPOINT_MICRO_BFD: Jericho only
* @param flags2: supported options:
*        BCM_BFD_ENDPOINT_FLAGS2_USE_MY_DIP_DESTINATION
*        Jericho2 and up, this option allows more DIPs
*        than the 16 entries in the table, and also
*        support ranges of DIPs by using masks.
* @return int
*/
int bfd_ipv4_example(int unit, bcm_gport_t remote_gport, uint32 flags, uint32 flags2) {
    int rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info = {0};
    bcm_bfd_endpoint_info_t bfd_endpoint_test_info = {0};
    int ret;
    bcm_if_t next_if;
    int is_multi_hop = (flags &BCM_BFD_ENDPOINT_MULTIHOP) !=0;
    int trap_code;
    bcm_l3_route_t l3rt;
    int use_my_bfd_dip_destination = ((flags2 & BCM_BFD_ENDPOINT_FLAGS2_USE_MY_DIP_DESTINATION) != 0);

    rv= oam__device_type_get(unit,&device_type);
    BCM_IF_ERROR_RETURN(rv);

    rv = bfd_ipv4_example_init(unit, port_1, port_2, use_my_bfd_dip_destination);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n",bcm_errmsg(rv));
        return rv;
    }
    printf("-------------init \n");


    if ((is_server || use_trap_with_snoop) && device_type<device_type_arad_plus) {
      printf("Error: Server can be supported only by arad+ devices and above.\n");
      return BCM_E_PARAM;
    }

    /*
    * Adding BFDoIPV4 multi hop endpoint
    */

    /* If enabled, create data entry in EEDB that specifies the
    * configured IPv4 SIP and calculated checksum. */
    next_if = next_hop_mac;

    /** This option is not relevant for JR2 */
    if (bfd_extended_sip)
    {
      bcm_l3_intf_t bfd_extended_l3_intf;
      bcm_l3_intf_t_init(&bfd_extended_l3_intf);

      bcm_tunnel_initiator_t tunnel;
      bcm_tunnel_initiator_t_init(&tunnel);
      tunnel.type = bcmTunnelTypeIpAnyIn4;
      tunnel.sip = 0x10203040;
      tunnel.aux_data = 0x11ae;
      tunnel.dip = 0;
      tunnel.l3_intf_id = next_hop_mac;

      rv = bcm_tunnel_initiator_create(unit, &bfd_extended_l3_intf, &tunnel);
      if (rv != BCM_E_NONE) {
          printf("(%s) \n",bcm_errmsg(rv));
          return rv;
      }

      next_if = bfd_extended_l3_intf.l3a_intf_id;
    }

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);

    bfd_endpoint_info.type = bcmBFDTunnelTypeUdp;
    bfd_endpoint_info.flags = flags;

    /* if bfd_extended_sip is set, there is no need to use a SIP in the BFD endpoint */
    bfd_endpoint_info.src_ip_addr = bfd_extended_sip ? 0 : 0x30F0701;
    if ((bfd_endpoint_info.flags &BCM_BFD_ENDPOINT_IN_HW) !=0  && ((remote_gport==BCM_GPORT_INVALID) || is_server || use_trap_with_snoop)) {

      if(is_device_or_above(unit, JERICHO2))
      {
          BCM_GPORT_SYSTEM_PORT_ID_SET(bfd_endpoint_info.tx_gport, port_1);
      }
      else
      {
          bcm_stk_sysport_gport_get(unit,port_1, &bfd_endpoint_info.tx_gport );
      }

      bfd_endpoint_info.loc_clear_threshold = 1;
      if ((flags & BCM_BFD_ENDPOINT_MULTIHOP) && !(flags2 & BCM_BFD_ENDPOINT_FLAGS2_SEAMLESS_BFD_INITIATOR)) {
          bfd_endpoint_info.ip_ttl = 200;
      } else {
          bfd_endpoint_info.ip_ttl = 255;
      }
     
      if (bfd_ipv4_flex_iptos) {
          bfd_endpoint_info.ip_tos = bfd_ipv4_flex_iptos;
      } else {
          bfd_endpoint_info.ip_tos = 255;
      }
      bfd_endpoint_info.udp_src_port = 0xC001;
      bfd_endpoint_info.egress_if = next_if;
      bfd_endpoint_info.int_pri = 1;
      bfd_endpoint_info.bfd_period = bfd_tx_period;
      if (is_multi_hop || device_type>=device_type_jericho) {
          /* dst IP address unavailable for Arad single hop.*/
          bfd_endpoint_info.dst_ip_addr =  0x7fffff03;
          if (device_type>=device_type_jericho && !is_multi_hop) {
              bfd_endpoint_info.ip_subnet_length = 16; /* have the OAMP verify the 16 MSBs of incoming BFD packets.*/
          }
      }
      if(is_device_or_above(unit, JERICHO2) && ((bfd_endpoint_info.flags & BCM_BFD_ECHO) != 0))
      {
          bfd_endpoint_info.ip_ttl = 200;
      }
      if (bfd_echo) {
          bfd_endpoint_info.flags |= BCM_BFD_ECHO;
          if (bfd_echo==2) {
              bfd_endpoint_info.udp_src_port = 0xffff;
              bfd_endpoint_info.src_ip_addr = 0x7fffff03;
              bfd_endpoint_info.ip_ttl = 254;
          }
      } else {
          bfd_endpoint_info.local_min_tx = 2;
          bfd_endpoint_info.local_min_rx = 0x1000; /* value in microseconds*/
          bfd_endpoint_info.local_state = 3;
          bfd_endpoint_info.local_flags = 0;
          bfd_endpoint_info.local_detect_mult = 208;
          bfd_endpoint_info.remote_detect_mult = 30;
          bfd_endpoint_info.remote_discr = 0x10002;
      }
      if (single_hop_extended || bfd_extended_sip) {
          bfd_endpoint_info.dst_ip_addr = 0x12345678;
      }


      if (is_server) {
          bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_HW_ACCELERATION_SET;
      }
    }


    if(is_device_or_above(unit, JERICHO2))
    {
        bfd_endpoint_info.flags2 = flags2;

        /** Is my-BFD-DIP-Destination in use? */
        if(use_my_bfd_dip_destination)
        {
            /** Set My-BFD-DIP-Destination */
            rv = bcm_switch_control_port_set(unit, 0, bcmSwitchBfdMyDipDestination, my_bfd_dip_destination);
            if (rv != BCM_E_NONE) {
                printf("(%s) \n",bcm_errmsg(rv));
                return rv;
            }

            /** Set up forwarding from the IP to the destination */
            bcm_l3_route_t_init(&l3rt);
            l3rt.l3a_subnet = bfd_endpoint_info.src_ip_addr;
            l3rt.l3a_ip_mask = 0xFFFFFFFF;
            l3rt.l3a_intf = my_bfd_dip_destination;
            l3rt.l3a_vrf = 0;
            rv = bcm_l3_route_add(unit, &l3rt);
            if (rv != BCM_E_NONE) {
                printf("(%s) \n",bcm_errmsg(rv));
                return rv;
            }
        }
    }

    bfd_endpoint_info.local_discr = is_single_and_multi_hop_bfd_coexit ? (bfd_local_discr + single_hop_extended) : bfd_local_discr;
    bfd_endpoint_info.remote_gport = remote_gport;
    if (int_pri) {
        bfd_endpoint_info.int_pri = int_pri;
    }
    if (is_s_bfd_init_ep) {
        bfd_endpoint_info.flags2 |= BCM_BFD_ENDPOINT_FLAGS2_SEAMLESS_BFD_INITIATOR;
        /* Some number outside 49152 - 65535 range since 
         * SBFD does not have limitations on UDP src port range */
        bfd_endpoint_info.udp_src_port = 20020; 
        if ((bfd_endpoint_info.flags &BCM_BFD_ENDPOINT_IN_HW) !=0) {
            /* local_min_rx and local_min_echo needs to be zero */
            bfd_endpoint_info.local_min_rx = 0;
            bfd_endpoint_info.local_min_echo = 0;
            /* TTL should be set to 255 */
            bfd_endpoint_info.ip_ttl = 255;
            /* local_state set to UP */
            bfd_endpoint_info.local_state = 3;
            /* Local flag should have demand bit (bit 1) set 
             * P | F | C | A | D | M 
             * 0 | 0 | 0 | 0 | 1 | 0 
             */
            bfd_endpoint_info.local_flags = 0x2;
        }
    }

    if (is_s_bfd_reflector) {
        rv = sbfd_reflector_endpoint_create(unit, 0x30F0701, 0x10, 3);
        return rv;
    }
    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    printf("created endpoint with id %d\n", bfd_endpoint_info.id);

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_test_info);
    printf("bcm_bfd_endpoint_get bfd_endpoint_test_info\n");
    rv = bcm_bfd_endpoint_get(unit, bfd_endpoint_info.id, &bfd_endpoint_test_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    /* Here mep_not_acc_info and mep_not_acc_test_info are compared */
    ret = cmp_structs(unit, &bfd_endpoint_info, &bfd_endpoint_test_info,bcmBFDTunnelTypeUdp) ;
    if (ret != 0) {
      printf("%d wrong fields in BFDoIPV4\n", ret);
    }

    printf("bcm_bfd_endpoint_destroy bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_destroy(unit, bfd_endpoint_info.id);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    bfd_ep1.id = bfd_endpoint_info.id;

    return rv;
}

    /**
    * 
    * 
    * @author sinai (03/09/2015)
    * 
    * @param unit 
    * @param port1 Port on which the endpoint resides
    * @param port2 
    * @param remote_port trap to a non default destination (may be 
    *  				  -1)
    * @param is_extended_sip 
    * @param flags: supported options: 
    *        BCM_BFD_ENDPOINT_MULTIHOP: multi hop/single hop
    *        indication
    *        BCM_BFD_ENDPOINT_IN_HW: accelerated in OAMP 
    *        indication
    *        BCM_BFD_ENDPOINT_MICRO_BFD: Jericho only
    * @param remote_port_fwd_strength:
    *           Indicates the trap strength to be set in
    *           remote_gport trap variable. 0 to indicate default
    *           behavior of setting 7.
    * @param flags2: supported options:
    *        BCM_BFD_ENDPOINT_FLAGS2_USE_MY_DIP_DESTINATION:
    *        The DIP is forwarded to my-BFD-DIP destination instead
    *        of being added to the table of 16 BFD DIPs.
    * 
    * @return int 
    */
int bfd_ipv4_run_with_defaults(int unit, int port1, int port2,  int remote_port,  int is_extended_sip, uint32 flags, int remote_port_fwd_strength, int flags2) {
    bcm_error_t rv;

    port_1 = port1;
    port_2 = port2;
    bcm_gport_t remote_gport;
    int trap_code;
    /*int is_single_hop , int is_acc, */

    if (is_extended_sip && soc_property_get(unit , "bfd_extended_ipv4_src_ip",1)) {
        bfd_extended_sip = 1;
    }

    rv = oam__device_type_get(unit, &device_type);
    if (rv < 0) {
      printf("Error checking whether the device is arad+.\n");
      print rv;
      return rv;
    }

    /* Using LEM/PMF to demultiplex BFD endpoints for:  BFD single hop or Micro BFD, when the soc property is on. */
    /* Mulit hop extended feature uses same program as single hop extended hence reusing the same variable */

    if ((!is_device_or_above(unit, JERICHO2))
       && ((flags & BCM_BFD_ENDPOINT_MULTIHOP)==0  || (flags & BCM_BFD_ENDPOINT_MICRO_BFD )!=0)
       && soc_property_get(unit, "bfd_ipv4_single_hop_extended", 1) || (soc_property_get(unit, "custom_feature_multi_hop_bfd_extra_dip_support", 0))
       && (device_type>=device_type_arad_plus)
       && ((!is_s_bfd_init_ep)&&(!is_s_bfd_reflector))) {
      single_hop_extended = 1;
    }

    if (!is_device_or_above(unit, JERICHO2)) {
        /** This SOC property no long exists in JR2 */

        /* Micro BFD may only be set with soc property and may not be set with multihop flags*/
        if ((flags & BCM_BFD_ENDPOINT_MICRO_BFD )!=0 && soc_property_get(unit, "bfd_ipv4_single_hop_extended", 1) ==0 ) {
          printf("Error: MICRO_BFD may only be configured with bfd_ipv4_single_hop_extended soc property.\n");
          print 34;
        }

        /** Not relevant for JR2 */
        rv = mpls__mpls_pipe_mode_exp_set(unit);
        if (rv != BCM_E_NONE) {
          printf("Error, in mpls__mpls_pipe_mode_exp_set\n");
          return rv;
        }
    }


    if (remote_port == -1) {
      remote_gport = BCM_GPORT_INVALID;
      if (is_device_or_above(unit, JERICHO2) && (flags & BCM_BFD_ENDPOINT_IN_HW) == 0)
      {
          rv = bcm_rx_trap_type_get(unit, 0, bcmRxTrapBfdOamDownMEP, &trap_code);
          if (rv != BCM_E_NONE) {
              printf("(%s) \n",bcm_errmsg(rv));
              return rv;
          }
          BCM_GPORT_TRAP_SET(remote_gport, trap_code, 7, 0);
      }
    }
    else {
      if (is_server || use_trap_with_snoop) {
          BCM_GPORT_TRAP_SET(remote_gport, remote_port, remote_port_fwd_strength?remote_port_fwd_strength:7, 3);
      }
      else {
          printf("Setting remote_gport to port 0x%08x with strength %d\n",
                  remote_port, remote_port_fwd_strength?remote_port_fwd_strength:7);
          BCM_GPORT_LOCAL_SET(remote_gport, remote_port);

          /* remote_gport field must be a trap */
          rv = bfd_create_trap_from_gport(unit, remote_gport, &trap_code);
          if (rv != BCM_E_NONE) {
              printf("Error bfd_create_trap_from_gport.\n");
              return rv;
          }
          BCM_GPORT_TRAP_SET(remote_gport, trap_code, remote_port_fwd_strength?remote_port_fwd_strength:7, 0);
          remote_gport_trap_code = trap_code;
      }
    }

    /* in case of sigle hop extended the PMF should do the classification*/
    if (single_hop_extended) {
        rv = bfd_ipv4_single_hop_field_action(unit);
        if (rv != BCM_E_NONE) {
          printf("Error bfd_ipv4_single_hop_field_trap_qualifier.\n");
          return rv;
        }
    }

    if(is_device_or_above(unit, JERICHO2) && (flags & BCM_BFD_ECHO))
    {
       bfd_echo = 1;
       rv = field_presel_fwd_layer_main(unit,cint_bfd_echo_presel_id, bcmFieldStageIngressPMF1, bcmFieldLayerTypeIp4, &cint_bfd_echo_context_id_ipmf1, "ipv4 hit");
       if (rv != BCM_E_NONE)
       {
           printf("Error (%d), in cint_field_always_hit_context_main Ingress\n", rv);
           return rv;
        }

        rv = cint_field_bfd_echo_main(unit, cint_bfd_echo_context_id_ipmf1);
        if (rv != BCM_E_NONE) {
          printf("Error cint_field_bfd_echo_main.\n");
          return rv;
        }

        rv = cint_field_bfd_echo_entry_add(unit, 0x7fffff03, bfd_local_discr & 0xFFFF);
        if (rv != BCM_E_NONE) {
          printf("Error cint_field_bfd_echo_entry_add.\n");
          return rv;
        }
    }

    if (!single_hop_extended && soc_property_get(unit, "bfd_mask_flags_bitfield", 0)){
        /* In a case of second call, skip this part */
        if (!is_field_created) {
            /* Feature requires egress PMF changes, taken from the trap code*/
            int bfd_ip_trap_code;
            rv = bcm_rx_trap_type_get(0,0, bcmRxTrapOamBfdIpv4,&bfd_ip_trap_code);
            BCM_IF_ERROR_RETURN(rv);

            rv = field_bfd_advanced_features(unit, bfd_ip_trap_code);
            BCM_IF_ERROR_RETURN(rv);
            is_field_created = 1;
        }
    }

    rv = bfd_ipv4_example(unit, remote_gport, flags, flags2);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    rv = register_events(unit);
    return rv;
}

int read_timeout_event_count_bfd(int expected_event_count) {
    printf("timeout_events_count_bfd=%d\n",timeout_events_count_bfd);

    if (timeout_events_count_bfd==expected_event_count) {
        return BCM_E_NONE;
    }
    else {
        return BCM_E_FAIL;
    }
}

/* This is an example of using bcm_bfd_event_register api.
* A simple callback is created for CCM timeout event.
* After a mep and rmep are created, the callback is called
* whenever CCMTimeout event is generated.
*/
int cb_bfd(
int unit,
uint32 flags,
bcm_bfd_event_types_t event_types,
bcm_bfd_endpoint_t endpoint,
void *user_data)
{
    int event_i;
    int rv;
    print unit;
    print flags;
    ep_id_in_event = endpoint;
    for (event_i = 0; event_i < bcmBFDEventCount; event_i++) {

        if (BCM_BFD_EVENT_TYPE_GET(event_types, event_i)) {
            print event_i;
            rv = oam__device_type_get(unit, &device_type);
            if (rv < 0) {
                printf("Error checking whether the device is arad+.\n");
                print rv;
                return rv;
            }
            if (bcmBFDEventStateChange==event_i && device_type>=device_type_arad_plus ) {
                /* The event change interrupt does not convey information about the new flags/state/diags.
                   Instead it possible to get these through endpoint_get (in Arad+)*/
                bcm_bfd_endpoint_info_t ep_get;
                rv = bcm_bfd_endpoint_get(unit, endpoint, &ep_get);
                if (rv != BCM_E_NONE) {
                    printf("(%s) \n", bcm_errmsg(rv));
                    return rv;
                }
                state_change_events_count_bfd++;
                printf("Flags is : 0x%x\n state is \n", ep_get.remote_flags);
                print ep_get.remote_state;
                print "diag is:";
                print ep_get.remote_diag;

            }
        }
    }
    print endpoint;
    timeout_events_count_bfd++;
    if (flags & BCM_OAM_EVENT_FLAGS_MULTIPLE) {
        ++timeout_events_count_multi_bfd;
    }
    return BCM_E_NONE;
}

int register_events(int unit) {
    bcm_error_t rv;
    bcm_bfd_event_types_t e;

    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimeout);
    rv = bcm_bfd_event_register(unit, e, cb_bfd, (void*)2);
    BCM_IF_ERROR_RETURN(rv);

    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimein);
    rv = bcm_bfd_event_register(unit, e, cb_bfd, (void*) 1 );
    BCM_IF_ERROR_RETURN(rv);

    BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventStateChange);
    rv = bcm_bfd_event_register(unit, e, cb_bfd, (void*) 1 );
    BCM_IF_ERROR_RETURN(rv);

    return rv;
}

int cb_bfd_multi_count_event(
    int unit,
    uint32 flags,
    bcm_bfd_event_types_t event_types,
    bcm_bfd_endpoint_t endpoint,
    void *user_data)
{   
    int event_i;
    int rv;
    print unit;
    print flags;
    
    ep_id_in_event = endpoint;
    for (event_i = 0; event_i < bcmBFDEventCount; event_i++) {
        if (BCM_BFD_EVENT_TYPE_GET(event_types, event_i)) {
            print event_i;
            /* when multiple OAM events feature is enabled
               upper 16 bits in flags field will provide
               the count which will indicate how many times
               that event occured before it is being handed
               over to application through call back function
            */
            if(event_i == bcmBFDEventEndpointTimeout)
                timeout_multi_event_count_bfd += (flags >> 16);
            if(event_i == bcmBFDEventEndpointTimein)
                timein_multi_event_count_bfd += ( flags  >> 16);
        }
    }
    print endpoint;
    return BCM_E_NONE;
}
    
int read_multi_event_count_bfd(int expected_timeout_event_count, int expected_timein_event_count) {
    printf("timeout_events_count_bfd=%d\n",timeout_multi_event_count_bfd);
    printf("timein_events_count_bfd=%d\n" ,timein_multi_event_count_bfd);
    if ((timeout_multi_event_count_bfd==expected_timeout_event_count) && (timein_multi_event_count_bfd==expected_timein_event_count)) {
        return BCM_E_NONE;
    }
    else {
        printf("timeout_multi_event_count_bfd=%d\n",timeout_multi_event_count_bfd);
        printf("timein_multi_event_count_bfd=%d\n" ,timein_multi_event_count_bfd);
        return BCM_E_FAIL;
    }
}

int register_count_event(int unit) {
  bcm_error_t rv;
  bcm_bfd_event_types_t e;

  BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimeout);
  BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimein);
  rv = bcm_bfd_event_unregister(unit,e,cb_bfd );
  BCM_IF_ERROR_RETURN(rv);

  BCM_BFD_EVENT_TYPE_CLEAR_ALL(e);
  BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimeout);
  rv = bcm_bfd_event_register(unit, e, cb_bfd_multi_count_event, (void*)2);
  BCM_IF_ERROR_RETURN(rv);

  BCM_BFD_EVENT_TYPE_SET(e, bcmBFDEventEndpointTimein);
  rv = bcm_bfd_event_register(unit, e, cb_bfd_multi_count_event, (void*) 1 );
  BCM_IF_ERROR_RETURN(rv);

  return rv;
}

/*
* Creating vpls tunnel and termination
* is_pwe_gal is only applicable for Arad+,
* Jericho does not need GAL termination or adding CW (These are both done at the OAMP).
*/
int pwe_init(int unit, uint8 is_pwe_gal) {
    bcm_error_t rv;
    bcm_mpls_tunnel_switch_t tunnel_switch;

    if(is_device_or_above(unit, JERICHO2))
    {
        cint_vpls_basic_info.cw_present = 1;
        rv = vpls_mp_basic_main(unit, port_1, port_2);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n",bcm_errmsg(rv));
            return rv;
        }
    }
    else
    {
        if (!is_pwe_gal && pwe_ach) {
          /*  in Jericho when a packet arrives with a GAL the MPLS termination mechanism knows to look for a CW. Hence in this case the LIF need not be configured with a CW. */
          pwe_cw = 1;
        }

        mpls_lsr_init(port_1,port_2, 0, next_hop_mac, mpls_label, mpls_label, 0, 0 ,0);
        rv = vswitch_vpls_run_with_defaults_dvapi(unit,port_1,port_2);
        if (rv != BCM_E_NONE) {
          printf("(%s) \n",bcm_errmsg(rv));
          return rv;
        }

        rv = mpls_add_term_entry_ex(unit, mpls_label, 0, &tunnel_switch);
        if (rv != BCM_E_NONE) {
          printf("(%s) \n",bcm_errmsg(rv));
          return rv;
        }
    }
    return rv;
}


/**
* Create PWE endpoint for the 4 different VCCV types.
*
* @author sinai (23/09/2014)
*
* @param unit
* @param vccv_type
*
* @return int
*/
int bfd_pwe_example(int unit , int vccv_type) {
    bcm_error_t rv;
    bcm_bfd_endpoint_info_t bfd_endpoint_info;
    bcm_bfd_endpoint_info_t bfd_endpoint_test_info;
    bcm_mpls_tunnel_switch_t tunnel_switch;
    int ret;
    int bfd_supported_flags;

    rv = oam__device_type_get(unit, &device_type);
    if (rv < 0) {
      printf("Error checking whether the device is arad+.\n");
      print rv;
      return rv;
    }

    if (soc_property_get(unit, "bfd_mask_flags_bitfield", 0)){
        /* Feature requires egress PMF changes, taken from the trap code*/
        int bfd_ip_trap_code;
        rv = bcm_rx_trap_type_get(0,0, bcmRxTrapOamBfdPwe,&bfd_ip_trap_code);
        BCM_IF_ERROR_RETURN(rv);

        rv = field_bfd_advanced_features(unit, bfd_ip_trap_code);
        BCM_IF_ERROR_RETURN(rv);
    }

    rv = pwe_init(unit, 0);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    /*
    * Adding BFDoPWE with control word endpoint
    */
    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_info);

    if (vccv_type == 4) {
        bfd_endpoint_info.type = bcmBFDTunnelTypePweGal;
    } else if (vccv_type == 2) {
        bfd_endpoint_info.type = bcmBFDTunnelTypePweRouterAlert;
        if (pwe_ach) {
            /* For Router Alert Types the PWE-ACH label is optional. supported via flag.*/
            bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_PWE_ACH;
        }
    } else if (vccv_type == 3) {
        bfd_endpoint_info.type = bcmBFDTunnelTypePweTtl;
    } else {
        bfd_endpoint_info.type = bcmBFDTunnelTypePweControlWord;
    }

    if(is_device_or_above(unit, JERICHO2))
    {
        /** Outer encapsulation port  */
        bfd_endpoint_info.gport = cint_vpls_basic_info.mpls_port_id_ingress;
        bfd_endpoint_info.egress_if = cint_vpls_basic_info.core_arp_id;
        bfd_endpoint_info.label = 3000; /* PWE Label */
        bfd_endpoint_info.udp_src_port = 50000;
        BCM_GPORT_SYSTEM_PORT_ID_SET(bfd_endpoint_info.tx_gport, port_1);
    }
    else
    {
        bfd_endpoint_info.gport = mpls_lsr_info_1.mpls_port_id; /*in lif: mpls_port->mpls_port_id */
        bfd_endpoint_info.egress_if = mpls_lsr_info_1.encap_id; /* out lif: mpls_port->encap_id */
        bfd_endpoint_info.egress_label.label = 2010; /* PWE Label */
        bfd_endpoint_info.udp_src_port = 0;
        bcm_stk_sysport_gport_get(unit,port_1, &bfd_endpoint_info.tx_gport);
    }

    bfd_endpoint_info.dst_ip_addr = 0;
    bfd_endpoint_info.src_ip_addr = 0;
    bfd_endpoint_info.ip_tos = 0;
    bfd_endpoint_info.ip_ttl = 0;
    bfd_endpoint_info.int_pri = 1;
    bfd_endpoint_info.local_min_tx = 2;
    bfd_endpoint_info.local_min_rx = 3;
    bfd_endpoint_info.bfd_period = 100;
    bfd_endpoint_info.local_detect_mult = 208;
    bfd_endpoint_info.local_state = 3;
    bfd_endpoint_info.flags |= BCM_BFD_ENDPOINT_IN_HW;
    bfd_endpoint_info.remote_discr = 0x10001;
    bfd_endpoint_info.remote_detect_mult = 30;
    bfd_endpoint_info.local_discr =  0x34;
    bfd_supported_flags = soc_property_get(unit, "bfd_supported_flags_bitfield",0);
    if(bfd_supported_flags == 0x38) {
        bfd_endpoint_info.local_flags = 0;
    } else {
        bfd_endpoint_info.local_flags = 2;
    }
    bfd_endpoint_info.egress_label.ttl = (vccv_type==3) ? 1 : 0xa;
    bfd_endpoint_info.egress_label.exp = 1;

    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    printf("created endpoint with id %d\n", bfd_endpoint_info.id);

    bcm_bfd_endpoint_info_t_init(&bfd_endpoint_test_info);
    printf("bcm_bfd_endpoint_get bfd_endpoint_test_info\n");
    rv = bcm_bfd_endpoint_get(unit, bfd_endpoint_info.id, &bfd_endpoint_test_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    /* Here mep_not_acc_info and mep_not_acc_test_info should be compared */
    ret =cmp_structs(unit, &bfd_endpoint_info, &bfd_endpoint_test_info,bcmBFDTunnelTypePweControlWord ) ;
    if (ret != 0) {
      printf("%d wrong fields in BFDoPWE\n", ret);
    }

    printf("bcm_bfd_endpoint_destroy bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_destroy(unit, bfd_endpoint_info.id);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    printf("bcm_bfd_endpoint_create bfd_endpoint_info\n");
    rv = bcm_bfd_endpoint_create(unit, &bfd_endpoint_info);
    if (rv != BCM_E_NONE) {
      printf("(%s) \n",bcm_errmsg(rv));
      return rv;
    }

    bfd_ep1.gport = bfd_endpoint_info.gport;
    bfd_ep1.id = bfd_endpoint_info.id;

    return rv;
}

/**
* BFD over PWE, according to VCCV Type:
* Type 1: BFD over CW (ACH)  over PWE
* Type 2: PWE  over router alert
* Type 3: PWE TTL=1 (unsupported)
* Type 4: BFD over G-ACH over GAL over PWE.
*
* @author sinai (23/09/2014)
*
* @param unit
* @param port1
* @param port2
* @param vccv_type - must be 1,2,4
*
* @return int
*/
int bfd_pwe_run_with_defaults(int unit, int port1, int port2, int vccv_type) {
    bcm_error_t rv;

    port_1 = port1;
    port_2 = port2;

    rv = mpls__mpls_pipe_mode_exp_set(unit);
    if (rv != BCM_E_NONE) {
        printf("Error, in mpls__mpls_pipe_mode_exp_set\n");
        return rv;
    }

    rv = oam__device_type_get(unit, &device_type);
    if (rv < 0) {
        printf("Error checking whether the device is arad+.\n");
        print rv;
        return rv;
    }

    /* In QAX all 4 VCCV types are supported */
    if (device_type<device_type_qax) {
        if (device_type>=device_type_jericho) {
             /* In Jericho VCCV type 3 is not supported */
            if (vccv_type != 1 && vccv_type != 2 && vccv_type != 4) {
                printf("Only VCCV Types 1,2,4 supported\n");
                return 99;
            }
        } else if (device_type==device_type_arad_plus) {
            /* In Arad Plus VCCV types 2,3 are not supported */
            if (vccv_type != 1 &&  vccv_type != 4) {
                printf("Only VCCV Types 1,4 supported\n");
                return 99;
            }
        } else {
            if (vccv_type != 1) {
                /* In Arad only VCCV type 1 is supported */
                printf("Only VCCV Type 1 supported\n");
                return 99;
            }
        }
    }


    if (device_type==device_type_arad_plus && vccv_type == 4) {
        /* PWE GAL handled serparatly in Arad+*/
        rv =  bfd_pwe_gal_example(unit);
        if (rv != BCM_E_NONE) {
            printf("(%s) \n", bcm_errmsg(rv));
            return rv;
        }
    }

    rv =  bfd_pwe_example(unit, vccv_type);
    if (rv != BCM_E_NONE) {
        printf("(%s) \n", bcm_errmsg(rv));
        return rv;
    }

    rv = register_events(unit);
    return rv;
}

/*
* function compares endpoint_info_t created with bfd_mpls_endpoint_info_create() and a struct returned from bfd_endpoint_info_get().
*  type may be bcmBFDTunnelTypePweControlWord,  bcmBFDTunnelTypeMpls or bcmBFDTunnelTypeUdp
*  function returns 0 upon success, number of wrong fields upon failure.
*/
int cmp_structs(int unit, bcm_bfd_endpoint_info_t* endpoint_create,bcm_bfd_endpoint_info_t* endpoint_get, int type  ){
    int rv =0;
    uint32 create_flags, get_flags;
    create_flags = endpoint_create->flags;
    get_flags = endpoint_get->flags;
    if(is_device_or_above(unit, JERICHO2))
    {
        if((endpoint_create->type == bcmBFDTunnelTypeMplsTpCc) ||
           (endpoint_create->type == bcmBFDTunnelTypePweGal) ||
           (endpoint_create->type == bcmBFDTunnelTypePweControlWord) ||
           (endpoint_create->type == bcmBFDTunnelTypePweRouterAlert) ||
           (endpoint_create->type == bcmBFDTunnelTypePweTtl))
        {
            /** This flag is added for these types */
            create_flags |= BCM_BFD_ENDPOINT_PWE_ACH;
            get_flags |= BCM_BFD_ENDPOINT_PWE_ACH;
        }
    }
    if (create_flags != get_flags) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - flags fields are different.\n");
      printf("Create flags: 0x%08X\nGet flags: 0x%08X\n", create_flags, get_flags);
      ++rv;
    }
    if (endpoint_create->id != endpoint_get->id ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - id fields are different.\n");
      ++rv;
    }
    if (endpoint_create->type != endpoint_get->type ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - type fields are different.\n");
      ++rv;
    }
    if(!is_device_or_above(unit, JERICHO2))
    {
        if (endpoint_create->gport != endpoint_get->gport ) {
          printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - gport fields do not match.\n Expected %d, got %d.\n",
                    endpoint_create->gport, endpoint_get->gport);
          ++rv;
        }
    }
    else
    {
        /**
         * In JR2, gport is ignored if the incoming packet is classified by discriminator.
         * Also, the gport's prefix (upper 16 bits) is changed before saving it.
         */
        if((endpoint_create->type != bcmBFDTunnelTypeUdp) && (endpoint_create->type != bcmBFDTunnelTypeMpls) &&
           ((endpoint_create->gport & 0xFFFF) != (endpoint_get->gport & 0xFFFF)))
        {
            printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - gport fields do not match.\n Expected %d, got %d.\n",
                      endpoint_create->gport, endpoint_get->gport);
        }
    }
    if((!is_device_or_above(unit, JERICHO2) || ((endpoint_create->flags & BCM_BFD_ENDPOINT_IN_HW)==0)) &&
     (endpoint_create->remote_gport != endpoint_get->remote_gport )) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - remote_gport fields do not match.\n");
      ++rv;
    }

    if (endpoint_create->src_ip_addr != endpoint_get->src_ip_addr ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - src_ip_addr fields do not match. Expected %d, got %d\n",
                endpoint_create->src_ip_addr, endpoint_get->src_ip_addr );
      ++rv;
    }
    if (!is_device_or_above(unit, JERICHO2) ||
       (((bcmBFDTunnelTypeUdp == endpoint_create->type)
         && ((endpoint_create->flags & BCM_BFD_ENDPOINT_MULTIHOP) != 0))
        || (bcmBFDTunnelTypeMpls == endpoint_create->type)))
    {
        if (endpoint_create->ip_tos != endpoint_get->ip_tos ) {
          printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - ip_tos fields do not match.\n");
          ++rv;
        }
        if (endpoint_create->ip_ttl != endpoint_get->ip_ttl ) {
          printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - ip_ttl fields do not match.\n");
         ++rv;
        }
    }
    /** In JR2, udp_src_port is ignored for PWE types */
    if ((!is_device_or_above(unit, JERICHO2) ||
       (bcmBFDTunnelTypeUdp == endpoint_create->type) ||
       (bcmBFDTunnelTypeMpls == endpoint_create->type)) &&
       (endpoint_create->udp_src_port != endpoint_get->udp_src_port) ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - udp_src_port fields do not match.\n");
     ++rv;
    }
    if (endpoint_create->egress_if !=endpoint_get->egress_if ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - egress_if fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->int_pri != endpoint_get->int_pri ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - int_pri fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_discr != endpoint_get->local_discr ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_discr fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_min_tx != endpoint_get->local_min_tx ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_min_tx fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->bfd_period - endpoint_get->bfd_period > 10) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - bfd_period fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_min_rx != endpoint_get->local_min_rx ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_min_rx fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_detect_mult != endpoint_get->local_detect_mult ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_detect_mult fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->local_state !=endpoint_get->local_state ) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_state fields do not match.\n");
      ++rv;
    }
    if (endpoint_create->remote_discr != endpoint_get->remote_discr) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - remote_discr fields do not match.Expected %d, got %d\n",
              endpoint_create->remote_discr, endpoint_get->remote_discr);
      ++rv;
    }
    if (endpoint_create->local_diag != endpoint_get->local_diag) {
      printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - local_diag fields do not match.\n");
      ++rv;
    }
    if ((type == bcmBFDTunnelTypeUdp && ((endpoint_create->flags & BCM_BFD_ENDPOINT_MULTIHOP)==0)) && !is_device_or_above(unit, JERICHO2)) { /*ip single hop - dest ip should be zero.*/
       if (endpoint_get->dst_ip_addr != 0 ) {
          printf("Error, BFDoIPV4: dst_ip_addr field in endpoint_info_t field returned from endpoint_info_get non zero on single hop ip encapsulation. Dest addr is %d\n",endpoint_get->dst_ip_addr);
          ++rv;
      }
    }
    else{ /* in other cases dest_addresses must match*/
      if (endpoint_get->dst_ip_addr != endpoint_create->dst_ip_addr ) {
          printf("Error: endpoint_info_t struct returned from endpoint_info_get not the same as the one created with endpoint_create() - dst_ip_addr fields do not match.\n");
          ++rv;
      }
    }
    return rv;
}
