
/*
 *         
 * $Id:$
 * 
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *         
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX family only!"
#endif /* BCM_DNX_SUPPORT */

#ifndef _IMB_H__H_
#define _IMB_H__H_

#include <soc/portmod/portmod.h>
#include <bcm/port.h>
#include <bcm/cosq.h>
#include <bcm_int/dnx/port/imb/imb_diag.h>
#include <soc/dnxc/legacy/dnxc_port.h>

/*!
 * @enum imb_dispatch_type_e
 * @brief Supported Drivers 
 */
typedef enum imb_dispatch_type_e
{
    imbDispatchTypeNone,
    imbDispatchTypeImb_cdu,
    imbDispatchTypeImb_ile,
    imbDispatchTypeImb_fabric,
    imbDispatchTypeCount
} imb_dispatch_type_t;

extern const enum_mapping_t imb_dispatch_type_t_mapping[];
/* imb_dispatch_type_t validation */
int imb_dispatch_type_t_validate(
    int unit,
    imb_dispatch_type_t imb_dispatch_type);

/*!
 * @struct imb_cdu_create_info_s
 * @brief CDU specific information required for IMB init. 
 */
typedef struct imb_cdu_create_info_s
{
    void *user_acc; /**< user access information to be passed to portmod layer. */
} imb_cdu_create_info_t;

/* imb_cdu_create_info_t initialization and validation */
int imb_cdu_create_info_t_validate(
    int unit,
    const imb_cdu_create_info_t * imb_cdu_create_info);
int imb_cdu_create_info_t_init(
    int unit,
    imb_cdu_create_info_t * imb_cdu_create_info);

/*!
 * @struct imb_ile_create_info_s
 * @brief ILU specific information required for IMB init. 
 */
typedef struct imb_ile_create_info_s
{
    int stub; /**< temp stub until ILKN is implemented */
} imb_ile_create_info_t;

/* imb_ile_create_info_t initialization and validation */
int imb_ile_create_info_t_validate(
    int unit,
    const imb_ile_create_info_t * imb_ile_create_info);
int imb_ile_create_info_t_init(
    int unit,
    imb_ile_create_info_t * imb_ile_create_info);

/*!
 * @struct imb_fabric_create_info_s
 * @brief Fabric specific information required for IMB init. 
 */
typedef struct imb_fabric_create_info_s
{
    int stub; /**< temp stub until Fabric is implemented */
} imb_fabric_create_info_t;

/* imb_fabric_create_info_t initialization and validation */
int imb_fabric_create_info_t_validate(
    int unit,
    const imb_fabric_create_info_t * imb_fabric_create_info);
int imb_fabric_create_info_t_init(
    int unit,
    imb_fabric_create_info_t * imb_fabric_create_info);

typedef union imb_specific_create_info_u
{
    imb_cdu_create_info_t cdu;
    imb_ile_create_info_t ile;
    imb_fabric_create_info_t fabric;
} imb_specific_create_info_t;

/*!
 * @struct imb_create_info_s
 * @brief This struct contains the required information in order to add new IMB. 
 */
typedef struct imb_create_info_s
{
    imb_dispatch_type_t type; /**< IMB type */
    int inst_id; /**< instatnce number. The physical phys will be deducted from the instance id. */
    imb_specific_create_info_t imb_specific_info;
} imb_create_info_t;

/* imb_create_info_t initialization and validation */
int imb_create_info_t_validate(
    int unit,
    const imb_create_info_t * imb_create_info);
int imb_create_info_t_init(
    int unit,
    imb_create_info_t * imb_create_info);

#define IMB_PRD_PRIORITY_ALL (BCM_PORT_F_PRIORITY_0 | BCM_PORT_F_PRIORITY_1 | BCM_PORT_F_PRIORITY_2 | BCM_PORT_F_PRIORITY_3 | BCM_PORT_F_PRIORITY_TDM) /**< Abbriviation to set all PRD priorities */

/*! 
 * imb_init_all
 *
 * @brief Initialize all IMBs on the specified unit. 
 *
 * @param [in]  unit            - unit id
 */
int imb_init_all(
    int unit);

/*! 
 * imb_deinit_all
 *
 * @brief De-initialize all IMBs on the specified unit. 
 *
 * @param [in]  unit            - unit id
 */
int imb_deinit_all(
    int unit);

/*! 
 * imb_init
 *
 * @brief initialize an IMB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_info        - IMB information required for the IMB to initialize.
 * @param [out]  imb_specific_info   - IMB information to be initialized by the specific IMB type.
 */
int imb_init(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info);

/*! 
 * imb_deinit
 *
 * @brief De-initialize an existing IMB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_info        - IMB information required for the IMB to de-init
 * @param [out]  imb_specific_info   - IMB information to be deinitialized by the IMB type.
 */
int imb_deinit(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info);

/*! 
 * imb_port_pad_size_set
 *
 * @brief TX pad packets to the specified size. value less than 17 means pad is disabled.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - TX packet pad size
 */
int imb_port_pad_size_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_pad_size_get
 *
 * @brief TX pad packets to the specified size. value less than 17 means pad is disabled.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - TX packet pad size
 */
int imb_port_pad_size_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * @brief Port Add Flags 
 */
#define IMB_PORT_ADD_F_INIT_PASS1 0x1 /**< imb port add PASS1: init port until firmware load */
#define IMB_PORT_ADD_F_INIT_PASS2 0x2 /**< imb port add PASS2: resume init port after firmware load */
#define IMB_PORT_ADD_F_SKIP_SETTINGS 0x4 /**< Skip IMB port settings */

#define IMB_PORT_ADD_F_INIT_PASS1_SET(flags) (flags |= IMB_PORT_ADD_F_INIT_PASS1)
#define IMB_PORT_ADD_F_INIT_PASS2_SET(flags) (flags |= IMB_PORT_ADD_F_INIT_PASS2)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_SET(flags) (flags |= IMB_PORT_ADD_F_SKIP_SETTINGS)

#define IMB_PORT_ADD_F_INIT_PASS1_CLR(flags) (flags &= ~IMB_PORT_ADD_F_INIT_PASS1)
#define IMB_PORT_ADD_F_INIT_PASS2_CLR(flags) (flags &= ~IMB_PORT_ADD_F_INIT_PASS2)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_CLR(flags) (flags &= ~IMB_PORT_ADD_F_SKIP_SETTINGS)

#define IMB_PORT_ADD_F_INIT_PASS1_GET(flags) (flags & IMB_PORT_ADD_F_INIT_PASS1 ? 1 : 0)
#define IMB_PORT_ADD_F_INIT_PASS2_GET(flags) (flags & IMB_PORT_ADD_F_INIT_PASS2 ? 1 : 0)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_GET(flags) (flags & IMB_PORT_ADD_F_SKIP_SETTINGS ? 1 : 0)

/*! 
 * imb_port_add
 *
 * @brief Add new IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which pass through port add. see IMB_PORT_ADD_F_INIT_...
 */
int imb_port_add(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_port_remove
 *
 * @brief Remove an existing IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_remove(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_attach
 *
 * @brief Add new IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which pass through port add. see IMB_PORT_ADD_F_INIT_...
 */
int imb_port_attach(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_port_detach
 *
 * @brief Remove an existing IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_detach(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_enable_set
 *
 * @brief Enable / disable a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port enable/disable indication
 */
int imb_port_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_enable_get
 *
 * @brief Enable / disable a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Port enabled indication
 */
int imb_port_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_rx_data_enable_set
 *
 * @brief Enable / disable port RX 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port Rx enable/disable
 */
int imb_port_rx_data_enable_set(
    int unit,
    bcm_port_t port,
    int enable);

/*! 
 * imb_port_loopback_set
 *
 * @brief Enable / disable loopback on a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback        - Port loopback indication
 */
int imb_port_loopback_set(
    int unit,
    bcm_port_t port,
    int loopback);
/*! 
 * imb_port_loopback_get
 *
 * @brief Enable / disable loopback on a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  loopback        - Port loopback enabled indication
 */
int imb_port_loopback_get(
    int unit,
    bcm_port_t port,
    int *loopback);

/*! 
 * imb_port_link_state_get
 *
 * @brief Get port link state 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  clear_status    - clear latch down indication
 * @param [out]  link_state      - Port link state
 */
int imb_port_link_state_get(
    int unit,
    bcm_port_t port,
    int clear_status,
    bcm_port_link_state_t * link_state);

/*! 
 * imb_port_eee_enable_set
 *
 * @brief Enable / disable EEE for a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port EEE enable/disable indication
 */
int imb_port_eee_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_eee_enable_get
 *
 * @brief Enable / disable EEE for a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Port EEE enabled indication
 */
int imb_port_eee_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_link_up_mac_update
 *
 * @brief Set Mac link according to Phy status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  link            - link status info
 */
int imb_port_link_up_mac_update(
    int unit,
    bcm_port_t port,
    int link);

/*! 
 * imb_port_priority_config_set
 *
 * @brief Set / get priority configuration for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority_config   - Priority config info
 */
int imb_port_priority_config_set(
    int unit,
    bcm_port_t port,
    const bcm_port_prio_config_t * priority_config);
/*! 
 * imb_port_priority_config_get
 *
 * @brief Set / get priority configuration for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  priority_config   - Priority config info
 */
int imb_port_priority_config_get(
    int unit,
    bcm_port_t port,
    bcm_port_prio_config_t * priority_config);

/*! 
 * imb_port_phy_measure_get
 *
 * @brief We can't measure the serdes freq directly, but we can measure the sync_eth counter, 
            and reconstruct the serdes freq from it by multiplying it with the blocks dividers. 
            In PML and PMH GSMII the dividers are:
            VCO                                                   Sync_eth counter
              _        --> PM synce_div --> NBIL/H synce div -->         _
            _| |_                                                      _| |_
            So 
            VCO = Fsynce * PMH_40_PML_20 * PM_1_7_11
            and we need to do:
            SerDes_rate = VCO/Oversample = Fsynce * PMH_40_PML_20 * PM_1_7_11 / Oversample

            In PMH which is not GSMII the dividers are:
            Serdes freq                                            Sync_eth counter
              _         --> PM synce_div --> NBIL/H synce div -->        _
            _| |_                                                      _| |_
            So we need to do:
            SerDes_rate = Fsynce * PMH_40_PML_20 * PM_1_7_11  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  is_rx           - use RX or TX FIFO to measure Serdes rate, only relevant for Fabric Serdes.
 * @param [out]  phy_measure     - PHY measure structure
 */
int imb_port_phy_measure_get(
    int unit,
    bcm_port_t port,
    int is_rx,
    soc_dnxc_port_phy_measure_t * phy_measure);

/*! 
 * imb_port_over_sampling_get
 *
 * @brief Get the over-sampling factor for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  os_int          - Over-sampling integer
 * @param [out]  os_remainder    - Over-sampling remainder after the decimal point
 */
int imb_port_over_sampling_get(
    int unit,
    bcm_port_t port,
    uint32 *os_int,
    uint32 *os_remainder);

/*! 
 * imb_port_autoneg_set
 *
 * @brief Set/Get autoneg properties 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [in]  an              - Auto Negotioation properties
 */
int imb_port_autoneg_set(
    int unit,
    bcm_port_t port,
    uint32 phy_flags,
    const phymod_autoneg_control_t * an);
/*! 
 * imb_port_autoneg_get
 *
 * @brief Set/Get autoneg properties 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  an              - Auto Negotioation properties
 */
int imb_port_autoneg_get(
    int unit,
    bcm_port_t port,
    uint32 phy_flags,
    phymod_autoneg_control_t * an);

/*! 
 * imb_port_link_get
 *
 * @brief Get link status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  link            - Link status indication up/down
 */
int imb_port_link_get(
    int unit,
    bcm_port_t port,
    int flags,
    int *link);

/*! 
 * imb_port_max_packet_size_set
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Max packet size
 */
int imb_port_max_packet_size_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_max_packet_size_get
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Max packet size
 */
int imb_port_max_packet_size_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_tx_average_ipg_set
 *
 * @brief Set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ipg_value       - Inter-packet gap to set
 */
int imb_port_tx_average_ipg_set(
    int unit,
    bcm_port_t port,
    int ipg_value);
/*! 
 * imb_port_tx_average_ipg_get
 *
 * @brief Set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ipg_value       - Get inter-packet gap
 */
int imb_port_tx_average_ipg_get(
    int unit,
    bcm_port_t port,
    int *ipg_value);

/*! 
 * imb_port_duplex_set
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Enable / disable port duplex. true=full duplex, false=half duplex
 */
int imb_port_duplex_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_duplex_get
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Get port duplex. true=full duplex, false=half duplex
 */
int imb_port_duplex_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_cntmaxsize_set
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  val             - Set max packet size that is used in statistics counter updates.
 */
int imb_port_cntmaxsize_set(
    int unit,
    bcm_port_t port,
    int val);
/*! 
 * imb_port_cntmaxsize_get
 *
 * @brief Disable lag failover. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - Get max packet size that is used in statistics counter updates.
 */
int imb_port_cntmaxsize_get(
    int unit,
    bcm_port_t port,
    int *val);

/*! 
 * imb_port_local_fault_status_get
 *
 * @brief Local fault steatus get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  local_fault     - Get local fault status
 */
int imb_port_local_fault_status_get(
    int unit,
    bcm_port_t port,
    int *local_fault);

/*! 
 * imb_port_local_fault_status_clear
 *
 * @brief Clear Local fault steatus 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_local_fault_status_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_remote_fault_status_get
 *
 * @brief Remote fault status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  remote_fault    - Get remote fault status
 */
int imb_port_remote_fault_status_get(
    int unit,
    bcm_port_t port,
    int *remote_fault);

/*! 
 * imb_port_remote_fault_status_clear
 *
 * @brief Clear Remote fault status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_remote_fault_status_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_local_fault_enable_set
 *
 * @brief local fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int imb_port_local_fault_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_local_fault_enable_get
 *
 * @brief local fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int imb_port_local_fault_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_remote_fault_enable_set
 *
 * @brief remote fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int imb_port_remote_fault_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_remote_fault_enable_get
 *
 * @brief remote fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int imb_port_remote_fault_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_tx_mac_sa_set
 *
 * @brief Set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - Source address for PAUSE/PFC packets generated by the MAC
 */
int imb_port_tx_mac_sa_set(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa);
/*! 
 * imb_port_tx_mac_sa_get
 *
 * @brief Set/get the MAC source address that will be sent in case of Pause/LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - Source address for PAUSE/PFC packets generated by the MAC
 */
int imb_port_tx_mac_sa_get(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa);

/*! 
 * imb_port_rx_mac_sa_set
 *
 * @brief Set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mac_sa          - Source Address recognized for MAC control packets in addition to the standard 0x0180C2000001
 */
int imb_port_rx_mac_sa_set(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa);
/*! 
 * imb_port_rx_mac_sa_get
 *
 * @brief Set/get SA recognized for MAC control packets in addition to the standard 0x0180C2000001 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  mac_sa          - Source Address recognized for MAC control packets in addition to the standard 0x0180C2000001
 */
int imb_port_rx_mac_sa_get(
    int unit,
    bcm_port_t port,
    sal_mac_addr_t mac_sa);

/*! 
 * imb_port_reset_set
 *
 * @brief Port Reset set/get - [this is not really supported in PHYMOD layer] 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - Phy reset mode. see phymod_reset_mode_t
 * @param [in]  opcode          - TBD
 * @param [in]  direction       - Phy reset direction. see phymod_reset_direction_t
 */
int imb_port_reset_set(
    int unit,
    bcm_port_t port,
    int mode,
    int opcode,
    int direction);
/*! 
 * imb_port_reset_get
 *
 * @brief Port Reset set/get - [this is not really supported in PHYMOD layer] 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  mode            - Phy reset mode. see phymod_reset_mode_t
 * @param [in]  opcode          - TBD
 * @param [out]  direction       - Phy reset direction. see phymod_reset_direction_t
 */
int imb_port_reset_get(
    int unit,
    bcm_port_t port,
    int mode,
    int opcode,
    int *direction);

/*! 
 * imb_port_pfc_control_set
 *
 * @brief Set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control         - Priority flow control configuration 
 */
int imb_port_pfc_control_set(
    int unit,
    bcm_port_t port,
    const portmod_pfc_control_t * control);
/*! 
 * imb_port_pfc_control_get
 *
 * @brief Set/get PFC FC configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  control         - Priority flow control configuration 
 */
int imb_port_pfc_control_get(
    int unit,
    bcm_port_t port,
    portmod_pfc_control_t * control);

/*! 
 * imb_port_eee_set
 *
 * @brief Set/get EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  eee             - EEE (Energy Eficient Ethernet) Timer Information.
 */
int imb_port_eee_set(
    int unit,
    bcm_port_t port,
    const portmod_eee_t * eee);
/*! 
 * imb_port_eee_get
 *
 * @brief Set/get EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  eee             - EEE (Energy Eficient Ethernet) Timer Information.
 */
int imb_port_eee_get(
    int unit,
    bcm_port_t port,
    portmod_eee_t * eee);

/*! 
 * imb_bandwidth_get
 *
 * @brief Get the Bandwidth for the CDU. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  is_port_include   - indication wether to include the specified port in the BW calculation
 * @param [out]  bandwidth       - bandwidth for all ports in CDU.
 */
int imb_bandwidth_get(
    int unit,
    bcm_port_t port,
    int is_port_include,
    int *bandwidth);

/*! 
 * imb_port_tx_start_thr_set
 *
 * @brief Set the Start TX threshold for the CDU. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed           - Port interface rate
 */
int imb_port_tx_start_thr_set(
    int unit,
    bcm_port_t port,
    int speed);

/*! 
 * imb_prd_enable_set
 *
 * @brief Set/get the PRD Enable mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable_mode     - PRD enable mode (0=>disable, 1=>only hard stage, 2=>hard and soft stgae)
 */
int imb_prd_enable_set(
    int unit,
    bcm_port_t port,
    int enable_mode);
/*! 
 * imb_prd_enable_get
 *
 * @brief Set/get the PRD Enable mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable_mode     - PRD enable mode (0=>disable, 1=>only hard stage, 2=>hard and soft stgae)
 */
int imb_prd_enable_get(
    int unit,
    bcm_port_t port,
    int *enable_mode);

/*!
 * @enum imb_prd_properties_e
 * @brief PRD properties 
 */
typedef enum imb_prd_properties_e
{
    imbImbPrdIgnoreIpDscp = 0,
    imbImbPrdIgnoreMplsExp = 1,
    imbImbPrdIgnoreInnerTag = 2,
    imbImbPrdIgnoreOuterTag = 3,
    imbImbPrdDefaultPriority = 4,
    imbImbPrdCount
} imb_prd_properties_t;

extern const enum_mapping_t imb_prd_properties_t_mapping[];
/* imb_prd_properties_t validation */
int imb_prd_properties_t_validate(
    int unit,
    imb_prd_properties_t imb_prd_properties);
/*! 
 * imb_prd_properties_set
 *
 * @brief Set/get PRD Properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  property        - PRD property to configure
 * @param [in]  val             - PRD Proeprty value
 */
int imb_prd_properties_set(
    int unit,
    bcm_port_t port,
    imb_prd_properties_t property,
    uint32 val);
/*! 
 * imb_prd_properties_get
 *
 * @brief Set/get PRD Properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  property        - PRD property to configure
 * @param [out]  val             - PRD Proeprty value
 */
int imb_prd_properties_get(
    int unit,
    bcm_port_t port,
    imb_prd_properties_t property,
    uint32 *val);

/*! 
 * imb_prd_map_set
 *
 * @brief Configure PRD priority maps. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  map             - PRD Map to configure
 * @param [in]  key             - Map key. composed differently according to the map type.              should be set by the user using the following MACROs:                 BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY(pcp, dei)                   BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY(tc, dp)                   BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY(dscp)                   BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY(exp)
 * @param [in]  priority        - PRD priority value
 */
int imb_prd_map_set(
    int unit,
    bcm_port_t port,
    bcm_cosq_ingress_port_drop_map_t map,
    uint32 key,
    uint32 priority);
/*! 
 * imb_prd_map_get
 *
 * @brief Configure PRD priority maps. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  map             - PRD Map to configure
 * @param [in]  key             - Map key. composed differently according to the map type.              should be set by the user using the following MACROs:                 BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY(pcp, dei)                   BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY(tc, dp)                   BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY(dscp)                   BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY(exp)
 * @param [out]  priority        - PRD priority value
 */
int imb_prd_map_get(
    int unit,
    bcm_port_t port,
    bcm_cosq_ingress_port_drop_map_t map,
    uint32 key,
    uint32 *priority);

/*! 
 * imb_prd_threshold_set
 *
 * @brief Configure PRD thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - PRD priority
 * @param [in]  threshold       - PRD threshols value (in entries) for the priority. threshold will be set for the RMC for which the priority is mapped.
 */
int imb_prd_threshold_set(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 threshold);
/*! 
 * imb_prd_threshold_get
 *
 * @brief Configure PRD thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - PRD priority
 * @param [out]  threshold       - PRD priority value (in entries) for the priority. threshold will be taken from the RMC for which the priority is mapped.
 */
int imb_prd_threshold_get(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 *threshold);

/*! 
 * imb_prd_tpid_set
 *
 * @brief Configure PRD TPIDs per port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tpid_index      - TPID index to set (0-3)
 * @param [in]  tpid_value      - TPID to be recognized by the port
 */
int imb_prd_tpid_set(
    int unit,
    bcm_port_t port,
    uint32 tpid_index,
    uint32 tpid_value);
/*! 
 * imb_prd_tpid_get
 *
 * @brief Configure PRD TPIDs per port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tpid_index      - TPID index to set (0-3)
 * @param [out]  tpid_value      - TPID recognized by the port
 */
int imb_prd_tpid_get(
    int unit,
    bcm_port_t port,
    uint32 tpid_index,
    uint32 *tpid_value);

/*! 
 * imb_prd_drop_count_get
 *
 * @brief Get PRD counter for the corresponding FIFO (RMC). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  sch_priority    - which scheduler is the PRD fifo mapped to
 * @param [out]  count           - PRD counter value
 */
int imb_prd_drop_count_get(
    int unit,
    bcm_port_t port,
    bcm_port_nif_scheduler_t sch_priority,
    uint64 *count);

/*! 
 * imb_prd_custom_ether_type_set
 *
 * @brief Set/Get PRD Configurable Ether types. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Custom Ether type code to assign to the Ether type(1-6)
 * @param [in]  ether_type_val   - Ether type value
 */
int imb_prd_custom_ether_type_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 ether_type_val);
/*! 
 * imb_prd_custom_ether_type_get
 *
 * @brief Set/Get PRD Configurable Ether types. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Custom Ether type code to assign to the Ether type(1-6)
 * @param [out]  ether_type_val   - Ether type value
 */
int imb_prd_custom_ether_type_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *ether_type_val);

/*! 
 * imb_prd_flex_key_entry_set
 *
 * @brief Set/Get PRD TCAM entries (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  key_index       - TCAM index to configure
 * @param [in]  flex_key_info   - TCAM entry information
 */
int imb_prd_flex_key_entry_set(
    int unit,
    bcm_port_t port,
    uint32 key_index,
    const bcm_cosq_ingress_drop_flex_key_entry_t * flex_key_info);
/*! 
 * imb_prd_flex_key_entry_get
 *
 * @brief Set/Get PRD TCAM entries (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  key_index       - TCAM index to configure
 * @param [out]  flex_key_info   - TCAM entry information
 */
int imb_prd_flex_key_entry_get(
    int unit,
    bcm_port_t port,
    uint32 key_index,
    bcm_cosq_ingress_drop_flex_key_entry_t * flex_key_info);

/*! 
 * imb_prd_flex_key_construct_set
 *
 * @brief Set/Get PRD TCAM key per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  flex_key_config   - TCAM key information
 */
int imb_prd_flex_key_construct_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    const bcm_cosq_ingress_drop_flex_key_construct_t * flex_key_config);
/*! 
 * imb_prd_flex_key_construct_get
 *
 * @brief Set/Get PRD TCAM key per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [out]  flex_key_config   - TCAM key information
 */
int imb_prd_flex_key_construct_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    bcm_cosq_ingress_drop_flex_key_construct_t * flex_key_config);

/*! 
 * imb_prd_control_frame_set
 *
 * @brief Set/Get PRD Control Frame proeprties. if a packet is identified as control frame, it will automatically get the highest priority. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control_frame_index   - Index of the control frame.
 * @param [in]  control_frame_config   - Control Frame properties
 */
int imb_prd_control_frame_set(
    int unit,
    bcm_port_t port,
    uint32 control_frame_index,
    const bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config);
/*! 
 * imb_prd_control_frame_get
 *
 * @brief Set/Get PRD Control Frame proeprties. if a packet is identified as control frame, it will automatically get the highest priority. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control_frame_index   - Index of the control frame.
 * @param [out]  control_frame_config   - Control Frame properties
 */
int imb_prd_control_frame_get(
    int unit,
    bcm_port_t port,
    uint32 control_frame_index,
    bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config);

/*! 
 * imb_prd_mpls_special_label_set
 *
 * @brief Set/Get PRD MPLS special label proeprties. if a packet is identified as MPLS special label and the label value matches to one of the saved special labels, the priority and TDM indication will be taken from the label properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  label_index     - Index of the control frame.
 * @param [in]  label_config    - MPLS special label properties
 */
int imb_prd_mpls_special_label_set(
    int unit,
    bcm_port_t port,
    uint32 label_index,
    const bcm_cosq_ingress_port_drop_mpls_special_label_config_t * label_config);
/*! 
 * imb_prd_mpls_special_label_get
 *
 * @brief Set/Get PRD MPLS special label proeprties. if a packet is identified as MPLS special label and the label value matches to one of the saved special labels, the priority and TDM indication will be taken from the label properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  label_index     - Index of the control frame.
 * @param [out]  label_config    - MPLS special label properties
 */
int imb_prd_mpls_special_label_get(
    int unit,
    bcm_port_t port,
    uint32 label_index,
    bcm_cosq_ingress_port_drop_mpls_special_label_config_t * label_config);

/*! 
 * imb_prd_is_custom_ether_type_get
 *
 * @brief Get indication whether the ether type code is configurable by the user or not 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code (0-15)
 * @param [out]  is_custom_ether_type   - is ether type mapped to the ether type code configurable by the user or not
 */
int imb_prd_is_custom_ether_type_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *is_custom_ether_type);

/*! 
 * imb_port_logical_lane_order_set
 *
 * @brief Set/Get the logical lane order for ILKN ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order      - ILKN Logical lane order. For pmOsILKN_50G, lane_order[N] is represent for the Nth lane; otherwise it is represent for logical lane N
 * @param [in]  lane_order_size   - Nof lanes of the ILKN port
 */
int imb_port_logical_lane_order_set(
    int unit,
    bcm_port_t port,
    const int *lane_order,
    int lane_order_size);
/*! 
 * imb_port_logical_lane_order_get
 *
 * @brief Set/Get the logical lane order for ILKN ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order_max_size   - Max lane numbers when get ILKN lane order
 * @param [out]  lane_order      - Logical lane order, lane_order[N] is represent for the Nth lane
 * @param [out]  lane_order_actual_size   - The actual lane numbers when get ILKN lane order
 */
int imb_port_logical_lane_order_get(
    int unit,
    bcm_port_t port,
    int lane_order_max_size,
    int *lane_order,
    int *lane_order_actual_size);

/*! 
 * imb_port_prbs_polynomial_set
 *
 * @brief Set/Get prbs polnomial value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  value           - prbs polynomial value
 */
int imb_port_prbs_polynomial_set(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    bcm_port_prbs_t value);
/*! 
 * imb_port_prbs_polynomial_get
 *
 * @brief Set/Get prbs polnomial value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  value           - prbs polynomial value
 */
int imb_port_prbs_polynomial_get(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    bcm_port_prbs_t * value);

/*! 
 * imb_port_prbs_invert_data_set
 *
 * @brief Set/Get prbs rx or tx data inversion status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  invert          - Enable or disable data inversion
 */
int imb_port_prbs_invert_data_set(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int invert);
/*! 
 * imb_port_prbs_invert_data_get
 *
 * @brief Set/Get prbs rx or tx data inversion status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  invert          - Enable or disablei data inversion
 */
int imb_port_prbs_invert_data_get(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int *invert);

/*! 
 * imb_port_prbs_enable_set
 *
 * @brief Set/Get prbs rx or tx enable status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  enable          - Enable or disable prbs
 */
int imb_port_prbs_enable_set(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int enable);
/*! 
 * imb_port_prbs_enable_get
 *
 * @brief Set/Get prbs rx or tx enable status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  enable          - Enable or disable prbs
 */
int imb_port_prbs_enable_get(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int *enable);

/*! 
 * imb_port_prbs_rx_status_get
 *
 * @brief Set/Get prbs status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  status          - Prbs status
 */
int imb_port_prbs_rx_status_get(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    int *status);

/*! 
 * imb_port_rx_fifo_status_get
 *
 * @brief Get rx fifo status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  sch_priority    - which scheduler is the PRD fifo mapped to
 * @param [out]  max_occupancy   - Indicates the corresponding lane MLF MAX fullness level of the FIFO
 * @param [out]  fifo_level      - Indicates the corresponding lane MLF fullness level of the FIFO
 */
int imb_port_rx_fifo_status_get(
    int unit,
    bcm_port_t port,
    bcm_port_nif_scheduler_t sch_priority,
    uint32 *max_occupancy,
    uint32 *fifo_level);

/*! 
 * imb_port_tx_fifo_status_get
 *
 * @brief Get tx fifo status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  max_occupancy   - Indicates the corresponding lane MLF MAX fullness level of the FIFO
 * @param [out]  fifo_level      - Indicates the corresponding lane MLF fullness level of the FIFO
 * @param [out]  pm_credits      - the number of credits received from the port-macro Tx buffer
 */
int imb_port_tx_fifo_status_get(
    int unit,
    bcm_port_t port,
    uint32 *max_occupancy,
    uint32 *fifo_level,
    uint32 *pm_credits);

/*! 
 * imb_port_low_latency_llfc_enable_set
 *
 * @brief Enable/Disable Low Latency LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_low_latency_llfc_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_low_latency_llfc_enable_get
 *
 * @brief Enable/Disable Low Latency LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_low_latency_llfc_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_fec_error_detect_enable_set
 *
 * @brief Enable/Disable FEC error detect 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_fec_error_detect_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_fec_error_detect_enable_get
 *
 * @brief Enable/Disable FEC error detect 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable FEC error detect
 */
int imb_port_fec_error_detect_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_llfc_after_fec_enable_set
 *
 * @brief Enable/Disable LLFC after FEC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable LLFC after FEC
 */
int imb_port_llfc_after_fec_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_llfc_after_fec_enable_get
 *
 * @brief Enable/Disable LLFC after FEC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable LLFC after FEC
 */
int imb_port_llfc_after_fec_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_extract_congestion_indication_from_llfc_enable_set
 *
 * @brief Enable/Disable extract congestion indication from LLFC cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable extract congestion indication from LLFC cells
 */
int imb_port_extract_congestion_indication_from_llfc_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_extract_congestion_indication_from_llfc_enable_get
 *
 * @brief Enable/Disable extract congestion indication from LLFC cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable extract congestion indication from LLFC cells
 */
int imb_port_extract_congestion_indication_from_llfc_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_control_cells_fec_bypass_enable_set
 *
 * @brief Enable/Disable FEC bypass on control cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable FEC bypass on control cells
 */
int imb_port_control_cells_fec_bypass_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_control_cells_fec_bypass_enable_get
 *
 * @brief Enable/Disable FEC bypass on control cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable FEC bypass on control cells
 */
int imb_port_control_cells_fec_bypass_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_speed_config_set
 *
 * @brief Port speed configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed_config    - Port speed configuration
 */
int imb_port_speed_config_set(
    int unit,
    bcm_port_t port,
    const portmod_speed_config_t * speed_config);
/*! 
 * imb_port_speed_config_get
 *
 * @brief Port speed configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  speed_config    - Port speed configuration
 */
int imb_port_speed_config_get(
    int unit,
    bcm_port_t port,
    portmod_speed_config_t * speed_config);

/*! 
 * imb_port_ilkn_counter_get
 *
 * @brief Get ilkn counter 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  counter_type    - counter type
 * @param [out]  counter_val     - ilkn counter value
 */
int imb_port_ilkn_counter_get(
    int unit,
    bcm_port_t port,
    int counter_type,
    uint64 *counter_val);

/*! 
 * imb_port_ilkn_counter_clear
 *
 * @brief Clear ilkn counter 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_ilkn_counter_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_autoneg_ability_advert_set
 *
 * @brief Set/Get port advertise abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  num_ability     - number of ability the port will advertise
 * @param [in]  abilities       - local advertisement for each ability
 */
int imb_port_autoneg_ability_advert_set(
    int unit,
    bcm_port_t port,
    int num_ability,
    const bcm_port_speed_ability_t * abilities);
/*! 
 * imb_port_autoneg_ability_advert_get
 *
 * @brief Set/Get port advertise abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_autoneg_ability_advert_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_speed_ability_local_get
 *
 * @brief Get the local speed abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_speed_ability_local_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_autoneg_ability_remote_get
 *
 * @brief Get the remote abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_autoneg_ability_remote_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_scheduler_config_set
 *
 * @brief Set port scheduler 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable port scheduler
 */
int imb_port_scheduler_config_set(
    int unit,
    bcm_port_t port,
    int enable);

/*! 
 * imb_port_resource_default_get
 *
 * @brief Get port's default resource configurations 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags
 * @param [out]  resource        - Port default resource configurations
 */
int imb_port_resource_default_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    bcm_port_resource_t * resource);

/*! 
 * imb_port_to_stif_instance_map_set
 *
 * @brief Map STIF instance ID with given port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  instace_id      - STIF instance id to map
 * @param [in]  instace_core    - STIF instance core to map
 * @param [in]  connect         - if TRUE connect the SIF instance to the port, if FALSE, disconnect the SIF instance
 */
int imb_port_to_stif_instance_map_set(
    int unit,
    bcm_port_t port,
    int instace_id,
    int instace_core,
    int connect);

/*! 
 * imb_phys_get
 *
 * @brief Get phys associated with imb instance 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [out]  phys            - phys associated with imb instance
 */
int imb_phys_get(
    int unit,
    int imb_id,
    bcm_pbmp_t * phys);

/*! 
 * imb_pms_reset_set
 *
 * @brief Reset pms 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [in]  in_reset        - 1 - reset, 0 - out of reset
 */
int imb_pms_reset_set(
    int unit,
    int imb_id,
    uint32 in_reset);
/*! 
 * imb_pms_reset_get
 *
 * @brief Reset pms 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [out]  in_reset        - 1 - reset, 0 - out of reset
 */
int imb_pms_reset_get(
    int unit,
    int imb_id,
    uint32 *in_reset);

/*! 
 * imb_port_gen_pfc_from_rmc_enable_set
 *
 * @brief Enable / disable a port's RMCs to produce PFC for the specified priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - Priority for the PFC that will be produced from the RMCs
 * @param [in]  enable          - Port RMCs to produce PFC enable/disable indication
 */
int imb_port_gen_pfc_from_rmc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 enable);
/*! 
 * imb_port_gen_pfc_from_rmc_enable_get
 *
 * @brief Enable / disable a port's RMCs to produce PFC for the specified priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - Priority for the PFC that will be produced from the RMCs
 * @param [out]  enable          - Port RMCs to produce PFC enabled indication
 */
int imb_port_gen_pfc_from_rmc_enable_get(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 *enable);

/*! 
 * imb_port_gen_llfc_from_rmc_enable_set
 *
 * @brief Enable / disable port's RMCs(all lanes) to generate LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port's RMCs(all lanes) to generate LLFC enable/disable indication
 */
int imb_port_gen_llfc_from_rmc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable);

/*! 
 * imb_port_stop_pm_from_cfc_llfc_enable_set
 *
 * @brief Enable / disable PM to stop TX on all of a port's lanes according to a LLFC signal from CFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_port_stop_pm_from_cfc_llfc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable);

/*! 
 * imb_port_fc_rx_qmlf_threshold_set
 *
 * @brief Set / get a port's Rx Quad MAC Lane FIFO (QMLF) Flow Control generation thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags to determine the threshold type (set/clear for PFC of set/clear for LLFC)
 * @param [in]  threshold       - Rx Quad MAC Lane FIFO (QMLF) Flow Control generation threshold value
 */
int imb_port_fc_rx_qmlf_threshold_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 threshold);
/*! 
 * imb_port_fc_rx_qmlf_threshold_get
 *
 * @brief Set / get a port's Rx Quad MAC Lane FIFO (QMLF) Flow Control generation thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags to determine the threshold type (set/clear for PFC of set/clear for LLFC)
 * @param [out]  threshold       - Rx Quad MAC Lane FIFO (QMLF) Flow Control generation threshold value
 */
int imb_port_fc_rx_qmlf_threshold_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 *threshold);

/*! 
 * imb_fc_reset_all
 *
 * @brief Set the Flow Control Interface in/out of reset for all CDUs. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  in_reset        - 1 - reset, 0 - out of reset
 */
int imb_fc_reset_all(
    int unit,
    uint32 in_reset);

/*! 
 * imb_fc_reset_set
 *
 * @brief Set the Flow Control Interface in/out of reset for a specified CDU. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 * @param [in]  in_reset        - 1 - reset, 0 - out of reset
 */
int imb_fc_reset_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 in_reset);

/*! 
 * imb_llfc_from_glb_rsc_enable_all
 *
 * @brief Enable / disable the generation of a LLFC based on a signal from Global Resources thresholds for all CDUs 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_llfc_from_glb_rsc_enable_all(
    int unit,
    uint32 enable);

/*! 
 * imb_llfc_from_glb_rsc_enable_set
 *
 * @brief Enable / disable the generation of a LLFC based on a signal from Global Resources thresholds for a specified CDU 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_llfc_from_glb_rsc_enable_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 enable);

/*! 
 * imb_pfc_rec_priority_map
 *
 * @brief Per CDU map the received PFC - each priority received by NIF should be mapped to a priority that will be sent to EGQ in order to stop a Q-pair 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [in]  nif_priority    - Priority of the PFC received by NIF
 * @param [in]  egq_priority    - Priority of the PFC sent to EGQ
 */
int imb_pfc_rec_priority_map(
    int unit,
    int imb_id,
    uint32 nif_priority,
    uint32 egq_priority);

/*! 
 * imb_pfc_rec_priority_unmap
 *
 * @brief Per CDU unmap all priorities of the received PFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 */
int imb_pfc_rec_priority_unmap(
    int unit,
    int imb_id);

#endif /*_IMB_H_*/
