/** \file dnx_data_internal_egr_queuing.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_EGR_QUEUING_H_
/*{*/
#define _DNX_DATA_INTERNAL_EGR_QUEUING_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_egr_queuing.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_egr_queuing_submodule_params,

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_submodule_nof
} dnx_data_egr_queuing_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE PARAMS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_egr_queuing_params_feature_get(
    int unit,
    dnx_data_egr_queuing_params_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_egr_queuing_params_define_nof_bits_in_tcg_weight,
    dnx_data_egr_queuing_params_define_nof_bits_in_nof_q_pairs_in_ps,
    dnx_data_egr_queuing_params_define_nof_q_pairs_in_ps,
    dnx_data_egr_queuing_params_define_nof_bits_in_q_pair,
    dnx_data_egr_queuing_params_define_nof_q_pairs,
    dnx_data_egr_queuing_params_define_nof_bits_in_nof_port_schedulers,
    dnx_data_egr_queuing_params_define_nof_port_schedulers,
    dnx_data_egr_queuing_params_define_nof_bits_in_calendar_size,
    dnx_data_egr_queuing_params_define_calendar_size,
    dnx_data_egr_queuing_params_define_nof_bits_in_nof_calendars,
    dnx_data_egr_queuing_params_define_nof_calendars,
    dnx_data_egr_queuing_params_define_nof_bits_in_egr_interface,
    dnx_data_egr_queuing_params_define_nof_egr_interfaces,
    dnx_data_egr_queuing_params_define_reserved_if,
    dnx_data_egr_queuing_params_define_egr_if_cpu,
    dnx_data_egr_queuing_params_define_egr_if_sat,
    dnx_data_egr_queuing_params_define_egr_if_oam,
    dnx_data_egr_queuing_params_define_egr_if_olp,
    dnx_data_egr_queuing_params_define_egr_if_rcy,
    dnx_data_egr_queuing_params_define_egr_if_txi_rcy,
    dnx_data_egr_queuing_params_define_egr_if_eventor,
    dnx_data_egr_queuing_params_define_cal_res,
    dnx_data_egr_queuing_params_define_cal_burst_res,
    dnx_data_egr_queuing_params_define_nof_bits_in_cal_cal_len,
    dnx_data_egr_queuing_params_define_cal_cal_len,
    dnx_data_egr_queuing_params_define_nof_bits_in_nif_cal_len,
    dnx_data_egr_queuing_params_define_nif_cal_len,
    dnx_data_egr_queuing_params_define_nof_bits_in_nof_tcg,
    dnx_data_egr_queuing_params_define_nof_tcg,
    dnx_data_egr_queuing_params_define_nof_bits_in_nof_egr_q_prio,
    dnx_data_egr_queuing_params_define_nof_egr_q_prio,
    dnx_data_egr_queuing_params_define_tcg_min_priorities,
    dnx_data_egr_queuing_params_define_max_credit_number,
    dnx_data_egr_queuing_params_define_max_gbps_rate_egq,
    dnx_data_egr_queuing_params_define_txq_iready_th,
    dnx_data_egr_queuing_params_define_txq_tdm_iready_th,
    dnx_data_egr_queuing_params_define_tdm_interleve,
    dnx_data_egr_queuing_params_define_tdm_tc,
    dnx_data_egr_queuing_params_define_tdm_dp,
    dnx_data_egr_queuing_params_define_tdm_exist,
    dnx_data_egr_queuing_params_define_invalid_otm_port,

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_params_define_nof
} dnx_data_egr_queuing_params_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_bits_in_tcg_weight
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_tcg_weight'
 * number of bits in 'weight' representation of a TCG. See EPS_DWM_8P
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_tcg_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_tcg_weight_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_q_pairs_in_ps
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_q_pairs_in_ps'
 * number of bits in 'nof_q_pairs_in_ps' representation. Essentially, log2(nof_q_pairs_in_ps)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_q_pairs_in_ps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_nof_q_pairs_in_ps_get(
    int unit);

/**
 * \brief returns define data of nof_q_pairs_in_ps
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_q_pairs_in_ps'
 * Number of qpairs per one port scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_q_pairs_in_ps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_q_pairs_in_ps_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_q_pair
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_q_pair'
 * number of bits in 'queue pair' representation. Essentially, log2(nof_q_pairs)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_q_pair - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_q_pair_get(
    int unit);

/**
 * \brief returns define data of nof_q_pairs
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_q_pairs'
 * Number of q_pairs per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_q_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_q_pairs_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_port_schedulers
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_port_schedulers'
 * number of bits in 'nof_port_schedulers' representation. Essentially, log2(nof_port_schedulers)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_port_schedulers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_nof_port_schedulers_get(
    int unit);

/**
 * \brief returns define data of nof_port_schedulers
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_port_schedulers'
 * Number of port schedulers per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_port_schedulers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_port_schedulers_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_calendar_size'
 * number of bits in 'num. of entries in calendar' representation. Essentially, log2(calendar_size)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_calendar_size_get(
    int unit);

/**
 * \brief returns define data of calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'calendar_size'
 * number of entries in calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_calendar_size_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_calendars
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_calendars'
 * number of bits in 'egr nof_calendars' representation. Essentially, log2(nof_calendars)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_nof_calendars_get(
    int unit);

/**
 * \brief returns define data of nof_calendars
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_calendars'
 * Number of calendar-pairs per core. Total number of calendars is twice this value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_calendars_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_egr_interface
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_egr_interface'
 * number of bits in 'egr interface' representation. Essentially, log2(nof_egr_interfaces)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_egr_interface - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_egr_interface_get(
    int unit);

/**
 * \brief returns define data of nof_egr_interfaces
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_egr_interfaces'
 * Number of egr interfaces, per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_egr_interfaces_get(
    int unit);

/**
 * \brief returns define data of reserved_if
 * Module - 'egr_queuing', Submodule - 'params', data - 'reserved_if'
 * reserved interface (used for dummy flow control mapping in LAG SCH)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_reserved_if_get(
    int unit);

/**
 * \brief returns define data of egr_if_cpu
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_cpu'
 * cpu interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_cpu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_egr_if_cpu_get(
    int unit);

/**
 * \brief returns define data of egr_if_sat
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_sat'
 * sat interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_sat - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_egr_if_sat_get(
    int unit);

/**
 * \brief returns define data of egr_if_oam
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_oam'
 * oam interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_oam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_egr_if_oam_get(
    int unit);

/**
 * \brief returns define data of egr_if_olp
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_olp'
 * olp interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_olp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_egr_if_olp_get(
    int unit);

/**
 * \brief returns define data of egr_if_rcy
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_rcy'
 * recycle interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_rcy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_egr_if_rcy_get(
    int unit);

/**
 * \brief returns define data of egr_if_txi_rcy
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_txi_rcy'
 * txi recycle interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_txi_rcy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_egr_if_txi_rcy_get(
    int unit);

/**
 * \brief returns define data of egr_if_eventor
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_eventor'
 * eventor interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_eventor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_egr_if_eventor_get(
    int unit);

/**
 * \brief returns define data of cal_res
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_res'
 * calendar resolution
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_res - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_cal_res_get(
    int unit);

/**
 * \brief returns define data of cal_burst_res
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_burst_res'
 * calendar resolution
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_burst_res - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_cal_burst_res_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_cal_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_cal_cal_len'
 * Number of bits in representation of cal_cal_len (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_cal_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_cal_cal_len_get(
    int unit);

/**
 * \brief returns define data of cal_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_cal_len'
 * calcal calendar length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_cal_cal_len_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_nif_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nif_cal_len'
 * Number of bits in representation of nif_cal_len (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nif_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_nif_cal_len_get(
    int unit);

/**
 * \brief returns define data of nif_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'nif_cal_len'
 * nif calendar length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nif_cal_len_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_tcg
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_tcg'
 * Number of bits in representation of nof_tcg (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_nof_tcg_get(
    int unit);

/**
 * \brief returns define data of nof_tcg
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_tcg'
 * Number of TC groups supported by this system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_tcg_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_egr_q_prio
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_egr_q_prio'
 * Number of bits in representation of nof_egr_q_prio (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_egr_q_prio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_bits_in_nof_egr_q_prio_get(
    int unit);

/**
 * \brief returns define data of nof_egr_q_prio
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_egr_q_prio'
 * Number of egress priorities for unscheduled traffic
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_q_prio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_nof_egr_q_prio_get(
    int unit);

/**
 * \brief returns define data of tcg_min_priorities
 * Module - 'egr_queuing', Submodule - 'params', data - 'tcg_min_priorities'
 * minimum number of priorities supported by tcg
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcg_min_priorities - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_tcg_min_priorities_get(
    int unit);

/**
 * \brief returns define data of max_credit_number
 * Module - 'egr_queuing', Submodule - 'params', data - 'max_credit_number'
 * the maximum number of credits supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_credit_number - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_max_credit_number_get(
    int unit);

/**
 * \brief returns define data of max_gbps_rate_egq
 * Module - 'egr_queuing', Submodule - 'params', data - 'max_gbps_rate_egq'
 * EGQ Maximum Gb/s rate. This is the upper boundary, it can be lower depending on the credit size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_gbps_rate_egq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_max_gbps_rate_egq_get(
    int unit);

/**
 * \brief returns define data of txq_iready_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'txq_iready_th'
 * Define ready TXQ treshold in PDs for non TDM queues, when Q is above this treshold FQP block relevant interface in EPS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     txq_iready_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_txq_iready_th_get(
    int unit);

/**
 * \brief returns define data of txq_tdm_iready_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'txq_tdm_iready_th'
 * Define ready TXQ treshold in PDs for TDM queues, when Q is above this treshold FQP block relevant interface in EPS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     txq_tdm_iready_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_txq_tdm_iready_th_get(
    int unit);

/**
 * \brief returns numeric data of tdm_interleve
 * Module - 'egr_queuing', Submodule - 'params', data - 'tdm_interleve'
 * Boolean. TDM interleaved queuing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_interleve - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_tdm_interleve_get(
    int unit);

/**
 * \brief returns numeric data of tdm_tc
 * Module - 'egr_queuing', Submodule - 'params', data - 'tdm_tc'
 * TDM traffic class
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_tc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_tdm_tc_get(
    int unit);

/**
 * \brief returns numeric data of tdm_dp
 * Module - 'egr_queuing', Submodule - 'params', data - 'tdm_dp'
 * TDM drop precident
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_dp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_tdm_dp_get(
    int unit);

/**
 * \brief returns numeric data of tdm_exist
 * Module - 'egr_queuing', Submodule - 'params', data - 'tdm_exist'
 * Boolean. is TDM exist in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_exist - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_tdm_exist_get(
    int unit);

/**
 * \brief returns numeric data of invalid_otm_port
 * Module - 'egr_queuing', Submodule - 'params', data - 'invalid_otm_port'
 * tm port that is marked as invalid (per core)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     invalid_otm_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_egr_queuing_params_invalid_otm_port_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_egr_queuing_params_table_if_speed_params,
    dnx_data_egr_queuing_params_table_emr_fifo,
    dnx_data_egr_queuing_params_table_port_spr_pkt_mode,

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_params_table_nof
} dnx_data_egr_queuing_params_table_e;

/* Get Data */
/**
 * \brief get table if_speed_params entry 
 * per port speed thresholds
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * 
 * \return
 *     if_speed_params - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_if_speed_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_egr_queuing_params_if_speed_params_t * dnx_data_egr_queuing_params_if_speed_params_get(
    int unit,
    int idx);

/**
 * \brief get table emr_fifo entry 
 * emr fifo parameters
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * \param [in] tdm - tdm exist in the system
 * 
 * \return
 *     emr_fifo - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_emr_fifo_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_egr_queuing_params_emr_fifo_t * dnx_data_egr_queuing_params_emr_fifo_get(
    int unit,
    int idx,
    int tdm);

/**
 * \brief get table port_spr_pkt_mode entry 
 * is shaper working at packet mode
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     port_spr_pkt_mode - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_port_spr_pkt_mode_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_egr_queuing_params_port_spr_pkt_mode_t * dnx_data_egr_queuing_params_port_spr_pkt_mode_get(
    int unit,
    int port);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'egr_queuing', Submodule - 'params', table - 'if_speed_params'
 * per port speed thresholds
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_egr_queuing_params_if_speed_params_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'egr_queuing', Submodule - 'params', table - 'emr_fifo'
 * emr fifo parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_egr_queuing_params_emr_fifo_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'egr_queuing', Submodule - 'params', table - 'port_spr_pkt_mode'
 * is shaper working at packet mode
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_egr_queuing_params_port_spr_pkt_mode_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)if_speed_params info
 * per port speed thresholds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     if_speed_params - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_egr_queuing_params_if_speed_params_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)emr_fifo info
 * emr fifo parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     emr_fifo - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_egr_queuing_params_emr_fifo_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)port_spr_pkt_mode info
 * is shaper working at packet mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_spr_pkt_mode - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_egr_queuing_params_port_spr_pkt_mode_info_get(
    int unit);

/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_egr_queuing_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_EGR_QUEUING_H_*/
/* *INDENT-ON* */
