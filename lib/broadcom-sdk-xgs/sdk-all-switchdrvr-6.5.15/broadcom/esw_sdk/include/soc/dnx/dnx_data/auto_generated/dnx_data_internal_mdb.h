/** \file dnx_data_internal_mdb.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_MDB_H_
/*{*/
#define _DNX_DATA_INTERNAL_MDB_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_mdb.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_mdb_submodule_global,
    dnx_data_mdb_submodule_dh,
    dnx_data_mdb_submodule_pdbs,
    dnx_data_mdb_submodule_em,
    dnx_data_mdb_submodule_direct,
    dnx_data_mdb_submodule_eedb,
    dnx_data_mdb_submodule_kaps,
    dnx_data_mdb_submodule_hw_bug,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_submodule_nof
} dnx_data_mdb_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GLOBAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_global_feature_get(
    int unit,
    dnx_data_mdb_global_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_global_define_nof
} dnx_data_mdb_global_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_global_table_nof
} dnx_data_mdb_global_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DH:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_dh_feature_get(
    int unit,
    dnx_data_mdb_dh_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_dh_define_nof_macroes_type_A,
    dnx_data_mdb_dh_define_nof_macroes_type_B,
    dnx_data_mdb_dh_define_total_nof_macroes,
    dnx_data_mdb_dh_define_total_nof_macroes_plus_em_ovf_or_eedb_bank,
    dnx_data_mdb_dh_define_total_nof_macroes_plus_data_width,
    dnx_data_mdb_dh_define_max_nof_cluster_interfaces,
    dnx_data_mdb_dh_define_nof_macro_clusters,
    dnx_data_mdb_dh_define_nof_bucket_clusters,
    dnx_data_mdb_dh_define_nof_buckets_in_macro,
    dnx_data_mdb_dh_define_nof_pair_clusters,
    dnx_data_mdb_dh_define_nof_rows_in_macro_a_cluster,
    dnx_data_mdb_dh_define_nof_rows_in_macro_b_cluster,
    dnx_data_mdb_dh_define_nof_rows_in_eedb_bank,
    dnx_data_mdb_dh_define_nof_data_rows_per_hitbit_row,
    dnx_data_mdb_dh_define_nof_rows_in_eedb_hitbit_bank,
    dnx_data_mdb_dh_define_cluster_row_width_bits,
    dnx_data_mdb_dh_define_dhha_nof_blocks,
    dnx_data_mdb_dh_define_dhhb_nof_blocks,
    dnx_data_mdb_dh_define_dhc_nof_blocks,
    dnx_data_mdb_dh_define_data_out_granularity,
    dnx_data_mdb_dh_define_dma_desc_aggregator_chain_length_max,
    dnx_data_mdb_dh_define_dma_desc_aggregator_buff_size_kb,
    dnx_data_mdb_dh_define_dma_desc_aggregator_timeout_usec,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_dh_define_nof
} dnx_data_mdb_dh_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_macroes_type_A
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macroes_type_A'
 * The NOF type A macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macroes_type_A - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_macroes_type_A_get(
    int unit);

/**
 * \brief returns define data of nof_macroes_type_B
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macroes_type_B'
 * The NOF type B macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macroes_type_B - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_macroes_type_B_get(
    int unit);

/**
 * \brief returns define data of total_nof_macroes
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes'
 * the total NOF macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_total_nof_macroes_get(
    int unit);

/**
 * \brief returns define data of total_nof_macroes_plus_em_ovf_or_eedb_bank
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes_plus_em_ovf_or_eedb_bank'
 * the total NOF macroes in the device plus another place for either the OVF buffer for EM tables or banks for EEDB tables.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes_plus_em_ovf_or_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_total_nof_macroes_plus_em_ovf_or_eedb_bank_get(
    int unit);

/**
 * \brief returns define data of total_nof_macroes_plus_data_width
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes_plus_data_width'
 * he total NOF macroes in the device plus another place for the data width.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes_plus_data_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_total_nof_macroes_plus_data_width_get(
    int unit);

/**
 * \brief returns define data of max_nof_cluster_interfaces
 * Module - 'mdb', Submodule - 'dh', data - 'max_nof_cluster_interfaces'
 * max NOF interfaces that can be associated with a single cluster.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_cluster_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_max_nof_cluster_interfaces_get(
    int unit);

/**
 * \brief returns define data of nof_macro_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macro_clusters'
 * nof clusters in a single macro.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macro_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_macro_clusters_get(
    int unit);

/**
 * \brief returns define data of nof_bucket_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_bucket_clusters'
 * nof clusters in a a bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bucket_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_bucket_clusters_get(
    int unit);

/**
 * \brief returns define data of nof_buckets_in_macro
 * Module - 'mdb', Submodule - 'dh', data - 'nof_buckets_in_macro'
 * The NOF buckets in a macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_buckets_in_macro - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_buckets_in_macro_get(
    int unit);

/**
 * \brief returns define data of nof_pair_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_pair_clusters'
 * nof clusters in a pair.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pair_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_pair_clusters_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_macro_a_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_macro_a_cluster'
 * NOF rows in a cluster that is places on a macro of type A.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_macro_a_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_rows_in_macro_a_cluster_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_macro_b_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_macro_b_cluster'
 * NOF rows in a cluster that is places on a macro of type B.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_macro_b_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_rows_in_macro_b_cluster_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_eedb_bank
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_eedb_bank'
 * NOF rows in an EEDB bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_rows_in_eedb_bank_get(
    int unit);

/**
 * \brief returns define data of nof_data_rows_per_hitbit_row
 * Module - 'mdb', Submodule - 'dh', data - 'nof_data_rows_per_hitbit_row'
 * How many eedb rows each hitbit row is mapped to
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_data_rows_per_hitbit_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_data_rows_per_hitbit_row_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_eedb_hitbit_bank
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_eedb_hitbit_bank'
 * How many rows in each eedb hitbit bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_eedb_hitbit_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_nof_rows_in_eedb_hitbit_bank_get(
    int unit);

/**
 * \brief returns define data of cluster_row_width_bits
 * Module - 'mdb', Submodule - 'dh', data - 'cluster_row_width_bits'
 * NOF bits in a single cluster row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cluster_row_width_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_cluster_row_width_bits_get(
    int unit);

/**
 * \brief returns define data of dhha_nof_blocks
 * Module - 'mdb', Submodule - 'dh', data - 'dhha_nof_blocks'
 * NOF DHHA blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dhha_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_dhha_nof_blocks_get(
    int unit);

/**
 * \brief returns define data of dhhb_nof_blocks
 * Module - 'mdb', Submodule - 'dh', data - 'dhhb_nof_blocks'
 * NOF DHHB blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dhhb_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_dhhb_nof_blocks_get(
    int unit);

/**
 * \brief returns define data of dhc_nof_blocks
 * Module - 'mdb', Submodule - 'dh', data - 'dhc_nof_blocks'
 * NOF DHC blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dhc_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_dhc_nof_blocks_get(
    int unit);

/**
 * \brief returns define data of data_out_granularity
 * Module - 'mdb', Submodule - 'dh', data - 'data_out_granularity'
 * The granularity used for data out.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_out_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_data_out_granularity_get(
    int unit);

/**
 * \brief returns numeric data of dma_desc_aggregator_chain_length_max
 * Module - 'mdb', Submodule - 'dh', data - 'dma_desc_aggregator_chain_length_max'
 * Maximal number of descriptors in a single chain.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_desc_aggregator_chain_length_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_dma_desc_aggregator_chain_length_max_get(
    int unit);

/**
 * \brief returns numeric data of dma_desc_aggregator_buff_size_kb
 * Module - 'mdb', Submodule - 'dh', data - 'dma_desc_aggregator_buff_size_kb'
 * Total size in KB of dmmable memory allocated in favor of the descriptor DMA double-buffer.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_desc_aggregator_buff_size_kb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_dma_desc_aggregator_buff_size_kb_get(
    int unit);

/**
 * \brief returns numeric data of dma_desc_aggregator_timeout_usec
 * Module - 'mdb', Submodule - 'dh', data - 'dma_desc_aggregator_timeout_usec'
 * Timeout between the creation of a descriptor chain and its commit to HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_desc_aggregator_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_dh_dma_desc_aggregator_timeout_usec_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_dh_table_dh_info,
    dnx_data_mdb_dh_table_macro_interface_mapping,
    dnx_data_mdb_dh_table_block_info,
    dnx_data_mdb_dh_table_entry_banks_info,
    dnx_data_mdb_dh_table_cluster_fmt_atr_info,
    dnx_data_mdb_dh_table_mdb_1_info,
    dnx_data_mdb_dh_table_mdb_3_info,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_dh_table_nof
} dnx_data_mdb_dh_table_e;

/* Get Data */
/**
 * \brief get table dh_info entry 
 * general information of the MDB data handlers
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     dh_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_dh_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_dh_info_t * dnx_data_mdb_dh_dh_info_get(
    int unit,
    int mdb_table_id);

/**
 * \brief get table macro_interface_mapping entry 
 * The available interfaces for each macro
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     macro_interface_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_macro_interface_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_macro_interface_mapping_t * dnx_data_mdb_dh_macro_interface_mapping_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table block_info entry 
 * holds the DH blocks information.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     block_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_block_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_block_info_t * dnx_data_mdb_dh_block_info_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table entry_banks_info entry 
 * holds the DHs entry banks and ABK banks information.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     entry_banks_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_entry_banks_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_entry_banks_info_t * dnx_data_mdb_dh_entry_banks_info_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table cluster_fmt_atr_info entry 
 * holds the cluster format attribute information
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     cluster_fmt_atr_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_cluster_fmt_atr_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_cluster_fmt_atr_info_t * dnx_data_mdb_dh_cluster_fmt_atr_info_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_1_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_1_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_1_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_mdb_1_info_t * dnx_data_mdb_dh_mdb_1_info_get(
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_3_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_3_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_3_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_dh_mdb_3_info_t * dnx_data_mdb_dh_mdb_3_info_get(
    int unit,
    int global_macro_index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'dh_info'
 * general information of the MDB data handlers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_dh_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'macro_interface_mapping'
 * The available interfaces for each macro
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_macro_interface_mapping_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'block_info'
 * holds the DH blocks information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_block_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'entry_banks_info'
 * holds the DHs entry banks and ABK banks information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_entry_banks_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'cluster_fmt_atr_info'
 * holds the cluster format attribute information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_cluster_fmt_atr_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'mdb_1_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_mdb_1_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'dh', table - 'mdb_3_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_dh_mdb_3_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)dh_info info
 * general information of the MDB data handlers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_dh_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)macro_interface_mapping info
 * The available interfaces for each macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     macro_interface_mapping - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_macro_interface_mapping_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)block_info info
 * holds the DH blocks information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     block_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_block_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)entry_banks_info info
 * holds the DHs entry banks and ABK banks information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_banks_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_entry_banks_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)cluster_fmt_atr_info info
 * holds the cluster format attribute information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cluster_fmt_atr_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_cluster_fmt_atr_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_1_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_1_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_mdb_1_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_3_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_3_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_dh_mdb_3_info_info_get(
    int unit);

/*
 * SUBMODULE PDBS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_pdbs_feature_get(
    int unit,
    dnx_data_mdb_pdbs_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_pdbs_define_max_nof_interface_dhs,
    dnx_data_mdb_pdbs_define_fec_extra_cluster_allocation,
    dnx_data_mdb_pdbs_define_kaps_nof_blocks,
    dnx_data_mdb_pdbs_define_mesh_mode_support,
    dnx_data_mdb_pdbs_define_max_key_size,
    dnx_data_mdb_pdbs_define_max_payload_size,
    dnx_data_mdb_pdbs_define_table_mdb_9_mdb_item_1_array_size,
    dnx_data_mdb_pdbs_define_table_mdb_9_mdb_item_2_array_size,
    dnx_data_mdb_pdbs_define_table_mdb_9_mdb_item_3_array_size,
    dnx_data_mdb_pdbs_define_mdb_kaps_a_size,
    dnx_data_mdb_pdbs_define_mdb_kaps_b_size,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_pdbs_define_nof
} dnx_data_mdb_pdbs_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_interface_dhs
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_nof_interface_dhs'
 * Max nof different DHs that can be associated with a single interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_interface_dhs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_max_nof_interface_dhs_get(
    int unit);

/**
 * \brief returns define data of fec_extra_cluster_allocation
 * Module - 'mdb', Submodule - 'pdbs', data - 'fec_extra_cluster_allocation'
 * The FECs tables can have their clusters moved between them dynamically so they need extra initial allocation of clusters to have room for that.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_extra_cluster_allocation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_fec_extra_cluster_allocation_get(
    int unit);

/**
 * \brief returns define data of kaps_nof_blocks
 * Module - 'mdb', Submodule - 'pdbs', data - 'kaps_nof_blocks'
 * NOF KPAS blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kaps_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_kaps_nof_blocks_get(
    int unit);

/**
 * \brief returns define data of mesh_mode_support
 * Module - 'mdb', Submodule - 'pdbs', data - 'mesh_mode_support'
 * Indicate if the device support mesh mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_mode_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_mesh_mode_support_get(
    int unit);

/**
 * \brief returns define data of max_key_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_key_size'
 * The largest key size from all the PDBs key sizes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_max_key_size_get(
    int unit);

/**
 * \brief returns define data of max_payload_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_payload_size'
 * The largest payload size from all the PDBs payloads sizes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_max_payload_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_1_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_1_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_1_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_9_mdb_item_1_array_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_2_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_2_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_2_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_9_mdb_item_2_array_size_get(
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_3_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_3_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_3_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_table_mdb_9_mdb_item_3_array_size_get(
    int unit);

/**
 * \brief returns numeric data of mdb_kaps_a_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'mdb_kaps_a_size'
 * The KAPS A size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_kaps_a_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_mdb_kaps_a_size_get(
    int unit);

/**
 * \brief returns numeric data of mdb_kaps_b_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'mdb_kaps_b_size'
 * The KAPS B size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_kaps_b_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_pdbs_mdb_kaps_b_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_pdbs_table_mdb_profile,
    dnx_data_mdb_pdbs_table_pdbs_info,
    dnx_data_mdb_pdbs_table_pdb_info,
    dnx_data_mdb_pdbs_table_mdb_11_info,
    dnx_data_mdb_pdbs_table_mdb_12_info,
    dnx_data_mdb_pdbs_table_mdb_26_info,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_pdbs_table_nof
} dnx_data_mdb_pdbs_table_e;

/* Get Data */
/**
 * \brief get table mdb_profile entry 
 * MDB profile SoC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_profile_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_profile_t * dnx_data_mdb_pdbs_mdb_profile_get(
    int unit);

/**
 * \brief get table pdbs_info entry 
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     pdbs_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_pdbs_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_pdbs_info_t * dnx_data_mdb_pdbs_pdbs_info_get(
    int unit,
    int mdb_table_id);

/**
 * \brief get table pdb_info entry 
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB
 * 
 * \return
 *     pdb_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_pdb_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_pdb_info_t * dnx_data_mdb_pdbs_pdb_info_get(
    int unit,
    int dbal_id);

/**
 * \brief get table mdb_11_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_11_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_11_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_11_info_t * dnx_data_mdb_pdbs_mdb_11_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_12_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_12_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_12_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_12_info_t * dnx_data_mdb_pdbs_mdb_12_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_26_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_26_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_26_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_pdbs_mdb_26_info_t * dnx_data_mdb_pdbs_mdb_26_info_get(
    int unit,
    int mdb_table);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_profile'
 * MDB profile SoC property
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_profile_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'pdbs_info'
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_pdbs_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'pdb_info'
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_pdb_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_11_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_11_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_12_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_12_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'pdbs', table - 'mdb_26_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_pdbs_mdb_26_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)mdb_profile info
 * MDB profile SoC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_profile_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)pdbs_info info
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pdbs_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_pdbs_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)pdb_info info
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pdb_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_pdb_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_11_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_11_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_11_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_12_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_12_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_12_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_26_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_26_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_pdbs_mdb_26_info_info_get(
    int unit);

/*
 * SUBMODULE EM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_em_feature_get(
    int unit,
    dnx_data_mdb_em_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_em_define_total_nof_lem_aging_bits,
    dnx_data_mdb_em_define_total_nof_exem_aging_bits,
    dnx_data_mdb_em_define_age_row_size_bits,
    dnx_data_mdb_em_define_age_ovfcam_row_size_bits,
    dnx_data_mdb_em_define_age_entry_size_bits,
    dnx_data_mdb_em_define_ovf_cam_max_size,
    dnx_data_mdb_em_define_age_support_per_entry_size_ratio,
    dnx_data_mdb_em_define_nof_aging_profiles,
    dnx_data_mdb_em_define_aging_profiles_size_in_bits,
    dnx_data_mdb_em_define_max_tid_size,
    dnx_data_mdb_em_define_max_nof_tids,
    dnx_data_mdb_em_define_flush_support_tids,
    dnx_data_mdb_em_define_flush_max_supported_key,
    dnx_data_mdb_em_define_flush_max_supported_payload,
    dnx_data_mdb_em_define_nof_lem_mact_apps,
    dnx_data_mdb_em_define_dh_120_entry_encoding_nof_bits,
    dnx_data_mdb_em_define_dh_240_entry_encoding_nof_bits,
    dnx_data_mdb_em_define_format_granularity,
    dnx_data_mdb_em_define_max_nof_vmv_size,
    dnx_data_mdb_em_define_vmv_nof_values,
    dnx_data_mdb_em_define_nof_vmv_size_nof_bits,
    dnx_data_mdb_em_define_esem_nof_vmv_size,
    dnx_data_mdb_em_define_mact_nof_vmv_size,
    dnx_data_mdb_em_define_mact_max_payload_size,
    dnx_data_mdb_em_define_shift_vmv_max_size,
    dnx_data_mdb_em_define_min_key_size,
    dnx_data_mdb_em_define_min_nof_app_id_bits,
    dnx_data_mdb_em_define_entry_addr_bits,
    dnx_data_mdb_em_define_max_nof_spn_sizes,
    dnx_data_mdb_em_define_nof_lfsr_sizes,
    dnx_data_mdb_em_define_nof_formats,
    dnx_data_mdb_em_define_defragmentation_priority_supported,
    dnx_data_mdb_em_define_disable_cuckoo_loop_detection_support,
    dnx_data_mdb_em_define_disable_cuckoo_hit_bit_sync,
    dnx_data_mdb_em_define_age_profile_per_ratio_support,
    dnx_data_mdb_em_define_flex_mag_supported,
    dnx_data_mdb_em_define_flex_fully_supported,
    dnx_data_mdb_em_define_step_table_max_size,
    dnx_data_mdb_em_define_nof_encoding_values,
    dnx_data_mdb_em_define_interrupt_register,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_em_define_nof
} dnx_data_mdb_em_define_e;

/* Get Data */
/**
 * \brief returns define data of total_nof_lem_aging_bits
 * Module - 'mdb', Submodule - 'em', data - 'total_nof_lem_aging_bits'
 * The total number of bits available for the LEM aging.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_lem_aging_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_total_nof_lem_aging_bits_get(
    int unit);

/**
 * \brief returns define data of total_nof_exem_aging_bits
 * Module - 'mdb', Submodule - 'em', data - 'total_nof_exem_aging_bits'
 * The total number of bits available for the EXEM aging.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_exem_aging_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_total_nof_exem_aging_bits_get(
    int unit);

/**
 * \brief returns define data of age_row_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_row_size_bits'
 * The number of bits in a single aging memory row
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_row_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_row_size_bits_get(
    int unit);

/**
 * \brief returns define data of age_ovfcam_row_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_ovfcam_row_size_bits'
 * The number of bits in a single aging ovfcam memory row
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_ovfcam_row_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_ovfcam_row_size_bits_get(
    int unit);

/**
 * \brief returns define data of age_entry_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_entry_size_bits'
 * The number of bits in a single aging memory entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_entry_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_entry_size_bits_get(
    int unit);

/**
 * \brief returns define data of ovf_cam_max_size
 * Module - 'mdb', Submodule - 'em', data - 'ovf_cam_max_size'
 * the MAX size of an OVF CAM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ovf_cam_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_ovf_cam_max_size_get(
    int unit);

/**
 * \brief returns define data of age_support_per_entry_size_ratio
 * Module - 'mdb', Submodule - 'em', data - 'age_support_per_entry_size_ratio'
 * Indicate if the aging profiles are supported per entry ratio size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_support_per_entry_size_ratio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_support_per_entry_size_ratio_get(
    int unit);

/**
 * \brief returns define data of nof_aging_profiles
 * Module - 'mdb', Submodule - 'em', data - 'nof_aging_profiles'
 * The NOF aging profile avialable in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_aging_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_aging_profiles_get(
    int unit);

/**
 * \brief returns define data of aging_profiles_size_in_bits
 * Module - 'mdb', Submodule - 'em', data - 'aging_profiles_size_in_bits'
 * The number of bits needed for the NOF aging profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aging_profiles_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_aging_profiles_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of max_tid_size
 * Module - 'mdb', Submodule - 'em', data - 'max_tid_size'
 * The largest TID size in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tid_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_max_tid_size_get(
    int unit);

/**
 * \brief returns define data of max_nof_tids
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_tids'
 * max NOF of TIDs for a PDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_tids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_max_nof_tids_get(
    int unit);

/**
 * \brief returns define data of flush_support_tids
 * Module - 'mdb', Submodule - 'em', data - 'flush_support_tids'
 * The max NOF of TIDs an MDB table that support flush machine could have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_support_tids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flush_support_tids_get(
    int unit);

/**
 * \brief returns define data of flush_max_supported_key
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_key'
 * The largest key size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flush_max_supported_key_get(
    int unit);

/**
 * \brief returns define data of flush_max_supported_payload
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_payload'
 * he largest payload size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flush_max_supported_payload_get(
    int unit);

/**
 * \brief returns define data of nof_lem_mact_apps
 * Module - 'mdb', Submodule - 'em', data - 'nof_lem_mact_apps'
 * NOF MACT apps in the LEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lem_mact_apps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_lem_mact_apps_get(
    int unit);

/**
 * \brief returns define data of dh_120_entry_encoding_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'dh_120_entry_encoding_nof_bits'
 * Number of bits representing a EM DH 120 width cluster encoding value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_120_entry_encoding_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_dh_120_entry_encoding_nof_bits_get(
    int unit);

/**
 * \brief returns define data of dh_240_entry_encoding_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'dh_240_entry_encoding_nof_bits'
 * Number of bits representing a EM DH 240 width cluster encoding value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_240_entry_encoding_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_dh_240_entry_encoding_nof_bits_get(
    int unit);

/**
 * \brief returns define data of format_granularity
 * Module - 'mdb', Submodule - 'em', data - 'format_granularity'
 * The granularity used for the EM format configuration.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     format_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_format_granularity_get(
    int unit);

/**
 * \brief returns define data of max_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_vmv_size'
 * The number of bits used to represent the vmv, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_max_nof_vmv_size_get(
    int unit);

/**
 * \brief returns define data of vmv_nof_values
 * Module - 'mdb', Submodule - 'em', data - 'vmv_nof_values'
 * NOF values available for the VMV (depends on the nof_vmv_size value)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vmv_nof_values - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_vmv_nof_values_get(
    int unit);

/**
 * \brief returns define data of nof_vmv_size_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'nof_vmv_size_nof_bits'
 * the nof_vmv_size size in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vmv_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_vmv_size_nof_bits_get(
    int unit);

/**
 * \brief returns define data of esem_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'esem_nof_vmv_size'
 * The number of bits used to represent the vmv for ESEM only, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     esem_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_esem_nof_vmv_size_get(
    int unit);

/**
 * \brief returns define data of mact_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'mact_nof_vmv_size'
 * The number of bits used to represent the vmv for MACT only, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB;This value is a HW constraint related to MACT LEL, other LEM logical tables can utilize the full MDB_NOF_VMV_BITS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_mact_nof_vmv_size_get(
    int unit);

/**
 * \brief returns define data of mact_max_payload_size
 * Module - 'mdb', Submodule - 'em', data - 'mact_max_payload_size'
 * MACT payload has to be this size or smaller
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_mact_max_payload_size_get(
    int unit);

/**
 * \brief returns define data of shift_vmv_max_size
 * Module - 'mdb', Submodule - 'em', data - 'shift_vmv_max_size'
 * NOF of EM lookup per stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shift_vmv_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_shift_vmv_max_size_get(
    int unit);

/**
 * \brief returns define data of min_key_size
 * Module - 'mdb', Submodule - 'em', data - 'min_key_size'
 * HW limitation, if a logical EM table key is smaller, it is padded with zeros to this size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_min_key_size_get(
    int unit);

/**
 * \brief returns define data of min_nof_app_id_bits
 * Module - 'mdb', Submodule - 'em', data - 'min_nof_app_id_bits'
 * The minimal number of bits used to represent APP ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_nof_app_id_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_min_nof_app_id_bits_get(
    int unit);

/**
 * \brief returns define data of entry_addr_bits
 * Module - 'mdb', Submodule - 'em', data - 'entry_addr_bits'
 * Number of bits taken from the entry key lsbits after hashing to be used as the address, These bits are not part of the entry stored in the cluster.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_addr_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_entry_addr_bits_get(
    int unit);

/**
 * \brief returns define data of max_nof_spn_sizes
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_spn_sizes'
 * The maximal NOF of SPN sizes options for a single EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_spn_sizes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_max_nof_spn_sizes_get(
    int unit);

/**
 * \brief returns define data of nof_lfsr_sizes
 * Module - 'mdb', Submodule - 'em', data - 'nof_lfsr_sizes'
 * The NOF of LFSR sizes options for a single EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lfsr_sizes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_lfsr_sizes_get(
    int unit);

/**
 * \brief returns define data of nof_formats
 * Module - 'mdb', Submodule - 'em', data - 'nof_formats'
 * The NOF formats which the EM application can used, a format define by the key size and address size and the table address space.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_formats - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_formats_get(
    int unit);

/**
 * \brief returns define data of defragmentation_priority_supported
 * Module - 'mdb', Submodule - 'em', data - 'defragmentation_priority_supported'
 * Overflow CAM defrag machine has priority over Host/Ext support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     defragmentation_priority_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_defragmentation_priority_supported_get(
    int unit);

/**
 * \brief returns define data of disable_cuckoo_loop_detection_support
 * Module - 'mdb', Submodule - 'em', data - 'disable_cuckoo_loop_detection_support'
 * indicate if the device has an option to disable loop detectionin cuckoo processing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     disable_cuckoo_loop_detection_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_disable_cuckoo_loop_detection_support_get(
    int unit);

/**
 * \brief returns define data of disable_cuckoo_hit_bit_sync
 * Module - 'mdb', Submodule - 'em', data - 'disable_cuckoo_hit_bit_sync'
 * indicate if the device has an option to disable cuckoo hit bit handle
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     disable_cuckoo_hit_bit_sync - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_disable_cuckoo_hit_bit_sync_get(
    int unit);

/**
 * \brief returns define data of age_profile_per_ratio_support
 * Module - 'mdb', Submodule - 'em', data - 'age_profile_per_ratio_support'
 * indicate if the device has an age profile per ratio support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_profile_per_ratio_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_age_profile_per_ratio_support_get(
    int unit);

/**
 * \brief returns define data of flex_mag_supported
 * Module - 'mdb', Submodule - 'em', data - 'flex_mag_supported'
 * the flex supported in the MAG but not necessarily fully supported 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_mag_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flex_mag_supported_get(
    int unit);

/**
 * \brief returns define data of flex_fully_supported
 * Module - 'mdb', Submodule - 'em', data - 'flex_fully_supported'
 * flex feature is fully supported (if this is set so does the flex_mag_supported should be).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_fully_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_flex_fully_supported_get(
    int unit);

/**
 * \brief returns define data of step_table_max_size
 * Module - 'mdb', Submodule - 'em', data - 'step_table_max_size'
 * The max NOF rows that a step table can hold.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     step_table_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_step_table_max_size_get(
    int unit);

/**
 * \brief returns define data of nof_encoding_values
 * Module - 'mdb', Submodule - 'em', data - 'nof_encoding_values'
 * the NOF encoding values (values that represent the payload size out of row width) in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_encoding_values - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_nof_encoding_values_get(
    int unit);

/**
 * \brief returns numeric data of interrupt_register
 * Module - 'mdb', Submodule - 'em', data - 'interrupt_register'
 * EM interrupt register.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interrupt_register - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_em_interrupt_register_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_em_table_spn,
    dnx_data_mdb_em_table_lfsr,
    dnx_data_mdb_em_table_em_aging_cfg,
    dnx_data_mdb_em_table_flush,
    dnx_data_mdb_em_table_em_info,
    dnx_data_mdb_em_table_step_table_max_depth,
    dnx_data_mdb_em_table_mdb_15_info,
    dnx_data_mdb_em_table_mdb_16_info,
    dnx_data_mdb_em_table_mdb_18_info,
    dnx_data_mdb_em_table_mdb_21_info,
    dnx_data_mdb_em_table_mdb_23_info,
    dnx_data_mdb_em_table_mdb_24_info,
    dnx_data_mdb_em_table_mdb_29_info,
    dnx_data_mdb_em_table_mdb_31_info,
    dnx_data_mdb_em_table_mdb_32_info,
    dnx_data_mdb_em_table_mdb_41_info,
    dnx_data_mdb_em_table_mdb_em_tables_info,
    dnx_data_mdb_em_table_mdb_emp_tables_info,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_em_table_nof
} dnx_data_mdb_em_table_e;

/* Get Data */
/**
 * \brief get table spn entry 
 * holds SPN information
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are vlid in this case)
 * 
 * \return
 *     spn - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_spn_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_spn_t * dnx_data_mdb_em_spn_get(
    int unit,
    int dbal_id);

/**
 * \brief get table lfsr entry 
 * holds LFSR information
 * 
 * \param [in] unit - unit #
 * \param [in] lfsr_index - the index number of the  requseted LFSR.
 * 
 * \return
 *     lfsr - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_lfsr_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_lfsr_t * dnx_data_mdb_em_lfsr_get(
    int unit,
    int lfsr_index);

/**
 * \brief get table em_aging_cfg entry 
 * aging information
 * 
 * \param [in] unit - unit #
 * \param [in] profile - The aging profile to set.
 * \param [in] emp_table - The EMP table to set.
 * 
 * \return
 *     em_aging_cfg - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_em_aging_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_em_aging_cfg_t * dnx_data_mdb_em_em_aging_cfg_get(
    int unit,
    int profile,
    int emp_table);

/**
 * \brief get table flush entry 
 * holds the flush machine information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_flush_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_flush_t * dnx_data_mdb_em_flush_get(
    int unit);

/**
 * \brief get table em_info entry 
 * Holds EM tables information
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are vlid in this case)
 * 
 * \return
 *     em_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_em_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_em_info_t * dnx_data_mdb_em_em_info_get(
    int unit,
    int dbal_id);

/**
 * \brief get table step_table_max_depth entry 
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 * 
 * \param [in] unit - unit #
 * \param [in] step_table_size_indication - indicate the step table size where 0> 512, 1->1024 and 2->2048 means rows in the step table.
 * \param [in] aspect_ratio_combination - the aspect ratio that are in the step table where bit to ratio mapping is 0->one, 1->half, 2->quarter, 3->eighth
 * 
 * \return
 *     step_table_max_depth - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_step_table_max_depth_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_step_table_max_depth_t * dnx_data_mdb_em_step_table_max_depth_get(
    int unit,
    int step_table_size_indication,
    int aspect_ratio_combination);

/**
 * \brief get table mdb_15_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_15_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_15_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_15_info_t * dnx_data_mdb_em_mdb_15_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_16_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_16_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_16_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_16_info_t * dnx_data_mdb_em_mdb_16_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_18_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_18_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_18_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_18_info_t * dnx_data_mdb_em_mdb_18_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_21_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_21_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_21_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_21_info_t * dnx_data_mdb_em_mdb_21_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_23_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_23_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_23_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_23_info_t * dnx_data_mdb_em_mdb_23_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_24_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_24_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_24_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_24_info_t * dnx_data_mdb_em_mdb_24_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_29_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_29_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_29_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_29_info_t * dnx_data_mdb_em_mdb_29_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_31_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_31_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_31_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_31_info_t * dnx_data_mdb_em_mdb_31_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_32_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_32_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_32_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_32_info_t * dnx_data_mdb_em_mdb_32_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_41_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_41_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_41_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_41_info_t * dnx_data_mdb_em_mdb_41_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_em_tables_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_em_tables_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_em_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_em_tables_info_t * dnx_data_mdb_em_mdb_em_tables_info_get(
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_emp_tables_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_emp_tables_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_emp_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_em_mdb_emp_tables_info_t * dnx_data_mdb_em_mdb_emp_tables_info_get(
    int unit,
    int mdb_table);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'spn'
 * holds SPN information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_spn_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'lfsr'
 * holds LFSR information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_lfsr_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'em_aging_cfg'
 * aging information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_em_aging_cfg_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'flush'
 * holds the flush machine information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_flush_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'em_info'
 * Holds EM tables information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_em_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'step_table_max_depth'
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_step_table_max_depth_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_15_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_15_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_16_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_16_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_18_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_18_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_21_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_21_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_23_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_23_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_24_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_24_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_29_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_29_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_31_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_31_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_32_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_32_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_41_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_41_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_em_tables_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_em_tables_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'em', table - 'mdb_emp_tables_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_em_mdb_emp_tables_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)spn info
 * holds SPN information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     spn - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_spn_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)lfsr info
 * holds LFSR information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lfsr - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_lfsr_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)em_aging_cfg info
 * aging information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     em_aging_cfg - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_em_aging_cfg_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)flush info
 * holds the flush machine information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_flush_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)em_info info
 * Holds EM tables information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     em_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_em_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)step_table_max_depth info
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     step_table_max_depth - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_step_table_max_depth_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_15_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_15_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_15_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_16_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_16_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_16_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_18_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_18_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_18_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_21_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_21_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_21_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_23_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_23_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_23_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_24_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_24_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_24_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_29_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_29_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_29_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_31_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_31_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_31_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_32_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_32_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_32_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_41_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_41_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_41_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_em_tables_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_em_tables_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_em_tables_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_emp_tables_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_emp_tables_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_em_mdb_emp_tables_info_info_get(
    int unit);

/*
 * SUBMODULE DIRECT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_direct_feature_get(
    int unit,
    dnx_data_mdb_direct_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_direct_define_physical_address_max_bits,
    dnx_data_mdb_direct_define_physical_address_max_bits_support_26k_granularity_fec_alloc,
    dnx_data_mdb_direct_define_vsi_physical_address_max_bits,
    dnx_data_mdb_direct_define_fec_address_mapping_bits,
    dnx_data_mdb_direct_define_fec_address_mapping_bits_relevant,
    dnx_data_mdb_direct_define_fec_address_mapping_bits_offset,
    dnx_data_mdb_direct_define_fec_max_cluster_pairs,
    dnx_data_mdb_direct_define_max_payload_size,
    dnx_data_mdb_direct_define_nof_fecs_in_super_fec,
    dnx_data_mdb_direct_define_nof_fec_ecmp_hierarchies,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_direct_define_nof
} dnx_data_mdb_direct_define_e;

/* Get Data */
/**
 * \brief returns define data of physical_address_max_bits
 * Module - 'mdb', Submodule - 'direct', data - 'physical_address_max_bits'
 * The number of DB_ATR_PHYSICAL_ADDRESS_SPACE bits associated with encoding 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_max_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_physical_address_max_bits_get(
    int unit);

/**
 * \brief returns define data of physical_address_max_bits_support_26k_granularity_fec_alloc
 * Module - 'mdb', Submodule - 'direct', data - 'physical_address_max_bits_support_26k_granularity_fec_alloc'
 * The largest address space value which can support 26k granularity for the FEC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_max_bits_support_26k_granularity_fec_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_physical_address_max_bits_support_26k_granularity_fec_alloc_get(
    int unit);

/**
 * \brief returns define data of vsi_physical_address_max_bits
 * Module - 'mdb', Submodule - 'direct', data - 'vsi_physical_address_max_bits'
 * The VSI number of DB_ATR_PHYSICAL_ADDRESS_SPACE bits associated with encoding 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsi_physical_address_max_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_vsi_physical_address_max_bits_get(
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits'
 * The FEC address mapping bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_fec_address_mapping_bits_get(
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits_relevant
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits_relevant'
 * The FEC relevant mapping bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits_relevant - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_fec_address_mapping_bits_relevant_get(
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits_offset
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits_offset'
 * The FEC address relevant mapping bits offset.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_fec_address_mapping_bits_offset_get(
    int unit);

/**
 * \brief returns define data of fec_max_cluster_pairs
 * Module - 'mdb', Submodule - 'direct', data - 'fec_max_cluster_pairs'
 * The maximal NOF cluster that can be associated to two FEC hierarchies.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_max_cluster_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_fec_max_cluster_pairs_get(
    int unit);

/**
 * \brief returns define data of max_payload_size
 * Module - 'mdb', Submodule - 'direct', data - 'max_payload_size'
 * The largest payload size associated with a direct table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_max_payload_size_get(
    int unit);

/**
 * \brief returns define data of nof_fecs_in_super_fec
 * Module - 'mdb', Submodule - 'direct', data - 'nof_fecs_in_super_fec'
 * NOF of FECs contained in a single super FEC.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fecs_in_super_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_nof_fecs_in_super_fec_get(
    int unit);

/**
 * \brief returns define data of nof_fec_ecmp_hierarchies
 * Module - 'mdb', Submodule - 'direct', data - 'nof_fec_ecmp_hierarchies'
 * NOF of FEC/ECMP hierarchies.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_ecmp_hierarchies - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_direct_nof_fec_ecmp_hierarchies_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_direct_table_direct_info,
    dnx_data_mdb_direct_table_hit_bit_pos_in_abk,
    dnx_data_mdb_direct_table_mdb_42_info,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_direct_table_nof
} dnx_data_mdb_direct_table_e;

/* Get Data */
/**
 * \brief get table direct_info entry 
 * general information of the direct table PDBs
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB
 * 
 * \return
 *     direct_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_direct_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_direct_direct_info_t * dnx_data_mdb_direct_direct_info_get(
    int unit,
    int dbal_id);

/**
 * \brief get table hit_bit_pos_in_abk entry 
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 * 
 * \param [in] unit - unit #
 * \param [in] hit_bit_index - the hit bit index
 * 
 * \return
 *     hit_bit_pos_in_abk - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_hit_bit_pos_in_abk_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_direct_hit_bit_pos_in_abk_t * dnx_data_mdb_direct_hit_bit_pos_in_abk_get(
    int unit,
    int hit_bit_index);

/**
 * \brief get table mdb_42_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_42_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_mdb_42_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_direct_mdb_42_info_t * dnx_data_mdb_direct_mdb_42_info_get(
    int unit,
    int mdb_table);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'direct', table - 'direct_info'
 * general information of the direct table PDBs
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_direct_direct_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'direct', table - 'hit_bit_pos_in_abk'
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_direct_hit_bit_pos_in_abk_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'direct', table - 'mdb_42_info'
 * No documentation.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_direct_mdb_42_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)direct_info info
 * general information of the direct table PDBs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     direct_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_direct_direct_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)hit_bit_pos_in_abk info
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hit_bit_pos_in_abk - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_direct_hit_bit_pos_in_abk_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mdb_42_info info
 * No documentation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_42_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_direct_mdb_42_info_info_get(
    int unit);

/*
 * SUBMODULE EEDB:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_eedb_feature_get(
    int unit,
    dnx_data_mdb_eedb_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_eedb_define_phase_map_bits,
    dnx_data_mdb_eedb_define_phase_map_array_size,
    dnx_data_mdb_eedb_define_nof_phase_per_mag,
    dnx_data_mdb_eedb_define_nof_phases,
    dnx_data_mdb_eedb_define_nof_eedb_mags,
    dnx_data_mdb_eedb_define_nof_eedb_banks,
    dnx_data_mdb_eedb_define_nof_phases_per_eedb_bank,
    dnx_data_mdb_eedb_define_nof_phases_per_eedb_bank_size,
    dnx_data_mdb_eedb_define_phase_bank_select_default,
    dnx_data_mdb_eedb_define_entry_format_bits,
    dnx_data_mdb_eedb_define_entry_format_encoding_bits,
    dnx_data_mdb_eedb_define_bank_id_bits,
    dnx_data_mdb_eedb_define_abk_bank,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_eedb_define_nof
} dnx_data_mdb_eedb_define_e;

/* Get Data */
/**
 * \brief returns define data of phase_map_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_map_bits'
 * number of msbits used for the phase mapping.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_map_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_phase_map_bits_get(
    int unit);

/**
 * \brief returns define data of phase_map_array_size
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_map_array_size'
 * Size of phase map array.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_map_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_phase_map_array_size_get(
    int unit);

/**
 * \brief returns define data of nof_phase_per_mag
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phase_per_mag'
 * the NOF phases each MAGs Is associated with.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phase_per_mag - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_phase_per_mag_get(
    int unit);

/**
 * \brief returns define data of nof_phases
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases'
 * NOF of EEDB phases.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_phases_get(
    int unit);

/**
 * \brief returns define data of nof_eedb_mags
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_eedb_mags'
 * NOF of EEDB MAGs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eedb_mags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_eedb_mags_get(
    int unit);

/**
 * \brief returns define data of nof_eedb_banks
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_eedb_banks'
 * NOF of EEDB banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eedb_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_eedb_banks_get(
    int unit);

/**
 * \brief returns define data of nof_phases_per_eedb_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases_per_eedb_bank'
 * Each EEDB bank can be associated with one of this amount of phases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases_per_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_phases_per_eedb_bank_get(
    int unit);

/**
 * \brief returns define data of nof_phases_per_eedb_bank_size
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases_per_eedb_bank_size'
 * nof_phases_per_eedb_bank size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases_per_eedb_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_nof_phases_per_eedb_bank_size_get(
    int unit);

/**
 * \brief returns define data of phase_bank_select_default
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_bank_select_default'
 * the default phase value for a bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_bank_select_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_phase_bank_select_default_get(
    int unit);

/**
 * \brief returns define data of entry_format_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_format_bits'
 * Number of MSbits used to determine the payload size in MDB_ENTRY_FORMATr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_format_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_entry_format_bits_get(
    int unit);

/**
 * \brief returns define data of entry_format_encoding_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_format_encoding_bits'
 * Number of bits used to represent the payload size (30/60/90/120) in MDB_ENTRY_FORMATr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_format_encoding_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_entry_format_encoding_bits_get(
    int unit);

/**
 * \brief returns define data of bank_id_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'bank_id_bits'
 * Number of bits used for bank_id comparison.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_id_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_bank_id_bits_get(
    int unit);

/**
 * \brief returns numeric data of abk_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'abk_bank'
 * the EEDB abk bank memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     abk_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_eedb_abk_bank_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_mdb_eedb_table_phase_info,
    dnx_data_mdb_eedb_table_outlif_physical_phase_granularity,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_eedb_table_nof
} dnx_data_mdb_eedb_table_e;

/* Get Data */
/**
 * \brief get table phase_info entry 
 * general information per EEDB phase.
 * 
 * \param [in] unit - unit #
 * \param [in] phase_number - the phase number.
 * 
 * \return
 *     phase_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_eedb_phase_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_eedb_phase_info_t * dnx_data_mdb_eedb_phase_info_get(
    int unit,
    int phase_number);

/**
 * \brief get table outlif_physical_phase_granularity entry 
 * Assign an outlif physical phase granularity.
 * 
 * \param [in] unit - unit #
 * \param [in] outlif_physical_phase - Physical phase.
 * 
 * \return
 *     outlif_physical_phase_granularity - returns the relevant entry values grouped in struct - see dnx_data_mdb_eedb_outlif_physical_phase_granularity_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_mdb_eedb_outlif_physical_phase_granularity_t * dnx_data_mdb_eedb_outlif_physical_phase_granularity_get(
    int unit,
    int outlif_physical_phase);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'eedb', table - 'phase_info'
 * general information per EEDB phase.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_eedb_phase_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'mdb', Submodule - 'eedb', table - 'outlif_physical_phase_granularity'
 * Assign an outlif physical phase granularity.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_eedb_outlif_physical_phase_granularity_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)phase_info info
 * general information per EEDB phase.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_eedb_phase_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)outlif_physical_phase_granularity info
 * Assign an outlif physical phase granularity.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_physical_phase_granularity - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_mdb_eedb_outlif_physical_phase_granularity_info_get(
    int unit);

/*
 * SUBMODULE KAPS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_kaps_feature_get(
    int unit,
    dnx_data_mdb_kaps_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_mdb_kaps_define_nof_small_bbs,
    dnx_data_mdb_kaps_define_nof_rows_in_small_bb,
    dnx_data_mdb_kaps_define_nof_rows_in_small_rbp_hitbits,
    dnx_data_mdb_kaps_define_nof_bytes_in_hitbit_row,
    dnx_data_mdb_kaps_define_key_lsn_bits,
    dnx_data_mdb_kaps_define_key_prefix_length,
    dnx_data_mdb_kaps_define_max_prefix_in_bb_row,
    dnx_data_mdb_kaps_define_key_width_in_bits,
    dnx_data_mdb_kaps_define_ad_width_in_bits,
    dnx_data_mdb_kaps_define_bb_byte_width,
    dnx_data_mdb_kaps_define_rpb_byte_width,
    dnx_data_mdb_kaps_define_ads_byte_width,
    dnx_data_mdb_kaps_define_rpb_valid_bits,
    dnx_data_mdb_kaps_define_rpb_field,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_kaps_define_nof
} dnx_data_mdb_kaps_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_small_bbs
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_small_bbs'
 * nof small BBs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_small_bbs_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_small_bb
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_rows_in_small_bb'
 * nof row in a small BB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_small_bb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_rows_in_small_bb_get(
    int unit);

/**
 * \brief returns define data of nof_rows_in_small_rbp_hitbits
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_rows_in_small_rbp_hitbits'
 * nof row in a small RPB hitbits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_small_rbp_hitbits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_rows_in_small_rbp_hitbits_get(
    int unit);

/**
 * \brief returns define data of nof_bytes_in_hitbit_row
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_bytes_in_hitbit_row'
 * nof bytes in a hitbit database row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bytes_in_hitbit_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_nof_bytes_in_hitbit_row_get(
    int unit);

/**
 * \brief returns define data of key_lsn_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'key_lsn_bits'
 * RPB input = {key, search_lsn}.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_lsn_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_key_lsn_bits_get(
    int unit);

/**
 * \brief returns define data of key_prefix_length
 * Module - 'mdb', Submodule - 'kaps', data - 'key_prefix_length'
 * The KAPS DB prefix length.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_prefix_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_key_prefix_length_get(
    int unit);

/**
 * \brief returns define data of max_prefix_in_bb_row
 * Module - 'mdb', Submodule - 'kaps', data - 'max_prefix_in_bb_row'
 * The maximum number of prefixes in a single KAPS BB row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_in_bb_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_max_prefix_in_bb_row_get(
    int unit);

/**
 * \brief returns define data of key_width_in_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'key_width_in_bits'
 * The KAPS(LPM) key size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_width_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_key_width_in_bits_get(
    int unit);

/**
 * \brief returns define data of ad_width_in_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'ad_width_in_bits'
 * The KAPS(LPM) payload size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ad_width_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_ad_width_in_bits_get(
    int unit);

/**
 * \brief returns define data of bb_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'bb_byte_width'
 * the BB width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bb_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_bb_byte_width_get(
    int unit);

/**
 * \brief returns define data of rpb_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_byte_width'
 * the RPB width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_rpb_byte_width_get(
    int unit);

/**
 * \brief returns define data of ads_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'ads_byte_width'
 * the ADS width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ads_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_ads_byte_width_get(
    int unit);

/**
 * \brief returns define data of rpb_valid_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_valid_bits'
 * the RPB valid size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_valid_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_rpb_valid_bits_get(
    int unit);

/**
 * \brief returns numeric data of rpb_field
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_field'
 * LPM RPB field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_mdb_kaps_rpb_field_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_kaps_table_nof
} dnx_data_mdb_kaps_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE HW_BUG:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_mdb_hw_bug_feature_get(
    int unit,
    dnx_data_mdb_hw_bug_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_hw_bug_define_nof
} dnx_data_mdb_hw_bug_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_hw_bug_table_nof
} dnx_data_mdb_hw_bug_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_mdb_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_MDB_H_*/
/* *INDENT-ON* */
