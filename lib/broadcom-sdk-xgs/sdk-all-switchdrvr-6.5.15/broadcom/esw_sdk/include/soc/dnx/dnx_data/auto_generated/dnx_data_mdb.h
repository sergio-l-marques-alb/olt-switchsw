/** \file dnx_data_mdb.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_MDB_H_
/*{*/
#define _DNX_DATA_MDB_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dbal/dbal.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_tables.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_mdb.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_mdb
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_mdb_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GLOBAL:
 * MDB global defines
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Descriptor DMA aggregation and async commit to HW.
     */
    dnx_data_mdb_global_desc_dma,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_global_feature_nof
} dnx_data_mdb_global_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_global_feature_get_f) (
    int unit,
    dnx_data_mdb_global_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - GLOBAL:
 * {
 */
/**
 * \brief Interface for mdb global data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_global_feature_get_f feature_get;
} dnx_data_if_mdb_global_t;

/*
 * }
 */

/*
 * SUBMODULE  - DH:
 * Data handlers information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule dh table dh_info
 * Table info:
 * general information of the MDB data handlers
 */
typedef struct
{
    /**
     * This is a mapping from a PDB MAG to the available DHs that connected to it.Each row represent a MAG and each column the MACROs  A0, A1, A2 .... A11, B0, B1 ... B7.The last column in every row is the position after the last available DH which used for the OVF (relevant for EM only).0xF means that the MAG isn't connected to the MACRO otherwise the number represent the serialconnection number of the MACRO to the MAGThere are some DHs which have 2 interfaces to the same MAG, in that case the difference between two legal interface values will be 2.
     */
    uint32 table_macro_interface_mapping[DNX_DATA_MAX_MDB_DH_TOTAL_NOF_MACROES_PLUS_EM_OVF_OR_EEDB_BANK];
    /**
     * The following array maps a PDB into his data in offset position (byte granularity) in a macro.Each column represent a macro A0, A1 ... A11, B0, .. B7 and the last column is the PDB data size (byte granularity).
     */
    uint32 cluster_if_offsets_values[DNX_DATA_MAX_MDB_DH_TOTAL_NOF_MACROES_PLUS_DATA_WIDTH];
    /**
     * This table holds the position of all the 30 bits chunks of a PDB in the IF cluster offset register.Each column represent a macro A0, A1 ... A11, B0, .. B7 and the last column is the PDB data size (30 bits granularity).
     */
    uint32 if_cluster_offsets_values[DNX_DATA_MAX_MDB_DH_TOTAL_NOF_MACROES_PLUS_DATA_WIDTH];
    /**
     * The table row width in bits.
     */
    uint32 row_width;
    /**
     * The data handler in size.
     */
    uint32 dh_in_width;
    /**
     * The data handler out size.
     */
    uint32 dh_out_width;
} dnx_data_mdb_dh_dh_info_t;

/**
 * \brief Holds values of submodule dh table macro_interface_mapping
 * Table info:
 * The available interfaces for each macro
 */
typedef struct
{
    /**
     * array of available interfaces.
     */
    dbal_enum_value_field_mdb_physical_table_e interfaces[DNX_DATA_MAX_MDB_DH_MAX_NOF_CLUSTER_INTERFACES];
} dnx_data_mdb_dh_macro_interface_mapping_t;

/**
 * \brief Holds values of submodule dh table block_info
 * Table info:
 * holds the DH blocks information.
 */
typedef struct
{
    /**
     * the block type that used by the DH macro (e.g. DDHA, DDHB or DHC)
     */
    dbal_enum_value_field_mdb_block_types_e block_type;
    /**
     * each block type have several blocks, this is the instance of the block type used by this DH
     */
    int block_index;
} dnx_data_mdb_dh_block_info_t;

/**
 * \brief Holds values of submodule dh table entry_banks_info
 * Table info:
 * holds the DHs entry banks and ABK banks information.
 */
typedef struct
{
    /**
     * the entries bank memory.
     */
    soc_mem_t entry_bank;
    /**
     * The overflow buffer used to hold the overflowed data of the last entry in the bank.
     */
    soc_reg_t overflow_reg;
    /**
     * The ABK memory of type A (destination hit bit)
     */
    soc_mem_t abk_bank_a;
    /**
     * The ABK memory of type B ()source hit bit)
     */
    soc_mem_t abk_bank_b;
} dnx_data_mdb_dh_entry_banks_info_t;

/**
 * \brief Holds values of submodule dh table cluster_fmt_atr_info
 * Table info:
 * holds the cluster format attribute information
 */
typedef struct
{
    /**
     * no description.
     */
    soc_mem_t fmt_atr_mem;
} dnx_data_mdb_dh_cluster_fmt_atr_info_t;

/**
 * \brief Holds values of submodule dh table mdb_1_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_3_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_4_field_size;
} dnx_data_mdb_dh_mdb_1_info_t;

/**
 * \brief Holds values of submodule dh table mdb_3_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_array_size;
} dnx_data_mdb_dh_mdb_3_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_dh_feature_nof
} dnx_data_mdb_dh_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_dh_feature_get_f) (
    int unit,
    dnx_data_mdb_dh_feature_e feature);

/**
 * \brief returns define data of nof_macroes_type_A
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macroes_type_A'
 * The NOF type A macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macroes_type_A - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_macroes_type_A_get_f) (
    int unit);

/**
 * \brief returns define data of nof_macroes_type_B
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macroes_type_B'
 * The NOF type B macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macroes_type_B - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_macroes_type_B_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_macroes
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes'
 * the total NOF macroes in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_total_nof_macroes_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_macroes_plus_em_ovf_or_eedb_bank
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes_plus_em_ovf_or_eedb_bank'
 * the total NOF macroes in the device plus another place for either the OVF buffer for EM tables or banks for EEDB tables.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes_plus_em_ovf_or_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_total_nof_macroes_plus_em_ovf_or_eedb_bank_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_macroes_plus_data_width
 * Module - 'mdb', Submodule - 'dh', data - 'total_nof_macroes_plus_data_width'
 * he total NOF macroes in the device plus another place for the data width.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_macroes_plus_data_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_total_nof_macroes_plus_data_width_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_cluster_interfaces
 * Module - 'mdb', Submodule - 'dh', data - 'max_nof_cluster_interfaces'
 * max NOF interfaces that can be associated with a single cluster.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_cluster_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_max_nof_cluster_interfaces_get_f) (
    int unit);

/**
 * \brief returns define data of nof_macro_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_macro_clusters'
 * nof clusters in a single macro.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_macro_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_macro_clusters_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bucket_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_bucket_clusters'
 * nof clusters in a a bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bucket_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_bucket_clusters_get_f) (
    int unit);

/**
 * \brief returns define data of nof_buckets_in_macro
 * Module - 'mdb', Submodule - 'dh', data - 'nof_buckets_in_macro'
 * The NOF buckets in a macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_buckets_in_macro - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_buckets_in_macro_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pair_clusters
 * Module - 'mdb', Submodule - 'dh', data - 'nof_pair_clusters'
 * nof clusters in a pair.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pair_clusters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_pair_clusters_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_macro_a_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_macro_a_cluster'
 * NOF rows in a cluster that is places on a macro of type A.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_macro_a_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_rows_in_macro_a_cluster_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_macro_b_cluster
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_macro_b_cluster'
 * NOF rows in a cluster that is places on a macro of type B.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_macro_b_cluster - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_rows_in_macro_b_cluster_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_eedb_bank
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_eedb_bank'
 * NOF rows in an EEDB bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_rows_in_eedb_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_data_rows_per_hitbit_row
 * Module - 'mdb', Submodule - 'dh', data - 'nof_data_rows_per_hitbit_row'
 * How many eedb rows each hitbit row is mapped to
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_data_rows_per_hitbit_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_data_rows_per_hitbit_row_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_eedb_hitbit_bank
 * Module - 'mdb', Submodule - 'dh', data - 'nof_rows_in_eedb_hitbit_bank'
 * How many rows in each eedb hitbit bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_eedb_hitbit_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_nof_rows_in_eedb_hitbit_bank_get_f) (
    int unit);

/**
 * \brief returns define data of cluster_row_width_bits
 * Module - 'mdb', Submodule - 'dh', data - 'cluster_row_width_bits'
 * NOF bits in a single cluster row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cluster_row_width_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_cluster_row_width_bits_get_f) (
    int unit);

/**
 * \brief returns define data of dhha_nof_blocks
 * Module - 'mdb', Submodule - 'dh', data - 'dhha_nof_blocks'
 * NOF DHHA blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dhha_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_dhha_nof_blocks_get_f) (
    int unit);

/**
 * \brief returns define data of dhhb_nof_blocks
 * Module - 'mdb', Submodule - 'dh', data - 'dhhb_nof_blocks'
 * NOF DHHB blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dhhb_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_dhhb_nof_blocks_get_f) (
    int unit);

/**
 * \brief returns define data of dhc_nof_blocks
 * Module - 'mdb', Submodule - 'dh', data - 'dhc_nof_blocks'
 * NOF DHC blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dhc_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_dhc_nof_blocks_get_f) (
    int unit);

/**
 * \brief returns define data of data_out_granularity
 * Module - 'mdb', Submodule - 'dh', data - 'data_out_granularity'
 * The granularity used for data out.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_out_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_data_out_granularity_get_f) (
    int unit);

/**
 * \brief returns numeric data of dma_desc_aggregator_chain_length_max
 * Module - 'mdb', Submodule - 'dh', data - 'dma_desc_aggregator_chain_length_max'
 * Maximal number of descriptors in a single chain.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_desc_aggregator_chain_length_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_dma_desc_aggregator_chain_length_max_get_f) (
    int unit);

/**
 * \brief returns numeric data of dma_desc_aggregator_buff_size_kb
 * Module - 'mdb', Submodule - 'dh', data - 'dma_desc_aggregator_buff_size_kb'
 * Total size in KB of dmmable memory allocated in favor of the descriptor DMA double-buffer.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_desc_aggregator_buff_size_kb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_dma_desc_aggregator_buff_size_kb_get_f) (
    int unit);

/**
 * \brief returns numeric data of dma_desc_aggregator_timeout_usec
 * Module - 'mdb', Submodule - 'dh', data - 'dma_desc_aggregator_timeout_usec'
 * Timeout between the creation of a descriptor chain and its commit to HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_desc_aggregator_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_dh_dma_desc_aggregator_timeout_usec_get_f) (
    int unit);

/**
 * \brief get table dh_info entry 
 * general information of the MDB data handlers
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     dh_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_dh_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_dh_info_t *(
    *dnx_data_mdb_dh_dh_info_get_f) (
    int unit,
    int mdb_table_id);

/**
 * \brief get table macro_interface_mapping entry 
 * The available interfaces for each macro
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     macro_interface_mapping - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_macro_interface_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_macro_interface_mapping_t *(
    *dnx_data_mdb_dh_macro_interface_mapping_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table block_info entry 
 * holds the DH blocks information.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     block_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_block_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_block_info_t *(
    *dnx_data_mdb_dh_block_info_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table entry_banks_info entry 
 * holds the DHs entry banks and ABK banks information.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     entry_banks_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_entry_banks_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_entry_banks_info_t *(
    *dnx_data_mdb_dh_entry_banks_info_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table cluster_fmt_atr_info entry 
 * holds the cluster format attribute information
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - global macro index including all the macro types in the count.
 * 
 * \return
 *     cluster_fmt_atr_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_cluster_fmt_atr_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_cluster_fmt_atr_info_t *(
    *dnx_data_mdb_dh_cluster_fmt_atr_info_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_1_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_1_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_1_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_mdb_1_info_t *(
    *dnx_data_mdb_dh_mdb_1_info_get_f) (
    int unit,
    int global_macro_index);

/**
 * \brief get table mdb_3_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] global_macro_index - no description.
 * 
 * \return
 *     mdb_3_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_dh_mdb_3_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_dh_mdb_3_info_t *(
    *dnx_data_mdb_dh_mdb_3_info_get_f) (
    int unit,
    int global_macro_index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - DH:
 * {
 */
/**
 * \brief Interface for mdb dh data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_dh_feature_get_f feature_get;
    /**
     * returns define data of nof_macroes_type_A
     */
    dnx_data_mdb_dh_nof_macroes_type_A_get_f nof_macroes_type_A_get;
    /**
     * returns define data of nof_macroes_type_B
     */
    dnx_data_mdb_dh_nof_macroes_type_B_get_f nof_macroes_type_B_get;
    /**
     * returns define data of total_nof_macroes
     */
    dnx_data_mdb_dh_total_nof_macroes_get_f total_nof_macroes_get;
    /**
     * returns define data of total_nof_macroes_plus_em_ovf_or_eedb_bank
     */
    dnx_data_mdb_dh_total_nof_macroes_plus_em_ovf_or_eedb_bank_get_f total_nof_macroes_plus_em_ovf_or_eedb_bank_get;
    /**
     * returns define data of total_nof_macroes_plus_data_width
     */
    dnx_data_mdb_dh_total_nof_macroes_plus_data_width_get_f total_nof_macroes_plus_data_width_get;
    /**
     * returns define data of max_nof_cluster_interfaces
     */
    dnx_data_mdb_dh_max_nof_cluster_interfaces_get_f max_nof_cluster_interfaces_get;
    /**
     * returns define data of nof_macro_clusters
     */
    dnx_data_mdb_dh_nof_macro_clusters_get_f nof_macro_clusters_get;
    /**
     * returns define data of nof_bucket_clusters
     */
    dnx_data_mdb_dh_nof_bucket_clusters_get_f nof_bucket_clusters_get;
    /**
     * returns define data of nof_buckets_in_macro
     */
    dnx_data_mdb_dh_nof_buckets_in_macro_get_f nof_buckets_in_macro_get;
    /**
     * returns define data of nof_pair_clusters
     */
    dnx_data_mdb_dh_nof_pair_clusters_get_f nof_pair_clusters_get;
    /**
     * returns define data of nof_rows_in_macro_a_cluster
     */
    dnx_data_mdb_dh_nof_rows_in_macro_a_cluster_get_f nof_rows_in_macro_a_cluster_get;
    /**
     * returns define data of nof_rows_in_macro_b_cluster
     */
    dnx_data_mdb_dh_nof_rows_in_macro_b_cluster_get_f nof_rows_in_macro_b_cluster_get;
    /**
     * returns define data of nof_rows_in_eedb_bank
     */
    dnx_data_mdb_dh_nof_rows_in_eedb_bank_get_f nof_rows_in_eedb_bank_get;
    /**
     * returns define data of nof_data_rows_per_hitbit_row
     */
    dnx_data_mdb_dh_nof_data_rows_per_hitbit_row_get_f nof_data_rows_per_hitbit_row_get;
    /**
     * returns define data of nof_rows_in_eedb_hitbit_bank
     */
    dnx_data_mdb_dh_nof_rows_in_eedb_hitbit_bank_get_f nof_rows_in_eedb_hitbit_bank_get;
    /**
     * returns define data of cluster_row_width_bits
     */
    dnx_data_mdb_dh_cluster_row_width_bits_get_f cluster_row_width_bits_get;
    /**
     * returns define data of dhha_nof_blocks
     */
    dnx_data_mdb_dh_dhha_nof_blocks_get_f dhha_nof_blocks_get;
    /**
     * returns define data of dhhb_nof_blocks
     */
    dnx_data_mdb_dh_dhhb_nof_blocks_get_f dhhb_nof_blocks_get;
    /**
     * returns define data of dhc_nof_blocks
     */
    dnx_data_mdb_dh_dhc_nof_blocks_get_f dhc_nof_blocks_get;
    /**
     * returns define data of data_out_granularity
     */
    dnx_data_mdb_dh_data_out_granularity_get_f data_out_granularity_get;
    /**
     * returns numeric data of dma_desc_aggregator_chain_length_max
     */
    dnx_data_mdb_dh_dma_desc_aggregator_chain_length_max_get_f dma_desc_aggregator_chain_length_max_get;
    /**
     * returns numeric data of dma_desc_aggregator_buff_size_kb
     */
    dnx_data_mdb_dh_dma_desc_aggregator_buff_size_kb_get_f dma_desc_aggregator_buff_size_kb_get;
    /**
     * returns numeric data of dma_desc_aggregator_timeout_usec
     */
    dnx_data_mdb_dh_dma_desc_aggregator_timeout_usec_get_f dma_desc_aggregator_timeout_usec_get;
    /**
     * get table dh_info entry 
     */
    dnx_data_mdb_dh_dh_info_get_f dh_info_get;
    /**
     * get general info table about table (for example key size)dh_info info
     */
    dnxc_data_table_info_get_f dh_info_info_get;
    /**
     * get table macro_interface_mapping entry 
     */
    dnx_data_mdb_dh_macro_interface_mapping_get_f macro_interface_mapping_get;
    /**
     * get general info table about table (for example key size)macro_interface_mapping info
     */
    dnxc_data_table_info_get_f macro_interface_mapping_info_get;
    /**
     * get table block_info entry 
     */
    dnx_data_mdb_dh_block_info_get_f block_info_get;
    /**
     * get general info table about table (for example key size)block_info info
     */
    dnxc_data_table_info_get_f block_info_info_get;
    /**
     * get table entry_banks_info entry 
     */
    dnx_data_mdb_dh_entry_banks_info_get_f entry_banks_info_get;
    /**
     * get general info table about table (for example key size)entry_banks_info info
     */
    dnxc_data_table_info_get_f entry_banks_info_info_get;
    /**
     * get table cluster_fmt_atr_info entry 
     */
    dnx_data_mdb_dh_cluster_fmt_atr_info_get_f cluster_fmt_atr_info_get;
    /**
     * get general info table about table (for example key size)cluster_fmt_atr_info info
     */
    dnxc_data_table_info_get_f cluster_fmt_atr_info_info_get;
    /**
     * get table mdb_1_info entry 
     */
    dnx_data_mdb_dh_mdb_1_info_get_f mdb_1_info_get;
    /**
     * get general info table about table (for example key size)mdb_1_info info
     */
    dnxc_data_table_info_get_f mdb_1_info_info_get;
    /**
     * get table mdb_3_info entry 
     */
    dnx_data_mdb_dh_mdb_3_info_get_f mdb_3_info_get;
    /**
     * get general info table about table (for example key size)mdb_3_info info
     */
    dnxc_data_table_info_get_f mdb_3_info_info_get;
} dnx_data_if_mdb_dh_t;

/*
 * }
 */

/*
 * SUBMODULE  - PDBS:
 * general physical data bases information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule pdbs table mdb_profile
 * Table info:
 * MDB profile SoC property
 */
typedef struct
{
    /**
     * The MDB profile
     */
    uint32 val;
} dnx_data_mdb_pdbs_mdb_profile_t;

/**
 * \brief Holds values of submodule pdbs table pdbs_info
 * Table info:
 * general information of the MDB physical data bases
 */
typedef struct
{
    /**
     * the DB type EM, direct, KAPS, TCAM or EEDB
     */
    dbal_enum_value_field_mdb_db_type_e db_type;
    /**
     * The table row width in bits.
     */
    uint32 row_width;
    /**
     * the direct payload size.
     */
    dbal_enum_value_field_direct_payload_sizes_e direct_payload_type;
} dnx_data_mdb_pdbs_pdbs_info_t;

/**
 * \brief Holds values of submodule pdbs table pdb_info
 * Table info:
 * general information of the MDB physical data bases
 */
typedef struct
{
    /**
     * map between MDB logical DB into a physical DB.
     */
    dbal_enum_value_field_mdb_physical_table_e logical_to_physical;
    /**
     * the DB type EM, direct, KAPS, TCAM or EEDB
     */
    dbal_enum_value_field_mdb_db_type_e db_type;
    /**
     * The table row width in bits.
     */
    uint32 row_width;
    /**
     * The maximal key size used for this PDB.
     */
    uint32 max_key_size;
    /**
     * The maximal payload size used from this PDB.
     */
    uint32 max_payload_size;
} dnx_data_mdb_pdbs_pdb_info_t;

/**
 * \brief Holds values of submodule pdbs table mdb_11_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_3_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_3_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_4_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_4_field_size;
} dnx_data_mdb_pdbs_mdb_11_info_t;

/**
 * \brief Holds values of submodule pdbs table mdb_12_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
} dnx_data_mdb_pdbs_mdb_12_info_t;

/**
 * \brief Holds values of submodule pdbs table mdb_26_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
} dnx_data_mdb_pdbs_mdb_26_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_pdbs_feature_nof
} dnx_data_mdb_pdbs_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_pdbs_feature_get_f) (
    int unit,
    dnx_data_mdb_pdbs_feature_e feature);

/**
 * \brief returns define data of max_nof_interface_dhs
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_nof_interface_dhs'
 * Max nof different DHs that can be associated with a single interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_interface_dhs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_max_nof_interface_dhs_get_f) (
    int unit);

/**
 * \brief returns define data of fec_extra_cluster_allocation
 * Module - 'mdb', Submodule - 'pdbs', data - 'fec_extra_cluster_allocation'
 * The FECs tables can have their clusters moved between them dynamically so they need extra initial allocation of clusters to have room for that.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_extra_cluster_allocation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_fec_extra_cluster_allocation_get_f) (
    int unit);

/**
 * \brief returns define data of kaps_nof_blocks
 * Module - 'mdb', Submodule - 'pdbs', data - 'kaps_nof_blocks'
 * NOF KPAS blocks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kaps_nof_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_kaps_nof_blocks_get_f) (
    int unit);

/**
 * \brief returns define data of mesh_mode_support
 * Module - 'mdb', Submodule - 'pdbs', data - 'mesh_mode_support'
 * Indicate if the device support mesh mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_mode_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_mesh_mode_support_get_f) (
    int unit);

/**
 * \brief returns define data of max_key_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_key_size'
 * The largest key size from all the PDBs key sizes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_max_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_payload_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'max_payload_size'
 * The largest payload size from all the PDBs payloads sizes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_max_payload_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_1_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_1_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_1_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_9_mdb_item_1_array_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_2_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_2_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_2_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_9_mdb_item_2_array_size_get_f) (
    int unit);

/**
 * \brief returns define data of table_mdb_9_mdb_item_3_array_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'table_mdb_9_mdb_item_3_array_size'
 * no description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_mdb_9_mdb_item_3_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_table_mdb_9_mdb_item_3_array_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdb_kaps_a_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'mdb_kaps_a_size'
 * The KAPS A size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_kaps_a_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_mdb_kaps_a_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of mdb_kaps_b_size
 * Module - 'mdb', Submodule - 'pdbs', data - 'mdb_kaps_b_size'
 * The KAPS B size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_kaps_b_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_pdbs_mdb_kaps_b_size_get_f) (
    int unit);

/**
 * \brief get table mdb_profile entry 
 * MDB profile SoC property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdb_profile - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_profile_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_profile_t *(
    *dnx_data_mdb_pdbs_mdb_profile_get_f) (
    int unit);

/**
 * \brief get table pdbs_info entry 
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table_id - MDB physical DB.
 * 
 * \return
 *     pdbs_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_pdbs_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_pdbs_info_t *(
    *dnx_data_mdb_pdbs_pdbs_info_get_f) (
    int unit,
    int mdb_table_id);

/**
 * \brief get table pdb_info entry 
 * general information of the MDB physical data bases
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB
 * 
 * \return
 *     pdb_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_pdb_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_pdb_info_t *(
    *dnx_data_mdb_pdbs_pdb_info_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table mdb_11_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_11_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_11_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_11_info_t *(
    *dnx_data_mdb_pdbs_mdb_11_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_12_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_12_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_12_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_12_info_t *(
    *dnx_data_mdb_pdbs_mdb_12_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_26_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_26_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_pdbs_mdb_26_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_pdbs_mdb_26_info_t *(
    *dnx_data_mdb_pdbs_mdb_26_info_get_f) (
    int unit,
    int mdb_table);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - PDBS:
 * {
 */
/**
 * \brief Interface for mdb pdbs data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_pdbs_feature_get_f feature_get;
    /**
     * returns define data of max_nof_interface_dhs
     */
    dnx_data_mdb_pdbs_max_nof_interface_dhs_get_f max_nof_interface_dhs_get;
    /**
     * returns define data of fec_extra_cluster_allocation
     */
    dnx_data_mdb_pdbs_fec_extra_cluster_allocation_get_f fec_extra_cluster_allocation_get;
    /**
     * returns define data of kaps_nof_blocks
     */
    dnx_data_mdb_pdbs_kaps_nof_blocks_get_f kaps_nof_blocks_get;
    /**
     * returns define data of mesh_mode_support
     */
    dnx_data_mdb_pdbs_mesh_mode_support_get_f mesh_mode_support_get;
    /**
     * returns define data of max_key_size
     */
    dnx_data_mdb_pdbs_max_key_size_get_f max_key_size_get;
    /**
     * returns define data of max_payload_size
     */
    dnx_data_mdb_pdbs_max_payload_size_get_f max_payload_size_get;
    /**
     * returns define data of table_mdb_9_mdb_item_1_array_size
     */
    dnx_data_mdb_pdbs_table_mdb_9_mdb_item_1_array_size_get_f table_mdb_9_mdb_item_1_array_size_get;
    /**
     * returns define data of table_mdb_9_mdb_item_2_array_size
     */
    dnx_data_mdb_pdbs_table_mdb_9_mdb_item_2_array_size_get_f table_mdb_9_mdb_item_2_array_size_get;
    /**
     * returns define data of table_mdb_9_mdb_item_3_array_size
     */
    dnx_data_mdb_pdbs_table_mdb_9_mdb_item_3_array_size_get_f table_mdb_9_mdb_item_3_array_size_get;
    /**
     * returns numeric data of mdb_kaps_a_size
     */
    dnx_data_mdb_pdbs_mdb_kaps_a_size_get_f mdb_kaps_a_size_get;
    /**
     * returns numeric data of mdb_kaps_b_size
     */
    dnx_data_mdb_pdbs_mdb_kaps_b_size_get_f mdb_kaps_b_size_get;
    /**
     * get table mdb_profile entry 
     */
    dnx_data_mdb_pdbs_mdb_profile_get_f mdb_profile_get;
    /**
     * get general info table about table (for example key size)mdb_profile info
     */
    dnxc_data_table_info_get_f mdb_profile_info_get;
    /**
     * get table pdbs_info entry 
     */
    dnx_data_mdb_pdbs_pdbs_info_get_f pdbs_info_get;
    /**
     * get general info table about table (for example key size)pdbs_info info
     */
    dnxc_data_table_info_get_f pdbs_info_info_get;
    /**
     * get table pdb_info entry 
     */
    dnx_data_mdb_pdbs_pdb_info_get_f pdb_info_get;
    /**
     * get general info table about table (for example key size)pdb_info info
     */
    dnxc_data_table_info_get_f pdb_info_info_get;
    /**
     * get table mdb_11_info entry 
     */
    dnx_data_mdb_pdbs_mdb_11_info_get_f mdb_11_info_get;
    /**
     * get general info table about table (for example key size)mdb_11_info info
     */
    dnxc_data_table_info_get_f mdb_11_info_info_get;
    /**
     * get table mdb_12_info entry 
     */
    dnx_data_mdb_pdbs_mdb_12_info_get_f mdb_12_info_get;
    /**
     * get general info table about table (for example key size)mdb_12_info info
     */
    dnxc_data_table_info_get_f mdb_12_info_info_get;
    /**
     * get table mdb_26_info entry 
     */
    dnx_data_mdb_pdbs_mdb_26_info_get_f mdb_26_info_get;
    /**
     * get general info table about table (for example key size)mdb_26_info info
     */
    dnxc_data_table_info_get_f mdb_26_info_info_get;
} dnx_data_if_mdb_pdbs_t;

/*
 * }
 */

/*
 * SUBMODULE  - EM:
 * EM information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule em table spn
 * Table info:
 * holds SPN information
 */
typedef struct
{
    /**
     * The NOF SPNs sizes available for a given EM table.
     */
    uint8 nof_spn_size;
    /**
     * the given table SPN sizes.
     */
    uint8 spn_array[DNX_DATA_MAX_MDB_EM_MAX_NOF_SPN_SIZES];
} dnx_data_mdb_em_spn_t;

/**
 * \brief Holds values of submodule em table lfsr
 * Table info:
 * holds LFSR information
 */
typedef struct
{
    /**
     * The LFSR size.
     */
    int lfsr_size;
} dnx_data_mdb_em_lfsr_t;

/**
 * \brief Holds values of submodule em table em_aging_cfg
 * Table info:
 * aging information
 */
typedef struct
{
    /**
     * When an entry is entered/learned this is the initial age value that it received.
     */
    uint8 init_value;
    /**
     * Allows updating the age value in multiplication of scan cycles.
     */
    uint8 global_value;
    /**
     * Allows updating the age value in multiplication of scan cycles.
     */
    uint8 global_mask;
    /**
     * Whether to take the age configuration from this register or externally (e.g. MACT age configuration).
     */
    uint8 external_profile;
    /**
     * Disable ageing.
     */
    uint8 aging_disable;
    /**
     * Disable elephant option.
     */
    uint8 elephant_disable;
    /**
     * A lower age threshold which an entry that reaches/pass this age threshold get some dedicated payload.
     */
    uint8 elephant_values;
    /**
     * An upper age threshold which an entry that reaches/pass this age threshold get some dedicated payload.
     */
    uint8 mouse_values;
    /**
     * An entry age can be update up to this value.
     */
    uint8 age_max_values;
    /**
     * In case of an entry hit the age will be incremented by this value.
     */
    uint8 increment_values;
    /**
     * In case the age scan found the an entry was not accessed (no hit) the age value will be decremented by this value.
     */
    uint8 decrement_values;
    /**
     * The age of entry that trigger entry removal (usually it will be zero).
     */
    uint8 out_values;
} dnx_data_mdb_em_em_aging_cfg_t;

/**
 * \brief Holds values of submodule em table flush
 * Table info:
 * holds the flush machine information
 */
typedef struct
{
    /**
     * A list of the LEM MACT applications.
     */
    dbal_tables_e mact_apps_list[DNX_DATA_MAX_MDB_EM_NOF_LEM_MACT_APPS];
} dnx_data_mdb_em_flush_t;

/**
 * \brief Holds values of submodule em table em_info
 * Table info:
 * Holds EM tables information
 */
typedef struct
{
    /**
     * The MDB table TID size.
     */
    uint32 tid_size;
    /**
     * the EM TID attribute register
     */
    soc_mem_t tid_atr_mem;
    /**
     * no description
     */
    soc_field_t field_0;
    /**
     * no description
     */
    soc_field_t field_1;
    /**
     * no description
     */
    soc_field_t field_2;
    /**
     * no description
     */
    soc_field_t field_3;
    /**
     * no description
     */
    soc_field_t field_4;
    /**
     * no description
     */
    soc_field_t field_5;
    /**
     * no description
     */
    soc_reg_t emp_age_profiles;
    /**
     * no description.
     */
    soc_reg_t ovf_enable_reg;
    /**
     * no description.
     */
    soc_field_t ovf_enable_field;
    /**
     * no description.
     */
    soc_mem_t em_interface;
    /**
     * no description.
     */
    soc_mem_t age_mem;
    /**
     * no description.
     */
    soc_mem_t age_ovf_cam_mem;
    /**
     * no description.
     */
    soc_reg_t status_reg;
    /**
     * no description.
     */
    soc_field_t interrupt_field;
    /**
     * step table NOF rows
     */
    uint32 step_table_size;
    /**
     * overflow CAM NOF rows
     */
    uint32 ovf_cam_size;
} dnx_data_mdb_em_em_info_t;

/**
 * \brief Holds values of submodule em table step_table_max_depth
 * Table info:
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 */
typedef struct
{
    /**
     * the step table max depth.
     */
    uint32 max_depth;
} dnx_data_mdb_em_step_table_max_depth_t;

/**
 * \brief Holds values of submodule em table mdb_15_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_5_field_size;
} dnx_data_mdb_em_mdb_15_info_t;

/**
 * \brief Holds values of submodule em table mdb_16_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
} dnx_data_mdb_em_mdb_16_info_t;

/**
 * \brief Holds values of submodule em table mdb_18_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
} dnx_data_mdb_em_mdb_18_info_t;

/**
 * \brief Holds values of submodule em table mdb_21_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
} dnx_data_mdb_em_mdb_21_info_t;

/**
 * \brief Holds values of submodule em table mdb_23_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_field_size;
} dnx_data_mdb_em_mdb_23_info_t;

/**
 * \brief Holds values of submodule em table mdb_24_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_array_size;
    /**
     * no description.
     */
    uint32 mdb_item_1_field_size;
} dnx_data_mdb_em_mdb_24_info_t;

/**
 * \brief Holds values of submodule em table mdb_29_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_array_size;
} dnx_data_mdb_em_mdb_29_info_t;

/**
 * \brief Holds values of submodule em table mdb_31_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 array_size;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
} dnx_data_mdb_em_mdb_31_info_t;

/**
 * \brief Holds values of submodule em table mdb_32_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 mdb_item_0_field_size;
} dnx_data_mdb_em_mdb_32_info_t;

/**
 * \brief Holds values of submodule em table mdb_41_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
    /**
     * no description.
     */
    uint32 array_size;
    /**
     * no description.
     */
    uint32 mdb_item_2_field_size;
    /**
     * no description.
     */
    uint32 mdb_item_3_field_size;
} dnx_data_mdb_em_mdb_41_info_t;

/**
 * \brief Holds values of submodule em table mdb_em_tables_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e mdb_14_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_15_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_17_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_29_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_step_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_32_table;
} dnx_data_mdb_em_mdb_em_tables_info_t;

/**
 * \brief Holds values of submodule em table mdb_emp_tables_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e mdb_19_table;
    /**
     * no description.
     */
    dbal_tables_e mdb_22_table;
} dnx_data_mdb_em_mdb_emp_tables_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is the entry type parsed by HW (or needs to be provided)?
     */
    dnx_data_mdb_em_entry_type_parser,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_em_feature_nof
} dnx_data_mdb_em_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_em_feature_get_f) (
    int unit,
    dnx_data_mdb_em_feature_e feature);

/**
 * \brief returns define data of total_nof_lem_aging_bits
 * Module - 'mdb', Submodule - 'em', data - 'total_nof_lem_aging_bits'
 * The total number of bits available for the LEM aging.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_lem_aging_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_total_nof_lem_aging_bits_get_f) (
    int unit);

/**
 * \brief returns define data of total_nof_exem_aging_bits
 * Module - 'mdb', Submodule - 'em', data - 'total_nof_exem_aging_bits'
 * The total number of bits available for the EXEM aging.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_exem_aging_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_total_nof_exem_aging_bits_get_f) (
    int unit);

/**
 * \brief returns define data of age_row_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_row_size_bits'
 * The number of bits in a single aging memory row
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_row_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_row_size_bits_get_f) (
    int unit);

/**
 * \brief returns define data of age_ovfcam_row_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_ovfcam_row_size_bits'
 * The number of bits in a single aging ovfcam memory row
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_ovfcam_row_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_ovfcam_row_size_bits_get_f) (
    int unit);

/**
 * \brief returns define data of age_entry_size_bits
 * Module - 'mdb', Submodule - 'em', data - 'age_entry_size_bits'
 * The number of bits in a single aging memory entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_entry_size_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_entry_size_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ovf_cam_max_size
 * Module - 'mdb', Submodule - 'em', data - 'ovf_cam_max_size'
 * the MAX size of an OVF CAM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ovf_cam_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_ovf_cam_max_size_get_f) (
    int unit);

/**
 * \brief returns define data of age_support_per_entry_size_ratio
 * Module - 'mdb', Submodule - 'em', data - 'age_support_per_entry_size_ratio'
 * Indicate if the aging profiles are supported per entry ratio size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_support_per_entry_size_ratio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_support_per_entry_size_ratio_get_f) (
    int unit);

/**
 * \brief returns define data of nof_aging_profiles
 * Module - 'mdb', Submodule - 'em', data - 'nof_aging_profiles'
 * The NOF aging profile avialable in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_aging_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_aging_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of aging_profiles_size_in_bits
 * Module - 'mdb', Submodule - 'em', data - 'aging_profiles_size_in_bits'
 * The number of bits needed for the NOF aging profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aging_profiles_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_aging_profiles_size_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of max_tid_size
 * Module - 'mdb', Submodule - 'em', data - 'max_tid_size'
 * The largest TID size in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tid_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_max_tid_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_tids
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_tids'
 * max NOF of TIDs for a PDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_tids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_max_nof_tids_get_f) (
    int unit);

/**
 * \brief returns define data of flush_support_tids
 * Module - 'mdb', Submodule - 'em', data - 'flush_support_tids'
 * The max NOF of TIDs an MDB table that support flush machine could have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_support_tids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flush_support_tids_get_f) (
    int unit);

/**
 * \brief returns define data of flush_max_supported_key
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_key'
 * The largest key size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flush_max_supported_key_get_f) (
    int unit);

/**
 * \brief returns define data of flush_max_supported_payload
 * Module - 'mdb', Submodule - 'em', data - 'flush_max_supported_payload'
 * he largest payload size that can be used by the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_max_supported_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flush_max_supported_payload_get_f) (
    int unit);

/**
 * \brief returns define data of nof_lem_mact_apps
 * Module - 'mdb', Submodule - 'em', data - 'nof_lem_mact_apps'
 * NOF MACT apps in the LEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lem_mact_apps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_lem_mact_apps_get_f) (
    int unit);

/**
 * \brief returns define data of dh_120_entry_encoding_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'dh_120_entry_encoding_nof_bits'
 * Number of bits representing a EM DH 120 width cluster encoding value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_120_entry_encoding_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_dh_120_entry_encoding_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of dh_240_entry_encoding_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'dh_240_entry_encoding_nof_bits'
 * Number of bits representing a EM DH 240 width cluster encoding value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dh_240_entry_encoding_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_dh_240_entry_encoding_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of format_granularity
 * Module - 'mdb', Submodule - 'em', data - 'format_granularity'
 * The granularity used for the EM format configuration.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     format_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_format_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_vmv_size'
 * The number of bits used to represent the vmv, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_max_nof_vmv_size_get_f) (
    int unit);

/**
 * \brief returns define data of vmv_nof_values
 * Module - 'mdb', Submodule - 'em', data - 'vmv_nof_values'
 * NOF values available for the VMV (depends on the nof_vmv_size value)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vmv_nof_values - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_vmv_nof_values_get_f) (
    int unit);

/**
 * \brief returns define data of nof_vmv_size_nof_bits
 * Module - 'mdb', Submodule - 'em', data - 'nof_vmv_size_nof_bits'
 * the nof_vmv_size size in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vmv_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_vmv_size_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of esem_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'esem_nof_vmv_size'
 * The number of bits used to represent the vmv for ESEM only, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     esem_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_esem_nof_vmv_size_get_f) (
    int unit);

/**
 * \brief returns define data of mact_nof_vmv_size
 * Module - 'mdb', Submodule - 'em', data - 'mact_nof_vmv_size'
 * The number of bits used to represent the vmv for MACT only, smaller vmv sizes are simply aligned to the MSB and the configuration iterates on all possible values of the LSB;This value is a HW constraint related to MACT LEL, other LEM logical tables can utilize the full MDB_NOF_VMV_BITS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_nof_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_mact_nof_vmv_size_get_f) (
    int unit);

/**
 * \brief returns define data of mact_max_payload_size
 * Module - 'mdb', Submodule - 'em', data - 'mact_max_payload_size'
 * MACT payload has to be this size or smaller
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_mact_max_payload_size_get_f) (
    int unit);

/**
 * \brief returns define data of shift_vmv_max_size
 * Module - 'mdb', Submodule - 'em', data - 'shift_vmv_max_size'
 * NOF of EM lookup per stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shift_vmv_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_shift_vmv_max_size_get_f) (
    int unit);

/**
 * \brief returns define data of min_key_size
 * Module - 'mdb', Submodule - 'em', data - 'min_key_size'
 * HW limitation, if a logical EM table key is smaller, it is padded with zeros to this size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_min_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of min_nof_app_id_bits
 * Module - 'mdb', Submodule - 'em', data - 'min_nof_app_id_bits'
 * The minimal number of bits used to represent APP ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_nof_app_id_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_min_nof_app_id_bits_get_f) (
    int unit);

/**
 * \brief returns define data of entry_addr_bits
 * Module - 'mdb', Submodule - 'em', data - 'entry_addr_bits'
 * Number of bits taken from the entry key lsbits after hashing to be used as the address, These bits are not part of the entry stored in the cluster.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_addr_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_entry_addr_bits_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_spn_sizes
 * Module - 'mdb', Submodule - 'em', data - 'max_nof_spn_sizes'
 * The maximal NOF of SPN sizes options for a single EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_spn_sizes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_max_nof_spn_sizes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_lfsr_sizes
 * Module - 'mdb', Submodule - 'em', data - 'nof_lfsr_sizes'
 * The NOF of LFSR sizes options for a single EM PDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lfsr_sizes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_lfsr_sizes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_formats
 * Module - 'mdb', Submodule - 'em', data - 'nof_formats'
 * The NOF formats which the EM application can used, a format define by the key size and address size and the table address space.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_formats - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_formats_get_f) (
    int unit);

/**
 * \brief returns define data of defragmentation_priority_supported
 * Module - 'mdb', Submodule - 'em', data - 'defragmentation_priority_supported'
 * Overflow CAM defrag machine has priority over Host/Ext support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     defragmentation_priority_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_defragmentation_priority_supported_get_f) (
    int unit);

/**
 * \brief returns define data of disable_cuckoo_loop_detection_support
 * Module - 'mdb', Submodule - 'em', data - 'disable_cuckoo_loop_detection_support'
 * indicate if the device has an option to disable loop detectionin cuckoo processing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     disable_cuckoo_loop_detection_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_disable_cuckoo_loop_detection_support_get_f) (
    int unit);

/**
 * \brief returns define data of disable_cuckoo_hit_bit_sync
 * Module - 'mdb', Submodule - 'em', data - 'disable_cuckoo_hit_bit_sync'
 * indicate if the device has an option to disable cuckoo hit bit handle
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     disable_cuckoo_hit_bit_sync - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_disable_cuckoo_hit_bit_sync_get_f) (
    int unit);

/**
 * \brief returns define data of age_profile_per_ratio_support
 * Module - 'mdb', Submodule - 'em', data - 'age_profile_per_ratio_support'
 * indicate if the device has an age profile per ratio support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age_profile_per_ratio_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_age_profile_per_ratio_support_get_f) (
    int unit);

/**
 * \brief returns define data of flex_mag_supported
 * Module - 'mdb', Submodule - 'em', data - 'flex_mag_supported'
 * the flex supported in the MAG but not necessarily fully supported 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_mag_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flex_mag_supported_get_f) (
    int unit);

/**
 * \brief returns define data of flex_fully_supported
 * Module - 'mdb', Submodule - 'em', data - 'flex_fully_supported'
 * flex feature is fully supported (if this is set so does the flex_mag_supported should be).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flex_fully_supported - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_flex_fully_supported_get_f) (
    int unit);

/**
 * \brief returns define data of step_table_max_size
 * Module - 'mdb', Submodule - 'em', data - 'step_table_max_size'
 * The max NOF rows that a step table can hold.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     step_table_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_step_table_max_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_encoding_values
 * Module - 'mdb', Submodule - 'em', data - 'nof_encoding_values'
 * the NOF encoding values (values that represent the payload size out of row width) in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_encoding_values - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_nof_encoding_values_get_f) (
    int unit);

/**
 * \brief returns numeric data of interrupt_register
 * Module - 'mdb', Submodule - 'em', data - 'interrupt_register'
 * EM interrupt register.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interrupt_register - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_em_interrupt_register_get_f) (
    int unit);

/**
 * \brief get table spn entry 
 * holds SPN information
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are vlid in this case)
 * 
 * \return
 *     spn - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_spn_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_spn_t *(
    *dnx_data_mdb_em_spn_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table lfsr entry 
 * holds LFSR information
 * 
 * \param [in] unit - unit #
 * \param [in] lfsr_index - the index number of the  requseted LFSR.
 * 
 * \return
 *     lfsr - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_lfsr_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_lfsr_t *(
    *dnx_data_mdb_em_lfsr_get_f) (
    int unit,
    int lfsr_index);

/**
 * \brief get table em_aging_cfg entry 
 * aging information
 * 
 * \param [in] unit - unit #
 * \param [in] profile - The aging profile to set.
 * \param [in] emp_table - The EMP table to set.
 * 
 * \return
 *     em_aging_cfg - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_em_aging_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_em_aging_cfg_t *(
    *dnx_data_mdb_em_em_aging_cfg_get_f) (
    int unit,
    int profile,
    int emp_table);

/**
 * \brief get table flush entry 
 * holds the flush machine information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_flush_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_flush_t *(
    *dnx_data_mdb_em_flush_get_f) (
    int unit);

/**
 * \brief get table em_info entry 
 * Holds EM tables information
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB (only EM tables are vlid in this case)
 * 
 * \return
 *     em_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_em_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_em_info_t *(
    *dnx_data_mdb_em_em_info_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table step_table_max_depth entry 
 * hold the maximal depth of the step table for different aspect ratio combinations and table sizes
 * 
 * \param [in] unit - unit #
 * \param [in] step_table_size_indication - indicate the step table size where 0> 512, 1->1024 and 2->2048 means rows in the step table.
 * \param [in] aspect_ratio_combination - the aspect ratio that are in the step table where bit to ratio mapping is 0->one, 1->half, 2->quarter, 3->eighth
 * 
 * \return
 *     step_table_max_depth - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_step_table_max_depth_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_step_table_max_depth_t *(
    *dnx_data_mdb_em_step_table_max_depth_get_f) (
    int unit,
    int step_table_size_indication,
    int aspect_ratio_combination);

/**
 * \brief get table mdb_15_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_15_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_15_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_15_info_t *(
    *dnx_data_mdb_em_mdb_15_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_16_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_16_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_16_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_16_info_t *(
    *dnx_data_mdb_em_mdb_16_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_18_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_18_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_18_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_18_info_t *(
    *dnx_data_mdb_em_mdb_18_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_21_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_21_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_21_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_21_info_t *(
    *dnx_data_mdb_em_mdb_21_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_23_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_23_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_23_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_23_info_t *(
    *dnx_data_mdb_em_mdb_23_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_24_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_24_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_24_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_24_info_t *(
    *dnx_data_mdb_em_mdb_24_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_29_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_29_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_29_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_29_info_t *(
    *dnx_data_mdb_em_mdb_29_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_31_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_31_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_31_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_31_info_t *(
    *dnx_data_mdb_em_mdb_31_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_32_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_32_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_32_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_32_info_t *(
    *dnx_data_mdb_em_mdb_32_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_41_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_41_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_41_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_41_info_t *(
    *dnx_data_mdb_em_mdb_41_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_em_tables_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_em_tables_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_em_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_em_tables_info_t *(
    *dnx_data_mdb_em_mdb_em_tables_info_get_f) (
    int unit,
    int mdb_table);

/**
 * \brief get table mdb_emp_tables_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_emp_tables_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_em_mdb_emp_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_em_mdb_emp_tables_info_t *(
    *dnx_data_mdb_em_mdb_emp_tables_info_get_f) (
    int unit,
    int mdb_table);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - EM:
 * {
 */
/**
 * \brief Interface for mdb em data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_em_feature_get_f feature_get;
    /**
     * returns define data of total_nof_lem_aging_bits
     */
    dnx_data_mdb_em_total_nof_lem_aging_bits_get_f total_nof_lem_aging_bits_get;
    /**
     * returns define data of total_nof_exem_aging_bits
     */
    dnx_data_mdb_em_total_nof_exem_aging_bits_get_f total_nof_exem_aging_bits_get;
    /**
     * returns define data of age_row_size_bits
     */
    dnx_data_mdb_em_age_row_size_bits_get_f age_row_size_bits_get;
    /**
     * returns define data of age_ovfcam_row_size_bits
     */
    dnx_data_mdb_em_age_ovfcam_row_size_bits_get_f age_ovfcam_row_size_bits_get;
    /**
     * returns define data of age_entry_size_bits
     */
    dnx_data_mdb_em_age_entry_size_bits_get_f age_entry_size_bits_get;
    /**
     * returns define data of ovf_cam_max_size
     */
    dnx_data_mdb_em_ovf_cam_max_size_get_f ovf_cam_max_size_get;
    /**
     * returns define data of age_support_per_entry_size_ratio
     */
    dnx_data_mdb_em_age_support_per_entry_size_ratio_get_f age_support_per_entry_size_ratio_get;
    /**
     * returns define data of nof_aging_profiles
     */
    dnx_data_mdb_em_nof_aging_profiles_get_f nof_aging_profiles_get;
    /**
     * returns define data of aging_profiles_size_in_bits
     */
    dnx_data_mdb_em_aging_profiles_size_in_bits_get_f aging_profiles_size_in_bits_get;
    /**
     * returns define data of max_tid_size
     */
    dnx_data_mdb_em_max_tid_size_get_f max_tid_size_get;
    /**
     * returns define data of max_nof_tids
     */
    dnx_data_mdb_em_max_nof_tids_get_f max_nof_tids_get;
    /**
     * returns define data of flush_support_tids
     */
    dnx_data_mdb_em_flush_support_tids_get_f flush_support_tids_get;
    /**
     * returns define data of flush_max_supported_key
     */
    dnx_data_mdb_em_flush_max_supported_key_get_f flush_max_supported_key_get;
    /**
     * returns define data of flush_max_supported_payload
     */
    dnx_data_mdb_em_flush_max_supported_payload_get_f flush_max_supported_payload_get;
    /**
     * returns define data of nof_lem_mact_apps
     */
    dnx_data_mdb_em_nof_lem_mact_apps_get_f nof_lem_mact_apps_get;
    /**
     * returns define data of dh_120_entry_encoding_nof_bits
     */
    dnx_data_mdb_em_dh_120_entry_encoding_nof_bits_get_f dh_120_entry_encoding_nof_bits_get;
    /**
     * returns define data of dh_240_entry_encoding_nof_bits
     */
    dnx_data_mdb_em_dh_240_entry_encoding_nof_bits_get_f dh_240_entry_encoding_nof_bits_get;
    /**
     * returns define data of format_granularity
     */
    dnx_data_mdb_em_format_granularity_get_f format_granularity_get;
    /**
     * returns define data of max_nof_vmv_size
     */
    dnx_data_mdb_em_max_nof_vmv_size_get_f max_nof_vmv_size_get;
    /**
     * returns define data of vmv_nof_values
     */
    dnx_data_mdb_em_vmv_nof_values_get_f vmv_nof_values_get;
    /**
     * returns define data of nof_vmv_size_nof_bits
     */
    dnx_data_mdb_em_nof_vmv_size_nof_bits_get_f nof_vmv_size_nof_bits_get;
    /**
     * returns define data of esem_nof_vmv_size
     */
    dnx_data_mdb_em_esem_nof_vmv_size_get_f esem_nof_vmv_size_get;
    /**
     * returns define data of mact_nof_vmv_size
     */
    dnx_data_mdb_em_mact_nof_vmv_size_get_f mact_nof_vmv_size_get;
    /**
     * returns define data of mact_max_payload_size
     */
    dnx_data_mdb_em_mact_max_payload_size_get_f mact_max_payload_size_get;
    /**
     * returns define data of shift_vmv_max_size
     */
    dnx_data_mdb_em_shift_vmv_max_size_get_f shift_vmv_max_size_get;
    /**
     * returns define data of min_key_size
     */
    dnx_data_mdb_em_min_key_size_get_f min_key_size_get;
    /**
     * returns define data of min_nof_app_id_bits
     */
    dnx_data_mdb_em_min_nof_app_id_bits_get_f min_nof_app_id_bits_get;
    /**
     * returns define data of entry_addr_bits
     */
    dnx_data_mdb_em_entry_addr_bits_get_f entry_addr_bits_get;
    /**
     * returns define data of max_nof_spn_sizes
     */
    dnx_data_mdb_em_max_nof_spn_sizes_get_f max_nof_spn_sizes_get;
    /**
     * returns define data of nof_lfsr_sizes
     */
    dnx_data_mdb_em_nof_lfsr_sizes_get_f nof_lfsr_sizes_get;
    /**
     * returns define data of nof_formats
     */
    dnx_data_mdb_em_nof_formats_get_f nof_formats_get;
    /**
     * returns define data of defragmentation_priority_supported
     */
    dnx_data_mdb_em_defragmentation_priority_supported_get_f defragmentation_priority_supported_get;
    /**
     * returns define data of disable_cuckoo_loop_detection_support
     */
    dnx_data_mdb_em_disable_cuckoo_loop_detection_support_get_f disable_cuckoo_loop_detection_support_get;
    /**
     * returns define data of disable_cuckoo_hit_bit_sync
     */
    dnx_data_mdb_em_disable_cuckoo_hit_bit_sync_get_f disable_cuckoo_hit_bit_sync_get;
    /**
     * returns define data of age_profile_per_ratio_support
     */
    dnx_data_mdb_em_age_profile_per_ratio_support_get_f age_profile_per_ratio_support_get;
    /**
     * returns define data of flex_mag_supported
     */
    dnx_data_mdb_em_flex_mag_supported_get_f flex_mag_supported_get;
    /**
     * returns define data of flex_fully_supported
     */
    dnx_data_mdb_em_flex_fully_supported_get_f flex_fully_supported_get;
    /**
     * returns define data of step_table_max_size
     */
    dnx_data_mdb_em_step_table_max_size_get_f step_table_max_size_get;
    /**
     * returns define data of nof_encoding_values
     */
    dnx_data_mdb_em_nof_encoding_values_get_f nof_encoding_values_get;
    /**
     * returns numeric data of interrupt_register
     */
    dnx_data_mdb_em_interrupt_register_get_f interrupt_register_get;
    /**
     * get table spn entry 
     */
    dnx_data_mdb_em_spn_get_f spn_get;
    /**
     * get general info table about table (for example key size)spn info
     */
    dnxc_data_table_info_get_f spn_info_get;
    /**
     * get table lfsr entry 
     */
    dnx_data_mdb_em_lfsr_get_f lfsr_get;
    /**
     * get general info table about table (for example key size)lfsr info
     */
    dnxc_data_table_info_get_f lfsr_info_get;
    /**
     * get table em_aging_cfg entry 
     */
    dnx_data_mdb_em_em_aging_cfg_get_f em_aging_cfg_get;
    /**
     * get general info table about table (for example key size)em_aging_cfg info
     */
    dnxc_data_table_info_get_f em_aging_cfg_info_get;
    /**
     * get table flush entry 
     */
    dnx_data_mdb_em_flush_get_f flush_get;
    /**
     * get general info table about table (for example key size)flush info
     */
    dnxc_data_table_info_get_f flush_info_get;
    /**
     * get table em_info entry 
     */
    dnx_data_mdb_em_em_info_get_f em_info_get;
    /**
     * get general info table about table (for example key size)em_info info
     */
    dnxc_data_table_info_get_f em_info_info_get;
    /**
     * get table step_table_max_depth entry 
     */
    dnx_data_mdb_em_step_table_max_depth_get_f step_table_max_depth_get;
    /**
     * get general info table about table (for example key size)step_table_max_depth info
     */
    dnxc_data_table_info_get_f step_table_max_depth_info_get;
    /**
     * get table mdb_15_info entry 
     */
    dnx_data_mdb_em_mdb_15_info_get_f mdb_15_info_get;
    /**
     * get general info table about table (for example key size)mdb_15_info info
     */
    dnxc_data_table_info_get_f mdb_15_info_info_get;
    /**
     * get table mdb_16_info entry 
     */
    dnx_data_mdb_em_mdb_16_info_get_f mdb_16_info_get;
    /**
     * get general info table about table (for example key size)mdb_16_info info
     */
    dnxc_data_table_info_get_f mdb_16_info_info_get;
    /**
     * get table mdb_18_info entry 
     */
    dnx_data_mdb_em_mdb_18_info_get_f mdb_18_info_get;
    /**
     * get general info table about table (for example key size)mdb_18_info info
     */
    dnxc_data_table_info_get_f mdb_18_info_info_get;
    /**
     * get table mdb_21_info entry 
     */
    dnx_data_mdb_em_mdb_21_info_get_f mdb_21_info_get;
    /**
     * get general info table about table (for example key size)mdb_21_info info
     */
    dnxc_data_table_info_get_f mdb_21_info_info_get;
    /**
     * get table mdb_23_info entry 
     */
    dnx_data_mdb_em_mdb_23_info_get_f mdb_23_info_get;
    /**
     * get general info table about table (for example key size)mdb_23_info info
     */
    dnxc_data_table_info_get_f mdb_23_info_info_get;
    /**
     * get table mdb_24_info entry 
     */
    dnx_data_mdb_em_mdb_24_info_get_f mdb_24_info_get;
    /**
     * get general info table about table (for example key size)mdb_24_info info
     */
    dnxc_data_table_info_get_f mdb_24_info_info_get;
    /**
     * get table mdb_29_info entry 
     */
    dnx_data_mdb_em_mdb_29_info_get_f mdb_29_info_get;
    /**
     * get general info table about table (for example key size)mdb_29_info info
     */
    dnxc_data_table_info_get_f mdb_29_info_info_get;
    /**
     * get table mdb_31_info entry 
     */
    dnx_data_mdb_em_mdb_31_info_get_f mdb_31_info_get;
    /**
     * get general info table about table (for example key size)mdb_31_info info
     */
    dnxc_data_table_info_get_f mdb_31_info_info_get;
    /**
     * get table mdb_32_info entry 
     */
    dnx_data_mdb_em_mdb_32_info_get_f mdb_32_info_get;
    /**
     * get general info table about table (for example key size)mdb_32_info info
     */
    dnxc_data_table_info_get_f mdb_32_info_info_get;
    /**
     * get table mdb_41_info entry 
     */
    dnx_data_mdb_em_mdb_41_info_get_f mdb_41_info_get;
    /**
     * get general info table about table (for example key size)mdb_41_info info
     */
    dnxc_data_table_info_get_f mdb_41_info_info_get;
    /**
     * get table mdb_em_tables_info entry 
     */
    dnx_data_mdb_em_mdb_em_tables_info_get_f mdb_em_tables_info_get;
    /**
     * get general info table about table (for example key size)mdb_em_tables_info info
     */
    dnxc_data_table_info_get_f mdb_em_tables_info_info_get;
    /**
     * get table mdb_emp_tables_info entry 
     */
    dnx_data_mdb_em_mdb_emp_tables_info_get_f mdb_emp_tables_info_get;
    /**
     * get general info table about table (for example key size)mdb_emp_tables_info info
     */
    dnxc_data_table_info_get_f mdb_emp_tables_info_info_get;
} dnx_data_if_mdb_em_t;

/*
 * }
 */

/*
 * SUBMODULE  - DIRECT:
 * direct information.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule direct table direct_info
 * Table info:
 * general information of the direct table PDBs
 */
typedef struct
{
    /**
     * the type of the direct payload
     */
    dbal_enum_value_field_mdb_direct_payload_e payload_type;
} dnx_data_mdb_direct_direct_info_t;

/**
 * \brief Holds values of submodule direct table hit_bit_pos_in_abk
 * Table info:
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 */
typedef struct
{
    /**
     * The hit bit position in the ABK (relative to the entry).
     */
    uint8 hit_bit_position;
} dnx_data_mdb_direct_hit_bit_pos_in_abk_t;

/**
 * \brief Holds values of submodule direct table mdb_42_info
 * Table info:
 * No documentation.
 */
typedef struct
{
    /**
     * no description.
     */
    dbal_tables_e dbal_table;
} dnx_data_mdb_direct_mdb_42_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_direct_feature_nof
} dnx_data_mdb_direct_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_direct_feature_get_f) (
    int unit,
    dnx_data_mdb_direct_feature_e feature);

/**
 * \brief returns define data of physical_address_max_bits
 * Module - 'mdb', Submodule - 'direct', data - 'physical_address_max_bits'
 * The number of DB_ATR_PHYSICAL_ADDRESS_SPACE bits associated with encoding 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_max_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_physical_address_max_bits_get_f) (
    int unit);

/**
 * \brief returns define data of physical_address_max_bits_support_26k_granularity_fec_alloc
 * Module - 'mdb', Submodule - 'direct', data - 'physical_address_max_bits_support_26k_granularity_fec_alloc'
 * The largest address space value which can support 26k granularity for the FEC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_max_bits_support_26k_granularity_fec_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_physical_address_max_bits_support_26k_granularity_fec_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of vsi_physical_address_max_bits
 * Module - 'mdb', Submodule - 'direct', data - 'vsi_physical_address_max_bits'
 * The VSI number of DB_ATR_PHYSICAL_ADDRESS_SPACE bits associated with encoding 0.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsi_physical_address_max_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_vsi_physical_address_max_bits_get_f) (
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits'
 * The FEC address mapping bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_fec_address_mapping_bits_get_f) (
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits_relevant
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits_relevant'
 * The FEC relevant mapping bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits_relevant - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_fec_address_mapping_bits_relevant_get_f) (
    int unit);

/**
 * \brief returns define data of fec_address_mapping_bits_offset
 * Module - 'mdb', Submodule - 'direct', data - 'fec_address_mapping_bits_offset'
 * The FEC address relevant mapping bits offset.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_address_mapping_bits_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_fec_address_mapping_bits_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fec_max_cluster_pairs
 * Module - 'mdb', Submodule - 'direct', data - 'fec_max_cluster_pairs'
 * The maximal NOF cluster that can be associated to two FEC hierarchies.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_max_cluster_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_fec_max_cluster_pairs_get_f) (
    int unit);

/**
 * \brief returns define data of max_payload_size
 * Module - 'mdb', Submodule - 'direct', data - 'max_payload_size'
 * The largest payload size associated with a direct table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_max_payload_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fecs_in_super_fec
 * Module - 'mdb', Submodule - 'direct', data - 'nof_fecs_in_super_fec'
 * NOF of FECs contained in a single super FEC.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fecs_in_super_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_nof_fecs_in_super_fec_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fec_ecmp_hierarchies
 * Module - 'mdb', Submodule - 'direct', data - 'nof_fec_ecmp_hierarchies'
 * NOF of FEC/ECMP hierarchies.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_ecmp_hierarchies - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_direct_nof_fec_ecmp_hierarchies_get_f) (
    int unit);

/**
 * \brief get table direct_info entry 
 * general information of the direct table PDBs
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_id - logical tables according to the XML definitions from the MDB
 * 
 * \return
 *     direct_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_direct_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_direct_direct_info_t *(
    *dnx_data_mdb_direct_direct_info_get_f) (
    int unit,
    int dbal_id);

/**
 * \brief get table hit_bit_pos_in_abk entry 
 * Each 30 bits of each entry has a matching ABK bit, this table matches hit bit option to an ABK hit bit position.
 * 
 * \param [in] unit - unit #
 * \param [in] hit_bit_index - the hit bit index
 * 
 * \return
 *     hit_bit_pos_in_abk - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_hit_bit_pos_in_abk_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_direct_hit_bit_pos_in_abk_t *(
    *dnx_data_mdb_direct_hit_bit_pos_in_abk_get_f) (
    int unit,
    int hit_bit_index);

/**
 * \brief get table mdb_42_info entry 
 * No documentation.
 * 
 * \param [in] unit - unit #
 * \param [in] mdb_table - no description.
 * 
 * \return
 *     mdb_42_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_direct_mdb_42_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_direct_mdb_42_info_t *(
    *dnx_data_mdb_direct_mdb_42_info_get_f) (
    int unit,
    int mdb_table);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - DIRECT:
 * {
 */
/**
 * \brief Interface for mdb direct data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_direct_feature_get_f feature_get;
    /**
     * returns define data of physical_address_max_bits
     */
    dnx_data_mdb_direct_physical_address_max_bits_get_f physical_address_max_bits_get;
    /**
     * returns define data of physical_address_max_bits_support_26k_granularity_fec_alloc
     */
    dnx_data_mdb_direct_physical_address_max_bits_support_26k_granularity_fec_alloc_get_f physical_address_max_bits_support_26k_granularity_fec_alloc_get;
    /**
     * returns define data of vsi_physical_address_max_bits
     */
    dnx_data_mdb_direct_vsi_physical_address_max_bits_get_f vsi_physical_address_max_bits_get;
    /**
     * returns define data of fec_address_mapping_bits
     */
    dnx_data_mdb_direct_fec_address_mapping_bits_get_f fec_address_mapping_bits_get;
    /**
     * returns define data of fec_address_mapping_bits_relevant
     */
    dnx_data_mdb_direct_fec_address_mapping_bits_relevant_get_f fec_address_mapping_bits_relevant_get;
    /**
     * returns define data of fec_address_mapping_bits_offset
     */
    dnx_data_mdb_direct_fec_address_mapping_bits_offset_get_f fec_address_mapping_bits_offset_get;
    /**
     * returns define data of fec_max_cluster_pairs
     */
    dnx_data_mdb_direct_fec_max_cluster_pairs_get_f fec_max_cluster_pairs_get;
    /**
     * returns define data of max_payload_size
     */
    dnx_data_mdb_direct_max_payload_size_get_f max_payload_size_get;
    /**
     * returns define data of nof_fecs_in_super_fec
     */
    dnx_data_mdb_direct_nof_fecs_in_super_fec_get_f nof_fecs_in_super_fec_get;
    /**
     * returns define data of nof_fec_ecmp_hierarchies
     */
    dnx_data_mdb_direct_nof_fec_ecmp_hierarchies_get_f nof_fec_ecmp_hierarchies_get;
    /**
     * get table direct_info entry 
     */
    dnx_data_mdb_direct_direct_info_get_f direct_info_get;
    /**
     * get general info table about table (for example key size)direct_info info
     */
    dnxc_data_table_info_get_f direct_info_info_get;
    /**
     * get table hit_bit_pos_in_abk entry 
     */
    dnx_data_mdb_direct_hit_bit_pos_in_abk_get_f hit_bit_pos_in_abk_get;
    /**
     * get general info table about table (for example key size)hit_bit_pos_in_abk info
     */
    dnxc_data_table_info_get_f hit_bit_pos_in_abk_info_get;
    /**
     * get table mdb_42_info entry 
     */
    dnx_data_mdb_direct_mdb_42_info_get_f mdb_42_info_get;
    /**
     * get general info table about table (for example key size)mdb_42_info info
     */
    dnxc_data_table_info_get_f mdb_42_info_info_get;
} dnx_data_if_mdb_direct_t;

/*
 * }
 */

/*
 * SUBMODULE  - EEDB:
 * EEDB information.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule eedb table phase_info
 * Table info:
 * general information per EEDB phase.
 */
typedef struct
{
    /**
     * NOF available banks for the phase.
     */
    uint32 nof_available_banks;
} dnx_data_mdb_eedb_phase_info_t;

/**
 * \brief Holds values of submodule eedb table outlif_physical_phase_granularity
 * Table info:
 * Assign an outlif physical phase granularity.
 */
typedef struct
{
    /**
     * The granularity of the EEDB data.
     */
    uint32 data_granularity;
} dnx_data_mdb_eedb_outlif_physical_phase_granularity_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_eedb_feature_nof
} dnx_data_mdb_eedb_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_eedb_feature_get_f) (
    int unit,
    dnx_data_mdb_eedb_feature_e feature);

/**
 * \brief returns define data of phase_map_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_map_bits'
 * number of msbits used for the phase mapping.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_map_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_phase_map_bits_get_f) (
    int unit);

/**
 * \brief returns define data of phase_map_array_size
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_map_array_size'
 * Size of phase map array.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_map_array_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_phase_map_array_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phase_per_mag
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phase_per_mag'
 * the NOF phases each MAGs Is associated with.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phase_per_mag - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_phase_per_mag_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phases
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases'
 * NOF of EEDB phases.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_phases_get_f) (
    int unit);

/**
 * \brief returns define data of nof_eedb_mags
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_eedb_mags'
 * NOF of EEDB MAGs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eedb_mags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_eedb_mags_get_f) (
    int unit);

/**
 * \brief returns define data of nof_eedb_banks
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_eedb_banks'
 * NOF of EEDB banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eedb_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_eedb_banks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phases_per_eedb_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases_per_eedb_bank'
 * Each EEDB bank can be associated with one of this amount of phases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases_per_eedb_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_phases_per_eedb_bank_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phases_per_eedb_bank_size
 * Module - 'mdb', Submodule - 'eedb', data - 'nof_phases_per_eedb_bank_size'
 * nof_phases_per_eedb_bank size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phases_per_eedb_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_nof_phases_per_eedb_bank_size_get_f) (
    int unit);

/**
 * \brief returns define data of phase_bank_select_default
 * Module - 'mdb', Submodule - 'eedb', data - 'phase_bank_select_default'
 * the default phase value for a bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phase_bank_select_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_phase_bank_select_default_get_f) (
    int unit);

/**
 * \brief returns define data of entry_format_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_format_bits'
 * Number of MSbits used to determine the payload size in MDB_ENTRY_FORMATr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_format_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_entry_format_bits_get_f) (
    int unit);

/**
 * \brief returns define data of entry_format_encoding_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'entry_format_encoding_bits'
 * Number of bits used to represent the payload size (30/60/90/120) in MDB_ENTRY_FORMATr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_format_encoding_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_entry_format_encoding_bits_get_f) (
    int unit);

/**
 * \brief returns define data of bank_id_bits
 * Module - 'mdb', Submodule - 'eedb', data - 'bank_id_bits'
 * Number of bits used for bank_id comparison.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_id_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_bank_id_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of abk_bank
 * Module - 'mdb', Submodule - 'eedb', data - 'abk_bank'
 * the EEDB abk bank memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     abk_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_eedb_abk_bank_get_f) (
    int unit);

/**
 * \brief get table phase_info entry 
 * general information per EEDB phase.
 * 
 * \param [in] unit - unit #
 * \param [in] phase_number - the phase number.
 * 
 * \return
 *     phase_info - returns the relevant entry values grouped in struct - see dnx_data_mdb_eedb_phase_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_eedb_phase_info_t *(
    *dnx_data_mdb_eedb_phase_info_get_f) (
    int unit,
    int phase_number);

/**
 * \brief get table outlif_physical_phase_granularity entry 
 * Assign an outlif physical phase granularity.
 * 
 * \param [in] unit - unit #
 * \param [in] outlif_physical_phase - Physical phase.
 * 
 * \return
 *     outlif_physical_phase_granularity - returns the relevant entry values grouped in struct - see dnx_data_mdb_eedb_outlif_physical_phase_granularity_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_mdb_eedb_outlif_physical_phase_granularity_t *(
    *dnx_data_mdb_eedb_outlif_physical_phase_granularity_get_f) (
    int unit,
    int outlif_physical_phase);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - EEDB:
 * {
 */
/**
 * \brief Interface for mdb eedb data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_eedb_feature_get_f feature_get;
    /**
     * returns define data of phase_map_bits
     */
    dnx_data_mdb_eedb_phase_map_bits_get_f phase_map_bits_get;
    /**
     * returns define data of phase_map_array_size
     */
    dnx_data_mdb_eedb_phase_map_array_size_get_f phase_map_array_size_get;
    /**
     * returns define data of nof_phase_per_mag
     */
    dnx_data_mdb_eedb_nof_phase_per_mag_get_f nof_phase_per_mag_get;
    /**
     * returns define data of nof_phases
     */
    dnx_data_mdb_eedb_nof_phases_get_f nof_phases_get;
    /**
     * returns define data of nof_eedb_mags
     */
    dnx_data_mdb_eedb_nof_eedb_mags_get_f nof_eedb_mags_get;
    /**
     * returns define data of nof_eedb_banks
     */
    dnx_data_mdb_eedb_nof_eedb_banks_get_f nof_eedb_banks_get;
    /**
     * returns define data of nof_phases_per_eedb_bank
     */
    dnx_data_mdb_eedb_nof_phases_per_eedb_bank_get_f nof_phases_per_eedb_bank_get;
    /**
     * returns define data of nof_phases_per_eedb_bank_size
     */
    dnx_data_mdb_eedb_nof_phases_per_eedb_bank_size_get_f nof_phases_per_eedb_bank_size_get;
    /**
     * returns define data of phase_bank_select_default
     */
    dnx_data_mdb_eedb_phase_bank_select_default_get_f phase_bank_select_default_get;
    /**
     * returns define data of entry_format_bits
     */
    dnx_data_mdb_eedb_entry_format_bits_get_f entry_format_bits_get;
    /**
     * returns define data of entry_format_encoding_bits
     */
    dnx_data_mdb_eedb_entry_format_encoding_bits_get_f entry_format_encoding_bits_get;
    /**
     * returns define data of bank_id_bits
     */
    dnx_data_mdb_eedb_bank_id_bits_get_f bank_id_bits_get;
    /**
     * returns numeric data of abk_bank
     */
    dnx_data_mdb_eedb_abk_bank_get_f abk_bank_get;
    /**
     * get table phase_info entry 
     */
    dnx_data_mdb_eedb_phase_info_get_f phase_info_get;
    /**
     * get general info table about table (for example key size)phase_info info
     */
    dnxc_data_table_info_get_f phase_info_info_get;
    /**
     * get table outlif_physical_phase_granularity entry 
     */
    dnx_data_mdb_eedb_outlif_physical_phase_granularity_get_f outlif_physical_phase_granularity_get;
    /**
     * get general info table about table (for example key size)outlif_physical_phase_granularity info
     */
    dnxc_data_table_info_get_f outlif_physical_phase_granularity_info_get;
} dnx_data_if_mdb_eedb_t;

/*
 * }
 */

/*
 * SUBMODULE  - KAPS:
 * kaps information.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_mdb_kaps_feature_nof
} dnx_data_mdb_kaps_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_kaps_feature_get_f) (
    int unit,
    dnx_data_mdb_kaps_feature_e feature);

/**
 * \brief returns define data of nof_small_bbs
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_small_bbs'
 * nof small BBs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_small_bbs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_small_bb
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_rows_in_small_bb'
 * nof row in a small BB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_small_bb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_rows_in_small_bb_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rows_in_small_rbp_hitbits
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_rows_in_small_rbp_hitbits'
 * nof row in a small RPB hitbits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rows_in_small_rbp_hitbits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_rows_in_small_rbp_hitbits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bytes_in_hitbit_row
 * Module - 'mdb', Submodule - 'kaps', data - 'nof_bytes_in_hitbit_row'
 * nof bytes in a hitbit database row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bytes_in_hitbit_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_nof_bytes_in_hitbit_row_get_f) (
    int unit);

/**
 * \brief returns define data of key_lsn_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'key_lsn_bits'
 * RPB input = {key, search_lsn}.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_lsn_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_key_lsn_bits_get_f) (
    int unit);

/**
 * \brief returns define data of key_prefix_length
 * Module - 'mdb', Submodule - 'kaps', data - 'key_prefix_length'
 * The KAPS DB prefix length.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_prefix_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_key_prefix_length_get_f) (
    int unit);

/**
 * \brief returns define data of max_prefix_in_bb_row
 * Module - 'mdb', Submodule - 'kaps', data - 'max_prefix_in_bb_row'
 * The maximum number of prefixes in a single KAPS BB row.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_in_bb_row - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_max_prefix_in_bb_row_get_f) (
    int unit);

/**
 * \brief returns define data of key_width_in_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'key_width_in_bits'
 * The KAPS(LPM) key size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_width_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_key_width_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ad_width_in_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'ad_width_in_bits'
 * The KAPS(LPM) payload size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ad_width_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_ad_width_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of bb_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'bb_byte_width'
 * the BB width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bb_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_bb_byte_width_get_f) (
    int unit);

/**
 * \brief returns define data of rpb_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_byte_width'
 * the RPB width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_rpb_byte_width_get_f) (
    int unit);

/**
 * \brief returns define data of ads_byte_width
 * Module - 'mdb', Submodule - 'kaps', data - 'ads_byte_width'
 * the ADS width in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ads_byte_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_ads_byte_width_get_f) (
    int unit);

/**
 * \brief returns define data of rpb_valid_bits
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_valid_bits'
 * the RPB valid size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_valid_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_rpb_valid_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of rpb_field
 * Module - 'mdb', Submodule - 'kaps', data - 'rpb_field'
 * LPM RPB field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rpb_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_mdb_kaps_rpb_field_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - KAPS:
 * {
 */
/**
 * \brief Interface for mdb kaps data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_kaps_feature_get_f feature_get;
    /**
     * returns define data of nof_small_bbs
     */
    dnx_data_mdb_kaps_nof_small_bbs_get_f nof_small_bbs_get;
    /**
     * returns define data of nof_rows_in_small_bb
     */
    dnx_data_mdb_kaps_nof_rows_in_small_bb_get_f nof_rows_in_small_bb_get;
    /**
     * returns define data of nof_rows_in_small_rbp_hitbits
     */
    dnx_data_mdb_kaps_nof_rows_in_small_rbp_hitbits_get_f nof_rows_in_small_rbp_hitbits_get;
    /**
     * returns define data of nof_bytes_in_hitbit_row
     */
    dnx_data_mdb_kaps_nof_bytes_in_hitbit_row_get_f nof_bytes_in_hitbit_row_get;
    /**
     * returns define data of key_lsn_bits
     */
    dnx_data_mdb_kaps_key_lsn_bits_get_f key_lsn_bits_get;
    /**
     * returns define data of key_prefix_length
     */
    dnx_data_mdb_kaps_key_prefix_length_get_f key_prefix_length_get;
    /**
     * returns define data of max_prefix_in_bb_row
     */
    dnx_data_mdb_kaps_max_prefix_in_bb_row_get_f max_prefix_in_bb_row_get;
    /**
     * returns define data of key_width_in_bits
     */
    dnx_data_mdb_kaps_key_width_in_bits_get_f key_width_in_bits_get;
    /**
     * returns define data of ad_width_in_bits
     */
    dnx_data_mdb_kaps_ad_width_in_bits_get_f ad_width_in_bits_get;
    /**
     * returns define data of bb_byte_width
     */
    dnx_data_mdb_kaps_bb_byte_width_get_f bb_byte_width_get;
    /**
     * returns define data of rpb_byte_width
     */
    dnx_data_mdb_kaps_rpb_byte_width_get_f rpb_byte_width_get;
    /**
     * returns define data of ads_byte_width
     */
    dnx_data_mdb_kaps_ads_byte_width_get_f ads_byte_width_get;
    /**
     * returns define data of rpb_valid_bits
     */
    dnx_data_mdb_kaps_rpb_valid_bits_get_f rpb_valid_bits_get;
    /**
     * returns numeric data of rpb_field
     */
    dnx_data_mdb_kaps_rpb_field_get_f rpb_field_get;
} dnx_data_if_mdb_kaps_t;

/*
 * }
 */

/*
 * SUBMODULE  - HW_BUG:
 * MDB related hw bug
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * step table fully support mix aspect ratio algorithm.
     */
    dnx_data_mdb_hw_bug_step_table_supports_mix_ar_algo,

    /**
     * Must be last one!
     */
    _dnx_data_mdb_hw_bug_feature_nof
} dnx_data_mdb_hw_bug_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_mdb_hw_bug_feature_get_f) (
    int unit,
    dnx_data_mdb_hw_bug_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_MDB - HW_BUG:
 * {
 */
/**
 * \brief Interface for mdb hw_bug data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_mdb_hw_bug_feature_get_f feature_get;
} dnx_data_if_mdb_hw_bug_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_MDB:
 * {
 */
/**
 * \brief Interface for mdb data
 */
typedef struct
{
    /**
     * Interface for mdb global data
     */
    dnx_data_if_mdb_global_t global;
    /**
     * Interface for mdb dh data
     */
    dnx_data_if_mdb_dh_t dh;
    /**
     * Interface for mdb pdbs data
     */
    dnx_data_if_mdb_pdbs_t pdbs;
    /**
     * Interface for mdb em data
     */
    dnx_data_if_mdb_em_t em;
    /**
     * Interface for mdb direct data
     */
    dnx_data_if_mdb_direct_t direct;
    /**
     * Interface for mdb eedb data
     */
    dnx_data_if_mdb_eedb_t eedb;
    /**
     * Interface for mdb kaps data
     */
    dnx_data_if_mdb_kaps_t kaps;
    /**
     * Interface for mdb hw_bug data
     */
    dnx_data_if_mdb_hw_bug_t hw_bug;
} dnx_data_if_mdb_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_mdb_t dnx_data_mdb;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_MDB_H_*/
/* *INDENT-ON* */
