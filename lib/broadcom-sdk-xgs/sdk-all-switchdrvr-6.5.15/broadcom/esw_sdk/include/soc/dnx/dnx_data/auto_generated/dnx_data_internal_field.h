/** \file dnx_data_internal_field.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_FIELD_H_
/*{*/
#define _DNX_DATA_INTERNAL_FIELD_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_field.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_field_submodule_base_ipmf1,
    dnx_data_field_submodule_base_ipmf2,
    dnx_data_field_submodule_base_ipmf3,
    dnx_data_field_submodule_base_epmf,
    dnx_data_field_submodule_base_ifwd2,
    dnx_data_field_submodule_stage,
    dnx_data_field_submodule_kbp,
    dnx_data_field_submodule_tcam,
    dnx_data_field_submodule_group,
    dnx_data_field_submodule_efes,
    dnx_data_field_submodule_fem,
    dnx_data_field_submodule_context,
    dnx_data_field_submodule_preselector,
    dnx_data_field_submodule_qual,
    dnx_data_field_submodule_action,
    dnx_data_field_submodule_profile_bits,
    dnx_data_field_submodule_dir_ext,
    dnx_data_field_submodule_state_table,
    dnx_data_field_submodule_hash,
    dnx_data_field_submodule_udh,
    dnx_data_field_submodule_system_headers,
    dnx_data_field_submodule_exem,
    dnx_data_field_submodule_ace,
    dnx_data_field_submodule_entry,
    dnx_data_field_submodule_L4_Ops,
    dnx_data_field_submodule_encoded_qual_actions_offset,
    dnx_data_field_submodule_Compare_operand,
    dnx_data_field_submodule_diag,
    dnx_data_field_submodule_common_max_val,
    dnx_data_field_submodule_init,
    dnx_data_field_submodule_hw_workarounds,
    dnx_data_field_submodule_hw_features,
    dnx_data_field_submodule_minor_changes_j2_a0_b0,

    /**
     * Must be last one!
     */
    _dnx_data_field_submodule_nof
} dnx_data_field_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE BASE_IPMF1:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_ipmf1_feature_get(
    int unit,
    dnx_data_field_base_ipmf1_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_ipmf1_define_nof_ffc,
    dnx_data_field_base_ipmf1_define_nof_ffc_groups,
    dnx_data_field_base_ipmf1_define_ffc_group_one_lower,
    dnx_data_field_base_ipmf1_define_ffc_group_one_upper,
    dnx_data_field_base_ipmf1_define_ffc_group_two_lower,
    dnx_data_field_base_ipmf1_define_ffc_group_two_upper,
    dnx_data_field_base_ipmf1_define_ffc_group_three_lower,
    dnx_data_field_base_ipmf1_define_ffc_group_three_upper,
    dnx_data_field_base_ipmf1_define_ffc_group_four_lower,
    dnx_data_field_base_ipmf1_define_ffc_group_four_upper,
    dnx_data_field_base_ipmf1_define_nof_keys,
    dnx_data_field_base_ipmf1_define_nof_keys_alloc,
    dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_tcam,
    dnx_data_field_base_ipmf1_define_nof_keys_alloc_for_exem,
    dnx_data_field_base_ipmf1_define_nof_masks_per_fes,
    dnx_data_field_base_ipmf1_define_nof_fes_id_per_array,
    dnx_data_field_base_ipmf1_define_nof_fes_array,
    dnx_data_field_base_ipmf1_define_nof_fes_instruction_per_context,
    dnx_data_field_base_ipmf1_define_nof_fes_programs,
    dnx_data_field_base_ipmf1_define_nof_prog_per_fes,
    dnx_data_field_base_ipmf1_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_base_ipmf1_define_nof_contexts,
    dnx_data_field_base_ipmf1_define_nof_link_profiles,
    dnx_data_field_base_ipmf1_define_nof_cs_lines,
    dnx_data_field_base_ipmf1_define_nof_actions,
    dnx_data_field_base_ipmf1_define_nof_qualifiers,
    dnx_data_field_base_ipmf1_define_nof_80B_zones,
    dnx_data_field_base_ipmf1_define_nof_key_zones,
    dnx_data_field_base_ipmf1_define_nof_key_zone_bits,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fes_action,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fes_key_select,
    dnx_data_field_base_ipmf1_define_nof_fes_key_selects_on_one_actions_line,
    dnx_data_field_base_ipmf1_define_fem_condition_ms_bit_min_value,
    dnx_data_field_base_ipmf1_define_fem_condition_ms_bit_max_value,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_programs,
    dnx_data_field_base_ipmf1_define_nof_fem_programs,
    dnx_data_field_base_ipmf1_define_log_nof_bits_in_fem_key_select,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_key_select,
    dnx_data_field_base_ipmf1_define_fem_key_select_resolution_in_bits,
    dnx_data_field_base_ipmf1_define_log_nof_bits_in_fem_map_data_field,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_map_data_field,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action_fems_2_15,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action_fems_0_1,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_action,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_condition,
    dnx_data_field_base_ipmf1_define_nof_fem_condition,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_map_index,
    dnx_data_field_base_ipmf1_define_nof_fem_map_index,
    dnx_data_field_base_ipmf1_define_nof_bits_in_fem_id,
    dnx_data_field_base_ipmf1_define_nof_fem_id,
    dnx_data_field_base_ipmf1_define_num_fems_with_short_action,
    dnx_data_field_base_ipmf1_define_num_bits_in_fem_field_select,
    dnx_data_field_base_ipmf1_define_nof_fem_id_per_array,
    dnx_data_field_base_ipmf1_define_nof_fem_array,
    dnx_data_field_base_ipmf1_define_nof_fems_per_context,
    dnx_data_field_base_ipmf1_define_default_strength,
    dnx_data_field_base_ipmf1_define_nof_compare_pairs_in_compare_mode,
    dnx_data_field_base_ipmf1_define_nof_compare_keys_in_compare_mode,
    dnx_data_field_base_ipmf1_define_compare_key_size,
    dnx_data_field_base_ipmf1_define_nof_l4_ops_ranges,
    dnx_data_field_base_ipmf1_define_nof_pkt_hdr_ranges,
    dnx_data_field_base_ipmf1_define_nof_out_lif_ranges,
    dnx_data_field_base_ipmf1_define_fes_key_select_for_zero_bit,
    dnx_data_field_base_ipmf1_define_fes_shift_for_zero_bit,
    dnx_data_field_base_ipmf1_define_uses_small_exem,
    dnx_data_field_base_ipmf1_define_uses_large_exem,
    dnx_data_field_base_ipmf1_define_cmp_selection,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf1_define_nof
} dnx_data_field_base_ipmf1_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ffc'
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of ffc_group_two_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_two_lower'
 * Min FFC Index for Second FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_two_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_two_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_two_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_two_upper'
 * Max FFC Index for Second FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_two_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_two_upper_get(
    int unit);

/**
 * \brief returns define data of ffc_group_three_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_three_lower'
 * Min FFC Index for Thirth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_three_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_three_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_three_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_three_upper'
 * Max FFC Index for Thirth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_three_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_three_upper_get(
    int unit);

/**
 * \brief returns define data of ffc_group_four_lower
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_four_lower'
 * Min FFC Index for Fourth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_four_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_four_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_four_upper
 * Module - 'field', Submodule - 'base_ipmf1', data - 'ffc_group_four_upper'
 * Max FFC Index for Fourth FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_four_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_ffc_group_four_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_alloc_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_alloc_for_tcam_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_keys_alloc_for_exem_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_contexts'
 * Number of Ingress PMF_A programs (contexts). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_link_profiles
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_link_profiles'
 * Number of profiles assigned to iPMF1 contexts in order to create links between iPMF1 and iPMF2 contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_link_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_link_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_actions_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groupsv
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fes_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fes_key_selects_on_one_actions_line_get(
    int unit);

/**
 * \brief returns define data of fem_condition_ms_bit_min_value
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_condition_ms_bit_min_value'
 * The minumum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_condition_ms_bit_min_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fem_condition_ms_bit_min_value_get(
    int unit);

/**
 * \brief returns define data of fem_condition_ms_bit_max_value
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_condition_ms_bit_max_value'
 * The maximum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_condition_ms_bit_max_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fem_condition_ms_bit_max_value_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_programs'
 * Number of bit in FEM program representation. This is log2 of the number of fem programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_programs_get(
    int unit);

/**
 * \brief returns define data of nof_fem_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_programs'
 * Total number FEM programs available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_programs_get(
    int unit);

/**
 * \brief returns define data of log_nof_bits_in_fem_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'log_nof_bits_in_fem_key_select'
 * Log2 of number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     log_nof_bits_in_fem_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_log_nof_bits_in_fem_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_key_select'
 * Number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_key_select_get(
    int unit);

/**
 * \brief returns define data of fem_key_select_resolution_in_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_key_select_resolution_in_bits'
 * Number of bits in the 'step' from one 'key select' to the following. See dbal_enum_value_field_field_pmf_a_fem_key_select_e. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_key_select_resolution_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fem_key_select_resolution_in_bits_get(
    int unit);

/**
 * \brief returns define data of log_nof_bits_in_fem_map_data_field
 * Module - 'field', Submodule - 'base_ipmf1', data - 'log_nof_bits_in_fem_map_data_field'
 * Log2 of number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     log_nof_bits_in_fem_map_data_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_log_nof_bits_in_fem_map_data_field_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_map_data_field
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_map_data_field'
 * Number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_map_data_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_map_data_field_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action_fems_2_15
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action_fems_2_15'
 * Number of bits on action value in IPPC_FEM_*_24B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action_fems_2_15 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_2_15_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action_fems_0_1
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action_fems_0_1'
 * Number of bits on action value in IPPC_FEM_*_4B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action_fems_0_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_0_1_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action'
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_condition
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_condition'
 * Number of bits on fem condition. This is log2 of the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_condition_get(
    int unit);

/**
 * \brief returns define data of nof_fem_condition
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_condition'
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_condition_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_map_index
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_map_index'
 * Number of bits on fem map index. This represents log2 of the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_map_index_get(
    int unit);

/**
 * \brief returns define data of nof_fem_map_index
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_map_index'
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_map_index_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_id
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_id'
 * Number of bits on fem identifier. This represents the number of FEMs in the system: No. of FEMs is 2^nof_bits_in_fem_id. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_bits_in_fem_id_get(
    int unit);

/**
 * \brief returns define data of nof_fem_id
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_id'
 * Total number 'FEM id's available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_id_get(
    int unit);

/**
 * \brief returns define data of num_fems_with_short_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'num_fems_with_short_action'
 * Number of FEMs, starting from 'fem_id=0', which have only 4 bits on action value. The rest have 24 bits on action value. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_fems_with_short_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_num_fems_with_short_action_get(
    int unit);

/**
 * \brief returns define data of num_bits_in_fem_field_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'num_bits_in_fem_field_select'
 * Number of bits on each of the HW field marked FIELD_SELECT_MAP_*. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_bits_in_fem_field_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_num_bits_in_fem_field_select_get(
    int unit);

/**
 * \brief returns define data of nof_fem_id_per_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_id_per_array'
 * Number FEMes in each FEM array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fem_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_array'
 * Number FEM arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fem_array_get(
    int unit);

/**
 * \brief returns define data of nof_fems_per_context
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fems_per_context'
 * Number of FEMs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fems_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_fems_per_context_get(
    int unit);

/**
 * \brief returns define data of default_strength
 * Module - 'field', Submodule - 'base_ipmf1', data - 'default_strength'
 * Default value for PMF strength. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_default_strength_get(
    int unit);

/**
 * \brief returns define data of nof_compare_pairs_in_compare_mode
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_compare_pairs_in_compare_mode'
 * Number compare pairs in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_compare_pairs_in_compare_mode_get(
    int unit);

/**
 * \brief returns define data of nof_compare_keys_in_compare_mode
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_compare_keys_in_compare_mode'
 * Number compare keys in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_keys_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_compare_keys_in_compare_mode_get(
    int unit);

/**
 * \brief returns define data of compare_key_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'compare_key_size'
 * Size of the compare key in the system. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compare_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_compare_key_size_get(
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_l4_ops_ranges'
 * Number of ranges for L4 Ops. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_l4_ops_ranges_get(
    int unit);

/**
 * \brief returns define data of nof_pkt_hdr_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_pkt_hdr_ranges'
 * Number of ranges for PKT HDR. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pkt_hdr_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_pkt_hdr_ranges_get(
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_out_lif_ranges'
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_nof_out_lif_ranges_get(
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fes_key_select_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_uses_small_exem_get(
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_uses_large_exem_get(
    int unit);

/**
 * \brief returns define data of cmp_selection
 * Module - 'field', Submodule - 'base_ipmf1', data - 'cmp_selection'
 * Compare selection for both keys of 2nd compare, See the CMP_SELECTION field in IPPC_PMF_GENERAL register for additional information. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cmp_selection - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf1_cmp_selection_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf1_table_nof
} dnx_data_field_base_ipmf1_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BASE_IPMF2:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_ipmf2_feature_get(
    int unit,
    dnx_data_field_base_ipmf2_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_ipmf2_define_nof_ffc,
    dnx_data_field_base_ipmf2_define_nof_ffc_groups,
    dnx_data_field_base_ipmf2_define_ffc_group_one_lower,
    dnx_data_field_base_ipmf2_define_ffc_group_one_upper,
    dnx_data_field_base_ipmf2_define_nof_keys,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_tcam,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_exem,
    dnx_data_field_base_ipmf2_define_nof_keys_alloc_for_dir_ext,
    dnx_data_field_base_ipmf2_define_nof_masks_per_fes,
    dnx_data_field_base_ipmf2_define_nof_fes_id_per_array,
    dnx_data_field_base_ipmf2_define_nof_fes_array,
    dnx_data_field_base_ipmf2_define_nof_fes_instruction_per_context,
    dnx_data_field_base_ipmf2_define_nof_cs_lines,
    dnx_data_field_base_ipmf2_define_nof_contexts,
    dnx_data_field_base_ipmf2_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_base_ipmf2_define_nof_qualifiers,
    dnx_data_field_base_ipmf2_define_nof_80B_zones,
    dnx_data_field_base_ipmf2_define_nof_key_zones,
    dnx_data_field_base_ipmf2_define_nof_key_zone_bits,
    dnx_data_field_base_ipmf2_define_fes_key_select_for_zero_bit,
    dnx_data_field_base_ipmf2_define_fes_shift_for_zero_bit,
    dnx_data_field_base_ipmf2_define_uses_small_exem,
    dnx_data_field_base_ipmf2_define_uses_large_exem,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf2_define_nof
} dnx_data_field_base_ipmf2_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_ffc'
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf2', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf2', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_for_tcam_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_for_exem_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_keys_alloc_for_dir_ext_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_contexts'
 * Number of contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf2', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf2', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_fes_key_select_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf2', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_uses_small_exem_get(
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf2_uses_large_exem_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf2_table_nof
} dnx_data_field_base_ipmf2_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BASE_IPMF3:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_ipmf3_feature_get(
    int unit,
    dnx_data_field_base_ipmf3_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_ipmf3_define_nof_ffc,
    dnx_data_field_base_ipmf3_define_nof_ffc_groups,
    dnx_data_field_base_ipmf3_define_ffc_group_one_lower,
    dnx_data_field_base_ipmf3_define_ffc_group_one_upper,
    dnx_data_field_base_ipmf3_define_nof_keys,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_tcam,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_exem,
    dnx_data_field_base_ipmf3_define_nof_keys_alloc_for_dir_ext,
    dnx_data_field_base_ipmf3_define_nof_masks_per_fes,
    dnx_data_field_base_ipmf3_define_nof_fes_id_per_array,
    dnx_data_field_base_ipmf3_define_nof_fes_array,
    dnx_data_field_base_ipmf3_define_nof_fes_instruction_per_context,
    dnx_data_field_base_ipmf3_define_nof_fes_programs,
    dnx_data_field_base_ipmf3_define_nof_prog_per_fes,
    dnx_data_field_base_ipmf3_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_base_ipmf3_define_nof_contexts,
    dnx_data_field_base_ipmf3_define_nof_cs_lines,
    dnx_data_field_base_ipmf3_define_nof_actions,
    dnx_data_field_base_ipmf3_define_nof_qualifiers,
    dnx_data_field_base_ipmf3_define_nof_80B_zones,
    dnx_data_field_base_ipmf3_define_nof_key_zones,
    dnx_data_field_base_ipmf3_define_nof_key_zone_bits,
    dnx_data_field_base_ipmf3_define_nof_bits_in_fes_action,
    dnx_data_field_base_ipmf3_define_nof_bits_in_fes_key_select,
    dnx_data_field_base_ipmf3_define_nof_fes_key_selects_on_one_actions_line,
    dnx_data_field_base_ipmf3_define_default_strength,
    dnx_data_field_base_ipmf3_define_nof_out_lif_ranges,
    dnx_data_field_base_ipmf3_define_fes_key_select_for_zero_bit,
    dnx_data_field_base_ipmf3_define_fes_shift_for_zero_bit,
    dnx_data_field_base_ipmf3_define_uses_small_exem,
    dnx_data_field_base_ipmf3_define_uses_large_exem,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf3_define_nof
} dnx_data_field_base_ipmf3_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_ffc'
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ipmf3', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ipmf3', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_for_tcam_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_for_exem_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_keys_alloc_for_dir_ext_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_ipmf3', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_contexts'
 * Number of Ingress PMF_B programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_actions_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_bits_in_fes_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can go into one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_fes_key_selects_on_one_actions_line_get(
    int unit);

/**
 * \brief returns define data of default_strength
 * Module - 'field', Submodule - 'base_ipmf3', data - 'default_strength'
 * Default value for PMF strength. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_default_strength_get(
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_out_lif_ranges'
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_nof_out_lif_ranges_get(
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_fes_key_select_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_uses_small_exem_get(
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ipmf3_uses_large_exem_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf3_table_nof
} dnx_data_field_base_ipmf3_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BASE_EPMF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_epmf_feature_get(
    int unit,
    dnx_data_field_base_epmf_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_epmf_define_nof_ffc,
    dnx_data_field_base_epmf_define_nof_ffc_groups,
    dnx_data_field_base_epmf_define_ffc_group_one_lower,
    dnx_data_field_base_epmf_define_ffc_group_one_upper,
    dnx_data_field_base_epmf_define_nof_keys,
    dnx_data_field_base_epmf_define_nof_keys_alloc,
    dnx_data_field_base_epmf_define_nof_keys_alloc_for_tcam,
    dnx_data_field_base_epmf_define_nof_keys_alloc_for_exem,
    dnx_data_field_base_epmf_define_nof_masks_per_fes,
    dnx_data_field_base_epmf_define_nof_fes_id_per_array,
    dnx_data_field_base_epmf_define_nof_fes_array,
    dnx_data_field_base_epmf_define_nof_fes_instruction_per_context,
    dnx_data_field_base_epmf_define_nof_fes_programs,
    dnx_data_field_base_epmf_define_nof_prog_per_fes,
    dnx_data_field_base_epmf_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_base_epmf_define_nof_cs_lines,
    dnx_data_field_base_epmf_define_nof_contexts,
    dnx_data_field_base_epmf_define_nof_actions,
    dnx_data_field_base_epmf_define_nof_qualifiers,
    dnx_data_field_base_epmf_define_nof_80B_zones,
    dnx_data_field_base_epmf_define_nof_key_zones,
    dnx_data_field_base_epmf_define_nof_key_zone_bits,
    dnx_data_field_base_epmf_define_nof_bits_in_fes_action,
    dnx_data_field_base_epmf_define_nof_bits_in_fes_key_select,
    dnx_data_field_base_epmf_define_nof_fes_key_selects_on_one_actions_line,
    dnx_data_field_base_epmf_define_nof_l4_ops_ranges,
    dnx_data_field_base_epmf_define_fes_key_select_for_zero_bit,
    dnx_data_field_base_epmf_define_fes_shift_for_zero_bit,
    dnx_data_field_base_epmf_define_uses_small_exem,
    dnx_data_field_base_epmf_define_uses_large_exem,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_epmf_define_nof
} dnx_data_field_base_epmf_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_ffc'
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_epmf', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_epmf', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_alloc_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_alloc_for_tcam_get(
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_keys_alloc_for_exem_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'base_epmf', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory EGQ_PMF_PROGRAM_SELECTION_CAM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_contexts'
 * Number of Egress contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_actions_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_80B_zones'
 * Number of Egress PMF 80b dedicated instruction groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_key_zones'
 * Number of Egress PMF 80b key zones. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_key_zone_bits'
 * Number of Egress PMF key zone bits. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_bits_in_fes_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can applied on one line on actions table.('double key' actions are considered one line). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_fes_key_selects_on_one_actions_line_get(
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_l4_ops_ranges'
 * Number of ranges for L4 Ops. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_nof_l4_ops_ranges_get(
    int unit);

/**
 * \brief returns define data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_fes_key_select_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_fes_shift_for_zero_bit_get(
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_uses_small_exem_get(
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_epmf_uses_large_exem_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_epmf_table_nof
} dnx_data_field_base_epmf_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BASE_IFWD2:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_base_ifwd2_feature_get(
    int unit,
    dnx_data_field_base_ifwd2_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_base_ifwd2_define_nof_ffc,
    dnx_data_field_base_ifwd2_define_nof_ffc_groups,
    dnx_data_field_base_ifwd2_define_ffc_group_one_lower,
    dnx_data_field_base_ifwd2_define_ffc_group_one_upper,
    dnx_data_field_base_ifwd2_define_nof_keys,
    dnx_data_field_base_ifwd2_define_nof_contexts,
    dnx_data_field_base_ifwd2_define_nof_cs_lines,

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ifwd2_define_nof
} dnx_data_field_base_ifwd2_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_ffc'
 * Number of FFC's in this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_groups
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_ffc_groups'
 * Number of FFC Groups. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_ffc_groups_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_lower
 * Module - 'field', Submodule - 'base_ifwd2', data - 'ffc_group_one_lower'
 * Min FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_lower - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_ffc_group_one_lower_get(
    int unit);

/**
 * \brief returns define data of ffc_group_one_upper
 * Module - 'field', Submodule - 'base_ifwd2', data - 'ffc_group_one_upper'
 * Max FFC Index for First FFC Group. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_group_one_upper - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_ffc_group_one_upper_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_keys'
 * Number of keys available for allocation for use by this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_contexts'
 * Number of KBP ACL contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_base_ifwd2_nof_cs_lines_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ifwd2_table_nof
} dnx_data_field_base_ifwd2_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE STAGE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_stage_feature_get(
    int unit,
    dnx_data_field_stage_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_stage_define_nof
} dnx_data_field_stage_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_stage_table_stage_info,

    /**
     * Must be last one!
     */
    _dnx_data_field_stage_table_nof
} dnx_data_field_stage_table_e;

/* Get Data */
/**
 * \brief get table stage_info entry 
 * Per stage information
 * 
 * \param [in] unit - unit #
 * \param [in] stage - Field stage enum
 * 
 * \return
 *     stage_info - returns the relevant entry values grouped in struct - see dnx_data_field_stage_stage_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_stage_stage_info_t * dnx_data_field_stage_stage_info_get(
    int unit,
    int stage);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'stage', table - 'stage_info'
 * Per stage information
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_stage_stage_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)stage_info info
 * Per stage information
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stage_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_stage_stage_info_info_get(
    int unit);

/*
 * SUBMODULE KBP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_kbp_feature_get(
    int unit,
    dnx_data_field_kbp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_kbp_define_nof_fgs,
    dnx_data_field_kbp_define_max_master_key_size,
    dnx_data_field_kbp_define_max_single_key_size,
    dnx_data_field_kbp_define_nof_acl_keys_master_max,
    dnx_data_field_kbp_define_nof_acl_keys_fg_max,
    dnx_data_field_kbp_define_min_acl_nof_ffc,
    dnx_data_field_kbp_define_max_fwd_context_num_for_one_apptype,
    dnx_data_field_kbp_define_max_acl_context_num,
    dnx_data_field_kbp_define_size_apptype_profile_id,
    dnx_data_field_kbp_define_key_bmp,
    dnx_data_field_kbp_define_apptype_user_1st,
    dnx_data_field_kbp_define_apptype_user_nof,

    /**
     * Must be last one!
     */
    _dnx_data_field_kbp_define_nof
} dnx_data_field_kbp_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_fgs
 * Module - 'field', Submodule - 'kbp', data - 'nof_fgs'
 * Number of External TCAM Field Groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fgs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_nof_fgs_get(
    int unit);

/**
 * \brief returns define data of max_master_key_size
 * Module - 'field', Submodule - 'kbp', data - 'max_master_key_size'
 * Maximum Master key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_master_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_max_master_key_size_get(
    int unit);

/**
 * \brief returns define data of max_single_key_size
 * Module - 'field', Submodule - 'kbp', data - 'max_single_key_size'
 * Maximum single key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_max_single_key_size_get(
    int unit);

/**
 * \brief returns define data of nof_acl_keys_master_max
 * Module - 'field', Submodule - 'kbp', data - 'nof_acl_keys_master_max'
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single context
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_acl_keys_master_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_nof_acl_keys_master_max_get(
    int unit);

/**
 * \brief returns define data of nof_acl_keys_fg_max
 * Module - 'field', Submodule - 'kbp', data - 'nof_acl_keys_fg_max'
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single field group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_acl_keys_fg_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_nof_acl_keys_fg_max_get(
    int unit);

/**
 * \brief returns define data of min_acl_nof_ffc
 * Module - 'field', Submodule - 'kbp', data - 'min_acl_nof_ffc'
 * Minimum number of FFC's that should be allocated for each context for ACL purposes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_acl_nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_min_acl_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of max_fwd_context_num_for_one_apptype
 * Module - 'field', Submodule - 'kbp', data - 'max_fwd_context_num_for_one_apptype'
 * Maximum number of fwd contexts that could be mapped to an apptype 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fwd_context_num_for_one_apptype - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_max_fwd_context_num_for_one_apptype_get(
    int unit);

/**
 * \brief returns define data of max_acl_context_num
 * Module - 'field', Submodule - 'kbp', data - 'max_acl_context_num'
 * Maximum number of ACL contexts in the KBP 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_acl_context_num - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_max_acl_context_num_get(
    int unit);

/**
 * \brief returns define data of size_apptype_profile_id
 * Module - 'field', Submodule - 'kbp', data - 'size_apptype_profile_id'
 * Size in bits of the apptype profile ID (based on iFED2 ACL context)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     size_apptype_profile_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_size_apptype_profile_id_get(
    int unit);

/**
 * \brief returns define data of key_bmp
 * Module - 'field', Submodule - 'kbp', data - 'key_bmp'
 * bitmap of the key IDs used by the KBP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_bmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_key_bmp_get(
    int unit);

/**
 * \brief returns define data of apptype_user_1st
 * Module - 'field', Submodule - 'kbp', data - 'apptype_user_1st'
 * First User defined Apptype id to avoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     apptype_user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_apptype_user_1st_get(
    int unit);

/**
 * \brief returns define data of apptype_user_nof
 * Module - 'field', Submodule - 'kbp', data - 'apptype_user_nof'
 * Number of user Defined apptypes that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     apptype_user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_kbp_apptype_user_nof_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_kbp_table_ffc_to_quad_and_group_map,

    /**
     * Must be last one!
     */
    _dnx_data_field_kbp_table_nof
} dnx_data_field_kbp_table_e;

/* Get Data */
/**
 * \brief get table ffc_to_quad_and_group_map entry 
 * Mapping of the ffc id to its quad anad group
 * 
 * \param [in] unit - unit #
 * \param [in] ffc_id - Id of the required ffc
 * 
 * \return
 *     ffc_to_quad_and_group_map - returns the relevant entry values grouped in struct - see dnx_data_field_kbp_ffc_to_quad_and_group_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_kbp_ffc_to_quad_and_group_map_t * dnx_data_field_kbp_ffc_to_quad_and_group_map_get(
    int unit,
    int ffc_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'kbp', table - 'ffc_to_quad_and_group_map'
 * Mapping of the ffc id to its quad anad group
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_kbp_ffc_to_quad_and_group_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)ffc_to_quad_and_group_map info
 * Mapping of the ffc id to its quad anad group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_to_quad_and_group_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_kbp_ffc_to_quad_and_group_map_info_get(
    int unit);

/*
 * SUBMODULE TCAM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_tcam_feature_get(
    int unit,
    dnx_data_field_tcam_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_tcam_define_key_size_half,
    dnx_data_field_tcam_define_key_size_single,
    dnx_data_field_tcam_define_key_size_double,
    dnx_data_field_tcam_define_dt_max_key_size,
    dnx_data_field_tcam_define_action_size_half,
    dnx_data_field_tcam_define_action_size_single,
    dnx_data_field_tcam_define_action_size_double,
    dnx_data_field_tcam_define_key_mode_size,
    dnx_data_field_tcam_define_entry_size_single_key_hw,
    dnx_data_field_tcam_define_entry_size_single_valid_bits_hw,
    dnx_data_field_tcam_define_entry_size_half_payload_hw,
    dnx_data_field_tcam_define_hw_bank_size,
    dnx_data_field_tcam_define_small_bank_size,
    dnx_data_field_tcam_define_nof_big_bank_lines,
    dnx_data_field_tcam_define_nof_small_bank_lines,
    dnx_data_field_tcam_define_nof_big_banks,
    dnx_data_field_tcam_define_nof_small_banks,
    dnx_data_field_tcam_define_nof_banks,
    dnx_data_field_tcam_define_nof_payload_tables,
    dnx_data_field_tcam_define_nof_access_profiles,
    dnx_data_field_tcam_define_action_width_selector_size,
    dnx_data_field_tcam_define_cascaded_data_nof_bits,
    dnx_data_field_tcam_define_big_bank_key_nof_bits,
    dnx_data_field_tcam_define_nof_entries_160_bits,
    dnx_data_field_tcam_define_nof_entries_80_bits,
    dnx_data_field_tcam_define_tcam_banks_size,
    dnx_data_field_tcam_define_tcam_banks_last_index,
    dnx_data_field_tcam_define_nof_tcam_handlers,
    dnx_data_field_tcam_define_max_prefix_size,
    dnx_data_field_tcam_define_max_prefix_value,
    dnx_data_field_tcam_define_nof_keys_in_double_key,
    dnx_data_field_tcam_define_nof_keys_max,
    dnx_data_field_tcam_define_access_profile_half_key_mode,
    dnx_data_field_tcam_define_access_profile_single_key_mode,
    dnx_data_field_tcam_define_access_profile_double_key_mode,
    dnx_data_field_tcam_define_hit_indication_entries_per_byte,
    dnx_data_field_tcam_define_max_tcam_priority,

    /**
     * Must be last one!
     */
    _dnx_data_field_tcam_define_nof
} dnx_data_field_tcam_define_e;

/* Get Data */
/**
 * \brief returns define data of key_size_half
 * Module - 'field', Submodule - 'tcam', data - 'key_size_half'
 * Half TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_half - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_key_size_half_get(
    int unit);

/**
 * \brief returns define data of key_size_single
 * Module - 'field', Submodule - 'tcam', data - 'key_size_single'
 * Single TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_single - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_key_size_single_get(
    int unit);

/**
 * \brief returns define data of key_size_double
 * Module - 'field', Submodule - 'tcam', data - 'key_size_double'
 * Double TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_double - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_key_size_double_get(
    int unit);

/**
 * \brief returns define data of dt_max_key_size
 * Module - 'field', Submodule - 'tcam', data - 'dt_max_key_size'
 * Maximum key size for TCAM DT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dt_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_dt_max_key_size_get(
    int unit);

/**
 * \brief returns define data of action_size_half
 * Module - 'field', Submodule - 'tcam', data - 'action_size_half'
 * When the key size is half key (80b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_half - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_action_size_half_get(
    int unit);

/**
 * \brief returns define data of action_size_single
 * Module - 'field', Submodule - 'tcam', data - 'action_size_single'
 * When the key size is single key (160b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_single - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_action_size_single_get(
    int unit);

/**
 * \brief returns define data of action_size_double
 * Module - 'field', Submodule - 'tcam', data - 'action_size_double'
 * When the key size is double key (320b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_double - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_action_size_double_get(
    int unit);

/**
 * \brief returns define data of key_mode_size
 * Module - 'field', Submodule - 'tcam', data - 'key_mode_size'
 * Number of bits representing the entry size for each half entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_mode_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_key_mode_size_get(
    int unit);

/**
 * \brief returns define data of entry_size_single_key_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_key_hw'
 * The full key size in HW, includingd entry size field, not including payload and valid bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_key_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_entry_size_single_key_hw_get(
    int unit);

/**
 * \brief returns define data of entry_size_single_valid_bits_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_valid_bits_hw'
 * The size of the valid bits in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_valid_bits_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_entry_size_single_valid_bits_hw_get(
    int unit);

/**
 * \brief returns define data of entry_size_half_payload_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_half_payload_hw'
 * The full payload size in HW for half an entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_half_payload_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_entry_size_half_payload_hw_get(
    int unit);

/**
 * \brief returns define data of hw_bank_size
 * Module - 'field', Submodule - 'tcam', data - 'hw_bank_size'
 * Size of a TCAM bank in HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hw_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_hw_bank_size_get(
    int unit);

/**
 * \brief returns define data of small_bank_size
 * Module - 'field', Submodule - 'tcam', data - 'small_bank_size'
 * Number of entries per small TCAM bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_small_bank_size_get(
    int unit);

/**
 * \brief returns define data of nof_big_bank_lines
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_bank_lines'
 * Number of TCAM big bank lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_bank_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_big_bank_lines_get(
    int unit);

/**
 * \brief returns define data of nof_small_bank_lines
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_bank_lines'
 * Number of TCAM small bank lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bank_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_small_bank_lines_get(
    int unit);

/**
 * \brief returns define data of nof_big_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_banks'
 * Number of TCAM big banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_big_banks_get(
    int unit);

/**
 * \brief returns define data of nof_small_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_banks'
 * Number of TCAM small banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_small_banks_get(
    int unit);

/**
 * \brief returns define data of nof_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_banks'
 * Number of TCAM banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_banks_get(
    int unit);

/**
 * \brief returns define data of nof_payload_tables
 * Module - 'field', Submodule - 'tcam', data - 'nof_payload_tables'
 * Number of action tables
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_payload_tables - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_payload_tables_get(
    int unit);

/**
 * \brief returns define data of nof_access_profiles
 * Module - 'field', Submodule - 'tcam', data - 'nof_access_profiles'
 * Number of TCAM access profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_access_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_access_profiles_get(
    int unit);

/**
 * \brief returns define data of action_width_selector_size
 * Module - 'field', Submodule - 'tcam', data - 'action_width_selector_size'
 * The action width selector size for each bank in each access profile, each bit represents the corresponding 32 bit in the action table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_width_selector_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_action_width_selector_size_get(
    int unit);

/**
 * \brief returns define data of cascaded_data_nof_bits
 * Module - 'field', Submodule - 'tcam', data - 'cascaded_data_nof_bits'
 * Number of TCAM cascaded data bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cascaded_data_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_cascaded_data_nof_bits_get(
    int unit);

/**
 * \brief returns define data of big_bank_key_nof_bits
 * Module - 'field', Submodule - 'tcam', data - 'big_bank_key_nof_bits'
 * Number of TCAM big bank key bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     big_bank_key_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_big_bank_key_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_entries_160_bits
 * Module - 'field', Submodule - 'tcam', data - 'nof_entries_160_bits'
 * Number of 160 bits TCAM entries; Value: (nof_big_banks*nof_big_bank_lines)+(nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_160_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_entries_160_bits_get(
    int unit);

/**
 * \brief returns define data of nof_entries_80_bits
 * Module - 'field', Submodule - 'tcam', data - 'nof_entries_80_bits'
 * Number of 80 bits TCAM entries; Value: (2*nof_big_banks*nof_big_bank_lines)+(2*nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_80_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_entries_80_bits_get(
    int unit);

/**
 * \brief returns define data of tcam_banks_size
 * Module - 'field', Submodule - 'tcam', data - 'tcam_banks_size'
 * The size of TCAM_TCAM_BANK which is equal to (nof_big_banks + nof_small_banks) * nof_big_bank_lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_banks_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_tcam_banks_size_get(
    int unit);

/**
 * \brief returns define data of tcam_banks_last_index
 * Module - 'field', Submodule - 'tcam', data - 'tcam_banks_last_index'
 * Last index available in TCAM banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_banks_last_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_tcam_banks_last_index_get(
    int unit);

/**
 * \brief returns define data of nof_tcam_handlers
 * Module - 'field', Submodule - 'tcam', data - 'nof_tcam_handlers'
 * Number of TCAM handlers in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_handlers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_tcam_handlers_get(
    int unit);

/**
 * \brief returns define data of max_prefix_size
 * Module - 'field', Submodule - 'tcam', data - 'max_prefix_size'
 * Maximum prefix size in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_max_prefix_size_get(
    int unit);

/**
 * \brief returns define data of max_prefix_value
 * Module - 'field', Submodule - 'tcam', data - 'max_prefix_value'
 * Maximum prefix value in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_max_prefix_value_get(
    int unit);

/**
 * \brief returns define data of nof_keys_in_double_key
 * Module - 'field', Submodule - 'tcam', data - 'nof_keys_in_double_key'
 * Number of 160'b key's in double key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_in_double_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_keys_in_double_key_get(
    int unit);

/**
 * \brief returns define data of nof_keys_max
 * Module - 'field', Submodule - 'tcam', data - 'nof_keys_max'
 * Number of 160'b key's in one search lookup
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_nof_keys_max_get(
    int unit);

/**
 * \brief returns define data of access_profile_half_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_half_key_mode'
 * Half key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_half_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_access_profile_half_key_mode_get(
    int unit);

/**
 * \brief returns define data of access_profile_single_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_single_key_mode'
 * Single key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_single_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_access_profile_single_key_mode_get(
    int unit);

/**
 * \brief returns define data of access_profile_double_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_double_key_mode'
 * Double key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_double_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_access_profile_double_key_mode_get(
    int unit);

/**
 * \brief returns define data of hit_indication_entries_per_byte
 * Module - 'field', Submodule - 'tcam', data - 'hit_indication_entries_per_byte'
 * Number of entries in byte, in TCAM and CS TCAM HIT and indication memories.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hit_indication_entries_per_byte - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_hit_indication_entries_per_byte_get(
    int unit);

/**
 * \brief returns define data of max_tcam_priority
 * Module - 'field', Submodule - 'tcam', data - 'max_tcam_priority'
 * The biggest valid value for the priority of a TCAM entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tcam_priority - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_tcam_max_tcam_priority_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_tcam_table_nof
} dnx_data_field_tcam_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE GROUP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_group_feature_get(
    int unit,
    dnx_data_field_group_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_group_define_nof_fgs,
    dnx_data_field_group_define_nof_action_per_fg,
    dnx_data_field_group_define_nof_quals_per_fg,
    dnx_data_field_group_define_nof_keys_per_fg_max,
    dnx_data_field_group_define_id_fec_wa,

    /**
     * Must be last one!
     */
    _dnx_data_field_group_define_nof
} dnx_data_field_group_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_fgs
 * Module - 'field', Submodule - 'group', data - 'nof_fgs'
 * Number of Field Groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fgs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_nof_fgs_get(
    int unit);

/**
 * \brief returns define data of nof_action_per_fg
 * Module - 'field', Submodule - 'group', data - 'nof_action_per_fg'
 * Number of action per Field Group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_fg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_nof_action_per_fg_get(
    int unit);

/**
 * \brief returns define data of nof_quals_per_fg
 * Module - 'field', Submodule - 'group', data - 'nof_quals_per_fg'
 * Number of qualifiers per Field Group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_quals_per_fg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_nof_quals_per_fg_get(
    int unit);

/**
 * \brief returns define data of nof_keys_per_fg_max
 * Module - 'field', Submodule - 'group', data - 'nof_keys_per_fg_max'
 * Maximum number of keys (KBRs) a field group can have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_per_fg_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_nof_keys_per_fg_max_get(
    int unit);

/**
 * \brief returns define data of id_fec_wa
 * Module - 'field', Submodule - 'group', data - 'id_fec_wa'
 * FEC WA is being used in more then one WA context, hence must be created with_id so that other WA can re-use the FG
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     id_fec_wa - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_group_id_fec_wa_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_group_table_nof
} dnx_data_field_group_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE EFES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_efes_feature_get(
    int unit,
    dnx_data_field_efes_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_efes_define_max_nof_key_selects_per_field_io,

    /**
     * Must be last one!
     */
    _dnx_data_field_efes_define_nof
} dnx_data_field_efes_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_key_selects_per_field_io
 * Module - 'field', Submodule - 'efes', data - 'max_nof_key_selects_per_field_io'
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_key_selects_per_field_io - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_efes_max_nof_key_selects_per_field_io_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_efes_table_key_select_properties,

    /**
     * Must be last one!
     */
    _dnx_data_field_efes_table_nof
} dnx_data_field_efes_table_e;

/* Get Data */
/**
 * \brief get table key_select_properties entry 
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * \param [in] stage - Field stage enum
 * \param [in] field_io - Identifies the source of the information
 * 
 * \return
 *     key_select_properties - returns the relevant entry values grouped in struct - see dnx_data_field_efes_key_select_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_efes_key_select_properties_t * dnx_data_field_efes_key_select_properties_get(
    int unit,
    int stage,
    int field_io);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'efes', table - 'key_select_properties'
 * The properties of the different key select options
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_efes_key_select_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)key_select_properties info
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_select_properties - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_efes_key_select_properties_info_get(
    int unit);

/*
 * SUBMODULE FEM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_fem_feature_get(
    int unit,
    dnx_data_field_fem_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_fem_define_max_nof_key_selects_per_field_io,

    /**
     * Must be last one!
     */
    _dnx_data_field_fem_define_nof
} dnx_data_field_fem_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_key_selects_per_field_io
 * Module - 'field', Submodule - 'fem', data - 'max_nof_key_selects_per_field_io'
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_key_selects_per_field_io - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_fem_max_nof_key_selects_per_field_io_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_fem_table_key_select_properties,

    /**
     * Must be last one!
     */
    _dnx_data_field_fem_table_nof
} dnx_data_field_fem_table_e;

/* Get Data */
/**
 * \brief get table key_select_properties entry 
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * \param [in] field_io - Identifies the source of the information
 * 
 * \return
 *     key_select_properties - returns the relevant entry values grouped in struct - see dnx_data_field_fem_key_select_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_fem_key_select_properties_t * dnx_data_field_fem_key_select_properties_get(
    int unit,
    int field_io);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'fem', table - 'key_select_properties'
 * The properties of the different key select options
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_fem_key_select_properties_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)key_select_properties info
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_select_properties - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_fem_key_select_properties_info_get(
    int unit);

/*
 * SUBMODULE CONTEXT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_context_feature_get(
    int unit,
    dnx_data_field_context_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_context_define_default_context,
    dnx_data_field_context_define_default_itmh_context,
    dnx_data_field_context_define_default_itmh_pph_context,
    dnx_data_field_context_define_default_j1_itmh_context,
    dnx_data_field_context_define_default_j1_itmh_pph_context,
    dnx_data_field_context_define_default_stacking_context,
    dnx_data_field_context_define_default_oam_context,
    dnx_data_field_context_define_default_oam_reflector_context,

    /**
     * Must be last one!
     */
    _dnx_data_field_context_define_nof
} dnx_data_field_context_define_e;

/* Get Data */
/**
 * \brief returns define data of default_context
 * Module - 'field', Submodule - 'context', data - 'default_context'
 * Default Context Id (used for Ethernet Packets)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_context_get(
    int unit);

/**
 * \brief returns define data of default_itmh_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_context'
 * Default Context Id for ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_itmh_context_get(
    int unit);

/**
 * \brief returns define data of default_itmh_pph_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_pph_context'
 * Default Context Id for ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_itmh_pph_context_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_itmh_context'
 * Default Context Id for J1 ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_j1_itmh_context_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_itmh_pph_context'
 * Default Context Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_j1_itmh_pph_context_get(
    int unit);

/**
 * \brief returns define data of default_stacking_context
 * Module - 'field', Submodule - 'context', data - 'default_stacking_context'
 * Default Context Id for Stacking Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_stacking_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_stacking_context_get(
    int unit);

/**
 * \brief returns define data of default_oam_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_context'
 * Default Context Id for OAM Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_oam_context_get(
    int unit);

/**
 * \brief returns define data of default_oam_reflector_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_reflector_context'
 * Default Context Id for OAM downmep reflector Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_reflector_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_context_default_oam_reflector_context_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_context_table_nof
} dnx_data_field_context_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE PRESELECTOR:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_preselector_feature_get(
    int unit,
    dnx_data_field_preselector_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_preselector_define_default_oam_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_itmh_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_j1_itmh_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_itmh_pph_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_itmh_pph_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_j1_itmh_pph_presel_id_ipmf1,
    dnx_data_field_preselector_define_default_j1_itmh_pph_presel_id_ipmf3,
    dnx_data_field_preselector_define_default_stacking_presel_id_ipmf1,
    dnx_data_field_preselector_define_num_cs_inlif_profile_entries,

    /**
     * Must be last one!
     */
    _dnx_data_field_preselector_define_nof
} dnx_data_field_preselector_define_e;

/* Get Data */
/**
 * \brief returns define data of default_oam_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for OAM Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_oam_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_itmh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_itmh_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for J1 ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_itmh_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf3_get(
    int unit);

/**
 * \brief returns define data of default_stacking_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_stacking_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for Stacking Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_stacking_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_default_stacking_presel_id_ipmf1_get(
    int unit);

/**
 * \brief returns define data of num_cs_inlif_profile_entries
 * Module - 'field', Submodule - 'preselector', data - 'num_cs_inlif_profile_entries'
 * The number of CS entries which are used for inlif profile mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_cs_inlif_profile_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_preselector_num_cs_inlif_profile_entries_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_preselector_table_nof
} dnx_data_field_preselector_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE QUAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_qual_feature_get(
    int unit,
    dnx_data_field_qual_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_qual_define_user_1st,
    dnx_data_field_qual_define_user_nof,
    dnx_data_field_qual_define_max_bits_in_qual,
    dnx_data_field_qual_define_ingress_pbus_header_length,
    dnx_data_field_qual_define_egress_pbus_header_length,
    dnx_data_field_qual_define_ifwd2_pbus_size,
    dnx_data_field_qual_define_ipmf1_pbus_size,
    dnx_data_field_qual_define_ipmf2_pbus_size,
    dnx_data_field_qual_define_ipmf3_pbus_size,
    dnx_data_field_qual_define_epmf_pbus_size,
    dnx_data_field_qual_define_ingress_nof_layer_records,
    dnx_data_field_qual_define_ingress_layer_record_size,
    dnx_data_field_qual_define_egress_nof_layer_records,
    dnx_data_field_qual_define_egress_layer_record_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_qual_define_nof
} dnx_data_field_qual_define_e;

/* Get Data */
/**
 * \brief returns define data of user_1st
 * Module - 'field', Submodule - 'qual', data - 'user_1st'
 * First User qualifier id to avoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_user_1st_get(
    int unit);

/**
 * \brief returns define data of user_nof
 * Module - 'field', Submodule - 'qual', data - 'user_nof'
 * Number of User Define Data qualifiers that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_user_nof_get(
    int unit);

/**
 * \brief returns define data of max_bits_in_qual
 * Module - 'field', Submodule - 'qual', data - 'max_bits_in_qual'
 * Maximum number of bits that any qualifier can have
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_bits_in_qual - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_max_bits_in_qual_get(
    int unit);

/**
 * \brief returns define data of ingress_pbus_header_length
 * Module - 'field', Submodule - 'qual', data - 'ingress_pbus_header_length'
 * Number of bits reserved in ingress PBUS for header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_pbus_header_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ingress_pbus_header_length_get(
    int unit);

/**
 * \brief returns define data of egress_pbus_header_length
 * Module - 'field', Submodule - 'qual', data - 'egress_pbus_header_length'
 * Number of bits reserved in egress PBUS for header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_pbus_header_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_egress_pbus_header_length_get(
    int unit);

/**
 * \brief returns define data of ifwd2_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ifwd2_pbus_size'
 * Number of bits in the PBUS of iFWD2
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ifwd2_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ifwd2_pbus_size_get(
    int unit);

/**
 * \brief returns define data of ipmf1_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf1_pbus_size'
 * Number of bits in the PBUS of iPMF1
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ipmf1_pbus_size_get(
    int unit);

/**
 * \brief returns define data of ipmf2_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf2_pbus_size'
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf2_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ipmf2_pbus_size_get(
    int unit);

/**
 * \brief returns define data of ipmf3_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf3_pbus_size'
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf3_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ipmf3_pbus_size_get(
    int unit);

/**
 * \brief returns define data of epmf_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'epmf_pbus_size'
 * Number of bits in the PBUS of ePMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     epmf_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_epmf_pbus_size_get(
    int unit);

/**
 * \brief returns define data of ingress_nof_layer_records
 * Module - 'field', Submodule - 'qual', data - 'ingress_nof_layer_records'
 * Number of layer records taken from the parser in ingress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ingress_nof_layer_records_get(
    int unit);

/**
 * \brief returns define data of ingress_layer_record_size
 * Module - 'field', Submodule - 'qual', data - 'ingress_layer_record_size'
 * Number of bits in each layer record in ingress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_ingress_layer_record_size_get(
    int unit);

/**
 * \brief returns define data of egress_nof_layer_records
 * Module - 'field', Submodule - 'qual', data - 'egress_nof_layer_records'
 * Number of layer records taken from the parser in egress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_egress_nof_layer_records_get(
    int unit);

/**
 * \brief returns define data of egress_layer_record_size
 * Module - 'field', Submodule - 'qual', data - 'egress_layer_record_size'
 * Number of bits in each layer record in egress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_qual_egress_layer_record_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_qual_table_params,
    dnx_data_field_qual_table_layer_record_info_ingress,
    dnx_data_field_qual_table_layer_record_info_egress,

    /**
     * Must be last one!
     */
    _dnx_data_field_qual_table_nof
} dnx_data_field_qual_table_e;

/* Get Data */
/**
 * \brief get table params entry 
 * Per stage Per qualifier properties
 * 
 * \param [in] unit - unit #
 * \param [in] stage - stage enum
 * \param [in] qual - dnx qualifier
 * 
 * \return
 *     params - returns the relevant entry values grouped in struct - see dnx_data_field_qual_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_qual_params_t * dnx_data_field_qual_params_get(
    int unit,
    int stage,
    int qual);

/**
 * \brief get table layer_record_info_ingress entry 
 * Information about layer record qualifiers in the ingress
 * 
 * \param [in] unit - unit #
 * \param [in] layer_record - layer record enum
 * 
 * \return
 *     layer_record_info_ingress - returns the relevant entry values grouped in struct - see dnx_data_field_qual_layer_record_info_ingress_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_qual_layer_record_info_ingress_t * dnx_data_field_qual_layer_record_info_ingress_get(
    int unit,
    int layer_record);

/**
 * \brief get table layer_record_info_egress entry 
 * Information about layer record qualifiers in the egress
 * 
 * \param [in] unit - unit #
 * \param [in] layer_record - layer record enum
 * 
 * \return
 *     layer_record_info_egress - returns the relevant entry values grouped in struct - see dnx_data_field_qual_layer_record_info_egress_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_qual_layer_record_info_egress_t * dnx_data_field_qual_layer_record_info_egress_get(
    int unit,
    int layer_record);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'qual', table - 'params'
 * Per stage Per qualifier properties
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_qual_params_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'qual', table - 'layer_record_info_ingress'
 * Information about layer record qualifiers in the ingress
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_qual_layer_record_info_ingress_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'qual', table - 'layer_record_info_egress'
 * Information about layer record qualifiers in the egress
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_qual_layer_record_info_egress_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)params info
 * Per stage Per qualifier properties
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     params - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_qual_params_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)layer_record_info_ingress info
 * Information about layer record qualifiers in the ingress
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_record_info_ingress - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_qual_layer_record_info_ingress_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)layer_record_info_egress info
 * Information about layer record qualifiers in the egress
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_record_info_egress - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_qual_layer_record_info_egress_info_get(
    int unit);

/*
 * SUBMODULE ACTION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_action_feature_get(
    int unit,
    dnx_data_field_action_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_action_define_user_1st,
    dnx_data_field_action_define_user_nof,

    /**
     * Must be last one!
     */
    _dnx_data_field_action_define_nof
} dnx_data_field_action_define_e;

/* Get Data */
/**
 * \brief returns define data of user_1st
 * Module - 'field', Submodule - 'action', data - 'user_1st'
 * First user action id to avaoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_action_user_1st_get(
    int unit);

/**
 * \brief returns define data of user_nof
 * Module - 'field', Submodule - 'action', data - 'user_nof'
 * Number of User Define Data actions that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_action_user_nof_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_action_table_nof
} dnx_data_field_action_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE PROFILE_BITS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_profile_bits_feature_get(
    int unit,
    dnx_data_field_profile_bits_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_profile_bits_define_nof_ing_in_lif,
    dnx_data_field_profile_bits_define_nof_eg_in_lif,
    dnx_data_field_profile_bits_define_nof_ing_eth_rif,
    dnx_data_field_profile_bits_define_nof_eg_eth_rif,
    dnx_data_field_profile_bits_define_ingress_pp_port_key_gen_var_size,
    dnx_data_field_profile_bits_define_max_port_profile_size,
    dnx_data_field_profile_bits_define_nof_bits_in_port_profile,
    dnx_data_field_profile_bits_define_nof_bits_in_ingress_pp_port_general_data,
    dnx_data_field_profile_bits_define_pmf_sexem3_stage,

    /**
     * Must be last one!
     */
    _dnx_data_field_profile_bits_define_nof
} dnx_data_field_profile_bits_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ing_in_lif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_ing_in_lif'
 * Number of reserved bits for Ingress FP in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ing_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_ing_in_lif_get(
    int unit);

/**
 * \brief returns define data of nof_eg_in_lif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_eg_in_lif'
 * Number of reserved bits for Egress FP in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eg_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_eg_in_lif_get(
    int unit);

/**
 * \brief returns define data of nof_ing_eth_rif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_ing_eth_rif'
 * Number of reserved bits for Ingress FP in in_rif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ing_eth_rif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_ing_eth_rif_get(
    int unit);

/**
 * \brief returns define data of nof_eg_eth_rif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_eg_eth_rif'
 * Number of reserved bits for Egress FP in in_rif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eg_eth_rif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_eg_eth_rif_get(
    int unit);

/**
 * \brief returns define data of ingress_pp_port_key_gen_var_size
 * Module - 'field', Submodule - 'profile_bits', data - 'ingress_pp_port_key_gen_var_size'
 * Number of bits available on the key_ken_per per PP port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_pp_port_key_gen_var_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_ingress_pp_port_key_gen_var_size_get(
    int unit);

/**
 * \brief returns define data of max_port_profile_size
 * Module - 'field', Submodule - 'profile_bits', data - 'max_port_profile_size'
 * The maximum number in bits of all port profiles hw memories possible
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_port_profile_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_max_port_profile_size_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_port_profile
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_bits_in_port_profile'
 * The number of bits used by the PMF for port profiles. Note that the actual number may be lower in some stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_port_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_bits_in_port_profile_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_ingress_pp_port_general_data
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_bits_in_ingress_pp_port_general_data'
 * The number of bits used by the PMF for per PP port general data.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_ingress_pp_port_general_data - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_nof_bits_in_ingress_pp_port_general_data_get(
    int unit);

/**
 * \brief returns numeric data of pmf_sexem3_stage
 * Module - 'field', Submodule - 'profile_bits', data - 'pmf_sexem3_stage'
 * Determines using SOC property if we use SEXEM3 in iPMF2 or iPMF3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_sexem3_stage - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_profile_bits_pmf_sexem3_stage_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_profile_bits_table_nof
} dnx_data_field_profile_bits_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DIR_EXT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_dir_ext_feature_get(
    int unit,
    dnx_data_field_dir_ext_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_dir_ext_define_half_key_size,
    dnx_data_field_dir_ext_define_single_key_size,
    dnx_data_field_dir_ext_define_double_key_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_dir_ext_define_nof
} dnx_data_field_dir_ext_define_e;

/* Get Data */
/**
 * \brief returns define data of half_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'half_key_size'
 * Half key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     half_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_dir_ext_half_key_size_get(
    int unit);

/**
 * \brief returns define data of single_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'single_key_size'
 * Single key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_dir_ext_single_key_size_get(
    int unit);

/**
 * \brief returns define data of double_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'double_key_size'
 * Double key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     double_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_dir_ext_double_key_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_dir_ext_table_nof
} dnx_data_field_dir_ext_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE STATE_TABLE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_state_table_feature_get(
    int unit,
    dnx_data_field_state_table_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_state_table_define_key_size,
    dnx_data_field_state_table_define_address_max,
    dnx_data_field_state_table_define_address_size,
    dnx_data_field_state_table_define_data_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_state_table_define_nof
} dnx_data_field_state_table_define_e;

/* Get Data */
/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'state_table', data - 'key_size'
 * Size of the state table key in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_key_size_get(
    int unit);

/**
 * \brief returns define data of address_max
 * Module - 'field', Submodule - 'state_table', data - 'address_max'
 * Max address for the state table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_address_max_get(
    int unit);

/**
 * \brief returns define data of address_size
 * Module - 'field', Submodule - 'state_table', data - 'address_size'
 * Size of the address field in State Table in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_address_size_get(
    int unit);

/**
 * \brief returns define data of data_size
 * Module - 'field', Submodule - 'state_table', data - 'data_size'
 * Size of the data field in State Table in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_state_table_data_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_state_table_table_nof
} dnx_data_field_state_table_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE HASH:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_hash_feature_get(
    int unit,
    dnx_data_field_hash_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_hash_define_max_key_size,

    /**
     * Must be last one!
     */
    _dnx_data_field_hash_define_nof
} dnx_data_field_hash_define_e;

/* Get Data */
/**
 * \brief returns define data of max_key_size
 * Module - 'field', Submodule - 'hash', data - 'max_key_size'
 * maximal key size Field Group type 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_hash_max_key_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_hash_table_nof
} dnx_data_field_hash_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE UDH:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_udh_feature_get(
    int unit,
    dnx_data_field_udh_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_udh_define_type_count,
    dnx_data_field_udh_define_type_0_length,
    dnx_data_field_udh_define_type_1_length,
    dnx_data_field_udh_define_type_2_length,
    dnx_data_field_udh_define_type_3_length,
    dnx_data_field_udh_define_field_class_id_size_0,
    dnx_data_field_udh_define_field_class_id_size_1,
    dnx_data_field_udh_define_field_class_id_size_2,
    dnx_data_field_udh_define_field_class_id_size_3,

    /**
     * Must be last one!
     */
    _dnx_data_field_udh_define_nof
} dnx_data_field_udh_define_e;

/* Get Data */
/**
 * \brief returns define data of type_count
 * Module - 'field', Submodule - 'udh', data - 'type_count'
 * UDH Type count
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_count - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_count_get(
    int unit);

/**
 * \brief returns define data of type_0_length
 * Module - 'field', Submodule - 'udh', data - 'type_0_length'
 * UDH Type 0 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_0_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_0_length_get(
    int unit);

/**
 * \brief returns define data of type_1_length
 * Module - 'field', Submodule - 'udh', data - 'type_1_length'
 * UDH Type 1 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_1_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_1_length_get(
    int unit);

/**
 * \brief returns define data of type_2_length
 * Module - 'field', Submodule - 'udh', data - 'type_2_length'
 * UDH Type 2 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_2_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_2_length_get(
    int unit);

/**
 * \brief returns define data of type_3_length
 * Module - 'field', Submodule - 'udh', data - 'type_3_length'
 * UDH Type 3 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_3_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_type_3_length_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_0
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_0'
 * J1 Mode UDH related size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_0 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_size_0_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_1
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_1'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_size_1_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_2
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_2'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_size_2_get(
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_3
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_3'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_udh_field_class_id_size_3_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_udh_table_nof
} dnx_data_field_udh_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE SYSTEM_HEADERS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_system_headers_feature_get(
    int unit,
    dnx_data_field_system_headers_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_system_headers_define_nof_profiles,

    /**
     * Must be last one!
     */
    _dnx_data_field_system_headers_define_nof
} dnx_data_field_system_headers_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_profiles
 * Module - 'field', Submodule - 'system_headers', data - 'nof_profiles'
 * Number of system headers in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_system_headers_nof_profiles_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_system_headers_table_system_header_profiles,

    /**
     * Must be last one!
     */
    _dnx_data_field_system_headers_table_nof
} dnx_data_field_system_headers_table_e;

/* Get Data */
/**
 * \brief get table system_header_profiles entry 
 * Contains all system headers profiles defined in this device
 * 
 * \param [in] unit - unit #
 * \param [in] system_header_profile - System header profile number
 * 
 * \return
 *     system_header_profiles - returns the relevant entry values grouped in struct - see dnx_data_field_system_headers_system_header_profiles_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_system_headers_system_header_profiles_t * dnx_data_field_system_headers_system_header_profiles_get(
    int unit,
    int system_header_profile);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'system_headers', table - 'system_header_profiles'
 * Contains all system headers profiles defined in this device
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_system_headers_system_header_profiles_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)system_header_profiles info
 * Contains all system headers profiles defined in this device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     system_header_profiles - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_system_headers_system_header_profiles_info_get(
    int unit);

/*
 * SUBMODULE EXEM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_exem_feature_get(
    int unit,
    dnx_data_field_exem_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_exem_define_small_app_db_id_size,
    dnx_data_field_exem_define_large_app_db_id_size,
    dnx_data_field_exem_define_small_vmv_size,
    dnx_data_field_exem_define_large_vmv_size,
    dnx_data_field_exem_define_small_max_key_size,
    dnx_data_field_exem_define_large_max_key_size,
    dnx_data_field_exem_define_small_max_entry_result_size,
    dnx_data_field_exem_define_large_max_entry_result_size,
    dnx_data_field_exem_define_small_max_result_size,
    dnx_data_field_exem_define_large_max_result_size,
    dnx_data_field_exem_define_small_max_container_size,
    dnx_data_field_exem_define_large_max_container_size,
    dnx_data_field_exem_define_small_key_hash_size,
    dnx_data_field_exem_define_large_key_hash_size,
    dnx_data_field_exem_define_small_min_app_db_id_range,
    dnx_data_field_exem_define_large_min_app_db_id_range,
    dnx_data_field_exem_define_small_max_app_db_id_range,
    dnx_data_field_exem_define_large_max_app_db_id_range,
    dnx_data_field_exem_define_small_ipmf2_key,
    dnx_data_field_exem_define_small_ipmf2_key_part,
    dnx_data_field_exem_define_small_ipmf2_key_hw_value,
    dnx_data_field_exem_define_small_ipmf2_key_hw_bits,
    dnx_data_field_exem_define_large_ipmf1_key_configurable,
    dnx_data_field_exem_define_large_ipmf1_key,

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_define_nof
} dnx_data_field_exem_define_e;

/* Get Data */
/**
 * \brief returns define data of small_app_db_id_size
 * Module - 'field', Submodule - 'exem', data - 'small_app_db_id_size'
 * Number of bits used application db
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_app_db_id_size_get(
    int unit);

/**
 * \brief returns define data of large_app_db_id_size
 * Module - 'field', Submodule - 'exem', data - 'large_app_db_id_size'
 * Number of bits used application db
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_app_db_id_size_get(
    int unit);

/**
 * \brief returns define data of small_vmv_size
 * Module - 'field', Submodule - 'exem', data - 'small_vmv_size'
 * Number of bits used to encode the container size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_vmv_size_get(
    int unit);

/**
 * \brief returns define data of large_vmv_size
 * Module - 'field', Submodule - 'exem', data - 'large_vmv_size'
 * Number of bits used to encode the container size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_vmv_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_vmv_size_get(
    int unit);

/**
 * \brief returns define data of small_max_key_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_key_size'
 * Small EXEM key size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_key_size_get(
    int unit);

/**
 * \brief returns define data of large_max_key_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_key_size'
 * Large EXEM key size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_key_size_get(
    int unit);

/**
 * \brief returns define data of small_max_entry_result_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_entry_result_size'
 * Small EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_entry_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_entry_result_size_get(
    int unit);

/**
 * \brief returns define data of large_max_entry_result_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_entry_result_size'
 * Large EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_entry_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_entry_result_size_get(
    int unit);

/**
 * \brief returns define data of small_max_result_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_result_size'
 * Small EXEM result (payload) size in bits, not including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_result_size_get(
    int unit);

/**
 * \brief returns define data of large_max_result_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_result_size'
 * Large EXEM result (payload) size in bits, not including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_result_size_get(
    int unit);

/**
 * \brief returns define data of small_max_container_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_container_size'
 * Large EXEM maximal container size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_container_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_container_size_get(
    int unit);

/**
 * \brief returns define data of large_max_container_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_container_size'
 * Large EXEM result (payload) size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_container_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_container_size_get(
    int unit);

/**
 * \brief returns define data of small_key_hash_size
 * Module - 'field', Submodule - 'exem', data - 'small_key_hash_size'
 * number of bits out of key used for hashing (these bits are spared from saving in container)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_key_hash_size_get(
    int unit);

/**
 * \brief returns define data of large_key_hash_size
 * Module - 'field', Submodule - 'exem', data - 'large_key_hash_size'
 * number of bits out of key used for hashing (these bits are spared from saving in container)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_key_hash_size_get(
    int unit);

/**
 * \brief returns define data of small_min_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'small_min_app_db_id_range'
 * Small EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_min_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_min_app_db_id_range_get(
    int unit);

/**
 * \brief returns define data of large_min_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'large_min_app_db_id_range'
 * Large EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_min_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_min_app_db_id_range_get(
    int unit);

/**
 * \brief returns define data of small_max_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'small_max_app_db_id_range'
 * Small EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_max_app_db_id_range_get(
    int unit);

/**
 * \brief returns define data of large_max_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'large_max_app_db_id_range'
 * Large EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_max_app_db_id_range_get(
    int unit);

/**
 * \brief returns define data of small_ipmf2_key
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key'
 * The PMF key used for EXEM lookup by iPMF2. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_ipmf2_key_get(
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_part
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_part'
 * The PMF key part used for EXEM lookup by iPMF2. 0 means the LSB half, 1 the MSB half.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_part - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_ipmf2_key_part_get(
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_hw_value
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_hw_value'
 * The HW value to provide for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_hw_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_ipmf2_key_hw_value_get(
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_hw_bits
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_hw_bits'
 * The number of bits used by the HW for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_hw_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_small_ipmf2_key_hw_bits_get(
    int unit);

/**
 * \brief returns define data of large_ipmf1_key_configurable
 * Module - 'field', Submodule - 'exem', data - 'large_ipmf1_key_configurable'
 * Whether or not the EXEM key for iPMF1 can be configured on a chip wide basis.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_ipmf1_key_configurable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_ipmf1_key_configurable_get(
    int unit);

/**
 * \brief returns define data of large_ipmf1_key
 * Module - 'field', Submodule - 'exem', data - 'large_ipmf1_key'
 * The PMF key used for EXEM lookup by iPMF1. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_ipmf1_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_exem_large_ipmf1_key_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_table_nof
} dnx_data_field_exem_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ACE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_ace_feature_get(
    int unit,
    dnx_data_field_ace_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_ace_define_ace_id_size,
    dnx_data_field_ace_define_key_size,
    dnx_data_field_ace_define_key_hash_size,
    dnx_data_field_ace_define_app_db_id_size,
    dnx_data_field_ace_define_payload_size,
    dnx_data_field_ace_define_min_key_range_pmf,
    dnx_data_field_ace_define_max_key_range_pmf,
    dnx_data_field_ace_define_min_ace_id_dynamic_range,
    dnx_data_field_ace_define_nof_ace_id,
    dnx_data_field_ace_define_nof_action_per_ace_format,
    dnx_data_field_ace_define_row_size,
    dnx_data_field_ace_define_min_entry_size,
    dnx_data_field_ace_define_ace_id_pmf_alloc_first,
    dnx_data_field_ace_define_ace_id_pmf_alloc_last,
    dnx_data_field_ace_define_nof_masks_per_fes,
    dnx_data_field_ace_define_nof_fes_id_per_array,
    dnx_data_field_ace_define_nof_fes_array,
    dnx_data_field_ace_define_nof_fes_instruction_per_context,
    dnx_data_field_ace_define_nof_fes_programs,
    dnx_data_field_ace_define_nof_prog_per_fes,
    dnx_data_field_ace_define_nof_bits_in_fes_action,
    dnx_data_field_ace_define_fes_shift_for_zero_bit,

    /**
     * Must be last one!
     */
    _dnx_data_field_ace_define_nof
} dnx_data_field_ace_define_e;

/* Get Data */
/**
 * \brief returns define data of ace_id_size
 * Module - 'field', Submodule - 'ace', data - 'ace_id_size'
 * Number of bits used for the ACE ID (result type), which serves as an ID for the ACE format and context ID for the ACE EFES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_ace_id_size_get(
    int unit);

/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'ace', data - 'key_size'
 * Number of bits in the key of the PPMC table, including the prefix that indicates the type to the entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_key_size_get(
    int unit);

/**
 * \brief returns define data of key_hash_size
 * Module - 'field', Submodule - 'ace', data - 'key_hash_size'
 * Number of bits in the key that are only used in the hash and aren't placed in the entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_hash_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_key_hash_size_get(
    int unit);

/**
 * \brief returns define data of app_db_id_size
 * Module - 'field', Submodule - 'ace', data - 'app_db_id_size'
 * Number of bits Used for the APP DB ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_app_db_id_size_get(
    int unit);

/**
 * \brief returns define data of payload_size
 * Module - 'field', Submodule - 'ace', data - 'payload_size'
 * Number of bits used to encode the container size, including the result type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_payload_size_get(
    int unit);

/**
 * \brief returns define data of min_key_range_pmf
 * Module - 'field', Submodule - 'ace', data - 'min_key_range_pmf'
 * The first entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_key_range_pmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_min_key_range_pmf_get(
    int unit);

/**
 * \brief returns define data of max_key_range_pmf
 * Module - 'field', Submodule - 'ace', data - 'max_key_range_pmf'
 * The last entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_range_pmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_max_key_range_pmf_get(
    int unit);

/**
 * \brief returns define data of min_ace_id_dynamic_range
 * Module - 'field', Submodule - 'ace', data - 'min_ace_id_dynamic_range'
 * Minimal number of ACE ID that can be allocated dynamically.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_ace_id_dynamic_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_min_ace_id_dynamic_range_get(
    int unit);

/**
 * \brief returns define data of nof_ace_id
 * Module - 'field', Submodule - 'ace', data - 'nof_ace_id'
 * Number of ACE IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ace_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_ace_id_get(
    int unit);

/**
 * \brief returns define data of nof_action_per_ace_format
 * Module - 'field', Submodule - 'ace', data - 'nof_action_per_ace_format'
 * Number of action per ACE Format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_ace_format - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_action_per_ace_format_get(
    int unit);

/**
 * \brief returns define data of row_size
 * Module - 'field', Submodule - 'ace', data - 'row_size'
 * Number of bits per raw, entry size is number row size times VMV encoding meaning, e.g. half row encoding VMV would mean 60 bits entry size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     row_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_row_size_get(
    int unit);

/**
 * \brief returns define data of min_entry_size
 * Module - 'field', Submodule - 'ace', data - 'min_entry_size'
 * Minimum number of bits in entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_min_entry_size_get(
    int unit);

/**
 * \brief returns define data of ace_id_pmf_alloc_first
 * Module - 'field', Submodule - 'ace', data - 'ace_id_pmf_alloc_first'
 * The first ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_pmf_alloc_first - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_ace_id_pmf_alloc_first_get(
    int unit);

/**
 * \brief returns define data of ace_id_pmf_alloc_last
 * Module - 'field', Submodule - 'ace', data - 'ace_id_pmf_alloc_last'
 * The last ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_pmf_alloc_last - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_ace_id_pmf_alloc_last_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'ace', data - 'nof_masks_per_fes'
 * Number of masks per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_array'
 * Number FES arrays
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per ACE ID, also the number of FESes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_programs'
 * Number of FES programs. For ACE the FES program is the same as ACE ID. Used here for compatibility with PMF FESes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'ace', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'ace', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'ace', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES. Uses the zero padding at the end of the payload, expected to work only if EFES field type=1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_ace_fes_shift_for_zero_bit_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_ace_table_nof
} dnx_data_field_ace_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ENTRY:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_entry_feature_get(
    int unit,
    dnx_data_field_entry_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_entry_define_dir_ext_nof_fields,
    dnx_data_field_entry_define_nof_action_params_per_entry,
    dnx_data_field_entry_define_nof_qual_params_per_entry,

    /**
     * Must be last one!
     */
    _dnx_data_field_entry_define_nof
} dnx_data_field_entry_define_e;

/* Get Data */
/**
 * \brief returns define data of dir_ext_nof_fields
 * Module - 'field', Submodule - 'entry', data - 'dir_ext_nof_fields'
 * The maximum number of fields in a direct extraction request. \n                                                   (e.g. if we want the action to be composed of 3 bits of constant value, 5 bits from the key, \n                                                   5 bits of constant value and then 4 bits from the key we need at least 4 fields.)\n                                                   Used by dnx_field_dir_ext_action_t for the array size of the fields. \n                                                   Arbitrary value, can be increased.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_nof_fields - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_entry_dir_ext_nof_fields_get(
    int unit);

/**
 * \brief returns define data of nof_action_params_per_entry
 * Module - 'field', Submodule - 'entry', data - 'nof_action_params_per_entry'
 * Number of action parameters can be given for each action \n                                                             e.g. action values that are filled for TCAM action result
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_params_per_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_entry_nof_action_params_per_entry_get(
    int unit);

/**
 * \brief returns define data of nof_qual_params_per_entry
 * Module - 'field', Submodule - 'entry', data - 'nof_qual_params_per_entry'
 * Number of qualifiers parameters can be given for each qualifier type \n                                                             e.g. qualifier/key values that are filled for TCAM key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qual_params_per_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_entry_nof_qual_params_per_entry_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_entry_table_nof
} dnx_data_field_entry_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE L4_OPS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_L4_Ops_feature_get(
    int unit,
    dnx_data_field_L4_Ops_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_L4_Ops_define_udp_position,
    dnx_data_field_L4_Ops_define_tcp_position,

    /**
     * Must be last one!
     */
    _dnx_data_field_L4_Ops_define_nof
} dnx_data_field_L4_Ops_define_e;

/* Get Data */
/**
 * \brief returns define data of udp_position
 * Module - 'field', Submodule - 'L4_Ops', data - 'udp_position'
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     udp_position - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_L4_Ops_udp_position_get(
    int unit);

/**
 * \brief returns define data of tcp_position
 * Module - 'field', Submodule - 'L4_Ops', data - 'tcp_position'
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcp_position - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_L4_Ops_tcp_position_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_L4_Ops_table_nof
} dnx_data_field_L4_Ops_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ENCODED_QUAL_ACTIONS_OFFSET:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_encoded_qual_actions_offset_feature_get(
    int unit,
    dnx_data_field_encoded_qual_actions_offset_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_encoded_qual_actions_offset_define_trap_strength_offset,
    dnx_data_field_encoded_qual_actions_offset_define_trap_qualifier_offset,
    dnx_data_field_encoded_qual_actions_offset_define_sniff_qualifier_offset,
    dnx_data_field_encoded_qual_actions_offset_define_mirror_qualifier_offset,

    /**
     * Must be last one!
     */
    _dnx_data_field_encoded_qual_actions_offset_define_nof
} dnx_data_field_encoded_qual_actions_offset_define_e;

/* Get Data */
/**
 * \brief returns define data of trap_strength_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'trap_strength_offset'
 * The offset of the Trap Strength in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_strength_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_encoded_qual_actions_offset_trap_strength_offset_get(
    int unit);

/**
 * \brief returns define data of trap_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'trap_qualifier_offset'
 * The offset of the Trap Qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_encoded_qual_actions_offset_trap_qualifier_offset_get(
    int unit);

/**
 * \brief returns define data of sniff_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'sniff_qualifier_offset'
 * The offset of the Snoop qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sniff_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_encoded_qual_actions_offset_sniff_qualifier_offset_get(
    int unit);

/**
 * \brief returns define data of mirror_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'mirror_qualifier_offset'
 * The offset of the Mirror Qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mirror_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_encoded_qual_actions_offset_mirror_qualifier_offset_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_encoded_qual_actions_offset_table_nof
} dnx_data_field_encoded_qual_actions_offset_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE COMPARE_OPERAND:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_Compare_operand_feature_get(
    int unit,
    dnx_data_field_Compare_operand_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_Compare_operand_define_equal,
    dnx_data_field_Compare_operand_define_not_equal,
    dnx_data_field_Compare_operand_define_smaller,
    dnx_data_field_Compare_operand_define_not_smaller,
    dnx_data_field_Compare_operand_define_bigger,
    dnx_data_field_Compare_operand_define_not_bigger,
    dnx_data_field_Compare_operand_define_nof_operands,

    /**
     * Must be last one!
     */
    _dnx_data_field_Compare_operand_define_nof
} dnx_data_field_Compare_operand_define_e;

/* Get Data */
/**
 * \brief returns define data of equal
 * Module - 'field', Submodule - 'Compare_operand', data - 'equal'
 * The position in the qual showing that the result of compare is equal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     equal - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_equal_get(
    int unit);

/**
 * \brief returns define data of not_equal
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_equal'
 * The position in the qual showing that the result of compare is not equal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_equal - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_not_equal_get(
    int unit);

/**
 * \brief returns define data of smaller
 * Module - 'field', Submodule - 'Compare_operand', data - 'smaller'
 * The position in the qual showing that the first compare value is smaller then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     smaller - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_smaller_get(
    int unit);

/**
 * \brief returns define data of not_smaller
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_smaller'
 * The position in the qual showing that the first compare value is not smaller then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_smaller - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_not_smaller_get(
    int unit);

/**
 * \brief returns define data of bigger
 * Module - 'field', Submodule - 'Compare_operand', data - 'bigger'
 * The position in the qual showing that the first compare value is bigger then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bigger - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_bigger_get(
    int unit);

/**
 * \brief returns define data of not_bigger
 * Module - 'field', Submodule - 'Compare_operand', data - 'not_bigger'
 * The position in the qual showing that the first compare value is not bigger then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_bigger - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_not_bigger_get(
    int unit);

/**
 * \brief returns define data of nof_operands
 * Module - 'field', Submodule - 'Compare_operand', data - 'nof_operands'
 * The number of all operands
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_operands - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_Compare_operand_nof_operands_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_Compare_operand_table_nof
} dnx_data_field_Compare_operand_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DIAG:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_diag_feature_get(
    int unit,
    dnx_data_field_diag_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_diag_define_bytes_to_remove_mask,
    dnx_data_field_diag_define_layers_to_remove_size_in_bit,
    dnx_data_field_diag_define_layers_to_remove_mask,
    dnx_data_field_diag_define_nof_signals_per_action,
    dnx_data_field_diag_define_nof_signals_per_qualifier,

    /**
     * Must be last one!
     */
    _dnx_data_field_diag_define_nof
} dnx_data_field_diag_define_e;

/* Get Data */
/**
 * \brief returns define data of bytes_to_remove_mask
 * Module - 'field', Submodule - 'diag', data - 'bytes_to_remove_mask'
 * Mask of bits, which are related to the value of bytes to remove, from the signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_to_remove_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_bytes_to_remove_mask_get(
    int unit);

/**
 * \brief returns define data of layers_to_remove_size_in_bit
 * Module - 'field', Submodule - 'diag', data - 'layers_to_remove_size_in_bit'
 * Size of the layers to remove value in bits, to be used for shifting the signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layers_to_remove_size_in_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_layers_to_remove_size_in_bit_get(
    int unit);

/**
 * \brief returns define data of layers_to_remove_mask
 * Module - 'field', Submodule - 'diag', data - 'layers_to_remove_mask'
 * Mask of bits, which are related to the value of layers to remove, from the signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layers_to_remove_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_layers_to_remove_mask_get(
    int unit);

/**
 * \brief returns define data of nof_signals_per_action
 * Module - 'field', Submodule - 'diag', data - 'nof_signals_per_action'
 * Maximum number of signals per action.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_signals_per_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_nof_signals_per_action_get(
    int unit);

/**
 * \brief returns define data of nof_signals_per_qualifier
 * Module - 'field', Submodule - 'diag', data - 'nof_signals_per_qualifier'
 * Maximum number of signals per qualifier.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_signals_per_qualifier - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_diag_nof_signals_per_qualifier_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_diag_table_nof
} dnx_data_field_diag_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE COMMON_MAX_VAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_common_max_val_feature_get(
    int unit,
    dnx_data_field_common_max_val_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_common_max_val_define_nof_ffc,
    dnx_data_field_common_max_val_define_nof_keys,
    dnx_data_field_common_max_val_define_nof_masks_per_fes,
    dnx_data_field_common_max_val_define_nof_fes_id_per_array,
    dnx_data_field_common_max_val_define_nof_fes_array,
    dnx_data_field_common_max_val_define_nof_fes_instruction_per_context,
    dnx_data_field_common_max_val_define_nof_fes_programs,
    dnx_data_field_common_max_val_define_nof_prog_per_fes,
    dnx_data_field_common_max_val_define_nof_program_selection_lines,
    dnx_data_field_common_max_val_define_program_selection_cam_mask_nof_bits,
    dnx_data_field_common_max_val_define_nof_cs_lines,
    dnx_data_field_common_max_val_define_nof_contexts,
    dnx_data_field_common_max_val_define_nof_actions,
    dnx_data_field_common_max_val_define_nof_qualifiers,
    dnx_data_field_common_max_val_define_nof_80B_zones,
    dnx_data_field_common_max_val_define_nof_key_zones,
    dnx_data_field_common_max_val_define_nof_key_zone_bits,
    dnx_data_field_common_max_val_define_nof_bits_in_fes_action,
    dnx_data_field_common_max_val_define_nof_bits_in_fes_key_select,
    dnx_data_field_common_max_val_define_nof_fes_key_selects_on_one_actions_line,
    dnx_data_field_common_max_val_define_nof_ffc_in_qual,
    dnx_data_field_common_max_val_define_nof_bits_in_ffc,
    dnx_data_field_common_max_val_define_nof_ffc_in_uint32,
    dnx_data_field_common_max_val_define_nof_action_per_group,
    dnx_data_field_common_max_val_define_nof_layer_records,
    dnx_data_field_common_max_val_define_nof_l4_ops_ranges,
    dnx_data_field_common_max_val_define_nof_pkt_hdr_ranges,
    dnx_data_field_common_max_val_define_nof_out_lif_ranges,
    dnx_data_field_common_max_val_define_kbr_size,
    dnx_data_field_common_max_val_define_nof_compare_pairs,
    dnx_data_field_common_max_val_define_nof_compare_pairs_in_compare_mode,
    dnx_data_field_common_max_val_define_nof_compare_keys_in_compare_mode,
    dnx_data_field_common_max_val_define_nof_bits_in_fem_action,
    dnx_data_field_common_max_val_define_nof_fem_condition,
    dnx_data_field_common_max_val_define_nof_fem_map_index,
    dnx_data_field_common_max_val_define_nof_array_ids,
    dnx_data_field_common_max_val_define_dbal_pairs,

    /**
     * Must be last one!
     */
    _dnx_data_field_common_max_val_define_nof
} dnx_data_field_common_max_val_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc'
 * Maximal number of FFC's in all stages
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_keys'
 * Number of keys for the entire PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_keys_get(
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_masks_per_fes'
 * Number of masks per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_masks_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_id_per_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_array'
 * Number FES arrays
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_array_get(
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_instruction_per_context_get(
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_programs'
 * Number of FES programs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_programs_get(
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_prog_per_fes_get(
    int unit);

/**
 * \brief returns define data of nof_program_selection_lines
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_program_selection_lines'
 * Number of Ingress context selection lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_program_selection_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_program_selection_lines_get(
    int unit);

/**
 * \brief returns define data of program_selection_cam_mask_nof_bits
 * Module - 'field', Submodule - 'common_max_val', data - 'program_selection_cam_mask_nof_bits'
 * Number of bits for data or mask in the memory IHB_FLP_PROGRAM_SELECTION_CAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     program_selection_cam_mask_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_program_selection_cam_mask_nof_bits_get(
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_cs_lines'
 * Number of program selection lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_cs_lines_get(
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_contexts'
 * Number of contexts per PMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_contexts_get(
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_actions'
 * Number of actions
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_actions_get(
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_qualifiers'
 * Number of qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_qualifiers_get(
    int unit);

/**
 * \brief returns define data of nof_80B_zones
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_80B_zones'
 * Number of Ingress PMF 80b dedicated instruction groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_80B_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_80B_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zones
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_key_zones'
 * Number of Ingress PMF 80b key zones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zones - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_key_zones_get(
    int unit);

/**
 * \brief returns define data of nof_key_zone_bits
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_key_zone_bits'
 * Number of Ingress PMF 80b key zone bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_key_zone_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_key_zone_bits_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fes_action'
 * Number of bits on the outpus of a FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_bits_in_fes_action_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_bits_in_fes_key_select_get(
    int unit);

/**
 * \brief returns define data of nof_fes_key_selects_on_one_actions_line
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_key_selects_on_one_actions_line'
 * Number of 'key select's that can be applied on one line on actions table. ('double key' actions are considered one line)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_key_selects_on_one_actions_line - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fes_key_selects_on_one_actions_line_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_in_qual
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc_in_qual'
 * Maximal number of ffc for one qualifier.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_in_qual - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_ffc_in_qual_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_ffc
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_ffc'
 * Number of bits in ffc.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_bits_in_ffc_get(
    int unit);

/**
 * \brief returns define data of nof_ffc_in_uint32
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc_in_uint32'
 * Number of uint32 needed to hold bitmap for maximum number of FFC's.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_in_uint32 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_ffc_in_uint32_get(
    int unit);

/**
 * \brief returns define data of nof_action_per_group
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_action_per_group'
 * Maxmimal number of actions between both Field Group and ACE format. Used for arrays in functions that serve both.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_action_per_group_get(
    int unit);

/**
 * \brief returns define data of nof_layer_records
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_layer_records'
 * Maximal number of layer records.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_layer_records_get(
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_l4_ops_ranges'
 * Maximal number of ranges for L4 Ops.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_l4_ops_ranges_get(
    int unit);

/**
 * \brief returns define data of nof_pkt_hdr_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_pkt_hdr_ranges'
 * Maximal number of ranges for packet header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pkt_hdr_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_pkt_hdr_ranges_get(
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_out_lif_ranges'
 * Maximal number of ranges for Out Lif.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_out_lif_ranges_get(
    int unit);

/**
 * \brief returns define data of kbr_size
 * Module - 'field', Submodule - 'common_max_val', data - 'kbr_size'
 * Maximal KBR size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbr_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_kbr_size_get(
    int unit);

/**
 * \brief returns define data of nof_compare_pairs
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_pairs'
 * Maximal number of pairs used for compare.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_compare_pairs_get(
    int unit);

/**
 * \brief returns define data of nof_compare_pairs_in_compare_mode
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_pairs_in_compare_mode'
 * Number compare pairs in compare mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_compare_pairs_in_compare_mode_get(
    int unit);

/**
 * \brief returns define data of nof_compare_keys_in_compare_mode
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_keys_in_compare_mode'
 * Number compare keys in compare mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_keys_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_compare_keys_in_compare_mode_get(
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fem_action'
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_bits_in_fem_action_get(
    int unit);

/**
 * \brief returns define data of nof_fem_condition
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_condition'
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fem_condition_get(
    int unit);

/**
 * \brief returns define data of nof_fem_map_index
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_map_index'
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_fem_map_index_get(
    int unit);

/**
 * \brief returns define data of nof_array_ids
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_array_ids'
 * Total number of 'array_is's which are used to identify a range of FESes or FEMs. See BCM_FIELD_ACTION_POSITION.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_array_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_nof_array_ids_get(
    int unit);

/**
 * \brief returns define data of dbal_pairs
 * Module - 'field', Submodule - 'common_max_val', data - 'dbal_pairs'
 * Maximum number of pairs which are used to identify the DBAL key/result field in dnx_field_dbal_entry_set function. 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbal_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_common_max_val_dbal_pairs_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_field_common_max_val_table_array_id_type,

    /**
     * Must be last one!
     */
    _dnx_data_field_common_max_val_table_nof
} dnx_data_field_common_max_val_table_e;

/* Get Data */
/**
 * \brief get table array_id_type entry 
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * 
 * \param [in] unit - unit #
 * \param [in] array_id - Index identifier of 'array_id'
 * 
 * \return
 *     array_id_type - returns the relevant entry values grouped in struct - see dnx_data_field_common_max_val_array_id_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_field_common_max_val_array_id_type_t * dnx_data_field_common_max_val_array_id_type_get(
    int unit,
    int array_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'field', Submodule - 'common_max_val', table - 'array_id_type'
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_common_max_val_array_id_type_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)array_id_type info
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     array_id_type - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_field_common_max_val_array_id_type_info_get(
    int unit);

/*
 * SUBMODULE INIT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_init_feature_get(
    int unit,
    dnx_data_field_init_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_init_define_wa_fec_dest,
    dnx_data_field_init_define_wa_l4_trap,
    dnx_data_field_init_define_wa_oam_layer_index,
    dnx_data_field_init_define_wa_oam_stat,
    dnx_data_field_init_define_wa_flow_id,
    dnx_data_field_init_define_wa_roo,
    dnx_data_field_init_define_wa_j1_same_port,
    dnx_data_field_init_define_wa_j1_learning,

    /**
     * Must be last one!
     */
    _dnx_data_field_init_define_nof
} dnx_data_field_init_define_e;

/* Get Data */
/**
 * \brief returns define data of wa_fec_dest
 * Module - 'field', Submodule - 'init', data - 'wa_fec_dest'
 * APP WA for fec destination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_fec_dest - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_wa_fec_dest_get(
    int unit);

/**
 * \brief returns define data of wa_l4_trap
 * Module - 'field', Submodule - 'init', data - 'wa_l4_trap'
 * APP WA for L4 Trap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_l4_trap - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_wa_l4_trap_get(
    int unit);

/**
 * \brief returns define data of wa_oam_layer_index
 * Module - 'field', Submodule - 'init', data - 'wa_oam_layer_index'
 * APP WA for OAM Layer Index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_oam_layer_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_wa_oam_layer_index_get(
    int unit);

/**
 * \brief returns define data of wa_oam_stat
 * Module - 'field', Submodule - 'init', data - 'wa_oam_stat'
 * APP WA for OAM Statistics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_oam_stat - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_wa_oam_stat_get(
    int unit);

/**
 * \brief returns define data of wa_flow_id
 * Module - 'field', Submodule - 'init', data - 'wa_flow_id'
 * APP WA for Flow ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_flow_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_wa_flow_id_get(
    int unit);

/**
 * \brief returns define data of wa_roo
 * Module - 'field', Submodule - 'init', data - 'wa_roo'
 * APP WA for Roo
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_roo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_wa_roo_get(
    int unit);

/**
 * \brief returns define data of wa_j1_same_port
 * Module - 'field', Submodule - 'init', data - 'wa_j1_same_port'
 * APP WA for J1 Same port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_j1_same_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_wa_j1_same_port_get(
    int unit);

/**
 * \brief returns define data of wa_j1_learning
 * Module - 'field', Submodule - 'init', data - 'wa_j1_learning'
 * APP WA for J1 Learning
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wa_j1_learning - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_init_wa_j1_learning_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_init_table_nof
} dnx_data_field_init_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE HW_WORKAROUNDS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_hw_workarounds_feature_get(
    int unit,
    dnx_data_field_hw_workarounds_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_hw_workarounds_define_ecc_wa_enable,

    /**
     * Must be last one!
     */
    _dnx_data_field_hw_workarounds_define_nof
} dnx_data_field_hw_workarounds_define_e;

/* Get Data */
/**
 * \brief returns define data of ecc_wa_enable
 * Module - 'field', Submodule - 'hw_workarounds', data - 'ecc_wa_enable'
 * ECC is calculated per whole entry on each entry write, therefore, when writing half-entries\n                      wrong ECC values is being calculated, this workaround enables read-modify-write of the whole\n                      entry instead of writing half-entries to have correct ECC calculated on each write.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecc_wa_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_hw_workarounds_ecc_wa_enable_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_hw_workarounds_table_nof
} dnx_data_field_hw_workarounds_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE HW_FEATURES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_hw_features_feature_get(
    int unit,
    dnx_data_field_hw_features_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_hw_features_define_switch_to_acl_context,

    /**
     * Must be last one!
     */
    _dnx_data_field_hw_features_define_nof
} dnx_data_field_hw_features_define_e;

/* Get Data */
/**
 * \brief returns define data of switch_to_acl_context
 * Module - 'field', Submodule - 'hw_features', data - 'switch_to_acl_context'
 * Allows to swap the acl_context and fwd_context signals after iPMF1/2 using IPPC_PMF_GENERAL.SWITCH_TO_ACL_CONTEXT.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     switch_to_acl_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_hw_features_switch_to_acl_context_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_hw_features_table_nof
} dnx_data_field_hw_features_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE MINOR_CHANGES_J2_A0_B0:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_field_minor_changes_j2_a0_b0_feature_get(
    int unit,
    dnx_data_field_minor_changes_j2_a0_b0_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_field_minor_changes_j2_a0_b0_define_lr_eth_is_da_mac_valid,
    dnx_data_field_minor_changes_j2_a0_b0_define_per_pp_port_pmf_profile_cs_offset,
    dnx_data_field_minor_changes_j2_a0_b0_define_tcam_result_flip_eco,

    /**
     * Must be last one!
     */
    _dnx_data_field_minor_changes_j2_a0_b0_define_nof
} dnx_data_field_minor_changes_j2_a0_b0_define_e;

/* Get Data */
/**
 * \brief returns define data of lr_eth_is_da_mac_valid
 * Module - 'field', Submodule - 'minor_changes_j2_a0_b0', data - 'lr_eth_is_da_mac_valid'
 * Whether layer record ETH_IS_DA_MAC works on device (works on JR2_B0 but not on JR2_A0). For internal DNX DATA usage only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lr_eth_is_da_mac_valid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_minor_changes_j2_a0_b0_lr_eth_is_da_mac_valid_get(
    int unit);

/**
 * \brief returns define data of per_pp_port_pmf_profile_cs_offset
 * Module - 'field', Submodule - 'minor_changes_j2_a0_b0', data - 'per_pp_port_pmf_profile_cs_offset'
 * The placement of PMF_PROFILE field within ERPP_PER_PORT_TABLE. Used because DBAL mapping by device didn't work.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     per_pp_port_pmf_profile_cs_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_minor_changes_j2_a0_b0_per_pp_port_pmf_profile_cs_offset_get(
    int unit);

/**
 * \brief returns define data of tcam_result_flip_eco
 * Module - 'field', Submodule - 'minor_changes_j2_a0_b0', data - 'tcam_result_flip_eco'
 * The TCAM result flip ECO is about flippiing lsb and msb parts of the TCAM-result in order to support 80b result being parsed by ARR
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_result_flip_eco - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_field_minor_changes_j2_a0_b0_tcam_result_flip_eco_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_minor_changes_j2_a0_b0_table_nof
} dnx_data_field_minor_changes_j2_a0_b0_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_field_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_FIELD_H_*/
/* *INDENT-ON* */
