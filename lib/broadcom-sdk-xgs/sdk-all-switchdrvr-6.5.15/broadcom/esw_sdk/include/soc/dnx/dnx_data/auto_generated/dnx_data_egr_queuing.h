/** \file dnx_data_egr_queuing.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_EGR_QUEUING_H_
/*{*/
#define _DNX_DATA_EGR_QUEUING_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_egr_queuing.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_egr_queuing
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_egr_queuing_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - PARAMS:
 * default values for egr_queuing module
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule params table if_speed_params
 * Table info:
 * per port speed thresholds
 */
typedef struct
{
    /**
     * port speed in GHz
     */
    int speed;
    /**
     * port egq interface ID
     */
    int if_id;
    /**
     * TXI credits
     */
    int crdt_size;
    /**
     * NRDY threshold
     */
    int irdy_thr;
    /**
     * TXQ max bytes threshold
     */
    int txq_max_bytes;
    /**
     * minimum gap between consecutive access to same interface if serving HP Q
     */
    int min_gap_hp;
} dnx_data_egr_queuing_params_if_speed_params_t;

/**
 * \brief Holds values of submodule params table emr_fifo
 * Table info:
 * emr fifo parameters
 */
typedef struct
{
    /**
     * depth configuration for each FIFO
     */
    int depth;
    /**
     * configuration of almost full threshold
     */
    int almost_full;
    /**
     * configuration of full threshold
     */
    int full;
} dnx_data_egr_queuing_params_emr_fifo_t;

/**
 * \brief Holds values of submodule params table port_spr_pkt_mode
 * Table info:
 * is shaper working at packet mode
 */
typedef struct
{
    /**
     * Boolean. is shaper working at packet mode
     */
    int val;
} dnx_data_egr_queuing_params_port_spr_pkt_mode_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is 'port_read_enable' required before accessing OTM_CALENDAR_CRDT_TABLE? (temporary HW issue)
     */
    dnx_data_egr_queuing_params_conditional_crdt_table_access,

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_params_feature_nof
} dnx_data_egr_queuing_params_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_egr_queuing_params_feature_get_f) (
    int unit,
    dnx_data_egr_queuing_params_feature_e feature);

/**
 * \brief returns define data of nof_bits_in_tcg_weight
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_tcg_weight'
 * number of bits in 'weight' representation of a TCG. See EPS_DWM_8P
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_tcg_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_tcg_weight_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_q_pairs_in_ps
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_q_pairs_in_ps'
 * number of bits in 'nof_q_pairs_in_ps' representation. Essentially, log2(nof_q_pairs_in_ps)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_q_pairs_in_ps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_q_pairs_in_ps_get_f) (
    int unit);

/**
 * \brief returns define data of nof_q_pairs_in_ps
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_q_pairs_in_ps'
 * Number of qpairs per one port scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_q_pairs_in_ps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_q_pairs_in_ps_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_q_pair
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_q_pair'
 * number of bits in 'queue pair' representation. Essentially, log2(nof_q_pairs)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_q_pair - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_q_pair_get_f) (
    int unit);

/**
 * \brief returns define data of nof_q_pairs
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_q_pairs'
 * Number of q_pairs per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_q_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_q_pairs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_port_schedulers
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_port_schedulers'
 * number of bits in 'nof_port_schedulers' representation. Essentially, log2(nof_port_schedulers)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_port_schedulers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_port_schedulers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_port_schedulers
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_port_schedulers'
 * Number of port schedulers per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_port_schedulers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_port_schedulers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_calendar_size'
 * number of bits in 'num. of entries in calendar' representation. Essentially, log2(calendar_size)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'calendar_size'
 * number of entries in calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_calendars
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_calendars'
 * number of bits in 'egr nof_calendars' representation. Essentially, log2(nof_calendars)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_calendars_get_f) (
    int unit);

/**
 * \brief returns define data of nof_calendars
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_calendars'
 * Number of calendar-pairs per core. Total number of calendars is twice this value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_calendars_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_egr_interface
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_egr_interface'
 * number of bits in 'egr interface' representation. Essentially, log2(nof_egr_interfaces)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_egr_interface - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_egr_interface_get_f) (
    int unit);

/**
 * \brief returns define data of nof_egr_interfaces
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_egr_interfaces'
 * Number of egr interfaces, per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_egr_interfaces_get_f) (
    int unit);

/**
 * \brief returns define data of reserved_if
 * Module - 'egr_queuing', Submodule - 'params', data - 'reserved_if'
 * reserved interface (used for dummy flow control mapping in LAG SCH)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_reserved_if_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_cpu
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_cpu'
 * cpu interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_cpu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_cpu_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_sat
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_sat'
 * sat interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_sat - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_sat_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_oam
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_oam'
 * oam interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_oam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_oam_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_olp
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_olp'
 * olp interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_olp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_olp_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_rcy
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_rcy'
 * recycle interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_rcy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_rcy_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_txi_rcy
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_txi_rcy'
 * txi recycle interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_txi_rcy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_txi_rcy_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_eventor
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_eventor'
 * eventor interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_eventor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_eventor_get_f) (
    int unit);

/**
 * \brief returns define data of cal_res
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_res'
 * calendar resolution
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_res - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_cal_res_get_f) (
    int unit);

/**
 * \brief returns define data of cal_burst_res
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_burst_res'
 * calendar resolution
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_burst_res - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_cal_burst_res_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_cal_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_cal_cal_len'
 * Number of bits in representation of cal_cal_len (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_cal_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_cal_cal_len_get_f) (
    int unit);

/**
 * \brief returns define data of cal_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_cal_len'
 * calcal calendar length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_cal_cal_len_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nif_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nif_cal_len'
 * Number of bits in representation of nif_cal_len (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nif_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nif_cal_len_get_f) (
    int unit);

/**
 * \brief returns define data of nif_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'nif_cal_len'
 * nif calendar length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nif_cal_len_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_tcg
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_tcg'
 * Number of bits in representation of nof_tcg (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_tcg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tcg
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_tcg'
 * Number of TC groups supported by this system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_tcg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_egr_q_prio
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_egr_q_prio'
 * Number of bits in representation of nof_egr_q_prio (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_egr_q_prio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_egr_q_prio_get_f) (
    int unit);

/**
 * \brief returns define data of nof_egr_q_prio
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_egr_q_prio'
 * Number of egress priorities for unscheduled traffic
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_q_prio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_egr_q_prio_get_f) (
    int unit);

/**
 * \brief returns define data of tcg_min_priorities
 * Module - 'egr_queuing', Submodule - 'params', data - 'tcg_min_priorities'
 * minimum number of priorities supported by tcg
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcg_min_priorities - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_tcg_min_priorities_get_f) (
    int unit);

/**
 * \brief returns define data of max_credit_number
 * Module - 'egr_queuing', Submodule - 'params', data - 'max_credit_number'
 * the maximum number of credits supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_credit_number - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_max_credit_number_get_f) (
    int unit);

/**
 * \brief returns define data of max_gbps_rate_egq
 * Module - 'egr_queuing', Submodule - 'params', data - 'max_gbps_rate_egq'
 * EGQ Maximum Gb/s rate. This is the upper boundary, it can be lower depending on the credit size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_gbps_rate_egq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_max_gbps_rate_egq_get_f) (
    int unit);

/**
 * \brief returns define data of txq_iready_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'txq_iready_th'
 * Define ready TXQ treshold in PDs for non TDM queues, when Q is above this treshold FQP block relevant interface in EPS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     txq_iready_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_txq_iready_th_get_f) (
    int unit);

/**
 * \brief returns define data of txq_tdm_iready_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'txq_tdm_iready_th'
 * Define ready TXQ treshold in PDs for TDM queues, when Q is above this treshold FQP block relevant interface in EPS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     txq_tdm_iready_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_txq_tdm_iready_th_get_f) (
    int unit);

/**
 * \brief returns numeric data of tdm_interleve
 * Module - 'egr_queuing', Submodule - 'params', data - 'tdm_interleve'
 * Boolean. TDM interleaved queuing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_interleve - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_tdm_interleve_get_f) (
    int unit);

/**
 * \brief returns numeric data of tdm_tc
 * Module - 'egr_queuing', Submodule - 'params', data - 'tdm_tc'
 * TDM traffic class
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_tc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_tdm_tc_get_f) (
    int unit);

/**
 * \brief returns numeric data of tdm_dp
 * Module - 'egr_queuing', Submodule - 'params', data - 'tdm_dp'
 * TDM drop precident
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_dp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_tdm_dp_get_f) (
    int unit);

/**
 * \brief returns numeric data of tdm_exist
 * Module - 'egr_queuing', Submodule - 'params', data - 'tdm_exist'
 * Boolean. is TDM exist in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdm_exist - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_tdm_exist_get_f) (
    int unit);

/**
 * \brief returns numeric data of invalid_otm_port
 * Module - 'egr_queuing', Submodule - 'params', data - 'invalid_otm_port'
 * tm port that is marked as invalid (per core)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     invalid_otm_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_invalid_otm_port_get_f) (
    int unit);

/**
 * \brief get table if_speed_params entry 
 * per port speed thresholds
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * 
 * \return
 *     if_speed_params - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_if_speed_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_egr_queuing_params_if_speed_params_t *(
    *dnx_data_egr_queuing_params_if_speed_params_get_f) (
    int unit,
    int idx);

/**
 * \brief get table emr_fifo entry 
 * emr fifo parameters
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * \param [in] tdm - tdm exist in the system
 * 
 * \return
 *     emr_fifo - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_emr_fifo_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_egr_queuing_params_emr_fifo_t *(
    *dnx_data_egr_queuing_params_emr_fifo_get_f) (
    int unit,
    int idx,
    int tdm);

/**
 * \brief get table port_spr_pkt_mode entry 
 * is shaper working at packet mode
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     port_spr_pkt_mode - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_port_spr_pkt_mode_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_egr_queuing_params_port_spr_pkt_mode_t *(
    *dnx_data_egr_queuing_params_port_spr_pkt_mode_get_f) (
    int unit,
    int port);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_EGR_QUEUING - PARAMS:
 * {
 */
/**
 * \brief Interface for egr_queuing params data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_egr_queuing_params_feature_get_f feature_get;
    /**
     * returns define data of nof_bits_in_tcg_weight
     */
    dnx_data_egr_queuing_params_nof_bits_in_tcg_weight_get_f nof_bits_in_tcg_weight_get;
    /**
     * returns define data of nof_bits_in_nof_q_pairs_in_ps
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_q_pairs_in_ps_get_f nof_bits_in_nof_q_pairs_in_ps_get;
    /**
     * returns define data of nof_q_pairs_in_ps
     */
    dnx_data_egr_queuing_params_nof_q_pairs_in_ps_get_f nof_q_pairs_in_ps_get;
    /**
     * returns define data of nof_bits_in_q_pair
     */
    dnx_data_egr_queuing_params_nof_bits_in_q_pair_get_f nof_bits_in_q_pair_get;
    /**
     * returns define data of nof_q_pairs
     */
    dnx_data_egr_queuing_params_nof_q_pairs_get_f nof_q_pairs_get;
    /**
     * returns define data of nof_bits_in_nof_port_schedulers
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_port_schedulers_get_f nof_bits_in_nof_port_schedulers_get;
    /**
     * returns define data of nof_port_schedulers
     */
    dnx_data_egr_queuing_params_nof_port_schedulers_get_f nof_port_schedulers_get;
    /**
     * returns define data of nof_bits_in_calendar_size
     */
    dnx_data_egr_queuing_params_nof_bits_in_calendar_size_get_f nof_bits_in_calendar_size_get;
    /**
     * returns define data of calendar_size
     */
    dnx_data_egr_queuing_params_calendar_size_get_f calendar_size_get;
    /**
     * returns define data of nof_bits_in_nof_calendars
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_calendars_get_f nof_bits_in_nof_calendars_get;
    /**
     * returns define data of nof_calendars
     */
    dnx_data_egr_queuing_params_nof_calendars_get_f nof_calendars_get;
    /**
     * returns define data of nof_bits_in_egr_interface
     */
    dnx_data_egr_queuing_params_nof_bits_in_egr_interface_get_f nof_bits_in_egr_interface_get;
    /**
     * returns define data of nof_egr_interfaces
     */
    dnx_data_egr_queuing_params_nof_egr_interfaces_get_f nof_egr_interfaces_get;
    /**
     * returns define data of reserved_if
     */
    dnx_data_egr_queuing_params_reserved_if_get_f reserved_if_get;
    /**
     * returns define data of egr_if_cpu
     */
    dnx_data_egr_queuing_params_egr_if_cpu_get_f egr_if_cpu_get;
    /**
     * returns define data of egr_if_sat
     */
    dnx_data_egr_queuing_params_egr_if_sat_get_f egr_if_sat_get;
    /**
     * returns define data of egr_if_oam
     */
    dnx_data_egr_queuing_params_egr_if_oam_get_f egr_if_oam_get;
    /**
     * returns define data of egr_if_olp
     */
    dnx_data_egr_queuing_params_egr_if_olp_get_f egr_if_olp_get;
    /**
     * returns define data of egr_if_rcy
     */
    dnx_data_egr_queuing_params_egr_if_rcy_get_f egr_if_rcy_get;
    /**
     * returns define data of egr_if_txi_rcy
     */
    dnx_data_egr_queuing_params_egr_if_txi_rcy_get_f egr_if_txi_rcy_get;
    /**
     * returns define data of egr_if_eventor
     */
    dnx_data_egr_queuing_params_egr_if_eventor_get_f egr_if_eventor_get;
    /**
     * returns define data of cal_res
     */
    dnx_data_egr_queuing_params_cal_res_get_f cal_res_get;
    /**
     * returns define data of cal_burst_res
     */
    dnx_data_egr_queuing_params_cal_burst_res_get_f cal_burst_res_get;
    /**
     * returns define data of nof_bits_in_cal_cal_len
     */
    dnx_data_egr_queuing_params_nof_bits_in_cal_cal_len_get_f nof_bits_in_cal_cal_len_get;
    /**
     * returns define data of cal_cal_len
     */
    dnx_data_egr_queuing_params_cal_cal_len_get_f cal_cal_len_get;
    /**
     * returns define data of nof_bits_in_nif_cal_len
     */
    dnx_data_egr_queuing_params_nof_bits_in_nif_cal_len_get_f nof_bits_in_nif_cal_len_get;
    /**
     * returns define data of nif_cal_len
     */
    dnx_data_egr_queuing_params_nif_cal_len_get_f nif_cal_len_get;
    /**
     * returns define data of nof_bits_in_nof_tcg
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_tcg_get_f nof_bits_in_nof_tcg_get;
    /**
     * returns define data of nof_tcg
     */
    dnx_data_egr_queuing_params_nof_tcg_get_f nof_tcg_get;
    /**
     * returns define data of nof_bits_in_nof_egr_q_prio
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_egr_q_prio_get_f nof_bits_in_nof_egr_q_prio_get;
    /**
     * returns define data of nof_egr_q_prio
     */
    dnx_data_egr_queuing_params_nof_egr_q_prio_get_f nof_egr_q_prio_get;
    /**
     * returns define data of tcg_min_priorities
     */
    dnx_data_egr_queuing_params_tcg_min_priorities_get_f tcg_min_priorities_get;
    /**
     * returns define data of max_credit_number
     */
    dnx_data_egr_queuing_params_max_credit_number_get_f max_credit_number_get;
    /**
     * returns define data of max_gbps_rate_egq
     */
    dnx_data_egr_queuing_params_max_gbps_rate_egq_get_f max_gbps_rate_egq_get;
    /**
     * returns define data of txq_iready_th
     */
    dnx_data_egr_queuing_params_txq_iready_th_get_f txq_iready_th_get;
    /**
     * returns define data of txq_tdm_iready_th
     */
    dnx_data_egr_queuing_params_txq_tdm_iready_th_get_f txq_tdm_iready_th_get;
    /**
     * returns numeric data of tdm_interleve
     */
    dnx_data_egr_queuing_params_tdm_interleve_get_f tdm_interleve_get;
    /**
     * returns numeric data of tdm_tc
     */
    dnx_data_egr_queuing_params_tdm_tc_get_f tdm_tc_get;
    /**
     * returns numeric data of tdm_dp
     */
    dnx_data_egr_queuing_params_tdm_dp_get_f tdm_dp_get;
    /**
     * returns numeric data of tdm_exist
     */
    dnx_data_egr_queuing_params_tdm_exist_get_f tdm_exist_get;
    /**
     * returns numeric data of invalid_otm_port
     */
    dnx_data_egr_queuing_params_invalid_otm_port_get_f invalid_otm_port_get;
    /**
     * get table if_speed_params entry 
     */
    dnx_data_egr_queuing_params_if_speed_params_get_f if_speed_params_get;
    /**
     * get general info table about table (for example key size)if_speed_params info
     */
    dnxc_data_table_info_get_f if_speed_params_info_get;
    /**
     * get table emr_fifo entry 
     */
    dnx_data_egr_queuing_params_emr_fifo_get_f emr_fifo_get;
    /**
     * get general info table about table (for example key size)emr_fifo info
     */
    dnxc_data_table_info_get_f emr_fifo_info_get;
    /**
     * get table port_spr_pkt_mode entry 
     */
    dnx_data_egr_queuing_params_port_spr_pkt_mode_get_f port_spr_pkt_mode_get;
    /**
     * get general info table about table (for example key size)port_spr_pkt_mode info
     */
    dnxc_data_table_info_get_f port_spr_pkt_mode_info_get;
} dnx_data_if_egr_queuing_params_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_EGR_QUEUING:
 * {
 */
/**
 * \brief Interface for egr_queuing data
 */
typedef struct
{
    /**
     * Interface for egr_queuing params data
     */
    dnx_data_if_egr_queuing_params_t params;
} dnx_data_if_egr_queuing_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_egr_queuing_t dnx_data_egr_queuing;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_EGR_QUEUING_H_*/
/* *INDENT-ON* */
