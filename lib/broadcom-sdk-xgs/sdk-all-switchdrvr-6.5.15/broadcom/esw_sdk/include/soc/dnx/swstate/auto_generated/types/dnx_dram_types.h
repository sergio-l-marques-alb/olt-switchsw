/** \file dnx/swstate/auto_generated/types/dnx_dram_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */

#ifndef __DNX_DRAM_TYPES_H__
#define __DNX_DRAM_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <include/bcm/switch.h>
#include <include/shared/periodic_event.h>
/*
 * TYPEDEFs
 */

typedef sw_state_user_def_t* dnx_power_down_callback_userdata_t;

/*
 * ENUMs
 */

/**
 * Enum used to determine the DRAM temperature monitoring thread state
 */
typedef enum {
    /**
     * DRAM monitoring thread is operating at normal temperature state
     */
    DNX_DRAM_NORMAL_TEMP = 0,
    /**
     * DRAM monitoring thread is operating at high temperature state
     */
    DNX_DRAM_HIGH_TEMP = 1
} dnx_dram_temperature_monitoring_state_e;

/*
 * STRUCTs
 */

typedef struct {
    /**
     * indication that the info in this struct was init to real values
     */
    uint32 is_init;
    /**
     * check JEDEC for additional info
     */
    uint32 gen2_test;
    /**
     * check JEDEC for additional info
     */
    uint32 ecc;
    /**
     * check JEDEC for additional info
     */
    uint32 density;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturer_id;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturing_location;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturing_year;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturing_week;
    /**
     * check JEDEC for additional info
     */
    uint32 serial_number[2];
    /**
     * check JEDEC for additional info
     */
    uint32 addressing_mode;
    /**
     * check JEDEC for additional info
     */
    uint32 channel_available;
    /**
     * check JEDEC for additional info
     */
    uint32 hbm_stack_hight;
    /**
     * check JEDEC for additional info
     */
    uint32 model_part_number;
} hbm_dram_vendor_info_hbm_t;

typedef struct {
    /**
     * mutex to prevent race condition on access to deleted dram buffers file
     */
    sal_mutex_t deleted_buffers_file_mutex;
} dnx_dram_sync_manager_t;

typedef struct {
    /**
     * pointer to power down callback function
     */
    bcm_switch_dram_power_down_callback_t callback;
    /**
     * user data pointer
     */
    dnx_power_down_callback_userdata_t userdata;
} dnx_power_down_t;

/**
 * DB for used by dram and dram buffers
 */
typedef struct {
    /**
     * manages sync between different threads
     */
    dnx_dram_sync_manager_t sync_manager;
    /**
     * power down callback information (as register by the user)
     */
    dnx_power_down_t power_down_callback;
    /**
     * if set - bist used during tuning will be override by native tune configuration. if not - last bist configuration used will also be used during tuning
     */
    int override_bist_configurations_during_tuning;
    /**
     * if set - bist used during tuning will perform channel soft reset after each run.
     */
    int channel_soft_init_after_bist;
    /**
     * -1 - all cores, 0 - core 0, 1 - core 1. this configurations will choose the core on which the traffic will run when using custom mode when tuning the dram
     */
    int traffic_tuning_core_mode;
    /**
     * temperature monitoring thread state as defined in the enum
     */
    dnx_dram_temperature_monitoring_state_e temperature_monitoring_thread_state;
    /**
     * a handle for the thread that is created
     */
    periodic_event_handler_t temperature_monitoring_thread_handler;
    /**
     * HBM vendor info
     */
    hbm_dram_vendor_info_hbm_t vendor_info[2];
} dnx_dram_db_t;


#endif /* __DNX_DRAM_TYPES_H__ */
