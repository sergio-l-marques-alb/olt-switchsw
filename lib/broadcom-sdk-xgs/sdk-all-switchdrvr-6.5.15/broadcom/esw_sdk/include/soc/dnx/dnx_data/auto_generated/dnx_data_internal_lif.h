/** \file dnx_data_internal_lif.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_LIF_H_
/*{*/
#define _DNX_DATA_INTERNAL_LIF_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_lif.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_lif_submodule_global_lif,
    dnx_data_lif_submodule_in_lif,
    dnx_data_lif_submodule_out_lif,
    dnx_data_lif_submodule_lif_table_manager,

    /**
     * Must be last one!
     */
    _dnx_data_lif_submodule_nof
} dnx_data_lif_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GLOBAL_LIF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_global_lif_feature_get(
    int unit,
    dnx_data_lif_global_lif_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs,
    dnx_data_lif_global_lif_define_glem_rif_optimization_enabled,
    dnx_data_lif_global_lif_define_nof_global_in_lifs,
    dnx_data_lif_global_lif_define_nof_global_out_lifs,
    dnx_data_lif_global_lif_define_nof_glem_lines,

    /**
     * Must be last one!
     */
    _dnx_data_lif_global_lif_define_nof
} dnx_data_lif_global_lif_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_global_l2_gport_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_l2_gport_lifs'
 * The mpls and vlan ports don't have enough bits to support the full global lif address. Their number is limited by this value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_l2_gport_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_nof_global_l2_gport_lifs_get(
    int unit);

/**
 * \brief returns define data of glem_rif_optimization_enabled
 * Module - 'lif', Submodule - 'global_lif', data - 'glem_rif_optimization_enabled'
 * Amount of out RIFs one GLEM entry can hold for optimized GLEM usage is 4.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     glem_rif_optimization_enabled - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_glem_rif_optimization_enabled_get(
    int unit);

/**
 * \brief returns numeric data of nof_global_in_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_in_lifs'
 * Number of in global lifs in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_in_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_nof_global_in_lifs_get(
    int unit);

/**
 * \brief returns numeric data of nof_global_out_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_out_lifs'
 * Number of out global lifs in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_out_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_nof_global_out_lifs_get(
    int unit);

/**
 * \brief returns numeric data of nof_glem_lines
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_glem_lines'
 * Number of entries in the GLEM.                     This is the maximum number of egress global lifs in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_glem_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_nof_glem_lines_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_global_lif_table_nof
} dnx_data_lif_global_lif_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE IN_LIF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_in_lif_feature_get(
    int unit,
    dnx_data_lif_in_lif_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_lif_in_lif_define_inlif_index_bit_size,
    dnx_data_lif_in_lif_define_inlif_minimum_index_size,
    dnx_data_lif_in_lif_define_inlif_resource_tag_size,
    dnx_data_lif_in_lif_define_nof_in_lif_profiles,
    dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits,
    dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits,
    dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation,
    dnx_data_lif_in_lif_define_nof_eth_rif_profiles,
    dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles,
    dnx_data_lif_in_lif_define_default_da_not_found_destination_profile,
    dnx_data_lif_in_lif_define_drop_in_lif,
    dnx_data_lif_in_lif_define_nof_dpc_local_in_lifs,
    dnx_data_lif_in_lif_define_dpc_local_inlif_array_sw_size,
    dnx_data_lif_in_lif_define_dpc_local_inlif_hash_sw_size,
    dnx_data_lif_in_lif_define_nof_sbc_local_in_lifs,
    dnx_data_lif_in_lif_define_sbc_local_inlif_array_sw_size,
    dnx_data_lif_in_lif_define_sbc_local_inlif_hash_sw_size,
    dnx_data_lif_in_lif_define_all_local_inlifs_array_sw_size,
    dnx_data_lif_in_lif_define_all_local_inlif_hash_sw_size,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientaion,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode,

    /**
     * Must be last one!
     */
    _dnx_data_lif_in_lif_define_nof
} dnx_data_lif_in_lif_define_e;

/* Get Data */
/**
 * \brief returns define data of inlif_index_bit_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_index_bit_size'
 * This is the size of a single index in the inlif table. Divide the entry  bit size by this to get its size in indexes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_index_bit_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_inlif_index_bit_size_get(
    int unit);

/**
 * \brief returns define data of inlif_minimum_index_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_minimum_index_size'
 * The minimum size in indexes of an inlif entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_minimum_index_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_inlif_minimum_index_size_get(
    int unit);

/**
 * \brief returns define data of inlif_resource_tag_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_resource_tag_size'
 * The size of the inlif resource's n-packs. The packs are used to  prevent fragmentation by assigning each pack a fixed entry size. The pack should be  the least common denominator of every possible entry side. See the SDD for full description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_resource_tag_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_inlif_resource_tag_size_get(
    int unit);

/**
 * \brief returns define data of nof_in_lif_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_in_lif_profiles'
 * Number of possible in_lif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_in_lif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_in_lif_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_used_in_lif_profile_bits
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_used_in_lif_profile_bits'
 * Number of used in_lif_profile bits out of 8.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_used_in_lif_profile_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_get(
    int unit);

/**
 * \brief returns define data of nof_used_eth_rif_profile_bits
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_used_eth_rif_profile_bits'
 * Number of used eth_rif_profile bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_used_eth_rif_profile_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_get(
    int unit);

/**
 * \brief returns define data of nof_in_lif_incoming_orientation
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_in_lif_incoming_orientation'
 * Number of possible in_lif profile incoming orientation groups.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_in_lif_incoming_orientation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_get(
    int unit);

/**
 * \brief returns define data of nof_eth_rif_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_eth_rif_profiles'
 * Number of possible eth_rif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eth_rif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_eth_rif_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_da_not_found_destination_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_da_not_found_destination_profiles'
 * Number of da_not_found_destination profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_da_not_found_destination_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_get(
    int unit);

/**
 * \brief returns define data of default_da_not_found_destination_profile
 * Module - 'lif', Submodule - 'in_lif', data - 'default_da_not_found_destination_profile'
 * Default da_not_found_destination profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_da_not_found_destination_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_default_da_not_found_destination_profile_get(
    int unit);

/**
 * \brief returns define data of drop_in_lif
 * Module - 'lif', Submodule - 'in_lif', data - 'drop_in_lif'
 * local in_lif id performing trap with drop action.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     drop_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_drop_in_lif_get(
    int unit);

/**
 * \brief returns numeric data of nof_dpc_local_in_lifs
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_dpc_local_in_lifs'
 * Number of duplicate per core local inlifs in the device. This value is per core, so the overall number is twice that.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dpc_local_in_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_dpc_local_in_lifs_get(
    int unit);

/**
 * \brief returns numeric data of dpc_local_inlif_array_sw_size
 * Module - 'lif', Submodule - 'in_lif', data - 'dpc_local_inlif_array_sw_size'
 * Size of sw array needed for dpc local inlif. This value is for the whole system, and not just per core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dpc_local_inlif_array_sw_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_dpc_local_inlif_array_sw_size_get(
    int unit);

/**
 * \brief returns numeric data of dpc_local_inlif_hash_sw_size
 * Module - 'lif', Submodule - 'in_lif', data - 'dpc_local_inlif_hash_sw_size'
 * Size of sw hash table needed for dpc local inlif. This value is for the whole system, and not just per core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dpc_local_inlif_hash_sw_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_dpc_local_inlif_hash_sw_size_get(
    int unit);

/**
 * \brief returns numeric data of nof_sbc_local_in_lifs
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_sbc_local_in_lifs'
 * Number of shared by cores local inlifs in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_sbc_local_in_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_sbc_local_in_lifs_get(
    int unit);

/**
 * \brief returns numeric data of sbc_local_inlif_array_sw_size
 * Module - 'lif', Submodule - 'in_lif', data - 'sbc_local_inlif_array_sw_size'
 * Size of sw array needed for sbc local inlif.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbc_local_inlif_array_sw_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_sbc_local_inlif_array_sw_size_get(
    int unit);

/**
 * \brief returns numeric data of sbc_local_inlif_hash_sw_size
 * Module - 'lif', Submodule - 'in_lif', data - 'sbc_local_inlif_hash_sw_size'
 * Size of sw hash table needed for sbc local inlif.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbc_local_inlif_hash_sw_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_sbc_local_inlif_hash_sw_size_get(
    int unit);

/**
 * \brief returns numeric data of all_local_inlifs_array_sw_size
 * Module - 'lif', Submodule - 'in_lif', data - 'all_local_inlifs_array_sw_size'
 * Size of sw array needed for dpc + sbc local inlifs. This value is for the whole system, and not just per core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     all_local_inlifs_array_sw_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_all_local_inlifs_array_sw_size_get(
    int unit);

/**
 * \brief returns numeric data of all_local_inlif_hash_sw_size
 * Module - 'lif', Submodule - 'in_lif', data - 'all_local_inlif_hash_sw_size'
 * Size of sw hash table needed for dpc local inlif. This value is for the whole system, and not just per core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     all_local_inlif_hash_sw_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_all_local_inlif_hash_sw_size_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_orientaion
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_orientaion'
 * number of bits needed for egress property in_lif_orientation in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_orientaion - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_orientaion_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_policer_inner_dp
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_policer_inner_dp'
 * number of bits needed for egress property ive_inner_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_policer_inner_dp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_policer_outer_dp
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_policer_outer_dp'
 * number of bits needed for egress property ive_outer_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_policer_outer_dp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_same_interface_mode
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_same_interface_mode'
 * number of bits needed for egress property in_lif_profile_allocate_same_interface_mode in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_same_interface_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_in_lif_table_nof
} dnx_data_lif_in_lif_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE OUT_LIF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_out_lif_feature_get(
    int unit,
    dnx_data_lif_out_lif_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_lif_out_lif_define_nof_out_lif_profiles,
    dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation,
    dnx_data_lif_out_lif_define_outlif_pointer_size,
    dnx_data_lif_out_lif_define_local_outlif_width,
    dnx_data_lif_out_lif_define_outlif_profile_width,
    dnx_data_lif_out_lif_define_glem_result,
    dnx_data_lif_out_lif_define_nof_local_out_lifs,
    dnx_data_lif_out_lif_define_allocation_bank_size,
    dnx_data_lif_out_lif_define_physical_bank_pointer_size,
    dnx_data_lif_out_lif_define_physical_bank_size,

    /**
     * Must be last one!
     */
    _dnx_data_lif_out_lif_define_nof
} dnx_data_lif_out_lif_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_out_lif_profiles
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_out_lif_profiles'
 * Number of possible out_lif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_nof_out_lif_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_out_lif_outgoing_orientation
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_out_lif_outgoing_orientation'
 * Number of possible out_lif profile outgoing orientation groups.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_outgoing_orientation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_get(
    int unit);

/**
 * \brief returns define data of outlif_pointer_size
 * Module - 'lif', Submodule - 'out_lif', data - 'outlif_pointer_size'
 * The number of bits in the outlif pointer used in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_pointer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_outlif_pointer_size_get(
    int unit);

/**
 * \brief returns define data of local_outlif_width
 * Module - 'lif', Submodule - 'out_lif', data - 'local_outlif_width'
 * The number of bits in the local outlif from GLEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     local_outlif_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_local_outlif_width_get(
    int unit);

/**
 * \brief returns define data of outlif_profile_width
 * Module - 'lif', Submodule - 'out_lif', data - 'outlif_profile_width'
 * The number of bits in the outlif profile from GLEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_profile_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_outlif_profile_width_get(
    int unit);

/**
 * \brief returns define data of glem_result
 * Module - 'lif', Submodule - 'out_lif', data - 'glem_result'
 * The number of bits in GLEM result.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     glem_result - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_glem_result_get(
    int unit);

/**
 * \brief returns define data of nof_local_out_lifs
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_local_out_lifs'
 * Number of potential local outlifs in the device. Derived from the pointer size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_local_out_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_nof_local_out_lifs_get(
    int unit);

/**
 * \brief returns define data of allocation_bank_size
 * Module - 'lif', Submodule - 'out_lif', data - 'allocation_bank_size'
 * Size of the outlif bank used by the outlif allocation algorithm.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     allocation_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_allocation_bank_size_get(
    int unit);

/**
 * \brief returns define data of physical_bank_pointer_size
 * Module - 'lif', Submodule - 'out_lif', data - 'physical_bank_pointer_size'
 * How many bits from the outlif pointer are used to indicate the physical bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_bank_pointer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_physical_bank_pointer_size_get(
    int unit);

/**
 * \brief returns define data of physical_bank_size
 * Module - 'lif', Submodule - 'out_lif', data - 'physical_bank_size'
 * Size of the outlif bank used by the phase map and mags. Derived from the outlif pointer size  and the physical bank pointer size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_physical_bank_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_lif_out_lif_table_logical_to_physical_phase_map,

    /**
     * Must be last one!
     */
    _dnx_data_lif_out_lif_table_nof
} dnx_data_lif_out_lif_table_e;

/* Get Data */
/**
 * \brief get table logical_to_physical_phase_map entry 
 * Map outlif logical phase to physical phase.  The reverse mapping is implied from this.
 * 
 * \param [in] unit - unit #
 * \param [in] logical_phase - Logical phase to map.
 * 
 * \return
 *     logical_to_physical_phase_map - returns the relevant entry values grouped in struct - see dnx_data_lif_out_lif_logical_to_physical_phase_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_lif_out_lif_logical_to_physical_phase_map_t * dnx_data_lif_out_lif_logical_to_physical_phase_map_get(
    int unit,
    int logical_phase);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'lif', Submodule - 'out_lif', table - 'logical_to_physical_phase_map'
 * Map outlif logical phase to physical phase.  The reverse mapping is implied from this.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_lif_out_lif_logical_to_physical_phase_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)logical_to_physical_phase_map info
 * Map outlif logical phase to physical phase.  The reverse mapping is implied from this.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     logical_to_physical_phase_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_lif_out_lif_logical_to_physical_phase_map_info_get(
    int unit);

/*
 * SUBMODULE LIF_TABLE_MANAGER:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_lif_table_manager_feature_get(
    int unit,
    dnx_data_lif_lif_table_manager_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_lif_lif_table_manager_define_max_nof_lif_tables,
    dnx_data_lif_lif_table_manager_define_max_nof_result_types,
    dnx_data_lif_lif_table_manager_define_max_fields_per_result_type,

    /**
     * Must be last one!
     */
    _dnx_data_lif_lif_table_manager_define_nof
} dnx_data_lif_lif_table_manager_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_lif_tables
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_nof_lif_tables'
 * Maximal number of logical lif tables (inlif + outlif)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_lif_tables - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_lif_table_manager_max_nof_lif_tables_get(
    int unit);

/**
 * \brief returns define data of max_nof_result_types
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_nof_result_types'
 * Maximal number of result types in lif table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_result_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_lif_table_manager_max_nof_result_types_get(
    int unit);

/**
 * \brief returns define data of max_fields_per_result_type
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_fields_per_result_type'
 * Maximal number of fields for one result types in lif table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fields_per_result_type - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_lif_table_manager_max_fields_per_result_type_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_lif_table_manager_table_nof
} dnx_data_lif_lif_table_manager_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_lif_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_LIF_H_*/
/* *INDENT-ON* */
