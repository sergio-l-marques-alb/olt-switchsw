/** \file dnx_data_nif.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_NIF_H_
/*{*/
#define _DNX_DATA_NIF_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <bcm/port.h>
#include <soc/portmod/portmod.h>
#include <soc/dnxc/legacy/dnxc_port.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_nif.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_nif
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_nif_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GLOBAL:
 * global nif proprties and data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule global table pll_phys
 * Table info:
 * phys controlled by each lcpll
 */
typedef struct
{
    /**
     * The min phy ID controlled by given pll
     */
    uint32 min_phy_id;
    /**
     * The max phy ID controlled by given pll
     */
    uint32 max_phy_id;
} dnx_data_nif_global_pll_phys_t;

/**
 * \brief Holds values of submodule global table start_tx_threshold_table
 * Table info:
 * TX threshold table of values per speed
 */
typedef struct
{
    /**
     * Interface rate
     */
    uint32 speed;
    /**
     * Start TX threshold
     */
    uint32 start_thr;
} dnx_data_nif_global_start_tx_threshold_table_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_global_feature_nof
} dnx_data_nif_global_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_nif_global_feature_get_f) (
    int unit,
    dnx_data_nif_global_feature_e feature);

/**
 * \brief returns define data of nof_lcplls
 * Module - 'nif', Submodule - 'global', data - 'nof_lcplls'
 * number of lcplls supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lcplls - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_global_nof_lcplls_get_f) (
    int unit);

/**
 * \brief returns numeric data of start_tx_threshold_global
 * Module - 'nif', Submodule - 'global', data - 'start_tx_threshold_global'
 * Global start TX threshold. This value overrides TX threshold table values
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     start_tx_threshold_global - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_global_start_tx_threshold_global_get_f) (
    int unit);

/**
 * \brief get table pll_phys entry 
 * phys controlled by each lcpll
 * 
 * \param [in] unit - unit #
 * \param [in] lcpll - LCPLL index
 * 
 * \return
 *     pll_phys - returns the relevant entry values grouped in struct - see dnx_data_nif_global_pll_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_global_pll_phys_t *(
    *dnx_data_nif_global_pll_phys_get_f) (
    int unit,
    int lcpll);

/**
 * \brief get table start_tx_threshold_table entry 
 * TX threshold table of values per speed
 * 
 * \param [in] unit - unit #
 * \param [in] idx - Entry index
 * 
 * \return
 *     start_tx_threshold_table - returns the relevant entry values grouped in struct - see dnx_data_nif_global_start_tx_threshold_table_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_global_start_tx_threshold_table_t *(
    *dnx_data_nif_global_start_tx_threshold_table_get_f) (
    int unit,
    int idx);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_NIF - GLOBAL:
 * {
 */
/**
 * \brief Interface for nif global data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_nif_global_feature_get_f feature_get;
    /**
     * returns define data of nof_lcplls
     */
    dnx_data_nif_global_nof_lcplls_get_f nof_lcplls_get;
    /**
     * returns numeric data of start_tx_threshold_global
     */
    dnx_data_nif_global_start_tx_threshold_global_get_f start_tx_threshold_global_get;
    /**
     * get table pll_phys entry 
     */
    dnx_data_nif_global_pll_phys_get_f pll_phys_get;
    /**
     * get general info table about table (for example key size)pll_phys info
     */
    dnxc_data_table_info_get_f pll_phys_info_get;
    /**
     * get table start_tx_threshold_table entry 
     */
    dnx_data_nif_global_start_tx_threshold_table_get_f start_tx_threshold_table_get;
    /**
     * get general info table about table (for example key size)start_tx_threshold_table info
     */
    dnxc_data_table_info_get_f start_tx_threshold_table_info_get;
} dnx_data_if_nif_global_t;

/*
 * }
 */

/*
 * SUBMODULE  - PHYS:
 * data about phys
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule phys table general
 * Table info:
 * general data about phys
 */
typedef struct
{
    /**
     * bitmap of supported phys
     */
    bcm_pbmp_t supported_phys;
} dnx_data_nif_phys_general_t;

/**
 * \brief Holds values of submodule phys table polarity
 * Table info:
 * rx and tx polarity per lane
 */
typedef struct
{
    /**
     * switch TX phy polarity
     */
    uint32 tx_polarity;
    /**
     * switch RX phy polarity
     */
    uint32 rx_polarity;
} dnx_data_nif_phys_polarity_t;

/**
 * \brief Holds values of submodule phys table core_phys_map
 * Table info:
 * map pipeline core to connected PHYs
 */
typedef struct
{
    /**
     * phys connected to the CORE.
     */
    bcm_pbmp_t phys;
} dnx_data_nif_phys_core_phys_map_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_phys_feature_nof
} dnx_data_nif_phys_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_nif_phys_feature_get_f) (
    int unit,
    dnx_data_nif_phys_feature_e feature);

/**
 * \brief returns define data of nof_phys
 * Module - 'nif', Submodule - 'phys', data - 'nof_phys'
 * number of phys supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_phys_nof_phys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_phys_per_core
 * Module - 'nif', Submodule - 'phys', data - 'nof_phys_per_core'
 * number of phys per core supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_phys_per_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_phys_nof_phys_per_core_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pms
 * Module - 'nif', Submodule - 'phys', data - 'nof_pms'
 * number of PMs supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_phys_nof_pms_get_f) (
    int unit);

/**
 * \brief returns define data of vco_div
 * Module - 'nif', Submodule - 'phys', data - 'vco_div'
 * VCO divider
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vco_div - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_phys_vco_div_get_f) (
    int unit);

/**
 * \brief get table general entry 
 * general data about phys
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     general - returns the relevant entry values grouped in struct - see dnx_data_nif_phys_general_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_phys_general_t *(
    *dnx_data_nif_phys_general_get_f) (
    int unit);

/**
 * \brief get table polarity entry 
 * rx and tx polarity per lane
 * 
 * \param [in] unit - unit #
 * \param [in] lane_index - lane index (0-based)
 * 
 * \return
 *     polarity - returns the relevant entry values grouped in struct - see dnx_data_nif_phys_polarity_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_phys_polarity_t *(
    *dnx_data_nif_phys_polarity_get_f) (
    int unit,
    int lane_index);

/**
 * \brief get table core_phys_map entry 
 * map pipeline core to connected PHYs
 * 
 * \param [in] unit - unit #
 * \param [in] core_index - Core number.
 * 
 * \return
 *     core_phys_map - returns the relevant entry values grouped in struct - see dnx_data_nif_phys_core_phys_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_phys_core_phys_map_t *(
    *dnx_data_nif_phys_core_phys_map_get_f) (
    int unit,
    int core_index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_NIF - PHYS:
 * {
 */
/**
 * \brief Interface for nif phys data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_nif_phys_feature_get_f feature_get;
    /**
     * returns define data of nof_phys
     */
    dnx_data_nif_phys_nof_phys_get_f nof_phys_get;
    /**
     * returns define data of nof_phys_per_core
     */
    dnx_data_nif_phys_nof_phys_per_core_get_f nof_phys_per_core_get;
    /**
     * returns define data of nof_pms
     */
    dnx_data_nif_phys_nof_pms_get_f nof_pms_get;
    /**
     * returns define data of vco_div
     */
    dnx_data_nif_phys_vco_div_get_f vco_div_get;
    /**
     * get table general entry 
     */
    dnx_data_nif_phys_general_get_f general_get;
    /**
     * get general info table about table (for example key size)general info
     */
    dnxc_data_table_info_get_f general_info_get;
    /**
     * get table polarity entry 
     */
    dnx_data_nif_phys_polarity_get_f polarity_get;
    /**
     * get general info table about table (for example key size)polarity info
     */
    dnxc_data_table_info_get_f polarity_info_get;
    /**
     * get table core_phys_map entry 
     */
    dnx_data_nif_phys_core_phys_map_get_f core_phys_map_get;
    /**
     * get general info table about table (for example key size)core_phys_map info
     */
    dnxc_data_table_info_get_f core_phys_map_info_get;
} dnx_data_if_nif_phys_t;

/*
 * }
 */

/*
 * SUBMODULE  - ILKN:
 * data about ILKN ports
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule ilkn table phys
 * Table info:
 * phys bitmap for ports added by soc property
 */
typedef struct
{
    /**
     * phys connected to the ILKN id.
     */
    bcm_pbmp_t bitmap;
} dnx_data_nif_ilkn_phys_t;

/**
 * \brief Holds values of submodule ilkn table supported_phys
 * Table info:
 * supported phys per ILKN id
 */
typedef struct
{
    /**
     * is ILKN id supported on the device.
     */
    uint32 is_supported;
    /**
     * Max supported phys for the ILKN id.
     */
    uint32 max_phys;
    /**
     * NIF phys supported by the ILKN id.
     */
    bcm_pbmp_t nif_phys;
    /**
     * Fabric phys supported by the ILKN id. if the ILKN unit is not connected to fabric lanes, this value should be 0.
     */
    bcm_pbmp_t fabric_phys;
} dnx_data_nif_ilkn_supported_phys_t;

/**
 * \brief Holds values of submodule ilkn table supported_core
 * Table info:
 * supported device core per ILKN id
 */
typedef struct
{
    /**
     * Core id of which ILKN id is associated.
     */
    int core;
} dnx_data_nif_ilkn_supported_core_t;

/**
 * \brief Holds values of submodule ilkn table properties
 * Table info:
 * ILKN properties per ILKN id - added using soc property.
 */
typedef struct
{
    /**
     * ILKN burst short value. Sets the smallest burst size for the ILKN port. Shorter bursts will be padded with idles
     */
    uint32 burst_short;
    /**
     * ILKN burst Max value. Set the max burst size for the ILKN port.
     */
    uint32 burst_max;
    /**
     * ILKN burst min value. BurstMin should be bigger or equal to BurstShort and less or equal to BurstMax/2. This value is used to optimize the usage of the interface.
     */
    uint32 burst_min;
    /**
     * Specify the interval (in words) between meta-frame sync words. supported values: 64-16K.
     */
    uint32 metaframe_period;
    /**
     * ILKN over fabric indication. Specify the ILKN port is using Fabric lanes instead of NIF phys.
     */
    uint32 is_over_fabric;
} dnx_data_nif_ilkn_properties_t;

/**
 * \brief Holds values of submodule ilkn table nif_pms
 * Table info:
 * ILKN PM table over NIF
 */
typedef struct
{
    /**
     * PM dispatch type in Portmod
     */
    portmod_dispatch_type_t dispatch_type;
    /**
     * PM first phy
     */
    uint32 first_phy;
} dnx_data_nif_ilkn_nif_pms_t;

/**
 * \brief Holds values of submodule ilkn table fabric_pms
 * Table info:
 * ILKN PM table over Fabric
 */
typedef struct
{
    /**
     * PM dispatch type in Portmod
     */
    portmod_dispatch_type_t dispatch_type;
    /**
     * PM first phy
     */
    uint32 first_phy;
} dnx_data_nif_ilkn_fabric_pms_t;

/**
 * \brief Holds values of submodule ilkn table ilkn_pms
 * Table info:
 * ILKN PM table per ILKN id
 */
typedef struct
{
    /**
     * ILKN connected PMs on NIF side
     */
    uint32 nif_pm_ids[DNX_DATA_MAX_NIF_ILKN_PMS_NOF];
    /**
     * ILKN connected PMs on Fabric side
     */
    uint32 fabric_pm_ids[DNX_DATA_MAX_NIF_ILKN_PMS_NOF];
} dnx_data_nif_ilkn_ilkn_pms_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * is device type support ILKN.
     */
    dnx_data_nif_ilkn_is_supported,

    /**
     * Must be last one!
     */
    _dnx_data_nif_ilkn_feature_nof
} dnx_data_nif_ilkn_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_nif_ilkn_feature_get_f) (
    int unit,
    dnx_data_nif_ilkn_feature_e feature);

/**
 * \brief returns define data of ilkn_unit_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_unit_nof'
 * Number of ILKN units in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_unit_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_ilkn_unit_nof_get_f) (
    int unit);

/**
 * \brief returns define data of ilkn_unit_if_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_unit_if_nof'
 * Number of ILKN Interfaces in each ILKN unit
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_unit_if_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_ilkn_unit_if_nof_get_f) (
    int unit);

/**
 * \brief returns define data of ilkn_if_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_if_nof'
 * Number of ILKN Interfaces in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_if_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_ilkn_if_nof_get_f) (
    int unit);

/**
 * \brief returns define data of lanes_max_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'lanes_max_nof'
 * Max number of lanes for ILKN port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lanes_max_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_lanes_max_nof_get_f) (
    int unit);

/**
 * \brief returns define data of lanes_allowed_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'lanes_allowed_nof'
 * The allowed lanes for each ILKN port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lanes_allowed_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_lanes_allowed_nof_get_f) (
    int unit);

/**
 * \brief returns define data of ilkn_over_eth_pms_max
 * Module - 'nif', Submodule - 'ilkn', data - 'ilkn_over_eth_pms_max'
 * Max number eth pms ilkn lanes is part of
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ilkn_over_eth_pms_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_ilkn_over_eth_pms_max_get_f) (
    int unit);

/**
 * \brief returns define data of segments_max_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'segments_max_nof'
 * Max number of segments in ILKN protocol. (Segment is a resource of ILKN which is shared between all ports of the ILKN unit)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     segments_max_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_segments_max_nof_get_f) (
    int unit);

/**
 * \brief returns define data of watermark_high
 * Module - 'nif', Submodule - 'ilkn', data - 'watermark_high'
 * High Watermark value for ILKN
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     watermark_high - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_watermark_high_get_f) (
    int unit);

/**
 * \brief returns define data of watermark_low
 * Module - 'nif', Submodule - 'ilkn', data - 'watermark_low'
 * Low Watermark value for ILKN
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     watermark_low - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_watermark_low_get_f) (
    int unit);

/**
 * \brief returns define data of pms_nof
 * Module - 'nif', Submodule - 'ilkn', data - 'pms_nof'
 * Number of PMs connectted to the ILKN unit
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pms_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_pms_nof_get_f) (
    int unit);

/**
 * \brief returns define data of fmac_bus_size
 * Module - 'nif', Submodule - 'ilkn', data - 'fmac_bus_size'
 * Fabric MAC bus size [bits], relevant for ILKN over fabric ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_bus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_ilkn_fmac_bus_size_get_f) (
    int unit);

/**
 * \brief get table phys entry 
 * phys bitmap for ports added by soc property
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     phys - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_ilkn_phys_t *(
    *dnx_data_nif_ilkn_phys_get_f) (
    int unit,
    int ilkn_id);

/**
 * \brief get table supported_phys entry 
 * supported phys per ILKN id
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     supported_phys - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_supported_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_ilkn_supported_phys_t *(
    *dnx_data_nif_ilkn_supported_phys_get_f) (
    int unit,
    int ilkn_id);

/**
 * \brief get table supported_core entry 
 * supported device core per ILKN id
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     supported_core - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_supported_core_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_ilkn_supported_core_t *(
    *dnx_data_nif_ilkn_supported_core_get_f) (
    int unit,
    int ilkn_id);

/**
 * \brief get table properties entry 
 * ILKN properties per ILKN id - added using soc property.
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     properties - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_ilkn_properties_t *(
    *dnx_data_nif_ilkn_properties_get_f) (
    int unit,
    int ilkn_id);

/**
 * \brief get table nif_pms entry 
 * ILKN PM table over NIF
 * 
 * \param [in] unit - unit #
 * \param [in] pm_id - Port Macro identifier
 * 
 * \return
 *     nif_pms - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_nif_pms_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_ilkn_nif_pms_t *(
    *dnx_data_nif_ilkn_nif_pms_get_f) (
    int unit,
    int pm_id);

/**
 * \brief get table fabric_pms entry 
 * ILKN PM table over Fabric
 * 
 * \param [in] unit - unit #
 * \param [in] pm_id - Port Macro identifier
 * 
 * \return
 *     fabric_pms - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_fabric_pms_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_ilkn_fabric_pms_t *(
    *dnx_data_nif_ilkn_fabric_pms_get_f) (
    int unit,
    int pm_id);

/**
 * \brief get table ilkn_pms entry 
 * ILKN PM table per ILKN id
 * 
 * \param [in] unit - unit #
 * \param [in] ilkn_id - ilkn if id
 * 
 * \return
 *     ilkn_pms - returns the relevant entry values grouped in struct - see dnx_data_nif_ilkn_ilkn_pms_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_ilkn_ilkn_pms_t *(
    *dnx_data_nif_ilkn_ilkn_pms_get_f) (
    int unit,
    int ilkn_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_NIF - ILKN:
 * {
 */
/**
 * \brief Interface for nif ilkn data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_nif_ilkn_feature_get_f feature_get;
    /**
     * returns define data of ilkn_unit_nof
     */
    dnx_data_nif_ilkn_ilkn_unit_nof_get_f ilkn_unit_nof_get;
    /**
     * returns define data of ilkn_unit_if_nof
     */
    dnx_data_nif_ilkn_ilkn_unit_if_nof_get_f ilkn_unit_if_nof_get;
    /**
     * returns define data of ilkn_if_nof
     */
    dnx_data_nif_ilkn_ilkn_if_nof_get_f ilkn_if_nof_get;
    /**
     * returns define data of lanes_max_nof
     */
    dnx_data_nif_ilkn_lanes_max_nof_get_f lanes_max_nof_get;
    /**
     * returns define data of lanes_allowed_nof
     */
    dnx_data_nif_ilkn_lanes_allowed_nof_get_f lanes_allowed_nof_get;
    /**
     * returns define data of ilkn_over_eth_pms_max
     */
    dnx_data_nif_ilkn_ilkn_over_eth_pms_max_get_f ilkn_over_eth_pms_max_get;
    /**
     * returns define data of segments_max_nof
     */
    dnx_data_nif_ilkn_segments_max_nof_get_f segments_max_nof_get;
    /**
     * returns define data of watermark_high
     */
    dnx_data_nif_ilkn_watermark_high_get_f watermark_high_get;
    /**
     * returns define data of watermark_low
     */
    dnx_data_nif_ilkn_watermark_low_get_f watermark_low_get;
    /**
     * returns define data of pms_nof
     */
    dnx_data_nif_ilkn_pms_nof_get_f pms_nof_get;
    /**
     * returns define data of fmac_bus_size
     */
    dnx_data_nif_ilkn_fmac_bus_size_get_f fmac_bus_size_get;
    /**
     * get table phys entry 
     */
    dnx_data_nif_ilkn_phys_get_f phys_get;
    /**
     * get general info table about table (for example key size)phys info
     */
    dnxc_data_table_info_get_f phys_info_get;
    /**
     * get table supported_phys entry 
     */
    dnx_data_nif_ilkn_supported_phys_get_f supported_phys_get;
    /**
     * get general info table about table (for example key size)supported_phys info
     */
    dnxc_data_table_info_get_f supported_phys_info_get;
    /**
     * get table supported_core entry 
     */
    dnx_data_nif_ilkn_supported_core_get_f supported_core_get;
    /**
     * get general info table about table (for example key size)supported_core info
     */
    dnxc_data_table_info_get_f supported_core_info_get;
    /**
     * get table properties entry 
     */
    dnx_data_nif_ilkn_properties_get_f properties_get;
    /**
     * get general info table about table (for example key size)properties info
     */
    dnxc_data_table_info_get_f properties_info_get;
    /**
     * get table nif_pms entry 
     */
    dnx_data_nif_ilkn_nif_pms_get_f nif_pms_get;
    /**
     * get general info table about table (for example key size)nif_pms info
     */
    dnxc_data_table_info_get_f nif_pms_info_get;
    /**
     * get table fabric_pms entry 
     */
    dnx_data_nif_ilkn_fabric_pms_get_f fabric_pms_get;
    /**
     * get general info table about table (for example key size)fabric_pms info
     */
    dnxc_data_table_info_get_f fabric_pms_info_get;
    /**
     * get table ilkn_pms entry 
     */
    dnx_data_nif_ilkn_ilkn_pms_get_f ilkn_pms_get;
    /**
     * get general info table about table (for example key size)ilkn_pms info
     */
    dnxc_data_table_info_get_f ilkn_pms_info_get;
} dnx_data_if_nif_ilkn_t;

/*
 * }
 */

/*
 * SUBMODULE  - ETH:
 * data about Ethernet ports
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule eth table pm_properties
 * Table info:
 * PM properties per PM
 */
typedef struct
{
    /**
     * phys connected to the PM.
     */
    bcm_pbmp_t phys;
    /**
     * PM TVCO PLL index.
     */
    int tvco_pll_index;
} dnx_data_nif_eth_pm_properties_t;

/**
 * \brief Holds values of submodule eth table cdu_pm_map
 * Table info:
 * map cdu to PM instance
 */
typedef struct
{
    /**
     * array of pms in each cdu.
     */
    int pms[DNX_DATA_MAX_NIF_ETH_CDU_PMS_NOF];
} dnx_data_nif_eth_cdu_pm_map_t;

/**
 * \brief Holds values of submodule eth table max_speed
 * Table info:
 * Max speed for each ethernet interface type.
 */
typedef struct
{
    /**
     * Max speed value.
     */
    int speed;
} dnx_data_nif_eth_max_speed_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_eth_feature_nof
} dnx_data_nif_eth_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_nif_eth_feature_get_f) (
    int unit,
    dnx_data_nif_eth_feature_e feature);

/**
 * \brief returns define data of cdu_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_nof'
 * Number of CDU instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_cdu_nof_get_f) (
    int unit);

/**
 * \brief returns define data of cdum_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdum_nof'
 * Number of CDUM instances in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdum_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_cdum_nof_get_f) (
    int unit);

/**
 * \brief returns define data of cdu_pms_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_pms_nof'
 * Number of pms in each CDU in the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_pms_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_cdu_pms_nof_get_f) (
    int unit);

/**
 * \brief returns define data of cdu_nof_per_core
 * Module - 'nif', Submodule - 'eth', data - 'cdu_nof_per_core'
 * Number of CDU instances in each device core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_nof_per_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_cdu_nof_per_core_get_f) (
    int unit);

/**
 * \brief returns define data of cdu_lanes_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_lanes_nof'
 * Number of lanes in each CDU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_lanes_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_cdu_lanes_nof_get_f) (
    int unit);

/**
 * \brief returns define data of cdu_mac_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_mac_nof'
 * Number of MAC units per CDU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_mac_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_cdu_mac_nof_get_f) (
    int unit);

/**
 * \brief returns define data of mac_lanes_nof
 * Module - 'nif', Submodule - 'eth', data - 'mac_lanes_nof'
 * Number of lanes in each MAC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_lanes_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_mac_lanes_nof_get_f) (
    int unit);

/**
 * \brief returns define data of cdu_logical_fifo_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_logical_fifo_nof'
 * number of logical fifos in the CDU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_logical_fifo_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_cdu_logical_fifo_nof_get_f) (
    int unit);

/**
 * \brief returns define data of cdu_memory_entries_nof
 * Module - 'nif', Submodule - 'eth', data - 'cdu_memory_entries_nof'
 * number of entries in the CDU memory, to be shared between all logical FIFOs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdu_memory_entries_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_cdu_memory_entries_nof_get_f) (
    int unit);

/**
 * \brief returns define data of priority_group_nof_entries_min
 * Module - 'nif', Submodule - 'eth', data - 'priority_group_nof_entries_min'
 * minimum number of entries to allocate to a priority group (priority group = RMC)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     priority_group_nof_entries_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_priority_group_nof_entries_min_get_f) (
    int unit);

/**
 * \brief returns define data of priority_groups_nof
 * Module - 'nif', Submodule - 'eth', data - 'priority_groups_nof'
 * number of allowed priority groups per port (priority group = RMC)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     priority_groups_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_priority_groups_nof_get_f) (
    int unit);

/**
 * \brief returns define data of pad_size_min
 * Module - 'nif', Submodule - 'eth', data - 'pad_size_min'
 * min padding size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pad_size_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_pad_size_min_get_f) (
    int unit);

/**
 * \brief returns define data of pad_size_max
 * Module - 'nif', Submodule - 'eth', data - 'pad_size_max'
 * max padding size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pad_size_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_pad_size_max_get_f) (
    int unit);

/**
 * \brief returns define data of packet_size_max
 * Module - 'nif', Submodule - 'eth', data - 'packet_size_max'
 * max packet size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     packet_size_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_packet_size_max_get_f) (
    int unit);

/**
 * \brief returns define data of an_max_nof_abilities
 * Module - 'nif', Submodule - 'eth', data - 'an_max_nof_abilities'
 * max auto-negotiation abilities
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     an_max_nof_abilities - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_eth_an_max_nof_abilities_get_f) (
    int unit);

/**
 * \brief get table pm_properties entry 
 * PM properties per PM
 * 
 * \param [in] unit - unit #
 * \param [in] pm_index - PM instance number.
 * 
 * \return
 *     pm_properties - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_pm_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_eth_pm_properties_t *(
    *dnx_data_nif_eth_pm_properties_get_f) (
    int unit,
    int pm_index);

/**
 * \brief get table cdu_pm_map entry 
 * map cdu to PM instance
 * 
 * \param [in] unit - unit #
 * \param [in] cdu_index - cdu instance number.
 * 
 * \return
 *     cdu_pm_map - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_cdu_pm_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_eth_cdu_pm_map_t *(
    *dnx_data_nif_eth_cdu_pm_map_get_f) (
    int unit,
    int cdu_index);

/**
 * \brief get table max_speed entry 
 * Max speed for each ethernet interface type.
 * 
 * \param [in] unit - unit #
 * \param [in] lane_num - number of lanes for the given interface type.
 * 
 * \return
 *     max_speed - returns the relevant entry values grouped in struct - see dnx_data_nif_eth_max_speed_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_eth_max_speed_t *(
    *dnx_data_nif_eth_max_speed_get_f) (
    int unit,
    int lane_num);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_NIF - ETH:
 * {
 */
/**
 * \brief Interface for nif eth data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_nif_eth_feature_get_f feature_get;
    /**
     * returns define data of cdu_nof
     */
    dnx_data_nif_eth_cdu_nof_get_f cdu_nof_get;
    /**
     * returns define data of cdum_nof
     */
    dnx_data_nif_eth_cdum_nof_get_f cdum_nof_get;
    /**
     * returns define data of cdu_pms_nof
     */
    dnx_data_nif_eth_cdu_pms_nof_get_f cdu_pms_nof_get;
    /**
     * returns define data of cdu_nof_per_core
     */
    dnx_data_nif_eth_cdu_nof_per_core_get_f cdu_nof_per_core_get;
    /**
     * returns define data of cdu_lanes_nof
     */
    dnx_data_nif_eth_cdu_lanes_nof_get_f cdu_lanes_nof_get;
    /**
     * returns define data of cdu_mac_nof
     */
    dnx_data_nif_eth_cdu_mac_nof_get_f cdu_mac_nof_get;
    /**
     * returns define data of mac_lanes_nof
     */
    dnx_data_nif_eth_mac_lanes_nof_get_f mac_lanes_nof_get;
    /**
     * returns define data of cdu_logical_fifo_nof
     */
    dnx_data_nif_eth_cdu_logical_fifo_nof_get_f cdu_logical_fifo_nof_get;
    /**
     * returns define data of cdu_memory_entries_nof
     */
    dnx_data_nif_eth_cdu_memory_entries_nof_get_f cdu_memory_entries_nof_get;
    /**
     * returns define data of priority_group_nof_entries_min
     */
    dnx_data_nif_eth_priority_group_nof_entries_min_get_f priority_group_nof_entries_min_get;
    /**
     * returns define data of priority_groups_nof
     */
    dnx_data_nif_eth_priority_groups_nof_get_f priority_groups_nof_get;
    /**
     * returns define data of pad_size_min
     */
    dnx_data_nif_eth_pad_size_min_get_f pad_size_min_get;
    /**
     * returns define data of pad_size_max
     */
    dnx_data_nif_eth_pad_size_max_get_f pad_size_max_get;
    /**
     * returns define data of packet_size_max
     */
    dnx_data_nif_eth_packet_size_max_get_f packet_size_max_get;
    /**
     * returns define data of an_max_nof_abilities
     */
    dnx_data_nif_eth_an_max_nof_abilities_get_f an_max_nof_abilities_get;
    /**
     * get table pm_properties entry 
     */
    dnx_data_nif_eth_pm_properties_get_f pm_properties_get;
    /**
     * get general info table about table (for example key size)pm_properties info
     */
    dnxc_data_table_info_get_f pm_properties_info_get;
    /**
     * get table cdu_pm_map entry 
     */
    dnx_data_nif_eth_cdu_pm_map_get_f cdu_pm_map_get;
    /**
     * get general info table about table (for example key size)cdu_pm_map info
     */
    dnxc_data_table_info_get_f cdu_pm_map_info_get;
    /**
     * get table max_speed entry 
     */
    dnx_data_nif_eth_max_speed_get_f max_speed_get;
    /**
     * get general info table about table (for example key size)max_speed info
     */
    dnxc_data_table_info_get_f max_speed_info_get;
} dnx_data_if_nif_eth_t;

/*
 * }
 */

/*
 * SUBMODULE  - PRD:
 * Priority Drop module
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule prd table ether_type
 * Table info:
 * Ether type codes and sizes for fixed ether types.
 */
typedef struct
{
    /**
     * the name of the Ether type.
     */
    char *ether_type_name;
    /**
     * the size in bytes of the ether type header.
     */
    uint32 ether_type_size;
} dnx_data_nif_prd_ether_type_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_prd_feature_nof
} dnx_data_nif_prd_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_nif_prd_feature_get_f) (
    int unit,
    dnx_data_nif_prd_feature_e feature);

/**
 * \brief returns define data of nof_control_frames
 * Module - 'nif', Submodule - 'prd', data - 'nof_control_frames'
 * Number of control frame properties to which each packet is compared in order to be recognized as control frame in the PRD parser
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_control_frames - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_prd_nof_control_frames_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ether_type_codes
 * Module - 'nif', Submodule - 'prd', data - 'nof_ether_type_codes'
 * Number of ether types supported by the PRD Parser
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ether_type_codes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_prd_nof_ether_type_codes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tcam_entries
 * Module - 'nif', Submodule - 'prd', data - 'nof_tcam_entries'
 * Number of entries in PRD Parser soft stage TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_prd_nof_tcam_entries_get_f) (
    int unit);

/**
 * \brief returns define data of nof_mpls_special_labels
 * Module - 'nif', Submodule - 'prd', data - 'nof_mpls_special_labels'
 * Number of MPLS special labels recognized by the PRD parser
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mpls_special_labels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_prd_nof_mpls_special_labels_get_f) (
    int unit);

/**
 * \brief returns define data of nof_priorities
 * Module - 'nif', Submodule - 'prd', data - 'nof_priorities'
 * Number of PRD Priorities
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_priorities - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_prd_nof_priorities_get_f) (
    int unit);

/**
 * \brief returns define data of custom_ether_type_code_min
 * Module - 'nif', Submodule - 'prd', data - 'custom_ether_type_code_min'
 * Min value of the configurable ether type codes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     custom_ether_type_code_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_prd_custom_ether_type_code_min_get_f) (
    int unit);

/**
 * \brief returns define data of custom_ether_type_code_max
 * Module - 'nif', Submodule - 'prd', data - 'custom_ether_type_code_max'
 * Max value of the configurable ether type codes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     custom_ether_type_code_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_prd_custom_ether_type_code_max_get_f) (
    int unit);

/**
 * \brief get table ether_type entry 
 * Ether type codes and sizes for fixed ether types.
 * 
 * \param [in] unit - unit #
 * \param [in] ether_type_code - Ether type code in PRD parser
 * 
 * \return
 *     ether_type - returns the relevant entry values grouped in struct - see dnx_data_nif_prd_ether_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_prd_ether_type_t *(
    *dnx_data_nif_prd_ether_type_get_f) (
    int unit,
    int ether_type_code);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_NIF - PRD:
 * {
 */
/**
 * \brief Interface for nif prd data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_nif_prd_feature_get_f feature_get;
    /**
     * returns define data of nof_control_frames
     */
    dnx_data_nif_prd_nof_control_frames_get_f nof_control_frames_get;
    /**
     * returns define data of nof_ether_type_codes
     */
    dnx_data_nif_prd_nof_ether_type_codes_get_f nof_ether_type_codes_get;
    /**
     * returns define data of nof_tcam_entries
     */
    dnx_data_nif_prd_nof_tcam_entries_get_f nof_tcam_entries_get;
    /**
     * returns define data of nof_mpls_special_labels
     */
    dnx_data_nif_prd_nof_mpls_special_labels_get_f nof_mpls_special_labels_get;
    /**
     * returns define data of nof_priorities
     */
    dnx_data_nif_prd_nof_priorities_get_f nof_priorities_get;
    /**
     * returns define data of custom_ether_type_code_min
     */
    dnx_data_nif_prd_custom_ether_type_code_min_get_f custom_ether_type_code_min_get;
    /**
     * returns define data of custom_ether_type_code_max
     */
    dnx_data_nif_prd_custom_ether_type_code_max_get_f custom_ether_type_code_max_get;
    /**
     * get table ether_type entry 
     */
    dnx_data_nif_prd_ether_type_get_f ether_type_get;
    /**
     * get general info table about table (for example key size)ether_type info
     */
    dnxc_data_table_info_get_f ether_type_info_get;
} dnx_data_if_nif_prd_t;

/*
 * }
 */

/*
 * SUBMODULE  - PORTMOD:
 * information required for portmod.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule portmod table pm_types_and_interfaces
 * Table info:
 * fixed types and interfaces per device
 */
typedef struct
{
    /**
     * pm type
     */
    portmod_dispatch_type_t type;
    /**
     * the number of instances of the specified pm type
     */
    int instances;
} dnx_data_nif_portmod_pm_types_and_interfaces_t;

/**
 * \brief Holds values of submodule portmod table pm_supported_features
 * Table info:
 * supported features per Port Macro
 */
typedef struct
{
    /**
     * are PAM4 speeds supported on this PM (50G)
     */
    uint32 is_pam4_support;
    /**
     * is PM support 400G mode
     */
    uint32 is_400g_support;
    /**
     * is PM support 25G speed
     */
    uint32 is_25g_support;
} dnx_data_nif_portmod_pm_supported_features_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_portmod_feature_nof
} dnx_data_nif_portmod_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_nif_portmod_feature_get_f) (
    int unit,
    dnx_data_nif_portmod_feature_e feature);

/**
 * \brief returns define data of pm_types_nof
 * Module - 'nif', Submodule - 'portmod', data - 'pm_types_nof'
 * Number of pm types
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pm_types_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_portmod_pm_types_nof_get_f) (
    int unit);

/**
 * \brief get table pm_types_and_interfaces entry 
 * fixed types and interfaces per device
 * 
 * \param [in] unit - unit #
 * \param [in] index - pm type index
 * 
 * \return
 *     pm_types_and_interfaces - returns the relevant entry values grouped in struct - see dnx_data_nif_portmod_pm_types_and_interfaces_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_portmod_pm_types_and_interfaces_t *(
    *dnx_data_nif_portmod_pm_types_and_interfaces_get_f) (
    int unit,
    int index);

/**
 * \brief get table pm_supported_features entry 
 * supported features per Port Macro
 * 
 * \param [in] unit - unit #
 * \param [in] pm_index - port macro index in the device
 * 
 * \return
 *     pm_supported_features - returns the relevant entry values grouped in struct - see dnx_data_nif_portmod_pm_supported_features_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_nif_portmod_pm_supported_features_t *(
    *dnx_data_nif_portmod_pm_supported_features_get_f) (
    int unit,
    int pm_index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_NIF - PORTMOD:
 * {
 */
/**
 * \brief Interface for nif portmod data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_nif_portmod_feature_get_f feature_get;
    /**
     * returns define data of pm_types_nof
     */
    dnx_data_nif_portmod_pm_types_nof_get_f pm_types_nof_get;
    /**
     * get table pm_types_and_interfaces entry 
     */
    dnx_data_nif_portmod_pm_types_and_interfaces_get_f pm_types_and_interfaces_get;
    /**
     * get general info table about table (for example key size)pm_types_and_interfaces info
     */
    dnxc_data_table_info_get_f pm_types_and_interfaces_info_get;
    /**
     * get table pm_supported_features entry 
     */
    dnx_data_nif_portmod_pm_supported_features_get_f pm_supported_features_get;
    /**
     * get general info table about table (for example key size)pm_supported_features info
     */
    dnxc_data_table_info_get_f pm_supported_features_info_get;
} dnx_data_if_nif_portmod_t;

/*
 * }
 */

/*
 * SUBMODULE  - SCHEDULDER:
 * data about NIF schedulder
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_nif_schedulder_feature_nof
} dnx_data_nif_schedulder_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_nif_schedulder_feature_get_f) (
    int unit,
    dnx_data_nif_schedulder_feature_e feature);

/**
 * \brief returns define data of rate_per_cdu_bit
 * Module - 'nif', Submodule - 'schedulder', data - 'rate_per_cdu_bit'
 * The Rate equivalent to 1 bit of CDU scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate_per_cdu_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_schedulder_rate_per_cdu_bit_get_f) (
    int unit);

/**
 * \brief returns define data of rate_per_rmc_bit
 * Module - 'nif', Submodule - 'schedulder', data - 'rate_per_rmc_bit'
 * The Rate equivalent to 1 bit of RMC scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate_per_rmc_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_schedulder_rate_per_rmc_bit_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cdu_bits
 * Module - 'nif', Submodule - 'schedulder', data - 'nof_cdu_bits'
 * Number of bits in CDU scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cdu_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_schedulder_nof_cdu_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_rmc_bits
 * Module - 'nif', Submodule - 'schedulder', data - 'nof_rmc_bits'
 * Number of bits in RMC scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rmc_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_nif_schedulder_nof_rmc_bits_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_NIF - SCHEDULDER:
 * {
 */
/**
 * \brief Interface for nif schedulder data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_nif_schedulder_feature_get_f feature_get;
    /**
     * returns define data of rate_per_cdu_bit
     */
    dnx_data_nif_schedulder_rate_per_cdu_bit_get_f rate_per_cdu_bit_get;
    /**
     * returns define data of rate_per_rmc_bit
     */
    dnx_data_nif_schedulder_rate_per_rmc_bit_get_f rate_per_rmc_bit_get;
    /**
     * returns define data of nof_cdu_bits
     */
    dnx_data_nif_schedulder_nof_cdu_bits_get_f nof_cdu_bits_get;
    /**
     * returns define data of nof_rmc_bits
     */
    dnx_data_nif_schedulder_nof_rmc_bits_get_f nof_rmc_bits_get;
} dnx_data_if_nif_schedulder_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_NIF:
 * {
 */
/**
 * \brief Interface for nif data
 */
typedef struct
{
    /**
     * Interface for nif global data
     */
    dnx_data_if_nif_global_t global;
    /**
     * Interface for nif phys data
     */
    dnx_data_if_nif_phys_t phys;
    /**
     * Interface for nif ilkn data
     */
    dnx_data_if_nif_ilkn_t ilkn;
    /**
     * Interface for nif eth data
     */
    dnx_data_if_nif_eth_t eth;
    /**
     * Interface for nif prd data
     */
    dnx_data_if_nif_prd_t prd;
    /**
     * Interface for nif portmod data
     */
    dnx_data_if_nif_portmod_t portmod;
    /**
     * Interface for nif schedulder data
     */
    dnx_data_if_nif_schedulder_t schedulder;
} dnx_data_if_nif_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_nif_t dnx_data_nif;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_NIF_H_*/
/* *INDENT-ON* */
