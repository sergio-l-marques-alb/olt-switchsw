/** \file dnx/swstate/auto_generated/types/dnx_field_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */

#ifndef __DNX_FIELD_TYPES_H__
#define __DNX_FIELD_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <include/bcm/field.h>
#include <include/soc/dnx/dbal/auto_generated/dbal_defines_fields.h>
#include <include/soc/dnx/dbal/auto_generated/dbal_defines_tables.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_field.h>
/*
 * MACROs
 */

/**
 * Number of uint32 needed to hold bitmap for
 * maximum number of FFC's per pass
 */
#define DNX_FIELD_MAX_FFC_PER_PASS_IN_UINT32 (((DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_FFC+SAL_UINT32_NOF_BITS-1)/SAL_UINT32_NOF_BITS))

/**
 * Number of uint32 needed to hold bitmap for
 * maximum number of PMF programs between stages
 */
#define DNX_FIELD_MAX_NOF_PMF_PROGS_IN_UINT32 ((DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS+SAL_UINT32_NOF_BITS-1)/SAL_UINT32_NOF_BITS)

/**
 * Number of uint32 needed to hold bitmap for
 * maximum number of Preselection lines (CS table) between stages
 */
#define DNX_FIELD_MAX_NOF_PRESEL_ID_IN_UINT32 ((DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_PROGRAM_SELECTION_LINES+SAL_UINT32_NOF_BITS-1)/SAL_UINT32_NOF_BITS)

/**
 * Invalid key ID.
 */
#define DNX_FIELD_KEY_ID_INVALID -1

/**
 * Invalid FG ID.
 */
#define DNX_FIELD_GROUP_INVALID (dnx_field_group_t)(-1)

/**
 * Invalid Context ID.
 */
#define DNX_FIELD_CONTEXT_ID_INVALID (dnx_field_context_t)(-1)

/**
 * Invalid Qualifier ID, common for all stages.
 */
#define DNX_FIELD_QUAL_ID_INVALID 0

/**
 * Fiers Qualifier ID, common for all stages.
 */
#define DNX_FIELD_QUAL_ID_FIRST 1

/**
 * 'Invalid' indication for ACTION_ID field (e.g., in IPPC_FES_2ND_INSTRUCTION, ERPP_FES_2ND_INSTRUCTION, etc.).
 * This may not just be any value, it should be the size of 'action' field and above (or equal to)
 * DBAL_ENUM_FVAL_FIELD_PMF_A_ACTION_INVALID so that HW will relate to it as 'invalid'.
 */
#define DNX_FIELD_ACTION_ID_INVALID 127

/**
 * Position of action class inside dnx qualifier.
 */
#define DNX_ACTION_CLASS_SHIFT 24

/**
 * Position of field stage inside dnx action.
 */
#define DNX_ACTION_STAGE_SHIFT 16


#define DNX_ACTION(dnx_class, dnx_stage, dnx_index) ((dnx_class << DNX_ACTION_CLASS_SHIFT) | (dnx_stage << DNX_ACTION_STAGE_SHIFT) | (dnx_index))

/**
 * Invalid DNX action serving as undefined(or initial) value.
 */
#define DNX_FIELD_ACTION_INVALID DNX_ACTION(DNX_FIELD_ACTION_CLASS_INVALID, DNX_FIELD_STAGE_INVALID, DNX_FIELD_ACTION_ID_INVALID)

/**
 * Position of qualifier class inside dnx qualifier.
 */
#define DNX_QUAL_CLASS_SHIFT 24

/**
 * Position of dnx stage inside dnx qualifier.
 */
#define DNX_QUAL_STAGE_SHIFT 16

/**
 * \brief Generate DNX qualifier from id, class and stage
 * \param [in] dnx_class - DNX qualifier class (dnx_field_qual_class_e)
 * \param [in] dnx_stage  - FP Stage (dnx_field_stage_e)
 * \param [in] dnx_index  - dnx id per class
 * \return
 * \retval encode dnx qualifier
 */
#define DNX_QUAL(dnx_class, dnx_stage, dnx_index) ((dnx_class << DNX_QUAL_CLASS_SHIFT) | (dnx_stage << DNX_QUAL_STAGE_SHIFT) | (dnx_index))

/**
 * Invalid DNX qualifier serving as undefined(or initial) value.
 */
#define DNX_FIELD_QUAL_TYPE_INVALID DNX_QUAL(DNX_FIELD_QUAL_CLASS_INVALID, DNX_FIELD_STAGE_INVALID, DNX_FIELD_QUAL_ID_INVALID)

/**
 * Define for invalid bank ID, used as array termination.
 */
#define DNX_FIELD_TCAM_BANK_ID_INVALID (-1)

/**
 * Invalid tcam handler ID.
 */
#define DNX_FIELD_TCAM_HANDLER_ID_INVALID 0x1023

/**
 * Invalid presel ID.
 */
#define DNX_FIELD_PRESEL_ID_INVALID -1

/**
 * Invalid db ID.
 */
#define DNX_FIELD_DB_ID_INVALID -1

/**
 * Invalid ffc ID.
 */
#define DNX_FIELD_FFC_ID_INVALID -1

/**
 * Invalid entry access ID.
 */
#define DNX_FIELD_ENTRY_ACCESS_ID_INVALID -1

/**
 * Invalid tcam handler ID.
 */
#define DNX_FIELD_TCAM_HANDLER_INVALID -1

/**
 * Invalid range ID.
 */
#define DNX_FIELD_RANGE_ID_INVALID -1

/**
 * Invalid Tcam entry priority.
 */
#define DNX_FIELD_TCAM_ENTRY_PRIORITY_INVALID -1

/**
 * Invalid Tcam entry priority.
 */
#define DNX_FIELD_TCAM_ENTRY_PRIORITY_INVALID -1

/**
 * Invalid Tcam entry priority.
 */
#define DNX_FIELD_APP_DB_ID_INVALID ((dnx_field_app_db_id_t)(-1))

/**
 * Invalid indication for 'FEM id'. See, for example, dnx_field_fem_get_next_fg_owner()
 */
#define DNX_FIELD_FEM_ID_INVALID ((dnx_field_fem_id_t)(-1))

/**
 * Invalid app type.
 */
#define DNX_FIELD_APPTYPE_INVALID ((bcm_field_AppType_t)(-1))

/**
 * Invalid action priority.
 */
#define DNX_FIELD_ACTION_PRIORITY_INVALID (~(1 << BCM_FIELD_ACTION_VALID_OFFSET))

/*
 * TYPEDEFs
 */

/**
 * Context ID for Field module
 */
typedef uint32 dnx_field_context_t;

/**
 * Field group ID.
 */
typedef int dnx_field_group_t;

/**
 * Field presel ID.
 */
typedef int dnx_field_presel_t;

/**
 * Action priority for Field module.
 * Encpoded through macros in includ/bcm_int/dnx/field/field.h                                                                        Represents a numerical priority or a mandatory FES/FEM ID to be placed in (or else don't care).
 */
typedef uint32 dnx_field_action_priority_t;

/**
 * Non encoded numerical priority, part of dnx_field_action_priority_t.
 */
typedef uint16 dnx_field_action_numerical_priority_t;

/**
 * Position of FES/FEM (by FES/FEM ID) within the FES/FEM array.
 */
typedef uint16 dnx_field_action_position_t;

/**
 * Index of the FES/FEM array in the stage.
 */
typedef uint8 dnx_field_action_array_t;

/**
 * This is the type used for identifying a specific FES.
 * To avoid too-large arrays, use a space saving type (uint8 in place of uint32)
 */
typedef uint8 dnx_field_fes_id_t;

/**
 * This is the type used for identifying a specific FES program.
 * This is program id that determines the FES_2ndInstruction (For example, for PMF-A, there are 32 such entries)
 * To avoid too-large arrays, use a space saving type (uint8 in place of uint32)
 */
typedef uint8 dnx_field_fes_pgm_id_t;

/**
 * This is the type used for identifying a specific FES action mask.
 * To avoid too-large arrays, use a space saving type (uint8 in place of uint32)
 */
typedef uint8 dnx_field_fes_mask_id_t;

/**
 * This is the type used for the value of the FES action mask.
 * This is the value of the 32 bit OR mask in the EFES_ACTION_MASK tables.
 */
typedef uint32 dnx_field_fes_mask_t;

/**
 * This is the 'type' used to indicate usage of 'valid bit' on FES.
 * To avoid too-large arrays, use a space saving type (uint8 in place of unsigned int)
 */
typedef uint8 dnx_field_fes_type_t;

/**
 * This is used to indicate 'polarity' of 'valid bit' on FES.
 * (Meaningful only if 'type' is zero).
 * To avoid too-large arrays, use a space saving type (uint8 in place of unsigned int)
 */
typedef uint8 dnx_field_fes_polarity_t;

/**
 * This is used to indicate 'inial_value_select' (on PMF EFES) or 'chosen_mask' (on ACE ACR) on FES which
 * indicates which of the 'masks', assigned to this FES, to use.
 * To avoid too-large arrays, use a space saving type (uint8 in place of unsigned int)
 */
typedef uint8 dnx_field_fes_chosen_mask_t;

/**
 * This is used to indicate 'shift' on FES which
 * indicates number of bits to shift from input 64 bits (FES key select).
 * To avoid too-large arrays, use a space saving type (uint8 in place of unsigned int)
 */
typedef uint8 dnx_field_fes_shift_t;

/**
 * This is used to indicate 'valid_bits' on FES which
 * indicates number of bits to actually extract after shifting. The same type may be used for 'invalid bits'
 * which complements 'valid bits' (to 32).
 * To avoid too-large arrays, use a space saving type (uint8 in place of unsigned int)
 */
typedef uint8 dnx_field_fes_valid_bits_t;

/**
 * This is used to indicate 'key_select' on FES which
 * indicates the 64 bits sector to extract from the input for FES.
 * To avoid too-large arrays, use a space saving type (uint8 in place of unsigned int)
 */
typedef uint8 dnx_field_fes_key_select_t;

/**
 * This is used to indicate the DNX level qualifier type.
 * This value is encoded by MAP module in following way:
 * QUAL_CLASS | FIELD_STAGE | QUAL_TYPE (QUAL_ID)
 * See DNX_QUAL() for details of encoding (using DNX_QUAL_CLASS_SHIFT, DNX_QUAL_CLASS_MASK, etc.)
 * See dnx_field_qual_class_e for the various 'QUAL_CLASS'
 * QUAL_TYPE (QUAL_ID) can be one of:
 * dnx_field_ipmf1_qual_e , dnx_field_ipmf3_qual_e, dnx_field_header_qual_e ...
 */
typedef uint32 dnx_field_qual_t;

/**
 * Used to indicate the id part of DNX qualifier,
 * may have different meaning per Qualifier class
 */
typedef int dnx_field_qual_id_t;

/**
 * Used to indicate the DNX level action type.
 * This value is encoded by MAP module in following way:
 * ACTION_CLASS | FIELD_STAGE | ACTION_ID
 * See DNX_ACTION() for details of encoding (using DNX_ACTION_CLASS_SHIFT, DNX_ACTION_CLASS_MASK, etc.)
 * See dnx_field_action_class_e for the various 'ACTION_CLASS'
 * ACTION_ID can be provided by user
 * or generated by algo for user defined actions
 * or actually be dnx_field_action_type_t, which is one of per stage enums:
 * dnx_field_ipmf1_action_e , dnx_field_ipmf3_action_e, ... referring to the action type.
 */
typedef uint32 dnx_field_action_t;

/**
 * Represents HW value, FEX is configured by - one of per stage enums:
 * dnx_field_ipmf1_action_e , dnx_field_ipmf3_action_e, ...
 */
typedef uint8 dnx_field_action_type_t;

/**
 * Used to indicate the id part of DNX Action dnx_field_action_t
 */
typedef int dnx_field_action_id_t;

/**
 * Used to indicate the APP_DB_ID of field groups. Uint32 because that is the DBAL value.
 */
typedef uint32 dnx_field_app_db_id_t;

/**
 * Used to hold the key of the PPMC table.
 */
typedef uint32 dnx_field_ace_key_t;

/**
 * Used to indicate the ID of an ACE field group and the result type of its entries in the PPMC database (MCDB), which serves as context for the ACE ACE EFES.
 */
typedef uint8 dnx_field_ace_id_t;

/**
 * Container of 5-bits identifiers of a bit index (one out of 24).
 * See, for example, 'dnx_field_fem_bit_val_t'
 * See tables FIELD_PMF_A_FEM_FIELD_SELECT_FEMS_2_15_MAP and FIELD_PMF_A_FEM_FIELD_SELECT_FEMS_0_1_MAP
 * on hl_acl_field_fem_definition.xml.
 */
typedef uint8 dnx_field_fem_bit_index_t;

/**
 * Container of 4-bits identifiers of a single 'condition'
 * (corresponding to a single 'FEM id' and 'FEM program')
 * See, for example, table FIELD_PMF_A_FEM_MAP_INDEX
 * on hl_acl_field_fem_definition.xml
 */
typedef uint8 dnx_field_fem_condition_t;

/**
 * Container of 4-bits identifiers of a FEM
 * See, for example, table FIELD_PMF_A_FEM_ADDER_FEMS_2_15_MAP
 * on hl_acl_field_fem_definition.xml
 */
typedef uint8 dnx_field_fem_id_t;

/*
 * ENUMs
 */

/**
 * Describe the Stages in our Block that can use Field API's
 */
typedef enum {
    /**
     * Invalid Field Stage
     */
    DNX_FIELD_STAGE_INVALID = -1,
    DNX_FIELD_STAGE_FIRST = 0,
    /**
     * Ingress PMF 1 (Pass 0 of PMF-A)
     */
    DNX_FIELD_STAGE_IPMF1 = DNX_FIELD_STAGE_FIRST,
    /**
     * Ingress PMF 2 (Pass 1 of PMF-A)
     */
    DNX_FIELD_STAGE_IPMF2,
    /**
     * Ingress PMF 3 (Rename of PMF-B)
     */
    DNX_FIELD_STAGE_IPMF3,
    /**
     * Egress PMF - single one at egress.
     */
    DNX_FIELD_STAGE_EPMF,
    /**
     * PPMC table and ACE ACR.
     */
    DNX_FIELD_STAGE_ACE,
    /**
     * Ingress FLP block 2 (used also for External lookup).
     */
    DNX_FIELD_STAGE_EXTERNAL,
    /**
     * Number of types in dnx_field_stage_e
     */
    DNX_FIELD_STAGE_NOF
} dnx_field_stage_e;

/**
 * Describe all Field Group types
 */
typedef enum {
    /**
     * Invalid Field Group
     */
    DNX_FIELD_GROUP_TYPE_INVALID = -1,
    DNX_FIELD_GROUP_TYPE_FIRST = 0,
    /**
     * TCAM Field Group: when a packet is qualified to an entry in
     * the Field Group, the entry's actions are applied to it.
     */
    DNX_FIELD_GROUP_TYPE_TCAM = DNX_FIELD_GROUP_TYPE_FIRST,
    /**
     * TCAM Direct Access Table Field Group: when a packet is qualified
     * to an entry in the Field Group, the entry's actions are
     * applied to it.
     */
    DNX_FIELD_GROUP_TYPE_DIRECT_TABLE_TCAM,
    /**
     * MDB Direct Access Table Field Group: when a packet is qualified
     * to an entry in the Field Group, the entry's actions are
     * applied to it. Up to one Field Group can be created of this type.
     */
    DNX_FIELD_GROUP_TYPE_DIRECT_TABLE_MDB,
    /**
     * Exact Match : when a packet is qualified
     * to an entry in the Field Group, the entry's actions are
     * applied to it.
     */
    DNX_FIELD_GROUP_TYPE_EXEM,
    
    DNX_FIELD_GROUP_TYPE_STATE_TABLE,
    /**
     * Direct Extraction Field Group. The action input is taken directly from the key.
     */
    DNX_FIELD_GROUP_TYPE_DIRECT_EXTRACTION,
    /**
     * Const Field Group. A field group without a key, only actions.
     * All actions must be zero sizes, not including action prefix (payload size 0).
     */
    DNX_FIELD_GROUP_TYPE_CONST,
    /**
     * KBP Field Group is the ACL group in the FLP block. The entries are located in the KBP device
     */
    DNX_FIELD_GROUP_TYPE_KBP,
    /**
     * Number of types in dnx_field_fg_type_e
     */
    DNX_FIELD_GROUP_TYPE_NOF
} dnx_field_group_type_e;

/**
 * Key that was created by field group can have 3 different length
 * Key HW length is 160 bit so the types are:
 * 80 bit -  half key
 * 160 bit - full key
 * 320 bit - T2 keys aggregated
 */
typedef enum {
    DNX_FIELD_KEY_LENGTH_TYPE_INVALID = -1,
    /**
     * DT key
     */
    DNX_FIELD_KEY_LENGTH_TYPE_DT = 0,
    /**
     * Half Key
     */
    DNX_FIELD_KEY_LENGTH_TYPE_HALF = 1,
    /**
     * 1 Key
     */
    DNX_FIELD_KEY_LENGTH_TYPE_SINGLE = 2,
    /**
     * 2 Keys
     */
    DNX_FIELD_KEY_LENGTH_TYPE_DOUBLE = 3,
    /**
     * No key being used
     */
    DNX_FIELD_KEY_LENGTH_TYPE_NONE = 4,
    DNX_FIELD_KEY_LENGTH_TYPE_NOF = 5
} dnx_field_key_length_type_e;

/**
 * The TOTAL length of action payload, regardless of the physical component.
 */
typedef enum {
    DNX_FIELD_ACTION_LENGTH_TYPE_INVALID = -1,
    /**
     * First TCAM action buffer half
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_TCAM_HALF = 0,
    /**
     * 1 full TCAM action buffer
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_TCAM_SINGLE = 1,
    /**
     * 2 full TCAM action buffers
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_TCAM_DOUBLE = 2,
    /**
     * Large EXEM
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_LEXEM = 3,
    /**
     * Small EXEM
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_SEXEM = 4,
    /**
     * ACE (PPMC database, A.K.A. MCDB)
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_ACE = 5,
    /**
     * Direct extraction
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_DIR_EXT = 6,
    /**
     * KBP field group
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_KBP = 7,
    /**
     * No input to action resolution (fg_type const)
     */
    DNX_FIELD_ACTION_LENGTH_TYPE_NONE = 8,
    DNX_FIELD_ACTION_LENGTH_TYPE_NOF = 9
} dnx_field_action_length_type_e;

/**
 * Enumeration to indicate which half-key is pointed. Only meaningful if just half
 * a key was allocated for some Field Group.
 * If DNX_FIELD_KEY_PART_TYPE_INVALID is used then it indicates a full key was allocated.
 */
typedef enum {
    DNX_FIELD_KEY_PART_TYPE_INVALID = -1,
    DNX_FIELD_KEY_PART_TYPE_FIRST = 0,
    /**
     * LSB bits of the Key
     */
    DNX_FIELD_KEY_PART_TYPE_LSB_HALF = DNX_FIELD_KEY_PART_TYPE_FIRST,
    /**
     * MSB bits of the Key
     */
    DNX_FIELD_KEY_PART_TYPE_MSB_HALF,
    /**
     * Number of valid values in dnx_field_key_part_type_e
     */
    DNX_FIELD_KEY_PART_TYPE_NOF
} dnx_field_key_part_type_e;

/**
 * Number of Layers supported by Parser
 */
typedef enum {
    /**
     * Invalid layer index
     */
    DNX_FIELD_LAYER_INDEX_INVALID = -1,
    /**
     * 
     */
    DNX_FIELD_LAYER_INDEX_0 = 0,
    DNX_FIELD_LAYER_INDEX_1 = 1,
    DNX_FIELD_LAYER_INDEX_2 = 2,
    DNX_FIELD_LAYER_INDEX_3 = 3,
    DNX_FIELD_LAYER_INDEX_4 = 4,
    DNX_FIELD_LAYER_INDEX_5 = 5,
    DNX_FIELD_LAYER_INDEX_6 = 6,
    DNX_FIELD_LAYER_INDEX_7 = 7,
    /**
     * Number of Layer supported by Parser
     */
    DNX_FIELD_LAYER_NOF = 8
} dnx_field_layer_index_e;

/**
 * Enum to indicate base layer type for qualifier.
 * Indicates the location on the pbus from which to take the data, and the FFC type.
 * Some input types also use the data in dnx_field_layer_index_e to indicate specific layer.
 */
typedef enum {
    /**
     * Invalid base layer
     */
    DNX_FIELD_INPUT_TYPE_INVALID = -1,
    /**
     * Extracted from a layer in the header. The layer index is added to the forwarding layer to determine the layer.
     */
    DNX_FIELD_INPUT_TYPE_LAYER_FWD = 0,
    /**
     * Extracted from a layer in the header, disregarding the forwarding layer.
     */
    DNX_FIELD_INPUT_TYPE_LAYER_ABSOLUTE = 1,
    /**
     * Extracted from MetaData
     */
    DNX_FIELD_INPUT_TYPE_META_DATA = 2,
    /**
     * Extracted from MetaData, used for iPMF2 native Metadata
     */
    DNX_FIELD_INPUT_TYPE_META_DATA2 = 3,
    /**
     * Extracted from the layer record, information about a layer. The layer index is added to the forwarding layer to determine the layer.
     */
    DNX_FIELD_INPUT_TYPE_LAYER_RECORDS_FWD = 4,
    /**
     * Extracted from the layer record, information about a layer, disregarding which layer is the forwarding layer
     */
    DNX_FIELD_INPUT_TYPE_LAYER_RECORDS_ABSOLUTE = 5,
    /**
     * Extracted from KBP field group result
     */
    DNX_FIELD_INPUT_TYPE_KBP = 6,
    /**
     * Extracted from 'Cascaded From' field group result
     */
    DNX_FIELD_INPUT_TYPE_CASCADED = 7,
    /**
     * Constant value. Zeros aren't written, every continuous set of 1' up to 16 is taken by an FFC from 'all ones' in Metadata.
     */
    DNX_FIELD_INPUT_TYPE_CONST = 8,
    /**
     * Number of Base Types
     */
    DNX_FIELD_INPUT_TYPE_NOF = 9
} dnx_field_input_type_e;

/**
 * Enum for bcm action class, see details per class
 */
typedef enum {
    DNX_FIELD_ACTION_CLASS_INVALID = 0,
    DNX_FIELD_ACTION_CLASS_FIRST = 1,
    /**
     * Predefined action that are defined by EFES/FEM hard values
     */
    DNX_FIELD_ACTION_CLASS_STATIC = DNX_FIELD_ACTION_CLASS_FIRST,
    /**
     * User defined action created by bcm_field_action_create() API
     */
    DNX_FIELD_ACTION_CLASS_USER,
    /**
     * Action that are not performed by EFES/FEM, used for other features such as: Cascading, Context Selection, EFES multiple action...
     */
    DNX_FIELD_ACTION_CLASS_SW,
    /**
     * Number of types in dnx_field_action_class_e
     */
    DNX_FIELD_ACTION_CLASS_NOF
} dnx_field_action_class_e;

/**
 * Enum for bcm qualifier class, see details per class
 */
typedef enum {
    DNX_FIELD_QUAL_CLASS_INVALID = 0,
    DNX_FIELD_QUAL_CLASS_FIRST = 1,
    /**
     * Metadata - qualifier is translated to stage general qualifier, characterized by offset and size and not dependent on traffic type
     */
    DNX_FIELD_QUAL_CLASS_META = DNX_FIELD_QUAL_CLASS_FIRST,
    /**
     * Mwtadata2 - special qualifier class for native PMF2 metadata qualifiers
     */
    DNX_FIELD_QUAL_CLASS_META2,
    /**
     * Layer Record - qualifiers based on Layer Record inside PBUS, managed like META qualifiers
     */
    DNX_FIELD_QUAL_CLASS_LAYER_RECORD,
    /**
     * Data Qualifier - user defined one
     */
    DNX_FIELD_QUAL_CLASS_USER,
    /**
     * Network - qualifier relates to packet field and its copy engine parameters(layer) depend on traffic type
     */
    DNX_FIELD_QUAL_CLASS_HEADER,
    /**
     * SW - software only qualifiers
     */
    DNX_FIELD_QUAL_CLASS_SW,
    /**
     * Number of types in dnx_field_qual_class_e
     */
    DNX_FIELD_QUAL_CLASS_NOF
} dnx_field_qual_class_e;

/*
 * STRUCTs
 */

/**
 * To indicate how to extract the qualifier from the PBUS (MetaData/LR/Layer).
 */
typedef struct {
    /**
     * The base of qualifier indicates from which part of the PBUS the info is taken
     * relevant for all type of qualifiers
     * DNX_FIELD_INPUT_TYPE_LAYER_FWD  - Takes data from a layer in the header, using the forwarding layer information.
     * DNX_FIELD_INPUT_TYPE_LAYER_ABSOLUTE - Takes data from a layer in the header, ignoring forwarding layer information.
     * DNX_FIELD_INPUT_TYPE_META_DATA - Takes data from the Metadata.
     * DNX_FIELD_INPUT_TYPE_META_DATA2 - Takes data from the native Metadata of iPMF2, relevant only for iPMF2.
     * DNX_FIELD_INPUT_TYPE_LAYER_RECORDS_FWD  -  Takes data about a layer in the header (layer record), using the forwarding layer information.
     * DNX_FIELD_INPUT_TYPE_LAYER_RECORDS_ABSOLUTE - Takes data about a layer in the header (layer record), ignoring the forwarding layer information.
     * DNX_FIELD_INPUT_TYPE_KBP - Takes data from the result of the KBP.
     * DNX_FIELD_INPUT_TYPE_CASCADED - Takes data from the result of a field group from an earlier stage, using cascading.
     * DNX_FIELD_INPUT_TYPE_CONST - Writes a constant value.
     */
    dnx_field_input_type_e input_type;
    /**
     * Input arg has different meaning per input type as follows:
     * DNX_FIELD_INPUT_TYPE_LAYER_FWD  - how many layer to increment from the forwarding layer (i.e. FWD+input_arg). Can take negative or positive values.
     * DNX_FIELD_INPUT_TYPE_LAYER_ABSOLUTE - how many layer to increment from the outermost layer (i.e. 0+input_arg). Can only take non-negative values.
     * DNX_FIELD_INPUT_TYPE_META_DATA - Has no meaning
     * DNX_FIELD_INPUT_TYPE_LAYER_RECORDS_FWD  -  how many layer to increment from the forwarding layer (i.e. FWD+input_arg). Can take negative or positive values.
     * DNX_FIELD_INPUT_TYPE_LAYER_RECORDS_ABSOLUTE - how many layer to increment from the absolute layer (i.e. 0+input_arg). Can only take non-negative values.
     * DNX_FIELD_INPUT_TYPE_KBP - Has no meaning
     * DNX_FIELD_INPUT_TYPE_CASCADED - Field group Id of the 'Cascaded from' result
     * DNX_FIELD_INPUT_TYPE_CONST - A constant, up to 32 bit.
     */
    int input_arg;
    /**
     * 1) This filed is bit resolution
     * 2) In case the qualifier was created by dnx_field_qual_create() this field is always relevant
     * it is the offset of the field inside the PBUS (MD/LR/Layer)
     * 3) For predefined qualifiers based on input_type:
     * DNX_FIELD_INPUT_TYPE_LAYER_FWD  - offset inside the layer  (chosen by input_type+input_arg)
     * DNX_FIELD_INPUT_TYPE_LAYER_ABSOLUTE - offset inside the layer  (chosen by input_type+input_arg)
     * DNX_FIELD_INPUT_TYPE_META_DATA - NA
     * DNX_FIELD_INPUT_TYPE_LAYER_RECORDS_FWD  -  NA
     * DNX_FIELD_INPUT_TYPE_LAYER_RECORDS_ABSOLUTE - NA
     * DNX_FIELD_INPUT_TYPE_KBP - offset of the field group in the KBP result buffer, plus the offset of the action withing the field group.
     * DNX_FIELD_INPUT_TYPE_CASCADED - offset in the field group of 'Cascaded from' result buffer
     * DNX_FIELD_INPUT_TYPE_CONST - NA
     */
    int offset;
} dnx_field_qual_attach_info_t;

/**
 * Include information on each action that configured in attach API.
 */
typedef struct {
    /**
     * Indicate the priority per action that was configured for specific Field Group
     * the lower the number the higher the priority of the actions the higher FES/FEM id will be allocated
     */
    dnx_field_action_priority_t priority;
} dnx_field_action_attach_info_t;


#endif /* __DNX_FIELD_TYPES_H__ */
