/** \file dnx/swstate/auto_generated/types/mdb_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 *
 */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */

#ifndef __MDB_TYPES_H__
#define __MDB_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_fields.h>
#include <soc/dnx/dbal/auto_generated/dbal_defines_tables.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_mdb.h>
/*
 * MACROs
 */

/**
 * Indicate that an encoding value isn't available.
 */
#define MDB_INVALID_EM_FORMAT_VALUE 0xFF

/**
 * The EM logical key has a size of 8 bits and the TID 6, this is the max value of both which is 256 + 64 = 320.
 */
#define MDB_EM_MAX_KEYS_PLUS_TID_VALS_SIZE 320

/*
 * ENUMs
 */

/**
 * types of macros
 */
typedef enum {
    /**
     * macro of type A
     */
    MDB_MACRO_A = 0,
    /**
     * macro of type B
     */
    MDB_MACRO_B = 1,
    /**
     * EEDB bank
     */
    MDB_EEDB_BANK = 2,
    /**
     * NOF macro types
     */
    MDB_NOF_MACRO_TYPES = 3
} mdb_macro_types_e;

/*
 * STRUCTs
 */

typedef struct {
    /**
     * The macro type of this cluster, in case of LL phydb it must be MDB_EEDB_BANK.
     */
    mdb_macro_types_e macro_type;
    /**
     * the index of the macro 0-nof indexes of the macro types -1
     */
    uint8 macro_index;
    /**
     * 0- NOF clusters in case of a MACRO A/B or bank number in case of EEDB bank.
     */
    uint8 cluster_index;
    /**
     * This is the serial number of the cluster in the entry which is a part of.e.g. if the entry is 480bits width and start on cluster 4, then cluster 4 will get position 0, cluster 5 position 1, 6->2 and 7->3.
     */
    uint8 cluster_position_in_entry;
    /**
     * The physical start address of entries in this cluster (inclusive)
     */
    int start_address;
    /**
     * The physical end address is calculated using the start_address + MDB_NOF_ROWS_IN_MACRO_A/B_CLUSTER / MDB_NOF_ROWS_IN_EEDB_BANK (exclusive).
     */
    int end_address;
    /**
     * MDB cluster rows used as EEDB data clusters can be associated with either one of two phases.phase_alloc holds the phase allocation for every MDB_NOF_ROWS_IN_EEDB_BANK rows,since this is the minimal number of rows that can have alternating allocation.
     */
    uint8 phase_alloc_rows[DNX_DATA_MAX_MDB_DH_NOF_ROWS_IN_MACRO_A_CLUSTER/DNX_DATA_MAX_MDB_DH_NOF_ROWS_IN_EEDB_BANK];
    /**
     * Holds all possible big KAPS allocations for this cluster, see MDB_KAPS_BIG_X
     */
    uint8 big_kaps_alloc_flags;
    /**
     * Holds current big KAPS allocation for this cluster, see MDB_KAPS_BIG_X
     */
    uint8 big_kaps_alloc_flags_current;
} mdb_cluster_info_t;

typedef struct {
    /**
     * The total number of clusters that were allocated for this table at init.
     */
    int number_of_alloc_clusters;
    /**
     * The total number of clusters associated with this table.
     */
    int number_of_clusters;
    /**
     * The number of clusters that each entry holds.
     */
    int nof_cluster_per_entry;
    /**
     * The cluster information.
     */
    mdb_cluster_info_t* clusters_info;
} mdb_db_info_t;

/**
 * This structure holds information to update the EM bank size and the EM formats which depends on the bank sizes.
 */
typedef struct {
    /**
     * Accumulates the 8k entries bank size that were used (relevant for EM only).Basically an allocation in DHA will result in +2 and in DHB in +1.Note that the row size doesn't affect the calculation  (240 doesn't counted twice)
     */
    uint32 bank_size_used_8k;
    /**
     * The macro index that the bank sizes were collected to.
     */
    uint8 macro_index;
    /**
     * The macro type that the bank sizes were collected to.
     */
    mdb_macro_types_e macro_type;
    /**
     * The clusters that are used in this macro for the given PDB.
     */
    uint32 cluster_mapping;
} dh_em_bank_info;

/**
 * This structure holds a single EM table key-format information.which is the format allocation to each key type.
 */
typedef struct {
    /**
     * Maps between a key (key size + TID size) value to its allocated format.
     */
    uint8 format_count;
    /**
     * Maps between a key (key size + TID size) value to its allocated format.
     */
    uint32 key_to_format_map[MDB_EM_MAX_KEYS_PLUS_TID_VALS_SIZE];
    /**
     * This structure holds the information of each EM PDB interface that is used for updating therelevant clusters EM format.
     */
    dh_em_bank_info em_bank_info[DNX_DATA_MAX_MDB_PDBS_MAX_NOF_INTERFACE_DHS];
} em_key_format_info;

/**
 * An array that holds for each cluster its MDB table association and SW shadow in case of Direct/EEDB clusters.
 */
typedef struct {
    /**
     * Enable MDB cache.
     */
    uint8 cache_enabled;
    /**
     * The MDB table association of MACRO A clusters.
     */
    dbal_enum_value_field_mdb_physical_table_e macro_a_cluster_assoc[DNX_DATA_MAX_MDB_DH_NOF_MACROES_TYPE_A *                                                                 DNX_DATA_MAX_MDB_DH_NOF_MACRO_CLUSTERS];
    /**
     * The SW shadow of MACRO A clusters, only allocated for Direct/EEDB.
     */
    uint32** macro_a_cluster_cache[DNX_DATA_MAX_MDB_DH_NOF_MACROES_TYPE_A * DNX_DATA_MAX_MDB_DH_NOF_MACRO_CLUSTERS];
    /**
     * The MDB table association of MACRO B clusters.
     */
    dbal_enum_value_field_mdb_physical_table_e macro_b_cluster_assoc[DNX_DATA_MAX_MDB_DH_NOF_MACROES_TYPE_B *                                                                 DNX_DATA_MAX_MDB_DH_NOF_MACRO_CLUSTERS];
    /**
     * The SW shadow of MACRO B clusters, only allocated for Direct/EEDB.
     */
    uint32** macro_b_cluster_cache[DNX_DATA_MAX_MDB_DH_NOF_MACROES_TYPE_B * DNX_DATA_MAX_MDB_DH_NOF_MACRO_CLUSTERS];
    /**
     * The MDB table association of EEDB banks.
     */
    dbal_enum_value_field_mdb_physical_table_e eedb_banks_assoc[DNX_DATA_MAX_MDB_EEDB_NOF_EEDB_BANKS];
    /**
     * The SW shadow of EEDB banks.
     */
    uint32** eedb_banks_cache[DNX_DATA_MAX_MDB_EEDB_NOF_EEDB_BANKS];
    /**
     * Cache for eedb hitbit banks. Since they're always read and clear, we must cache them after every call or they'll be overridden.
     */
    uint32* eedb_banks_hitbit[DNX_DATA_MAX_MDB_EEDB_NOF_EEDB_BANKS];
    /**
     * Cache for small KAPS BB hitbit banks. Since they're always read and clear, we must cache them after every call or they'll be overridden.
     */
    uint32** small_kaps_bb_hitbit;
} mdb_cluster_info;

/**
 * An array that holds for each physical table the addresses of its physical resources.
 */
typedef struct {
    /**
     * Holds all the EM key and format information for both the DHs init and the MDB tables init.
     */
    em_key_format_info em_key_format[DBAL_NOF_PHYSICAL_TABLES];
    /**
     * clusters informaiton of the MDB tables.
     */
    mdb_db_info_t db[DBAL_NOF_ENUM_MDB_PHYSICAL_TABLE_VALUES];
    /**
     * Each entry in this array holds the capacity of an MDB table.
     */
    int capacity[DBAL_NOF_PHYSICAL_TABLES];
    /**
     * the EEDB payload type.
     */
    uint32 eedb_payload_type[DBAL_NOF_ENUM_MDB_EEDB_PHASE_VALUES];
    /**
     * The MDB cluster association and SW shadow.
     */
    mdb_cluster_info mdb_cluster_infos;
    /**
     * the maximal  FEC ID value supported.
     */
    uint32 max_fec_id_value;
} mdb_tables_info;


#endif /* __MDB_TYPES_H__ */
