/** \file dnx_data_internal_meter.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_METER_H_
/*{*/
#define _DNX_DATA_INTERNAL_METER_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_meter.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_meter_submodule_profile,
    dnx_data_meter_submodule_diag,
    dnx_data_meter_submodule_meter_db,
    dnx_data_meter_submodule_mem_mgmt,
    dnx_data_meter_submodule_compensation,

    /**
     * Must be last one!
     */
    _dnx_data_meter_submodule_nof
} dnx_data_meter_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE PROFILE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_meter_profile_feature_get(
    int unit,
    dnx_data_meter_profile_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_meter_profile_define_large_bucket_mode_exp_add,
    dnx_data_meter_profile_define_max_regular_bucket_mode_burst,
    dnx_data_meter_profile_define_rev_exp_min,
    dnx_data_meter_profile_define_rev_exp_max,
    dnx_data_meter_profile_define_burst_size_min,
    dnx_data_meter_profile_define_nof_valid_global_meters,
    dnx_data_meter_profile_define_nof_dp_command_max,
    dnx_data_meter_profile_define_global_engine_hw_stat_database_id,

    /**
     * Must be last one!
     */
    _dnx_data_meter_profile_define_nof
} dnx_data_meter_profile_define_e;

/* Get Data */
/**
 * \brief returns define data of large_bucket_mode_exp_add
 * Module - 'meter', Submodule - 'profile', data - 'large_bucket_mode_exp_add'
 * cbs calculation: the value need to add to the exponent in larger bucket mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_bucket_mode_exp_add - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_profile_large_bucket_mode_exp_add_get(
    int unit);

/**
 * \brief returns define data of max_regular_bucket_mode_burst
 * Module - 'meter', Submodule - 'profile', data - 'max_regular_bucket_mode_burst'
 * max value for burst size (in bytes), which do not use large bucket mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_regular_bucket_mode_burst - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_profile_max_regular_bucket_mode_burst_get(
    int unit);

/**
 * \brief returns define data of rev_exp_min
 * Module - 'meter', Submodule - 'profile', data - 'rev_exp_min'
 * min value for reverse exponent
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rev_exp_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_profile_rev_exp_min_get(
    int unit);

/**
 * \brief returns define data of rev_exp_max
 * Module - 'meter', Submodule - 'profile', data - 'rev_exp_max'
 * max value for reverse exponent
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rev_exp_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_profile_rev_exp_max_get(
    int unit);

/**
 * \brief returns define data of burst_size_min
 * Module - 'meter', Submodule - 'profile', data - 'burst_size_min'
 * minimum burst size in kbits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_size_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_profile_burst_size_min_get(
    int unit);

/**
 * \brief returns define data of nof_valid_global_meters
 * Module - 'meter', Submodule - 'profile', data - 'nof_valid_global_meters'
 * nof_valid_global_meters, based in nof fwd-types
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_valid_global_meters - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_profile_nof_valid_global_meters_get(
    int unit);

/**
 * \brief returns define data of nof_dp_command_max
 * Module - 'meter', Submodule - 'profile', data - 'nof_dp_command_max'
 * max nof DP commands
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dp_command_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_profile_nof_dp_command_max_get(
    int unit);

/**
 * \brief returns define data of global_engine_hw_stat_database_id
 * Module - 'meter', Submodule - 'profile', data - 'global_engine_hw_stat_database_id'
 * to indicate global meter in HW - for Ingress Gtimer counter statistic
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_engine_hw_stat_database_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_profile_global_engine_hw_stat_database_id_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_meter_profile_table_nof
} dnx_data_meter_profile_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE DIAG:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_meter_diag_feature_get(
    int unit,
    dnx_data_meter_diag_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_meter_diag_define_nof
} dnx_data_meter_diag_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_meter_diag_table_nof
} dnx_data_meter_diag_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE METER_DB:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_meter_meter_db_feature_get(
    int unit,
    dnx_data_meter_meter_db_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_meter_meter_db_define_nof_ingress_db,
    dnx_data_meter_meter_db_define_nof_egress_db,
    dnx_data_meter_meter_db_define_meter_ids_in_group,

    /**
     * Must be last one!
     */
    _dnx_data_meter_meter_db_define_nof
} dnx_data_meter_meter_db_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_ingress_db
 * Module - 'meter', Submodule - 'meter_db', data - 'nof_ingress_db'
 * nof ingress meter databases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ingress_db - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_meter_db_nof_ingress_db_get(
    int unit);

/**
 * \brief returns define data of nof_egress_db
 * Module - 'meter', Submodule - 'meter_db', data - 'nof_egress_db'
 * nof egress meter databases
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egress_db - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_meter_db_nof_egress_db_get(
    int unit);

/**
 * \brief returns define data of meter_ids_in_group
 * Module - 'meter', Submodule - 'meter_db', data - 'meter_ids_in_group'
 * nof meter ids in one meter group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     meter_ids_in_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_meter_db_meter_ids_in_group_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_meter_meter_db_table_nof
} dnx_data_meter_meter_db_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE MEM_MGMT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_meter_mem_mgmt_feature_get(
    int unit,
    dnx_data_meter_mem_mgmt_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_meter_mem_mgmt_define_adrress_range_resolution,
    dnx_data_meter_mem_mgmt_define_object_stat_pointer_base_resolution,
    dnx_data_meter_mem_mgmt_define_ptr_map_table_resolution,
    dnx_data_meter_mem_mgmt_define_base_big_engine_for_meter,
    dnx_data_meter_mem_mgmt_define_sections_offset,
    dnx_data_meter_mem_mgmt_define_ingress_single_bucket_engine,
    dnx_data_meter_mem_mgmt_define_egress_single_bucket_engine,
    dnx_data_meter_mem_mgmt_define_counters_buckets_ratio_per_engine,

    /**
     * Must be last one!
     */
    _dnx_data_meter_mem_mgmt_define_nof
} dnx_data_meter_mem_mgmt_define_e;

/* Get Data */
/**
 * \brief returns define data of adrress_range_resolution
 * Module - 'meter', Submodule - 'mem_mgmt', data - 'adrress_range_resolution'
 * nof of meters resolution in shmem address range HW table 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     adrress_range_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_mem_mgmt_adrress_range_resolution_get(
    int unit);

/**
 * \brief returns define data of object_stat_pointer_base_resolution
 * Module - 'meter', Submodule - 'mem_mgmt', data - 'object_stat_pointer_base_resolution'
 * resolution for parameter 'object_stat_pointer_base', in API bcm_policer_engine_database_attach
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     object_stat_pointer_base_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_mem_mgmt_object_stat_pointer_base_resolution_get(
    int unit);

/**
 * \brief returns define data of ptr_map_table_resolution
 * Module - 'meter', Submodule - 'mem_mgmt', data - 'ptr_map_table_resolution'
 * ptr map table index is 8 msb bits mask of the object stat id pointer. this indicates the resolution of the table based on this mask
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ptr_map_table_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_mem_mgmt_ptr_map_table_resolution_get(
    int unit);

/**
 * \brief returns define data of base_big_engine_for_meter
 * Module - 'meter', Submodule - 'mem_mgmt', data - 'base_big_engine_for_meter'
 * the base engine that is used for engine. (except the small engines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     base_big_engine_for_meter - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_mem_mgmt_base_big_engine_for_meter_get(
    int unit);

/**
 * \brief returns define data of sections_offset
 * Module - 'meter', Submodule - 'mem_mgmt', data - 'sections_offset'
 * one engine contain two sections (banks). This parameter holds the offset between two sections. (For example: engine 16: banks: 0,6)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sections_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_mem_mgmt_sections_offset_get(
    int unit);

/**
 * \brief returns define data of ingress_single_bucket_engine
 * Module - 'meter', Submodule - 'mem_mgmt', data - 'ingress_single_bucket_engine'
 * holds the engines that is used for ingress eth meter, which is small and can be used only in single bucket mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_single_bucket_engine - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_mem_mgmt_ingress_single_bucket_engine_get(
    int unit);

/**
 * \brief returns define data of egress_single_bucket_engine
 * Module - 'meter', Submodule - 'mem_mgmt', data - 'egress_single_bucket_engine'
 * holds the engines that is used for egress eth meter, which is small and can be used only in single bucket mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_single_bucket_engine - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_mem_mgmt_egress_single_bucket_engine_get(
    int unit);

/**
 * \brief returns define data of counters_buckets_ratio_per_engine
 * Module - 'meter', Submodule - 'mem_mgmt', data - 'counters_buckets_ratio_per_engine'
 * each engine contain X counters or 2*X buckets (for meter). this holds the ratio
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counters_buckets_ratio_per_engine - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_meter_mem_mgmt_counters_buckets_ratio_per_engine_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_meter_mem_mgmt_table_nof
} dnx_data_meter_mem_mgmt_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE COMPENSATION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_meter_compensation_feature_get(
    int unit,
    dnx_data_meter_compensation_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_meter_compensation_define_nof
} dnx_data_meter_compensation_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_meter_compensation_table_ingress_port_delta_value,

    /**
     * Must be last one!
     */
    _dnx_data_meter_compensation_table_nof
} dnx_data_meter_compensation_table_e;

/* Get Data */
/**
 * \brief get table ingress_port_delta_value entry 
 * minimum and maximum delta value for ingress compensation per port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_port_delta_value - returns the relevant entry values grouped in struct - see dnx_data_meter_compensation_ingress_port_delta_value_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_meter_compensation_ingress_port_delta_value_t * dnx_data_meter_compensation_ingress_port_delta_value_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'meter', Submodule - 'compensation', table - 'ingress_port_delta_value'
 * minimum and maximum delta value for ingress compensation per port
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_meter_compensation_ingress_port_delta_value_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)ingress_port_delta_value info
 * minimum and maximum delta value for ingress compensation per port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_port_delta_value - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_meter_compensation_ingress_port_delta_value_info_get(
    int unit);

/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_meter_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_METER_H_*/
/* *INDENT-ON* */
