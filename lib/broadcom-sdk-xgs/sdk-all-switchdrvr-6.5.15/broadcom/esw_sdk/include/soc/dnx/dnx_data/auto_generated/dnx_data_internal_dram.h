/** \file dnx_data_internal_dram.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 */
#ifndef _DNX_DATA_INTERNAL_DRAM_H_
/*{*/
#define _DNX_DATA_INTERNAL_DRAM_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_dram.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_dram_submodule_hbm,
    dnx_data_dram_submodule_general_info,
    dnx_data_dram_submodule_address_translation,
    dnx_data_dram_submodule_buffers,

    /**
     * Must be last one!
     */
    _dnx_data_dram_submodule_nof
} dnx_data_dram_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE HBM:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_hbm_feature_get(
    int unit,
    dnx_data_dram_hbm_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_hbm_define_burst_length,
    dnx_data_dram_hbm_define_stop_traffic_temp_threshold,
    dnx_data_dram_hbm_define_restore_traffic_temp_threshold,
    dnx_data_dram_hbm_define_usec_between_temp_samples,
    dnx_data_dram_hbm_define_power_down_temp_threshold,
    dnx_data_dram_hbm_define_dram_temp_monitor_enable,
    dnx_data_dram_hbm_define_nof_hbms,
    dnx_data_dram_hbm_define_nof_channels,
    dnx_data_dram_hbm_define_channel_broadcast_id,
    dnx_data_dram_hbm_define_mr_mask,
    dnx_data_dram_hbm_define_nof_mrs,
    dnx_data_dram_hbm_define_phy_address_mask,
    dnx_data_dram_hbm_define_hbc_physical_last_in_chain,

    /**
     * Must be last one!
     */
    _dnx_data_dram_hbm_define_nof
} dnx_data_dram_hbm_define_e;

/* Get Data */
/**
 * \brief returns numeric data of burst_length
 * Module - 'dram', Submodule - 'hbm', data - 'burst_length'
 * burst length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_burst_length_get(
    int unit);

/**
 * \brief returns numeric data of stop_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_temp_threshold'
 * temperature threshold (C degrees) above which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_stop_traffic_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of restore_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_temp_threshold'
 * temperature threshold (C degrees) below which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_restore_traffic_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of usec_between_temp_samples
 * Module - 'dram', Submodule - 'hbm', data - 'usec_between_temp_samples'
 * time in usecs to wait between HBM temperature sampling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     usec_between_temp_samples - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_usec_between_temp_samples_get(
    int unit);

/**
 * \brief returns numeric data of power_down_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_temp_threshold'
 * temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_power_down_temp_threshold_get(
    int unit);

/**
 * \brief returns numeric data of dram_temp_monitor_enable
 * Module - 'dram', Submodule - 'hbm', data - 'dram_temp_monitor_enable'
 * enable/disable driver temperature monitoring
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_temp_monitor_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_dram_temp_monitor_enable_get(
    int unit);

/**
 * \brief returns define data of nof_hbms
 * Module - 'dram', Submodule - 'hbm', data - 'nof_hbms'
 * number of HBMs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hbms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_nof_hbms_get(
    int unit);

/**
 * \brief returns define data of nof_channels
 * Module - 'dram', Submodule - 'hbm', data - 'nof_channels'
 * number of channels in each HBM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_nof_channels_get(
    int unit);

/**
 * \brief returns define data of channel_broadcast_id
 * Module - 'dram', Submodule - 'hbm', data - 'channel_broadcast_id'
 * channel id to use in dbal when trying to broadcast
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_broadcast_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_channel_broadcast_id_get(
    int unit);

/**
 * \brief returns define data of mr_mask
 * Module - 'dram', Submodule - 'hbm', data - 'mr_mask'
 * mode register bit mask
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mr_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_mr_mask_get(
    int unit);

/**
 * \brief returns define data of nof_mrs
 * Module - 'dram', Submodule - 'hbm', data - 'nof_mrs'
 * number of mode registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mrs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_nof_mrs_get(
    int unit);

/**
 * \brief returns define data of phy_address_mask
 * Module - 'dram', Submodule - 'hbm', data - 'phy_address_mask'
 * bit mask to describe the relevant bits in phy register address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_address_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_phy_address_mask_get(
    int unit);

/**
 * \brief returns define data of hbc_physical_last_in_chain
 * Module - 'dram', Submodule - 'hbm', data - 'hbc_physical_last_in_chain'
 * block index of the physically last in chain hbc, provided all hbms are active
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbc_physical_last_in_chain - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_hbm_hbc_physical_last_in_chain_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_hbm_table_mr_defaults,
    dnx_data_dram_hbm_table_channel_symmetric_regs,
    dnx_data_dram_hbm_table_channel_not_symmetric_regs,
    dnx_data_dram_hbm_table_controller_symmetric_regs,
    dnx_data_dram_hbm_table_controller_not_symmetric_regs,
    dnx_data_dram_hbm_table_channel_interrupt_regs,
    dnx_data_dram_hbm_table_controller_interrupt_regs,
    dnx_data_dram_hbm_table_channel_debug_regs,
    dnx_data_dram_hbm_table_channel_counter_regs,
    dnx_data_dram_hbm_table_channel_type_regs,
    dnx_data_dram_hbm_table_controller_info_regs,

    /**
     * Must be last one!
     */
    _dnx_data_dram_hbm_table_nof
} dnx_data_dram_hbm_table_e;

/* Get Data */
/**
 * \brief get table mr_defaults entry 
 * mode registers default values
 * 
 * \param [in] unit - unit #
 * \param [in] index - mode register index
 * 
 * \return
 *     mr_defaults - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_mr_defaults_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_mr_defaults_t * dnx_data_dram_hbm_mr_defaults_get(
    int unit,
    int index);

/**
 * \brief get table channel_symmetric_regs entry 
 * per channel list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_symmetric_regs_t * dnx_data_dram_hbm_channel_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_not_symmetric_regs entry 
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_not_symmetric_regs_t * dnx_data_dram_hbm_channel_not_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_symmetric_regs entry 
 * per controller list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_symmetric_regs_t * dnx_data_dram_hbm_controller_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_not_symmetric_regs entry 
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_not_symmetric_regs_t * dnx_data_dram_hbm_controller_not_symmetric_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_interrupt_regs_t * dnx_data_dram_hbm_channel_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per controller list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_interrupt_regs_t * dnx_data_dram_hbm_controller_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_debug_regs_t * dnx_data_dram_hbm_channel_debug_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_counter_regs_t * dnx_data_dram_hbm_channel_counter_regs_get(
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_channel_type_regs_t * dnx_data_dram_hbm_channel_type_regs_get(
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_hbm_controller_info_regs_t * dnx_data_dram_hbm_controller_info_regs_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'mr_defaults'
 * mode registers default values
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_mr_defaults_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_symmetric_regs'
 * per channel list of symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_not_symmetric_regs'
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_not_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_symmetric_regs'
 * per controller list of symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_not_symmetric_regs'
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_not_symmetric_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_interrupt_regs'
 * per channel list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_interrupt_regs'
 * per controller list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_debug_regs'
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_debug_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_counter_regs'
 * per channel list of counter registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_counter_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'channel_type_regs'
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_channel_type_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'hbm', table - 'controller_info_regs'
 * per contorller list of info registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_hbm_controller_info_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)mr_defaults info
 * mode registers default values
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mr_defaults - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_mr_defaults_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_symmetric_regs info
 * per channel list of symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_not_symmetric_regs info
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_not_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_not_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_symmetric_regs info
 * per controller list of symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_not_symmetric_regs info
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_not_symmetric_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_not_symmetric_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_interrupt_regs info
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_interrupt_regs info
 * per controller list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_debug_regs info
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_debug_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_debug_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_counter_regs info
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_counter_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_counter_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)channel_type_regs info
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     channel_type_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_channel_type_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)controller_info_regs info
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     controller_info_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_hbm_controller_info_regs_info_get(
    int unit);

/*
 * SUBMODULE GENERAL_INFO:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_general_info_feature_get(
    int unit,
    dnx_data_dram_general_info_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_general_info_define_otp_restore_version,
    dnx_data_dram_general_info_define_frequency,
    dnx_data_dram_general_info_define_buffer_size,
    dnx_data_dram_general_info_define_command_address_parity,
    dnx_data_dram_general_info_define_dq_write_parity,
    dnx_data_dram_general_info_define_dq_read_parity,
    dnx_data_dram_general_info_define_dbi_read,
    dnx_data_dram_general_info_define_dbi_write,
    dnx_data_dram_general_info_define_write_latency,
    dnx_data_dram_general_info_define_read_latency,
    dnx_data_dram_general_info_define_parity_latency,
    dnx_data_dram_general_info_define_actual_parity_latency,
    dnx_data_dram_general_info_define_tune_mode_on_init,

    /**
     * Must be last one!
     */
    _dnx_data_dram_general_info_define_nof
} dnx_data_dram_general_info_define_e;

/* Get Data */
/**
 * \brief returns define data of otp_restore_version
 * Module - 'dram', Submodule - 'general_info', data - 'otp_restore_version'
 * when restoring from OTP the tune data, do it according to the given version format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     otp_restore_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_otp_restore_version_get(
    int unit);

/**
 * \brief returns numeric data of frequency
 * Module - 'dram', Submodule - 'general_info', data - 'frequency'
 * dram frequency (in MHZ), used to calculated data_rate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     frequency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_frequency_get(
    int unit);

/**
 * \brief returns numeric data of buffer_size
 * Module - 'dram', Submodule - 'general_info', data - 'buffer_size'
 * dram buffer size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     buffer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_buffer_size_get(
    int unit);

/**
 * \brief returns numeric data of command_address_parity
 * Module - 'dram', Submodule - 'general_info', data - 'command_address_parity'
 * command address parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_address_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_command_address_parity_get(
    int unit);

/**
 * \brief returns numeric data of dq_write_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_write_parity'
 * dq write parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_write_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dq_write_parity_get(
    int unit);

/**
 * \brief returns numeric data of dq_read_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_read_parity'
 * dq read parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_read_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dq_read_parity_get(
    int unit);

/**
 * \brief returns numeric data of dbi_read
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_read'
 * dbi read
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dbi_read_get(
    int unit);

/**
 * \brief returns numeric data of dbi_write
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_write'
 * dbi write
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_dbi_write_get(
    int unit);

/**
 * \brief returns numeric data of write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'write_latency'
 * write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_write_latency_get(
    int unit);

/**
 * \brief returns numeric data of read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'read_latency'
 * read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_read_latency_get(
    int unit);

/**
 * \brief returns numeric data of parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'parity_latency'
 * parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_parity_latency_get(
    int unit);

/**
 * \brief returns numeric data of actual_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'actual_parity_latency'
 * parity latency to be used after factoring in the effect of other numerics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     actual_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_actual_parity_latency_get(
    int unit);

/**
 * \brief returns numeric data of tune_mode_on_init
 * Module - 'dram', Submodule - 'general_info', data - 'tune_mode_on_init'
 * tune mode during init sequence
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tune_mode_on_init - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_general_info_tune_mode_on_init_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_general_info_table_dram_info,
    dnx_data_dram_general_info_table_timing_params,
    dnx_data_dram_general_info_table_refresh_intervals,

    /**
     * Must be last one!
     */
    _dnx_data_dram_general_info_table_nof
} dnx_data_dram_general_info_table_e;

/* Get Data */
/**
 * \brief get table dram_info entry 
 * general information regarding the dram in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_info - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_dram_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_dram_info_t * dnx_data_dram_general_info_dram_info_get(
    int unit);

/**
 * \brief get table timing_params entry 
 * timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     timing_params - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_timing_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_timing_params_t * dnx_data_dram_general_info_timing_params_get(
    int unit);

/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * \param [in] temp_index - temperature index
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_general_info_refresh_intervals_t * dnx_data_dram_general_info_refresh_intervals_get(
    int unit,
    int temp_index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'dram_info'
 * general information regarding the dram in the system
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_dram_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'timing_params'
 * timing parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_timing_params_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'general_info', table - 'refresh_intervals'
 * refresh intervals timing parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_general_info_refresh_intervals_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)dram_info info
 * general information regarding the dram in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_dram_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)timing_params info
 * timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     timing_params - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_timing_params_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)refresh_intervals info
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_general_info_refresh_intervals_info_get(
    int unit);

/*
 * SUBMODULE ADDRESS_TRANSLATION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_address_translation_feature_get(
    int unit,
    dnx_data_dram_address_translation_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_address_translation_define_matrix_column_size,
    dnx_data_dram_address_translation_define_physical_address_transaction_size,

    /**
     * Must be last one!
     */
    _dnx_data_dram_address_translation_define_nof
} dnx_data_dram_address_translation_define_e;

/* Get Data */
/**
 * \brief returns define data of matrix_column_size
 * Module - 'dram', Submodule - 'address_translation', data - 'matrix_column_size'
 * the number of rows in the ATM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     matrix_column_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_matrix_column_size_get(
    int unit);

/**
 * \brief returns define data of physical_address_transaction_size
 * Module - 'dram', Submodule - 'address_translation', data - 'physical_address_transaction_size'
 * nof bytes in each read/write from/to physical address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_transaction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_address_translation_physical_address_transaction_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_address_translation_table_matrix_configuration,
    dnx_data_dram_address_translation_table_interrupt_regs,
    dnx_data_dram_address_translation_table_counter_regs,

    /**
     * Must be last one!
     */
    _dnx_data_dram_address_translation_table_nof
} dnx_data_dram_address_translation_table_e;

/* Get Data */
/**
 * \brief get table matrix_configuration entry 
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - unit #
 * \param [in] matrix_option - matrix selector
 * 
 * \return
 *     matrix_configuration - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_matrix_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_matrix_configuration_t * dnx_data_dram_address_translation_matrix_configuration_get(
    int unit,
    int matrix_option);

/**
 * \brief get table interrupt_regs entry 
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_interrupt_regs_t * dnx_data_dram_address_translation_interrupt_regs_get(
    int unit,
    int index);

/**
 * \brief get table counter_regs entry 
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_address_translation_counter_regs_t * dnx_data_dram_address_translation_counter_regs_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'matrix_configuration'
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_matrix_configuration_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'interrupt_regs'
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_interrupt_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'address_translation', table - 'counter_regs'
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_address_translation_counter_regs_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)matrix_configuration info
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     matrix_configuration - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_matrix_configuration_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)interrupt_regs info
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interrupt_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_interrupt_regs_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)counter_regs info
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counter_regs - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_address_translation_counter_regs_info_get(
    int unit);

/*
 * SUBMODULE BUFFERS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_dram_buffers_feature_get(
    int unit,
    dnx_data_dram_buffers_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_dram_buffers_define_allowed_errors,
    dnx_data_dram_buffers_define_nof_bdbs,
    dnx_data_dram_buffers_define_nof_fpc_banks,

    /**
     * Must be last one!
     */
    _dnx_data_dram_buffers_define_nof
} dnx_data_dram_buffers_define_e;

/* Get Data */
/**
 * \brief returns numeric data of allowed_errors
 * Module - 'dram', Submodule - 'buffers', data - 'allowed_errors'
 * number of times a buffer is allowed into the quarantine FIFO before it is deleted instead of restored
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     allowed_errors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_allowed_errors_get(
    int unit);

/**
 * \brief returns define data of nof_bdbs
 * Module - 'dram', Submodule - 'buffers', data - 'nof_bdbs'
 * number of BDBs per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_nof_bdbs_get(
    int unit);

/**
 * \brief returns define data of nof_fpc_banks
 * Module - 'dram', Submodule - 'buffers', data - 'nof_fpc_banks'
 * number of free pointer controler banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fpc_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_dram_buffers_nof_fpc_banks_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_dram_buffers_table_deleted_buffers_info,

    /**
     * Must be last one!
     */
    _dnx_data_dram_buffers_table_nof
} dnx_data_dram_buffers_table_e;

/* Get Data */
/**
 * \brief get table deleted_buffers_info entry 
 * deleted buffers info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     deleted_buffers_info - returns the relevant entry values grouped in struct - see dnx_data_dram_buffers_deleted_buffers_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_dram_buffers_deleted_buffers_info_t * dnx_data_dram_buffers_deleted_buffers_info_get(
    int unit);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'dram', Submodule - 'buffers', table - 'deleted_buffers_info'
 * deleted buffers info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_buffers_deleted_buffers_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)deleted_buffers_info info
 * deleted buffers info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     deleted_buffers_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_dram_buffers_deleted_buffers_info_info_get(
    int unit);

/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_dram_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_DRAM_H_*/
/* *INDENT-ON* */
