/*
 * $Copyright: (c) 2018 Broadcom.
 * Broadcom Proprietary and Confidential. All rights reserved.$
 *  $Id$
 *  This file implements Switch specific Bus access to the PCIE Gen3 PHY.
*/
#include <sal/compiler.h>
#include <sal/core/thread.h>
#include <soc/iproc.h>
#include <soc/mcm/memregs.h>
#include <shared/bsl.h>
#include "merlin16_pcieg3_internal.h"
#include "common/srds_api_err_code.h"
#include "common/srds_api_types.h"
#include "merlin16_pcieg3_common.h"
#include "merlin16_pcieg3_functions.h"
#include "merlin16_pcieg3_dependencies.h"
#define SERDES_PMI_ADDR (0x1130)
#define SERDES_PMI_WDATA (0x1134)
#define PMI_WDATA_DATA_MASK (0xFFFF)
#define PMI_WDATA_RCMD (1 << 30)
#define PMI_WDATA_WCMD (1 << 31)
#define SERDES_PMI_RDATA (0x1138)
#define PMI_RDATA_DATA_MASK (0xFFFF)
#define PMI_RDATA_VALID  (1 << 31)
#define SERDES_PMI_RD_DONE_COUNT (1000)

/** Read a register from the currently selected Serdes IP Lane.
 * @param sa__ is an opaque state vector passed through to device access functions.
 * @param address Address of register to be read
 * @param *val value read out from the register
 * @return Error code generated by read function (returns ERR_CODE_NONE if no errors)
 */
err_code_t merlin16_pcieg3_pmd_rdt_reg(srds_access_t *sa__, uint16_t address, uint16_t *val)
{
    uint32_t data, cmd;
    int unit = sa__->unit; 
    uint32_t phyaddr = address | 1 << 27;
    uint32_t lane = (uint32_t)(merlin16_pcieg3_get_lane(sa__));

    phyaddr |= (lane & 0x1F) << 16;
    /* Accessed indirectly via the PAXB CFG IND ADDR/DATA & SERDES_PMI_ADDR/DATA regs */
    WRITE_PAXB_0_CONFIG_IND_ADDRr(unit, SERDES_PMI_ADDR);
    sal_udelay(1000);
    WRITE_PAXB_0_CONFIG_IND_DATAr(unit, phyaddr);
    sal_udelay(1000); 
    /* Initiate read cycle: */
    WRITE_PAXB_0_CONFIG_IND_ADDRr(unit, SERDES_PMI_WDATA);
    sal_udelay(1000);
    WRITE_PAXB_0_CONFIG_IND_DATAr(unit, PMI_WDATA_RCMD);
    sal_udelay(1000);
    /* Check if read is complete */
    do {
        WRITE_PAXB_0_CONFIG_IND_ADDRr(unit, SERDES_PMI_WDATA);
        sal_udelay(1000);
        READ_PAXB_0_CONFIG_IND_DATAr(unit, &cmd);
        sal_udelay(1000);        
        WRITE_PAXB_0_CONFIG_IND_ADDRr(unit, SERDES_PMI_RDATA);
        sal_udelay(1000);
        READ_PAXB_0_CONFIG_IND_DATAr(unit, &data);
        sal_udelay(1000);      
    } while (((cmd & PMI_WDATA_RCMD) != 0) || ((data & PMI_RDATA_VALID) == 0));

    *val = data;

    return ERR_CODE_NONE;
}

/** Write to a register from the currently selected Serdes IP Lane.
 * @param sa__ is an opaque state vector passed through to device access functions.
 * @param address Address of register to be written
 * @param val Value to be written to the register
 * @return Error code generated by write function (returns ERR_CODE_NONE if no errors)
 */
err_code_t merlin16_pcieg3_pmd_wr_reg(srds_access_t *sa__, uint16_t address, uint16_t val)
{
    uint32_t data;
    int unit = sa__->unit;
    uint32_t phyaddr = address | 1 << 27;
    uint32_t lane = (uint32_t)(merlin16_pcieg3_get_lane(sa__));

    phyaddr |= ((lane & 0x1F) << 16);
    /* Accessed indirectly via the PAXB CFG IND ADDR/DATA & SERDES_PMI_ADDR/DATA regs */
    WRITE_PAXB_0_CONFIG_IND_ADDRr(unit, SERDES_PMI_ADDR);
    sal_udelay(1000);
    WRITE_PAXB_0_CONFIG_IND_DATAr(unit, phyaddr);
    sal_udelay(1000);
    /* Initiate write cycle: */
    WRITE_PAXB_0_CONFIG_IND_ADDRr(unit, SERDES_PMI_WDATA);
    sal_udelay(1000);
    WRITE_PAXB_0_CONFIG_IND_DATAr(unit, PMI_WDATA_WCMD | val);
    sal_udelay(1000);
    /* Check if write is complete */
    do {
        WRITE_PAXB_0_CONFIG_IND_ADDRr(unit, SERDES_PMI_WDATA);
        sal_udelay(1000);
        READ_PAXB_0_CONFIG_IND_DATAr(unit, &data);
    } while ((data & PMI_WDATA_WCMD) != 0);

    return ERR_CODE_NONE;
}

/** Masked Register Write to the currently selected Serdes IP core/lane.
 * If using Serdes MDIO controller to access the registers, implement this function using merlin16_pcieg3_pmd_mdio_mwr_reg(..)
 *
 * If NOT using a Serdes MDIO controller or the Serdes PMI Masked write feature, please use the following code to
 * implement this function
 *
 *    merlin16_pcieg3_pmd_wr_reg(addr, ((merlin16_pmd_rd_reg(addr) & ~mask) | (mask & (val << lsb))));
 *
 * @param sa__ is an opaque state vector passed through to device access functions.
 * @param addr Address of register to be written
 * @param mask 16-bit mask indicating the position of the field with bits of 1s
 * @param lsb  LSB of the field
 * @param val  16bit value to be written
 * @return Error code generated by write function (returns ERR_CODE_NONE if no errors)
 */
err_code_t merlin16_pcieg3_pmd_mwr_reg(srds_access_t *sa__, uint16_t addr, uint16_t mask, uint8_t lsb, uint16_t val)
{
    err_code_t error_code;
    uint16_t data;    

    error_code= merlin16_pcieg3_pmd_rdt_reg(sa__, addr, &data);
    if(error_code != ERR_CODE_NONE) 
       return error_code;

    data = (data & ~mask) | (mask & (val << lsb));

    error_code = merlin16_pcieg3_pmd_wr_reg(sa__, addr, data);    

    return error_code; 
}

/** Write to a PRAM location for the currently selected Serdes IP Core.
 *  The address is auto-incrementing, per the PRAM interface specification.
 * @param sa__ is an opaque state vector passed through to device access functions.
 * @param val Value to be written
 * @return Error code generated by write function (returns ERR_CODE_NONE if no errors)
 */
err_code_t merlin16_pcieg3_pmd_wr_pram(srds_access_t *sa__, uint8_t val)
{
    return ERR_CODE_NONE;
}

/** Write message to the logger with the designated verbose level.
 * Output is sent to stdout and a logfile
 * @param message_verbose_level   Verbose level for the current message
 * @param *format Format string as in printf
 * @param ... Additional variables used as in printf
 * @return Error code generated by function (returns ERR_CODE_NONE if no errors)
 */
#ifdef SRDS_API_ALL_FUNCTIONS_HAVE_ACCESS_STRUCT
int logger_write(srds_access_t *sa__, int message_verbose_level, const char *format, ...)
{
    return ERR_CODE_NONE;
}
#endif

/** Delay the execution of the code for atleast specified amount of time in nanoseconds.
 * This function is used ONLY for delays less than 1 microsecond, non-zero error code may be returned otherwise.
 * The user can implement this as an empty function if their register access latency exceeds 1 microsecond.
 * @param delay_ns Delay in nanoseconds
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)
 */
#ifdef SRDS_API_ALL_FUNCTIONS_HAVE_ACCESS_STRUCT
err_code_t merlin16_pcieg3_delay_ns(srds_access_t *sa__, uint16_t delay_ns)
{
    uint32_t delay;
    delay = delay_ns / 1000; 
    if(!delay) {
        delay = 1;
    }
    sal_udelay(delay);
    return 0;
}
#else
err_code_t merlin16_pcieg3_delay_ns(uint16_t delay_ns)
{
    uint32_t delay;
    delay = delay_ns / 1000; 
    if(!delay) {
        delay = 1;
    }
    sal_udelay(delay);
    return 0;
}
#endif

/** Delay the execution of the code for atleast specified amount of time in microseconds.
 * For longer delays, accuracy is required. When requested delay is > 100ms, the implemented delay is assumed
 * to be < 10% bigger than requested.
 * This function is used ONLY for delays greater than or equal to 1 microsecond.
 * @param delay_us Delay in microseconds
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)
 */
#ifdef SRDS_API_ALL_FUNCTIONS_HAVE_ACCESS_STRUCT
err_code_t merlin16_pcieg3_delay_us(srds_access_t *sa__, uint32_t delay_us)
{
    sal_udelay(delay_us);
    return 0;
}
#else
err_code_t merlin16_pcieg3_delay_us(uint32_t delay_us)
{
    sal_udelay(delay_us);
    return 0;
}
#endif

/** Delay the execution of the code for atleast specified amount of time in milliseconds.
 * For longer delays, accuracy is required. When requested delay is > 100ms, the implemented delay is assumed
 * to be < 10% bigger than requested.
 * This function is used ONLY for delays greater than or equal to 1 millisecond.
 * @param delay_ms Delay in milliseconds
 * @return Error code generated by delay function (returns ERR_CODE_NONE if no errors)
 */
#ifdef SRDS_API_ALL_FUNCTIONS_HAVE_ACCESS_STRUCT
err_code_t merlin16_pcieg3_delay_ms(srds_access_t *sa__, uint32_t delay_ms)
{
    sal_udelay(delay_ms * 1000);
    return 0;
}
#else
err_code_t merlin16_pcieg3_delay_ms(uint32_t delay_ms)
{
    sal_udelay(delay_ms * 1000);
    return 0;
}
#endif

/** Return the address of current selected Serdes IP Core.
 * @param sa__ is an opaque state vector passed through to device access functions.
 * @return the IP level address of the current core.
 */
uint8_t merlin16_pcieg3_get_core(srds_access_t *sa__)
{
    return 0;
}

/** Return the address of current selected Serdes IP lane.
 * @param sa__ is an opaque state vector passed through to device access functions.
 * @return the IP level address of the current lane. 0 to N-1, for an N lane IP
 */
uint8_t merlin16_pcieg3_get_lane(srds_access_t *sa__)
{
    uint8_t lane_index;

    if(sa__->lane_mask == 0x1) {
        lane_index = 0;
    } else if(sa__->lane_mask == 0x2) {
        lane_index = 1;
    } else if(sa__->lane_mask == 0x4) {
        lane_index = 2;
    } else if(sa__->lane_mask == 0x8) {
        lane_index = 3;
    } else {
        lane_index = 0;
    }
    return (sa__->core + lane_index);
}

/** Set the address of current selected Serdes IP lane.  Used in diagnostic
 * and core-level management functions.
 * @param sa__ is an opaque state vector passed through to device access functions.
 * @param lane_index is the lane index
 * @return Any error code generated during execution; ERR_CODE NONE otherwise.
 */
err_code_t merlin16_pcieg3_set_lane(srds_access_t *sa__, uint8_t lane_index)
{
    
    sa__->core = (lane_index/4); /* Four lanes per core */
    sa__->lane_mask = (1 << (lane_index % 4));

    return ERR_CODE_NONE;
}


