diff -rpN '--unified=6' sdk-all-6.5.5/include/appl/diag/cmdlist.h esw_sdk_modified/include/appl/diag/cmdlist.h
--- sdk-all-6.5.5/include/appl/diag/cmdlist.h	2016-07-30 00:54:20.000000000 +0100
+++ esw_sdk_modified/include/appl/diag/cmdlist.h	2018-01-26 11:20:46.610358520 +0000
@@ -52,13 +52,13 @@
 
 #include <appl/diag/parse.h>
 #include <appl/diag/shell.h>
 
 #if defined(MOUSSE) || defined(BMW) || defined(IDTRP334) || defined(GTO) || \
     defined(MBZ) || defined(IDT438) || defined(NSX) || defined(ROBO_4704) || \
-    defined(METROCORE) || defined(KEYSTONE)
+    defined(METROCORE) || defined(KEYSTONE) || defined(LVL7_FIXUP)
 #ifdef VXWORKS
 #include <config.h>      /* For INCLUDE_XXX */
 #endif
 #endif
 
 #define DCL_CMD(_f,_u)  \
@@ -270,21 +270,21 @@ DCL_CMD(dbg_bkpmon, bkpmon_usage)
 
 DCL_CMD(cmd_esw_dump,   cmd_esw_dump_usage)
 DCL_CMD(cmd_robo_dump,  cmd_robo_dump_usage)
 /* txrx.c */
 
 DCL_CMD(cmd_esw_tx,     cmd_esw_tx_usage)
-DCL_CMD(cmd_esw_tx_start,   cmd_esw_tx_start_usage)
+DCL_CMD(cmd_esw_tx_start,   cmd_esw_tx_usage)
 DCL_CMD(cmd_esw_tx_stop,    cmd_esw_tx_stop_usage)
 DCL_CMD(cmd_esw_tx_count,   cmd_esw_tx_count_usage)
 DCL_CMD(cmd_esw_rx_cfg, cmd_esw_rx_cfg_usage)
 DCL_CMD(cmd_esw_rx_init,    cmd_esw_rx_init_usage)
 DCL_CMD(cmd_esw_rx_mon, cmd_esw_rx_mon_usage)
 
 DCL_CMD(cmd_robo_tx,        cmd_robo_tx_usage)
-DCL_CMD(cmd_robo_tx_start,  cmd_robo_tx_start_usage)
+DCL_CMD(cmd_robo_tx_start,  cmd_robo_tx_usage)
 DCL_CMD(cmd_robo_tx_stop,   cmd_robo_tx_stop_usage)
 DCL_CMD(cmd_robo_tx_count,  cmd_robo_tx_count_usage)
 DCL_CMD(cmd_robo_rx_cfg,    cmd_robo_rx_cfg_usage)
 DCL_CMD(cmd_robo_rx_init,   cmd_robo_rx_init_usage)
 DCL_CMD(cmd_robo_rx_mon,    cmd_robo_rx_mon_usage)
 
diff -rpN '--unified=6' sdk-all-6.5.5/include/appl/stktask/attach.h esw_sdk_modified/include/appl/stktask/attach.h
--- sdk-all-6.5.5/include/appl/stktask/attach.h	2016-07-30 00:54:21.000000000 +0100
+++ esw_sdk_modified/include/appl/stktask/attach.h	2018-01-26 11:20:46.678358520 +0000
@@ -67,7 +67,13 @@ extern int bcm_stack_attach_unregister(b
 
 extern int bcm_stack_attach_update(cpudb_ref_t db_ref);
 extern int bcm_stack_attach_running(void);
 extern int bcm_stack_attach(cpudb_ref_t db_ref);
 extern int bcm_stack_detach(cpudb_ref_t db_ref);
 
+#ifdef LVL7_FIXUP
+int bcm_stack_attach_manager_set(int manager);
+void bcm_stack_attach_fn(cpudb_ref_t topology_db, int local_cpu_only, 
+			 int detach_only);
+#endif
+
 #endif /* _STKTASK_ATTACH_H */
diff -rpN '--unified=6' sdk-all-6.5.5/include/bcm/custom.h esw_sdk_modified/include/bcm/custom.h
--- sdk-all-6.5.5/include/bcm/custom.h	2016-07-30 00:54:21.000000000 +0100
+++ esw_sdk_modified/include/bcm/custom.h	2018-01-26 11:20:52.590358520 +0000
@@ -51,14 +51,18 @@
 #ifndef __BCM_CUSTOM_H__
 #define __BCM_CUSTOM_H__
 
 #include <bcm/types.h>
 
 #if !defined(BCM_CUSTOM_ARGS_MAX)
+#ifdef LVL7_FIXUP
+#define BCM_CUSTOM_ARGS_MAX     375       
+#else
 #define BCM_CUSTOM_ARGS_MAX     256        
 #endif
+#endif
 
 #define BCM_CUSTOM_SET          1          
 #define BCM_CUSTOM_GET          2          
 
 /* bcm_custom_cb_t */
 typedef int (*bcm_custom_cb_t)(
diff -rpN '--unified=6' sdk-all-6.5.5/include/bcm/field.h esw_sdk_modified/include/bcm/field.h
--- sdk-all-6.5.5/include/bcm/field.h	2016-07-30 00:54:21.000000000 +0100
+++ esw_sdk_modified/include/bcm/field.h	2018-01-26 11:20:52.606358520 +0000
@@ -4991,12 +4991,18 @@ typedef struct bcm_field_group_status_s
     int counters_free;  /* Unused counters in slice. */
     int meters_total;   /* Total meters in slice. */
     int meters_free;    /* Unused meters in slice. */
     int entry_count;    /* Number of entries in the group. */
     int counter_count;  /* Number of counters attached to group entries. */
     int meter_count;    /* Number of meters attached to group entries. */
+#ifdef LVL7_FIXUP
+    int slice_width_physical;   /* Slice width of group based on physical slices. */
+    int intraslice_mode_enable; /* Indicates if intraslice mode is enabled. */
+    int natural_depth;          /* Number of rules when slice depth is one. */
+#endif
+
 } bcm_field_group_status_t;
 
 /* Group Modes (single, double or triple wide). */
 typedef enum bcm_field_group_mode_e {
     bcmFieldGroupModeSingle = 0,        /* Single-wide group. */
     bcmFieldGroupModeDouble = 1,        /* Double-wide group. */
diff -rpN '--unified=6' sdk-all-6.5.5/include/bcm/types.h esw_sdk_modified/include/bcm/types.h
--- sdk-all-6.5.5/include/bcm/types.h	2016-07-30 00:54:21.000000000 +0100
+++ esw_sdk_modified/include/bcm/types.h	2018-01-26 11:20:52.578358520 +0000
@@ -72,14 +72,18 @@ typedef int bcm_multicast_t;
 #define BCM_LOCAL_UNITS_MAX     18         
 #endif
 
 #define BCM_MAX_NUM_UNITS       BCM_LOCAL_UNITS_MAX 
 
 #if !defined(BCM_UNITS_MAX)
+#if defined(LVL7_FIXUP) && defined(L7_PRODUCT_SMARTPATH)
+#define BCM_UNITS_MAX           8
+#else
 #define BCM_UNITS_MAX           128        
 #endif
+#endif
 
 #define BCM_PBMP_PORT_MAX       _SHR_PBMP_PORT_MAX 
 
 #define BCM_PBMP_CLEAR(pbm)     _SHR_PBMP_CLEAR(pbm) 
 #define BCM_PBMP_MEMBER(bmp, port)  _SHR_PBMP_MEMBER((bmp), (port)) 
 #define BCM_PBMP_ITER(bmp, port)  _SHR_PBMP_ITER((bmp), (port)) 
diff -rpN '--unified=6' sdk-all-6.5.5/include/bcm/vlan.h esw_sdk_modified/include/bcm/vlan.h
--- sdk-all-6.5.5/include/bcm/vlan.h	2016-07-30 00:54:21.000000000 +0100
+++ esw_sdk_modified/include/bcm/vlan.h	2018-01-26 11:20:52.594358520 +0000
@@ -2268,12 +2268,14 @@ extern int bcm_vlan_port_stat_multi_set3
                                                           added when a packet
                                                           egress out from this
                                                           VLAN port. */
 #define BCM_VLAN_PORT_NATIVE                0x00200000 /* Creates a native vlan
                                                           port. */
 
+#define BCM_VLAN_PORT_INNER_VLAN_REPLACE    0x01000000  /* PTin added: Replace the port inner vid */
+
 /* Logical layer 2 port match criteria */
 typedef enum bcm_vlan_port_match_e {
     BCM_VLAN_PORT_MATCH_INVALID = 0,    /* Illegal. */
     BCM_VLAN_PORT_MATCH_NONE = 1,       /* No source match criteria. */
     BCM_VLAN_PORT_MATCH_PORT = 2,       /* {Module, Port} or Trunk. */
     BCM_VLAN_PORT_MATCH_PORT_VLAN = 3,  /* Mod/port/trunk + outer VLAN. */
diff -rpN '--unified=6' sdk-all-6.5.5/include/sal/core/alloc.h esw_sdk_modified/include/sal/core/alloc.h
--- sdk-all-6.5.5/include/sal/core/alloc.h	2016-07-30 00:54:22.000000000 +0100
+++ esw_sdk_modified/include/sal/core/alloc.h	2018-01-26 11:20:46.266358520 +0000
@@ -46,23 +46,40 @@
  * Purpose: 	Memory allocation
  */
 
 #ifndef _SAL_ALLOC_H
 #define _SAL_ALLOC_H
 
+#if ((defined(LVL7_FIXUP)) && (defined(L7_SAL_MAP_TO_OSAPI)) && (!defined(__KERNEL__)))
+#include "osapi.h"
+#endif
+
 /*
  * SAL Memory and Cache Support
  *
  *    NOTE: This driver was developed only on fully cache-coherent
  *    systems.  Therefore, we are certain to have missed a lot of places
  *    where we should be calling sal_dma_flush or sal_dma_inval before
  *    or after DMA operations.
  */
 
+/* Map sal_alloc/sal_free to osapi Api's except for 
+** - MIPS64 cpu: SDK has some special code for MIPS64 in sal_alloc.
+** - Linux kernel mode
+** - Smartpath product
+*/
+#if ((defined(LVL7_FIXUP)) && (defined(L7_SAL_MAP_TO_OSAPI)) && (!defined(__KERNEL__)))
+#define sal_alloc(sz,str) osapiMalloc(L7_DRIVER_COMPONENT_ID, sz)
+#define sal_free(ptr) osapiFree(L7_DRIVER_COMPONENT_ID, ptr)
+
+#else
+
 extern void *sal_alloc(unsigned int, char *);
 extern void  sal_free(void *);
+#endif
+
 extern void sal_get_alloc_counters(unsigned long *alloc_bytes_count,unsigned long *free_bytes_count);
 
 /*
  * DMA Memory allocation
  *
  */
diff -rpN '--unified=6' sdk-all-6.5.5/include/sal/core/boot.h esw_sdk_modified/include/sal/core/boot.h
--- sdk-all-6.5.5/include/sal/core/boot.h	2016-07-30 00:54:22.000000000 +0100
+++ esw_sdk_modified/include/sal/core/boot.h	2018-01-26 11:20:46.270358520 +0000
@@ -103,13 +103,12 @@ extern void _default_assert(const char *
 
 /*
  * Init
  */
 extern int sal_core_init(void);
 
-
 /*
  * Returns a string describing the current Operating System
  */
 extern const char* sal_os_name(void); 
 
 
diff -rpN '--unified=6' sdk-all-6.5.5/include/sdk_custom_config.h esw_sdk_modified/include/sdk_custom_config.h
--- sdk-all-6.5.5/include/sdk_custom_config.h	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/include/sdk_custom_config.h	2018-01-26 11:20:52.358358520 +0000
@@ -0,0 +1,84 @@
+/*********************************************************************
+*
+* (C) Copyright Broadcom Corporation 2000-2007
+*
+**********************************************************************
+*
+* @filename  sdk_custom_config.h
+*
+* @purpose   Overrides for constants defined by the ESW SDK. 
+*
+* @component Driver
+*
+* @comments  This file is specific to FASTPATH/SmartPATH. 
+*
+* @create    3/24/2009
+*
+* @author    cmutter
+*
+* @end
+*
+**********************************************************************/
+#ifndef _SDK_CUSTOM_CONFIG_H
+#define _SDK_CUSTOM_CONFIG_H
+
+#include "flex.h"
+
+#define BCM_RLINK_RX_REMOTE_MAX_DEFAULT {10, 10, 10, 80, 80, 0, 0, 0}
+#define BCM_RLINK_L2_REMOTE_MAX_DEFAULT 0
+
+#ifdef L7_PRODUCT_SMARTPATH
+
+#define SOC_MAX_NUM_SWITCH_DEVICES 2
+#define SAL_THREAD_STKSZ 16384
+
+#else /* Not SmartPATH */
+
+#define SAL_THREAD_STKSZ 32768
+
+#endif /* Not SmartPATH */
+
+#if defined(L7_PRODUCT_SMB) || defined(L7_PRODUCT_SMARTPATH)
+
+#define BCM_RX_POOL_COUNT_DEFAULT 96
+
+#else /* Not SMB or SmartPATH */
+
+#define BCM_RX_POOL_COUNT_DEFAULT 384
+
+#endif /* Not SMB or SmartPATH */
+
+#if defined(L7_PRODUCT_SMARTPATH)
+#define BCM_LOCAL_UNITS_MAX     8
+#else
+#define BCM_LOCAL_UNITS_MAX     18
+#endif
+
+#if (defined(L7_PRODUCT_SMB) || defined(L7_PRODUCT_SMARTPATH))
+#define CT_TUNNEL_QUEUE_SIZE 64
+#else
+#define CT_TUNNEL_QUEUE_SIZE 256
+#endif
+
+#ifdef PC_LINUX_HOST
+#define ATP_RETRY_TIMEOUT_DEFAULT 10000000
+#else
+#define ATP_RETRY_TIMEOUT_DEFAULT 1000000
+#endif
+#define ATP_RETRY_COUNT_DEFAULT   20
+
+  /*
+  **       The RPC timeout interval is chosen to be twice the overall ATP 
+  **       timeout. Since transaction requires two ATP transfers plus some work on 
+  **       remote unit, the timeout should theoretically be twice the ATP 
+  **       timeout plus some processing time, but since we use a very long ATP
+  **       timeout we ignore the processing time delay.
+  */
+#define RPC_REPLY_TIMEOUT (2 * ATP_RETRY_TIMEOUT_DEFAULT * ATP_RETRY_COUNT_DEFAULT)
+
+
+#if L7_FEAT_CUSTOM_MMU
+#include "brd_e2e_overrides.h"
+#endif
+
+#endif /* _SDK_CUSTOM_CONFIG_H */
diff -rpN '--unified=6' sdk-all-6.5.5/include/shared/alloc.h esw_sdk_modified/include/shared/alloc.h
--- sdk-all-6.5.5/include/shared/alloc.h	2016-07-30 00:54:22.000000000 +0100
+++ esw_sdk_modified/include/shared/alloc.h	2018-01-26 11:20:46.322358520 +0000
@@ -55,9 +55,11 @@
  * 
  * This allows all code within the SDK to use the NULL-safe version without
  * affecting existing SAL implementations or external codebases.
  *
  */
 
+#if (!((defined(LVL7_FIXUP)) && (defined(L7_SAL_MAP_TO_OSAPI)) && (!defined(__KERNEL__))))
 #define sal_free sal_free_safe
+#endif
  
 #endif /* _SHR_ALLOC_H */
diff -rpN '--unified=6' sdk-all-6.5.5/include/shared/bslext.h esw_sdk_modified/include/shared/bslext.h
--- sdk-all-6.5.5/include/shared/bslext.h	2016-07-30 00:54:22.000000000 +0100
+++ esw_sdk_modified/include/shared/bslext.h	2018-01-26 11:20:46.334358520 +0000
@@ -55,8 +55,12 @@
 extern void
 bsl_config_t_init(bsl_config_t *config);
 
 extern int
 bsl_init(bsl_config_t *config);
 
+/* PTin added: BSL LOG */
+extern int
+bsl_vectors_get(bsl_config_t * dst);
+
 #endif /* _SHR_BSLEXT_H_ */
 
diff -rpN '--unified=6' sdk-all-6.5.5/include/soc/arl.h esw_sdk_modified/include/soc/arl.h
--- sdk-all-6.5.5/include/soc/arl.h	2016-07-30 00:54:25.000000000 +0100
+++ esw_sdk_modified/include/soc/arl.h	2018-01-26 11:20:47.426358520 +0000
@@ -50,18 +50,25 @@
  */
 
 #ifndef _SOC_ARL_H
 #define _SOC_ARL_H
 
 #include <shared/avl.h>
+
+/* PTin modified: SDK 6.3.0 */
+#ifdef LVL7_FIXUP
+#include <soc/mcm/memregs.h>
+#include <soc/robo/mcm/memregs.h>
+#else
 #if defined(BCM_ESW_SUPPORT) || defined(BCM_SBX_SUPPORT) || defined(BCM_SAND_SUPPORT)
 #include <soc/mcm/memregs.h>
 #endif
 #ifdef BCM_ROBO_SUPPORT        
 #include <soc/robo/mcm/memregs.h>
 #endif
+#endif
 
 extern int soc_arl_attach(int unit);
 extern int soc_arl_detach(int unit);
 extern int soc_arl_init(int unit);
 
 
diff -rpN '--unified=6' sdk-all-6.5.5/include/soc/debug.h esw_sdk_modified/include/soc/debug.h
--- sdk-all-6.5.5/include/soc/debug.h	2016-07-30 00:54:25.000000000 +0100
+++ esw_sdk_modified/include/soc/debug.h	2018-01-26 11:20:51.690358520 +0000
@@ -62,13 +62,13 @@ extern void soc_mem_watch_set(int unit,
 #define _SOC_MSG(string) "%s[%d]%s unit %d: " string "\n", __FILE__, __LINE__, FUNCTION_NAME(), unit
 
 #define _BSL_SOC_MSG(string) _ERR_MSG_MODULE_NAME, unit, "%s[%d]%s unit %d: " string "\n", __FILE__, __LINE__, FUNCTION_NAME(), unit
 
 #else
 
-#define _SOC_MSG(string) string
+#define _SOC_MSG(string) string "\n"
 
-#define _BSL_SOC_MSG(string) _ERR_MSG_MODULE_NAME, unit, string
+#define _BSL_SOC_MSG(string) _ERR_MSG_MODULE_NAME, unit, string "\n"
 
 #endif   /* defined(BROADCOM_DEBUG) */
 
 #endif  /* !_SOC_DEBUG_H */
diff -rpN '--unified=6' sdk-all-6.5.5/include/soc/drv_if.h esw_sdk_modified/include/soc/drv_if.h
--- sdk-all-6.5.5/include/soc/drv_if.h	2016-07-30 00:54:25.000000000 +0100
+++ esw_sdk_modified/include/soc/drv_if.h	2018-01-26 11:20:47.342358520 +0000
@@ -765,12 +765,22 @@ typedef struct{
 	int (*led_funcgrp_select_get)(int unit,int port,int *led_group);
 	int (*led_funcgrp_select_set)(int unit,int port,int led_group);
 	int (*led_mode_get)(int unit,int port,uint32 *led_mode);
 	int (*led_mode_set)(int unit,int port,uint32 led_mode);
 	int (*igmp_mld_snoop_mode_get)(int unit,int type,int *mode);
 	int (*igmp_mld_snoop_mode_set)(int unit,int type,int mode);
+    /* Egress vlan tranlation */
+#ifdef LVL7_FIXUP
+    int (*vlan_evt_entry_add)(int unit, int port, int *evr_id, int out_op, uint16 out_vid,
+                              int in_op, uint16 in_vid);
+    int (*vlan_evt_entry_delete)(int unit, int port, int evr_id);
+    int (*vlan_evt_entry_get)(int unit, int port, int evr_id, int *out_op, uint16 *out_vid,
+                              int *in_op, uint16 *in_vid);
+    int (*vlan_evt_entry_modify)(int unit, int port, int evr_id, int out_op, uint16 out_vid,
+                              int in_op, uint16 in_vid);
+#endif
 	int (*wred_init)(int unit);
 	int (*wred_config_create)(int unit,uint32 flags,drv_wred_config_t *config,int *wred_id);
 	int (*wred_config_set)(int unit,int wred_id,drv_wred_config_t *config);
 	int (*wred_config_get)(int unit,int wred_id,drv_wred_config_t *config);
 	int (*wred_config_destroy)(int unit,int wred_id);
 	int (*wred_map_attach)(int unit,int wred_id,drv_wred_map_info_t *map);
diff -rpN '--unified=6' sdk-all-6.5.5/include/soc/field.h esw_sdk_modified/include/soc/field.h
--- sdk-all-6.5.5/include/soc/field.h	2016-07-30 00:54:25.000000000 +0100
+++ esw_sdk_modified/include/soc/field.h	2018-01-26 11:20:51.686358520 +0000
@@ -52,15 +52,20 @@
 #include <soc/types.h>
 #if defined(BCM_ESW_SUPPORT) || defined(BCM_SBX_SUPPORT) || defined(BCM_SAND_SUPPORT) || defined(PORTMOD_SUPPORT)
 #include <soc/mcm/allenum.h>
 #endif
 #include <soc/schanmsg.h>
 #include <soc/types.h>
+/* PTin modified: SDK 6.3.0 */
+#ifdef LVL7_FIXUP
+#include <soc/robo/mcm/allenum.h>
+#else
 #ifdef BCM_ROBO_SUPPORT
 #include <soc/robo/mcm/allenum.h>
 #endif      
+#endif
 
 #ifdef BCM_EA_SUPPORT    
 #include <soc/ea/allenum.h>
 #endif
 
 /* Values for flags */
diff -rpN '--unified=6' sdk-all-6.5.5/include/soc/i2c.h esw_sdk_modified/include/soc/i2c.h
--- sdk-all-6.5.5/include/soc/i2c.h	2016-07-30 00:54:25.000000000 +0100
+++ esw_sdk_modified/include/soc/i2c.h	2018-01-26 11:20:47.354358520 +0000
@@ -193,12 +193,16 @@ extern int soc_i2c_is_attached(int unit)
 extern void soc_i2c_show_log(int unit, int reverse);
 extern void soc_i2c_clear_log(int unit);
 extern void soc_i2c_show_speeds(int unit);
 extern char *soc_i2c_saddr_to_string(int unit, i2c_saddr_t saddr);
 extern int soc_i2c_unload_devices(int unit);
 
+#ifdef LVL7_FIXUP
+extern int soc_i2c_read_test(int unit, uint8 devid, uint8 *ptr, int len);
+extern int soc_i2c_write_test(int unit, uint8 devid, uint8 *ptr, int len);
+#endif
 /*
  * SMB commands
  */
 extern int soc_i2c_read_byte(int unit, i2c_saddr_t saddr, uint8* data);
 extern int soc_i2c_write_byte(int unit, i2c_saddr_t saddr, uint8 data);
 extern int soc_i2c_read_word(int unit, i2c_saddr_t saddr, uint16* data);
diff -rpN '--unified=6' sdk-all-6.5.5/include/soc/macipadr.h esw_sdk_modified/include/soc/macipadr.h
--- sdk-all-6.5.5/include/soc/macipadr.h	2016-07-30 00:54:25.000000000 +0100
+++ esw_sdk_modified/include/soc/macipadr.h	2018-01-26 11:20:47.034358520 +0000
@@ -50,12 +50,13 @@
 #define _SYS_MACIPADR_H
 
 #include <sal/core/libc.h>
 #include <soc/types.h>
 #include <shared/l3.h>
 
+typedef uint8   mac_addr_t[6];          /* MAC address */   /* PTin added: SDK compatibility */
 typedef _shr_ip_addr_t  ip_addr_t;      /* IP Address */
 typedef _shr_ip6_addr_t  ip6_addr_t;    /* IPv6 Address */
 
 extern const sal_mac_addr_t _soc_mac_spanning_tree;
 extern const sal_mac_addr_t _soc_mac_all_routers;
 extern const sal_mac_addr_t _soc_mac_all_zeroes;
diff -rpN '--unified=6' sdk-all-6.5.5/include/soc/phy.h esw_sdk_modified/include/soc/phy.h
--- sdk-all-6.5.5/include/soc/phy.h	2016-07-30 00:54:25.000000000 +0100
+++ esw_sdk_modified/include/soc/phy.h	2018-01-26 11:20:51.690358520 +0000
@@ -699,12 +699,37 @@ typedef struct soc_phy_wcmod_uc_desc_s{
 /* Forward def */
 typedef struct soc_phy_table_s soc_phy_table_t;
 typedef int (*soc_phy_ident_f)(int unit, soc_port_t port,
                                soc_phy_table_t *my_entry,
                                uint16 phy_id0, uint16 phy_id1,
                                soc_phy_info_t *pi);
+#ifdef LVL7_FIXUP
+/* SDK only provides a way to configure a single phy address for
+ * each port, whereas some of the customer boxes have different
+ * phy addresses for same port. So we use the custom driver
+ * (registered in FP application) checkphy fuction to look for
+ * device ids at the secondary phy addresses, and return SUCESS
+ * if match is successful). _ext_phy_probe() uses two pointer
+ * variables - pi and ext_pc. We manage to run our own custom
+ * _check_phy function, which does the OUI check for us. But
+ * our requirement is to change the phy addresses and other
+ * parameters maintained in structures pointed to by pi
+ * (soc_phy_info_t) and ext_pc(phy_ctrl_t), in  case the match
+ * is successful.  We don't have a way to do that unless we run
+ * our custom function below, or SDK functions are re-designed
+ * to facilitate this operation.
+ */
+typedef int (*soc_phy_cust_f)(int unit, soc_port_t port,
+                              soc_phy_table_t *my_entry,
+                              soc_phy_info_t *pi, phy_ctrl_t *int_pc);
+struct soc_phy_cust_s
+{
+    soc_phy_cust_f  custPhySettings;
+};
+typedef struct soc_phy_cust_s soc_phy_cust_t;
+#endif
 
 /* For identifying phy */
 struct soc_phy_table_s {
     soc_phy_ident_f     checkphy;       /* call back to check for this phy */
     soc_known_phy_t     myNum;          /* For known phys, its enum val */
     char                *phy_name;      /* Phy Name */
diff -rpN '--unified=6' sdk-all-6.5.5/include/soc/property.h esw_sdk_modified/include/soc/property.h
--- sdk-all-6.5.5/include/soc/property.h	2016-07-30 00:54:25.000000000 +0100
+++ esw_sdk_modified/include/soc/property.h	2018-01-26 11:20:46.942358520 +0000
@@ -492,12 +492,16 @@
 /* This specifies the external PHY device is BCM5690. */
 #define spn_PHY_5690  "phy_5690"
 
 /* This specifies the external PHY device is BCM8706 and equivalent. */
 #define spn_PHY_8706  "phy_8706"
 
+#ifdef LVL7_FIXUP
+#define spn_PHY_VIRTUALCOMBO            "phy_virtualcombo"
+#endif
+
 /* This specifies the external PHY device is BCM8072 and equivalent. */
 #define spn_PHY_8072  "phy_8072"
 
 /* This specifies the external PHY device is BCM84740. */
 #define spn_PHY_84740  "phy_84740"
 
@@ -2618,12 +2622,26 @@
  * cannot be used with :i.
  *  Valid Phy lane configs: 442/244/343. Valid fallback phy options: 0/1/2. Applicable to BCM56860 device family.
  * Example: portmap_1 = 1:100:343
  *          portmap_1 = 1:40:2
  */
 #define spn_PORTMAP  "portmap"
+#ifdef LVL7_FIXUP
+#define spn_PORT_PHY_ADDR "port_phy_addr"
+#define spn_LED_MODE_CUST "led_mode_cust"
+#define spn_PORT_PHY_ADDR_XE            "port_phy_addr_xe"
+#define spn_PORT_COMBO_VIRTUAL_PHY      "port_combo_virtual_phy"
+#define spn_PORT_VIRTUAL_PHY_ADDR       "port_virtual_phy_addr"
+#define spn_PORT_VIRTUAL_PREF_PHYNUM    "port_virtual_pref_phy"
+#define spn_PORT_VIRTUAL_ACTIVE_DRIV    "port_virtual_activ_driv"
+#define spn_BCM56638_4X12_2X24          "bcm56638_4x12_2x24"
+#define spn_HELPCLI_ENABLE              "help_cli_enable"
+#define spn_SERDES_LANE0_RESET          "serdes_lane0_reset"
+#define spn_PORT_INTERNAL               "port_internal"
+#define spn_PORT_SUPER_ISOLATE          "port_super_isolate"
+#endif
 /*
  * Specifies the number of lanes used by each port in the flex port group.
  * portgroup_<port group>=<number of lanes>.
  * Applicable to BCM566xx and BCM565xx device family
  *  Example:
  *    portgroup_<port_group> = 1
diff -rpN '--unified=6' sdk-all-6.5.5/make/Make.config esw_sdk_modified/make/Make.config
--- sdk-all-6.5.5/make/Make.config	2016-07-30 00:54:33.000000000 +0100
+++ esw_sdk_modified/make/Make.config	2018-01-26 11:20:52.730358520 +0000
@@ -55,12 +55,13 @@ endif
 
 ifeq (${BCM_HIDE_DISPATCHABLE},1)
 # {
 CFGFLAGS += -DBCM_HIDE_DISPATCHABLE
 # }
 endif
+LVL7_FIXUP = 1
 
 ifeq (${WAN_PORT_SUPPORT},1)
 # {
 CFGFLAGS += -DWAN_PORT_SUPPORT
 # }
 endif
@@ -808,13 +809,13 @@ endif
 # }
 endif
 
 ifdef ESW_CHIPS
 # {
 _ESW_FEATURE_LIST = L3 I2C BCMX BCMX_DIAG MEM_SCAN EDITLINE RCPU OOB_RCPU CUSTOMER \
-    TEST CHASSIS CINT PTP BFD TCB PSTATS
+    TEST CHASSIS CINT PTP		#PTIN changed (original on next line)
 #
 # CES is only supported on Katana devices.
 #
 ifdef BCM_56440_A0 
 # {
 _ESW_FEATURE_LIST += CES
@@ -887,13 +889,13 @@ ifdef DNXF_CHIPS
 _DNXF_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT
 # }
 endif
 
 _ALL_FEATURE_LIST = ${_ROBO_FEATURE_LIST} ${_ESW_FEATURE_LIST} \
 		${_SBX_FEATURE_LIST} ${_EA_FEATURE_LIST} ${_DPP_FEATURE_LIST} \
-		${_DFE_FEATURE_LIST} ${_DNX_FEATURE_LIST} ${_DNXF_FEATURE_LIST}
+		${_DFE_FEATURE_LIST} ${_DNX_FEATURE_LIST} ${_DNXF_FEATURE_LIST} ${SDK_FEATURE_LIST_ADD}
 
 FEATURE_LIST = $(sort ${_ALL_FEATURE_LIST})
 
 ifeq ($(targetbase),vxworks)
 # {
 FEATURE_LIST +=	TELNET
@@ -1386,12 +1388,15 @@ endif
 all_suffix = ${chip_suffix}${target_suffix}
 
 #
 # Default location to place binaries and make depend files for building
 # purposes.
 #
+ifdef LVL7_FIXUP
+BLDROOT = $(L7_OUTPUT)/$(target)${all_suffix}${bldroot_suffix}
+else
 ifeq "$(HOSTTYPE)" "Windows2000PC"
 # {
 BLDROOTWITHDRIVE = ${SDK}/build/${target}${all_suffix}${bldroot_suffix}
 BLDROOT = ${SDK_NO_DRIVE_NAME}/build/${target}${all_suffix}${bldroot_suffix}
 # }
 else # ifeq "$(HOSTTYPE)" "Windows2000PC"
@@ -1416,12 +1421,14 @@ ifeq ($(MAKELEVEL),0)
 # {
 # }
 endif
 # }
 endif
 
+endif #end LVL7_FIXUP 
+
 ifeq ($(DEST_DIR),)
 # {
 export DEST_DIR :=${SDK}/${SDKBUILD}$(if ${BLDCONFIG},/${BLDCONFIG})$(DEST_DIR_SUFFIX)
 # }
 endif
 
@@ -1732,12 +1739,17 @@ INCDIR += -I${SDK}/src/soc/phy/phy8806x/
 INCFLAGS = -I${INCDIR} -I${SDK}/systems
 
 CFLAGS += ${INCFLAGS}
 CXXFLAGS += ${INCFLAGS}
 CPPFLAGS += ${INCFLAGS}
 
+ifdef LVL7_FIXUP
+CFLAGS += $(L7_BCM_VENDOR_INCL) $(L7_BCM_VENDOR_CFLAGS)
+CXXFLAGS += $(L7_BCM_VENDOR_INCL)
+CPPFLAGS += $(L7_BCM_VENDOR_INCL)
+endif
 #
 # Debug #ifdef control
 #
 # Compiling out #ifdef DEBUG code saves about 1.3% on executable size.
 # It is recommended to leave debug enabled when developing applications.
 #
diff -rpN '--unified=6' sdk-all-6.5.5/make/Makefile.linux-CXO2T4-e500mc-3_x esw_sdk_modified/make/Makefile.linux-CXO2T4-e500mc-3_x
--- sdk-all-6.5.5/make/Makefile.linux-CXO2T4-e500mc-3_x	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/Makefile.linux-CXO2T4-e500mc-3_x	2018-01-26 11:20:52.718358520 +0000
@@ -0,0 +1,281 @@
+# $Id: Makefile.linux-gto-2_6,v 1.28 Broadcom SDK $
+# $Copyright: Copyright 2010 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+# User must select one platform from below.By default WR_LINUX is selected. .
+ifeq (,$(BUILD_PLATFORM))
+#BUILD_PLATFORM=ELDK
+BUILD_PLATFORM=WR_LINUX
+endif
+
+# Specify the ELDK version you want to use for building SDK.
+ifeq (,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+ELDK_VERSION=4.0
+endif
+endif
+
+# Specify the KERNEL VERSION  you want to use for building SDK.
+ifeq (,$(KERN_VER))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KERN_VER=4.1.8
+#2.6.21.7
+endif
+endif
+
+
+# Specify the Windriver Linux version here.For example '2.0' as shown below.
+ifeq (WR_LINUX,$(BUILD_PLATFORM))
+ifeq (,$(WRS_LINUX_VERSION))
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=2.6.27
+endif
+endif
+
+
+#glibc_small and glibc_std have their own cross-compilation tools and and path for these tools are different as implemented below. To enable glibc_small build, line given below should be uncommented.
+
+#WRL_GLIBC_SMALL=TRUE
+
+ifeq (2.0,$(WRS_LINUX_VERSION))
+ifeq ($(WRL_GLIBC_SMALL),TRUE)
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= $(KERNEL_PATH)
+
+else
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= $(KERNEL_PATH)
+
+endif 
+
+export WRL_GLIBC_SMALL
+
+# After this point glibc_std and glibc_small share these flags
+
+WRLINUX_BASE ?=/tools/windriver/linux_ed/2.0_GA/Linux
+TOOLCHAIN_EXEC_PREFIX=$(WRLINUX_BASE)/gnu/4.1-wrlinux-2.0/x86-linux2
+TOOLCHAIN_BIN_DIR=$(TOOLCHAIN_EXEC_PREFIX)
+WIND_LIC_PROXY=$(WRLINUX_BASE)/setup/x86-linux2/bin
+WRLINUX_GNU_PATH = $(WRLINUX_BASE)/gnu/4.1-wrlinux-2.0/x86-linux2/bin
+override PATH := $(TOOLCHAIN_EXEC_PREFIX):$(KERNDIR)/../../host-cross/bin:$(KERNDIR)/../../host-cross/powerpc-wrs-linux-gnu/bin:$(WRLINUX_GNU_PATH):$(PATH)
+export TOOLCHAIN_EXEC_PREFIX TOOLCHAIN_BIN_DIR WIND_LIC_PROXY
+endif
+
+
+ifeq (3.0,$(WRS_LINUX_VERSION))
+ifeq ($(WRL_GLIBC_SMALL),TRUE)
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+KERNDIR_STD ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+
+else
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= $(KERNEL_PATH)
+KERNDIR_STD ?= $(KERNEL_PATH)
+
+endif 
+
+export WRL_GLIBC_SMALL
+
+# After this point glibc_std and glibc_small share these flags
+
+WRLINUX_BASE ?=/tools/windriver/linux_ed/3.0/Linux
+TOOLCHAIN_EXEC_PREFIX=$(WRLINUX_BASE)/wrlinux-3.0/layers/wrll-toolchain-4.3-85/powerpc/toolchain/x86-linux2
+TOOLCHAIN_BIN_DIR=$(TOOLCHAIN_EXEC_PREFIX)
+WIND_LIC_PROXY=$(WRLINUX_BASE)/setup/x86-linux2/bin
+WRLINUX_GNU_PATH = $(WRLINUX_BASE)/wrlinux-3.0/layers/wrll-toolchain-4.3-85/powerpc/toolchain/x86-linux2/bin
+override PATH := $(TOOLCHAIN_EXEC_PREFIX):$(KERNDIR_STD)/../../host-cross/bin:$(KERNDIR_STD)/../../host-cross/powerpc-wrs-linux-gnu/bin:$(WRLINUX_GNU_PATH):$(PATH)
+export TOOLCHAIN_EXEC_PREFIX TOOLCHAIN_BIN_DIR WIND_LIC_PROXY
+
+LINUX_INCLUDE_STD := $(KERNDIR_STD)/include
+
+endif
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.21.7, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= $(KERNEL_PATH)
+endif
+endif
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.24.4, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= $(KERNEL_PATH)
+endif
+endif
+
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.25, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= $(KERNEL_PATH)
+endif
+endif
+
+
+# Default Linux include directory
+ifeq (,$(LINUX_INCLUDE))
+LINUX_INCLUDE := $(KERNDIR)/include
+endif
+
+CFGFLAGS += -DSYS_BE_PIO=1 -DSYS_BE_PACKET=0 -DSYS_BE_OTHER=1
+ENDIAN = BE_HOST=1
+CFGFLAGS += -D$(ENDIAN) 
+CFGFLAGS += -DBCM_PLATFORM_STRING=\"OLT_P2040\"
+#CFGFLAGS += -DSAL_BDE_32BIT_USER_64BIT_KERNEL
+CFGFLAGS += -DPHYS_ADDRS_ARE_64BITS
+#CFGFLAGS += -DSAL_BDE_USE_MMAP2
+#CFGFLAGS += -DSAL_BDE_CACHE_DMA_MEM
+CFGFLAGS += -DSAL_BDE_DMA_MEM_DEFAULT=16
+#CFGFLAGS += -DNONCOHERENT_DMA_MEMORY
+#CFGFLAGS += -DREMAP_DMA_NONCACHED
+CFGFLAGS += -DSAL_SPL_LOCK_ON_IRQ=1
+#CFGFLAGS += -DPTRS_ARE_64BITS
+
+# Extra variables.
+EXTRA_CFLAGS = -D"KBUILD_STR(s)=\#s" $(basename_flags) $(modname_flags)
+EXTRA_CFLAGS+=-Wno-unused-but-set-variable -Wno-unused-value
+#-Wno-enum-compare -Wno-address -Wno-uninitialized -Wno-sequence-point -Wno-switch
+#EXTRA_CFLAGS+= -mcpu=e500mc -m32 -mhard-float --sysroot=/opt/fsl/1.2/sysroots/ppce500mc-fsl-linux
+
+ARCH = powerpc
+KBUILD_VERBOSE = 1
+
+export ARCH KBUILD_VERBOSE 
+
+
+# From linux/arch/ppc/Makefile
+comma = ,
+basetarget = $(basename $(notdir $@))
+modname = $(basetarget)
+
+name-fix = $(subst $(comma),_,$(subst -,_,$1))
+basename_flags = -D"KBUILD_BASENAME=KBUILD_STR($(call name-fix,$(basetarget)))"
+modname_flags  = $(if $(filter 1,$(words $(modname))),\
+                 -D"KBUILD_MODNAME=KBUILD_STR($(call name-fix,$(modname)))")
+
+
+ifeq (4.0,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KFLAG_INCLD = /tools/eldk/4.0/usr/lib/gcc/powerpc-linux/4.0.0/include
+endif
+endif
+
+ifeq (4.1,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KFLAG_INCLD = /tools/eldk/4.1/usr/lib/gcc/powerpc-linux/4.0.0/include
+endif
+endif
+
+ifeq (2.0,$(WRS_LINUX_VERSION))
+KFLAG_INCLD = /opt/eldk/usr/lib/gcc/powerpc-linux/4.2.2/include
+endif
+
+ifeq (3.0,$(WRS_LINUX_VERSION))
+KFLAG_INCLD = $(WRLINUX_GNU_PATH)/../lib/gcc/powerpc-wrs-linux-gnu/4.3.2/include
+endif
+
+ifdef SBX_CHIPS
+CFLAGS += -DBCM_PLX9656_LOCAL_BUS -DBDE_LINUX_NON_INTERRUPTIBLE 
+endif
+
+ifeq (,$(KFLAGS))
+#JORGE includes acrescentados para o kernel 3.12
+#KFLAGS := -D__KERNEL__ -m32 -nostdinc -isystem $(KFLAG_INCLD) -I$(LINUX_INCLUDE) -include $(LINUX_INCLUDE)/linux/version.h -include $(LINUX_INCLUDE)/generated/autoconf.h -I$(KERNDIR)/arch/powerpc -I$(KERNDIR)/arch/powerpc/include -I$(KERNDIR)/include/asm-generic -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -mhard-float -pipe -ffixed-r2 -mmultiple -mno-altivec -funit-at-a-time -Wa,-me500 -fomit-frame-pointer  -Wdeclaration-after-statement -Wno-pointer-sign
+KFLAGS := -D__KERNEL__ -m32 -nostdinc -isystem $(KFLAG_INCLD) -I$(LINUX_INCLUDE) -I$(LINUX_INCLUDE)/linux -include $(LINUX_INCLUDE)/generated/uapi/linux/version.h -include $(LINUX_INCLUDE)/generated/autoconf.h -I$(LINUX_INCLUDE)/generated/uapi -I$(KERNDIR)/arch/powerpc -I$(KERNDIR)/arch/powerpc/include -I$(KERNDIR)/include/asm-generic -I$(KERNDIR)/arch/powerpc/include/uapi -I$(KERNDIR)/include/uapi -I$(KERNDIR)/arch/powerpc/include/generated -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -mhard-float -pipe -ffixed-r2 -mmultiple -mno-altivec -funit-at-a-time -Wa,-me500 -fomit-frame-pointer  -Wdeclaration-after-statement -Wno-pointer-sign
+endif
+
+# Use MSI interrupts if kernel is compiled with MSI support.
+CFLAGS += -DBDE_LINUX_USE_MSI_INTERRUPT
+
+#Wind river Linux 3.0 needs addtional flags
+ifeq (3.0,$(WRS_LINUX_VERSION))
+KFLAGS += -I$(LINUX_INCLUDE_STD) -I$(KERNDIR_STD)/arch/powerpc -I$(KERNDIR_STD)/arch/powerpc/include -I$(KERNDIR_STD)/include.asm-generic -mno-spe
+endif
+
+ifneq ($(targetplat),user)
+include ${SDK}/make/Makefile.linux-kernel-3_x
+endif
diff -rpN '--unified=6' sdk-all-6.5.5/make/Makefile.linux-kernel-3_x esw_sdk_modified/make/Makefile.linux-kernel-3_x
--- sdk-all-6.5.5/make/Makefile.linux-kernel-3_x	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/Makefile.linux-kernel-3_x	2018-01-26 11:20:52.634358520 +0000
@@ -0,0 +1,173 @@
+# $Id: Makefile.linux-kernel-3_8,v 1.40 Broadcom SDK $
+# $Copyright: Copyright 2012 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+# Configuration Flags
+
+# Filter out features that cannot or should not be supported in kernel mode
+
+_FEATURE_EXCLUDE_LIST += EDITLINE TCL OOB_RCPU CINT APIMODE DUNE_UI C_UNIT
+FEATURE_EXCLUDE_LIST = $(sort $(_FEATURE_EXCLUDE_LIST))
+
+# Tools
+
+# Conditionally Replaces DEFAULT var
+ifeq ($(origin CC),default)
+CC	= $(LSRUN) $(CROSS_COMPILE)gcc
+endif
+
+ifeq ($(origin CXX),default)
+CXX	= $(CROSS_COMPILE)g++
+endif
+
+ifeq ($(origin LD),default)
+LD	= $(CROSS_COMPILE)ld
+endif
+
+ifeq ($(origin AR),default)
+AR	= $(CROSS_COMPILE)ar
+endif
+
+ifeq ($(origin AS),default)
+AS	= $(CROSS_COMPILE)as
+endif
+
+ifeq ($(origin ARFLAGS),default)
+	ARFLAGS	= -rc
+endif
+
+STRIP	= $(CROSS_COMPILE)strip
+RANLIB  = $(CROSS_COMPILE)ranlib
+OBJCOPY = $(CROSS_COMPILE)objcopy
+NM      = $(CROSS_COMPILE)nm
+
+# Handle differences between gcc 2.x and gcc 3.x
+gcc-tune-flag = $(shell if ${CC} -dumpspecs | grep mcpu >/dev/null; then echo cpu; else echo tune; fi)
+
+# Configuration Variables
+
+# OSType Defines: This defines the type of RTOS or microkernel which you
+# are compiling the SAL (and its associated driver) for. New platforms
+# can be created by porting the routines (system.c) to your platform and
+# adding the define in this Makefile.
+
+OSTYPE = LINUX
+
+#
+# ORIGIN is used to Optionally select different CFLAGS. It is used to import
+# source from other vendors. If SOURCE=Broadcom, then the BCM_ flags are added
+# to those passed to the compiler. If SOURCE != Broadcom, BCM_ flags are NOT
+# added.
+#
+# Default specifies Broadcom
+#
+ifndef ORIGIN
+	ORIGIN = Broadcom
+endif
+
+#
+# STD_{C|CPP|CXX}FLAGS - Standard flags used by ALL compilations
+# BCM_{C|CPP|CXX}FLAGS - Flags used for Broadcom source files
+# OPT_{C|CPP|CXX}FLAGS - Defined in local make files BEFORE inclusion of 
+#			 this Makefile, to define local "Extra" flags.
+#
+
+ifdef IPROC_BUILD
+CFGFLAGS += -I$(SDK)/systems/linux/kernel/modules/include \
+	    -I$(SDK)/systems/bde/linux/include \
+	    -I$(LINUX_INCLUDE) \
+            -I$(KERNDIR)/arch/$(ARCH)
+else
+CFGFLAGS += -I$(SDK)/systems/linux/kernel/modules/include \
+	    -I$(SDK)/systems/bde/linux/include \
+	    -I$(LINUX_INCLUDE) \
+	    -I$(LINUX_INCLUDE)/asm/gcc \
+	    -I$(LINUX_INCLUDE)/asm/mach-generic \
+            -I$(KERNDIR)/arch/$(ARCH)
+endif
+
+CFGFLAGS += -DNO_CTRL_C -DNO_MEMTUNE
+#CFGFLAGS += -DNO_FILEIO
+
+CFGFLAGS += -D$(OSTYPE)
+
+# No user sal for the linux kernel
+# NO_SAL_APPL=1
+
+STD_CFLAGS = $(KFLAGS) $(CFGFLAGS)
+
+
+STD_CPPFLAGS = ${STD_CFLAGS}
+STD_CXXFLAGS = ${STD_CFLAGS}
+
+ifndef BCM_CFLAGS
+BCM_CFLAGS   = -Wall -Werror
+endif
+
+BCM_CPPFLAGS = ${BCM_CFLAGS}
+BCM_CXXFLAGS = ${BCM_CFLAGS}
+
+ifeq (${ORIGIN}, Broadcom)
+	CFLAGS   += ${STD_CFLAGS}   ${BCM_CFLAGS}   ${OPT_CFLAGS}
+	CPPFLAGS += ${STD_CPPFLAGS} ${BCM_CPPFLAGS} ${OPT_CPPFLAGS}
+	CXXFLAGS += ${STD_CXXFLAGS} ${BCM_CXXFLAGS} ${OPT_CXXFLAGS}
+else
+	CFLAGS   += ${STD_CFLAGS}   ${OPT_CFLAGS}
+	CPPFLAGS += ${STD_CPPFLAGS} ${OPT_CPPFLAGS}
+	CXXFLAGS += ${STD_CXXFLAGS} ${OPT_CXXFLAGS}
+endif
+
+#
+# Ignore pedantic flag for kernel modules
+#
+ifdef DEBUG_PEDANTIC
+DEBUG_PEDANTIC = FALSE
+endif
+
+#
+# DEPEND is used as a command to generate the list of dependencies.
+# The format of the output must be 
+#	"file.o : file.c a/b/c.h d/e/f.h ...", 
+# if it is on multiple lines, each line must end in a backslash. 
+# The output MUST be on standard out.
+#
+DEPEND = ${CC} -M $(CFLAGS) $< 
diff -rpN '--unified=6' sdk-all-6.5.5/make/Makefile.linux-TA12XG-e500-3_x esw_sdk_modified/make/Makefile.linux-TA12XG-e500-3_x
--- sdk-all-6.5.5/make/Makefile.linux-TA12XG-e500-3_x	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/Makefile.linux-TA12XG-e500-3_x	2018-01-26 11:20:52.642358520 +0000
@@ -0,0 +1,267 @@
+# $Id: Makefile.linux-gto-2_6,v 1.28 Broadcom SDK $
+# $Copyright: Copyright 2010 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+# User must select one platform from below.By default WR_LINUX is selected. .
+ifeq (,$(BUILD_PLATFORM))
+#BUILD_PLATFORM=ELDK
+BUILD_PLATFORM=WR_LINUX
+endif
+
+# Specify the ELDK version you want to use for building SDK.
+ifeq (,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+ELDK_VERSION=4.0
+endif
+endif
+
+# Specify the KERNEL VERSION  you want to use for building SDK.
+ifeq (,$(KERN_VER))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KERN_VER=3.8.13
+#2.6.21.7
+endif
+endif
+
+
+# Specify the Windriver Linux version here.For example '2.0' as shown below.
+ifeq (WR_LINUX,$(BUILD_PLATFORM))
+ifeq (,$(WRS_LINUX_VERSION))
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=2.6.27
+endif
+endif
+
+
+#glibc_small and glibc_std have their own cross-compilation tools and and path for these tools are different as implemented below. To enable glibc_small build, line given below should be uncommented.
+
+#WRL_GLIBC_SMALL=TRUE
+
+ifeq (2.0,$(WRS_LINUX_VERSION))
+ifeq ($(WRL_GLIBC_SMALL),TRUE)
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?=/home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+
+else
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+
+endif 
+
+export WRL_GLIBC_SMALL
+
+# After this point glibc_std and glibc_small share these flags
+
+WRLINUX_BASE ?=/tools/windriver/linux_ed/2.0_GA/Linux
+TOOLCHAIN_EXEC_PREFIX=$(WRLINUX_BASE)/gnu/4.1-wrlinux-2.0/x86-linux2
+TOOLCHAIN_BIN_DIR=$(TOOLCHAIN_EXEC_PREFIX)
+WIND_LIC_PROXY=$(WRLINUX_BASE)/setup/x86-linux2/bin
+WRLINUX_GNU_PATH = $(WRLINUX_BASE)/gnu/4.1-wrlinux-2.0/x86-linux2/bin
+override PATH := $(TOOLCHAIN_EXEC_PREFIX):$(KERNDIR)/../../host-cross/bin:$(KERNDIR)/../../host-cross/powerpc-wrs-linux-gnu/bin:$(WRLINUX_GNU_PATH):$(PATH)
+export TOOLCHAIN_EXEC_PREFIX TOOLCHAIN_BIN_DIR WIND_LIC_PROXY
+endif
+
+
+ifeq (3.0,$(WRS_LINUX_VERSION))
+ifeq ($(WRL_GLIBC_SMALL),TRUE)
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+KERNDIR_STD ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+
+else
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+KERNDIR_STD ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+
+endif 
+
+export WRL_GLIBC_SMALL
+
+# After this point glibc_std and glibc_small share these flags
+
+WRLINUX_BASE ?=/tools/windriver/linux_ed/3.0/Linux
+TOOLCHAIN_EXEC_PREFIX=$(WRLINUX_BASE)/wrlinux-3.0/layers/wrll-toolchain-4.3-85/powerpc/toolchain/x86-linux2
+TOOLCHAIN_BIN_DIR=$(TOOLCHAIN_EXEC_PREFIX)
+WIND_LIC_PROXY=$(WRLINUX_BASE)/setup/x86-linux2/bin
+WRLINUX_GNU_PATH = $(WRLINUX_BASE)/wrlinux-3.0/layers/wrll-toolchain-4.3-85/powerpc/toolchain/x86-linux2/bin
+override PATH := $(TOOLCHAIN_EXEC_PREFIX):$(KERNDIR_STD)/../../host-cross/bin:$(KERNDIR_STD)/../../host-cross/powerpc-wrs-linux-gnu/bin:$(WRLINUX_GNU_PATH):$(PATH)
+export TOOLCHAIN_EXEC_PREFIX TOOLCHAIN_BIN_DIR WIND_LIC_PROXY
+
+LINUX_INCLUDE_STD := $(KERNDIR_STD)/include
+
+endif
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.21.7, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= /projects/ntsw-sw/linux/eldk/gto_eldk/linux-2.6.21.7
+endif
+endif
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.24.4, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= /projects/ntsw-sw/linux/eldk/gto_eldk/linux-2.6.24.4
+endif
+endif
+
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.25, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= /projects/ntsw-sw/linux/eldk/gto_eldk/linux-2.6.25
+endif
+endif
+
+
+# Default Linux include directory
+ifeq (,$(LINUX_INCLUDE))
+LINUX_INCLUDE := $(KERNDIR)/include
+endif
+
+CFGFLAGS += -DSYS_BE_PIO=1 -DSYS_BE_PACKET=0 -DSYS_BE_OTHER=1
+ENDIAN = BE_HOST=1
+CFGFLAGS += -D$(ENDIAN) 
+CFGFLAGS += -DBCM_PLATFORM_STRING=\"GTO_MPC1010\"
+
+# Extra variables.
+EXTRA_CFLAGS = -D"KBUILD_STR(s)=\#s" $(basename_flags) $(modname_flags)
+
+ARCH = powerpc
+KBUILD_VERBOSE = 1
+
+export ARCH KBUILD_VERBOSE 
+
+
+# From linux/arch/ppc/Makefile
+comma = ,
+basetarget = $(basename $(notdir $@))
+modname = $(basetarget)
+
+name-fix = $(subst $(comma),_,$(subst -,_,$1))
+basename_flags = -D"KBUILD_BASENAME=KBUILD_STR($(call name-fix,$(basetarget)))"
+modname_flags  = $(if $(filter 1,$(words $(modname))),\
+                 -D"KBUILD_MODNAME=KBUILD_STR($(call name-fix,$(modname)))")
+
+
+ifeq (4.0,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KFLAG_INCLD = /tools/eldk/4.0/usr/lib/gcc/powerpc-linux/4.0.0/include
+endif
+endif
+
+ifeq (4.1,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KFLAG_INCLD = /tools/eldk/4.1/usr/lib/gcc/powerpc-linux/4.0.0/include
+endif
+endif
+
+ifeq (2.0,$(WRS_LINUX_VERSION))
+KFLAG_INCLD = /opt/eldk/usr/lib/gcc/powerpc-linux/4.2.2/include
+endif
+
+ifeq (3.0,$(WRS_LINUX_VERSION))
+KFLAG_INCLD = $(WRLINUX_GNU_PATH)/../lib/gcc/powerpc-wrs-linux-gnu/4.3.2/include
+endif
+
+ifdef SBX_CHIPS
+CFLAGS += -DBCM_PLX9656_LOCAL_BUS -DBDE_LINUX_NON_INTERRUPTIBLE 
+endif
+
+ifeq (,$(KFLAGS))
+KFLAGS := -D__KERNEL__ -m32 -Wp, -nostdinc -isystem $(KFLAG_INCLD) -I$(LINUX_INCLUDE) -include $(LINUX_INCLUDE)/generated/autoconf.h -I$(KERNDIR)/arch/powerpc -I$(KERNDIR)/arch/powerpc/include -I$(KERNDIR)/usr/include -I$(KERNDIR)/arch/powerpc/include/generated/ -I$(KERNDIR)/arch/powerpc/include/uapi -I$(KERNDIR)/include/uapi/asm-generic -I$(KERNDIR)/include/asm-generic -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -msoft-float -pipe -ffixed-r2 -mmultiple -mno-altivec -funit-at-a-time -Wa,-me500 -fomit-frame-pointer  -Wdeclaration-after-statement -Wno-pointer-sign
+endif
+
+# Use MSI interrupts if kernel is compiled with MSI support.
+CFLAGS += -DBDE_LINUX_USE_MSI_INTERRUPT
+
+#Wind river Linux 3.0 needs addtional flags
+ifeq (3.0,$(WRS_LINUX_VERSION))
+KFLAGS += -I$(LINUX_INCLUDE_STD) -I$(KERNDIR_STD)/arch/powerpc -I$(KERNDIR_STD)/arch/powerpc/include -I$(KERNDIR_STD)/include.asm-generic -mno-spe
+endif
+
+ifneq ($(targetplat),user)
+include ${SDK}/make/Makefile.linux-kernel-3_x
+endif
diff -rpN '--unified=6' sdk-all-6.5.5/make/Makefile.linux-TT08SXG-e500mc-3_x esw_sdk_modified/make/Makefile.linux-TT08SXG-e500mc-3_x
--- sdk-all-6.5.5/make/Makefile.linux-TT08SXG-e500mc-3_x	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/Makefile.linux-TT08SXG-e500mc-3_x	2018-01-26 11:20:52.630358520 +0000
@@ -0,0 +1,281 @@
+# $Id: Makefile.linux-gto-2_6,v 1.28 Broadcom SDK $
+# $Copyright: Copyright 2010 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+# User must select one platform from below.By default WR_LINUX is selected. .
+ifeq (,$(BUILD_PLATFORM))
+#BUILD_PLATFORM=ELDK
+BUILD_PLATFORM=WR_LINUX
+endif
+
+# Specify the ELDK version you want to use for building SDK.
+ifeq (,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+ELDK_VERSION=4.0
+endif
+endif
+
+# Specify the KERNEL VERSION  you want to use for building SDK.
+ifeq (,$(KERN_VER))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KERN_VER=3.0.51
+#2.6.21.7
+endif
+endif
+
+
+# Specify the Windriver Linux version here.For example '2.0' as shown below.
+ifeq (WR_LINUX,$(BUILD_PLATFORM))
+ifeq (,$(WRS_LINUX_VERSION))
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=2.6.27
+endif
+endif
+
+
+#glibc_small and glibc_std have their own cross-compilation tools and and path for these tools are different as implemented below. To enable glibc_small build, line given below should be uncommented.
+
+#WRL_GLIBC_SMALL=TRUE
+
+ifeq (2.0,$(WRS_LINUX_VERSION))
+ifeq ($(WRL_GLIBC_SMALL),TRUE)
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= $(KERNEL_PATH)
+
+else
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= $(KERNEL_PATH)
+
+endif 
+
+export WRL_GLIBC_SMALL
+
+# After this point glibc_std and glibc_small share these flags
+
+WRLINUX_BASE ?=/tools/windriver/linux_ed/2.0_GA/Linux
+TOOLCHAIN_EXEC_PREFIX=$(WRLINUX_BASE)/gnu/4.1-wrlinux-2.0/x86-linux2
+TOOLCHAIN_BIN_DIR=$(TOOLCHAIN_EXEC_PREFIX)
+WIND_LIC_PROXY=$(WRLINUX_BASE)/setup/x86-linux2/bin
+WRLINUX_GNU_PATH = $(WRLINUX_BASE)/gnu/4.1-wrlinux-2.0/x86-linux2/bin
+override PATH := $(TOOLCHAIN_EXEC_PREFIX):$(KERNDIR)/../../host-cross/bin:$(KERNDIR)/../../host-cross/powerpc-wrs-linux-gnu/bin:$(WRLINUX_GNU_PATH):$(PATH)
+export TOOLCHAIN_EXEC_PREFIX TOOLCHAIN_BIN_DIR WIND_LIC_PROXY
+endif
+
+
+ifeq (3.0,$(WRS_LINUX_VERSION))
+ifeq ($(WRL_GLIBC_SMALL),TRUE)
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+KERNDIR_STD ?= /home/mruas/repositorio/svn/lib/kernel/linux-2.6.35_gcc_4.2.2
+
+else
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+KERNDIR ?= $(KERNEL_PATH)
+KERNDIR_STD ?= $(KERNEL_PATH)
+
+endif 
+
+export WRL_GLIBC_SMALL
+
+# After this point glibc_std and glibc_small share these flags
+
+WRLINUX_BASE ?=/tools/windriver/linux_ed/3.0/Linux
+TOOLCHAIN_EXEC_PREFIX=$(WRLINUX_BASE)/wrlinux-3.0/layers/wrll-toolchain-4.3-85/powerpc/toolchain/x86-linux2
+TOOLCHAIN_BIN_DIR=$(TOOLCHAIN_EXEC_PREFIX)
+WIND_LIC_PROXY=$(WRLINUX_BASE)/setup/x86-linux2/bin
+WRLINUX_GNU_PATH = $(WRLINUX_BASE)/wrlinux-3.0/layers/wrll-toolchain-4.3-85/powerpc/toolchain/x86-linux2/bin
+override PATH := $(TOOLCHAIN_EXEC_PREFIX):$(KERNDIR_STD)/../../host-cross/bin:$(KERNDIR_STD)/../../host-cross/powerpc-wrs-linux-gnu/bin:$(WRLINUX_GNU_PATH):$(PATH)
+export TOOLCHAIN_EXEC_PREFIX TOOLCHAIN_BIN_DIR WIND_LIC_PROXY
+
+LINUX_INCLUDE_STD := $(KERNDIR_STD)/include
+
+endif
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.21.7, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= $(KERNEL_PATH)
+endif
+endif
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.24.4, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= $(KERNEL_PATH)
+endif
+endif
+
+
+ifeq (ELDK,$(BUILD_PLATFORM))
+ifeq (2.6.25, $(KERN_VER))
+
+ifeq (,$(CROSS_COMPILE))
+CROSS_COMPILE := /opt/eldk/usr/bin/ppc_85xxDP-
+endif
+
+ifeq (4.0, $(ELDK_VERSION))
+override PATH := /tools/eldk/4.0/usr/bin:$(PATH)
+else
+override PATH := /tools/eldk/4.1/usr/bin:$(PATH)
+endif
+KERNDIR ?= $(KERNEL_PATH)
+endif
+endif
+
+
+# Default Linux include directory
+ifeq (,$(LINUX_INCLUDE))
+LINUX_INCLUDE := $(KERNDIR)/include
+endif
+
+CFGFLAGS += -DSYS_BE_PIO=1 -DSYS_BE_PACKET=0 -DSYS_BE_OTHER=1
+ENDIAN = BE_HOST=1
+CFGFLAGS += -D$(ENDIAN) 
+CFGFLAGS += -DBCM_PLATFORM_STRING=\"OLT_P2040\"
+#CFGFLAGS += -DSAL_BDE_32BIT_USER_64BIT_KERNEL
+CFGFLAGS += -DPHYS_ADDRS_ARE_64BITS
+#CFGFLAGS += -DSAL_BDE_USE_MMAP2
+#CFGFLAGS += -DSAL_BDE_CACHE_DMA_MEM
+CFGFLAGS += -DSAL_BDE_DMA_MEM_DEFAULT=16
+#CFGFLAGS += -DNONCOHERENT_DMA_MEMORY
+#CFGFLAGS += -DREMAP_DMA_NONCACHED
+CFGFLAGS += -DSAL_SPL_LOCK_ON_IRQ=1
+#CFGFLAGS += -DPTRS_ARE_64BITS
+
+# Extra variables.
+EXTRA_CFLAGS = -D"KBUILD_STR(s)=\#s" $(basename_flags) $(modname_flags)
+EXTRA_CFLAGS+=-Wno-unused-but-set-variable -Wno-unused-value
+#-Wno-enum-compare -Wno-address -Wno-uninitialized -Wno-sequence-point -Wno-switch
+#EXTRA_CFLAGS+= -mcpu=e500mc -m32 -mhard-float --sysroot=/opt/fsl/1.2/sysroots/ppce500mc-fsl-linux
+
+ARCH = powerpc
+KBUILD_VERBOSE = 1
+
+export ARCH KBUILD_VERBOSE 
+
+
+# From linux/arch/ppc/Makefile
+comma = ,
+basetarget = $(basename $(notdir $@))
+modname = $(basetarget)
+
+name-fix = $(subst $(comma),_,$(subst -,_,$1))
+basename_flags = -D"KBUILD_BASENAME=KBUILD_STR($(call name-fix,$(basetarget)))"
+modname_flags  = $(if $(filter 1,$(words $(modname))),\
+                 -D"KBUILD_MODNAME=KBUILD_STR($(call name-fix,$(modname)))")
+
+
+ifeq (4.0,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KFLAG_INCLD = /tools/eldk/4.0/usr/lib/gcc/powerpc-linux/4.0.0/include
+endif
+endif
+
+ifeq (4.1,$(ELDK_VERSION))
+ifeq (ELDK,$(BUILD_PLATFORM))
+KFLAG_INCLD = /tools/eldk/4.1/usr/lib/gcc/powerpc-linux/4.0.0/include
+endif
+endif
+
+ifeq (2.0,$(WRS_LINUX_VERSION))
+KFLAG_INCLD = /opt/eldk/usr/lib/gcc/powerpc-linux/4.2.2/include
+endif
+
+ifeq (3.0,$(WRS_LINUX_VERSION))
+KFLAG_INCLD = $(WRLINUX_GNU_PATH)/../lib/gcc/powerpc-wrs-linux-gnu/4.3.2/include
+endif
+
+ifdef SBX_CHIPS
+CFLAGS += -DBCM_PLX9656_LOCAL_BUS -DBDE_LINUX_NON_INTERRUPTIBLE 
+endif
+
+ifeq (,$(KFLAGS))
+#JORGE includes acrescentados para o kernel 3.12
+#KFLAGS := -D__KERNEL__ -m32 -nostdinc -isystem $(KFLAG_INCLD) -I$(LINUX_INCLUDE) -include $(LINUX_INCLUDE)/linux/version.h -include $(LINUX_INCLUDE)/generated/autoconf.h -I$(KERNDIR)/arch/powerpc -I$(KERNDIR)/arch/powerpc/include -I$(KERNDIR)/include/asm-generic -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -mhard-float -pipe -ffixed-r2 -mmultiple -mno-altivec -funit-at-a-time -Wa,-me500 -fomit-frame-pointer  -Wdeclaration-after-statement -Wno-pointer-sign
+KFLAGS := -D__KERNEL__ -m32 -nostdinc -isystem $(KFLAG_INCLD) -I$(LINUX_INCLUDE) -include $(LINUX_INCLUDE)/linux/version.h -include $(LINUX_INCLUDE)/generated/autoconf.h -I$(KERNDIR)/arch/powerpc -I$(KERNDIR)/arch/powerpc/include -I$(KERNDIR)/include/asm-generic -I$(KERNDIR)/arch/powerpc/include/uapi -I$(KERNDIR)/include/uapi -I$(KERNDIR)/arch/powerpc/include/generated -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common -mhard-float -pipe -ffixed-r2 -mmultiple -mno-altivec -funit-at-a-time -Wa,-me500 -fomit-frame-pointer  -Wdeclaration-after-statement -Wno-pointer-sign
+endif
+
+# Use MSI interrupts if kernel is compiled with MSI support.
+CFLAGS += -DBDE_LINUX_USE_MSI_INTERRUPT
+
+#Wind river Linux 3.0 needs addtional flags
+ifeq (3.0,$(WRS_LINUX_VERSION))
+KFLAGS += -I$(LINUX_INCLUDE_STD) -I$(KERNDIR_STD)/arch/powerpc -I$(KERNDIR_STD)/arch/powerpc/include -I$(KERNDIR_STD)/include.asm-generic -mno-spe
+endif
+
+ifneq ($(targetplat),user)
+include ${SDK}/make/Makefile.linux-kernel-3_x
+endif
diff -rpN '--unified=6' sdk-all-6.5.5/make/Make.linux esw_sdk_modified/make/Make.linux
--- sdk-all-6.5.5/make/Make.linux	2016-07-30 00:54:33.000000000 +0100
+++ esw_sdk_modified/make/Make.linux	2018-01-26 11:20:52.734358520 +0000
@@ -56,12 +56,21 @@
 #
 # LINUX_MAKE_DIR
 #   Common makefile location, if it is not ../common
 #
 #
 
+LVL7_FIXUP = 1
+
+ifdef LVL7_FIXUP
+  ifdef QUIET
+    MAKE := @$(MAKE)
+  endif
+  MAKE := +$(MAKE)
+endif
+
 export DEST_DIR_SUFFIX :=$(subst $(realpath $(SDK))/systems,,$(realpath $(CURDIR)/$(dir ($(firstword $(MAKEFILE_LIST))))))
 
 ifeq (,$(kernel_version))
 kernel_version=2_4
 endif
 
@@ -116,6 +125,13 @@ clean_d: clean
 
 distclean:
 	$(MAKE) $(CMD) $@
 
 .PHONY: build clean distclean clean_d DELIVER variable mod bcm user
 
+
+ifdef LVL7_FIXUP
+.PHONY: get_sdk_flags
+
+get_sdk_flags:
+	$(MAKE) $(CMD) get_sdk_flags
+endif
diff -rpN '--unified=6' sdk-all-6.5.5/make/Make.local.dnx esw_sdk_modified/make/Make.local.dnx
--- sdk-all-6.5.5/make/Make.local.dnx	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/Make.local.dnx	2018-01-26 11:20:52.730358520 +0000
@@ -0,0 +1,614 @@
+# $Id: Make.local.template,v 1.181 Broadcom SDK $
+# $Copyright: Copyright 2012 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+#
+
+# Usage for Make.local.template and Make.local:
+#
+# Make.local.template is checked into the tree, but Make.local is never
+# checked in.  Copy Make.local.template to Make.local, then change
+# Make.local to select the desired compilation options (mostly debugging
+# features).
+#
+# Note on CFGFLAGS usage:
+#
+#   Because CFGFLAGS may be used with other source preprocessing tools,
+#   please limit the values added to CFGFLAGS to -D defines.
+#
+#
+# Table of Contents:
+#
+#     Compiler Related Options
+#     Boot and Debug Related Options
+#     Operational and Policy Options
+#     System Management and Multiple CPU Options
+#     Selective Device Support (Switches and PHYs)
+#     Miscellaneous Options
+#
+
+################################################################
+#
+# Compiler Related Options
+#
+################################################################
+
+# Compiling out #ifdef DEBUG code saves about 1.3% on executable size.
+# It is recommended to leave debug enabled when developing applications.
+#DEBUG_IFDEFS=FALSE
+
+# SAL resource usage tracking #ifdef control
+# DEBUG_IFDEFS should also be  TRUE for this switch to take effect.
+#BCM_RESOURCE_USAGE_PROFILE_IFDEFS=TRUE
+
+# Uncomment to build without debug symbols
+#DEBUG_SYMBOLS=FALSE
+
+# Uncomment to add private CFLAGS
+#DEBUG_CFLAGS=
+
+# Uncomment to turn off the optimizer when debugging (recommended)
+#DEBUG_OPTIMIZE=FALSE
+
+# Compiling out assert() saves about 1.1% on executable size,
+# however do so is VERY MUCH discouraged.
+#DEBUG_ASSERTS=FALSE
+
+# Controlling GCC -pedantic flag
+#DEBUG_PEDANTIC=TRUE
+
+# compiler.h overrides, these disable various compiler
+# related features even if the compiler normally supports them
+
+# Disable use of long long for uint64
+#CFGFLAGS += -DCOMPILER_OVERRIDE_NO_LONGLONG
+
+# Disable use of doubles
+#CFGFLAGS += -DCOMPILER_OVERRIDE_NO_DOUBLE
+
+# Disable inlining of functions
+#CFGFLAGS += -DCOMPILER_OVERRIDE_NO_INLINE
+
+# Disable use of const
+#CFGFLAGS += -DCOMPILER_OVERRIDE_NO_CONST
+
+# Disable use of static functions
+#CFGFLAGS += -DCOMPILER_OVERRIDE_NO_STATIC
+
+# Disable RPC flexible (long) bitmaps.
+# Warning: Disabling this changes the RPC version to 2 and
+# makes systems running this code incompatible with systems
+# running previous versions of BCM RPC code.
+#CFGFLAGS += -DBCM_RPC_PBMP_64
+
+#
+# Define if longs are 64 bits on your compiler;
+# this is typically true ONLY for 64-bit processors.
+#CFGFLAGS += -DLONGS_ARE_64BITS
+
+#
+# Define if pointers are 64 bits on your compiler;
+# this is typically true ONLY for 64-bit processors.
+# NOTE: This support works ONLY under conditions where the
+# upper 32 bits for ALL pointers are ZERO.
+#CFGFLAGS += -DPTRS_ARE_64BITS
+
+
+################################################################
+#
+# Boot and Debug Related Options
+#
+################################################################
+
+# Define this to add debug code for RX pool buffer tracking
+#CFGFLAGS += -DBCM_RXP_DEBUG
+
+# Allow debugging of PCI reads/writes (debug +pci)
+#CFGFLAGS += -DSOC_PCI_DEBUG
+
+# Make default debugging settings be 0 (very very quiet)
+#CFGFLAGS += -DNO_DEBUG_OUTPUT_DEFAULT
+
+# Don't use vxMemProbe
+#CFGFLAGS += -DVX_NO_MEM_PROBE
+
+# Allow debugging of Memory Allocation/Deallocation logging
+#CFGFLAGS += -DMEMLOG_SUPPORT
+
+################################################################
+################################################################
+#
+# Operational and Policy Options
+#
+################################################################
+
+# VLAN policy control:
+#	NO_DEFAULT_ETHER	do not init ether ports into vlan 1
+#	NO_DEFAULT_CPU		do not init cpu ports into vlan 1
+#	NO_DEFAULT_SPI_SUBPORT	do not init spi subports into vlan 1
+#	NO_AUTO_STACK		do not init stack/HG ports into created vlans
+#CFGFLAGS += -DBCM_VLAN_NO_DEFAULT_ETHER
+#CFGFLAGS += -DBCM_VLAN_NO_DEFAULT_CPU
+#CFGFLAGS += -DBCM_VLAN_NO_DEFAULT_SPI_SUBPORT
+#CFGFLAGS += -DBCM_VLAN_NO_AUTO_STACK
+
+# VLAN multicast flood Policy Control:
+# BCM_VLAN_MCAST_FLOOD_ALL      Flood all multicast packets to the VLAN
+# BCM_VLAN_MCAST_FLOOD_UNKNOWN  Flood unknown multicast packets to the vlan
+# BCM_VLAN_MCAST_FLOOD_NONE     Forward multicast packets with known
+#                               destination addresses to the appropriate ports.
+#                               All packets destined to an unknown multicast
+#                               address are dropped.
+#CFGFLAGS += -DBCM_MCAST_FLOOD_DEFAULT=BCM_VLAN_MCAST_FLOOD_ALL
+#CFGFLAGS += -DBCM_MCAST_FLOOD_DEFAULT=BCM_VLAN_MCAST_FLOOD_UNKNOWN
+#CFGFLAGS += -DBCM_MCAST_FLOOD_DEFAULT=BCM_VLAN_MCAST_FLOOD_NONE
+
+#Port Enable/Disable Policy control:
+#       PORT_DEFAULT_DISABLE       disable ports during switch initialization
+CFGFLAGS += -DBCM_PORT_DEFAULT_DISABLE
+
+# sal thread priority override (this value used for all threads if defined)
+#CFGFLAGS += -DSAL_THREAD_PRIORITY=255
+
+# disable printing of thread name in messages
+#CFGFLAGS += -DSAL_THREAD_NAME_PRINT_DISABLE
+
+# disable runtime reading of flash config.bcm file (even if !NO_FILEIO)
+CFGFLAGS += -DSAL_CONFIG_FILE=\"/usr/local/ptin/sbin/config.bcm\" -DSAL_CONFIG_TEMP=\"/usr/local/ptin/sbin/config.tmp\"
+#-DSAL_CONFIG_FILE_DISABLE
+
+# disable all Application SAL dependencies
+#NO_SAL_APPL=1
+
+
+# Prevent scheduling in SPL locks when interrupt code is run as a thread.
+# This option should not be necessary if all locks are implemented correctly,
+# however, some locks may still rely on the assumption that scheduling does
+# not occur when interrupts are disabled. If you experience any locking
+# problems in e.g. Linux User Mode, try enabling this option.
+# Please note that turning on this option will reduce performance by an
+# estimated 5 to 10 %.
+#CFGFLAGS += -DSAL_SPL_NO_PREEMPT
+
+# disable mapping of higig cosq when mapping priority to cosq
+# (use identity mapping instead : map prio0->cos0, prio1->cos1, ... , prio7->cos7)
+#CFGFLAGS += -DBCM_COSQ_HIGIG_MAP_DISABLE
+
+################################################################
+#
+# System Management and Multiple CPU Options
+#
+################################################################
+
+# Turn on BCMX inclusion
+#     INCLUDE_BCMX for any support
+INCLUDE_BCMX=1
+
+# Telekinesis suite applications for CPU to CPU communication and discovery
+#     CPUDB:         Simple CPU data base manager
+#     CPUTRANS:      CPU to CPU communication mechanisms
+#     DISCOVER:      Simple discovery; will also include CPUTRANS
+#     STKTASK:       Stack manager application
+#
+#CFGFLAGS += -DINCLUDE_LIB_CPUDB
+#CFGFLAGS += -DINCLUDE_LIB_CPUTRANS
+#CFGFLAGS += -DINCLUDE_LIB_DISCOVER
+#CFGFLAGS += -DINCLUDE_LIB_STKTASK
+
+# Option for discovery to use the application-data field in routing
+# packets for Board-ID and CPU base flag information.
+#CFGFLAGS += -DDISCOVER_APP_DATA_BOARDID
+
+# Optionally override list of included dispatch modules
+# Note: including RPC automatically includes the Telekinesis suite libs
+# ESW is the enterprise platforms.
+# ROBO includes the managed devices.
+# SBX includes API support for bcm988020QSK24X2
+#DISPATCH_LIST = RPC ESW ASYNC SBX
+
+# Define to have end-to-end flow control enabled on boards that
+# support it
+#CFGFLAGS += -DBCM_BOARD_AUTO_E2E
+
+# Define the following to support per-CPU transmit pointers.
+# This allows the TX setup and send functions to be defined on a
+# per-CPU basis, allowing mixed in-band and out-of-band communication.
+#CFGFLAGS += -DBCM_C2C_TRANSPORT_SWITCHING
+
+# Options for feature list (INCLUDE_XXX)
+# If FEATURE_LIST is defined, it is a list of features to include.
+# See Make.config for the default feature list.
+#
+# Avaliable features:
+#
+#     BCMX
+#     BCMX_DIAG
+#     CHASSIS
+#     CUSTOMER
+#     DRIVERS
+#     EDITLINE
+#     I2C
+#     L3
+#     MEM_SCAN
+#     ATPTRANS_SOCKET
+#     TELNET
+#     TEST
+#     ACL
+#     RCPU
+#     KNET - Linux user mode kernel network support
+#     BCM_SAL_PROFILE - make available an API to track SAL usage.
+#     CINT - Include the C Interpreter in the diagnostic shell. 
+#            Please note this cannot be used in Linux kernel mode. 
+#     C_UNIT - Include the C unit testing framework.  If CINT is also included
+#              then hooks will be provided for use from it.
+#     PHY_SYM_DBG - PHY GUI MDIO read/write support. Socket interface
+#                   to PHY GUI for Symbolic debugging.
+#     APIMODE - call SDK API functions from shell, requires CINT
+#     DUNE_UI - dune legacy user interface. For debug only. Tested
+#               on linux-user-gto-2.6 only.
+#     KBP   -   include nlm2(11K)/nlm3(12K) KBP support
+#     BHH   -   Include Support for BHH Application (MPLS-TP OAM based on Y.1731) 
+#               using BTE on select devices.
+#     AVS   - Include AVS support
+#FEATURE_LIST=ATPTRANS_SOCKET BCMX_DIAG L3 I2C BCMX MEM_SCAN EDITLINE \
+#    CUSTOMER TELNET DRIVERS CHASSIS TEST ACL RCPU BCM_SAL_PROFILE CINT \
+#    PTP CES FCMAP BOARD KNET REGEX MACSEC APIMODE BFD KBP AVS
+
+###############################################################
+#              KBP supported devices
+#
+#Enable this for 11K device support
+#KBP_DEVICE = KBP_11K
+#
+#Enable this for 12K device support
+#KBP_DEVICE = KBP_ALG
+#
+###############################################################
+
+################################################################
+#
+# Selective Device Support (Switches and PHYs)
+#
+################################################################
+
+# Multiple Chip Support
+#
+# By default, the driver supports all Strata switch and fabric chips
+# included in this software release.  It checks device IDs at runtime
+# to run the correct driver modules.
+#
+# To save space, the driver can be compiled to support just a subset of
+# the chips.  To do this, uncomment the line for BCM_PTL_SPT (partial
+# support) and uncomment one line for each chip to support.
+#
+# Note that there are a lot more chips than drivers.
+# For example, the BCM5615 driver is also used for BCM5625 and BCM5645.
+#
+
+#BCM_PTL_SPT = 1
+
+#BCM_5675_A0 = 1
+#BCM_56102_A0 = 1
+#BCM_56112_A0 = 1
+#BCM_56304_B0 = 1
+#BCM_56314_A0 = 1
+#BCM_56504_A0 = 1
+#BCM_56504_B0 = 1
+#BCM_56514_A0 = 1
+#BCM_56624_A0 = 1
+#BCM_56624_B0 = 1
+#BCM_56680_A0 = 1
+#BCM_56680_B0 = 1
+#BCM_56580_A0 = 1
+#BCM_56700_A0 = 1
+#BCM_56800_A0 = 1
+#BCM_56218_A0 = 1
+#BCM_56224_A0 = 1
+#BCM_56224_B0 = 1
+#BCM_56725_A0 = 1
+#BCM_56820_A0 = 1
+#BCM_53314_A0 = 1
+#BCM_53324_A0 = 1
+#BCM_56634_A0 = 1
+#BCM_56634_B0 = 1
+#BCM_56524_A0 = 1
+#BCM_56524_B0 = 1
+#BCM_56685_A0 = 1
+#BCM_56685_B0 = 1
+#BCM_56334_A0 = 1
+#BCM_56334_B0 = 1
+#BCM_56840_A0 = 1
+#BCM_56840_B0 = 1
+#BCM_56850_A0 = 1
+#BCM_56142_A0 = 1
+#BCM_56150_A0 = 1
+#BCM_56836_A0 = 1
+#BCM_56640_A0 = 1
+#BCM_56440_A0 = 1
+#BCM_56440_B0 = 1
+#BCM_56450_A0 = 1
+#BCM_56960_A0 = 1
+#BCM_56860_A0 = 1
+
+#BCM_5338_A0 = 1
+#BCM_5380_A0 = 1
+#BCM_5338_B0 = 1
+#BCM_5325_A1 = 1
+
+#BCM_5324_A0 = 1
+#BCM_5396_A0 = 1
+#BCM_5389_A0 = 1
+#BCM_5398_A0 = 1
+#BCM_5324_A1 = 1
+#BCM_53115_A0 = 1
+#BCM_53118_A0 = 1
+#BCM_53280_A0 = 1
+#BCM_53280_B0 = 1
+#BCM_53101_A0 = 1
+#BCM_53125_A0 = 1
+#BCM_53128_A0 = 1
+#BCM_53600_A0 = 1
+#BCM_89500_A0 = 1
+
+#BCM_88030_A0 = 1
+#BCM_QE2000_A0 = 1
+#BCM_BME3200_B0 = 1
+#BCM_BM9600_A0 = 1
+#BCM_88230_A0 = 1
+#BCM_88230_B0 = 1
+#BCM_88230_C0 = 1
+
+ifeq ($(BOARD),CXO2T4)
+DPP_CHIPS = 1
+BCM_88675_A0 = 1
+BCM_88675_B0 = 1
+BCM_88375_A0 = 1
+BCM_88375_B0 = 1
+BCM_88650_A0 = 1
+endif
+
+ifeq ($(BOARD),CXO2T2)
+DPP_CHIPS = 1
+BCM_88470_A0 = 1
+BCM_88375_A0 = 1
+BCM_88375_B0 = 1
+BCM_88650_A0 = 1
+endif
+
+ifeq ($(BOARD),TA12XG)
+DPP_CHIPS = 1
+BCM_88660_A0 = 1
+BCM_88650_A0 = 1
+BCM_88650_B0 = 1
+endif
+
+ifeq ($(BOARD),TT08SXG)
+DPP_CHIPS = 1
+BCM_88660_A0 = 1
+BCM_88650_A0 = 1
+BCM_88650_B0 = 1
+endif
+
+
+BCM_PTL_SPT=1
+DEBUG_OPTIMIZE=FALSE
+#FEATURE_LIST=CINT BSAFE ATPTRANS_SOCKET L3 I2C MEM_SCAN EDITLINE TELNET DRIVERS INTR CHASSIS TEST BCM_SAL_PROFILE RCPU DUNE_UI NO_SAL_APPL=1
+#FEATURE_LIST=ATPTRANS_SOCKET BCMX_DIAG L3 I2C BCMX MEM_SCAN EDITLINE CUSTOMER TEST ACL
+FEATURE_LIST=ATPTRANS_SOCKET BCMX_DIAG L3 I2C BCMX MEM_SCAN EDITLINE CUSTOMER TEST ACL \
+             CINT BCM_SAL_PROFILE NO_SAL_APPL=1
+#TELNET DRIVERS INTR CHASSIS BSAFE RCPU DUNE_UI
+
+#BCM_88640_A0 = 1
+#BCM_88650_A0 = 1
+#BCM_88650_B0 = 1
+#BCM_88650_B1 = 1
+#BCM_88750_A0 = 1
+#BCM_88750_B0 = 1
+
+#BCM_TK371X_A0 = 1
+
+# Options for multiple PHY support
+# If BCM_PHY_LIST is defined, it is a list of PHYs to include.
+# The default is to include all of them.
+# If none of them should be included specify BCM_PHY_LIST=EMPTY
+#BCM_PHY_LIST=522X 54XX 5464 5421S 5482 54616 54680 54680E 52681E 54880E 54682 54684 54640 54640E 54880 SERDES SIMUL 8703 8705 8706 8072 8040 8481 8750 8729 84740 84756 84328 EMPTY
+
+# Options for BCM5338 5380
+#CFGFLAGS += -DROBO_OLD
+#ROBO_OLD = 1
+
+# Support for phy simulation
+#CFGFLAGS += -DINCLUDE_PHY_SIMUL
+#CFGFLAGS += -DSIM_ALL_PHYS        # All phys use simulation driver
+#CFGFLAGS += -DSIM_CMIC_LINK_STAT  # Get link status from CMIC register
+
+# Support for BOARD library
+# if BOARD_LIST is defined, it is a list of Board drivers to include.
+# The default is to include all board drivers appropriate for the devices
+# included in the build. If none of them should be included specify
+# BOARD_LIST=EMPTY.
+#BOARD_LIST=GENERIC
+
+# Support for event logging
+#CFGFLAGS += -DINCLUDE_SHARED_EVLOG
+
+# Support for BCM API port translation
+#CFGFLAGS += -DINCLUDE_BCM_API_XLATE_PORT
+
+# Support for callback error checks and abort in traverse api's
+#CFGFLAGS += -DBCM_CB_ABORT_ON_ERR
+################################################################
+#
+# Misc Options
+#
+################################################################
+#CFGFLAGS += -DSOC_MEM_L3_DEFIP_WAR
+
+# Compile out Register/Table descriptive strings to generate a
+# compact image
+#CFGFLAGS +=-DSOC_NO_NAMES
+#CFGFLAGS +=-DSOC_NO_ALIAS
+#CFGFLAGS +=-DSOC_NO_DESC
+
+# Reload/WarmBoot Support
+#
+#CFGFLAGS += -DBCM_WARM_BOOT_SUPPORT
+#
+# Need this for validation using SOC scripts; Will move to tcl 
+# someday
+#CFGFLAGS += -DBCM_WARM_BOOT_SUPPORT_SW_DUMP
+#
+# Adds a CRC check on scache buffer: Calculate when saving,
+# and verify when loading.
+# When doing ISSU, both source and destination versions should either have
+# this flag enabled or disabled.
+#CFGFLAGS += -DSCACHE_CRC_CHECK
+
+################################################################
+#
+# Enable Easy Reload Support
+#
+################################################################
+#CFGFLAGS += -DBCM_EASY_RELOAD_SUPPORT
+# For validation purposes
+#CFGFLAGS += -DBCM_EASY_RELOAD_SUPPORT_SW_DUMP
+
+# Software Trunk failover Support
+#
+#CFGFLAGS += -DBCM_TRUNK_FAILOVER_SUPPORT
+
+# This option is not present in the default make.local.template.
+ifdef LVL7_FIXUP
+CFGFLAGS += -DBCM_BOARD_AUTO_TRUNK
+endif
+
+################################################################
+#
+# Override default VXWORKS thread options to make set 
+# VX_UNBREAKABLE flag in task creation.
+#
+################################################################
+#CFGFLAGS += -DVX_THREAD_OPT_UNBREAKABLE
+
+
+################################################################
+#
+# Use default priority for BDE interrupt thread.
+#
+################################################################
+#CFGFLAGS += -DSAL_BDE_THREAD_PRIO_DEFAULT
+
+################################################################
+#
+# Use cached DMA memory when mapping kernel DMA memory to user
+# mode. Should only be enabled on cache-coherent platforms.
+#
+################################################################
+#CFGFLAGS += -DSAL_BDE_CACHE_DMA_MEM
+
+################################################################
+#
+# Take the spl lock upon entering an ISR
+#
+################################################################
+#CFGFLAGS += -DSAL_SPL_LOCK_ON_IRQ
+
+################################################################
+#
+# Silently ignore NULL pointer free in sal_free API
+# Default behaviour is to assert if a NULL pointer is passed to sal_free
+#
+################################################################
+#CFGFLAGS += -DSAL_FREE_NULL_IGNORE
+
+################################################################
+# Enable SBX MPLS TP support
+################################################################
+#CFGFLAGS += -DBCM_SBX_MPLSTP_SUPPORT
+#CFGFLAGS += -DBCM_SBX_C1_MPLSTP_SUPPORT
+
+################################################################
+# Restrict SBX C2 Fte range to C2's range
+################################################################
+#CFGFLAGS += -DBCM_SBX_C1_C2_INTEROP
+
+################################################################
+# For historical reasons the PCI probe function skips device 12
+# by default to prevent a system hang on certain platforms.
+# Set this value to zero to probe all PCI devices.
+################################################################
+#CFGFLAGS += -DOVERRIDE_PCI_SKIP_DEV_MASK=0
+
+################################################################
+# Override max devices supported by PLI BDE
+################################################################
+#CFGFLAGS += -DPLI_MAX_DEVICES
+
+################################################################
+# Track BCM API calls to avoid deinitialization while calls active
+# This will incur a small time penalty for each BCM API call
+################################################################
+#CFGFLAGS += -DBCM_CONTROL_API_TRACKING
+
+################################################################
+# Override default retry time for detach to wait for executing
+# APIs to complete.
+################################################################
+#CFGFLAGS += -DBCM_DETACH_POLL_INTERVAL_USECS_DEFAULT=100000
+#CFGFLAGS += -DBCM_DETACH_NUM_RETRIES_DEFAULT=3000
+
+################################################################
+# Disable the RX module initialization
+################################################################
+#CFGFLAGS += -DBCM_RX_DISABLE
+
+################################################################
+# Enable TX callback in interrupt thread
+################################################################
+#CFGFLAGS += -DTX_CB_INTR
+
+
+ifdef LVL7_FIXUP
+# Turn on BCM Shell inclusion
+L7_INCLUDE_BCM_SHELL = 1
+CFGFLAGS += -DL7_BCM_SHELL_SUPPORT
+endif
+
diff -rpN '--unified=6' sdk-all-6.5.5/make/make.pkg.vendor esw_sdk_modified/make/make.pkg.vendor
--- sdk-all-6.5.5/make/make.pkg.vendor	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/make.pkg.vendor	2018-01-26 11:20:52.742358520 +0000
@@ -0,0 +1,20 @@
+# Vendor makefile definitions included by andl package.
+# 
+# NOTE: The vendor source files are built using the Broadcom
+#       SDK make system, so none of the usual FASTPATH make 
+#       variables are used here.
+#
+#       See corresponding file makerules.pkg.vendor for details.
+#
+
+# Output location for vendor files.
+#
+out_vend_sdk := $(OUT_ANDL)/vendor
+
+
+# Names of include files used to connect FASTPATH and SDK make systems.
+#
+export SDK_BUILD_FILE      := $(FP_ROOT)/$(out_vend_sdk)/$(SDK_BUILD_FILE_NAME)
+export SDK_FLAGS_FILE      := $(FP_ROOT)/$(out_vend_sdk)/$(SDK_FLAGS_FILE_NAME)
+export SDK_FLAGS_TEMP_FILE := $(FP_ROOT)/$(out_vend_sdk)/$(SDK_FLAGS_FILE_NAME).tmp
+
diff -rpN '--unified=6' sdk-all-6.5.5/make/makerules.link.vendor esw_sdk_modified/make/makerules.link.vendor
--- sdk-all-6.5.5/make/makerules.link.vendor	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/makerules.link.vendor	2018-01-26 11:20:52.626358520 +0000
@@ -0,0 +1,35 @@
+# Broadcom vendor SDK build rules included by ipl package.
+#
+
+# Define list of kernel modules to use.
+#
+# Note: Caller must set up $(out_kmod) and $(out_target) for use here.
+#       Example:
+#                 out_kmod   := $(FP_BASE)/$(OUT_KMOD)
+#                 out_target := $(FP_BASE)/$(OUT_TARGET)
+#
+ifeq (1,$(BLD_L7_TARGETOS_LINUX))
+  kernelobjs := $(addprefix $(out_target)/,$(filter %.ko,$(L7_MODULE_LIST)))
+endif
+
+kmod_file = $(patsubst $(out_target)/%,$(out_kmod)/%,$@)
+
+
+ifneq (,$(COPYING_MSG))
+  copying_msg1 = $(COPYING_MSG) "$(notdir $(kmod_file)) to $(patsubst %/,%,$(subst ../,,$(dir $@)))"
+endif
+
+
+# Put out an error message if the kernel modules do not exist in the output target directory.
+#
+ifneq (,$(strip $(kernelobjs)))
+  $(kernelobjs):
+	@if [ ! -s $(kmod_file) ] ;\
+	then \
+		$(echo) "Error: The $(kmod_file) file is missing." ; \
+		$(echo) "  (This should have been built during 'bldlib' processing.)" ; \
+		exit 60 ; \
+	fi
+	$(copying_msg1)
+	$(DBG) cp -f $(kmod_file) $@
+endif
diff -rpN '--unified=6' sdk-all-6.5.5/make/makerules.pkg.vendor esw_sdk_modified/make/makerules.pkg.vendor
--- sdk-all-6.5.5/make/makerules.pkg.vendor	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/makerules.pkg.vendor	2018-01-26 11:20:52.734358520 +0000
@@ -0,0 +1,133 @@
+# This file defines special package-level build rules.
+#
+# Note: The vendor source files listed here are built into individual archive
+#       files which are subsequently included when pre-linking the package 
+#       library.
+#
+
+# Output location for vendor files.
+#
+out_vend_sdk := $(OUT_ANDL)/vendor
+
+
+# Vendor output log file.
+#
+# Note: Using a Perl script instead of the 'grep' utility to prevent a 
+#       command error that occurs when all of the output messages are
+#       filtered by grep (thus giving a return value of 1).
+#
+grep_cmd          := $(PERL) $(FP_BASE)/src/l7tools/build/filter_sdk_output.pl
+vend_logging      := $(REDIRERR) | $(grep_cmd)
+ifeq (terse,$(CMD_DISPLAY_MODE))
+  vend_logging    := $(DEVNULL) $(REDIRERR)
+endif
+
+
+# Location where SDK archives are stored by vendor make system.
+#
+ifeq (1,$(BLD_L7_TARGETOS_LINUX))
+  vend_sdk_arc := $(out_vend_sdk)/unix-user/$(BOARD)-$(L7_CPU)
+
+  ifeq (1,$(BLD_L7_TARGETOS_LINUX_26))
+    vend_sdk_arc := $(vend_sdk_arc)-2_6
+  endif
+
+  ifeq (1,$(BLD_L7_TARGETOS_LINUX_36))
+    vend_sdk_arc := $(vend_sdk_arc)-3_6
+  endif
+
+  ifeq (1,$(BLD_L7_TARGETOS_LINUX_3x))
+    vend_sdk_arc := $(vend_sdk_arc)-3_x
+  endif
+endif
+
+ifeq (1,$(BLD_L7_TARGETOS_VXWORKS))
+  vend_sdk_arc := $(out_vend_sdk)/$(L7_TARGETOS)-$(L7_CPU)
+endif
+
+ifeq (1,$(BLD_L7_TARGETOS_ECOS))
+  vend_sdk_arc := $(out_vend_sdk)/$(L7_TARGETOS)-$(L7_CPU)
+endif
+
+# Define list of kernel modules to build (if any).
+#
+ifeq (1,$(BLD_L7_TARGETOS_LINUX))
+  krnl_module_list := $(filter %.ko,$(L7_MODULE_LIST))
+endif
+
+# A linuxhost 'sim' target trumps the L7_TARGETOS, override the value set above.
+#
+ifeq (1,$(BLD_L7_CPU_LINUXHOST))
+  vend_sdk_arc := $(out_vend_sdk)/unix-$(L7_CPU)
+endif
+
+# Temp file names.
+#
+temp1     := $(FP_BASE)/$(out_vend_sdk)/_templist1_sdk
+temp_out1 := $(FP_BASE)/$(out_vend_sdk)/$(sdk_build_file_name).tmp
+temp_out2 := $(SDK_FLAGS_TEMP_FILE)
+
+
+ifneq (,$(COPYING_MSG))
+  copying_msg1 = $(patsubst @%,%,$(COPYING_MSG)) "$(SPACE)$$i to $(OUT_TARGET)" ;
+endif
+
+
+.PHONY: clean
+
+
+# Clean vendor output archives and directories
+#
+# Note: No need to invoke the vendor make system here, since it is more efficient
+#       to simply delete all of the output files directly.
+#
+clean::
+	@echo "Removing vendor archive directories: $(out_vend_sdk)" $(HUSH)
+	+$(DBG)[ ! -d $(FP_BASE)/$(out_vend_sdk) ] || $(RM) -r $(FP_BASE)/$(out_vend_sdk)
+	$(DBG) for i in $(krnl_module_list) ; \
+	do \
+		$(RM) $(FP_BASE)/$(OUT_TARGET)/$$i ; \
+	done
+
+
+# Note:  Must ensure all output directories used by the vendor make system exist
+#        prior to invoking the vendor make file.
+#
+
+$(SDK_BUILD_FILE):
+	@echo "============================== THIS IS SDK-ALL-6.5.5 =============================="
+	@echo "Building vendor SDK" $(HUSH)
+	+$(DBG)[ -d $(FP_BASE)/$(out_vend_sdk) ] || mkdir -p $(FP_BASE)/$(out_vend_sdk)
+	+$(DBG)[ -d $(FP_BASE)/$(OUT_TARGET) ] || mkdir -p $(FP_BASE)/$(OUT_TARGET)
+    # Invoke vendor SDK make system to build all of its files.
+	+$(DBG)$(MAKE) -C $(FP_BASE)/$(BROADCOM_SDK) -f ./make/make.sdk bldlib $(vend_logging)
+    # Copy the kernel modules to the desired output location
+    # (it's done this way so the modules can be found and re-copied after a 'cleanexe').
+	$(DBG) for i in $(krnl_module_list) ; \
+	do \
+		if ! cmp -s $(FP_BASE)/$(out_vend_sdk)/$$i $(FP_BASE)/$(OUT_TARGET)/$$i ; \
+		then \
+			$(copying_msg1) \
+			cp -f $(FP_BASE)/$(out_vend_sdk)/$$i $(FP_BASE)/$(OUT_TARGET) ; \
+		fi ; \
+	done
+    # Build list of vendor archive files and store results in a temp file.
+    # Create dependency list and build rule from content file list.
+	-$(DBG) $(RM) $(temp1)
+	$(DBG) touch $(temp1)
+	$(DBG) echo -n -e "LIBARCS := " > $(temp_out1)
+	$(DBG) find $(FP_BASE)/$(vend_sdk_arc) -maxdepth 1 -type f -name "*.a" -fprintf $(temp1) "%p "
+	$(DBG) cat $(temp1) >> $(temp_out1)
+	-$(DBG) $(RM) $(temp1)
+	$(DBG) cp -f $(temp_out1) $@
+	-$(DBG) $(RM) $(temp_out1)
+
+$(SDK_FLAGS_FILE):
+	@echo "Building SDK flags file" $(HUSH)
+	+$(DBG)[ -d $(FP_BASE)/$(out_vend_sdk) ] || mkdir -p $(FP_BASE)/$(out_vend_sdk)
+	-$(DBG) $(RM) $(temp_out2)
+    # Invoke vendor SDK make system to create CFLAGS_SDK variable in $(SDK_FLAGS_TEMP_FILE).
+	+$(DBG)$(MAKE) -C $(FP_BASE)/$(BROADCOM_SDK) -f ./make/make.sdk get_sdk_flags $(vend_logging)
+	$(DBG) cp -f $(temp_out2) $@
+	-$(DBG) $(RM) $(temp_out2)
+
diff -rpN '--unified=6' sdk-all-6.5.5/make/make.sdk esw_sdk_modified/make/make.sdk
--- sdk-all-6.5.5/make/make.sdk	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/make/make.sdk	2018-01-26 11:20:52.650358520 +0000
@@ -0,0 +1,194 @@
+# Device-level makefile definitions included by andl package.
+# 
+
+# Local source path abbreviations (for convenience).
+#
+
+# Output location for vendor files.
+#
+out_vend_sdk := $(OUT_ANDL)/vendor
+
+
+# Pull in common make definitions.
+#
+include $(FP_ROOT)/src/l7tools/build/make.cfg
+
+# Note: Be sure to reference this using +$(VEND_MAKE) so that certain make
+#       command line parameters are passed through to the sub-makefile.
+#
+VEND_MAKE := $(DBG)$(MAKE)
+
+
+ifndef MAKE_LOCAL
+ $(error 'The $$MAKE_LOCAL environment variable is not set')
+endif
+
+# Adjust the console messages generated by the vendor make system by defining
+# its QUIET variable.
+#
+# Note: This still does not provide a sufficient level of control to mesh with
+#       the type of output messages generated by the FASTPATH make system, but
+#       it's a start.
+#
+ifneq (verbose,$(CMD_DISPLAY_MODE))
+  export QUIET=1
+endif
+
+
+# The following variables are required by the Broadcom SDK.
+#
+# Note: Want the SDK make system to store the stripped kernel modules
+#       in the vendor output directory; the FASTPATH make system will 
+#       copy them to the intended target location.
+#
+export SDK              := $(FP_ROOT)/$(BROADCOM_SDK)
+export TARGET           := $(L7_TARGETOS)-$(L7_CPU)
+export L7_PKGNAME       := $(PKGNAME)
+export L7_OUTPUT        := $(FP_ROOT)/$(out_vend_sdk)
+export L7_OUTPUT_KMOD   := $(FP_ROOT)/$(out_vend_sdk)
+export L7_OUT_SDK_FLAGS := $(SDK_FLAGS_TEMP_FILE)
+export PPC_TOOLS_DIR    := $(dir $(CROSS_COMPILE))
+export MIPS_TOOLS_DIR   := $(PPC_TOOLS_DIR)
+
+ifeq (1,$(BLD_L7_TARGETOS_LINUX))
+  export LINUX_INCLUDE := $(KERNEL_SRC)/include
+  export KERNDIR     := $(KERNEL_SRC)
+ifeq (1,$(BLD_L7_TARGETOS_LINUX_3x))
+  os_suffix          := -3_x
+else
+  os_suffix          := -2_6
+endif
+endif
+
+
+# Extra include paths to be passed to BCM vendor make.
+#
+l7_extra_inc_paths := \
+	$(L7PUBLIC_INCLDIR) \
+	$(COMPONENT_INCLDIR) \
+	-I$(FP_BASE)/andl/hapi/$(L7_CHIP)/base \
+	-I$(FP_BASE)/andl/hapi/$(L7_CHIP)/base/bcmsys \
+	-I$(SDK)/include/customer/$(L7_CUSTOMER) \
+	-I$(SDK)/libs/phymod/include
+
+ifneq (,$(strip $(PRJ_DIR)))
+  l7_extra_inc_paths += \
+	-I$(PRJ_DIR) 
+endif
+
+ifneq (,$(strip $(BSP_DIR)))
+  l7_extra_inc_paths += \
+        -I$(BSP_DIR)
+endif
+
+ifneq (,$(strip $(BSP_DIR)))
+  l7_extra_inc_paths += \
+        -I$(BSP_DIR)
+endif
+
+ifeq (1,$(BLD_L7_TARGETOS_VXWORKS))
+  l7_extra_inc_paths += \
+	-I$(WIND_BASE)/target/config/comps/src \
+	-I$(WIND_BASE)/target/src/drv
+endif
+
+export L7_BCM_VENDOR_INCL := $(subst $(FP_BASE),$(FP_ROOT),$(l7_extra_inc_paths))
+
+
+# Additional CFLAGS to be passed to BCM vendor make.
+#
+export L7_BCM_VENDOR_CFLAGS := \
+	-DLVL7_FIXUP \
+	-DBCM_COSQ_HIGIG_MAP_DISABLE \
+	-DSAL_THREAD_PRIORITY=255 \
+	$(L7_OS_VERSION) \
+	-DSAL_NO_FLASH_FS \
+	-DRW_MULTI_THREAD \
+	$(CPU_TYPE) \
+	$(PRODUCT_TYPE) \
+  $(L7_TOOL_FLAG) \
+  -DSAL_BDE_THREAD_PRIO_DEFAULT \
+  -DVX_THREAD_OPT_UNBREAKABLE \
+  -DSDK_INCLUDE_CUSTOM_CONFIG
+
+ifneq (1,$(BLD_L7_TARGETOS_VXWORKS))
+#export L7_BCM_VENDOR_CFLAGS += -DNO_FILEIO
+endif
+
+ifneq (,$(filter -mlongcall,$(CPU_FLAGS)))
+export L7_BCM_VENDOR_CFLAGS += -mlongcall
+endif
+
+# Map sal_alloc/sal_free to osapi Api's except for 
+# - MIPS64 cpu: SDK has some special code for MIPS64 in sal_alloc.
+# - Linux kernel mode
+# - Smartpath product
+
+l7_sal_map_to_osapi := 1
+
+ifeq (1,$(BLD_L7_PRODUCT_SMARTPATH))
+l7_sal_map_to_osapi := 0
+endif
+
+ifeq (MIPS64,$(CPU))
+l7_sal_map_to_osapi := 0
+endif
+
+ifeq (1,$(l7_sal_map_to_osapi))
+export L7_BCM_VENDOR_CFLAGS += \
+	-DL7_SAL_MAP_TO_OSAPI
+endif
+
+# Translate the make command goal to that used by the vendor make system.
+#
+# Note: The default is to leave this blank so that everything gets built.
+#
+vend_bld_goal   :=
+ifeq (get_sdk_flags,$(MAKECMDGOALS))
+  vend_bld_goal := get_sdk_flags
+endif
+
+
+# Decide which type of target to build.
+#
+target_type := $(L7_TARGETOS)
+ifeq (1,$(BLD_L7_CPU_LINUXHOST))
+  target_type := linuxhost
+endif
+
+# Disallow parallel build option (-j) since the underlying SDK target rules
+# are not designed to handle it properly.
+#
+new_makeflags = $(filter-out -j,$(MAKEFLAGS))
+
+
+# Special Build rules
+#  - All entries must be specified relative to top-of-view $(FP_ROOT).
+#  - Defines all source locations to be referenced by the package-level makefile.
+#
+# Note: Assumes all necessary output directories already exist.
+#
+# Note: To echo debug messages, begin the message text with "Debug: " to get past
+#       the SDK output message filter script.
+#
+
+.PHONY: bldlib get_sdk_flags vend_sdk_linux vend_sdk_vxworks vend_sdk_linuxhost
+
+
+bldlib get_sdk_flags:: vend_sdk_$(target_type)
+	$(NOOP)
+
+
+vend_sdk_linux::
+	+$(VEND_MAKE) -C $(SDK)/systems/$(L7_TARGETOS)/user/fastpath$(os_suffix) $(vend_bld_goal) MAKEFLAGS=$(QT)$(new_makeflags)$(QT)
+
+vend_sdk_ecos::
+	+$(VEND_MAKE) -C $(SDK)/systems/$(L7_TARGETOS)/$(L7_CPU) $(vend_bld_goal) MAKEFLAGS=$(QT)$(new_makeflags)$(QT)
+
+vend_sdk_vxworks::
+	+$(VEND_MAKE) -C $(SDK)/systems/$(L7_TARGETOS)/common $(vend_bld_goal) MAKEFLAGS=$(QT)$(new_makeflags)$(QT)
+
+
+vend_sdk_linuxhost::
+	+$(VEND_MAKE) -C $(SDK)/systems/linuxhost $(vend_bld_goal) MAKEFLAGS=$(QT)$(new_makeflags)$(QT)
+
diff -rpN '--unified=6' sdk-all-6.5.5/make/Make.tools esw_sdk_modified/make/Make.tools
--- sdk-all-6.5.5/make/Make.tools	2016-07-30 00:54:33.000000000 +0100
+++ esw_sdk_modified/make/Make.tools	2018-01-26 11:20:52.738358520 +0000
@@ -169,12 +169,23 @@ MKVERS	=	$(PERL) ${SDK}/tools/version.pl
 RM	=	/bin/rm -rf
 CP	=	/bin/cp
 MKDIR	=	/bin/mkdir -p
 FOREACH	=	$(MKTOOL) -foreach
 MAKEDEP =	/bin/echo
 ECHO	=	/bin/echo
+ifdef LVL7_FIXUP
+ifeq "$(HOSTTYPE)" "Windows2000PC"
+RM	=	rm -rf
+CP	=	cp
+MKDIR	=	mkdir -p
+MAKEDEP =	echo
+ECHO	=	echo
+TOUCH   =	touch
+endif
+endif
+
 MKBEEP	=	$(MKTOOL) -beep
 endif
 
 MKSBXHS =	$(PERL) $(SDK)/tools/mksbxhs.pl
 
 #
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/cputrans/atp.c esw_sdk_modified/src/appl/cputrans/atp.c
--- sdk-all-6.5.5/src/appl/cputrans/atp.c	2016-07-30 00:54:34.000000000 +0100
+++ esw_sdk_modified/src/appl/cputrans/atp.c	2018-01-26 11:20:32.754358520 +0000
@@ -3885,20 +3885,35 @@ bet_c2c_free_tx_cb(uint8 *pkt_buf, void
 
 STATIC void
 tx_done_handle(_atp_client_t *client, int cpu, _atp_tx_trans_t *trans)
 {
 
     if (trans->flags & _ATP_TX_F_TIMEOUT) {
+#ifdef LVL7_FIXUP
+        /* Print the mac-address of the unit */
+        LOG_ERROR(BSL_LS_TKS_ATP,
+                      (BSL_META("ATP: TX timeout, seq %d. cli %d. to %d(mac %x:%x:%x:%x:%x:%x) tx cnt %d.\n"),
+                      trans->_atp_hdr.seq_num, trans->client->client_id,
+                      trans->dest_cpu, 
+                      _atp_cpu_info[trans->dest_cpu].key.key[0],
+                      _atp_cpu_info[trans->dest_cpu].key.key[1],
+                       _atp_cpu_info[trans->dest_cpu].key.key[2],
+                       _atp_cpu_info[trans->dest_cpu].key.key[3],
+                       _atp_cpu_info[trans->dest_cpu].key.key[4],
+                       _atp_cpu_info[trans->dest_cpu].key.key[5],
+                       trans->tx_count));
+#else
         LOG_ERROR(BSL_LS_TKS_ATP,
                   (BSL_META("ATP: TX timeout, seq %d. " CPUDB_KEY_FMT 
                    " cli %d. to %d tx cnt %d.\n"),
                    trans->_atp_hdr.seq_num,
                    CPUDB_KEY_DISP(_atp_cpu_info[trans->dest_cpu].key),
                    trans->client->client_id,
                    trans->dest_cpu,
                    trans->tx_count));
+#endif
         if (atp_timeout_cb != NULL) {
             (*atp_timeout_cb)(CPU_KEY(trans->dest_cpu));
         }
     }
 
     if (trans->callback != NULL) {
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/diag/cint/sal_cint_data.c esw_sdk_modified/src/appl/diag/cint/sal_cint_data.c
--- sdk-all-6.5.5/src/appl/diag/cint/sal_cint_data.c	2016-07-30 00:54:35.000000000 +0100
+++ esw_sdk_modified/src/appl/diag/cint/sal_cint_data.c	2018-01-26 11:20:32.650358520 +0000
@@ -61,12 +61,20 @@ int sal_core_cint_data_not_empty;
 #include <sal/core/thread.h>
 #include <sal/appl/config.h>
 
 #include <sal/appl/sal.h>
 
 
+/* PTin added: solve an incompatibility of CINT with LVL7_FIXUP definition */
+#if ((defined(LVL7_FIXUP)) && (defined(L7_SAL_MAP_TO_OSAPI)) && (!defined(__KERNEL__)))
+#undef sal_alloc
+#undef sal_free
+extern void *sal_alloc(unsigned int, char *);
+extern void sal_free(void *);
+#endif
+
 
 CINT_FWRAPPER_CREATE_RP2(void*, void, 1, 0, 
                          sal_alloc, 
                          int,int,size,0,0,
                          void*,void,name,1,0); 
 
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/diag/cmdlist.c esw_sdk_modified/src/appl/diag/cmdlist.c
--- sdk-all-6.5.5/src/appl/diag/cmdlist.c	2016-07-30 00:54:34.000000000 +0100
+++ esw_sdk_modified/src/appl/diag/cmdlist.c	2018-01-26 11:20:32.594358520 +0000
@@ -703,14 +703,16 @@ static cmd_t bcm_esw_cmd_list[] = {
     {"StartSim",        cmd_simstart,           NULL,                   "Tell plisim to activate" },
 #endif
     {"STG",             if_esw_stg,             if_esw_stg_usage,       "Manage spanning tree groups" },
     {"STiMeout",        cmd_stimeout,           stimeout_usage,         "Set S-Channel timeout in microseconds" },
     {"STKMode",         cmd_stkmode,            cmd_stkmode_usage,       "Hardware Stacking Mode Control"},
 #if defined(TKS_SUPPORT)
+#if LVL7_FIXUP && !defined(L7_PRODUCT_SMARTPATH)
     {"StkTask",         tks_stk_task,           tks_stk_task_usage,      "Stack task control" },
 #endif
+#endif
 #ifdef SW_AUTONEG_SUPPORT    
     {"SW_AN", if_esw_swAutoneg, if_esw_swAutoneg_usage, "Enable/Disable SW AN Thread"},
 #endif    
     {"SwitchControl",   cmd_switch_control,     cmd_switch_control_usage, "General switch control"},
 #ifdef INCLUDE_I2C
 #ifdef BCM_ESW_SUPPORT
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/diag/dcmn/init.c esw_sdk_modified/src/appl/diag/dcmn/init.c
--- sdk-all-6.5.5/src/appl/diag/dcmn/init.c	2016-07-30 00:54:35.000000000 +0100
+++ esw_sdk_modified/src/appl/diag/dcmn/init.c	2018-01-26 11:20:32.394358520 +0000
@@ -149,13 +149,13 @@ extern int _cpu_pci_register(int d);
 
 #define PCP_DEVICE_ID (SOC_SAND_MAX_DEVICE-1)
 
 #define MAX_NUM_DEVICES (SOC_SAND_MAX_DEVICE)
 #define MAX_COS         (8)
 #define MAX_MODIDS_PER_DEVICE 2
-#define MODIDS_PER_DEVICE (g_dii.is_symmetric ? MAX_MODIDS_PER_DEVICE : 1)
+#define MODIDS_PER_DEVICE (g_dii.is_symmetric ? (g_dii.nof_active_cores) /*MAX_MODIDS_PER_DEVICE*/ : 1)
 #define OLP_DEFAULT_CORE 0
 #define CORE_ID2INDEX(core_id) ((core_id == BCM_CORE_ALL) ? 0 : core_id)
 
 #define NOF_DEF_SLOW_SPEEDS (4)
 
 #ifdef BCM_PETRA_SUPPORT
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/diag/decode.c esw_sdk_modified/src/appl/diag/decode.c
--- sdk-all-6.5.5/src/appl/diag/decode.c	2016-07-30 00:54:34.000000000 +0100
+++ esw_sdk_modified/src/appl/diag/decode.c	2018-01-26 11:20:32.570358520 +0000
@@ -52,13 +52,17 @@
 
 #ifdef linux
 #undef  _POSIX_SOURCE
 #undef  _POSIX_C_SOURCE
 #undef _GNU_SOURCE
 #undef _SVID_SOURCE
-#define _BSD_SOURCE
+#if ((__GNUC__ == 4 && __GNUC_MINOR__ >= 9) || (__GNUC__ > 4))
+ #define _DEFAULT_SOURCE
+#else
+ #define _BSD_SOURCE
+#endif
 #endif
 
 #include <sal/types.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <net/if.h>
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/diag/shell.c esw_sdk_modified/src/appl/diag/shell.c
--- sdk-all-6.5.5/src/appl/diag/shell.c	2016-07-30 00:54:35.000000000 +0100
+++ esw_sdk_modified/src/appl/diag/shell.c	2018-01-26 11:20:32.594358520 +0000
@@ -3450,17 +3450,21 @@ sh_print_version(int verbose)
  * Parameters:    verbose - includes more info if TRUE
  * Returns:    Nothing
  */
 {
     cli_out("Broadcom Command Monitor: "
             "Copyright (c) 1998-2016 Broadcom\n");
+#if !defined(LVL7_FIXUP) || defined(VXWORKS)
     cli_out("Release: %s built %s (%s)\n",
             _build_release, _build_datestamp, _build_date);
     cli_out("From %s@%s:%s\n",
             _build_user, _build_host, _build_tree);
+#endif
+#if !defined(LVL7_FIXUP)
     cli_out("Platform: %s\n", BCM_PLATFORM_STRING); 
+#endif
     cli_out("OS: %s\n", sal_os_name() ? sal_os_name() : "unknown"); 
 
     if (verbose) {
 #if (defined(BCM_ROBO_SUPPORT) || defined(BCM_ESW_SUPPORT) || defined(BCM_SBX_SUPPORT) || defined(BCM_SAND_SUPPORT))
     int        i, j;
 #endif
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/diag/tksdiag.c esw_sdk_modified/src/appl/diag/tksdiag.c
--- sdk-all-6.5.5/src/appl/diag/tksdiag.c	2016-07-30 00:54:35.000000000 +0100
+++ esw_sdk_modified/src/appl/diag/tksdiag.c	2018-01-26 11:20:32.698358520 +0000
@@ -119,12 +119,18 @@ const bcm_mac_t _bcast_mac = {0xff, 0xff
 /****************************************************************
  *
  * CPUDB control
  *
  ****************************************************************/
 
+#ifdef LVL7_FIXUP
+extern int bcmx_device_attach(int bcm_unit);
+extern int bcmx_device_detach(int bcm_unit);
+extern void tks_st_thread(void *cookie);
+#endif
+
 STATIC INLINE void
 db_entry_show(const cpudb_entry_t *entry)
 {
     const cpudb_stk_port_t  *sp_p;
     int                     i;
     char                    keybuf[CPUDB_KEY_STRING_LEN];
@@ -407,12 +413,17 @@ char ct_cpudb_usage[] =
     ;
 
 cpudb_ref_t db_refs[MAX_DBS];
 int cur_db;
 int num_db = 0;
 
+#ifdef LVL7_FIXUP
+extern void bcmx_attach_callback(int unit, int attach,
+                         cpudb_entry_t *cpuent, int cpuunit);
+#endif
+
 cmd_result_t
 ct_cpudb(int unit, args_t *args)
 {
     char *subcmd;
     char *int_arg;
     parse_table_t pt;
@@ -1039,12 +1050,13 @@ mh_opcode0_priority(int action)
 static int st_pri = TKS_STK_DEFAULT_THREAD_PRIORITY;
 static sal_thread_t st_tid = SAL_THREAD_ERROR;
 static sal_sem_t st_done_sem;
 
 #define TOPO_ATP_FLAGS (ATP_F_NEXT_HOP | ATP_F_REASSEM_BUF)
 
+#ifndef LVL7_FIXUP
 STATIC void
 tks_st_thread(void *cookie)
 {
     bcm_st_config_t *cfg;
     int rv, unit, i;
     sal_usecs_t attach_timeout;
@@ -1113,12 +1125,13 @@ tks_st_thread(void *cookie)
 #endif
 
     mh_opcode0_priority(MH_OPCODE0_CLEAR);
     sal_sem_give(st_done_sem);
     sal_thread_exit(rv);
 }
+#endif
 
 typedef struct {
     int timeout;
     int rv;
 } tks_st_stop_thread_arg_t;
 
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/discover/disc_int.h esw_sdk_modified/src/appl/discover/disc_int.h
--- sdk-all-6.5.5/src/appl/discover/disc_int.h	2016-07-30 00:54:36.000000000 +0100
+++ esw_sdk_modified/src/appl/discover/disc_int.h	2018-01-26 11:20:32.746358520 +0000
@@ -286,10 +286,14 @@
 #define STK_ENTRY_BFLAGS_OFS    (STK_ENTRY_WEIGHT_OFS + sizeof(uint32))
 #define STK_ENTRY_UNIT_OFS      (STK_ENTRY_BFLAGS_OFS + sizeof(uint32))
 #define STK_ENTRY_PORT_OFS      (STK_ENTRY_UNIT_OFS + sizeof(uint32))
 
 /* These are used to pre-allocate packet buffers for routing packets */
 #define ROUTE_ENTRIES_PER_PKT_MAX 4    /* Max entries allowed/pkt */
+#if defined(LVL7_FIXUP) && defined(L7_PRODUCT_SMB)
+#define ROUTE_PKTS_MAX            32 /* Max route pkts for table */
+#else
 #define ROUTE_PKTS_MAX            CPUDB_CPU_MAX /* Max route pkts for table */
+#endif
 #define ROUTE_PKT_BYTES_MAX    1500    /* Max route pkts for table */
 
 #endif /* _DISC_INT_H_ */
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/dpp/UserInterface/ui_module.c esw_sdk_modified/src/appl/dpp/UserInterface/ui_module.c
--- sdk-all-6.5.5/src/appl/dpp/UserInterface/ui_module.c	2016-07-30 00:54:36.000000000 +0100
+++ esw_sdk_modified/src/appl/dpp/UserInterface/ui_module.c	2018-01-26 11:20:33.386358520 +0000
@@ -239,14 +239,16 @@ STATUS
   #include <sys/types.h>
   #include <sys/uio.h>
   #include <unistd.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <termios.h>
+
+  #undef min
   #define min(a,b)    (((a) < (b)) ? (a) : (b))
-  
+
 /*} LINUX */
 #endif
 
 #ifdef __DUNE_SSF__
 /* { */
 #include <appl/diag/dpp/utils_char_queue.h>
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/dpp/UserInterface/ui_utils.c esw_sdk_modified/src/appl/dpp/UserInterface/ui_utils.c
--- sdk-all-6.5.5/src/appl/dpp/UserInterface/ui_utils.c	2016-07-30 00:54:36.000000000 +0100
+++ esw_sdk_modified/src/appl/dpp/UserInterface/ui_utils.c	2018-01-26 11:20:33.378358520 +0000
@@ -50,12 +50,13 @@
 #include <soc/dpp/SAND/Utils/sand_os_interface.h>
 #ifdef __DUNE_HRP__
   #include <DHRP/dhrp_defs.h>
 #endif
 
 #if (defined(LINUX) || defined(UNIX))
+  #undef min
   #define min(a,b)    (((a) < (b)) ? (a) : (b))
 
   #include <unistd.h>
 #else
   #if !defined(__DUNE_GTO_BCM_CPU__)
   #include <appl/diag/dpp/utils_nvram_configuration.h>
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/stktask/brd_common.c esw_sdk_modified/src/appl/stktask/brd_common.c
--- sdk-all-6.5.5/src/appl/stktask/brd_common.c	2016-07-30 00:54:36.000000000 +0100
+++ esw_sdk_modified/src/appl/stktask/brd_common.c	2018-01-26 11:20:33.318358520 +0000
@@ -481,12 +481,15 @@ _bcm_board_trunk_interconnect_mark(int u
  *      BCM_E_XXX
  * Notes:
  *     Some early discovery versions do not carry stack-port information
  *     for remote CPU entries.
  */
 
+#ifdef LVL7_FIXUP
+extern int lvl7_internal_hg_trunkid;
+#endif
 
 STATIC int
 _bcm_board_trunk_unit(int unit, cpudb_entry_t *entry, cpudb_ref_t db_ref,
                       int start, int flags)
 {
     int                     tid, rv = BCM_E_NONE, i, j;
@@ -503,12 +506,20 @@ _bcm_board_trunk_unit(int unit, cpudb_en
     bcm_trunk_chip_info_t   ti;
     int                     trunk_maxnum;
 
     /* Destroy any pre-existing fabric trunks */
     if (flags & BCM_BOARD_TRUNK_DESTROY) {
         for (tid = start;; tid++) {
+#ifdef LVL7_FIXUP
+            /* Don't destroy the internal HG trunk */
+            if ((lvl7_internal_hg_trunkid != -1) && (tid == lvl7_internal_hg_trunkid))
+            {
+                continue;            
+            }
+#endif
+
             rv = bcm_trunk_destroy(unit, tid);
             if (BCM_FAILURE(rv) && (BCM_E_NOT_FOUND != rv)) {
                 break;
             }
         }
         if (tid != start) {
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/stktask/topo_brd.c esw_sdk_modified/src/appl/stktask/topo_brd.c
--- sdk-all-6.5.5/src/appl/stktask/topo_brd.c	2016-07-30 00:54:36.000000000 +0100
+++ esw_sdk_modified/src/appl/stktask/topo_brd.c	2018-01-26 11:20:33.318358520 +0000
@@ -530,12 +530,20 @@ _topo_board_default_program(cpudb_ref_t
        should not matter. Define TOPO_BRD_UPDATE_BEFORE_PROGRAM to
        restore the older behavior if it is needed. */
     BCM_IF_ERROR_RETURN(_topo_stk_ports_update(db_ref, topo_cpu));
 #endif
 
     /* Set up the board based on device detection. */
+    #ifdef LVL7_FIXUP
+    extern int lvl7_topo_board_program(cpudb_ref_t db_ref, topo_cpu_t *topo_cpu,int *rv);
+
+    if (lvl7_topo_board_program(db_ref,topo_cpu,&rv)){
+      /* nothing to do but skip the rest of the board detections */
+    }
+    else
+    #endif
     if (soc_ndev == 1 &&
                SOC_IS_HERCULES15(0)) {
         rv = bcm_board_topo_cfm_xgs2(topo_cpu, db_ref);
     } else if (soc_ndev == 1 &&
                SOC_IS_XGS12_FABRIC(0)) {
         rv = bcm_board_topo_8h(topo_cpu, db_ref);
diff -rpN '--unified=6' sdk-all-6.5.5/src/appl/stktask/topology.c esw_sdk_modified/src/appl/stktask/topology.c
--- sdk-all-6.5.5/src/appl/stktask/topology.c	2016-07-30 00:54:36.000000000 +0100
+++ esw_sdk_modified/src/appl/stktask/topology.c	2018-01-26 11:20:33.326358520 +0000
@@ -197,20 +197,28 @@ tp_weights_init(cpudb_ref_t db_ref, weig
                  * Already have a connection indicated;
                  * fabric trunking handles this case
                  */
                 continue;
             }
 
+#ifdef LVL7_FIXUP
+            TP_WEIGHT(weights, s_idx, d_idx) = sp_base->weight;
+#else
             TP_WEIGHT(weights, s_idx, d_idx) = TOPO_DEFAULT_WEIGHT;
+#endif
             /* Below indicates is reachable and by what stk port */
             TP_TX_CXN(db_ref, s_idx, d_idx) = i;
             TP_RX_CXN(db_ref, d_idx, s_idx) = sp->tx_stk_idx;
             /* Check for duplex connection and set up if so. */
             if (sp->flags & CPUDB_SPF_DUPLEX) {
                 if (!TP_REACHABLE(db_ref, d_idx, s_idx)) {
+#ifdef LVL7_FIXUP
+                    TP_WEIGHT(weights, d_idx, s_idx) = dest_entry->base.stk_ports[sp->tx_stk_idx].weight;
+#else
                     TP_WEIGHT(weights, d_idx, s_idx) = TOPO_DEFAULT_WEIGHT;
+#endif
                     /* Below indicates is reachable and by what stk port */
                     TP_TX_CXN(db_ref, d_idx, s_idx) = sp->tx_stk_idx;
                     TP_RX_CXN(db_ref, s_idx, d_idx) = i;
                 } else {
                     LOG_WARN(BSL_LS_TKS_TOPOLOGY,
                              (BSL_META("TOPO WARNING: Duplex port already marked, "
diff -rpN '--unified=6' sdk-all-6.5.5/src/bcm/common/tx.c esw_sdk_modified/src/bcm/common/tx.c
--- sdk-all-6.5.5/src/bcm/common/tx.c	2016-07-30 00:54:38.000000000 +0100
+++ esw_sdk_modified/src/bcm/common/tx.c	2018-01-26 11:20:45.762358520 +0000
@@ -2501,14 +2501,28 @@ _xgs3_tx(int unit, bcm_pkt_t *pkt, void
             return BCM_E_MEMORY;
         }
         _xgs3_tx_cb_cookie->orig_pkt = pkt; 
         _xgs3_tx_cb_cookie->orig_cookie = cookie;
         _xgs3_tx_cb_cookie->cleanup_mem = packets_p;
 
+#ifdef LVL7_FIXUP
+        /* If original pkt was synchronous, make a synchronous call */
+        if (NULL == pkt->call_back) {
+          /* Make synchronous call, and invoke the callback */
+          rv = bcm_common_tx_array(unit, packet_pointers_p, pkt_cnt, NULL, NULL);
+
+          _xgs3_tx_cb(unit, packet_pointers_p[0],  _xgs3_tx_cb_cookie);
+        }
+        else {
+           rv = bcm_common_tx_array(unit, packet_pointers_p, pkt_cnt, &_xgs3_tx_cb,
+                _xgs3_tx_cb_cookie);
+        }
+#else
         rv = bcm_common_tx_array(unit, packet_pointers_p, pkt_cnt, &_xgs3_tx_cb,
                 _xgs3_tx_cb_cookie);
+#endif
 
         sal_free(packet_pointers_p);
         /* packets_p and _xgs3_tx_cb_cookie will be freed by _xgs3_tx_cb */
 
     } else {
         rv = bcm_common_tx_array(unit, packet_pointers_p, pkt_cnt, NULL, NULL);
diff -rpN '--unified=6' sdk-all-6.5.5/src/bcm/dpp/port.c esw_sdk_modified/src/bcm/dpp/port.c
--- sdk-all-6.5.5/src/bcm/dpp/port.c	2016-07-30 00:54:38.000000000 +0100
+++ esw_sdk_modified/src/bcm/dpp/port.c	2018-01-26 11:20:46.110358520 +0000
@@ -3660,13 +3660,14 @@ bcm_petra_port_selective_get(int unit, b
         }
     }
 
     if (mask & BCM_PORT_ATTR_LINKSTAT_MASK) {
         rv = bcm_petra_port_link_status_get(unit, port_ndx, &info->linkstatus);
         if (rv != BCM_E_NONE) {
-            BCMDNX_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("bcm_petra_port_link_status_get failed: %s"), bcm_errmsg(rv)));
+            BCMDNX_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("(unit %d, port %d) bcm_petra_port_link_status_get failed: %s"),
+                                     unit, port_ndx, bcm_errmsg(rv)));
         }
     }
 
     if (mask & BCM_PORT_ATTR_SPEED_MASK) {
         if ((rv = bcm_petra_port_speed_get(unit, port_ndx, &info->speed)) < 0) {
             if (rv != BCM_E_BUSY) {
diff -rpN '--unified=6' sdk-all-6.5.5/src/bcm/rpc/rpc.c esw_sdk_modified/src/bcm/rpc/rpc.c
--- sdk-all-6.5.5/src/bcm/rpc/rpc.c	2016-07-30 00:54:40.000000000 +0100
+++ esw_sdk_modified/src/bcm/rpc/rpc.c	2018-01-26 11:20:44.742358520 +0000
@@ -329,12 +329,22 @@ bcm_rpc_request(int unit, uint8 *buf, in
 
     if (req->rbuf == NULL) {  /* no response buffer */
         /* This request normally would have been unlinked when req.sem
            was given, but if sal_sem_take returns in error then the
            request record needs to be be unlinked here.
         */
+#ifdef LVL7_FIXUP
+      LOG_ERROR(BSL_LS_BCM_COMMON,
+                    (BSL_META("RPC - Timeout to CPU: %x:%x:%x:%x:%x:%x.\n"),
+                     cpu.key[0],
+                     cpu.key[1],
+                     cpu.key[2],
+                     cpu.key[3],
+                     cpu.key[4],
+                     cpu.key[5]));
+#endif
         _bcm_rpc_unlink_request(req);
         sal_sem_destroy(req->sem);
         sal_free((void *)req);
         RPC_COUNT(_rpc_count_c_timeout);
         return BCM_E_TIMEOUT;
     }
diff -rpN '--unified=6' sdk-all-6.5.5/src/bcmx/bcmx.c esw_sdk_modified/src/bcmx/bcmx.c
--- sdk-all-6.5.5/src/bcmx/bcmx.c	2016-07-30 00:54:40.000000000 +0100
+++ esw_sdk_modified/src/bcmx/bcmx.c	2018-01-26 11:20:30.370358520 +0000
@@ -1055,15 +1055,15 @@ bcmx_device_attach(int bcm_unit)
         _bcmx_port_flags_create(&config, port, &port_flags);
 
         /* Add port */
         rv = _bcmx_port_add(bcm_unit, port, lport[i], port_flags);
         if (BCM_FAILURE(rv)) {
             LOG_WARN(BSL_LS_BCMX_COMMON,
-                     (BSL_META("BCMX: Failed to add lport 0x%x (unit %d, port %d). "
+                     (BSL_META("BCMX: Failed to add lport 0x%x (unit %d, port %d, port_flags=0x%x). "
                                "%d: %s.\n"),
-                      lport[i], bcm_unit, port, rv, bcm_errmsg(rv)));
+                      lport[i], bcm_unit, port, port_flags, rv, bcm_errmsg(rv)));
 
             /* If BCM_E_EXISTS, do not exit, try remaining ports */
             if (rv != BCM_E_EXISTS) {
                 BCMX_CONFIG_UNLOCK;
                 return rv;
             }
@@ -1857,13 +1857,15 @@ _bcmx_dest_to_bcm(_bcmx_dest_bcmx_t *fro
         to_bcm->mcast = from_bcmx->mcast;
 
     } else if (*flags & BCMX_DEST_TRUNK) {
         /* Check TRUNK flag next */
         flags_out |= BCMX_DEST_TRUNK;
         to_bcm->trunk = from_bcmx->trunk;
-
+#ifdef LVL7_FIXUP
+        to_bcm->module_id = 0;
+#endif
     } else {
         
         if (BCM_GPORT_IS_SET(from_bcmx->port)) {
             /*
              * If GPORT_AWARE flag is set, direct assignment
              * (BCM can handle gport format).
diff -rpN '--unified=6' sdk-all-6.5.5/src/bcmx/custom.c esw_sdk_modified/src/bcmx/custom.c
--- sdk-all-6.5.5/src/bcmx/custom.c	2016-07-30 00:54:40.000000000 +0100
+++ esw_sdk_modified/src/bcmx/custom.c	2018-01-26 11:20:30.370358520 +0000
@@ -83,13 +83,23 @@ bcmx_custom_port_set(bcmx_lport_t port,
          * custom routines continue to work.
          */
         if (BCM_FAILURE(_bcmx_dest_to_unit_port(port, &bcm_unit, &bcm_port,
                                                 BCMX_DEST_CONVERT_NON_GPORT))) {
             return BCM_E_PORT;
         }
+#ifdef LVL7_FIXUP
+        rv = bcm_custom_port_set(bcm_unit, bcm_port, type, len, args);
+        if (rv == BCM_E_UNIT)
+        {
+          rv = BCM_E_PORT;    
+        }
+
+        return rv;
+#else
         return bcm_custom_port_set(bcm_unit, bcm_port, type, len, args);
+#endif
     }
 
     /* Virtual port */
     BCMX_UNIT_ITER(bcm_unit, i) {
         tmp_rv = bcm_custom_port_set(bcm_unit, port, type, len, args);
         BCM_IF_ERROR_RETURN
@@ -117,14 +127,25 @@ bcmx_custom_port_get(bcmx_lport_t port,
          * custom routines continue to work.
          */
         if (BCM_FAILURE(_bcmx_dest_to_unit_port(port, &bcm_unit, &bcm_port,
                                                 BCMX_DEST_CONVERT_NON_GPORT))) {
             return BCM_E_PORT;
         }
+#ifdef LVL7_FIXUP
+        rv = bcm_custom_port_get(bcm_unit, bcm_port, type,
+                                 max_len, args, actual_len);
+        if (rv == BCM_E_UNIT)
+        {
+          rv = BCM_E_PORT;    
+        }
+
+        return rv;
+#else
         return bcm_custom_port_get(bcm_unit, bcm_port, type,
                                    max_len, args, actual_len);
+#endif
     }
 
     /* Virtual port */
     BCMX_UNIT_ITER(bcm_unit, i) {
         rv = bcm_custom_port_get(bcm_unit, port, type, max_len, args, actual_len);
         if (BCMX_CUSTOM_GET_IS_VALID(bcm_unit, rv)) {
diff -rpN '--unified=6' sdk-all-6.5.5/src/bcmx/mcast.c esw_sdk_modified/src/bcmx/mcast.c
--- sdk-all-6.5.5/src/bcmx/mcast.c	2016-07-30 00:54:40.000000000 +0100
+++ esw_sdk_modified/src/bcmx/mcast.c	2018-01-26 11:20:30.394358520 +0000
@@ -369,17 +369,28 @@ bcmx_mcast_join(bcm_mac_t mac,
 
     BCMX_MCAST_INIT_CHECK;
 
     BCM_IF_ERROR_RETURN
         (_bcmx_dest_to_unit_port(port, &bcm_unit, &bcm_port,
                                  BCMX_DEST_CONVERT_DEFAULT));
+#ifdef LVL7_FIXUP
+
+  /* If we pass NULL then code below will try to dereference
+  ** address 0.
+  */
+  rv = bcm_mcast_join(bcm_unit, mac, vid,
+                        bcm_port,
+                      &bcm_mca ,
+                      &pbmp );
+#else
 
     rv = bcm_mcast_join(bcm_unit, mac, vid,
                         bcm_port,
                         mcaddr ? &bcm_mca : NULL,
                         allrtr ? &pbmp : NULL);
+#endif
     if (BCM_SUCCESS(rv)) {
         if (mcaddr) {
             bcmx_mcast_addr_t_init(mcaddr, mac, vid);
             mcaddr->cos_dst = bcm_mca.cos_dst;
             mcaddr->l2mc_index = bcm_mca.l2mc_index;
             BCMX_LPLIST_PBMP_ADD(&mcaddr->ports, bcm_unit, bcm_mca.pbmp);
diff -rpN '--unified=6' sdk-all-6.5.5/src/sal/appl/editline/sysunix.c esw_sdk_modified/src/sal/appl/editline/sysunix.c
--- sdk-all-6.5.5/src/sal/appl/editline/sysunix.c	2016-07-30 00:54:41.000000000 +0100
+++ esw_sdk_modified/src/sal/appl/editline/sysunix.c	2018-01-26 11:20:30.358358520 +0000
@@ -20,21 +20,26 @@
   -1 Default initialize value which can not be 0 or 1. This is neccessary so 
      that when Reset is called the first time with either 0 or 1 that 
      actions will be taken.
   0 put device into raw mode. Disable echo so that editline can control it.
   1 restore device back to mode prior to raw mode.
 */
+/* PTin removed: serial port */
+#if (L7_SERIAL_COM_ATTR)
 static int sRESET_CURRENT = -1;
+#endif
 
 #if	defined(HAVE_TCGETATTR)
 #include <termios.h>
 
 void
 rl_ttyset(Reset)
     int				Reset;
 {
+/* PTin removed: serial port */
+#if (L7_SERIAL_COM_ATTR)
     static struct termios old;
     struct termios		  new;
 
     if (Reset != sRESET_CURRENT) {
       sRESET_CURRENT = Reset;
       if (Reset == 0) {
@@ -64,22 +69,25 @@ rl_ttyset(Reset)
         }
       } else {
         /* Reset must be 1. */
 	    (void)tcsetattr(0, TCSADRAIN, &old);
       }
     }
+#endif
 }
 
 #else
 #if	defined(HAVE_TERMIO)
 #include <termio.h>
 
 void
 rl_ttyset(Reset)
     int				Reset;
 {
+/* PTin removed: serial port */
+#if (L7_SERIAL_COM_ATTR)
     static struct termio old;
     struct termio		 new;
 
     if (Reset != sRESET_CURRENT) {
       sRESET_CURRENT = Reset;
       if (Reset == 0) {
@@ -104,21 +112,24 @@ rl_ttyset(Reset)
 	    new.c_cc[VTIME] = 0;
 	    (void)ioctl(0, TCSETAW, &new);
       } else {
         (void)ioctl(0, TCSETAW, &old);
       }
     }
+#endif
 }
 
 #else
 #include <sgtty.h>
 
 void
 rl_ttyset(Reset)
     int				Reset;
 {
+/* PTin removed: serial port */
+#if (L7_SERIAL_COM_ATTR)
     static struct sgttyb	old_sgttyb;
     static struct tchars	old_tchars;
     struct sgttyb		new_sgttyb;
     struct tchars		new_tchars;
 #if	defined(DO_SIGTSTP)
     struct ltchars		old_ltchars;
@@ -154,12 +165,13 @@ rl_ttyset(Reset)
 	    new_tchars.t_quitc = -1;
 	  (void)ioctl(0, TIOCSETC, &new_tchars);
       } else { (void)ioctl(0, TIOCSETP, &old_sgttyb);
         (void)ioctl(0, TIOCSETC, &old_tchars);
       }
     }
+#endif
 }
 #endif	/* defined(HAVE_TERMIO) */
 #endif	/* defined(HAVE_TCGETATTR) */
 
 void
 rl_add_slash(path, p)
diff -rpN '--unified=6' sdk-all-6.5.5/src/sal/appl/linux/sal.c esw_sdk_modified/src/sal/appl/linux/sal.c
--- sdk-all-6.5.5/src/sal/appl/linux/sal.c	2016-07-30 00:54:41.000000000 +0100
+++ esw_sdk_modified/src/sal/appl/linux/sal.c	2018-01-26 11:20:30.362358520 +0000
@@ -45,15 +45,21 @@
  * File: 	sal.c
  * Purpose:	Defines sal routines for Kernel-mode Linux targets.
  */
 
 #include <shared/bsl.h>
 
+#ifdef LVL7_FIXUP
+#include <ctype.h>
+#include <stdlib.h>
+#include "bspapi.h"
+#else
 #include <linux/ctype.h>
 #include <linux/kernel.h>
 #include <linux/random.h>
+#endif
 
 #include <sal/core/time.h>
 #include <sal/core/thread.h>
 #include <sal/core/sync.h>
 #include <sal/core/boot.h>
 #include <sal/core/spl.h>
@@ -274,12 +280,15 @@ sal_appl_init(void)
  *	Not supported for Linux kernel mode.
  */
 
 void
 sal_reboot(void)
 {
+#ifdef LVL7_FIXUP
+  bspapiSwitchReset();
+#endif
 }
 
 /*
  * Function:
  *	sal_shell
  * Purpose:
diff -rpN '--unified=6' sdk-all-6.5.5/src/sal/core/linux/thread.c esw_sdk_modified/src/sal/core/linux/thread.c
--- sdk-all-6.5.5/src/sal/core/linux/thread.c	2016-07-30 00:54:41.000000000 +0100
+++ esw_sdk_modified/src/sal/core/linux/thread.c	2018-01-26 11:20:30.338358520 +0000
@@ -190,13 +190,14 @@ do { \
 #endif
 
 #ifdef LKM_2_6
 #define SCHED_OTHER     SCHED_NORMAL
 #endif
 
-#ifdef MAX_USER_RT_PRIO
+//JORGE
+#if defined (MAX_USER_RT_PRIO) || LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 /* Assume 2.6 scheduler - Some Linux vendors have the 2.6 scheduler in 2.4 (MontaVista)
    This is a way of detecting it.
  */
 #define SET_USER_SCHED(task, prio) \
 do { \
     task->policy = SCHED_OTHER; \
diff -rpN '--unified=6' sdk-all-6.5.5/src/sal/core/unix/alloc.c esw_sdk_modified/src/sal/core/unix/alloc.c
--- sdk-all-6.5.5/src/sal/core/unix/alloc.c	2016-07-30 00:54:41.000000000 +0100
+++ esw_sdk_modified/src/sal/core/unix/alloc.c	2018-01-26 11:20:30.342358520 +0000
@@ -49,12 +49,17 @@
 #include <sys/types.h>
 #include <stdlib.h>
 #include <assert.h>
 
 #include <sal/types.h>
 
+#ifdef LVL7_FIXUP
+#include <soc/cm.h>
+#else
+#endif
+
 #include <sal/core/memlog.h>
 
 #ifdef MEMORY_MEASUREMENT_DIAGNOSTICS
 #include <shared/mem_measure_tool.h>
 #endif
 
@@ -411,15 +416,21 @@ sal_dma_alloc(size_t sz, char *s)
      * Round up size to accommodate corruption detection sentinels.
      * Place sentinels at the beginning and end of the data area to
      * detect memory corruption.  These are verified on free.
      */
     sz = (sz + 3) & ~3;
 
+#if defined(LVL7_FIXUP) && !defined(PLISIM)
+    if ((p = soc_cm_salloc(0,sz + 12 ,s)) == 0) {
+        return p;
+    }
+#else
     if ((p = malloc(sz + 12)) == 0) {
 	return p;
     }
+#endif
 
     assert(INT_TO_PTR(PTR_TO_INT(p)) == p);
 
     p[0] = sz / 4;
     p[1] = 0xaaaaaaaa;
     p[2 + sz / 4] = 0xbbbbbbbb;
@@ -489,14 +500,18 @@ sal_dma_free(void *addr)
 /* } */
 #endif /* BROADCOM_DEBUG */
 
     MEMLOG_FREE("sal_dma_free", ap);
 
     ap[1] = 0;			/* Detect redundant frees */
+#if defined(LVL7_FIXUP) && !defined(PLISIM)
+    soc_cm_sfree(0, ap);
+#else
     /*    coverity[address_free : FALSE]    */
     free(ap);
+#endif
 }
 
 /* } */
 #endif /* LINUX_SAL_DMA_ALLOC_OVERRIDE */
 
 /*
diff -rpN '--unified=6' sdk-all-6.5.5/src/sal/core/unix/boot.c esw_sdk_modified/src/sal/core/unix/boot.c
--- sdk-all-6.5.5/src/sal/core/unix/boot.c	2016-07-30 00:54:41.000000000 +0100
+++ esw_sdk_modified/src/sal/core/unix/boot.c	2018-01-26 11:20:30.346358520 +0000
@@ -57,12 +57,16 @@
 #include <sal/core/libc.h>
 #include <sal/core/boot.h>
 #include <sal/core/spl.h>
 #include <sal/core/dpc.h>
 #include <sal/core/sync.h>
 
+#include <bcm/init.h>
+#include <soc/drv.h>
+#include <bcm/error.h>
+
 #ifdef PLISIM
 #define DEFAULT_BOOT_FLAGS (BOOT_F_PLISIM | BOOT_F_NO_PROBE)
 #else
 #define DEFAULT_BOOT_FLAGS 0
 #endif
 
diff -rpN '--unified=6' sdk-all-6.5.5/src/sal/core/unix/thread.c esw_sdk_modified/src/sal/core/unix/thread.c
--- sdk-all-6.5.5/src/sal/core/unix/thread.c	2016-07-30 00:54:41.000000000 +0100
+++ esw_sdk_modified/src/sal/core/unix/thread.c	2018-01-26 11:20:30.342358520 +0000
@@ -81,16 +81,18 @@
 #endif
 
 #ifndef SAL_THREAD_RT_PRIO_HIGHEST
 #define SAL_THREAD_RT_PRIO_HIGHEST  90
 #endif
 
+#ifndef LVL7_FIXUP
 static pthread_mutex_t _sal_thread_lock = PTHREAD_MUTEX_INITIALIZER;
 
 #define THREAD_LOCK() pthread_mutex_lock(&_sal_thread_lock)
 #define THREAD_UNLOCK() pthread_mutex_unlock(&_sal_thread_lock)
+#endif
 
 #if defined(BROADCOM_DEBUG) && defined(INCLUDE_BCM_SAL_PROFILE)
 static unsigned int _sal_thread_count_curr;
 static unsigned int _sal_thread_count_max;
 static unsigned int _sal_thread_stack_size_curr;
 static unsigned int _sal_thread_stack_size_max;
@@ -147,12 +149,17 @@ sal_thread_resource_usage_get(unsigned i
 #    define PTHREAD_STACK_MIN PTHREAD_STACK_SIZE
 #  else
 #    define PTHREAD_STACK_MIN 0
 #  endif
 #endif
 
+#ifdef LVL7_FIXUP
+#include <l7_common.h>
+#include <osapi.h>
+#else
+
 /*
  * Function:
  *	thread_boot
  * Purpose:
  *	Entry point for each new thread created
  * Parameters:
@@ -217,12 +224,13 @@ thread_boot(void *ti_void)
     /* Thread function did not call sal_thread_exit() */
     sal_thread_exit(0);
 
     /* Will never get here */
     return NULL;
 }
+#endif /* LVL7_FIXUP */
 
 /*
  * Function:
  *	sal_thread_create
  * Purpose:
  *	Abstraction for task creation
@@ -236,12 +244,22 @@ thread_boot(void *ti_void)
  *	Thread ID
  */
 
 sal_thread_t
 sal_thread_create(char *name, int ss, int prio, void (f)(void *), void *arg)
 {
+#ifdef LVL7_FIXUP
+    L7_int32 salTaskHandle;
+
+    salTaskHandle = osapiTaskCreate(name, f, (L7_uint32) arg,
+                                    L7_NULLPTR, ss,
+                                    L7_DEFAULT_TASK_PRIORITY,
+                                    L7_DEFAULT_TASK_SLICE);
+
+    return (sal_thread_t) salTaskHandle;
+#else
     pthread_attr_t	attribs;
     struct sched_param param;
     thread_info_t	*ti;
     pthread_t		id;
     sal_sem_t           sem;
 
@@ -315,12 +333,13 @@ sal_thread_create(char *name, int ss, in
      * to update thread_info_t and tell us to continue.
      */
     sal_sem_take(sem, sal_sem_FOREVER);
     sal_sem_destroy(sem);
 
     return ((sal_thread_t)id);
+#endif /* LVL7_FIXUP */
 }
 
 /*
  * Function:
  *	sal_thread_destroy
  * Purpose:
@@ -340,12 +359,19 @@ sal_thread_create(char *name, int ss, in
  *	sal_thread_exit().
  */
 
 int
 sal_thread_destroy(sal_thread_t thread)
 {
+#ifdef LVL7_FIXUP
+    L7_int32 salTaskHandle = (L7_int32) thread;
+
+    osapiTaskDelete(salTaskHandle);
+
+    return 0;
+#else
 #ifdef netbsd
     /* not supported */
     return -1;
 #else
     thread_info_t	*ti, **tp;
     pthread_t		id = (pthread_t) thread;
@@ -377,12 +403,13 @@ sal_thread_destroy(sal_thread_t thread)
         }
         free(ti);
     }
 
     return 0;
 #endif
+#endif /* LVL7_FIXUP */
 }
 
 /*
  * Function:
  *	sal_thread_self
  * Purpose:
@@ -393,13 +420,17 @@ sal_thread_destroy(sal_thread_t thread)
  *	Thread ID
  */
 
 sal_thread_t
 sal_thread_self(void)
 {
+#ifdef LVL7_FIXUP
+    return (sal_thread_t) osapiTaskIdSelf();
+#else
     return (sal_thread_t) pthread_self();
+#endif /* LVL7_FIXUP */
 }
 
 int
 sal_thread_id_get(void)
 {
     return syscall(SYS_gettid);
@@ -410,15 +441,25 @@ sal_thread_self(void)
  *		gets empty string if not available
  *	thread_name_size - maximum size of buffer
  * Returns:
  *	NULL, if name not available
  *	thread_name, if name available
  */
+#ifdef LVL7_FIXUP
+extern pthread_key_t osapi_name_key;
+#endif /* LVL7_FIXUP */
 char *
 sal_thread_name(sal_thread_t thread, char *thread_name, int thread_name_size)
 {
+#ifdef LVL7_FIXUP
+    char *task_name;
+
+    task_name = (char *) pthread_getspecific(osapi_name_key);
+    strncpy(thread_name, task_name, thread_name_size);
+    return thread_name;
+#else
     thread_info_t	*ti;
     char                *name;
 
     name = NULL;
 
     THREAD_LOCK();
@@ -434,12 +475,13 @@ sal_thread_name(sal_thread_t thread, cha
 
     if (name == NULL) {
         thread_name[0] = 0;
     }
 
     return name;
+#endif /* LVL7_FIXUP */
 }
 
 /*
  * Function:
  *	sal_thread_exit
  * Purpose:
@@ -450,12 +492,20 @@ sal_thread_name(sal_thread_t thread, cha
  *	Never returns.
  */
 
 void
 sal_thread_exit(int rc)
 {
+#ifdef LVL7_FIXUP
+  L7_int32 salTaskHandler = osapiTaskIdSelf();
+
+  osapiTaskDelete(salTaskHandler);
+
+  return;
+
+#else
     thread_info_t	*ti, **tp;
     pthread_t		id = pthread_self();
 
     ti = NULL;
 
     THREAD_LOCK();
@@ -478,12 +528,13 @@ sal_thread_exit(int rc)
             free(ti->name);
         }
         free(ti);
     }
 
     pthread_exit(INT_TO_PTR(rc));
+#endif /* LVL7_FIXUP */
 }
 
 /*
  * Function:
  *	sal_thread_yield
  * Purpose:
diff -rpN '--unified=6' sdk-all-6.5.5/src/shared/bsl.c esw_sdk_modified/src/shared/bsl.c
--- sdk-all-6.5.5/src/shared/bsl.c	2016-07-30 00:54:41.000000000 +0100
+++ esw_sdk_modified/src/shared/bsl.c	2018-01-26 11:20:32.122358520 +0000
@@ -69,12 +69,21 @@ bsl_init(bsl_config_t *config)
 void
 bsl_config_t_init(bsl_config_t *config)
 {
     sal_memset(config, 0, sizeof(*config));
 }
 
+/* PTin added: LOG */
+int
+bsl_vectors_get(bsl_config_t * dst)
+{
+    *dst = bsl_config;
+    return 0;
+}
+
+
 /* "Fast" checker function */
 int
 bsl_fast_check(uint32 chk)
 {
     if (bsl_config.check_hook != NULL) {
         return bsl_config.check_hook(chk);
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/common/cm.c esw_sdk_modified/src/soc/common/cm.c
--- sdk-all-6.5.5/src/soc/common/cm.c	2016-07-30 00:54:43.000000000 +0100
+++ esw_sdk_modified/src/soc/common/cm.c	2018-01-26 11:20:43.126358520 +0000
@@ -76,12 +76,15 @@
 #ifdef BCM_DFE_SUPPORT
 #include <soc/dfe/cmn/dfe_drv.h>
 #endif
 
 #include <sal/core/memlog.h>
 
+/* PTin added: logger */
+#include "logger.h"
+
 #if defined(BCM_ESW_SUPPORT) || defined(BCM_SAND_SUPPORT)
 #define IHOST_S0_ADDR_START 0x19000000
 #define IHOST_S0_ADDR_END  0x1901FFFF
 #define IHOST_ACP_ADDR_START 0x19020000
 #define IHOST_ACP_ADDR_END  0x19022FFF
 
@@ -7484,12 +7487,17 @@ soc_cm_salloc(int dev, int size, const c
 #ifdef BROADCOM_DEBUG
     if (soc_cm_debug_property_get(dev)) {
         shared_block_t  *p = NULL;
         uint32             size_words = (size + 3) / 4;
         uint32             modified_size = 0;
 
+        if (name == NULL || name[0] == 0)
+        {
+          PT_LOG_FATAL(LOG_CTX_SDK,"XXXXXX - SEGMENTATION FAULT - XXXXXX");
+        }
+
         assert(name != NULL);        /* Don't pass NULLs in here! */
         assert(name[0] != 0);        /* Don't pass empty strings in here! */
 
         modified_size = sizeof (shared_block_t) + (size_words * 4);
         p = CMVEC(dev).salloc(&CMDEV(dev).dev, modified_size, name);
 
@@ -7558,12 +7566,17 @@ soc_cm_sfree(int dev, void *ptr)
         int            size_words = 0;
         */
 
         p = (shared_block_t *) (((char*)ptr) -
         ( (((char*)&(((shared_block_t*)0)->user_data[0]))) - ((char*)(shared_block_t*)0) ));
 
+        if (p == NULL)
+        {
+          PT_LOG_FATAL(LOG_CTX_SDK,"XXXXXX - SEGMENTATION FAULT - XXXXXX");
+        }
+
         assert(SHARED_GOOD_START(p));
         assert(SHARED_GOOD_END(p));
         /*
         size_words = (p->size + 3) / 4;
         LOG_VERBOSE(BSL_LS_SOC_MEM,
                 (BSL_META("Freeing Start:%x: Desc:%s: Size:%d: 
@@ -7575,12 +7588,16 @@ soc_cm_sfree(int dev, void *ptr)
         if (p == head) {
             head = p->next;
             if (head != NULL) {
                 head->prev = NULL;
             }
         } else {
+            if (p->prev == NULL)
+            {
+              PT_LOG_FATAL(LOG_CTX_SDK,"XXXXXX - SEGMENTATION FAULT - XXXXXX");
+            }
             p->prev->next = p->next;
             if (p->next != NULL) {
                 p->next->prev = p->prev;
             }
         }
         CM_DB_UNLOCK();
@@ -7715,12 +7732,19 @@ soc_cm_sflush(int dev, void *addr, int l
  * Returns:     SOC_E_XXX
  */
 
 int
 soc_cm_sinval(int dev, void *addr, int length)
 {
+#if defined(LVL7_FIXUP) && defined(LVL7_DNI8541)
+/* The cache doesn't need to be synced on the PPC85XX processor. 
+** Invoking the function causes a crash on the PPC85XX devices.
+*/
+    return SOC_E_NONE;
+#endif	
+
     if (CMVEC(dev).sinval) {
         return CMVEC(dev).sinval(&CMDEV(dev).dev, addr, length);
     }
 
     return SOC_E_NONE;
 }
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/common/ddrc28.c esw_sdk_modified/src/soc/common/ddrc28.c
--- sdk-all-6.5.5/src/soc/common/ddrc28.c	2016-07-30 00:54:43.000000000 +0100
+++ esw_sdk_modified/src/soc/common/ddrc28.c	2018-01-26 11:20:43.250358520 +0000
@@ -94,13 +94,13 @@ int soc_phy_ddrc28_reg_field_set(int uni
 
     if (finfop->len < 32) 
     {
         mask = (1 << finfop->len) - 1;
         if ((value & ~mask) != 0) 
         {
-            LOG_ERROR(BSL_LS_SOC_DDR, (BSL_META_U(unit, "soc_phy_ddrc28_reg_field_set(): value too big for field\n")));
+            LOG_ERROR(BSL_LS_SOC_DDR, (BSL_META_U(unit, "soc_phy_ddrc28_reg_field_set(): value too big for field [reg=0x%x regval=%u field=%d value=%u mask=%u]\n"), reg, *regval, field, value, mask));
             return SOC_E_PARAM;
         }
     } else {
         mask = -1;
     }
 
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/common/dma.c esw_sdk_modified/src/soc/common/dma.c
--- sdk-all-6.5.5/src/soc/common/dma.c	2016-07-30 00:54:43.000000000 +0100
+++ esw_sdk_modified/src/soc/common/dma.c	2018-01-26 11:20:43.094358520 +0000
@@ -96,12 +96,16 @@
 #endif
 
 #ifdef INCLUDE_KNET
 #include <soc/knet.h>
 #endif
 
+/* PTin added */
+#include "logger.h"
+#include "unistd.h"
+
 #ifdef BCM_CMIC_SUPPORT
 
 #define DV_MAGIC_NUMBER 0xba5eba11
 
 #define DMA_CHAIN_DONE_TIMEOUT_USEC         (4000)
 #define DMA_CHAIN_DONE_INTERVAL_USEC        (1000)
@@ -1866,13 +1870,32 @@ soc_dma_done_chain(int unit, uint32 vcha
      */
 
     cmic_drv[unit].chan_chain_done(unit, vchan, sdc_mtg->mitigation_started);
 
     soc_dma_start_channel(unit, sc);
 
-    soc_dma_process_done_desc(unit, dv_chain, dv_active);
+    /* PTIn added: By calling this multiple times it should force a cache flush. */
+    int i = 0;
+    do
+    {
+      soc_dma_process_done_desc(unit, dv_chain, dv_active);
+
+      /* Wait 1 millisecond, if process not completed */
+      if (dv_chain->dv_dcnt != dv_chain->dv_vcnt)
+        usleep(10000);
+    } while ((dv_chain->dv_dcnt != dv_chain->dv_vcnt) && ((++i) < 100));
+
+    /* PTin added: print assert info */
+    if (dv_chain->dv_dcnt != dv_chain->dv_vcnt)
+    {
+      PT_LOG_ERR(LOG_CTX_SDK, "dv_chain->dv_dcnt=%d, dv_chain->dv_vcnt=%d", dv_chain->dv_dcnt, dv_chain->dv_vcnt);
+    }
+    else if (i > 0)
+    {
+      PT_LOG_WARN(LOG_CTX_SDK, "%u tries to achieve dv_chain->dv_dcnt (%d) == dv_chain->dv_vcnt (%d)", i, dv_chain->dv_dcnt, dv_chain->dv_vcnt);
+    }
 
     assert(dv_chain->dv_dcnt == dv_chain->dv_vcnt); 
 
     if (dv_chain->dv_flags & DV_F_NOTIFY_CHN) {
         if (dv_chain->dv_done_chain == NULL) {
             LOG_WARN(BSL_LS_SOC_PACKETDMA,
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/common/mem.c esw_sdk_modified/src/soc/common/mem.c
--- sdk-all-6.5.5/src/soc/common/mem.c	2016-07-30 00:54:43.000000000 +0100
+++ esw_sdk_modified/src/soc/common/mem.c	2018-01-26 11:20:42.982358520 +0000
@@ -18506,19 +18506,31 @@ _soc_mem_dual_hash_insert(int unit,
         if (hash_info.hash_sel0 == hash_info.hash_sel1) {
             /* Can't juggle the entries */
             return SOC_E_FULL;
         }
         hash_info.bucket_size = SOC_L2X_BUCKET_SIZE;
         hash_info.base_mem = mem;
+#ifdef LVL7_FIXUP
+       /* soc_l2x_freeze/thaw routine are very costly as they try to disable
+        * learning on all Physical and VPs. In cases where we are continously
+        * running into hash collision, freeze/thaw ends up taking a lot of 
+        * cpu time un-neccessarily as we have not enabled software dual-hash
+        * move by default. */
+       if (recurse_depth > 0)
+       {
+#endif
 
         /* Time to shuffle the entries */
         SOC_IF_ERROR_RETURN(soc_l2x_freeze(unit));
         rv = _soc_mem_dual_hash_move(unit, mem, SOC_MEM_HASH_BANK_BOTH,
                                      copyno, entry_data, &hash_info,
                                      NULL, recurse_depth - 1,0);
         SOC_IF_ERROR_RETURN(soc_l2x_thaw(unit));
+#ifdef LVL7_FIXUP
+       }
+#endif
         return rv;
 #if defined(BCM_TRIUMPH_SUPPORT)
 #endif /* BCM_TRIUMPH_SUPPORT */
 #ifdef BCM_TRX_SUPPORT
     case VLAN_XLATEm:
         if (!SOC_IS_TRX(unit)) {
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/dfe/fe1600/fe1600_interrupt.c esw_sdk_modified/src/soc/dfe/fe1600/fe1600_interrupt.c
--- sdk-all-6.5.5/src/soc/dfe/fe1600/fe1600_interrupt.c	2016-07-30 00:54:43.000000000 +0100
+++ esw_sdk_modified/src/soc/dfe/fe1600/fe1600_interrupt.c	2018-01-26 11:20:34.894358520 +0000
@@ -161,13 +161,13 @@ static soc_interrupt_clear_read_fifo_t F
 };
 
 
 int fe1600_interrupts_array_init(int unit)  
 {
     int intr_id;
-    char* interrupts_info_allocation= "interrupts_info_allocation";
+    //char* interrupts_info_allocation= "interrupts_info_allocation";
     soc_interrupt_db_t *fe1600_interrupts;            
     soc_interrupt_tree_t *fe1600_interrupt_tree;
     SOCDNX_INIT_FUNC_DEFS;
 	SOC_FE1600_ONLY(unit);
 
     SOC_CONTROL(unit)->interrupts_info = sal_alloc(sizeof(soc_interrupt_t), "DFE: fe1600_interrupts");
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/dpp/ARAD/arad_drv.c esw_sdk_modified/src/soc/dpp/ARAD/arad_drv.c
--- sdk-all-6.5.5/src/soc/dpp/ARAD/arad_drv.c	2016-07-30 00:54:44.000000000 +0100
+++ esw_sdk_modified/src/soc/dpp/ARAD/arad_drv.c	2018-01-26 11:20:44.474358520 +0000
@@ -5018,13 +5018,13 @@ soc_arad_info_config(int unit)
     val = soc_property_get(unit, spn_TDM_EGRESS_DP, 0);
     dpp_arad->init.tdm_egress_dp = val;
 
     /*
      * Init NIF ports
      */
-    dpp_arad->init.nif_recovery_enable = soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "nif_recovery_enable", 1);
+    dpp_arad->init.nif_recovery_enable = soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "nif_recovery_enable", 0);	/* PTin modified: startup */
     dpp_arad->init.nif_recovery_iter = soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "nif_recovery_iter", 5);
 
     /*
      * rcy port allocation per channel for channelized interfaces
      */
     dpp_arad->init.rcy_channelized_shared_context_enable = soc_property_get(unit, spn_RCY_CHANNELIZED_SHARED_CONTEXT_ENABLE, 0);
@@ -5798,14 +5798,42 @@ soc_arad_info_config(int unit)
                 dpp_arad->init.drc_info.zq_calib_map[1] = 1;
                 dpp_arad->init.drc_info.zq_calib_map[2] = 3;
                 dpp_arad->init.drc_info.zq_calib_map[3] = 3;    
 
             } else if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
                 dram_bitmap = soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "dram_bitamp", 0x0);
+                printf("%s(%d) dram_bitmap=0x%x\r\n", __FUNCTION__, __LINE__, dram_bitmap);
                 if (dram_bitmap != 0) {
                     SHR_BITCOPY_RANGE(dpp_arad->init.drc_info.dram_bitmap, 0, &dram_bitmap, 0, SOC_DPP_DEFS_GET(unit, hw_dram_interfaces_max));
+
+                    /* Ref CLK: A is the master of B, C is the master of D, F is the master of E, H is the master of G. */
+                    SHR_BITSET(dpp_arad->init.drc_info.ref_clk_bitmap, 0);
+                    SHR_BITSET(dpp_arad->init.drc_info.ref_clk_bitmap, 2);
+                    SHR_BITSET(dpp_arad->init.drc_info.ref_clk_bitmap, 5);
+                    SHR_BITSET(dpp_arad->init.drc_info.ref_clk_bitmap, 7);
+
+                    /* 
+                     * Jericho ZQ calibration mapping:
+                     * A slave of C
+                     * B slave of C
+                     * C is Master
+                     * D slave of C
+                     * E slave of F
+                     * F is Master
+                     * G slave of F
+                     * H slave of F
+                     */
+                    dpp_arad->init.drc_info.zq_calib_map[0] = 2;
+                    dpp_arad->init.drc_info.zq_calib_map[1] = 2;
+                    dpp_arad->init.drc_info.zq_calib_map[2] = 2;
+                    dpp_arad->init.drc_info.zq_calib_map[3] = 2;
+                    dpp_arad->init.drc_info.zq_calib_map[4] = 5;
+                    dpp_arad->init.drc_info.zq_calib_map[5] = 5;
+                    dpp_arad->init.drc_info.zq_calib_map[6] = 5;
+                    dpp_arad->init.drc_info.zq_calib_map[7] = 5;
+
                 } else {
 
                     /* Allowed values for Jericho/88675:
                      *  0
                      *  2  (Dram's A, C)
                      *  3  (Dram's A, B, C)
@@ -5823,12 +5851,13 @@ soc_arad_info_config(int unit)
                         break;
                     case 3:
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 0);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 1);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 2);
                         break;
+                    case 4:
                     case 41:
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 0);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 1);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 2);
                         SHR_BITSET(dpp_arad->init.drc_info.dram_bitmap, 3);
                         break;
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/dpp/DRC/drc_combo28_init.c esw_sdk_modified/src/soc/dpp/DRC/drc_combo28_init.c
--- sdk-all-6.5.5/src/soc/dpp/DRC/drc_combo28_init.c	2016-07-30 00:54:45.000000000 +0100
+++ esw_sdk_modified/src/soc/dpp/DRC/drc_combo28_init.c	2018-01-26 11:20:44.634358520 +0000
@@ -1852,28 +1852,28 @@ int soc_dpp_drc_combo28_init_check_bist_
     SOCDNX_NULL_CHECK(combo28_bist_err_cnt);
 
     is_gddr5 = (drc_info->dram_type == SHMOO_COMBO28_DRAM_TYPE_GDDR5);
     is_crc   = ((drc_info->write_crc == 1) && (drc_info->read_crc == 1));
 
     /* Print Result */
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "\nDRAM index: %u \nResults:\n"), dram_ndx));
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "\nDRAM index: %u \nResults:\n"), dram_ndx));
     /* Mapping of bits with errors : 0x%x (bit N stands for an error in bits N, N+32, ... N+224) */
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_err_occur));
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_err_occur));
     /* Number of errors occoured in bits that are not masked by bist full mask: %d */
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of errors occoured (bist full mask): %d\n"), combo28_bist_err_cnt->bist_full_err_cnt)); 
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of errors occoured (bist full mask): %d\n"), combo28_bist_err_cnt->bist_full_err_cnt)); 
     /* Number of errors occoured in bits that are not masked by bist single bit mask: %d */
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of errors occoured (bist single mask): %d\n"), combo28_bist_err_cnt->bist_single_err_cnt)); 
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of global errors: %d\n"), combo28_bist_err_cnt->bist_global_err_cnt));
-    LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of DBI errors: %d\n"), combo28_bist_err_cnt->bist_dbi_global_err_cnt));
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of errors occoured (bist single mask): %d\n"), combo28_bist_err_cnt->bist_single_err_cnt)); 
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of global errors: %d\n"), combo28_bist_err_cnt->bist_global_err_cnt));
+    LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of DBI errors: %d\n"), combo28_bist_err_cnt->bist_dbi_global_err_cnt));
     /* Mapping of DBI bits with errors : 0x%x (bit N stands for an error in bits N, N+8, ... N+24) */
     LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of DBI bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_dbi_err_occur));
     if ((is_gddr5 == 1) && (is_crc == 1))
     {
-        LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of EDC errors: %d\n"), combo28_bist_err_cnt->bist_edc_global_err_cnt));
+        LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Number of EDC errors: %d\n"), combo28_bist_err_cnt->bist_edc_global_err_cnt));
         /* Mapping of EDC bits with errors : 0x%x (bit N stands for an error in bits N, N+8, ... N+24) */
-        LOG_VERBOSE(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of EDC bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_edc_err_occur));
+        LOG_INFO(BSL_LS_SOC_DRAM, (BSL_META_U(unit, "Mapping of EDC bits with errors : 0x%x \n"), combo28_bist_err_cnt->bist_edc_err_occur));
     }
 
     /* Check BIST resault */
     if ((combo28_bist_err_cnt->bist_err_occur != 0x0)          || (combo28_bist_err_cnt->bist_full_err_cnt != 0x0)   || 
         (combo28_bist_err_cnt->bist_single_err_cnt != 0x0)     || (combo28_bist_err_cnt->bist_global_err_cnt != 0x0) ||
         (combo28_bist_err_cnt->bist_dbi_global_err_cnt != 0x0) || (combo28_bist_err_cnt->bist_dbi_err_occur != 0x0)  || 
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/i2c/bus.c esw_sdk_modified/src/soc/i2c/bus.c
--- sdk-all-6.5.5/src/soc/i2c/bus.c	2016-07-30 00:54:47.000000000 +0100
+++ esw_sdk_modified/src/soc/i2c/bus.c	2018-01-26 11:20:44.642358520 +0000
@@ -2186,6 +2186,105 @@ soc_i2c_show_speeds(int unit)
                  i2c_xgs3_freq_tab[i].n : i2c_freq_tab[i].n,
                  SOC_IS_XGS3_SWITCH(unit) ?
                  i2c_xgs3_freq_tab[i].speed : i2c_freq_tab[i].speed));
     }
 }
 
+#ifdef LVL7_FIXUP
+int
+soc_i2c_read_test(int unit, uint8 devid, uint8 *ptr, int len)
+{
+    int rv = SOC_E_NONE;
+    int i;
+
+    if ( (rv = soc_i2c_start(unit, SOC_I2C_RX_ADDR(devid) ) ) < 0 ) {
+        LOG_ERROR(BSL_LS_SOC_I2C,
+                      (BSL_META_U(unit,
+                                  "i2c%d: soc_i2c_read_byte_data: failed to generate start.\n"),
+                       unit));
+        return rv;
+    }
+
+    do {
+        for (i = 0; i < len; i++) {
+           if (i == len - 1) {
+             if ( (rv = soc_i2c_read_one_byte(unit, ptr,
+                                              FALSE)) < 0 ) {
+               LOG_ERROR(BSL_LS_SOC_I2C,
+                             (BSL_META_U(unit,
+                                         "i2c%d: soc_i2c_read_byte_data: failed to read data byte.\n"),
+                              unit));
+             }
+           } else {
+             if ( (rv = soc_i2c_read_one_byte(unit, ptr,
+                                              TRUE)) < 0 ) {
+               LOG_ERROR(BSL_LS_SOC_I2C,
+                             (BSL_META_U(unit,
+                                         "i2c%d: soc_i2c_read_byte_data: failed to read data byte.\n"),
+                              unit));
+             }
+           }
+           ptr++;
+        }
+    } while (0);
+
+    soc_i2c_stop(unit);
+
+    return rv;
+
+
+}
+
+int
+soc_i2c_write_test(int unit, uint8 devid, uint8 *ptr, int len)
+{
+    int rv = SOC_E_NONE;
+    int i;
+
+    if ( (rv = soc_i2c_start(unit, SOC_I2C_TX_ADDR(devid) ) ) < 0 ) {
+        LOG_ERROR(BSL_LS_SOC_I2C,
+                      (BSL_META_U(unit,
+                                  "i2c%d: soc_i2c_write_test: failed to generate start.\n"),
+                       unit));
+        return rv;
+    }
+
+    do {
+        for (i = 0; i < len; i++) {
+
+              LOG_INFO(BSL_LS_SOC_I2C,
+                           (BSL_META_U(unit,
+                                       "i2c%d: soc_i2c_write_test: writing byte%d = %d\n"),
+                            unit, i, *ptr));
+
+             if ( (rv = soc_i2c_write_one_byte(unit, *ptr)) < 0 ) {
+                LOG_ERROR(BSL_LS_SOC_I2C,
+                              (BSL_META_U(unit,
+                                          "i2c%d: soc_i2c_write_test: failed to write data byte.\n"),
+                               unit));
+             }
+           ptr++;
+        }
+    } while (0);
+
+    soc_i2c_stop(unit);
+
+    return rv;
+
+}
+
+void soc_i2c_regdump()
+{
+  int unit = 0;
+
+  LOG_INFO(BSL_LS_SOC_I2C,
+               (BSL_META_U(unit,
+                           "soc_i2c_regdump: SLAVE_ADDR: 0x%02x DATA: 0x%02x CTRL: 0x%02x STAT: 0x%02x SLAVE_XADDR: 0x%02x RESET: 0x%02x\n"),
+                soc_i2c_pci_read(unit, CMIC_I2C_SLAVE_ADDR),
+                soc_i2c_pci_read(unit, CMIC_I2C_DATA),
+                soc_i2c_pci_read(unit, CMIC_I2C_CTRL),
+                soc_i2c_pci_read(unit, CMIC_I2C_STAT),
+                soc_i2c_pci_read(unit, CMIC_I2C_SLAVE_XADDR),
+                soc_i2c_pci_read(unit, CMIC_I2C_RESET)));
+}
+#endif /* LVL7_FIXUP */
+
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/hl65.c esw_sdk_modified/src/soc/phy/hl65.c
--- sdk-all-6.5.5/src/soc/phy/hl65.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/hl65.c	2018-01-26 11:20:34.490358520 +0000
@@ -2130,19 +2130,19 @@ phy_hl65_speed_get(int unit, soc_port_t
                 *speed = 12000;
                 break;
             default:
                 break;
         }
 
-        LOG_INFO(BSL_LS_SOC_PHY,
-                 (BSL_META_U(unit,
-                             "phy_hl65_speed_get: u=%d p=%d GP_STATUS_TOPANSTATUS1 %04x speed= %d\n"),
-                  unit, port,
-                  ((xgxs_stat & GP_STATUS_XGXSSTATUS1_ACTUAL_SPEED_LN0_MASK) >>
-                  GP_STATUS_XGXSSTATUS1_ACTUAL_SPEED_LN0_SHIFT), *speed));
-
+        /* PTin modified: logs */
+        LOG_DEBUG(BSL_LS_SOC_PHY,
+                      (BSL_META_U(unit,
+                                  "phy_hl65_speed_get: u=%d p=%d GP_STATUS_TOPANSTATUS1 %04x speed= %d\n"),
+                       unit, port,
+                       ((xgxs_stat & GP_STATUS_XGXSSTATUS1_ACTUAL_SPEED_LN0_MASK) >>
+                        GP_STATUS_XGXSSTATUS1_ACTUAL_SPEED_LN0_SHIFT), *speed));
     }
     return SOC_E_NONE;
 }
 
 /*
  * Function:    
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/phy5464.c esw_sdk_modified/src/soc/phy/phy5464.c
--- sdk-all-6.5.5/src/soc/phy/phy5464.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/phy5464.c	2018-01-26 11:20:34.422358520 +0000
@@ -146,12 +146,17 @@
 #include <soc/phyreg.h>
 
 #include <soc/phy.h>
 #include <soc/phy/phyctrl.h>
 #include <soc/phy/drv.h>
 
+#ifdef LVL7_FIXUP
+#include "sysapi_hpc.h"
+#include "hpc_phy.h"
+#endif
+
 #include "phydefs.h"      /* Must include before other phy related includes */
 
 #if defined(INCLUDE_PHY_5464_ESW)
 #include "phyconfig.h"    /* Must be the first phy include after phydefs.h */
 
 #include "phyident.h"
@@ -235,12 +240,16 @@ STATIC int _phy_5464_medium_change(int u
 STATIC int
 _phy_5464_medium_check(int unit, soc_port_t port, int *medium)
 {
     phy_ctrl_t        *pc;    /* PHY state */
     uint16             tmp;    /* Temp variable */
     int                copper; /* Copper medium is active */
+#if (defined(LVL7_FIXUP) && \
+    (defined(LVL7_ALPHA8245) || defined(LVL7_DNI8541)))
+static int              fiberCnt[2][24];
+#endif
 
     pc    = EXT_PHY_SW_STATE(unit, port);
     /* Read Mode Register (0x1c shadow 11111) */
     SOC_IF_ERROR_RETURN
         (READ_PHY5464_MODE_CTRLr(unit, pc, &tmp));
     if (PHY_FORCED_COPPER_MODE(unit, port)) {
@@ -252,13 +261,28 @@ _phy_5464_medium_check(int unit, soc_por
             copper = FALSE;
         } else {
             if (pc->fiber.preferred) {
                 /* 0x10 Fiber Signal Detect
                  * 0x20 Copper Energy Detect
                  */
+#if (defined(LVL7_FIXUP) && \
+    (defined(LVL7_ALPHA8245) || defined(LVL7_DNI8541)))
+                copper = TRUE;
+                if ((tmp & 0x10) == 0x10) {
+                    fiberCnt[unit][port]++;
+                    /* Require multiple detections so as not to prematurely    */
+                    /* disable the copper transmitter because of a transition. */
+                    if (fiberCnt[unit][port] > 5) {
+                        copper = FALSE;
+                    }
+                } else {
+                    fiberCnt[unit][port] = 0;
+                }
+#else
                 copper = ((tmp & 0x30) == 0x20); 
+#endif
             } else {
                 copper = ((tmp & 0x20) == 0x20);
             }
         }
     }
     *medium = copper ? SOC_PORT_MEDIUM_COPPER : SOC_PORT_MEDIUM_FIBER;
@@ -1332,12 +1356,19 @@ phy_5464_link_get(int unit, soc_port_t p
         if (PHY_FIBER_MODE(unit, port)) {
             copper_transmit = (*link) ? 0x2000 : 0; 
         }
         SOC_IF_ERROR_RETURN
             (MODIFY_PHY5464_MII_ECRr(unit, pc, copper_transmit, 0x2000));
     }
+#ifdef LVL7_FIXUP 
+    /* alok relook*/
+    if (soc_property_get(unit, spn_LED_MODE_CUST, 0))
+    {
+      (void)sysapiHpcLedModeCustomization(unit, (int)port, *link);
+    }
+#endif
 
     DPRINTF_VERBOSE((BSL_META_U(unit,
                                 "phy_5464_link_get: "
                                 "u=%d p=%d mode=%s%s%s link=%d\n"),
                     unit, port,
                     PHY_COPPER_MODE(unit, port) ? "C" : "",
@@ -3227,12 +3258,16 @@ phy_5464_shadow_dump(int unit, soc_port_
     uint16      tmp;
     int         i;
     phy_ctrl_t *pc;
 
     pc       = EXT_PHY_SW_STATE(unit, port);
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     /* Register 0x18 Shadows */
     for (i = 0; i <= 7; i++) {
         WRITE_PHY_REG(unit, pc, 0x18, (i << 12) | 0x7);
         READ_PHY_REG(unit, pc, 0x18, &tmp);
         if ((tmp & ~7) == 0x0000) {
             continue;
@@ -3259,16 +3294,66 @@ phy_5464_shadow_dump(int unit, soc_port_
         if (tmp  == 0x0000) {
             continue;
         }
         LOG_CLI((BSL_META_U(unit,
                             "0x17[0x%x]=0x%04x\n"), i, tmp));
     }
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
 }
 
 #endif /* BROADCOM_DEBUG */
 
+#ifdef LVL7_FIXUP
+/*
+ * Function:    
+ *      phy_5464_link_up
+ * Purpose:     
+ *      Performs tasks on link up.
+ * Parameters:
+ *      unit - StrataSwitch unit #.
+ *      port - StrataSwitch port #. 
+ * Returns:     
+ *      SOC_E_XXX
+ * Notes:
+ *      sees link up.
+ */
+STATIC int
+phy_5464_link_up(int unit, soc_port_t port)
+{
+    int an, an_done;
+
+    DPRINTF((BSL_META_U(unit,
+                        "phy_5464_link_up: u=%d p=%d \n"),
+             unit, port));
+
+    /* For copper mode only */
+    if (PHY_FLAGS_TST(unit, port, PHY_FLAGS_COPPER)) {
+        /* Get the an status */
+        SOC_IF_ERROR_RETURN
+            (phy_5464_autoneg_get(unit, port, &an, &an_done));
+
+        /* If an is diabled and link up happens then enable PHY 
+        ** as on combp ports it does not happen 
+        */
+        if (an == FALSE) {
+
+            SOC_IF_ERROR_RETURN
+               (soc_phyctrl_notify(unit, port, phyEventResume, PHY_STOP_PHY_DIS));
+
+            DPRINTF((BSL_META_U(unit,
+                                "phy_5464_link_up: Resume PHY_STOP_PHY_DIS for u=%d p=%d \n"),
+                     unit, port));
+        }
+    }
+    return SOC_E_NONE;
+}
+#endif /* LVL7_FIXUP */
+
 /*
  * Variable:    phy_5464drv_ge
  * Purpose:     PHY driver for 5464
  */
 
 phy_driver_t phy_5464drv_ge = {
@@ -3291,13 +3376,17 @@ phy_driver_t phy_5464drv_ge = {
     phy_5464_adv_remote_get,
     phy_5464_lb_set,
     phy_5464_lb_get,
     phy_5464_interface_set,
     phy_5464_interface_get,
     phy_5464_ability_get,
-    NULL,                       /* Link up event */
+#ifdef LVL7_FIXUP
+    phy_5464_link_up,          /* Link up event */
+#else 
+    NULL,
+#endif
     phy_5464_link_down,
     phy_5464_mdix_set,
     phy_5464_mdix_get,
     phy_5464_mdix_status_get,
     phy_5464_medium_config_set,
     phy_5464_medium_config_get,
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/phy54680.c esw_sdk_modified/src/soc/phy/phy54680.c
--- sdk-all-6.5.5/src/soc/phy/phy54680.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/phy54680.c	2018-01-26 11:20:33.982358520 +0000
@@ -1244,12 +1244,18 @@ phy_54680_enable_set(int unit, soc_port_
 
     power_down = (enable) ? 0 : MII_CTRL_PD;
 
     SOC_IF_ERROR_RETURN
         (MODIFY_PHY54680_MII_CTRLr(unit, pc, power_down, MII_CTRL_PD));
 
+#ifdef LVL7_FIXUP
+        if (soc_property_port_get(unit, port, spn_PORT_SUPER_ISOLATE, 0) != 0) {
+            SOC_IF_ERROR_RETURN
+                (MODIFY_PHY54680_MII_POWER_CTRLr(unit, pc, 0, 0x20));
+        }
+#endif
     if (!enable) {
         if ((PHY_FLAGS_TST(unit, port, PHY_FLAGS_EEE_ENABLED)) &&
            (((pc->phy_rev & 0x4) == 0x0) || /* A0,A1,B0,B1 */
             (PHY_IS_BCM53125(pc) && pc->phy_rev == 0x4) ||
             (PHY_IS_BCM53128(pc) && pc->phy_rev == 0x4) ||
             (PHY_IS_BCM53324(pc) && pc->phy_rev == 0x0) ||
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/phy8706.c esw_sdk_modified/src/soc/phy/phy8706.c
--- sdk-all-6.5.5/src/soc/phy/phy8706.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/phy8706.c	2018-01-26 11:20:34.134358520 +0000
@@ -61,12 +61,15 @@
 #include <soc/phy.h>
 #include <soc/phy/phyctrl.h>
 #include <soc/phy/drv.h>
 
 #include "phydefs.h"      /* Must include before other phy related includes */
 
+///LTX for printf
+#include <stdio.h>
+
 #if defined(INCLUDE_PHY_8706)
 #include "phyconfig.h"    /* Must be the first phy include after phydefs.h */
 #include "phyident.h"
 #include "phyreg.h"
 #include "phynull.h"
 #include "phyxehg.h"
@@ -547,12 +550,15 @@ _8727_rom_load_war(int unit, int port, p
 
 #endif
 
 STATIC int
 _8726_rom_load(int unit, int port, phy_ctrl_t *pc)
 {
+	printf("LTX: aborting _8726_rom_load\n");
+    return SOC_E_NONE;
+
     SOC_IF_ERROR_RETURN
         (WRITE_PHY8706_PMA_PMD_REG(unit, pc, 0xca85, 0x0001));
     sal_usleep(1000);
 
     SOC_IF_ERROR_RETURN
         (WRITE_PHY8706_PMA_PMD_REG(unit, pc, 0xca10, 0x0188));
@@ -588,13 +594,14 @@ _8747_rom_load(int unit, int port, phy_c
     for(i = 0; i < 4; i++) { 
         /* Disable SPI for all ports, return value ignored on purpose */
         pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc843), 0x000f);
         pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc840), 0x000C);
 
         /* Set bit SPI Download (15), SER Boot (14) And SPI Port Enable (0) In C848, SPI_PORT_CTRL */
-        pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc848), 0xC0F1);
+//        pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc848), 0xC0F1);
+        pc->write(unit, phy_addr+i,SOC_PHY_CLAUSE45_ADDR(1, 0xc848), 0x80F1);
     }
 
     /* Place Micro in reset */
     SOC_IF_ERROR_RETURN
         (WRITE_PHY8706_PMA_PMD_REG(unit, pc, 0xca10, 0x018f));
 
@@ -882,14 +889,19 @@ phy_8706_init(int unit, soc_port_t port)
     uint16      tmp;
 
     pc = EXT_PHY_SW_STATE(unit, port);
     
     PHY_FLAGS_SET(unit, port,  PHY_FLAGS_FIBER | PHY_FLAGS_C45);
 
-    phy_ext_rom_boot = soc_property_port_get(unit, port, 
-                                            spn_PHY_EXT_ROM_BOOT, 1);
+    ///LTX
+//    phy_ext_rom_boot = soc_property_port_get(unit, port,
+//                                            spn_PHY_EXT_ROM_BOOT, 1);
+    phy_ext_rom_boot=1;
+
+
+
     SOC_IF_ERROR_RETURN
         (READ_PHY8706_PMA_PMD_REG(unit, pc, MII_PHY_ID1_REG, &phyid1));
 
 #ifdef BCM8727_MICROCODE_LOAD_WAR
     if ((phyid1 != PHY_ID1_8727) || (!phy_ext_rom_boot))
 #endif
@@ -1364,12 +1376,22 @@ phy_8706_init(int unit, soc_port_t port)
 
             /* Initialize the next Device */
             PHYDRV_CALL_NOARG(pc,PHY_INIT);
         }
     }
 
+    ///LTX
+
+    printf("LTX: Hacking phy_8706_init to enable tx on address 0xc800\n");
+
+    (PHY8706_REG_WRITE(unit, pc,
+                      SOC_PHY_CLAUSE45_ADDR(PHY8706_C45_DEV_PMA_PMD,
+                                            0xC800),
+                      0xFF00));
+
+
     /* Enable Squelch */
     SOC_IF_ERROR_RETURN(_phy_8706_squelch_enable(unit, port, TRUE));
 
  
     return SOC_E_NONE;
 }
@@ -2375,12 +2397,13 @@ phy_8706_lb_set(int unit, soc_port_t por
     /* Disable(Enable) Squelch when we Enable(Disable) loopback */
     SOC_IF_ERROR_RETURN
         (_phy_8706_squelch_enable(unit, port, enable ? FALSE : TRUE));
 
     if (PHY_IS_BCM5942(pc)) {
         SOC_IF_ERROR_RETURN
+//        (_phy_8706_lb_set(unit, port, enable));
             (_phy_5942_lb_set(unit, port, enable));
     } else {
         SOC_IF_ERROR_RETURN
             (_phy_8706_lb_set(unit, port, enable));
     }
 
@@ -3169,15 +3192,18 @@ _phy_8706_speed_set(int unit, soc_port_t
 
     /* need to set the internal phy's speed accordingly */
 
     if (NULL != int_pc) {
         if (PHY_IS_BCM5942(pc)) {
             SOC_IF_ERROR_RETURN
-                (PHY_INTERFACE_SET(int_pc->pd, unit, port, SOC_PORT_IF_SFI));
+//            (PHY_INTERFACE_SET(int_pc->pd, unit, port, SOC_PORT_IF_XFI));
+                (PHY_INTERFACE_SET(int_pc->pd, unit, port, SOC_PORT_IF_XFI));
+            printf("LTX: internal phy on port %d set to SOC_PORT_IF_XFI\n", port);
             SOC_IF_ERROR_RETURN
                 (PHY_AUTO_NEGOTIATE_SET (int_pc->pd, unit, port, 0));
+            printf("LTX: internal phy on port %d set to AUTONEG OFF\n", port);
         }
         rv = PHY_SPEED_SET(int_pc->pd, unit, port, speed);
     }
 
 #if 0
     if (NXT_PC(pc)) {
@@ -3193,12 +3219,14 @@ _phy_8706_speed_set(int unit, soc_port_t
 
 STATIC int
 phy_8706_speed_set(int unit, soc_port_t port, int speed)
 {
     phy_ctrl_t  *pc;
 
+    printf("LTX: Called phy_8706_speed_set for port %d\n", port);
+
     pc = EXT_PHY_SW_STATE(unit, port);
 
     SOC_IF_ERROR_RETURN
         (_phy_8706_speed_set (unit, port, speed));
     if (NXT_PC(pc)) {
         PHYDRV_CALL_ARG1(pc,PHY_SPEED_SET,speed);
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/phyident.c esw_sdk_modified/src/soc/phy/phyident.c
--- sdk-all-6.5.5/src/soc/phy/phyident.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/phyident.c	2018-01-26 11:20:34.454358520 +0000
@@ -178,14 +178,19 @@ static int _chk_serdes_65lp(int unit, so
 static int _chk_unicore(int unit, soc_port_t port,
                         soc_phy_table_t *my_entry,
                         uint16 phy_id0, uint16 phy_id1, soc_phy_info_t *pi);
 #endif /* INCLUDE_PHY_XGXS6 */
 
 #if defined(INCLUDE_PHY_8706)
+#ifdef LVL7_FIXUP
+ int _chk_8706(int unit, soc_port_t port, soc_phy_table_t *my_entry,
+			   uint16 phy_id0, uint16 phy_id1, soc_phy_info_t *pi);
+#else
 static int _chk_8706(int unit, soc_port_t port, soc_phy_table_t *my_entry,
                      uint16 phy_id0, uint16 phy_id1, soc_phy_info_t *pi);
+#endif
 #endif /* INCLUDE_PHY_8706 */
 
 #if defined(INCLUDE_PHY_8072)
 static int _chk_8072(int unit, soc_port_t port, soc_phy_table_t *my_entry,
                      uint16 phy_id0, uint16 phy_id1, soc_phy_info_t *pi);
 #endif /* INCLUDE_PHY_8072 */
@@ -5668,13 +5673,17 @@ _chk_sfp_phy(int unit, soc_port_t port,
         }
     }
     return FALSE;
 }
 
 #if defined(INCLUDE_PHY_8706)
-static int
+#ifndef LVL7_FIXUP
+static 
+#endif
+int
+//static int
 _chk_8706(int unit, soc_port_t port, soc_phy_table_t *my_entry,
              uint16 phy_id0, uint16 phy_id1, soc_phy_info_t *pi)
 {
     if (my_entry->myNum == _phy_ident_type_get(phy_id0, phy_id1) ||
         soc_property_port_get(unit, port, spn_PHY_8706, FALSE)) {
         pi->phy_name = my_entry->phy_name;
@@ -6710,12 +6719,37 @@ _ext_phy_probe(int unit, soc_port_t port
                     soc_cm_get_id(unit, &dev_id, &rev_id);
                     ext_pc->phy_rev = rev_id;
                 }
 #endif /* BCM_NORTHSTAR_SUPPORT */
 
                 PHY_FLAGS_SET(unit, port, PHY_FLAGS_EXTERNAL_PHY);
+#ifdef LVL7_FIXUP
+#if L7_FEAT_SF10GBT
+                /* SDK only provides a way to configure a single phy address for 
+                 * each port, whereas some of the customer boxes have different
+                 * phy addresses for same port. So we use the custom driver 
+                 * (registered in FP application) checkphy fuction to look for
+                 * device ids at the secondary phy addresses, and return SUCESS
+                 * if match is successful). _ext_phy_probe() uses two pointer 
+                 * variables - pi and ext_pc. We manage to run our own custom 
+                 * _check_phy function, which does the OUI check for us. But 
+                 * our requirement is to change the phy addresses and other 
+                 * parameters maintained in structures pointed to by pi 
+                 * (soc_phy_info_t) and ext_pc(phy_ctrl_t), in  case the match 
+                 * is successful.  We don't have a way to do that unless we run 
+                 * our custom function below, or SDK functions are re-designed 
+                 * to facilitate this operation.
+                 */
+                soc_phy_cust_t* fixPhySet = NULL;
+                if (phy_table[i]->cookie != NULL)
+                {
+                  fixPhySet = (soc_phy_cust_t*)(phy_table[i]->cookie);
+                  (fixPhySet->custPhySettings)(unit, port, phy_table[i], pi, ext_pc);
+                }
+#endif
+#endif
 
                 break;
             }
         }
     }
 
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/phyreg.c esw_sdk_modified/src/soc/phy/phyreg.c
--- sdk-all-6.5.5/src/soc/phy/phyreg.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/phyreg.c	2018-01-26 11:20:33.974358520 +0000
@@ -58,12 +58,21 @@
 #include <soc/phy/phyctrl.h>
 
 #include "phydefs.h"      /* Must include before other phy related includes */
 
 #include "phyreg.h"
 
+#ifdef LVL7_FIXUP
+#include "sysapi_hpc.h"
+#include "hpc_phy.h"
+
+#undef SOC_IF_ERROR_RETURN
+#define SOC_IF_ERROR_RETURN(op) \
+    do { int __rv__; if ((__rv__ = (op)) < 0) {HPC_PHY_SHADOW_REG_UNLOCK(unit); return(__rv__);} } while(0)
+#endif
+
 #define _SOC_PHY_REG_DIRECT \
         ((SOC_PHY_REG_1000X << 1) | (SOC_PHY_REG_1000X >> 1))
 
 
 #define PHY_MODEL_CHECK(_pc, _oui, _model) \
                                 (((_pc)->phy_oui == (_oui)) && \
@@ -107,32 +116,44 @@ phy_reg_modify(int unit, phy_ctrl_t *pc,
     uint16  tmp, otmp;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     reg_data = reg_data & reg_mask;
 
     SOC_IF_ERROR_RETURN
         (READ_PHY_REG(unit, pc, reg_addr, &tmp));
     otmp = tmp;
     tmp &= ~(reg_mask);
     tmp |= reg_data;
 
     if (otmp != tmp) {
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, reg_addr, tmp));
     }
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return SOC_E_NONE;
 }
 int 
 phy_reg_fe_read(int unit, phy_ctrl_t *pc, uint16 reg_bank,
                 uint8 reg_addr, uint16 *data)
 {
     uint16 test_reg;
   
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     if (reg_bank) {
         SOC_IF_ERROR_RETURN
             (READ_PHY_REG(unit, pc, 0x1f, &test_reg));
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 0x1f, test_reg | 0x0080));
     
@@ -141,12 +162,16 @@ phy_reg_fe_read(int unit, phy_ctrl_t *pc
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 0x1f, test_reg));
     } else {
         SOC_IF_ERROR_RETURN
             (READ_PHY_REG(unit, pc, reg_addr, data));
     }
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return SOC_E_NONE;
 }
 
 int 
 phy_reg_fe_write(int unit, phy_ctrl_t *pc, uint16 reg_bank, 
                  uint8 reg_addr, uint16 data)
@@ -154,12 +179,16 @@ phy_reg_fe_write(int unit, phy_ctrl_t *p
     uint16 test_reg;
  
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
  
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     if (reg_bank) {
         SOC_IF_ERROR_RETURN
             (READ_PHY_REG(unit, pc, 0x1f, &test_reg));
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 0x1f, test_reg | 0x0080));
     
@@ -168,12 +197,16 @@ phy_reg_fe_write(int unit, phy_ctrl_t *p
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 0x1f, test_reg));
     } else {
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, reg_addr, data));
     }
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return SOC_E_NONE;
 }
 
 int 
 phy_reg_fe_modify(int unit, phy_ctrl_t *pc, uint16 reg_bank, 
                   uint8 reg_addr, uint16 data, uint16 mask)
@@ -181,12 +214,16 @@ phy_reg_fe_modify(int unit, phy_ctrl_t *
     uint16 test_reg;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
   
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     if (reg_bank) {
         SOC_IF_ERROR_RETURN
             (READ_PHY_REG(unit, pc, 0x1f, &test_reg));
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 0x1f, test_reg | 0x0080));
     
@@ -196,23 +233,31 @@ phy_reg_fe_modify(int unit, phy_ctrl_t *
             (WRITE_PHY_REG(unit, pc, 0x1f, test_reg));
     } else {
         SOC_IF_ERROR_RETURN
             (MODIFY_PHY_REG(unit, pc, reg_addr, data, mask));
     }
  
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return SOC_E_NONE;
 }
 
 int
 phy_reg_ge_read(int unit, phy_ctrl_t *pc, uint32 flags, uint16 reg_bank,
                 uint8 reg_addr, uint16 *data)
 {
     int     rv;
 
     rv       = SOC_E_NONE;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     if (flags & SOC_PHY_REG_1000X) {
         if (reg_addr <= 0x000f) {
             uint16 blk_sel;
 
             /* Map 1000X page */
             SOC_IF_ERROR_RETURN
@@ -276,12 +321,16 @@ phy_reg_ge_read(int unit, phy_ctrl_t *pc
             break;
         }
         if (SOC_SUCCESS(rv)) {
             rv = READ_PHY_REG(unit, pc, reg_addr, data);
         }
     } 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     if (SOC_FAILURE(rv)) {
         LOG_ERROR(BSL_LS_SOC_PHY,
                   (BSL_META_U(unit,
                               "phy_reg_ge_read failed:"
                               " u=%d phy_id=0x%2x reg_bank=0x%04x reg_addr=0x%02x "
                               " rv=%d\n"), unit, pc->phy_id, reg_bank, reg_addr, rv)); 
@@ -298,12 +347,16 @@ phy_reg_ge_write(int unit, phy_ctrl_t *p
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
     rv       = SOC_E_NONE;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     if (flags & SOC_PHY_REG_1000X) {
         if (reg_addr <= 0x000f) {
             uint16 blk_sel;
 
             /* Map 1000X page */
             SOC_IF_ERROR_RETURN
@@ -375,12 +428,16 @@ phy_reg_ge_write(int unit, phy_ctrl_t *p
                             SOC_PHY_SHAD_RETRY_CNT);
                 }
             }
         }
     } 
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     if (SOC_FAILURE(rv)) {
         LOG_ERROR(BSL_LS_SOC_PHY,
                   (BSL_META_U(unit,
                               "phy_reg_ge_write failed:"
                               " u=%d phy_id=0x%2x reg_bank=0x%04x reg_addr=0x%02x "
                               " rv=%d\n"), unit, pc->phy_id, reg_bank, reg_addr, rv)); 
@@ -398,12 +455,16 @@ phy_reg_ge_modify(int unit, phy_ctrl_t *
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
     rv       = SOC_E_NONE;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     if (flags & SOC_PHY_REG_1000X) {
         if (reg_addr <= 0x000f) {
             uint16 blk_sel;
 
             /* Map 1000X page */
             SOC_IF_ERROR_RETURN
@@ -481,12 +542,16 @@ phy_reg_ge_modify(int unit, phy_ctrl_t *
                 }
             }
 
         }
     } 
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     if (SOC_FAILURE(rv)) {
         LOG_ERROR(BSL_LS_SOC_PHY,
                   (BSL_META_U(unit,
                               "phy_reg_ge_modify failed:"
                               " u=%d phy_id=0x%2x reg_bank=0x%04x reg_addr=0x%02x "
                               " rv=%d\n"), unit, pc->phy_id, reg_bank, reg_addr, rv)); 
@@ -581,12 +646,16 @@ phy_reg_xge_write(int unit, phy_ctrl_t *
     rv       = SOC_E_NONE;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)) {
         return rv;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     {
         switch(reg_addr) {
         /* Map shadow registers */
         case 0xfff5:
             SOC_IF_ERROR_RETURN
                     (WRITE_PHY_REG(unit, pc, SOC_PHY_CLAUSE45_ADDR(dev_addr, 0xfff7), reg_bank));
@@ -626,12 +695,16 @@ phy_reg_xge_write(int unit, phy_ctrl_t *
         }
         if (SOC_SUCCESS(rv)) {
             rv = WRITE_PHY_REG(unit, pc, SOC_PHY_CLAUSE45_ADDR(dev_addr, reg_addr), data);
         }
     } 
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     if (SOC_FAILURE(rv)) {
         LOG_ERROR(BSL_LS_SOC_PHY,
                   (BSL_META_U(unit,
                               "phy_reg_ge_write failed:"
                               " u=%d phy_id=0x%2x dev_addr=0x%02x reg_bank=0x%04x reg_addr=0x%02x "
                               " rv=%d\n"), unit, pc->phy_id, dev_addr, reg_bank, reg_addr, rv)); 
@@ -645,12 +718,16 @@ phy_reg_xge_modify(int unit, phy_ctrl_t
                 uint8 dev_addr, uint16 reg_addr, uint16 data, uint16 mask)
 {
     int     rv;
 
     rv       = SOC_E_NONE;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     {
         switch(reg_addr) {
         /* Map shadow registers */
         case 0xfff5:
             SOC_IF_ERROR_RETURN
                 (WRITE_PHY_REG(unit, pc, SOC_PHY_CLAUSE45_ADDR(dev_addr, 0xfff7), reg_bank));
@@ -699,12 +776,16 @@ phy_reg_xge_modify(int unit, phy_ctrl_t
         }
         if (SOC_SUCCESS(rv)) {
             rv = MODIFY_PHY_REG(unit, pc, SOC_PHY_CLAUSE45_ADDR(dev_addr, reg_addr), data, mask);
         }
     } 
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     if (SOC_FAILURE(rv)) {
         LOG_ERROR(BSL_LS_SOC_PHY,
                   (BSL_META_U(unit,
                               "phy_reg_ge_modify failed:"
                               " u=%d phy_id=0x%2x dev_addr=0x%02x reg_bank=0x%04x reg_addr=0x%02x "
                               " rv=%d\n"), unit, pc->phy_id, dev_addr, reg_bank, reg_addr, rv)); 
@@ -717,12 +798,16 @@ phy_reg_serdes_read(int unit, phy_ctrl_t
                     uint8 reg_addr, uint16 *phy_rd_data) 
 { 
     int    rv; 
  
     rv     = SOC_E_NONE; 
  
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
 #ifdef INCLUDE_PHY_XGXS6
     if (soc_feature(unit, soc_feature_xgxs_v6)) { 
         if ((reg_bank != 0) || (reg_addr >= 0x0010)) { 
             reg_bank = 0x300 + (reg_bank << 4); 
         } 
     } 
@@ -731,12 +816,16 @@ phy_reg_serdes_read(int unit, phy_ctrl_t
     rv = WRITE_PHY_REG(unit, pc, 0x1f, reg_bank); 
  
     if (SOC_SUCCESS(rv)) { 
         rv = READ_PHY_REG(unit, pc, reg_addr, phy_rd_data);  
     } 
  
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv; 
 }
 
 int
 phy_reg_serdes_write(int unit, phy_ctrl_t *pc, uint16 reg_bank, 
                      uint8 reg_addr, uint16 phy_wr_data)
@@ -746,12 +835,16 @@ phy_reg_serdes_write(int unit, phy_ctrl_
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
     rv     = SOC_E_NONE;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
 #ifdef INCLUDE_PHY_XGXS6
     if (soc_feature(unit, soc_feature_xgxs_v6)) {
         if ((reg_bank != 0) || (reg_addr >= 0x0010)) {
             reg_bank = 0x300 + (reg_bank << 4);
         }
     }
@@ -760,12 +853,16 @@ phy_reg_serdes_write(int unit, phy_ctrl_
     rv = WRITE_PHY_REG(unit, pc, 0x1f, reg_bank);
 
     if (SOC_SUCCESS(rv)) {
         rv = WRITE_PHY_REG(unit, pc, reg_addr, phy_wr_data);
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 
 int
 phy_reg_serdes_modify(int unit, phy_ctrl_t *pc,
                       uint16 reg_bank, uint8 reg_addr,
@@ -776,12 +873,16 @@ phy_reg_serdes_modify(int unit, phy_ctrl
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
     rv     = SOC_E_NONE;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
 #ifdef INCLUDE_PHY_XGXS6
     if (soc_feature(unit, soc_feature_xgxs_v6)) {
         if ((reg_bank != 0) || (reg_addr >= 0x0010)) {
             reg_bank = 0x300 + (reg_bank << 4);
         }
     }
@@ -790,28 +891,40 @@ phy_reg_serdes_modify(int unit, phy_ctrl
     rv = WRITE_PHY_REG(unit, pc, 0x1f, reg_bank);
 
     if (SOC_SUCCESS(rv)) {
         rv = MODIFY_PHY_REG(unit, pc, reg_addr, phy_mo_data, phy_mo_mask);
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 
 #if defined(INCLUDE_PHY_XGXS)
 int 
 phy_reg_xgxs_read(int unit, phy_ctrl_t *pc, uint16 reg_bank,
                            uint8 reg_addr, uint16 *data)
 {
     int    rv;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     rv = WRITE_PHY_REG(unit, pc, 0x1f, reg_bank);
 
     if (SOC_SUCCESS(rv)) {
         rv = READ_PHY_REG(unit, pc, reg_addr, data);
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 
 int 
 phy_reg_xgxs_write(int unit, phy_ctrl_t *pc, uint16 reg_bank,
                             uint8 reg_addr, uint16 data)
@@ -819,18 +932,26 @@ phy_reg_xgxs_write(int unit, phy_ctrl_t
     int    rv;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     rv = WRITE_PHY_REG(unit, pc, 0x1f, reg_bank);
 
     if (SOC_SUCCESS(rv)) {
         rv = WRITE_PHY_REG(unit, pc, reg_addr, data);
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 
 int 
 phy_reg_xgxs_modify(int unit, phy_ctrl_t *pc, uint16 reg_bank,
                              uint8 reg_addr, uint16 data, uint16 mask)
@@ -838,18 +959,26 @@ phy_reg_xgxs_modify(int unit, phy_ctrl_t
     int    rv;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     rv = WRITE_PHY_REG(unit, pc, 0x1f, reg_bank);
 
     if (SOC_SUCCESS(rv)) {
         rv = MODIFY_PHY_REG(unit, pc, reg_addr, data, mask);
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 #endif /* INCLUDE_PHY_XGXS */
 
 #if defined(INCLUDE_PHY_XGXS6)
 int 
@@ -857,12 +986,16 @@ phy_reg_xgxs6_read(int unit, phy_ctrl_t
                            uint8 reg_addr, uint16 *data)
 {
     int    rv;
 
     rv     = SOC_E_NONE;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     if (reg_addr < 0x10) {
         /* Select between SerDes and XAUI mapping */
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 0x1f, 0x0000));
         SOC_IF_ERROR_RETURN
             (MODIFY_PHY_REG(unit, pc, 0x1e, 
@@ -875,12 +1008,16 @@ phy_reg_xgxs6_read(int unit, phy_ctrl_t
     }
 
     if (SOC_SUCCESS(rv)) {
         rv = READ_PHY_REG(unit, pc, reg_addr, data);
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 
 int 
 phy_reg_xgxs6_write(int unit, phy_ctrl_t *pc, uint32 flags, uint16 reg_bank,
                             uint8 reg_addr, uint16 data)
@@ -888,12 +1025,16 @@ phy_reg_xgxs6_write(int unit, phy_ctrl_t
     int    rv;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     rv     = SOC_E_NONE;
 
     if (reg_addr < 0x10) {
         /* Select between SerDes and XAUI mapping */
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 0x1f, 0x0000));
@@ -908,12 +1049,16 @@ phy_reg_xgxs6_write(int unit, phy_ctrl_t
     }
 
     if (SOC_SUCCESS(rv)) {
         rv = WRITE_PHY_REG(unit, pc, reg_addr, data);
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 
 int 
 phy_reg_xgxs6_modify(int unit, phy_ctrl_t *pc, uint32 flags, uint16 reg_bank,
                              uint8 reg_addr, uint16 data, uint16 mask)
@@ -921,12 +1066,16 @@ phy_reg_xgxs6_modify(int unit, phy_ctrl_
     int    rv;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     rv     = SOC_E_NONE;
 
     if (reg_addr < 0x10) {
         /* Select between SerDes and XAUI mapping */
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 0x1f, 0x0000));
@@ -941,23 +1090,31 @@ phy_reg_xgxs6_modify(int unit, phy_ctrl_
     }
 
     if (SOC_SUCCESS(rv)) {
         rv = MODIFY_PHY_REG(unit, pc, reg_addr, data, mask);
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 #endif /* INCLUDE_PHY_XGXS6 */
 
 STATIC int 
 _phy_reg_aer_cl45_read(int unit, phy_ctrl_t *pc, uint32 reg_addr,
                  uint16 *data)
 {
     uint16 phy_reg_addr;
     int    cl45_devid;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     phy_reg_addr = PHY_AER_REG_ADDR_CL45_REGAD(reg_addr);
     cl45_devid   = PHY_AER_REG_ADDR_CL45_DEVID(reg_addr);
 
     if (PHY_AER_REG_ADDR_LANE_NUM(reg_addr)) {
         /* write the lane number to the AER if lane specific */
         SOC_IF_ERROR_RETURN
@@ -973,12 +1130,17 @@ _phy_reg_aer_cl45_read(int unit, phy_ctr
         /* restore back the lane number to 0 */
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 
                 SOC_PHY_CLAUSE45_ADDR(cl45_devid,PHY_AER_REG),
                 0));
     }
+
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return SOC_E_NONE;
 }
 
 STATIC int 
 _phy_reg_aer_cl45_write(int unit, phy_ctrl_t *pc, uint32 reg_addr,
                   uint16 data)
@@ -987,12 +1149,16 @@ _phy_reg_aer_cl45_write(int unit, phy_ct
     int    cl45_devid;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     phy_reg_addr = PHY_AER_REG_ADDR_CL45_REGAD(reg_addr);
     cl45_devid = PHY_AER_REG_ADDR_CL45_DEVID(reg_addr);
 
     if (PHY_AER_REG_ADDR_LANE_NUM(reg_addr)) {
         /* write the lane number to the AER if lane specific */
         SOC_IF_ERROR_RETURN
@@ -1008,12 +1174,17 @@ _phy_reg_aer_cl45_write(int unit, phy_ct
         /* write the lane number 0 to the AER */
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 
                 SOC_PHY_CLAUSE45_ADDR(cl45_devid,PHY_AER_REG),
                 0));
     }
+
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return SOC_E_NONE;
 }
 
 STATIC int 
 _phy_reg_aer_cl45_modify(int unit, phy_ctrl_t *pc, uint32 reg_addr,
                   uint16 data,uint16 mask)
@@ -1022,12 +1193,16 @@ _phy_reg_aer_cl45_modify(int unit, phy_c
     int    cl45_devid;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     phy_reg_addr = PHY_AER_REG_ADDR_CL45_REGAD(reg_addr);
     cl45_devid = PHY_AER_REG_ADDR_CL45_DEVID(reg_addr);
 
     if (PHY_AER_REG_ADDR_LANE_NUM(reg_addr)) {
         /* write the lane number to the AER if lane specific */
         SOC_IF_ERROR_RETURN
@@ -1043,12 +1218,17 @@ _phy_reg_aer_cl45_modify(int unit, phy_c
         /* write the lane number 0 to the AER */
         SOC_IF_ERROR_RETURN
             (WRITE_PHY_REG(unit, pc, 
                 SOC_PHY_CLAUSE45_ADDR(cl45_devid,PHY_AER_REG),
                 0));
     }
+
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return SOC_E_NONE;
 }
 
 STATIC int 
 _phy_reg_aer_cl22_read(int unit, phy_ctrl_t *pc, uint32 reg_addr,
                  uint16 *data)
@@ -1057,12 +1237,16 @@ _phy_reg_aer_cl22_read(int unit, phy_ctr
     uint16 phy_reg_blk;
     uint16 phy_reg_addr;
     int    rv;
 
     rv     = SOC_E_UNAVAIL;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     phy_reg_aer  = PHY_AER_REG_ADDR_AER(reg_addr);
     phy_reg_blk  = PHY_AER_REG_ADDR_BLK(reg_addr);
     phy_reg_addr = PHY_AER_REG_ADDR_REGAD(reg_addr);
     if (phy_reg_aer == 0) {
         rv = WRITE_PHY_REG(unit, pc, 0x1f, phy_reg_blk);
 
@@ -1094,12 +1278,16 @@ _phy_reg_aer_cl22_read(int unit, phy_ctr
             rv = WRITE_PHY_REG(unit, pc, 0x1e, 0);
         }
         if (SOC_SUCCESS(rv)) {
             rv = WRITE_PHY_REG(unit, pc, 0x1f, 0x0);
         }
     }
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 
 STATIC int 
 _phy_reg_aer_cl22_write(int unit, phy_ctrl_t *pc, uint32 reg_addr,
                   uint16 data)
@@ -1110,12 +1298,16 @@ _phy_reg_aer_cl22_write(int unit, phy_ct
     int    rv;
 
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     rv     = SOC_E_UNAVAIL;
 
     phy_reg_aer  = PHY_AER_REG_ADDR_AER(reg_addr);
     phy_reg_blk  = PHY_AER_REG_ADDR_BLK(reg_addr);
     phy_reg_addr = PHY_AER_REG_ADDR_REGAD(reg_addr);
     if (phy_reg_aer == 0) {
@@ -1146,12 +1338,16 @@ _phy_reg_aer_cl22_write(int unit, phy_ct
             rv = WRITE_PHY_REG(unit, pc, 0x1f, 0xffd0);
         }
         if (SOC_SUCCESS(rv)) {
             rv = WRITE_PHY_REG(unit, pc, 0x1e, 0);
         }
     }
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 }
 
 STATIC int 
 _phy_reg_aer_cl22_modify(int unit, phy_ctrl_t *pc, uint32 reg_addr,
                    uint16 data, uint16 mask)
@@ -1164,12 +1360,16 @@ _phy_reg_aer_cl22_modify(int unit, phy_c
     if (SOC_WARM_BOOT(unit) || SOC_IS_RELOADING(unit)){
         return SOC_E_NONE;
     }
 
     rv     = SOC_E_UNAVAIL;
 
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_LOCK(unit);
+#endif
+
     phy_reg_aer  = PHY_AER_REG_ADDR_AER(reg_addr);
     phy_reg_blk  = PHY_AER_REG_ADDR_BLK(reg_addr);
     phy_reg_addr = PHY_AER_REG_ADDR_REGAD(reg_addr);
     if (phy_reg_aer == 0) {
         /* Only support AER = 0 for now */
         rv = WRITE_PHY_REG(unit, pc, 0x1f, phy_reg_blk);
@@ -1199,12 +1399,16 @@ _phy_reg_aer_cl22_modify(int unit, phy_c
         }
         if (SOC_SUCCESS(rv)) {
             rv = WRITE_PHY_REG(unit, pc, 0x1e, 0);
         }
 
     }
+#ifdef LVL7_FIXUP
+    HPC_PHY_SHADOW_REG_UNLOCK(unit);
+#endif
+
     return rv;
 
 }
 
 int
 phy_reg_aer_read(int unit, phy_ctrl_t *pc, uint32 reg_addr,
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/serdescombo65.c esw_sdk_modified/src/soc/phy/serdescombo65.c
--- sdk-all-6.5.5/src/soc/phy/serdescombo65.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/serdescombo65.c	2018-01-26 11:20:34.358358520 +0000
@@ -1242,13 +1242,17 @@ phy_combo65_medium_config_get(int unit,
 
     switch (medium) {
     case SOC_PORT_MEDIUM_FIBER:
         sal_memcpy(cfg, &pc->fiber, sizeof (*cfg));
         return SOC_E_NONE;
     default:
+#ifdef LVL7_FIXUP
+        return SOC_E_UNAVAIL;
+#else
         return SOC_E_PARAM;
+#endif
     }
 }
 
 /*
  * Function:
  *      phy_combo65_medium_status
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/wc40.c esw_sdk_modified/src/soc/phy/wc40.c
--- sdk-all-6.5.5/src/soc/phy/wc40.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/wc40.c	2018-01-26 11:20:34.442358520 +0000
@@ -63,12 +63,16 @@
 #include "phydefs.h"      /* Must include before other phy related includes */
 
 #ifdef BCM_WARM_BOOT_SUPPORT
 #include <soc/scache.h>
 #endif
 
+#include <logger.h>       /* PTin added: WC40 */
+
+#define PTIN_PRBS_ALWAYS_CL49 1
+
 #if defined(INCLUDE_XGXS_WC40)
 #include "phyconfig.h"     /* Must include before other phy related includes */
 #include "phyreg.h"
 #include "phyfege.h"
 #include "phynull.h"
 #include "serdesid.h"
@@ -5494,16 +5498,17 @@ _phy_wc40_interlaken_speed_get(int unit,
             *speed = 3125;
             break;
         default:
             *speed = 0;
             break;
     }
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(unit,
-                         "_phy_wc40_interlaken_speed_get: u=%d p=%d LANECTRL1r %04x speed= %d\n"),
-              unit, port,data16, *speed));
+    /* PTin modified: logs */
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+                  (BSL_META_U(unit,
+                              "_phy_wc40_interlaken_speed_get: u=%d p=%d LANECTRL1r %04x speed= %d\n"),
+                   unit, port,data16, *speed));
     return SOC_E_NONE;
 }
 
 /*
  * Function:
  *      phy_wc40_speed_get
@@ -6720,13 +6725,13 @@ _phy_wc40_c73_adv_local_get(int unit, so
         default:
             pause = 0;
             break;
     }
     ability->pause = pause;
 
-    LOG_INFO(BSL_LS_SOC_PHY,
+    LOG_VERBOSE(BSL_LS_SOC_PHY,
              (BSL_META_U(unit,
                          "_phy_wc40_c73_adv_local_get: u=%d p=%d pause=%08x speeds=%04x\n"),
               unit, port, pause, speeds));
     return SOC_E_NONE;
 }
 
@@ -7065,13 +7070,13 @@ phy_wc40_ability_advert_get(int unit, so
     /* check for clause73 */
     if (DEV_CFG_PTR(pc)->cl73an) {
         SOC_IF_ERROR_RETURN
             (_phy_wc40_c73_adv_local_get(unit, port, ability));
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
+    LOG_VERBOSE(BSL_LS_SOC_PHY,
              (BSL_META_U(unit,
                          "phy_wc40_ability_advert_get:unit=%d p=%d pause=%08x sp=%08x\n"),
               unit, port, ability->pause, ability->speed_full_duplex));
 
     return SOC_E_NONE;
 }
@@ -7691,16 +7696,17 @@ phy_wc40_ability_local_get(int unit, soc
         ability->interface = SOC_PA_INTF_XGMII;
         phy_wc40_medium_get(unit, port, &ability->medium);
         ability->loopback  = SOC_PA_LB_PHY;
         ability->flags     = SOC_PA_AUTONEG;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(unit,
-                         "phy_wc40_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, port, ability->speed_full_duplex));
+    /* PTin modified: logs */
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+                  (BSL_META_U(unit,
+                              "phy_wc40_ability_local_get:unit=%d p=%d sp=%08x\n"),
+                   unit, port, ability->speed_full_duplex));
 
     return (SOC_E_NONE);
 }
 
 
 #define PHY_WC40_LANEPRBS_LANE_SHIFT   4
@@ -7848,23 +7854,27 @@ _phy_wc40_control_prbs_tx_invert_data_ge
 STATIC int
 _phy_wc40_control_prbs_enable_set(int unit, soc_port_t port, 
                                           uint32 enable)
 {
     uint16      data16;
     uint16      mask16;
+    #if (!PTIN_PRBS_ALWAYS_CL49)
     int an;
     int an_done;
+    #endif
     soc_port_if_t intf;
     int prbs_lanes = 0;
     int lane;
     phy_ctrl_t *pc = INT_PHY_SW_STATE(unit, port);
 
     /* If mode is autoneg KR/KR4, do it thru CL49 PRBS and configure KR forced mode and disable autoneg
      * This way the FIR settings negotiated thru CL72 is preserved
      */
 
+    /* PTin modified: PRBS */
+    #if (!PTIN_PRBS_ALWAYS_CL49)
     if (DEV_CTRL_PTR(pc)->prbs.type != WC40_PRBS_TYPE_CL49) {
         SOC_IF_ERROR_RETURN
             (phy_wc40_an_get(unit,port,&an,&an_done));
 
         if (an && an_done) {
             /* check interface */
@@ -7872,12 +7882,18 @@ _phy_wc40_control_prbs_enable_set(int un
                 (phy_wc40_interface_get(unit,port,&intf));
             if ((intf == SOC_PORT_IF_KR) || (intf == SOC_PORT_IF_KR4) ) {
                 DEV_CTRL_PTR(pc)->prbs.type = WC40_PRBS_TYPE_CL49;
             }
         }
     }
+    #else
+    /* check interface */
+    SOC_IF_ERROR_RETURN
+        (phy_wc40_interface_get(unit,port,&intf));
+    DEV_CTRL_PTR(pc)->prbs.type = WC40_PRBS_TYPE_CL49;
+    #endif
 
     if (DEV_CTRL_PTR(pc)->prbs.type == WC40_PRBS_TYPE_CL49) {
         SOC_IF_ERROR_RETURN
             (phy_wc40_interface_get(unit,port,&intf));
 
         if (!enable) {  /* disable */
@@ -7890,12 +7906,17 @@ _phy_wc40_control_prbs_enable_set(int un
                 SOC_IF_ERROR_RETURN
                     (WRITE_WC40_PCS_IEEE2BLK_PCS_TPCONTROLr(unit, pc, 0x00, 0));
             }
             DEV_CTRL_PTR(pc)->prbs.type = 0;
         } 
 
+        /* PTin added: PRBS */
+        #if (PTIN_PRBS_ALWAYS_CL49)
+        if (intf==SOC_PORT_IF_KR4 || intf==SOC_PORT_IF_KR)
+        {
+        #endif
         if (intf == SOC_PORT_IF_KR4) {
             SOC_IF_ERROR_RETURN
                 (MODIFY_WC40_SERDESDIGITAL_MISC1r(unit, pc, 0x00, 
                       enable? 0x11: 0, 
                       SERDESDIGITAL_MISC1_FORCE_SPEED_MASK));
 
@@ -7943,12 +7964,23 @@ _phy_wc40_control_prbs_enable_set(int un
                                   enable? 0: MII_CTRL_AE | MII_CTRL_RAN,
                                       MII_CTRL_AE | MII_CTRL_RAN));
 
         SOC_IF_ERROR_RETURN
             (READ_WC40_AN_IEEE0BLK_AN_IEEECONTROL1r(unit, pc, 0x00, 
                                           &data16));
+
+        /* PTin added: PRBS */
+        #if (PTIN_PRBS_ALWAYS_CL49)
+        }
+        else if (enable)
+        {
+          SOC_IF_ERROR_RETURN
+              (WRITE_WC40_PCS_IEEE2BLK_PCS_TPCONTROLr(unit, pc, 0x00, WC40_PRBS_CL49_POLY31));
+        }
+        #endif
+
         /* not to enable PRBS here. Once PRBS is enabled, the link will go down.
          * Autoneg will be restarted by link partner and Tx settings will be lost.
          * It will be enabled in get function when first time called 
          */ 
         return SOC_E_NONE;
     }
@@ -10373,12 +10405,14 @@ phy_wc40_firmware_load(int unit, int por
         (READ_WC40_UC_INFO_B1_VERSIONr(unit, pc, 0x00, &ver));
 
     LOG_VERBOSE(BSL_LS_SOC_PHY,
                 (BSL_META_U(unit,
                             "WC40 : uC RAM download success: u=%d p=%d ver=%x"), unit, port,ver));
 
+    PT_LOG_NOTICE(LOG_CTX_SDK,"WC40 : uC RAM download success: u=%d p=%d ver=%x\r\n", unit, port,ver);   /* PTin added: WC40 */
+
     if (!no_cksum) {
         LOG_VERBOSE(BSL_LS_SOC_PHY,
                     (BSL_META_U(unit,
                                 " cksum=0x%x\n"), cksum));
     } else {
         LOG_VERBOSE(BSL_LS_SOC_PHY,
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/wc40_config.c esw_sdk_modified/src/soc/phy/wc40_config.c
--- sdk-all-6.5.5/src/soc/phy/wc40_config.c	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/wc40_config.c	2018-01-26 11:20:34.118358520 +0000
@@ -328,23 +328,23 @@ phy_wc40_config_init(phy_ctrl_t *pc)
     } else {
         pCfg->fiber_pref = FALSE;
     }
     pCfg->fw_dfe = SOC_PHY_DFE_AUTO;
 
     if (PHY_INDEPENDENT_LANE_MODE(unit, port)) {
-        pCfg->cl73an     = WC40_CL73_AND_CL73BAM; /*WC40_CL73_WO_CL73BAM; */
+        pCfg->cl73an     = WC40_CL73_AUTONEG_MODE; /*WC40_CL73_AND_CL73BAM;*/     /* PTin modified: WC40 */
     } else {
        if (IS_HG_PORT(unit, port)) {
            pCfg->cl73an     = FALSE;
        } else {
-           pCfg->cl73an     = WC40_CL73_AND_CL73BAM;
+           pCfg->cl73an     = WC40_CL73_AUTONEG_MODE; /*WC40_CL73_AND_CL73BAM;*/  /* PTin modified: WC40 */
        }
     }
    
     /* Default setting for CL37 */ 
-    pCfg->cl37an     = WC40_CL37_AND_CL37BAM; 
+    pCfg->cl37an     = WC40_CL73_AUTONEG_MODE; /*WC40_CL73_AND_CL73BAM;*/         /* PTin modified: WC40 */
 
     if ((PHY_FIBER_MODE(unit, port) && !PHY_EXTERNAL_MODE(unit, port)) ||
         PHY_PASSTHRU_MODE(unit, port) ||
         PHY_SGMII_AUTONEG_MODE(unit, port)) {
         pCfg->pdetect1000x = TRUE;
     } else {
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/wc40_extra.h esw_sdk_modified/src/soc/phy/wc40_extra.h
--- sdk-all-6.5.5/src/soc/phy/wc40_extra.h	2016-07-30 00:54:54.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/wc40_extra.h	2018-01-26 11:20:33.990358520 +0000
@@ -220,12 +220,13 @@
 #define WC40_CL73_KR2_CUSTOM_WAR  6
 #define WC40_CL73_KR2_WAR         5
 #define WC40_CL73_KR2_CUSTOM   4
 #define WC40_CL73_KR2          3
 #define WC40_CL73_WO_CL73BAM   2
 #define WC40_CL73_AND_CL73BAM  1
+#define WC40_CL73_AUTONEG_MODE WC40_CL73_WO_CL73BAM /* PTin added: WC40 */
 
 #define WC40_CL37_WO_CL37BAM   2
 #define WC40_CL37_AND_CL37BAM  1
 
 /* KR2 control */
 #define WC40_SOFT_KR2_STATE_INIT        0
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/wcmod/src/wcmod.c esw_sdk_modified/src/soc/phy/wcmod/src/wcmod.c
--- sdk-all-6.5.5/src/soc/phy/wcmod/src/wcmod.c	2016-07-30 00:54:55.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/wcmod/src/wcmod.c	2018-01-26 11:20:34.006358520 +0000
@@ -73,12 +73,13 @@
 #include "wcmod_phyreg.h"
 #include "wcmod_main.h"
 #include "wcmod_defines.h"
 #include "wcmod_functions.h"
 #include "wcmod_diagnostics.h"
 
+#include "logger.h"
 
 
 #define WCMOD_SDK32387_REVS(_pc) (WCMOD_REVID_A0(_pc) || WCMOD_REVID_A1(_pc) || WCMOD_REVID_B0(_pc))
 #define WCMOD_PHY400_REVS(_pc) (WCMOD_REVID_B0(_pc))
 
 /* static variables */
@@ -3815,12 +3816,18 @@ phy_wcmod_init(int unit, soc_port_t port
         (phy_wcmod_ability_advert_set(unit, port, &ability));
 
     LOG_INFO(BSL_LS_SOC_PHY,
              (BSL_META_U(pc->unit,
                          "phy_wcmod_init: u=%d p=%d\n"), unit, port));
 
+    /* PTin added: PHY link down problem */
+    #if 1
+    PT_LOG_INFO(LOG_CTX_SDK,"WCMOD initialized for bcm_port %u", port);
+    osapiSleepMSec(50);
+    #endif
+
     return SOC_E_NONE;
 }
 
 #define PCS_STATUS_LANE4_SYNC   0x80F
 
 /*
@@ -6701,12 +6708,17 @@ phy_wcmod_xgxs16g1l_an_set(int unit, soc
             (MODIFY_WC40_AN_IEEE0BLK_AN_IEEECONTROL1r(unit, ws, an_enable, 
                                                       MII_CTRL_AE | MII_CTRL_RAN));
     }
                                                                                 
     pc->fiber.autoneg_enable = an;
                                                                                 
+    LOG_INFO(BSL_LS_SOC_PHY,
+             (BSL_META_U(pc->unit,
+                         "phy_wcmod_xgxs16g1l_an_set: Successfully set u=%d p=%d an=%d\n"),
+              unit, port, an));
+
     return SOC_E_NONE;
 }
 
 STATIC int
 phy_wcmod_xgxs16g1l_an_get(int unit, soc_port_t port, int *an, int *an_done)
 {
@@ -7289,16 +7301,17 @@ phy_wcmod_xgxs16g1l_ability_local_get(in
         ability->interface = SOC_PA_INTF_XGMII ;
         ability->medium    = SOC_PA_MEDIUM_FIBER;
         ability->loopback  = SOC_PA_LB_PHY;
         ability->flags     = 0 ;    /*SOC_PA_AUTONEG */
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(pc->unit,
-                         "phy_wc_xgxs16g11_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, pc->port, ability->speed_full_duplex));
+    /* PTin modified: logs */
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+                  (BSL_META_U(pc->unit,
+                              "phy_wc_xgxs16g11_ability_local_get:unit=%d p=%d sp=%08x\n"),
+                   unit, pc->port, ability->speed_full_duplex));
 
     return (SOC_E_NONE);
 }
 
 /* end of xenia AN codes */
 
@@ -7924,13 +7937,13 @@ _phy_wcmod_c73_adv_local_get(int unit, s
         default:
             pause = 0;
             break;
     }
     ability->pause = pause;
 
-    LOG_INFO(BSL_LS_SOC_PHY,
+    LOG_VERBOSE(BSL_LS_SOC_PHY,
              (BSL_META_U(pc->unit,
                          "_phy_wcmod_c73_adv_local_get: u=%d p=%d pause=%08x speeds=%04x\n"),
               unit, port, pause, speeds));
 
     return SOC_E_NONE;
 }
@@ -8290,13 +8303,13 @@ phy_wcmod_ability_advert_get(int unit, s
     /* check for clause73 */
     if (DEV_CFG_PTR(pc)->cl73an) {
         SOC_IF_ERROR_RETURN
             (_phy_wcmod_c73_adv_local_get(unit, port, ability));
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
+    LOG_VERBOSE(BSL_LS_SOC_PHY,
              (BSL_META_U(pc->unit,
                          "phy_wcmod_ability_advert_get:unit=%d p=%d pause=%08x sp=%08x max_spd=%0d\n"),
               unit, port, ability->pause, ability->speed_full_duplex, pc->speed_max));
 
 
     return SOC_E_NONE;
@@ -9041,16 +9054,17 @@ phy_wcmod_ability_local_get(int unit, so
         ability->interface = SOC_PA_INTF_XGMII;
         phy_wcmod_medium_get(unit, port, &ability->medium);
         ability->loopback  = SOC_PA_LB_PHY;
         ability->flags     = SOC_PA_AUTONEG;
     }
 
-    LOG_INFO(BSL_LS_SOC_PHY,
-             (BSL_META_U(pc->unit,
-                         "phy_wcmod_ability_local_get:unit=%d p=%d sp=%08x\n"),
-              unit, port, ability->speed_full_duplex));
+    /* PTin modified: logs */
+    LOG_DEBUG(BSL_LS_SOC_PHY,
+                  (BSL_META_U(pc->unit,
+                              "phy_wcmod_ability_local_get:unit=%d p=%d sp=%08x\n"),
+                   unit, port, ability->speed_full_duplex));
 
     return (SOC_E_NONE);
 }
 
 /*
 Bits lane assignment
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/phy/wcmod/src/wcmod_cfg_seq.c esw_sdk_modified/src/soc/phy/wcmod/src/wcmod_cfg_seq.c
--- sdk-all-6.5.5/src/soc/phy/wcmod/src/wcmod_cfg_seq.c	2016-07-30 00:54:55.000000000 +0100
+++ esw_sdk_modified/src/soc/phy/wcmod/src/wcmod_cfg_seq.c	2018-01-26 11:20:34.002358520 +0000
@@ -6312,12 +6312,14 @@ int wcmod_power_control(wcmod_st* pc)
   int mask = 0;
   int tmp_lane;
   uint16 ln_ctrl;
 
   tmp_lane = pc->this_lane;
 
+  /* PTin removed: this section code is pulling down the next QSGMII core link, when the first is disabled (ge0 disable->ge4 goes down) */
+#if 0
   /* if the core is qsgmii core */ 
   if (((pc->model_type) == WCMOD_QS_A0) && !(pc->port_type == WCMOD_COMBO)) {
       int power_down = 0;
       if (cntl & CHANGE_TX0_POWERED_STATE){
         if (cntl & POWER_DOWN_TX0)
         power_down = 1;
@@ -6335,12 +6337,13 @@ int wcmod_power_control(wcmod_st* pc)
         power_down = 1;
       }
       MODIFY_WC40_COMBO_IEEE0_MIICNTLr(pc->unit, pc,
                                    power_down << IEEE0BLK_MIICNTL_PWRDWN_SW_SHIFT,
                                    IEEE0BLK_MIICNTL_PWRDWN_SW_MASK);
   } else {
+#endif
   if (cntl & CHANGE_TX0_POWERED_STATE){
     if (cntl & POWER_DOWN_TX0)
       power_down_val |= 0x1 << (XGXSBLK1_LANECTRL3_PWRDN_TX_SHIFT);
     mask |= 0x1 << (XGXSBLK1_LANECTRL3_PWRDN_TX_SHIFT);
   }
   if (cntl & CHANGE_TX1_POWERED_STATE){
@@ -6399,13 +6402,15 @@ int wcmod_power_control(wcmod_st* pc)
       mask |= XGXSBLK1_LANECTRL3_PWRDWN_FORCE_MASK;
   }  
   MODIFY_WC40_XGXSBLK1_LANECTRL3r(pc->unit, pc, power_down_val, mask);
 
   pc->lane_num_ignore = 0;
   pc->this_lane = tmp_lane;
+#if 0
   }
+#endif
 
   return SOC_E_NONE;
 }
 
 /*!
 \brief sets the lanes in Full Duplex/ half duplex mode.
diff -rpN '--unified=6' sdk-all-6.5.5/src/soc/portmod/portmod.c esw_sdk_modified/src/soc/portmod/portmod.c
--- sdk-all-6.5.5/src/soc/portmod/portmod.c	2016-07-30 00:54:55.000000000 +0100
+++ esw_sdk_modified/src/soc/portmod/portmod.c	2018-01-26 11:20:34.554358520 +0000
@@ -1750,18 +1750,18 @@ int portmod_port_pm_type_get(int unit, i
     if(_pmm_info[unit] == NULL){
         _SOC_EXIT_WITH_ERR(SOC_E_INIT, (_SOC_MSG("Portmod was not initialized for the unit")));
     }
 
     rv = SOC_WB_ENGINE_GET_ARR(unit, SOC_WB_ENGINE_PORTMOD, PMM_WB_PORT_ALIAS_MAP, real_port, port);
     if (SOC_FAILURE(rv)) {
-        _SOC_EXIT_WITH_ERR(SOC_E_PORT, ("port %d doesn't exist", port));
+        _SOC_EXIT_WITH_ERR(SOC_E_PORT, (_SOC_MSG("port %d doesn't exist"), port));
     }
 
     /* if real_port is invalid, it should not call portmod_pm_info_get with invalid port.*/
     if(*real_port == INVALID_PORT) {
-        _SOC_EXIT_WITH_ERR(SOC_E_PORT, ("port %d is not valid.", port));        
+        _SOC_EXIT_WITH_ERR(SOC_E_PORT, (_SOC_MSG("port %d is not valid."), port));        
     }
 
     _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, *real_port, &pm_info));
     *type = pm_info->type;
 exit:
     SOC_FUNC_RETURN;     
diff -rpN '--unified=6' sdk-all-6.5.5/systems/bde/linux/kernel/linux-kernel-bde.c esw_sdk_modified/systems/bde/linux/kernel/linux-kernel-bde.c
--- sdk-all-6.5.5/systems/bde/linux/kernel/linux-kernel-bde.c	2016-07-30 00:54:58.000000000 +0100
+++ esw_sdk_modified/systems/bde/linux/kernel/linux-kernel-bde.c	2018-01-26 11:20:30.274358520 +0000
@@ -147,16 +147,24 @@
 #include <etc_robo.h>
 #endif 
 #endif /* BCM_ROBO_SUPPORT */
 
 MODULE_AUTHOR("Broadcom Corporation");
 MODULE_DESCRIPTION("Kernel BDE");
+#ifdef __arm__
 MODULE_LICENSE("Proprietary");
+#else
+MODULE_LICENSE("GPL");
+#endif
 
 /* PCIe max payload */
+#if defined (__arm__)     /* PTin added: PCI */
 int maxpayload = 256;
+#else
+int maxpayload = 128;     /* PTin modified: Max payload limited to 128B */
+#endif
 LKM_MOD_PARAM(maxpayload, "i", int, 0);
 MODULE_PARM_DESC(maxpayload,
 "Limit maximum payload size and request size on PCIe devices");
 
 /* Use MSI interrupts */
 int usemsi = -1;
@@ -561,18 +569,21 @@ robo_spi_write(void *cookie, uint16_t re
 #define PCI_DEVID_PI7C9X130   0xE130
 #define DEV_CTRL_REG           0xb8
 
 #define MAX_PAYLOAD_256B       (1 << 5)
 #define MAX_PAYLOAD_512B       (2 << 5)
 #define MAX_READ_REQ_256B      (1 << 12)
-
+#define MAX_READ_REQ_512B      (2 << 12)          /* PTin added: PCI */
 
 /* Freescale 8548 PCI-E  host Bridge */
 #define FSL_VENDOR_ID                   0x1957
 #define FSL8548PCIE_DEVICE_ID           0x0013
 #define FSL2020EPCIE_DEVICE_ID          0x0070
+#define FSL8544PCIE_DEVICE_ID           0x0033    /* PTin added: PCI PQ3 8544 */
+#define FSL2040EPCIE_DEVICE_ID          0x0411    /* PTin added: PCI P2040 */
+#define FSL2040SECEPCIE_DEVICE_ID       0x0410    /* PTin added: PCI P2040 */
 #define FSL8548PCIE_DEV_CTRL_REG        0x54
 
 /* 4716 PCI-E  host Bridge */
 #define BCM4716_VENDOR_ID               0x14e4
 #define BCM4716PCIE_DEVICE_ID           0x4716
 #define BCM4716PCIE_DEV_CAP_REG         0xd4
@@ -615,12 +626,23 @@ robo_spi_write(void *cookie, uint16_t re
 #define BCM58522_PCI_DEVICE_ID     0x8022
 
 /* Broadcom BCM58712 */
 #define BCM58712_PCI_VENDOR_ID     0x14E4
 #define BCM58712_PCI_DEVICE_ID     0x168E
 
+/* PTin added: PCI high speed switches */
+#if 1
+/* Broadcom BCM56640 */
+#define BCM56640_PCI_VENDOR_ID     0x14E4
+#define BCM56640_PCI_DEVICE_ID     0xb640
+
+/* Broadcom BCM56846 */
+#define BCM56846_PCI_VENDOR_ID     0x14E4
+#define BCM56846_PCI_DEVICE_ID     0xb846
+#endif
+
 static uint32_t _read(int d, uint32_t addr);
 
 #ifdef BCM_ICS
 #else
 /* Used to determine overall memory limits across all devices */
 static uint32_t _pci_mem_start = 0xFFFFFFFF;
@@ -722,12 +744,15 @@ _eb_device_create(resource_size_t paddr,
 
 static int
 petra_device_create(void)
 {
     bde_ctrl_t* ctrl;
 
+    /* PTin added: Do not execute this function */
+    return 0;
+
     ctrl = _devices; 
 
 #ifndef __DUNE_LINUX_BCM_CPU_PCIE__
     _switch_ndevices++;
     _ndevices++;
 
@@ -1773,22 +1798,38 @@ p2p_bridge(void)
          * Writes to the PCIE capability device control register
          */
         pci_write_config_dword(dev, DEV_CTRL_REG,
                                MAX_PAYLOAD_256B | MAX_READ_REQ_256B);
     }
 
-    if ((dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL8548PCIE_DEVICE_ID, NULL)) != NULL ||
+    if ((dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL8544PCIE_DEVICE_ID, NULL)) != NULL ||     /* PTin added: PCI PQ3-8544*/
+        (dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL8548PCIE_DEVICE_ID, NULL)) != NULL ||
         (dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL2020EPCIE_DEVICE_ID, NULL)) != NULL) {
         /*
          * Configure the PCIE cap: Max payload size: 256, Max Read
          * Request size: 256, disabling relax ordering.
          * Writes to the PCIE capability device control register
          */
         pci_write_config_dword(dev, FSL8548PCIE_DEV_CTRL_REG,
                                MAX_PAYLOAD_256B | MAX_READ_REQ_256B);
     }
+    /* PTin added: PCI P2040 */
+    #if 1
+    else if ((dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL2040EPCIE_DEVICE_ID, NULL)) != NULL ||
+             (dev = PCI_FIND_DEV(FSL_VENDOR_ID, FSL2040SECEPCIE_DEVICE_ID, NULL)) != NULL)
+    {
+        /*
+         * Configure the PCIE cap: Max payload size: 512, Max Read
+         * Request size: 512, disabling relax ordering.
+         * Writes to the PCIE capability device control register
+         */
+        pci_write_config_dword(dev, FSL8548PCIE_DEV_CTRL_REG,
+                               MAX_PAYLOAD_512B | MAX_READ_REQ_512B);
+    }
+    #endif
+
     if ((dev = PCI_FIND_DEV(BCM4716_VENDOR_ID, BCM4716PCIE_DEVICE_ID, NULL)) != NULL ||
         (dev = PCI_FIND_DEV(BCM53000_VENDOR_ID, BCM53000PCIE_DEVICE_ID, NULL)) != NULL) {
         uint32 tmp, maxpayld, device_bmp=0, mask;
         unsigned long addr;
         uint16 tmp16, tmp161;
         int i, bus0 = -1, bus1 = -1, port;        
@@ -2168,12 +2209,17 @@ _pci_probe(struct pci_dev *dev, const st
 
         if (debug >= 4) {gprintk("Enabling PCI device : vendor_id=0x%x, device_id=0x%x\n", dev->vendor, dev->device);}
         if (pci_enable_device(dev)) {
             gprintk("Cannot enable PCI device : vendor_id = %x, device_id = %x\n",
                     dev->vendor, dev->device);
         }
+/* PTin added */
+        else {
+            gprintk("LTX: Enabled pci device : vendor_id = %x, device_id = %x\n",dev->vendor, dev->device);
+        }
+/* PTin end */
 
         
         /*
          * These are workarounds to get around some existing
          * kernel problems :(
          */
@@ -2182,15 +2228,17 @@ _pci_probe(struct pci_dev *dev, const st
          * While probing we determine the overall limits for the PCI
          * memory windows across all devices. These limits are used
          * later on by the PCI-PCI bridge  code.
          */
         if (pci_resource_start(dev, baroff) < _pci_mem_start) {
             _pci_mem_start = pci_resource_start(dev, baroff);
+            gprintk("LTX: Adjusted _pci_mem_start\n");
         }
         if (pci_resource_end(dev, baroff) > _pci_mem_end) {
             _pci_mem_end = pci_resource_end(dev, baroff);
+            gprintk("LTX: Adjusted _pci_mem_end\n");
         }
 
 #ifdef CONFIG_SANDPOINT
         /*
          * Something wrong with the PCI subsystem in the mousse kernel.
          * The device is programmed correctly, but the irq in the pci
@@ -2282,12 +2330,29 @@ _pci_probe(struct pci_dev *dev, const st
             /* BCM58525/BCM58712 CPU boards support 128 Max payload size */
             if (maxpayload) {
                 maxpayload = 128;
                 if (debug >= 1) gprintk("force max payload size to 128\n");
             }
         }
+        /* PTin added: PCI */
+        #if 1
+        else if ((PCI_FIND_DEV(BCM56846_PCI_VENDOR_ID, BCM56846_PCI_DEVICE_ID, NULL)) != NULL) {
+            /* BCM58525 CPU boards support 128 Max payload size */
+            if (maxpayload) {
+                maxpayload = 256;
+                if (debug >= 1) gprintk("force max payload size to 256\n");
+            }
+        }
+        else if ((PCI_FIND_DEV(BCM56640_PCI_VENDOR_ID, BCM56640_PCI_DEVICE_ID, NULL)) != NULL) {
+            /* BCM58525 CPU boards support 128 Max payload size */
+            if (maxpayload) {
+                maxpayload = 512;
+                if (debug >= 1) gprintk("force max payload size to 512\n");
+            }
+        }
+        #endif
 
         if (forceirq > 0 && dev->irq != (uint32) forceirq) {
             if (forceirqubm & (1U << (_ndevices - 1))) {
                 dev->irq = forceirq;
                 if (debug >= 1) gprintk("force irq to %d\n", forceirq);
             }
@@ -2349,12 +2414,48 @@ _pci_probe(struct pci_dev *dev, const st
         break;
     default:
         break;
     }
 #endif
 
+#ifndef __arm__
+    if (debug >= 1) {
+        uint8 aux8;
+        uint32 aux32;
+
+        gprintk("***********PCI Conf registers: api 5.9.2**********\n");
+        pci_read_config_dword(dev, 0x0, &aux32);
+        gprintk("* Vendor ID | Device ID :  0x%08X *\n", aux32);
+        pci_read_config_dword(dev, 0x4, &aux32);
+        gprintk("* Class Code| rev ID    :  0x%08X *\n", aux32);
+        pci_read_config_byte(dev, 0xC, &aux8);
+        gprintk("* Cache line syze       :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0xD, &aux8);
+        gprintk("* Latency Timer         :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0xE, &aux8);
+        gprintk("* Header Type           :  0x%02X       *\n", aux8);
+        pci_read_config_dword(dev, 0x10, &aux32);
+        gprintk("* BASE ADDRESS LOW      :  0x%08X *\n", aux32);
+        pci_read_config_dword(dev, 0x14, &aux32);
+        gprintk("* BASE ADDRESS HIGH     :  0x%08X *\n", aux32);
+        pci_read_config_byte(dev, 0x3C, &aux8);
+        gprintk("* Interrupt Line        :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x3D, &aux8);
+        gprintk("* Interrupt Pin         :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x3E, &aux8);
+        gprintk("* Minimum Grant         :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x3F, &aux8);
+        gprintk("* Maximum Latency       :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x40, &aux8);
+        gprintk("* Retry Count           :  0x%02X       *\n", aux8);
+        pci_read_config_byte(dev, 0x41, &aux8);
+        gprintk("* TRDY Timeout          :  0x%02X       *\n", aux8);
+        gprintk("****************************\n");
+    }
+#endif
+
     /* Prevent compiler warning */
     if (ctrl == NULL) {
         return 0;
     }
 
     ctrl->be_pio = 0;
@@ -2528,12 +2629,13 @@ _pci_probe(struct pci_dev *dev, const st
     if (debug >= 2) {
         gprintk("_pci_probe: configured dev:0x%x rev:0x%x with base_addresses: 0x%lx 0x%lx\n",
           (unsigned)ctrl->bde_dev.device, (unsigned)ctrl->bde_dev.rev,
           (unsigned long)ctrl->bde_dev.base_address, (unsigned long)ctrl->bde_dev.base_address1);
     }
     /* Let's boogie */
+    gprintk("LTX: BCM: Reached end of _probe\n");
     return 0;
 }
 
 /*
  * Function: _pci_remove
  *
@@ -4621,12 +4732,23 @@ _interrupt_connect(int d,
 {
     bde_ctrl_t *ctrl;
     unsigned long irq_flags;
     int isr2_dev;
     int isr_active;
 
+    /* PTin added: Kernel */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+#ifndef __arm__
+    struct device_node *np = NULL;
+    unsigned int eirq;
+#endif
+#endif
+
+    gprintk("Setting IRQ...\n");
+    /* PTin end */
+
     isr2_dev = d & LKBDE_ISR2_DEV;
     d &= ~LKBDE_ISR2_DEV;
 
     if (!VALID_DEVICE(d)) {
         gprintk("_interrupt_connect: Invalid device index %d\n", d);
         return -1;
@@ -4663,18 +4785,44 @@ _interrupt_connect(int d,
         if (isr_active) {
             /* Main handler (_isr) already installed */
             return 0;
         }
     }
 
+    /* PTin added: Kernel */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+#ifndef __arm__
+    np = of_find_compatible_node(NULL, NULL, "bcm,fastpath-pci");
+	  if (np == NULL){
+      gprintk ("LMP - Nao apanhei nenhum no' da devtree\n\r");
+      return -1;
+    }
+    eirq = irq_of_parse_and_map(np, 0);
+    if (eirq == NO_IRQ)
+    {
+      gprintk ("LMP - Nao apanhei nenhum irq devtree\n\r");
+      return -1;
+    }
+    ctrl->iLine = eirq;
+#endif
+#endif
+    gprintk("irq to be used: %d\n",ctrl->iLine);
+    /* PTin end */
+
     if (ctrl->iLine != -1) {
         irq_flags = IRQF_SHARED;
 #if defined(CONFIG_PCI_MSI)
+        gprintk ("LTX: Trying to enable MSI\n");
         if (ctrl->use_msi && pci_enable_msi(ctrl->pci_device) == 0) {
             irq_flags = 0;
             ctrl->iLine = ctrl->pci_device->irq;
+            gprintk ("LTX: Success enabling MSI\n");
+        }
+        else
+        {
+            gprintk ("LTX: MSI not enabled\n");
         }
 #endif
         if (request_irq(ctrl->iLine,
                        _isr,
                        irq_flags,
                        LINUX_KERNEL_BDE_NAME,
@@ -4690,12 +4838,13 @@ _interrupt_connect(int d,
             if (ctrl->use_msi && irq_flags == 0) {
                 pci_disable_msi(ctrl->pci_device);
             }
 #endif
             return -1;
         }
+        gprintk("Success requesting irq %d\n", ctrl->iLine);
     }
 
     return 0;
 }
 
 static int
diff -rpN '--unified=6' sdk-all-6.5.5/systems/bde/linux/kernel/linux_dma.c esw_sdk_modified/systems/bde/linux/kernel/linux_dma.c
--- sdk-all-6.5.5/systems/bde/linux/kernel/linux_dma.c	2016-07-30 00:54:58.000000000 +0100
+++ esw_sdk_modified/systems/bde/linux/kernel/linux_dma.c	2018-01-26 11:20:30.274358520 +0000
@@ -136,13 +136,13 @@ /* DMA memory allocation */
 #define ONE_MB (1024*1024)
 
 /* Default DMA memory size */
 #ifdef SAL_BDE_DMA_MEM_DEFAULT
 #define DMA_MEM_DEFAULT (SAL_BDE_DMA_MEM_DEFAULT * ONE_MB)
 #else
-#define DMA_MEM_DEFAULT (8 * ONE_MB)
+#define DMA_MEM_DEFAULT (16 * ONE_MB)
 #endif
 #define DMA_MEM_DEFAULT_ROBO (4 * ONE_MB)
 
 /* We try to assemble a contiguous segment from chunks of this size */
 #define DMA_BLOCK_SIZE (512 * ONE_KB)
 
@@ -530,12 +530,14 @@ _alloc_mpool(size_t size)
         if (((pbase + size) >> 16) > DMA_BIT_MASK(16)) {
             gprintk("DMA in high memory at 0x%lx size 0x%lx is beyond the 4GB limit and not supported.\n", pbase, (unsigned long)size);
             return;
         }
         _dma_pbase = pbase;
         _dma_vbase = IOREMAP(_dma_pbase, size);
+        if (dma_debug >= 1)
+          gprintk("_alloc_mpool (himem=1): _dma_vbase:%p pbase:%lx  allocated:%lx\n", _dma_vbase, pbase, (unsigned long)size);
     } else {
         /* Get DMA memory from kernel */
         switch (dmaalloc) {
 #if _SIMPLE_MEMORY_ALLOCATION_
           case ALLOC_TYPE_API: {
             size_t alloc_size = size; /* size of memory allocated in current iteration */
@@ -530,22 +530,24 @@ _alloc_mpool(size_t size)
                 alloc_size = DMA_MAX_ALLOC_SIZE;
             }
             /* get a memory allocation from the kernel */
             {
                 dma_addr_t dma_handle;
                 if (!(_dma_vbase = dma_alloc_coherent(0, alloc_size, &dma_handle, GFP_KERNEL)) || !dma_handle) {
-                    gprintk("_alloc_mpool: Kernel failed to allocate the memory pool of size 0x%lx\n", (unsigned long)alloc_size);
+                    gprintk("_alloc_mpool: Kernel failed to allocate the memory pool of size 0x%lx (_dma_vbase=0x%08lx dma_handle=0x%08lx)\n",
+                        (unsigned long)alloc_size, (unsigned long) _dma_vbase, (unsigned long) dma_handle);
                     return;
                 }
                 pbase = dma_handle;
             }
 
             if (alloc_size != size) {
                 gprintk("_alloc_mpool: allocated 0x%lx bytes instead of 0x%lx bytes.\n", (unsigned long)alloc_size, (unsigned long)size);
             }
             size = _dma_mem_size = alloc_size;
+            gprintk("_alloc_mpool: _SIMPLE_MEMORY_ALLOCATION_ successfull\n");
             break;
           }
 #endif /* _SIMPLE_MEMORY_ALLOCATION_ */
 
           case ALLOC_TYPE_CHUNK:
             _dma_vbase = _pgalloc(size);
@@ -3126,12 +3232,14 @@ _alloc_mpool(size_t size)
             return;
         }
         _dma_pbase = pbase;
 #ifdef REMAP_DMA_NONCACHED
         _dma_vbase = IOREMAP(_dma_pbase, size);
 #endif
+        if (debug >= 1)
+          gprintk("_alloc_mpool: _dma_vbase:%p pbase:%lx  allocated:%lx\n", _dma_vbase, pbase, (unsigned long)size);
     }
 }
 
 /*
  * Function: _dma_cleanup
  *
@@ -630,25 +630,28 @@ _dma_init(void)
         }
     }
 
     if (himem) {
         if ((himem[0] & ~0x20) == 'Y' || himem[0] == '1') {
             _use_himem = 1;
+            gprintk("LTX: Using himem dma allocation\n");
         } else if ((himem[0] & ~0x20) == 'N' || himem[0] == '0') {
+            gprintk("LTX: NOT Using himem dma allocation\n");
             _use_himem = 0;
         }
     }
 
     if (_dma_mem_size) {
         _alloc_mpool(_dma_mem_size);
         if (_dma_vbase == NULL) {
             gprintk("no DMA memory available\n");
         }
         else {
             mpool_init();
             _dma_pool = mpool_create(_dma_vbase, _dma_mem_size);
+            gprintk("Allocated %d bytes for DMA memory\n", _dma_mem_size);  /* PTin added */
         }
     }
 }
 
 #if USE_LINUX_BDE_MMAP
 /*
diff -rpN '--unified=6' sdk-all-6.5.5/systems/bde/linux/kernel/Makefile.kbde esw_sdk_modified/systems/bde/linux/kernel/Makefile.kbde
--- sdk-all-6.5.5/systems/bde/linux/kernel/Makefile.kbde	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/bde/linux/kernel/Makefile.kbde	2018-01-26 11:20:30.274358520 +0000
@@ -0,0 +1,11 @@
+# This Makefile is copied to the objects/kmod output directory along with
+# the required .c files in order to build the kernel module in the output
+# location.
+#
+# Using the original kernel Makefile contents, but stripping off the
+# path names from the list of .o files being built.
+#
+
+include $(FP_ROOT)/vendor/broadcom/esw_sdk/systems/bde/linux/kernel/Makefile
+
+kbde-y := $(notdir $(kbde-y))
diff -rpN '--unified=6' sdk-all-6.5.5/systems/bde/linux/shared/Makefile esw_sdk_modified/systems/bde/linux/shared/Makefile
--- sdk-all-6.5.5/systems/bde/linux/shared/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/bde/linux/shared/Makefile	2018-01-26 11:20:30.278358520 +0000
@@ -0,0 +1,40 @@
+FP_BASE=../../../../../../..
+
+FPLIB=fp_shared.a
+
+# -*- Makefile -*-
+# $Id: Makefile,v 1.4 Broadcom SDK $
+# $Copyright: (c) 2004 Broadcom Corp.
+# All Rights Reserved.$
+#
+# Makefile for Linux user BDE
+#
+
+# Do not change this line.
+#
+include $(FP_BASE)/src/l7tools/build/make.cfg
+
+# Specify additional header directories needed by your component
+COMPONENT_INCLDIR += $(BROADCOM_INCL) \
+	-I../include \
+	-I$(KERNEL_SRC)/arch/ppc
+	
+	
+
+# Specify compile flags.
+#
+CFLAGSLOCAL= $(GFLAG) $(SWCFLAG)  \
+ 	-DBROADCOM_DEBUG
+
+# Specify modules that need to be compiled.
+#
+ifeq ($(findstring LINUX,$(L7_OS_VERSION)),LINUX) 
+LIBOBJS = mpool.o
+else
+LIBOBJS =
+endif
+
+# Do not change this line.
+#
+include $(FP_BASE)/src/l7tools/build/make.footer
+
diff -rpN '--unified=6' sdk-all-6.5.5/systems/bde/linux/user/kernel/Makefile.ubde esw_sdk_modified/systems/bde/linux/user/kernel/Makefile.ubde
--- sdk-all-6.5.5/systems/bde/linux/user/kernel/Makefile.ubde	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/bde/linux/user/kernel/Makefile.ubde	2018-01-26 11:20:30.278358520 +0000
@@ -0,0 +1,11 @@
+# This Makefile is copied to the objects/kmod output directory along with
+# the required .c files in order to build the kernel module in the output
+# location.
+#
+# Using the original kernel Makefile contents, but stripping off the
+# path names from the list of .o files being built.
+#
+
+include $(FP_ROOT)/vendor/broadcom/esw_sdk/systems/bde/linux/user/kernel/Makefile
+
+ubde-y := $(notdir $(ubde-y))
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/kernel/CXO2T4-e500mc-3_x/Makefile esw_sdk_modified/systems/linux/kernel/CXO2T4-e500mc-3_x/Makefile
--- sdk-all-6.5.5/systems/linux/kernel/CXO2T4-e500mc-3_x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/kernel/CXO2T4-e500mc-3_x/Makefile	2018-01-26 11:20:30.186358520 +0000
@@ -0,0 +1,104 @@
+# -*- Makefile -*-
+# $Id: Makefile 1.10 Broadcom SDK $
+# $Copyright: Copyright 2012 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+#
+# This make job requires the following environment variables to be set:
+#
+# SDK                - path to StrataXGS SDK root directory
+#
+# Optionally the following environment variables can be set to
+# override the default build server configuration:
+#
+# PPC_TOOLS_DIR     - path to build tools (if not in PATH already)
+# PPC_CROSS_COMPILE - cross compile tools prefix
+# LINUX_INCLUDE      - path to Linux kernel include directory
+#
+
+SDK :=$(shell if [ -n "$$SDK" ] ; then\
+	echo $$SDK;\
+	else\
+	cd $(dir $(lastword $(MAKEFILE_LIST))); while /usr/bin/test ! -e RELEASE ; do \
+	dir=`cd ../;pwd`;			\
+	if [ "$$dir" = "/" ] ; then		\
+	   echo Cannot find SDK in $(lastword $(MAKEFILE_LIST)) 1>&2;		\
+	   exit 1;				\
+	fi ;					\
+	cd $$dir;				\
+	done ;					\
+	pwd;					\
+	fi)
+
+ifeq ($(SDK),)					
+$(error Please run this in a tree)		
+endif 				
+
+export SDK
+
+override kernel_version=3_x
+platform=CXO2T4-e500mc-$(kernel_version)
+
+# Select build platform 
+BUILD_PLATFORM=WR_LINUX
+#BUILD_PLATFORM=ELDK
+
+#Select the LINUX KERNEL VERSION 
+#KERN_VER = 2.6.21.7
+#KERN_VER = 2.6.24.4
+KERN_VER = 4.1.8
+
+#Select the ELDK version
+#ELDK_VERSION=4.1
+#ELDK_VERSION=4.0
+
+#Select WRS linux version
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=3.0
+
+
+export KERN_VER
+export ELDK_VERSION
+export BUILD_PLATFORM
+export WRS_LINUX_VERSION
+include ${SDK}/make/Make.linux
+
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/kernel/modules/include/lkm.h esw_sdk_modified/systems/linux/kernel/modules/include/lkm.h
--- sdk-all-6.5.5/systems/linux/kernel/modules/include/lkm.h	2016-07-30 00:54:58.000000000 +0100
+++ esw_sdk_modified/systems/linux/kernel/modules/include/lkm.h	2018-01-26 11:20:30.158358520 +0000
@@ -68,16 +68,20 @@
 #include <linux/smp_lock.h>
 #endif
 #include <linux/module.h>
 
 /* Helper defines for multi-version kernel  support */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#ifndef LKM_2_4
 #define LKM_2_4
+#endif
 #else
+#ifndef LKM_2_6
 #define LKM_2_6
 #endif
+#endif
 
 #include <linux/kernel.h>   /* printk() */
 #include <linux/fs.h>       /* everything... */
 #include <linux/errno.h>    /* error codes */
 #include <linux/types.h>    /* size_t */
 #include <linux/proc_fs.h>
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/kernel/TA12XG-e500-3_x/Makefile esw_sdk_modified/systems/linux/kernel/TA12XG-e500-3_x/Makefile
--- sdk-all-6.5.5/systems/linux/kernel/TA12XG-e500-3_x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/kernel/TA12XG-e500-3_x/Makefile	2018-01-26 11:20:30.190358520 +0000
@@ -0,0 +1,104 @@
+# -*- Makefile -*-
+# $Id: Makefile 1.10 Broadcom SDK $
+# $Copyright: Copyright 2012 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+#
+# This make job requires the following environment variables to be set:
+#
+# SDK                - path to StrataXGS SDK root directory
+#
+# Optionally the following environment variables can be set to
+# override the default build server configuration:
+#
+# PPC_TOOLS_DIR     - path to build tools (if not in PATH already)
+# PPC_CROSS_COMPILE - cross compile tools prefix
+# LINUX_INCLUDE      - path to Linux kernel include directory
+#
+
+SDK :=$(shell if [ -n "$$SDK" ] ; then\
+	echo $$SDK;\
+	else\
+	cd $(dir $(lastword $(MAKEFILE_LIST))); while /usr/bin/test ! -e RELEASE ; do \
+	dir=`cd ../;pwd`;			\
+	if [ "$$dir" = "/" ] ; then		\
+	   echo Cannot find SDK in $(lastword $(MAKEFILE_LIST)) 1>&2;		\
+	   exit 1;				\
+	fi ;					\
+	cd $$dir;				\
+	done ;					\
+	pwd;					\
+	fi)
+
+ifeq ($(SDK),)					
+$(error Please run this in a tree)		
+endif 				
+
+export SDK
+
+override kernel_version=3_x
+platform=TA12XG-e500-$(kernel_version)
+
+# Select build platform 
+BUILD_PLATFORM=WR_LINUX
+#BUILD_PLATFORM=ELDK
+
+#Select the LINUX KERNEL VERSION 
+#KERN_VER = 2.6.21.7
+#KERN_VER = 2.6.24.4
+KERN_VER = 3.8.13
+
+#Select the ELDK version
+#ELDK_VERSION=4.1
+#ELDK_VERSION=4.0
+
+#Select WRS linux version
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=3.0
+
+
+export KERN_VER
+export ELDK_VERSION
+export BUILD_PLATFORM
+export WRS_LINUX_VERSION
+include ${SDK}/make/Make.linux
+
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/kernel/TT08SXG-e500mc-3_x/Makefile esw_sdk_modified/systems/linux/kernel/TT08SXG-e500mc-3_x/Makefile
--- sdk-all-6.5.5/systems/linux/kernel/TT08SXG-e500mc-3_x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/kernel/TT08SXG-e500mc-3_x/Makefile	2018-01-26 11:20:30.186358520 +0000
@@ -0,0 +1,105 @@
+# -*- Makefile -*-
+# $Id: Makefile 1.10 Broadcom SDK $
+# $Copyright: Copyright 2012 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+#
+# This make job requires the following environment variables to be set:
+#
+# SDK                - path to StrataXGS SDK root directory
+#
+# Optionally the following environment variables can be set to
+# override the default build server configuration:
+#
+# PPC_TOOLS_DIR     - path to build tools (if not in PATH already)
+# PPC_CROSS_COMPILE - cross compile tools prefix
+# LINUX_INCLUDE      - path to Linux kernel include directory
+#
+
+SDK :=$(shell if [ -n "$$SDK" ] ; then\
+	echo $$SDK;\
+	else\
+	cd $(dir $(lastword $(MAKEFILE_LIST))); while /usr/bin/test ! -e RELEASE ; do \
+	dir=`cd ../;pwd`;			\
+	if [ "$$dir" = "/" ] ; then		\
+	   echo Cannot find SDK in $(lastword $(MAKEFILE_LIST)) 1>&2;		\
+	   exit 1;				\
+	fi ;					\
+	cd $$dir;				\
+	done ;					\
+	pwd;					\
+	fi)
+
+ifeq ($(SDK),)					
+$(error Please run this in a tree)		
+endif 				
+
+export SDK
+
+override kernel_version=3_x
+platform=TT08SXG-e500mc-$(kernel_version)
+
+# Select build platform 
+BUILD_PLATFORM=WR_LINUX
+#BUILD_PLATFORM=ELDK
+
+#Select the LINUX KERNEL VERSION 
+#KERN_VER = 2.6.21.7
+#KERN_VER = 2.6.24.4
+#KERN_VER = 3.8.13
+KERN_VER=3.0.51
+
+#Select the ELDK version
+#ELDK_VERSION=4.1
+#ELDK_VERSION=4.0
+
+#Select WRS linux version
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=3.0
+
+
+export KERN_VER
+export ELDK_VERSION
+export BUILD_PLATFORM
+export WRS_LINUX_VERSION
+include ${SDK}/make/Make.linux
+
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/user/CXO2T4-e500mc-3_x/Makefile esw_sdk_modified/systems/linux/user/CXO2T4-e500mc-3_x/Makefile
--- sdk-all-6.5.5/systems/linux/user/CXO2T4-e500mc-3_x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/user/CXO2T4-e500mc-3_x/Makefile	2018-01-26 11:20:30.234358520 +0000
@@ -0,0 +1,108 @@
+# -*- Makefile -*-
+# $Id: Makefile 1.9 Broadcom SDK $
+# $Copyright: Copyright 2012 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+#
+# This make job requires the following environment variables to be set:
+#
+# SDK                - path to StrataXGS SDK root directory
+#
+# Optionally the following environment variables can be set to
+# override the default build server configuration:
+#
+# PPC_TOOLS_DIR      - path to build tools (if not in PATH already)
+# PPC_CROSS_COMPILE  - cross compile tools prefix
+# LINUX_INCLUDE      - path to Linux kernel include directory
+#
+
+SDK :=$(shell if [ -n "$$SDK" ] ; then\
+	echo $$SDK;\
+	else\
+	cd $(dir $(lastword $(MAKEFILE_LIST))); while /usr/bin/test ! -e RELEASE ; do \
+	dir=`cd ../;pwd`;			\
+	if [ "$$dir" = "/" ] ; then		\
+	   echo Cannot find SDK in $(lastword $(MAKEFILE_LIST)) 1>&2;		\
+	   exit 1;				\
+	fi ;					\
+	cd $$dir;				\
+	done ;					\
+	pwd;					\
+	fi)
+
+ifeq ($(SDK),)					
+$(error Please run this in a tree)		
+endif 				
+
+export SDK
+
+override kernel_version=3_x
+platform=CXO2T4-e500mc-$(kernel_version)
+LINUX_MAKE_USER=1
+export LINKER_RELAX=1
+
+# Select the build environment
+#BUILD_PLATFORM=ELDK
+BUILD_PLATFORM=WR_LINUX
+
+#Select the LINUX KERNEL VERSION
+#KERN_VER = 2.6.21.7
+#KERN_VER = 2.6.24.4
+KERN_VER = 4.1.8
+
+
+# Select the ELDK version
+#ELDK_VERSION=4.1
+#ELDK_VERSION=4.0
+
+#Select WRS Linux version
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=3.0
+
+
+export KERN_VER
+export ELDK_VERSION
+export BUILD_PLATFORM
+export WRS_LINUX_VERSION
+
+include ${SDK}/make/Make.linux
+
Binary files sdk-all-6.5.5/systems/linux/user/CXO2T4-e500mc-3_x/netserve and esw_sdk_modified/systems/linux/user/CXO2T4-e500mc-3_x/netserve differ
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/user/fastpath-3_x/Makefile esw_sdk_modified/systems/linux/user/fastpath-3_x/Makefile
--- sdk-all-6.5.5/systems/linux/user/fastpath-3_x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/user/fastpath-3_x/Makefile	2018-01-26 11:20:30.246358520 +0000
@@ -0,0 +1,27 @@
+# -*- Makefile -*-
+# $Id: Makefile,v 1.1.2.2 Broadcom SDK $
+# $Copyright: Copyright 2007, Broadcom Corporation All Rights Reserved.
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES
+# OF ANY KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE.
+# BROADCOM SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.$
+
+#
+# This make job requires the following environment variables to be set:
+#
+# SDK                - path to StrataXGS SDK root directory
+#
+# Optionally the following environment variables can be set to
+# override the default build server configuration:
+#
+# PPC_TOOLS_DIR      - path to build tools (if not in PATH already)
+# PPC_CROSS_COMPILE  - cross compile tools prefix
+# LINUX_INCLUDE      - path to Linux kernel include directory
+#
+
+override kernel_version=3_x
+platform=$(BOARD)-$(L7_CPU)-$(kernel_version)
+LINUX_MAKE_USER=1
+LINUX_MAKE_DIR := $(SDK)/systems/linux/user/fastpath_common
+include ${SDK}/make/Make.linux
+
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/user/fastpath_common/bdecreate.c esw_sdk_modified/systems/linux/user/fastpath_common/bdecreate.c
--- sdk-all-6.5.5/systems/linux/user/fastpath_common/bdecreate.c	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/user/fastpath_common/bdecreate.c	2018-01-26 11:20:30.238358520 +0000
@@ -0,0 +1,148 @@
+/*
+ * $Id: socdiag.c,v 1.13 Broadcom SDK $
+ * $Copyright: Copyright 2008 Broadcom Corporation.
+ * This program is the proprietary software of Broadcom Corporation
+ * and/or its licensors, and may only be used, duplicated, modified
+ * or distributed pursuant to the terms and conditions of a separate,
+ * written license agreement executed between you and Broadcom
+ * (an "Authorized License").  Except as set forth in an Authorized
+ * License, Broadcom grants no license (express or implied), right
+ * to use, or waiver of any kind with respect to the Software, and
+ * Broadcom expressly reserves all rights in and to the Software
+ * and all intellectual property rights therein.  IF YOU HAVE
+ * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+ * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+ * ALL USE OF THE SOFTWARE.  
+ *  
+ * Except as expressly set forth in the Authorized License,
+ *  
+ * 1.     This program, including its structure, sequence and organization,
+ * constitutes the valuable trade secrets of Broadcom, and you shall use
+ * all reasonable efforts to protect the confidentiality thereof,
+ * and to use this information only in connection with your use of
+ * Broadcom integrated circuit products.
+ *  
+ * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+ * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+ * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+ * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+ * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+ * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+ * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+ * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+ * 
+ * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+ * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+ * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+ * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+ * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+ * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1,
+ * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+ * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+ *
+ * socdiag: low-level diagnostics shell for Orion (SOC) driver.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+
+#include <sal/core/boot.h>
+#include <sal/appl/sal.h>
+#include <sal/appl/config.h>
+#include <soc/debug.h>
+
+#include <appl/diag/system.h>
+
+#include <linux-bde.h>
+
+ibde_t *bde;
+
+/* The bus properties are (currently) the only system specific
+ * settings required. 
+ * These must be defined beforehand 
+ */
+
+#ifndef SYS_BE_PIO
+#error "SYS_BE_PIO must be defined for the target platform"
+#endif
+#ifndef SYS_BE_PACKET
+#error "SYS_BE_PACKET must be defined for the target platform"
+#endif
+#ifndef SYS_BE_OTHER
+#error "SYS_BE_OTHER must be defined for the target platform"
+#endif
+
+#if !defined(SYS_BE_PIO) || !defined(SYS_BE_PACKET) || !defined(SYS_BE_OTHER)
+#error "platform bus properties not defined."
+#endif
+
+int
+bde_create(void)
+{	
+    linux_bde_bus_t bus;
+    bus.be_pio = SYS_BE_PIO;
+    bus.be_packet = SYS_BE_PACKET;
+    bus.be_other = SYS_BE_OTHER;
+    return linux_bde_create(&bus, &bde);
+}
+
+/* PTin added: application control */
+int
+bde_destroy(void)
+{	
+    return linux_bde_destroy(bde);
+}
+
+
+/*
+ * These stubs are here for legacy compatability reasons. 
+ * They are used only by the diag/test code, not the driver, 
+ * so they are really not that important. 
+ */
+typedef void* pci_dev_t;
+
+int pci_dma_putw(pci_dev_t *dev, uint32 addr, uint32 data)
+{
+    *(uint32 *) INT_TO_PTR(addr) = data;
+    return 0;
+}
+
+int pci_dma_puth(pci_dev_t *dev, uint32 addr, uint16 data)
+{
+    *(uint16 *) INT_TO_PTR(addr) = data;
+    return 0;
+}
+
+int pci_dma_putb(pci_dev_t *dev, uint32 addr, uint8 data)
+{
+    *(uint8 *) INT_TO_PTR(addr) = data;
+    return 0;
+}
+
+uint32 pci_dma_getw(pci_dev_t *dev, uint32 addr)
+{
+  uint32 data;
+  data = *(uint32 *) INT_TO_PTR(addr);
+  return data;
+}
+
+uint16 pci_dma_geth(pci_dev_t *dev, uint32 addr)
+{
+  uint16 data;
+  data = *(uint16 *) INT_TO_PTR(addr);
+  return data;
+}
+
+uint8 pci_dma_getb(pci_dev_t *dev, uint32 addr)
+{
+  uint8 data;
+  data = *(uint8 *) INT_TO_PTR(addr);
+  return data;
+}
+
+int pci_print_all(void)
+{
+  return 0;
+}
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/user/fastpath_common/Makefile esw_sdk_modified/systems/linux/user/fastpath_common/Makefile
--- sdk-all-6.5.5/systems/linux/user/fastpath_common/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/user/fastpath_common/Makefile	2018-01-26 11:20:30.238358520 +0000
@@ -0,0 +1,306 @@
+# -*- Makefile -*-
+# $Id: Makefile,v 1.56 Broadcom SDK $
+# $Copyright: Copyright 2008 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+#
+
+override-target=unix-user
+
+NUM_CPUS = $(shell grep -c 'model name' /proc/cpuinfo)
+
+all: check build
+
+ifeq ($(LINUX_MAKE_SHARED_LIB),1)
+libext = so.$(SHAREDLIBVER)
+else
+libext = a
+endif
+
+check:
+ifeq (,$(SDK))
+	@echo 'The $$SDK environment variable is not set'; exit 1
+else
+ifeq (,$(platform))
+	@echo 'Internal error: platform variable is not set'; exit 1
+else
+include $(SDK)/make/Make.config
+LOCALDIR=systems/linux/user/fastpath_common
+include $(SDK)/make/Make.depend
+kernel-override=linux-$(platform)
+ifdef LVL7_FIXUP
+KERN_BLDROOT=$(L7_OUTPUT)/$(kernel-override)$(bldroot_suffix)
+DEST_DIR=$(L7_OUTPUT_KMOD)
+else
+ifdef BLDCONFIG
+KERN_BLDROOT=$(SDK)/build/$(BLDCONFIG)/$(kernel-override)$(bldroot_suffix)
+else
+KERN_BLDROOT=$(SDK)/build/$(kernel-override)$(bldroot_suffix)
+endif
+endif # end LVL7_FIXUP
+endif
+endif
+
+ifeq (,$(kernel_version))
+kernel_version=2_4
+endif
+
+ifeq ($(kernel_version),3_x)
+ADD_TO_CFLAGS += -DLKM_3_x
+KOBJ=ko
+else
+ifeq ($(kernel_version),2_6)
+ADD_TO_CFLAGS += -DLKM_2_6
+KOBJ=ko
+else
+ADD_TO_CFLAGS += -DLKM_2_4
+KOBJ=o
+endif
+endif
+
+ifneq (,$(TOOLS_DIR))
+override PATH := $(TOOLS_DIR):$(PATH)
+endif
+
+ifeq ($(DEST_DIR),)
+DEST_DIR=../$(platform)
+endif
+
+BCM = $(DEST_DIR)/bcm.$(targetplat)$(all_suffix)
+
+KERNEL_BDE=$(DEST_DIR)/linux-kernel-bde.$(KOBJ)
+USER_BDE=$(DEST_DIR)/linux-user-bde.$(KOBJ)
+
+NETSERVE = $(DEST_DIR)/netserve
+
+ifdef LVL7_FIXUP
+all_targets = kernel_modules user_libs $(KERNEL_BDE) $(USER_BDE)
+else
+all_targets = kernel_modules user_libs $(KERNEL_BDE) $(USER_BDE) $(BCM) $(NETSERVE)
+endif
+
+
+# Define targets to be built by default.
+build_targets = $(all_targets)
+
+ADD_TO_CFLAGS += -I$(SDK)/systems/linux/kernel/modules/include
+
+# Target specific
+ifndef LVL7_FIXUP
+ADD_TO_CFLAGS += -DLINUX_SAL_DMA_ALLOC_OVERRIDE
+#ADD_TO_CFLAGS += -DLINUX_SAL_USLEEP_OVERRIDE -DLINUX_SAL_SEM_OVERRIDE
+#ADD_TO_CFLAGS += -DLINUX_SAL_UDELAY_OVERRIDE
+else # Only override SEM
+ADD_TO_CFLAGS += -DLINUX_SAL_SEM_OVERRIDE
+endif
+
+# User BDE libraries
+ADD_TO_CFLAGS += -I$(SDK)/systems/bde/linux/include
+
+ifdef BUILD_PHYMOD
+ADD_TO_CFLAGS += $(SYSROOT)
+endif
+
+CFLAGS += $(ADD_TO_CFLAGS)
+
+ifdef ESW_CHIPS
+ESW_DIAG_LIBS = libdiag_esw.a 
+endif
+
+ifdef ROBO_CHIPS
+ROBO_DIAG_LIBS = libdiagrobo.a
+endif
+
+ifdef SBX_CHIPS
+SBX_DIAG_LIBS = \
+	libdiag_sbx.$(libext)
+endif
+
+ifdef DPP_CHIPS
+DPP_DIAG_LIBS = \
+        libdiag_dpp.$(libext)
+endif
+
+ifdef DFE_CHIPS
+DPP_DIAG_LIBS = \
+        libdiag_dfe.$(libext)
+endif
+
+DIAG_LIBS = \
+        libdiag.a       \
+        ${ESW_DIAG_LIBS} \
+        ${ROBO_DIAG_LIBS} \
+        ${SBX_DIAG_LIBS} \
+	$(COND_LIB_EAV_APPL) \
+	${COND_LIB_BCMX_DIAG} \
+        ${COND_LIB_TEST} \
+	$(COND_LIB_TCL) \
+	$(APPL_LIBS) \
+	$(COND_LIB_EDITLINE) \
+	$(COND_LIB_WBDM) \
+	$(COND_LIB_SMB) \
+	$(COND_LIB_PHY_DIAGNOSTICS) \
+	$(COND_LIB_BSAFE) \
+	libsal_appl.a libsal_appl_plat.a liblubde.a
+
+ACL_LIB = $(COND_LIB_ACL)
+BCM_LIBS = $(DIAG_LIBS) $(DRV_LIBS) $(ACL_LIB) $(COND_LIB_ETH_DRV)
+BCM_LIBS_BLD = $(addprefix $(BLDDIR)/,$(BCM_LIBS))
+
+BCM_LIBS_BLD += ${EXTERNAL_LIBS}
+ifdef LVL7_FIXUP
+  ifdef QUIET
+    entry_msg    = @${ECHO} Generating $(notdir $@)
+    OBJCOPY      := @$(OBJCOPY)
+  endif
+endif
+
+
+build:: $(BLDDIR)/.tree $(build_targets)
+
+kernel_modules:
+	$(MAKE) -j$(NUM_CPUS) -C $(SDK)/systems/bde/linux/kernel kernel_version=$(kernel_version) OPT_CFLAGS="$(ADD_TO_CFLAGS)"
+	$(MAKE) -j$(NUM_CPUS) -C $(SDK)/systems/bde/linux/user/kernel kernel_version=$(kernel_version) OPT_CFLAGS="$(ADD_TO_CFLAGS)"
+
+# LVL7_FIXUP :
+# 1. Added $(MAKE) -C $(SDK)/systems/linux/user/common -f Makefile.fastpath CFLAGS="$(CFLAGS)"
+# 2. Remove $(MAKE) -C $(SDK)/systems/drv CFLAGS="$(CFLAGS)"
+user_libs:
+	$(MAKE) -j$(NUM_CPUS) -C $(SDK)/systems/linux/user/fastpath_common -f Makefile.fastpath CFLAGS="$(CFLAGS)"
+	$(MAKE) -j$(NUM_CPUS) -C $(SDK)/systems/bde/linux/user CFLAGS="$(CFLAGS)"
+	$(MAKE) -j$(NUM_CPUS) -C $(SDK)/src CFLAGS="$(ADD_TO_CFLAGS)"
+ifdef BUILD_MACSEC
+	@${ECHO} "Building MACSEC libraries ...."
+	$(MAKE) -j$(NUM_CPUS) -C ${MACSEC_HOME} MACSEC_CC="${CC}" MACSEC_LD="${LD}" MACSEC_AR="$(AR)" MACSEC_CFLAGS="${MACSEC_BUILD_FLAG}" MACSEC_TARGET="${targetbase}/${targetplat}/${platform}"
+endif
+	$(info SYSROOT=$(SYSROOT))
+ifdef BUILD_PHYMOD
+	@${ECHO} "Building PHYMOD libraries ...."
+	$(info "CFLAGS=$(CFLAGS)")
+	$(info "ADD_TO_CFLAGS=$(ADD_TO_CFLAGS)")
+	$(MAKE) -j$(NUM_CPUS) -C $(SDK)/libs/phymod CFLAGS="$(ADD_TO_CFLAGS)"
+endif
+
+# Broadcom Command Monitor
+
+# Build platform_defines.c to compile in config.bcm
+#
+ifndef NO_SAL_APPL
+PLATFORM_DEFINES_OBJ=${BLDDIR}/platform_defines.o
+${BLDDIR}/platform_defines.c: ${SDK}/rc/config.bcm
+	$(PERL) ${SDK}/tools/bcm2c_linux.pl ${SDK}/rc/config.bcm >$@
+${BLDDIR}/platform_defines.o: ${BLDDIR}/platform_defines.c
+	${CC} ${CFLAGS} -c $< -o $@
+else
+PLATFORM_DEFINES_OBJ=
+endif
+
+
+$(BCM): $(BCM).dbg
+	$(OBJCOPY) --strip-debug $< $@
+
+
+$(BCM).dbg: $(BLDDIR)/bdecreate.o $(BLDDIR)/version.o \
+	${PLATFORM_DEFINES_OBJ} $(BCM_LIBS_BLD) 
+	@rm -f $@	# Prevent core dump if currently running
+	$(CC) $(CFLAGS) -o $@ $(BLDDIR)/bdecreate.o $(BLDDIR)/version.o \
+	${PLATFORM_DEFINES_OBJ} $(BCM_LIBS_BLD) $(LDFLAGS)
+
+$(KERNEL_BDE): $(KERN_BLDROOT)/linux-kernel-bde.$(KOBJ)
+ifdef LVL7_FIXUP
+	$(entry_msg)
+endif
+	$(OBJCOPY) --strip-debug $< $@
+
+$(USER_BDE): $(KERN_BLDROOT)/linux-user-bde.$(KOBJ)
+ifdef LVL7_FIXUP
+	$(entry_msg)
+endif
+	$(OBJCOPY) --strip-debug $< $@
+
+$(NETSERVE): $(BLDDIR)/netserve.o
+	$(CC) $(CFLAGS) -o $@ $(BLDDIR)/netserve.o $(LDFLAGS) -lutil
+	$(OBJCOPY) --strip-debug $@
+
+
+
+
+# Build Version
+
+$(BLDDIR)/version.c: $(BLDDIR)/bdecreate.o $(BCM_LIBS_BLD)
+	$(PERL) $(SDK)/tools/version.pl > $@
+$(BLDDIR)/version.o: $(BLDDIR)/version.c
+	$(CC) $(CFLAGS) -c $< -o $@
+
+clean::
+	$(MAKE) -C $(SDK)/systems/bde/linux/kernel $@
+	$(MAKE) -C $(SDK)/systems/bde/linux/user/kernel $@
+	$(MAKE) -C $(SDK)/systems/bde/linux/user CFLAGS="$(CFLAGS)" $@
+	$(MAKE) -C $(SDK)/src CFLAGS="$(CFLAGS)" $@
+	$(RM) $(BLDDIR)/version.c $(BLDDIR)/version.o
+	$(RM) $(BLDDIR)/platform_defines.c $(BLDDIR)/platform_defines.o
+	$(RM) $(BLDDIR)/bdecreate.o
+	$(RM) $(KERNEL_BDE) $(USER_BDE) $(BCM) $(BCM).dbg
+	$(RM) $(BLDDIR)/netserve.o
+	$(RM) $(NETSERVE)
+
+distclean:: clean
+
+.PHONY: variable
+
+#
+# Echo variable values used for configuration
+# usage: make VAR=CC variable
+#
+variable::
+	@echo $($(VAR))
+
+# Make.config defines remaining phony targets
+.PHONY: build kernel_modules user_libs
+
+# Output the CFLAGS used by the SDK
+#
+ifdef LVL7_FIXUP
+.PHONY: get_sdk_flags
+
+get_sdk_flags::
+	@echo "CFLAGS_SDK := $(filter -D%,$(CFLAGS))" >$(L7_OUT_SDK_FLAGS)
+endif
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/user/fastpath_common/Makefile.fastpath esw_sdk_modified/systems/linux/user/fastpath_common/Makefile.fastpath
--- sdk-all-6.5.5/systems/linux/user/fastpath_common/Makefile.fastpath	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/user/fastpath_common/Makefile.fastpath	2018-01-26 11:20:30.238358520 +0000
@@ -0,0 +1,17 @@
+#$Id: Makefile,v 1.3.4.1 Broadcom SDK $
+# $Copyright: Copyright 2007, Broadcom Corporation All Rights Reserved.
+# THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES
+# OF ANY KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE.
+# BROADCOM SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.$
+#
+LOCALDIR = systems/linux/user/fastpath_common
+
+include ${SDK}/make/Make.config
+
+lib = liblusrcmmsys
+
+include ${SDK}/make/Make.lib
+
+include ${SDK}/make/Make.depend
+
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/user/TA12XG-e500-3_x/Makefile esw_sdk_modified/systems/linux/user/TA12XG-e500-3_x/Makefile
--- sdk-all-6.5.5/systems/linux/user/TA12XG-e500-3_x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/user/TA12XG-e500-3_x/Makefile	2018-01-26 11:20:30.246358520 +0000
@@ -0,0 +1,108 @@
+# -*- Makefile -*-
+# $Id: Makefile 1.9 Broadcom SDK $
+# $Copyright: Copyright 2012 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+#
+# This make job requires the following environment variables to be set:
+#
+# SDK                - path to StrataXGS SDK root directory
+#
+# Optionally the following environment variables can be set to
+# override the default build server configuration:
+#
+# PPC_TOOLS_DIR      - path to build tools (if not in PATH already)
+# PPC_CROSS_COMPILE  - cross compile tools prefix
+# LINUX_INCLUDE      - path to Linux kernel include directory
+#
+
+SDK :=$(shell if [ -n "$$SDK" ] ; then\
+	echo $$SDK;\
+	else\
+	cd $(dir $(lastword $(MAKEFILE_LIST))); while /usr/bin/test ! -e RELEASE ; do \
+	dir=`cd ../;pwd`;			\
+	if [ "$$dir" = "/" ] ; then		\
+	   echo Cannot find SDK in $(lastword $(MAKEFILE_LIST)) 1>&2;		\
+	   exit 1;				\
+	fi ;					\
+	cd $$dir;				\
+	done ;					\
+	pwd;					\
+	fi)
+
+ifeq ($(SDK),)					
+$(error Please run this in a tree)		
+endif 				
+
+export SDK
+
+override kernel_version=3_x
+platform=TA12XG-e500-$(kernel_version)
+LINUX_MAKE_USER=1
+export LINKER_RELAX=1
+
+# Select the build environment
+#BUILD_PLATFORM=ELDK
+BUILD_PLATFORM=WR_LINUX
+
+#Select the LINUX KERNEL VERSION
+#KERN_VER = 2.6.21.7
+#KERN_VER = 2.6.24.4
+KERN_VER = 3.8.13
+
+
+# Select the ELDK version
+#ELDK_VERSION=4.1
+#ELDK_VERSION=4.0
+
+#Select WRS Linux version
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=3.0
+
+
+export KERN_VER
+export ELDK_VERSION
+export BUILD_PLATFORM
+export WRS_LINUX_VERSION
+
+include ${SDK}/make/Make.linux
+
diff -rpN '--unified=6' sdk-all-6.5.5/systems/linux/user/TT08SXG-e500mc-3_x/Makefile esw_sdk_modified/systems/linux/user/TT08SXG-e500mc-3_x/Makefile
--- sdk-all-6.5.5/systems/linux/user/TT08SXG-e500mc-3_x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ esw_sdk_modified/systems/linux/user/TT08SXG-e500mc-3_x/Makefile	2018-01-26 11:20:30.222358520 +0000
@@ -0,0 +1,109 @@
+# -*- Makefile -*-
+# $Id: Makefile 1.9 Broadcom SDK $
+# $Copyright: Copyright 2012 Broadcom Corporation.
+# This program is the proprietary software of Broadcom Corporation
+# and/or its licensors, and may only be used, duplicated, modified
+# or distributed pursuant to the terms and conditions of a separate,
+# written license agreement executed between you and Broadcom
+# (an "Authorized License").  Except as set forth in an Authorized
+# License, Broadcom grants no license (express or implied), right
+# to use, or waiver of any kind with respect to the Software, and
+# Broadcom expressly reserves all rights in and to the Software
+# and all intellectual property rights therein.  IF YOU HAVE
+# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
+# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
+# ALL USE OF THE SOFTWARE.  
+#  
+# Except as expressly set forth in the Authorized License,
+#  
+# 1.     This program, including its structure, sequence and organization,
+# constitutes the valuable trade secrets of Broadcom, and you shall use
+# all reasonable efforts to protect the confidentiality thereof,
+# and to use this information only in connection with your use of
+# Broadcom integrated circuit products.
+#  
+# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
+# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
+# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
+# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
+# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
+# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
+# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
+# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+# 
+# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
+# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
+# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
+# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
+# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
+# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
+# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
+# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
+
+#
+# This make job requires the following environment variables to be set:
+#
+# SDK                - path to StrataXGS SDK root directory
+#
+# Optionally the following environment variables can be set to
+# override the default build server configuration:
+#
+# PPC_TOOLS_DIR      - path to build tools (if not in PATH already)
+# PPC_CROSS_COMPILE  - cross compile tools prefix
+# LINUX_INCLUDE      - path to Linux kernel include directory
+#
+
+SDK :=$(shell if [ -n "$$SDK" ] ; then\
+	echo $$SDK;\
+	else\
+	cd $(dir $(lastword $(MAKEFILE_LIST))); while /usr/bin/test ! -e RELEASE ; do \
+	dir=`cd ../;pwd`;			\
+	if [ "$$dir" = "/" ] ; then		\
+	   echo Cannot find SDK in $(lastword $(MAKEFILE_LIST)) 1>&2;		\
+	   exit 1;				\
+	fi ;					\
+	cd $$dir;				\
+	done ;					\
+	pwd;					\
+	fi)
+
+ifeq ($(SDK),)					
+$(error Please run this in a tree)		
+endif 				
+
+export SDK
+
+override kernel_version=3_x
+platform=TT08SXG-e500mc-$(kernel_version)
+LINUX_MAKE_USER=1
+export LINKER_RELAX=1
+
+# Select the build environment
+#BUILD_PLATFORM=ELDK
+BUILD_PLATFORM=WR_LINUX
+
+#Select the LINUX KERNEL VERSION
+#KERN_VER = 2.6.21.7
+#KERN_VER = 2.6.24.4
+#KERN_VER = 3.8.13
+KERN_VER=3.0.51
+
+
+# Select the ELDK version
+#ELDK_VERSION=4.1
+#ELDK_VERSION=4.0
+
+#Select WRS Linux version
+WRS_LINUX_VERSION=2.0
+#WRS_LINUX_VERSION=3.0
+
+
+export KERN_VER
+export ELDK_VERSION
+export BUILD_PLATFORM
+export WRS_LINUX_VERSION
+
+include ${SDK}/make/Make.linux
+
